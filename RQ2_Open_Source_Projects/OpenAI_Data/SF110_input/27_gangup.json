[
	{
		"original_code": "// Unpacker.java\n/* $Id: Unpacker.java,v 1.4 2004/04/27 19:26:22 bja Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Emil Lundstr�m <emill@kth.se>\n * @version: $Revision: 1.4 $\n *\n */\npackage util;\n\nimport state.*;\n\n/**\n * Packing class.\n */\npublic class Unpacker {\n\n    public static Packable unpack(int messagetype, byte[] data) throws PackingException {\n        return unpack(messagetype, data, -1);\n    }\n\n    public static Packable unpack(int messagetype, byte[] data, int actor) throws PackingException {\n        Packable p = null;\n        switch(messagetype) {\n            case Packable.TEXT_MESSAGE:\n                p = new TextMessage();\n                p.unpack(data);\n                if (actor != -1) {\n                    ((TextMessage) p).setActor(actor);\n                }\n                break;\n            case Packable.ACTION:\n                p = new Action();\n                p.unpack(data);\n                if (actor != -1) {\n                    ((Action) p).setActor(actor);\n                }\n                break;\n            case Packable.GAME_EVENT:\n                p = new GameEvent();\n                p.unpack(data);\n                break;\n            case Packable.GAME_STATE:\n                System.err.println(\"GAME STATE RECEIVED\");\n                p = new GameState();\n                p.unpack(data);\n                break;\n            case Packable.PLAYER:\n                System.err.println(\"PLAYER RECEIVED\");\n                p = new Player();\n                p.unpack(data);\n                break;\n            default:\n                throw new PackingException(\"Unknown message type: \" + messagetype);\n        }\n        return p;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/util/UnpackerTest0.java",
		"test_prompt": "// UnpackerTest0.java\npackage util;\n\nimport state.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Unpacker}.\n* It contains ten unit test cases for the {@link Unpacker#unpack(int, byte[])} method.\n*/\nclass UnpackerTest0 {"
	},
	{
		"original_code": "// Unpacker.java\n/* $Id: Unpacker.java,v 1.4 2004/04/27 19:26:22 bja Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Emil Lundstr�m <emill@kth.se>\n * @version: $Revision: 1.4 $\n *\n */\npackage util;\n\nimport state.*;\n\n/**\n * Packing class.\n */\npublic class Unpacker {\n\n    public static Packable unpack(int messagetype, byte[] data) throws PackingException {\n        return unpack(messagetype, data, -1);\n    }\n\n    public static Packable unpack(int messagetype, byte[] data, int actor) throws PackingException {\n        Packable p = null;\n        switch(messagetype) {\n            case Packable.TEXT_MESSAGE:\n                p = new TextMessage();\n                p.unpack(data);\n                if (actor != -1) {\n                    ((TextMessage) p).setActor(actor);\n                }\n                break;\n            case Packable.ACTION:\n                p = new Action();\n                p.unpack(data);\n                if (actor != -1) {\n                    ((Action) p).setActor(actor);\n                }\n                break;\n            case Packable.GAME_EVENT:\n                p = new GameEvent();\n                p.unpack(data);\n                break;\n            case Packable.GAME_STATE:\n                System.err.println(\"GAME STATE RECEIVED\");\n                p = new GameState();\n                p.unpack(data);\n                break;\n            case Packable.PLAYER:\n                System.err.println(\"PLAYER RECEIVED\");\n                p = new Player();\n                p.unpack(data);\n                break;\n            default:\n                throw new PackingException(\"Unknown message type: \" + messagetype);\n        }\n        return p;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/util/UnpackerTest1.java",
		"test_prompt": "// UnpackerTest1.java\npackage util;\n\nimport state.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Unpacker}.\n* It contains ten unit test cases for the {@link Unpacker#unpack(int, byte[], int)} method.\n*/\nclass UnpackerTest1 {"
	},
	{
		"original_code": "// AbstractFactory.java\n/* $Id: AbstractFactory.java,v 1.2 2004/04/27 19:26:22 bja Exp $ \n *\n * @author Joel Andersson <bja@kth.se>\n * @version $Revision: 1.2 $\n */\npackage util;\n\nimport java.util.Stack;\n\n//import java.util.LinkedList;\n/**\n * This class provides a generic interface for creating and managing\n * objects. The factory produces and manages objects derived from\n * {@link util.ManagedObject}. The ref and unref methods are used to\n * keep track of the number of referencing objects, when this number\n * reaches zero (no referencing object) the object calls the unrefObject\n * method of its associated manager.\n *\n * Note: currently a produced object is never freed, which means that if\n * you create many new objects under some time, but normally only use a\n * fraction of that, then there will be a large number of vasted objects.\n * A possible solution to this is to trim the stoch from time to time.\n */\npublic abstract class AbstractFactory<E extends ManagedObject> implements ObjectManager<E> {\n\n    /**\n     * The prototype associated with this Factory.\n     */\n    protected E prototype = null;\n\n    /**\n     * The collection of unused (available) Messages.\n     */\n    protected Stack<E> stock = null;\n\n    //protected LinkedList<E> stock = null;\n    /**\n     * The total number of objects produced by this factory.\n     */\n    protected int totalObjectsProduced = 0;\n\n    /**\n     * Creates a new instance of the MessageFactory class.\n     * @param prototype The prototype of this factory.\n     */\n    protected AbstractFactory(E prototype) {\n        this.stock = new Stack<E>();\n        //this.stock = new LinkedList<E>();\n        this.prototype = prototype;\n        this.prototype.setManager(this);\n    }\n\n    /**\n     * Get a reference to an unused ManagedObject instance. The object's\n     * reference count is increased to one.\n     *\n     * @return a reference to an unused object instance.\n     */\n    public synchronized E createObject() {\n        E obj = stock.size() == 0 ? (E) produceObject() : stock.pop();\n        obj.ref();\n        System.err.println(\"+\" + obj.hashCode());\n        return obj;\n    }\n\n    /**\n     * Adds the specified object to the list of unused objects.\n     * @param obj the object that is to be added.\n     */\n    public synchronized void unrefObject(E obj) {\n        stock.push(obj);\n        System.err.println(\"-\" + obj.hashCode());\n    }\n\n    /**\n     * Returns the current number of unused (i.e. available) objects.\n     * @return the current number of unused (i.e. available) objects.\n     */\n    public synchronized int getStockCount() {\n        return stock.size();\n    }\n\n    /**\n     * Returns the total number of produced objects, i.e. the number of\n     * new instances of the prototype that created.\n     *\n     * @return the total number of prototype instances created.\n     */\n    public int getTotalProduced() {\n        return totalObjectsProduced;\n    }\n\n    /**\n     * Produces and returns a new object based on this factory's prototype.\n     * @return a new instance of the prototype object.\n     */\n    protected E produceObject() {\n        totalObjectsProduced++;\n        return (E) prototype.clone();\n    }\n\n    /**\n     * Produces the given number of objects of this factory's prototype\n     * and adds them to the stock.\n     *\n     * @param count the number of objects to produce.\n     */\n    protected synchronized void produceObjects(int count) {\n        for (int i = 0; i < count; i++) {\n            stock.push((E) prototype.clone());\n        }\n        totalObjectsProduced += count;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/util/AbstractFactoryTest.java",
		"test_prompt": "// AbstractFactoryTest.java\npackage util;\n\nimport java.util.Stack;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractFactory}.\n* It contains ten unit test cases for the {@link AbstractFactory#createObject()} method.\n*/\nclass AbstractFactoryTest {"
	},
	{
		"original_code": "// Packer.java\n/* $Id: Packer.java,v 1.3 2004/04/27 19:26:22 bja Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.3 $\n *\n */\npackage util;\n\n/**\n * This class provides a set of functions for converting data types from\n * their normal representation to byte arrays.\n */\npublic class Packer {\n\n    /**\n     * Packs n shorts of the short array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack16v(short[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 2) {\n            pack16(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n shorts of the byte array b into the specified short array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack16v(byte[] b, int s, short[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 2) {\n            v[d + i] = unpack16(b, s);\n        }\n    }\n\n    public static void pack16(short x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static short unpack16(byte[] b, int offset) {\n        short y = 0;\n        y |= ((short) b[offset++] & 0xff) << 8;\n        y |= ((short) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack16(short x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 8) & 0xff);\n        b[1] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static short unpack16(byte[] b) {\n        short y = 0;\n        y |= ((short) b[0] & 0xff) << 8;\n        y |= ((short) b[1] & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n integers of the integer array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack32v(int[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 4) {\n            pack32(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n integers of the byte array b into the specified integer\n     * array v, starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack32v(byte[] b, int s, int[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 4) {\n            v[d + i] = unpack32(b, s);\n        }\n    }\n\n    public static void pack32(int x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static int unpack32(byte[] b, int offset) {\n        int y = 0;\n        y |= ((int) b[offset++] & 0xff) << 24;\n        y |= ((int) b[offset++] & 0xff) << 16;\n        y |= ((int) b[offset++] & 0xff) << 8;\n        y |= ((int) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack32(int x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 24) & 0xff);\n        b[1] = (byte) ((x >> 16) & 0xff);\n        b[2] = (byte) ((x >> 8) & 0xff);\n        b[3] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static int unpack32(byte[] b) {\n        int y = 0;\n        y |= ((int) (b[0]) & 0xff) << 24;\n        y |= ((int) (b[1]) & 0xff) << 16;\n        y |= ((int) (b[2]) & 0xff) << 8;\n        y |= ((int) (b[3]) & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n longs in the long array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack64v(long[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 8) {\n            pack64(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n longs of the byte array b into the specified long array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack64v(byte[] b, int s, long[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 8) {\n            v[d + i] = unpack64(b, s);\n        }\n    }\n\n    public static void pack64(long x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 56) & 0xff);\n        b[offset++] = (byte) ((x >> 48) & 0xff);\n        b[offset++] = (byte) ((x >> 40) & 0xff);\n        b[offset++] = (byte) ((x >> 32) & 0xff);\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static long unpack64(byte[] b, int offset) {\n        long y = 0;\n        y |= ((long) b[offset++] & 0xff) << 56;\n        y |= ((long) b[offset++] & 0xff) << 48;\n        y |= ((long) b[offset++] & 0xff) << 40;\n        y |= ((long) b[offset++] & 0xff) << 32;\n        y |= ((long) b[offset++] & 0xff) << 24;\n        y |= ((long) b[offset++] & 0xff) << 16;\n        y |= ((long) b[offset++] & 0xff) << 8;\n        y |= ((long) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack64(long x) {\n        byte[] b = new byte[8];\n        b[0] = (byte) ((x >> 56) & 0xff);\n        b[1] = (byte) ((x >> 48) & 0xff);\n        b[2] = (byte) ((x >> 40) & 0xff);\n        b[3] = (byte) ((x >> 32) & 0xff);\n        b[4] = (byte) ((x >> 24) & 0xff);\n        b[5] = (byte) ((x >> 16) & 0xff);\n        b[6] = (byte) ((x >> 8) & 0xff);\n        b[7] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static long unpack64(byte[] b) {\n        long y = 0;\n        y |= ((long) b[0] & 0xff) << 56;\n        y |= ((long) b[1] & 0xff) << 48;\n        y |= ((long) b[2] & 0xff) << 40;\n        y |= ((long) b[3] & 0xff) << 32;\n        y |= ((long) b[4] & 0xff) << 24;\n        y |= ((long) b[5] & 0xff) << 16;\n        y |= ((long) b[6] & 0xff) << 8;\n        y |= ((long) b[7] & 0xff);\n        return y;\n    }\n\n    /**\n     * Converts the specified float to four bytes.\n     * @param f the float array that is to be packed as a bytes.\n     */\n    public static byte[] packf(float f) {\n        return pack32(Float.floatToIntBits(f));\n    }\n\n    /**\n     * Converts the specified float array to an array of bytes.\n     * @param fv the float array that is to be packed as a byte array.\n     * @param start the offset in fv from which to start packing.\n     * @param count the number of floats to pack.\n     */\n    public static byte[] packfv(float[] fv, int start, int count) {\n        byte[] buf = new byte[count << 4];\n        count += start;\n        for (int i = start, j = 0; i < count; i++, j += 4) {\n            pack32(Float.floatToIntBits(fv[i]), buf, j);\n        }\n        return buf;\n    }\n\n    /**\n     * Converts the specified byte vector to an float.\n     * @param b the byte data that is to be unpacked as a float.\n     */\n    public static float unpackf(byte[] b) {\n        return Float.intBitsToFloat(unpack32(b));\n    }\n\n    /**\n     * Converts the specified integer to a byte vector.\n     * @param i the integer that is to be packed.\n     */\n    public static byte[] packi(int i) {\n        return pack32(i);\n    }\n\n    /**\n     * Converts the specified byte vector to an integer.\n     * @param b the byte data that is to be unpacked as an integer.\n     */\n    public static int unpacki(byte[] b) {\n        return unpack32(b);\n    }\n\n    /**\n     * Converts the specified long to a byte vector.\n     * @param l the long that is to be packed.\n     */\n    public static byte[] packl(long l) {\n        return pack64(l);\n    }\n\n    /**\n     * Converts the specified byte vector to a long.\n     * @param b the byte data that is to be unpacked as a long.\n     */\n    public static long unpackl(byte[] b) {\n        return unpack64(b);\n    }\n\n    /**\n     * Converts the specified double to a byte vector.\n     * @param d the double that is to be packed.\n     */\n    public static byte[] packd(double d) {\n        return pack64(Double.doubleToRawLongBits(d));\n    }\n\n    /**\n     * Converts the specified byte vector to an double.\n     * @param b the byte data that is to be unpacked as an double.\n     */\n    public static double unpackd(byte[] b) {\n        return Double.longBitsToDouble(unpack64(b));\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     * @param b the byte vector to put result in.\n     * @param offset the offset at which to put result.\n     */\n    public static void packs(String s, byte[] b, int offset) {\n        byte[] p = packs(s);\n        System.arraycopy(p, 0, b, offset, p.length);\n    }\n\n    /**\n     * Converts the specified byte vector to a string.\n     * @param b the byte vector containing the packed string.\n     * @param offset the offset at which to start unpacking.\n     * @param length the number of bytes to convert.\n     */\n    public static String unpacks(byte[] b, int offset, int length) {\n        try {\n            return new String(b, offset, length, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     */\n    public static byte[] packs(String s) {\n        try {\n            return s.getBytes(\"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified byte vector to a String.\n     * @param data the byte data that is to be unpacked as a String.\n     */\n    public static String unpacks(byte[] b) {\n        try {\n            return new String(b, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/util/PackerTest0.java",
		"test_prompt": "// PackerTest0.java\npackage util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Packer}.\n* It contains ten unit test cases for the {@link Packer#unpack16(byte[], int)} method.\n*/\nclass PackerTest0 {"
	},
	{
		"original_code": "// Packer.java\n/* $Id: Packer.java,v 1.3 2004/04/27 19:26:22 bja Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.3 $\n *\n */\npackage util;\n\n/**\n * This class provides a set of functions for converting data types from\n * their normal representation to byte arrays.\n */\npublic class Packer {\n\n    /**\n     * Packs n shorts of the short array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack16v(short[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 2) {\n            pack16(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n shorts of the byte array b into the specified short array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack16v(byte[] b, int s, short[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 2) {\n            v[d + i] = unpack16(b, s);\n        }\n    }\n\n    public static void pack16(short x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static short unpack16(byte[] b, int offset) {\n        short y = 0;\n        y |= ((short) b[offset++] & 0xff) << 8;\n        y |= ((short) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack16(short x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 8) & 0xff);\n        b[1] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static short unpack16(byte[] b) {\n        short y = 0;\n        y |= ((short) b[0] & 0xff) << 8;\n        y |= ((short) b[1] & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n integers of the integer array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack32v(int[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 4) {\n            pack32(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n integers of the byte array b into the specified integer\n     * array v, starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack32v(byte[] b, int s, int[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 4) {\n            v[d + i] = unpack32(b, s);\n        }\n    }\n\n    public static void pack32(int x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static int unpack32(byte[] b, int offset) {\n        int y = 0;\n        y |= ((int) b[offset++] & 0xff) << 24;\n        y |= ((int) b[offset++] & 0xff) << 16;\n        y |= ((int) b[offset++] & 0xff) << 8;\n        y |= ((int) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack32(int x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 24) & 0xff);\n        b[1] = (byte) ((x >> 16) & 0xff);\n        b[2] = (byte) ((x >> 8) & 0xff);\n        b[3] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static int unpack32(byte[] b) {\n        int y = 0;\n        y |= ((int) (b[0]) & 0xff) << 24;\n        y |= ((int) (b[1]) & 0xff) << 16;\n        y |= ((int) (b[2]) & 0xff) << 8;\n        y |= ((int) (b[3]) & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n longs in the long array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack64v(long[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 8) {\n            pack64(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n longs of the byte array b into the specified long array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack64v(byte[] b, int s, long[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 8) {\n            v[d + i] = unpack64(b, s);\n        }\n    }\n\n    public static void pack64(long x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 56) & 0xff);\n        b[offset++] = (byte) ((x >> 48) & 0xff);\n        b[offset++] = (byte) ((x >> 40) & 0xff);\n        b[offset++] = (byte) ((x >> 32) & 0xff);\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static long unpack64(byte[] b, int offset) {\n        long y = 0;\n        y |= ((long) b[offset++] & 0xff) << 56;\n        y |= ((long) b[offset++] & 0xff) << 48;\n        y |= ((long) b[offset++] & 0xff) << 40;\n        y |= ((long) b[offset++] & 0xff) << 32;\n        y |= ((long) b[offset++] & 0xff) << 24;\n        y |= ((long) b[offset++] & 0xff) << 16;\n        y |= ((long) b[offset++] & 0xff) << 8;\n        y |= ((long) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack64(long x) {\n        byte[] b = new byte[8];\n        b[0] = (byte) ((x >> 56) & 0xff);\n        b[1] = (byte) ((x >> 48) & 0xff);\n        b[2] = (byte) ((x >> 40) & 0xff);\n        b[3] = (byte) ((x >> 32) & 0xff);\n        b[4] = (byte) ((x >> 24) & 0xff);\n        b[5] = (byte) ((x >> 16) & 0xff);\n        b[6] = (byte) ((x >> 8) & 0xff);\n        b[7] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static long unpack64(byte[] b) {\n        long y = 0;\n        y |= ((long) b[0] & 0xff) << 56;\n        y |= ((long) b[1] & 0xff) << 48;\n        y |= ((long) b[2] & 0xff) << 40;\n        y |= ((long) b[3] & 0xff) << 32;\n        y |= ((long) b[4] & 0xff) << 24;\n        y |= ((long) b[5] & 0xff) << 16;\n        y |= ((long) b[6] & 0xff) << 8;\n        y |= ((long) b[7] & 0xff);\n        return y;\n    }\n\n    /**\n     * Converts the specified float to four bytes.\n     * @param f the float array that is to be packed as a bytes.\n     */\n    public static byte[] packf(float f) {\n        return pack32(Float.floatToIntBits(f));\n    }\n\n    /**\n     * Converts the specified float array to an array of bytes.\n     * @param fv the float array that is to be packed as a byte array.\n     * @param start the offset in fv from which to start packing.\n     * @param count the number of floats to pack.\n     */\n    public static byte[] packfv(float[] fv, int start, int count) {\n        byte[] buf = new byte[count << 4];\n        count += start;\n        for (int i = start, j = 0; i < count; i++, j += 4) {\n            pack32(Float.floatToIntBits(fv[i]), buf, j);\n        }\n        return buf;\n    }\n\n    /**\n     * Converts the specified byte vector to an float.\n     * @param b the byte data that is to be unpacked as a float.\n     */\n    public static float unpackf(byte[] b) {\n        return Float.intBitsToFloat(unpack32(b));\n    }\n\n    /**\n     * Converts the specified integer to a byte vector.\n     * @param i the integer that is to be packed.\n     */\n    public static byte[] packi(int i) {\n        return pack32(i);\n    }\n\n    /**\n     * Converts the specified byte vector to an integer.\n     * @param b the byte data that is to be unpacked as an integer.\n     */\n    public static int unpacki(byte[] b) {\n        return unpack32(b);\n    }\n\n    /**\n     * Converts the specified long to a byte vector.\n     * @param l the long that is to be packed.\n     */\n    public static byte[] packl(long l) {\n        return pack64(l);\n    }\n\n    /**\n     * Converts the specified byte vector to a long.\n     * @param b the byte data that is to be unpacked as a long.\n     */\n    public static long unpackl(byte[] b) {\n        return unpack64(b);\n    }\n\n    /**\n     * Converts the specified double to a byte vector.\n     * @param d the double that is to be packed.\n     */\n    public static byte[] packd(double d) {\n        return pack64(Double.doubleToRawLongBits(d));\n    }\n\n    /**\n     * Converts the specified byte vector to an double.\n     * @param b the byte data that is to be unpacked as an double.\n     */\n    public static double unpackd(byte[] b) {\n        return Double.longBitsToDouble(unpack64(b));\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     * @param b the byte vector to put result in.\n     * @param offset the offset at which to put result.\n     */\n    public static void packs(String s, byte[] b, int offset) {\n        byte[] p = packs(s);\n        System.arraycopy(p, 0, b, offset, p.length);\n    }\n\n    /**\n     * Converts the specified byte vector to a string.\n     * @param b the byte vector containing the packed string.\n     * @param offset the offset at which to start unpacking.\n     * @param length the number of bytes to convert.\n     */\n    public static String unpacks(byte[] b, int offset, int length) {\n        try {\n            return new String(b, offset, length, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     */\n    public static byte[] packs(String s) {\n        try {\n            return s.getBytes(\"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified byte vector to a String.\n     * @param data the byte data that is to be unpacked as a String.\n     */\n    public static String unpacks(byte[] b) {\n        try {\n            return new String(b, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/util/PackerTest1.java",
		"test_prompt": "// PackerTest1.java\npackage util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Packer}.\n* It contains ten unit test cases for the {@link Packer#pack16(short)} method.\n*/\nclass PackerTest1 {"
	},
	{
		"original_code": "// Packer.java\n/* $Id: Packer.java,v 1.3 2004/04/27 19:26:22 bja Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.3 $\n *\n */\npackage util;\n\n/**\n * This class provides a set of functions for converting data types from\n * their normal representation to byte arrays.\n */\npublic class Packer {\n\n    /**\n     * Packs n shorts of the short array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack16v(short[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 2) {\n            pack16(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n shorts of the byte array b into the specified short array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack16v(byte[] b, int s, short[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 2) {\n            v[d + i] = unpack16(b, s);\n        }\n    }\n\n    public static void pack16(short x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static short unpack16(byte[] b, int offset) {\n        short y = 0;\n        y |= ((short) b[offset++] & 0xff) << 8;\n        y |= ((short) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack16(short x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 8) & 0xff);\n        b[1] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static short unpack16(byte[] b) {\n        short y = 0;\n        y |= ((short) b[0] & 0xff) << 8;\n        y |= ((short) b[1] & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n integers of the integer array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack32v(int[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 4) {\n            pack32(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n integers of the byte array b into the specified integer\n     * array v, starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack32v(byte[] b, int s, int[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 4) {\n            v[d + i] = unpack32(b, s);\n        }\n    }\n\n    public static void pack32(int x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static int unpack32(byte[] b, int offset) {\n        int y = 0;\n        y |= ((int) b[offset++] & 0xff) << 24;\n        y |= ((int) b[offset++] & 0xff) << 16;\n        y |= ((int) b[offset++] & 0xff) << 8;\n        y |= ((int) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack32(int x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 24) & 0xff);\n        b[1] = (byte) ((x >> 16) & 0xff);\n        b[2] = (byte) ((x >> 8) & 0xff);\n        b[3] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static int unpack32(byte[] b) {\n        int y = 0;\n        y |= ((int) (b[0]) & 0xff) << 24;\n        y |= ((int) (b[1]) & 0xff) << 16;\n        y |= ((int) (b[2]) & 0xff) << 8;\n        y |= ((int) (b[3]) & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n longs in the long array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack64v(long[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 8) {\n            pack64(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n longs of the byte array b into the specified long array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack64v(byte[] b, int s, long[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 8) {\n            v[d + i] = unpack64(b, s);\n        }\n    }\n\n    public static void pack64(long x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 56) & 0xff);\n        b[offset++] = (byte) ((x >> 48) & 0xff);\n        b[offset++] = (byte) ((x >> 40) & 0xff);\n        b[offset++] = (byte) ((x >> 32) & 0xff);\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static long unpack64(byte[] b, int offset) {\n        long y = 0;\n        y |= ((long) b[offset++] & 0xff) << 56;\n        y |= ((long) b[offset++] & 0xff) << 48;\n        y |= ((long) b[offset++] & 0xff) << 40;\n        y |= ((long) b[offset++] & 0xff) << 32;\n        y |= ((long) b[offset++] & 0xff) << 24;\n        y |= ((long) b[offset++] & 0xff) << 16;\n        y |= ((long) b[offset++] & 0xff) << 8;\n        y |= ((long) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack64(long x) {\n        byte[] b = new byte[8];\n        b[0] = (byte) ((x >> 56) & 0xff);\n        b[1] = (byte) ((x >> 48) & 0xff);\n        b[2] = (byte) ((x >> 40) & 0xff);\n        b[3] = (byte) ((x >> 32) & 0xff);\n        b[4] = (byte) ((x >> 24) & 0xff);\n        b[5] = (byte) ((x >> 16) & 0xff);\n        b[6] = (byte) ((x >> 8) & 0xff);\n        b[7] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static long unpack64(byte[] b) {\n        long y = 0;\n        y |= ((long) b[0] & 0xff) << 56;\n        y |= ((long) b[1] & 0xff) << 48;\n        y |= ((long) b[2] & 0xff) << 40;\n        y |= ((long) b[3] & 0xff) << 32;\n        y |= ((long) b[4] & 0xff) << 24;\n        y |= ((long) b[5] & 0xff) << 16;\n        y |= ((long) b[6] & 0xff) << 8;\n        y |= ((long) b[7] & 0xff);\n        return y;\n    }\n\n    /**\n     * Converts the specified float to four bytes.\n     * @param f the float array that is to be packed as a bytes.\n     */\n    public static byte[] packf(float f) {\n        return pack32(Float.floatToIntBits(f));\n    }\n\n    /**\n     * Converts the specified float array to an array of bytes.\n     * @param fv the float array that is to be packed as a byte array.\n     * @param start the offset in fv from which to start packing.\n     * @param count the number of floats to pack.\n     */\n    public static byte[] packfv(float[] fv, int start, int count) {\n        byte[] buf = new byte[count << 4];\n        count += start;\n        for (int i = start, j = 0; i < count; i++, j += 4) {\n            pack32(Float.floatToIntBits(fv[i]), buf, j);\n        }\n        return buf;\n    }\n\n    /**\n     * Converts the specified byte vector to an float.\n     * @param b the byte data that is to be unpacked as a float.\n     */\n    public static float unpackf(byte[] b) {\n        return Float.intBitsToFloat(unpack32(b));\n    }\n\n    /**\n     * Converts the specified integer to a byte vector.\n     * @param i the integer that is to be packed.\n     */\n    public static byte[] packi(int i) {\n        return pack32(i);\n    }\n\n    /**\n     * Converts the specified byte vector to an integer.\n     * @param b the byte data that is to be unpacked as an integer.\n     */\n    public static int unpacki(byte[] b) {\n        return unpack32(b);\n    }\n\n    /**\n     * Converts the specified long to a byte vector.\n     * @param l the long that is to be packed.\n     */\n    public static byte[] packl(long l) {\n        return pack64(l);\n    }\n\n    /**\n     * Converts the specified byte vector to a long.\n     * @param b the byte data that is to be unpacked as a long.\n     */\n    public static long unpackl(byte[] b) {\n        return unpack64(b);\n    }\n\n    /**\n     * Converts the specified double to a byte vector.\n     * @param d the double that is to be packed.\n     */\n    public static byte[] packd(double d) {\n        return pack64(Double.doubleToRawLongBits(d));\n    }\n\n    /**\n     * Converts the specified byte vector to an double.\n     * @param b the byte data that is to be unpacked as an double.\n     */\n    public static double unpackd(byte[] b) {\n        return Double.longBitsToDouble(unpack64(b));\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     * @param b the byte vector to put result in.\n     * @param offset the offset at which to put result.\n     */\n    public static void packs(String s, byte[] b, int offset) {\n        byte[] p = packs(s);\n        System.arraycopy(p, 0, b, offset, p.length);\n    }\n\n    /**\n     * Converts the specified byte vector to a string.\n     * @param b the byte vector containing the packed string.\n     * @param offset the offset at which to start unpacking.\n     * @param length the number of bytes to convert.\n     */\n    public static String unpacks(byte[] b, int offset, int length) {\n        try {\n            return new String(b, offset, length, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     */\n    public static byte[] packs(String s) {\n        try {\n            return s.getBytes(\"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified byte vector to a String.\n     * @param data the byte data that is to be unpacked as a String.\n     */\n    public static String unpacks(byte[] b) {\n        try {\n            return new String(b, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/util/PackerTest2.java",
		"test_prompt": "// PackerTest2.java\npackage util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Packer}.\n* It contains ten unit test cases for the {@link Packer#unpack16(byte[])} method.\n*/\nclass PackerTest2 {"
	},
	{
		"original_code": "// Packer.java\n/* $Id: Packer.java,v 1.3 2004/04/27 19:26:22 bja Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.3 $\n *\n */\npackage util;\n\n/**\n * This class provides a set of functions for converting data types from\n * their normal representation to byte arrays.\n */\npublic class Packer {\n\n    /**\n     * Packs n shorts of the short array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack16v(short[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 2) {\n            pack16(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n shorts of the byte array b into the specified short array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack16v(byte[] b, int s, short[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 2) {\n            v[d + i] = unpack16(b, s);\n        }\n    }\n\n    public static void pack16(short x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static short unpack16(byte[] b, int offset) {\n        short y = 0;\n        y |= ((short) b[offset++] & 0xff) << 8;\n        y |= ((short) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack16(short x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 8) & 0xff);\n        b[1] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static short unpack16(byte[] b) {\n        short y = 0;\n        y |= ((short) b[0] & 0xff) << 8;\n        y |= ((short) b[1] & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n integers of the integer array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack32v(int[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 4) {\n            pack32(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n integers of the byte array b into the specified integer\n     * array v, starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack32v(byte[] b, int s, int[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 4) {\n            v[d + i] = unpack32(b, s);\n        }\n    }\n\n    public static void pack32(int x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static int unpack32(byte[] b, int offset) {\n        int y = 0;\n        y |= ((int) b[offset++] & 0xff) << 24;\n        y |= ((int) b[offset++] & 0xff) << 16;\n        y |= ((int) b[offset++] & 0xff) << 8;\n        y |= ((int) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack32(int x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 24) & 0xff);\n        b[1] = (byte) ((x >> 16) & 0xff);\n        b[2] = (byte) ((x >> 8) & 0xff);\n        b[3] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static int unpack32(byte[] b) {\n        int y = 0;\n        y |= ((int) (b[0]) & 0xff) << 24;\n        y |= ((int) (b[1]) & 0xff) << 16;\n        y |= ((int) (b[2]) & 0xff) << 8;\n        y |= ((int) (b[3]) & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n longs in the long array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack64v(long[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 8) {\n            pack64(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n longs of the byte array b into the specified long array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack64v(byte[] b, int s, long[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 8) {\n            v[d + i] = unpack64(b, s);\n        }\n    }\n\n    public static void pack64(long x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 56) & 0xff);\n        b[offset++] = (byte) ((x >> 48) & 0xff);\n        b[offset++] = (byte) ((x >> 40) & 0xff);\n        b[offset++] = (byte) ((x >> 32) & 0xff);\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static long unpack64(byte[] b, int offset) {\n        long y = 0;\n        y |= ((long) b[offset++] & 0xff) << 56;\n        y |= ((long) b[offset++] & 0xff) << 48;\n        y |= ((long) b[offset++] & 0xff) << 40;\n        y |= ((long) b[offset++] & 0xff) << 32;\n        y |= ((long) b[offset++] & 0xff) << 24;\n        y |= ((long) b[offset++] & 0xff) << 16;\n        y |= ((long) b[offset++] & 0xff) << 8;\n        y |= ((long) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack64(long x) {\n        byte[] b = new byte[8];\n        b[0] = (byte) ((x >> 56) & 0xff);\n        b[1] = (byte) ((x >> 48) & 0xff);\n        b[2] = (byte) ((x >> 40) & 0xff);\n        b[3] = (byte) ((x >> 32) & 0xff);\n        b[4] = (byte) ((x >> 24) & 0xff);\n        b[5] = (byte) ((x >> 16) & 0xff);\n        b[6] = (byte) ((x >> 8) & 0xff);\n        b[7] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static long unpack64(byte[] b) {\n        long y = 0;\n        y |= ((long) b[0] & 0xff) << 56;\n        y |= ((long) b[1] & 0xff) << 48;\n        y |= ((long) b[2] & 0xff) << 40;\n        y |= ((long) b[3] & 0xff) << 32;\n        y |= ((long) b[4] & 0xff) << 24;\n        y |= ((long) b[5] & 0xff) << 16;\n        y |= ((long) b[6] & 0xff) << 8;\n        y |= ((long) b[7] & 0xff);\n        return y;\n    }\n\n    /**\n     * Converts the specified float to four bytes.\n     * @param f the float array that is to be packed as a bytes.\n     */\n    public static byte[] packf(float f) {\n        return pack32(Float.floatToIntBits(f));\n    }\n\n    /**\n     * Converts the specified float array to an array of bytes.\n     * @param fv the float array that is to be packed as a byte array.\n     * @param start the offset in fv from which to start packing.\n     * @param count the number of floats to pack.\n     */\n    public static byte[] packfv(float[] fv, int start, int count) {\n        byte[] buf = new byte[count << 4];\n        count += start;\n        for (int i = start, j = 0; i < count; i++, j += 4) {\n            pack32(Float.floatToIntBits(fv[i]), buf, j);\n        }\n        return buf;\n    }\n\n    /**\n     * Converts the specified byte vector to an float.\n     * @param b the byte data that is to be unpacked as a float.\n     */\n    public static float unpackf(byte[] b) {\n        return Float.intBitsToFloat(unpack32(b));\n    }\n\n    /**\n     * Converts the specified integer to a byte vector.\n     * @param i the integer that is to be packed.\n     */\n    public static byte[] packi(int i) {\n        return pack32(i);\n    }\n\n    /**\n     * Converts the specified byte vector to an integer.\n     * @param b the byte data that is to be unpacked as an integer.\n     */\n    public static int unpacki(byte[] b) {\n        return unpack32(b);\n    }\n\n    /**\n     * Converts the specified long to a byte vector.\n     * @param l the long that is to be packed.\n     */\n    public static byte[] packl(long l) {\n        return pack64(l);\n    }\n\n    /**\n     * Converts the specified byte vector to a long.\n     * @param b the byte data that is to be unpacked as a long.\n     */\n    public static long unpackl(byte[] b) {\n        return unpack64(b);\n    }\n\n    /**\n     * Converts the specified double to a byte vector.\n     * @param d the double that is to be packed.\n     */\n    public static byte[] packd(double d) {\n        return pack64(Double.doubleToRawLongBits(d));\n    }\n\n    /**\n     * Converts the specified byte vector to an double.\n     * @param b the byte data that is to be unpacked as an double.\n     */\n    public static double unpackd(byte[] b) {\n        return Double.longBitsToDouble(unpack64(b));\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     * @param b the byte vector to put result in.\n     * @param offset the offset at which to put result.\n     */\n    public static void packs(String s, byte[] b, int offset) {\n        byte[] p = packs(s);\n        System.arraycopy(p, 0, b, offset, p.length);\n    }\n\n    /**\n     * Converts the specified byte vector to a string.\n     * @param b the byte vector containing the packed string.\n     * @param offset the offset at which to start unpacking.\n     * @param length the number of bytes to convert.\n     */\n    public static String unpacks(byte[] b, int offset, int length) {\n        try {\n            return new String(b, offset, length, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     */\n    public static byte[] packs(String s) {\n        try {\n            return s.getBytes(\"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified byte vector to a String.\n     * @param data the byte data that is to be unpacked as a String.\n     */\n    public static String unpacks(byte[] b) {\n        try {\n            return new String(b, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/util/PackerTest3.java",
		"test_prompt": "// PackerTest3.java\npackage util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Packer}.\n* It contains ten unit test cases for the {@link Packer#unpack32(byte[], int)} method.\n*/\nclass PackerTest3 {"
	},
	{
		"original_code": "// Packer.java\n/* $Id: Packer.java,v 1.3 2004/04/27 19:26:22 bja Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.3 $\n *\n */\npackage util;\n\n/**\n * This class provides a set of functions for converting data types from\n * their normal representation to byte arrays.\n */\npublic class Packer {\n\n    /**\n     * Packs n shorts of the short array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack16v(short[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 2) {\n            pack16(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n shorts of the byte array b into the specified short array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack16v(byte[] b, int s, short[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 2) {\n            v[d + i] = unpack16(b, s);\n        }\n    }\n\n    public static void pack16(short x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static short unpack16(byte[] b, int offset) {\n        short y = 0;\n        y |= ((short) b[offset++] & 0xff) << 8;\n        y |= ((short) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack16(short x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 8) & 0xff);\n        b[1] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static short unpack16(byte[] b) {\n        short y = 0;\n        y |= ((short) b[0] & 0xff) << 8;\n        y |= ((short) b[1] & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n integers of the integer array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack32v(int[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 4) {\n            pack32(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n integers of the byte array b into the specified integer\n     * array v, starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack32v(byte[] b, int s, int[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 4) {\n            v[d + i] = unpack32(b, s);\n        }\n    }\n\n    public static void pack32(int x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static int unpack32(byte[] b, int offset) {\n        int y = 0;\n        y |= ((int) b[offset++] & 0xff) << 24;\n        y |= ((int) b[offset++] & 0xff) << 16;\n        y |= ((int) b[offset++] & 0xff) << 8;\n        y |= ((int) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack32(int x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 24) & 0xff);\n        b[1] = (byte) ((x >> 16) & 0xff);\n        b[2] = (byte) ((x >> 8) & 0xff);\n        b[3] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static int unpack32(byte[] b) {\n        int y = 0;\n        y |= ((int) (b[0]) & 0xff) << 24;\n        y |= ((int) (b[1]) & 0xff) << 16;\n        y |= ((int) (b[2]) & 0xff) << 8;\n        y |= ((int) (b[3]) & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n longs in the long array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack64v(long[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 8) {\n            pack64(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n longs of the byte array b into the specified long array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack64v(byte[] b, int s, long[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 8) {\n            v[d + i] = unpack64(b, s);\n        }\n    }\n\n    public static void pack64(long x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 56) & 0xff);\n        b[offset++] = (byte) ((x >> 48) & 0xff);\n        b[offset++] = (byte) ((x >> 40) & 0xff);\n        b[offset++] = (byte) ((x >> 32) & 0xff);\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static long unpack64(byte[] b, int offset) {\n        long y = 0;\n        y |= ((long) b[offset++] & 0xff) << 56;\n        y |= ((long) b[offset++] & 0xff) << 48;\n        y |= ((long) b[offset++] & 0xff) << 40;\n        y |= ((long) b[offset++] & 0xff) << 32;\n        y |= ((long) b[offset++] & 0xff) << 24;\n        y |= ((long) b[offset++] & 0xff) << 16;\n        y |= ((long) b[offset++] & 0xff) << 8;\n        y |= ((long) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack64(long x) {\n        byte[] b = new byte[8];\n        b[0] = (byte) ((x >> 56) & 0xff);\n        b[1] = (byte) ((x >> 48) & 0xff);\n        b[2] = (byte) ((x >> 40) & 0xff);\n        b[3] = (byte) ((x >> 32) & 0xff);\n        b[4] = (byte) ((x >> 24) & 0xff);\n        b[5] = (byte) ((x >> 16) & 0xff);\n        b[6] = (byte) ((x >> 8) & 0xff);\n        b[7] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static long unpack64(byte[] b) {\n        long y = 0;\n        y |= ((long) b[0] & 0xff) << 56;\n        y |= ((long) b[1] & 0xff) << 48;\n        y |= ((long) b[2] & 0xff) << 40;\n        y |= ((long) b[3] & 0xff) << 32;\n        y |= ((long) b[4] & 0xff) << 24;\n        y |= ((long) b[5] & 0xff) << 16;\n        y |= ((long) b[6] & 0xff) << 8;\n        y |= ((long) b[7] & 0xff);\n        return y;\n    }\n\n    /**\n     * Converts the specified float to four bytes.\n     * @param f the float array that is to be packed as a bytes.\n     */\n    public static byte[] packf(float f) {\n        return pack32(Float.floatToIntBits(f));\n    }\n\n    /**\n     * Converts the specified float array to an array of bytes.\n     * @param fv the float array that is to be packed as a byte array.\n     * @param start the offset in fv from which to start packing.\n     * @param count the number of floats to pack.\n     */\n    public static byte[] packfv(float[] fv, int start, int count) {\n        byte[] buf = new byte[count << 4];\n        count += start;\n        for (int i = start, j = 0; i < count; i++, j += 4) {\n            pack32(Float.floatToIntBits(fv[i]), buf, j);\n        }\n        return buf;\n    }\n\n    /**\n     * Converts the specified byte vector to an float.\n     * @param b the byte data that is to be unpacked as a float.\n     */\n    public static float unpackf(byte[] b) {\n        return Float.intBitsToFloat(unpack32(b));\n    }\n\n    /**\n     * Converts the specified integer to a byte vector.\n     * @param i the integer that is to be packed.\n     */\n    public static byte[] packi(int i) {\n        return pack32(i);\n    }\n\n    /**\n     * Converts the specified byte vector to an integer.\n     * @param b the byte data that is to be unpacked as an integer.\n     */\n    public static int unpacki(byte[] b) {\n        return unpack32(b);\n    }\n\n    /**\n     * Converts the specified long to a byte vector.\n     * @param l the long that is to be packed.\n     */\n    public static byte[] packl(long l) {\n        return pack64(l);\n    }\n\n    /**\n     * Converts the specified byte vector to a long.\n     * @param b the byte data that is to be unpacked as a long.\n     */\n    public static long unpackl(byte[] b) {\n        return unpack64(b);\n    }\n\n    /**\n     * Converts the specified double to a byte vector.\n     * @param d the double that is to be packed.\n     */\n    public static byte[] packd(double d) {\n        return pack64(Double.doubleToRawLongBits(d));\n    }\n\n    /**\n     * Converts the specified byte vector to an double.\n     * @param b the byte data that is to be unpacked as an double.\n     */\n    public static double unpackd(byte[] b) {\n        return Double.longBitsToDouble(unpack64(b));\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     * @param b the byte vector to put result in.\n     * @param offset the offset at which to put result.\n     */\n    public static void packs(String s, byte[] b, int offset) {\n        byte[] p = packs(s);\n        System.arraycopy(p, 0, b, offset, p.length);\n    }\n\n    /**\n     * Converts the specified byte vector to a string.\n     * @param b the byte vector containing the packed string.\n     * @param offset the offset at which to start unpacking.\n     * @param length the number of bytes to convert.\n     */\n    public static String unpacks(byte[] b, int offset, int length) {\n        try {\n            return new String(b, offset, length, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     */\n    public static byte[] packs(String s) {\n        try {\n            return s.getBytes(\"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified byte vector to a String.\n     * @param data the byte data that is to be unpacked as a String.\n     */\n    public static String unpacks(byte[] b) {\n        try {\n            return new String(b, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/util/PackerTest4.java",
		"test_prompt": "// PackerTest4.java\npackage util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Packer}.\n* It contains ten unit test cases for the {@link Packer#pack32(int)} method.\n*/\nclass PackerTest4 {"
	},
	{
		"original_code": "// Packer.java\n/* $Id: Packer.java,v 1.3 2004/04/27 19:26:22 bja Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.3 $\n *\n */\npackage util;\n\n/**\n * This class provides a set of functions for converting data types from\n * their normal representation to byte arrays.\n */\npublic class Packer {\n\n    /**\n     * Packs n shorts of the short array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack16v(short[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 2) {\n            pack16(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n shorts of the byte array b into the specified short array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack16v(byte[] b, int s, short[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 2) {\n            v[d + i] = unpack16(b, s);\n        }\n    }\n\n    public static void pack16(short x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static short unpack16(byte[] b, int offset) {\n        short y = 0;\n        y |= ((short) b[offset++] & 0xff) << 8;\n        y |= ((short) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack16(short x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 8) & 0xff);\n        b[1] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static short unpack16(byte[] b) {\n        short y = 0;\n        y |= ((short) b[0] & 0xff) << 8;\n        y |= ((short) b[1] & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n integers of the integer array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack32v(int[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 4) {\n            pack32(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n integers of the byte array b into the specified integer\n     * array v, starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack32v(byte[] b, int s, int[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 4) {\n            v[d + i] = unpack32(b, s);\n        }\n    }\n\n    public static void pack32(int x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static int unpack32(byte[] b, int offset) {\n        int y = 0;\n        y |= ((int) b[offset++] & 0xff) << 24;\n        y |= ((int) b[offset++] & 0xff) << 16;\n        y |= ((int) b[offset++] & 0xff) << 8;\n        y |= ((int) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack32(int x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 24) & 0xff);\n        b[1] = (byte) ((x >> 16) & 0xff);\n        b[2] = (byte) ((x >> 8) & 0xff);\n        b[3] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static int unpack32(byte[] b) {\n        int y = 0;\n        y |= ((int) (b[0]) & 0xff) << 24;\n        y |= ((int) (b[1]) & 0xff) << 16;\n        y |= ((int) (b[2]) & 0xff) << 8;\n        y |= ((int) (b[3]) & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n longs in the long array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack64v(long[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 8) {\n            pack64(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n longs of the byte array b into the specified long array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack64v(byte[] b, int s, long[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 8) {\n            v[d + i] = unpack64(b, s);\n        }\n    }\n\n    public static void pack64(long x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 56) & 0xff);\n        b[offset++] = (byte) ((x >> 48) & 0xff);\n        b[offset++] = (byte) ((x >> 40) & 0xff);\n        b[offset++] = (byte) ((x >> 32) & 0xff);\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static long unpack64(byte[] b, int offset) {\n        long y = 0;\n        y |= ((long) b[offset++] & 0xff) << 56;\n        y |= ((long) b[offset++] & 0xff) << 48;\n        y |= ((long) b[offset++] & 0xff) << 40;\n        y |= ((long) b[offset++] & 0xff) << 32;\n        y |= ((long) b[offset++] & 0xff) << 24;\n        y |= ((long) b[offset++] & 0xff) << 16;\n        y |= ((long) b[offset++] & 0xff) << 8;\n        y |= ((long) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack64(long x) {\n        byte[] b = new byte[8];\n        b[0] = (byte) ((x >> 56) & 0xff);\n        b[1] = (byte) ((x >> 48) & 0xff);\n        b[2] = (byte) ((x >> 40) & 0xff);\n        b[3] = (byte) ((x >> 32) & 0xff);\n        b[4] = (byte) ((x >> 24) & 0xff);\n        b[5] = (byte) ((x >> 16) & 0xff);\n        b[6] = (byte) ((x >> 8) & 0xff);\n        b[7] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static long unpack64(byte[] b) {\n        long y = 0;\n        y |= ((long) b[0] & 0xff) << 56;\n        y |= ((long) b[1] & 0xff) << 48;\n        y |= ((long) b[2] & 0xff) << 40;\n        y |= ((long) b[3] & 0xff) << 32;\n        y |= ((long) b[4] & 0xff) << 24;\n        y |= ((long) b[5] & 0xff) << 16;\n        y |= ((long) b[6] & 0xff) << 8;\n        y |= ((long) b[7] & 0xff);\n        return y;\n    }\n\n    /**\n     * Converts the specified float to four bytes.\n     * @param f the float array that is to be packed as a bytes.\n     */\n    public static byte[] packf(float f) {\n        return pack32(Float.floatToIntBits(f));\n    }\n\n    /**\n     * Converts the specified float array to an array of bytes.\n     * @param fv the float array that is to be packed as a byte array.\n     * @param start the offset in fv from which to start packing.\n     * @param count the number of floats to pack.\n     */\n    public static byte[] packfv(float[] fv, int start, int count) {\n        byte[] buf = new byte[count << 4];\n        count += start;\n        for (int i = start, j = 0; i < count; i++, j += 4) {\n            pack32(Float.floatToIntBits(fv[i]), buf, j);\n        }\n        return buf;\n    }\n\n    /**\n     * Converts the specified byte vector to an float.\n     * @param b the byte data that is to be unpacked as a float.\n     */\n    public static float unpackf(byte[] b) {\n        return Float.intBitsToFloat(unpack32(b));\n    }\n\n    /**\n     * Converts the specified integer to a byte vector.\n     * @param i the integer that is to be packed.\n     */\n    public static byte[] packi(int i) {\n        return pack32(i);\n    }\n\n    /**\n     * Converts the specified byte vector to an integer.\n     * @param b the byte data that is to be unpacked as an integer.\n     */\n    public static int unpacki(byte[] b) {\n        return unpack32(b);\n    }\n\n    /**\n     * Converts the specified long to a byte vector.\n     * @param l the long that is to be packed.\n     */\n    public static byte[] packl(long l) {\n        return pack64(l);\n    }\n\n    /**\n     * Converts the specified byte vector to a long.\n     * @param b the byte data that is to be unpacked as a long.\n     */\n    public static long unpackl(byte[] b) {\n        return unpack64(b);\n    }\n\n    /**\n     * Converts the specified double to a byte vector.\n     * @param d the double that is to be packed.\n     */\n    public static byte[] packd(double d) {\n        return pack64(Double.doubleToRawLongBits(d));\n    }\n\n    /**\n     * Converts the specified byte vector to an double.\n     * @param b the byte data that is to be unpacked as an double.\n     */\n    public static double unpackd(byte[] b) {\n        return Double.longBitsToDouble(unpack64(b));\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     * @param b the byte vector to put result in.\n     * @param offset the offset at which to put result.\n     */\n    public static void packs(String s, byte[] b, int offset) {\n        byte[] p = packs(s);\n        System.arraycopy(p, 0, b, offset, p.length);\n    }\n\n    /**\n     * Converts the specified byte vector to a string.\n     * @param b the byte vector containing the packed string.\n     * @param offset the offset at which to start unpacking.\n     * @param length the number of bytes to convert.\n     */\n    public static String unpacks(byte[] b, int offset, int length) {\n        try {\n            return new String(b, offset, length, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     */\n    public static byte[] packs(String s) {\n        try {\n            return s.getBytes(\"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified byte vector to a String.\n     * @param data the byte data that is to be unpacked as a String.\n     */\n    public static String unpacks(byte[] b) {\n        try {\n            return new String(b, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/util/PackerTest5.java",
		"test_prompt": "// PackerTest5.java\npackage util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Packer}.\n* It contains ten unit test cases for the {@link Packer#unpack32(byte[])} method.\n*/\nclass PackerTest5 {"
	},
	{
		"original_code": "// Packer.java\n/* $Id: Packer.java,v 1.3 2004/04/27 19:26:22 bja Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.3 $\n *\n */\npackage util;\n\n/**\n * This class provides a set of functions for converting data types from\n * their normal representation to byte arrays.\n */\npublic class Packer {\n\n    /**\n     * Packs n shorts of the short array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack16v(short[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 2) {\n            pack16(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n shorts of the byte array b into the specified short array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack16v(byte[] b, int s, short[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 2) {\n            v[d + i] = unpack16(b, s);\n        }\n    }\n\n    public static void pack16(short x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static short unpack16(byte[] b, int offset) {\n        short y = 0;\n        y |= ((short) b[offset++] & 0xff) << 8;\n        y |= ((short) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack16(short x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 8) & 0xff);\n        b[1] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static short unpack16(byte[] b) {\n        short y = 0;\n        y |= ((short) b[0] & 0xff) << 8;\n        y |= ((short) b[1] & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n integers of the integer array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack32v(int[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 4) {\n            pack32(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n integers of the byte array b into the specified integer\n     * array v, starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack32v(byte[] b, int s, int[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 4) {\n            v[d + i] = unpack32(b, s);\n        }\n    }\n\n    public static void pack32(int x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static int unpack32(byte[] b, int offset) {\n        int y = 0;\n        y |= ((int) b[offset++] & 0xff) << 24;\n        y |= ((int) b[offset++] & 0xff) << 16;\n        y |= ((int) b[offset++] & 0xff) << 8;\n        y |= ((int) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack32(int x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 24) & 0xff);\n        b[1] = (byte) ((x >> 16) & 0xff);\n        b[2] = (byte) ((x >> 8) & 0xff);\n        b[3] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static int unpack32(byte[] b) {\n        int y = 0;\n        y |= ((int) (b[0]) & 0xff) << 24;\n        y |= ((int) (b[1]) & 0xff) << 16;\n        y |= ((int) (b[2]) & 0xff) << 8;\n        y |= ((int) (b[3]) & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n longs in the long array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack64v(long[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 8) {\n            pack64(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n longs of the byte array b into the specified long array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack64v(byte[] b, int s, long[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 8) {\n            v[d + i] = unpack64(b, s);\n        }\n    }\n\n    public static void pack64(long x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 56) & 0xff);\n        b[offset++] = (byte) ((x >> 48) & 0xff);\n        b[offset++] = (byte) ((x >> 40) & 0xff);\n        b[offset++] = (byte) ((x >> 32) & 0xff);\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static long unpack64(byte[] b, int offset) {\n        long y = 0;\n        y |= ((long) b[offset++] & 0xff) << 56;\n        y |= ((long) b[offset++] & 0xff) << 48;\n        y |= ((long) b[offset++] & 0xff) << 40;\n        y |= ((long) b[offset++] & 0xff) << 32;\n        y |= ((long) b[offset++] & 0xff) << 24;\n        y |= ((long) b[offset++] & 0xff) << 16;\n        y |= ((long) b[offset++] & 0xff) << 8;\n        y |= ((long) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack64(long x) {\n        byte[] b = new byte[8];\n        b[0] = (byte) ((x >> 56) & 0xff);\n        b[1] = (byte) ((x >> 48) & 0xff);\n        b[2] = (byte) ((x >> 40) & 0xff);\n        b[3] = (byte) ((x >> 32) & 0xff);\n        b[4] = (byte) ((x >> 24) & 0xff);\n        b[5] = (byte) ((x >> 16) & 0xff);\n        b[6] = (byte) ((x >> 8) & 0xff);\n        b[7] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static long unpack64(byte[] b) {\n        long y = 0;\n        y |= ((long) b[0] & 0xff) << 56;\n        y |= ((long) b[1] & 0xff) << 48;\n        y |= ((long) b[2] & 0xff) << 40;\n        y |= ((long) b[3] & 0xff) << 32;\n        y |= ((long) b[4] & 0xff) << 24;\n        y |= ((long) b[5] & 0xff) << 16;\n        y |= ((long) b[6] & 0xff) << 8;\n        y |= ((long) b[7] & 0xff);\n        return y;\n    }\n\n    /**\n     * Converts the specified float to four bytes.\n     * @param f the float array that is to be packed as a bytes.\n     */\n    public static byte[] packf(float f) {\n        return pack32(Float.floatToIntBits(f));\n    }\n\n    /**\n     * Converts the specified float array to an array of bytes.\n     * @param fv the float array that is to be packed as a byte array.\n     * @param start the offset in fv from which to start packing.\n     * @param count the number of floats to pack.\n     */\n    public static byte[] packfv(float[] fv, int start, int count) {\n        byte[] buf = new byte[count << 4];\n        count += start;\n        for (int i = start, j = 0; i < count; i++, j += 4) {\n            pack32(Float.floatToIntBits(fv[i]), buf, j);\n        }\n        return buf;\n    }\n\n    /**\n     * Converts the specified byte vector to an float.\n     * @param b the byte data that is to be unpacked as a float.\n     */\n    public static float unpackf(byte[] b) {\n        return Float.intBitsToFloat(unpack32(b));\n    }\n\n    /**\n     * Converts the specified integer to a byte vector.\n     * @param i the integer that is to be packed.\n     */\n    public static byte[] packi(int i) {\n        return pack32(i);\n    }\n\n    /**\n     * Converts the specified byte vector to an integer.\n     * @param b the byte data that is to be unpacked as an integer.\n     */\n    public static int unpacki(byte[] b) {\n        return unpack32(b);\n    }\n\n    /**\n     * Converts the specified long to a byte vector.\n     * @param l the long that is to be packed.\n     */\n    public static byte[] packl(long l) {\n        return pack64(l);\n    }\n\n    /**\n     * Converts the specified byte vector to a long.\n     * @param b the byte data that is to be unpacked as a long.\n     */\n    public static long unpackl(byte[] b) {\n        return unpack64(b);\n    }\n\n    /**\n     * Converts the specified double to a byte vector.\n     * @param d the double that is to be packed.\n     */\n    public static byte[] packd(double d) {\n        return pack64(Double.doubleToRawLongBits(d));\n    }\n\n    /**\n     * Converts the specified byte vector to an double.\n     * @param b the byte data that is to be unpacked as an double.\n     */\n    public static double unpackd(byte[] b) {\n        return Double.longBitsToDouble(unpack64(b));\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     * @param b the byte vector to put result in.\n     * @param offset the offset at which to put result.\n     */\n    public static void packs(String s, byte[] b, int offset) {\n        byte[] p = packs(s);\n        System.arraycopy(p, 0, b, offset, p.length);\n    }\n\n    /**\n     * Converts the specified byte vector to a string.\n     * @param b the byte vector containing the packed string.\n     * @param offset the offset at which to start unpacking.\n     * @param length the number of bytes to convert.\n     */\n    public static String unpacks(byte[] b, int offset, int length) {\n        try {\n            return new String(b, offset, length, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     */\n    public static byte[] packs(String s) {\n        try {\n            return s.getBytes(\"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified byte vector to a String.\n     * @param data the byte data that is to be unpacked as a String.\n     */\n    public static String unpacks(byte[] b) {\n        try {\n            return new String(b, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/util/PackerTest6.java",
		"test_prompt": "// PackerTest6.java\npackage util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Packer}.\n* It contains ten unit test cases for the {@link Packer#unpack64(byte[], int)} method.\n*/\nclass PackerTest6 {"
	},
	{
		"original_code": "// Packer.java\n/* $Id: Packer.java,v 1.3 2004/04/27 19:26:22 bja Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.3 $\n *\n */\npackage util;\n\n/**\n * This class provides a set of functions for converting data types from\n * their normal representation to byte arrays.\n */\npublic class Packer {\n\n    /**\n     * Packs n shorts of the short array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack16v(short[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 2) {\n            pack16(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n shorts of the byte array b into the specified short array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack16v(byte[] b, int s, short[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 2) {\n            v[d + i] = unpack16(b, s);\n        }\n    }\n\n    public static void pack16(short x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static short unpack16(byte[] b, int offset) {\n        short y = 0;\n        y |= ((short) b[offset++] & 0xff) << 8;\n        y |= ((short) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack16(short x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 8) & 0xff);\n        b[1] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static short unpack16(byte[] b) {\n        short y = 0;\n        y |= ((short) b[0] & 0xff) << 8;\n        y |= ((short) b[1] & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n integers of the integer array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack32v(int[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 4) {\n            pack32(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n integers of the byte array b into the specified integer\n     * array v, starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack32v(byte[] b, int s, int[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 4) {\n            v[d + i] = unpack32(b, s);\n        }\n    }\n\n    public static void pack32(int x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static int unpack32(byte[] b, int offset) {\n        int y = 0;\n        y |= ((int) b[offset++] & 0xff) << 24;\n        y |= ((int) b[offset++] & 0xff) << 16;\n        y |= ((int) b[offset++] & 0xff) << 8;\n        y |= ((int) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack32(int x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 24) & 0xff);\n        b[1] = (byte) ((x >> 16) & 0xff);\n        b[2] = (byte) ((x >> 8) & 0xff);\n        b[3] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static int unpack32(byte[] b) {\n        int y = 0;\n        y |= ((int) (b[0]) & 0xff) << 24;\n        y |= ((int) (b[1]) & 0xff) << 16;\n        y |= ((int) (b[2]) & 0xff) << 8;\n        y |= ((int) (b[3]) & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n longs in the long array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack64v(long[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 8) {\n            pack64(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n longs of the byte array b into the specified long array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack64v(byte[] b, int s, long[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 8) {\n            v[d + i] = unpack64(b, s);\n        }\n    }\n\n    public static void pack64(long x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 56) & 0xff);\n        b[offset++] = (byte) ((x >> 48) & 0xff);\n        b[offset++] = (byte) ((x >> 40) & 0xff);\n        b[offset++] = (byte) ((x >> 32) & 0xff);\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static long unpack64(byte[] b, int offset) {\n        long y = 0;\n        y |= ((long) b[offset++] & 0xff) << 56;\n        y |= ((long) b[offset++] & 0xff) << 48;\n        y |= ((long) b[offset++] & 0xff) << 40;\n        y |= ((long) b[offset++] & 0xff) << 32;\n        y |= ((long) b[offset++] & 0xff) << 24;\n        y |= ((long) b[offset++] & 0xff) << 16;\n        y |= ((long) b[offset++] & 0xff) << 8;\n        y |= ((long) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack64(long x) {\n        byte[] b = new byte[8];\n        b[0] = (byte) ((x >> 56) & 0xff);\n        b[1] = (byte) ((x >> 48) & 0xff);\n        b[2] = (byte) ((x >> 40) & 0xff);\n        b[3] = (byte) ((x >> 32) & 0xff);\n        b[4] = (byte) ((x >> 24) & 0xff);\n        b[5] = (byte) ((x >> 16) & 0xff);\n        b[6] = (byte) ((x >> 8) & 0xff);\n        b[7] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static long unpack64(byte[] b) {\n        long y = 0;\n        y |= ((long) b[0] & 0xff) << 56;\n        y |= ((long) b[1] & 0xff) << 48;\n        y |= ((long) b[2] & 0xff) << 40;\n        y |= ((long) b[3] & 0xff) << 32;\n        y |= ((long) b[4] & 0xff) << 24;\n        y |= ((long) b[5] & 0xff) << 16;\n        y |= ((long) b[6] & 0xff) << 8;\n        y |= ((long) b[7] & 0xff);\n        return y;\n    }\n\n    /**\n     * Converts the specified float to four bytes.\n     * @param f the float array that is to be packed as a bytes.\n     */\n    public static byte[] packf(float f) {\n        return pack32(Float.floatToIntBits(f));\n    }\n\n    /**\n     * Converts the specified float array to an array of bytes.\n     * @param fv the float array that is to be packed as a byte array.\n     * @param start the offset in fv from which to start packing.\n     * @param count the number of floats to pack.\n     */\n    public static byte[] packfv(float[] fv, int start, int count) {\n        byte[] buf = new byte[count << 4];\n        count += start;\n        for (int i = start, j = 0; i < count; i++, j += 4) {\n            pack32(Float.floatToIntBits(fv[i]), buf, j);\n        }\n        return buf;\n    }\n\n    /**\n     * Converts the specified byte vector to an float.\n     * @param b the byte data that is to be unpacked as a float.\n     */\n    public static float unpackf(byte[] b) {\n        return Float.intBitsToFloat(unpack32(b));\n    }\n\n    /**\n     * Converts the specified integer to a byte vector.\n     * @param i the integer that is to be packed.\n     */\n    public static byte[] packi(int i) {\n        return pack32(i);\n    }\n\n    /**\n     * Converts the specified byte vector to an integer.\n     * @param b the byte data that is to be unpacked as an integer.\n     */\n    public static int unpacki(byte[] b) {\n        return unpack32(b);\n    }\n\n    /**\n     * Converts the specified long to a byte vector.\n     * @param l the long that is to be packed.\n     */\n    public static byte[] packl(long l) {\n        return pack64(l);\n    }\n\n    /**\n     * Converts the specified byte vector to a long.\n     * @param b the byte data that is to be unpacked as a long.\n     */\n    public static long unpackl(byte[] b) {\n        return unpack64(b);\n    }\n\n    /**\n     * Converts the specified double to a byte vector.\n     * @param d the double that is to be packed.\n     */\n    public static byte[] packd(double d) {\n        return pack64(Double.doubleToRawLongBits(d));\n    }\n\n    /**\n     * Converts the specified byte vector to an double.\n     * @param b the byte data that is to be unpacked as an double.\n     */\n    public static double unpackd(byte[] b) {\n        return Double.longBitsToDouble(unpack64(b));\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     * @param b the byte vector to put result in.\n     * @param offset the offset at which to put result.\n     */\n    public static void packs(String s, byte[] b, int offset) {\n        byte[] p = packs(s);\n        System.arraycopy(p, 0, b, offset, p.length);\n    }\n\n    /**\n     * Converts the specified byte vector to a string.\n     * @param b the byte vector containing the packed string.\n     * @param offset the offset at which to start unpacking.\n     * @param length the number of bytes to convert.\n     */\n    public static String unpacks(byte[] b, int offset, int length) {\n        try {\n            return new String(b, offset, length, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     */\n    public static byte[] packs(String s) {\n        try {\n            return s.getBytes(\"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified byte vector to a String.\n     * @param data the byte data that is to be unpacked as a String.\n     */\n    public static String unpacks(byte[] b) {\n        try {\n            return new String(b, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/util/PackerTest7.java",
		"test_prompt": "// PackerTest7.java\npackage util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Packer}.\n* It contains ten unit test cases for the {@link Packer#pack64(long)} method.\n*/\nclass PackerTest7 {"
	},
	{
		"original_code": "// Packer.java\n/* $Id: Packer.java,v 1.3 2004/04/27 19:26:22 bja Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.3 $\n *\n */\npackage util;\n\n/**\n * This class provides a set of functions for converting data types from\n * their normal representation to byte arrays.\n */\npublic class Packer {\n\n    /**\n     * Packs n shorts of the short array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack16v(short[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 2) {\n            pack16(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n shorts of the byte array b into the specified short array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack16v(byte[] b, int s, short[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 2) {\n            v[d + i] = unpack16(b, s);\n        }\n    }\n\n    public static void pack16(short x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static short unpack16(byte[] b, int offset) {\n        short y = 0;\n        y |= ((short) b[offset++] & 0xff) << 8;\n        y |= ((short) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack16(short x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 8) & 0xff);\n        b[1] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static short unpack16(byte[] b) {\n        short y = 0;\n        y |= ((short) b[0] & 0xff) << 8;\n        y |= ((short) b[1] & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n integers of the integer array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack32v(int[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 4) {\n            pack32(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n integers of the byte array b into the specified integer\n     * array v, starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack32v(byte[] b, int s, int[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 4) {\n            v[d + i] = unpack32(b, s);\n        }\n    }\n\n    public static void pack32(int x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static int unpack32(byte[] b, int offset) {\n        int y = 0;\n        y |= ((int) b[offset++] & 0xff) << 24;\n        y |= ((int) b[offset++] & 0xff) << 16;\n        y |= ((int) b[offset++] & 0xff) << 8;\n        y |= ((int) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack32(int x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 24) & 0xff);\n        b[1] = (byte) ((x >> 16) & 0xff);\n        b[2] = (byte) ((x >> 8) & 0xff);\n        b[3] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static int unpack32(byte[] b) {\n        int y = 0;\n        y |= ((int) (b[0]) & 0xff) << 24;\n        y |= ((int) (b[1]) & 0xff) << 16;\n        y |= ((int) (b[2]) & 0xff) << 8;\n        y |= ((int) (b[3]) & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n longs in the long array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack64v(long[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 8) {\n            pack64(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n longs of the byte array b into the specified long array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack64v(byte[] b, int s, long[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 8) {\n            v[d + i] = unpack64(b, s);\n        }\n    }\n\n    public static void pack64(long x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 56) & 0xff);\n        b[offset++] = (byte) ((x >> 48) & 0xff);\n        b[offset++] = (byte) ((x >> 40) & 0xff);\n        b[offset++] = (byte) ((x >> 32) & 0xff);\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static long unpack64(byte[] b, int offset) {\n        long y = 0;\n        y |= ((long) b[offset++] & 0xff) << 56;\n        y |= ((long) b[offset++] & 0xff) << 48;\n        y |= ((long) b[offset++] & 0xff) << 40;\n        y |= ((long) b[offset++] & 0xff) << 32;\n        y |= ((long) b[offset++] & 0xff) << 24;\n        y |= ((long) b[offset++] & 0xff) << 16;\n        y |= ((long) b[offset++] & 0xff) << 8;\n        y |= ((long) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack64(long x) {\n        byte[] b = new byte[8];\n        b[0] = (byte) ((x >> 56) & 0xff);\n        b[1] = (byte) ((x >> 48) & 0xff);\n        b[2] = (byte) ((x >> 40) & 0xff);\n        b[3] = (byte) ((x >> 32) & 0xff);\n        b[4] = (byte) ((x >> 24) & 0xff);\n        b[5] = (byte) ((x >> 16) & 0xff);\n        b[6] = (byte) ((x >> 8) & 0xff);\n        b[7] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static long unpack64(byte[] b) {\n        long y = 0;\n        y |= ((long) b[0] & 0xff) << 56;\n        y |= ((long) b[1] & 0xff) << 48;\n        y |= ((long) b[2] & 0xff) << 40;\n        y |= ((long) b[3] & 0xff) << 32;\n        y |= ((long) b[4] & 0xff) << 24;\n        y |= ((long) b[5] & 0xff) << 16;\n        y |= ((long) b[6] & 0xff) << 8;\n        y |= ((long) b[7] & 0xff);\n        return y;\n    }\n\n    /**\n     * Converts the specified float to four bytes.\n     * @param f the float array that is to be packed as a bytes.\n     */\n    public static byte[] packf(float f) {\n        return pack32(Float.floatToIntBits(f));\n    }\n\n    /**\n     * Converts the specified float array to an array of bytes.\n     * @param fv the float array that is to be packed as a byte array.\n     * @param start the offset in fv from which to start packing.\n     * @param count the number of floats to pack.\n     */\n    public static byte[] packfv(float[] fv, int start, int count) {\n        byte[] buf = new byte[count << 4];\n        count += start;\n        for (int i = start, j = 0; i < count; i++, j += 4) {\n            pack32(Float.floatToIntBits(fv[i]), buf, j);\n        }\n        return buf;\n    }\n\n    /**\n     * Converts the specified byte vector to an float.\n     * @param b the byte data that is to be unpacked as a float.\n     */\n    public static float unpackf(byte[] b) {\n        return Float.intBitsToFloat(unpack32(b));\n    }\n\n    /**\n     * Converts the specified integer to a byte vector.\n     * @param i the integer that is to be packed.\n     */\n    public static byte[] packi(int i) {\n        return pack32(i);\n    }\n\n    /**\n     * Converts the specified byte vector to an integer.\n     * @param b the byte data that is to be unpacked as an integer.\n     */\n    public static int unpacki(byte[] b) {\n        return unpack32(b);\n    }\n\n    /**\n     * Converts the specified long to a byte vector.\n     * @param l the long that is to be packed.\n     */\n    public static byte[] packl(long l) {\n        return pack64(l);\n    }\n\n    /**\n     * Converts the specified byte vector to a long.\n     * @param b the byte data that is to be unpacked as a long.\n     */\n    public static long unpackl(byte[] b) {\n        return unpack64(b);\n    }\n\n    /**\n     * Converts the specified double to a byte vector.\n     * @param d the double that is to be packed.\n     */\n    public static byte[] packd(double d) {\n        return pack64(Double.doubleToRawLongBits(d));\n    }\n\n    /**\n     * Converts the specified byte vector to an double.\n     * @param b the byte data that is to be unpacked as an double.\n     */\n    public static double unpackd(byte[] b) {\n        return Double.longBitsToDouble(unpack64(b));\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     * @param b the byte vector to put result in.\n     * @param offset the offset at which to put result.\n     */\n    public static void packs(String s, byte[] b, int offset) {\n        byte[] p = packs(s);\n        System.arraycopy(p, 0, b, offset, p.length);\n    }\n\n    /**\n     * Converts the specified byte vector to a string.\n     * @param b the byte vector containing the packed string.\n     * @param offset the offset at which to start unpacking.\n     * @param length the number of bytes to convert.\n     */\n    public static String unpacks(byte[] b, int offset, int length) {\n        try {\n            return new String(b, offset, length, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     */\n    public static byte[] packs(String s) {\n        try {\n            return s.getBytes(\"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified byte vector to a String.\n     * @param data the byte data that is to be unpacked as a String.\n     */\n    public static String unpacks(byte[] b) {\n        try {\n            return new String(b, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/util/PackerTest8.java",
		"test_prompt": "// PackerTest8.java\npackage util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Packer}.\n* It contains ten unit test cases for the {@link Packer#unpack64(byte[])} method.\n*/\nclass PackerTest8 {"
	},
	{
		"original_code": "// Packer.java\n/* $Id: Packer.java,v 1.3 2004/04/27 19:26:22 bja Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.3 $\n *\n */\npackage util;\n\n/**\n * This class provides a set of functions for converting data types from\n * their normal representation to byte arrays.\n */\npublic class Packer {\n\n    /**\n     * Packs n shorts of the short array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack16v(short[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 2) {\n            pack16(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n shorts of the byte array b into the specified short array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack16v(byte[] b, int s, short[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 2) {\n            v[d + i] = unpack16(b, s);\n        }\n    }\n\n    public static void pack16(short x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static short unpack16(byte[] b, int offset) {\n        short y = 0;\n        y |= ((short) b[offset++] & 0xff) << 8;\n        y |= ((short) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack16(short x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 8) & 0xff);\n        b[1] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static short unpack16(byte[] b) {\n        short y = 0;\n        y |= ((short) b[0] & 0xff) << 8;\n        y |= ((short) b[1] & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n integers of the integer array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack32v(int[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 4) {\n            pack32(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n integers of the byte array b into the specified integer\n     * array v, starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack32v(byte[] b, int s, int[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 4) {\n            v[d + i] = unpack32(b, s);\n        }\n    }\n\n    public static void pack32(int x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static int unpack32(byte[] b, int offset) {\n        int y = 0;\n        y |= ((int) b[offset++] & 0xff) << 24;\n        y |= ((int) b[offset++] & 0xff) << 16;\n        y |= ((int) b[offset++] & 0xff) << 8;\n        y |= ((int) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack32(int x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 24) & 0xff);\n        b[1] = (byte) ((x >> 16) & 0xff);\n        b[2] = (byte) ((x >> 8) & 0xff);\n        b[3] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static int unpack32(byte[] b) {\n        int y = 0;\n        y |= ((int) (b[0]) & 0xff) << 24;\n        y |= ((int) (b[1]) & 0xff) << 16;\n        y |= ((int) (b[2]) & 0xff) << 8;\n        y |= ((int) (b[3]) & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n longs in the long array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack64v(long[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 8) {\n            pack64(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n longs of the byte array b into the specified long array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack64v(byte[] b, int s, long[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 8) {\n            v[d + i] = unpack64(b, s);\n        }\n    }\n\n    public static void pack64(long x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 56) & 0xff);\n        b[offset++] = (byte) ((x >> 48) & 0xff);\n        b[offset++] = (byte) ((x >> 40) & 0xff);\n        b[offset++] = (byte) ((x >> 32) & 0xff);\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static long unpack64(byte[] b, int offset) {\n        long y = 0;\n        y |= ((long) b[offset++] & 0xff) << 56;\n        y |= ((long) b[offset++] & 0xff) << 48;\n        y |= ((long) b[offset++] & 0xff) << 40;\n        y |= ((long) b[offset++] & 0xff) << 32;\n        y |= ((long) b[offset++] & 0xff) << 24;\n        y |= ((long) b[offset++] & 0xff) << 16;\n        y |= ((long) b[offset++] & 0xff) << 8;\n        y |= ((long) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack64(long x) {\n        byte[] b = new byte[8];\n        b[0] = (byte) ((x >> 56) & 0xff);\n        b[1] = (byte) ((x >> 48) & 0xff);\n        b[2] = (byte) ((x >> 40) & 0xff);\n        b[3] = (byte) ((x >> 32) & 0xff);\n        b[4] = (byte) ((x >> 24) & 0xff);\n        b[5] = (byte) ((x >> 16) & 0xff);\n        b[6] = (byte) ((x >> 8) & 0xff);\n        b[7] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static long unpack64(byte[] b) {\n        long y = 0;\n        y |= ((long) b[0] & 0xff) << 56;\n        y |= ((long) b[1] & 0xff) << 48;\n        y |= ((long) b[2] & 0xff) << 40;\n        y |= ((long) b[3] & 0xff) << 32;\n        y |= ((long) b[4] & 0xff) << 24;\n        y |= ((long) b[5] & 0xff) << 16;\n        y |= ((long) b[6] & 0xff) << 8;\n        y |= ((long) b[7] & 0xff);\n        return y;\n    }\n\n    /**\n     * Converts the specified float to four bytes.\n     * @param f the float array that is to be packed as a bytes.\n     */\n    public static byte[] packf(float f) {\n        return pack32(Float.floatToIntBits(f));\n    }\n\n    /**\n     * Converts the specified float array to an array of bytes.\n     * @param fv the float array that is to be packed as a byte array.\n     * @param start the offset in fv from which to start packing.\n     * @param count the number of floats to pack.\n     */\n    public static byte[] packfv(float[] fv, int start, int count) {\n        byte[] buf = new byte[count << 4];\n        count += start;\n        for (int i = start, j = 0; i < count; i++, j += 4) {\n            pack32(Float.floatToIntBits(fv[i]), buf, j);\n        }\n        return buf;\n    }\n\n    /**\n     * Converts the specified byte vector to an float.\n     * @param b the byte data that is to be unpacked as a float.\n     */\n    public static float unpackf(byte[] b) {\n        return Float.intBitsToFloat(unpack32(b));\n    }\n\n    /**\n     * Converts the specified integer to a byte vector.\n     * @param i the integer that is to be packed.\n     */\n    public static byte[] packi(int i) {\n        return pack32(i);\n    }\n\n    /**\n     * Converts the specified byte vector to an integer.\n     * @param b the byte data that is to be unpacked as an integer.\n     */\n    public static int unpacki(byte[] b) {\n        return unpack32(b);\n    }\n\n    /**\n     * Converts the specified long to a byte vector.\n     * @param l the long that is to be packed.\n     */\n    public static byte[] packl(long l) {\n        return pack64(l);\n    }\n\n    /**\n     * Converts the specified byte vector to a long.\n     * @param b the byte data that is to be unpacked as a long.\n     */\n    public static long unpackl(byte[] b) {\n        return unpack64(b);\n    }\n\n    /**\n     * Converts the specified double to a byte vector.\n     * @param d the double that is to be packed.\n     */\n    public static byte[] packd(double d) {\n        return pack64(Double.doubleToRawLongBits(d));\n    }\n\n    /**\n     * Converts the specified byte vector to an double.\n     * @param b the byte data that is to be unpacked as an double.\n     */\n    public static double unpackd(byte[] b) {\n        return Double.longBitsToDouble(unpack64(b));\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     * @param b the byte vector to put result in.\n     * @param offset the offset at which to put result.\n     */\n    public static void packs(String s, byte[] b, int offset) {\n        byte[] p = packs(s);\n        System.arraycopy(p, 0, b, offset, p.length);\n    }\n\n    /**\n     * Converts the specified byte vector to a string.\n     * @param b the byte vector containing the packed string.\n     * @param offset the offset at which to start unpacking.\n     * @param length the number of bytes to convert.\n     */\n    public static String unpacks(byte[] b, int offset, int length) {\n        try {\n            return new String(b, offset, length, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     */\n    public static byte[] packs(String s) {\n        try {\n            return s.getBytes(\"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified byte vector to a String.\n     * @param data the byte data that is to be unpacked as a String.\n     */\n    public static String unpacks(byte[] b) {\n        try {\n            return new String(b, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/util/PackerTest9.java",
		"test_prompt": "// PackerTest9.java\npackage util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Packer}.\n* It contains ten unit test cases for the {@link Packer#packf(float)} method.\n*/\nclass PackerTest9 {"
	},
	{
		"original_code": "// Packer.java\n/* $Id: Packer.java,v 1.3 2004/04/27 19:26:22 bja Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.3 $\n *\n */\npackage util;\n\n/**\n * This class provides a set of functions for converting data types from\n * their normal representation to byte arrays.\n */\npublic class Packer {\n\n    /**\n     * Packs n shorts of the short array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack16v(short[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 2) {\n            pack16(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n shorts of the byte array b into the specified short array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack16v(byte[] b, int s, short[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 2) {\n            v[d + i] = unpack16(b, s);\n        }\n    }\n\n    public static void pack16(short x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static short unpack16(byte[] b, int offset) {\n        short y = 0;\n        y |= ((short) b[offset++] & 0xff) << 8;\n        y |= ((short) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack16(short x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 8) & 0xff);\n        b[1] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static short unpack16(byte[] b) {\n        short y = 0;\n        y |= ((short) b[0] & 0xff) << 8;\n        y |= ((short) b[1] & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n integers of the integer array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack32v(int[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 4) {\n            pack32(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n integers of the byte array b into the specified integer\n     * array v, starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack32v(byte[] b, int s, int[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 4) {\n            v[d + i] = unpack32(b, s);\n        }\n    }\n\n    public static void pack32(int x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static int unpack32(byte[] b, int offset) {\n        int y = 0;\n        y |= ((int) b[offset++] & 0xff) << 24;\n        y |= ((int) b[offset++] & 0xff) << 16;\n        y |= ((int) b[offset++] & 0xff) << 8;\n        y |= ((int) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack32(int x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 24) & 0xff);\n        b[1] = (byte) ((x >> 16) & 0xff);\n        b[2] = (byte) ((x >> 8) & 0xff);\n        b[3] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static int unpack32(byte[] b) {\n        int y = 0;\n        y |= ((int) (b[0]) & 0xff) << 24;\n        y |= ((int) (b[1]) & 0xff) << 16;\n        y |= ((int) (b[2]) & 0xff) << 8;\n        y |= ((int) (b[3]) & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n longs in the long array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack64v(long[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 8) {\n            pack64(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n longs of the byte array b into the specified long array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack64v(byte[] b, int s, long[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 8) {\n            v[d + i] = unpack64(b, s);\n        }\n    }\n\n    public static void pack64(long x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 56) & 0xff);\n        b[offset++] = (byte) ((x >> 48) & 0xff);\n        b[offset++] = (byte) ((x >> 40) & 0xff);\n        b[offset++] = (byte) ((x >> 32) & 0xff);\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static long unpack64(byte[] b, int offset) {\n        long y = 0;\n        y |= ((long) b[offset++] & 0xff) << 56;\n        y |= ((long) b[offset++] & 0xff) << 48;\n        y |= ((long) b[offset++] & 0xff) << 40;\n        y |= ((long) b[offset++] & 0xff) << 32;\n        y |= ((long) b[offset++] & 0xff) << 24;\n        y |= ((long) b[offset++] & 0xff) << 16;\n        y |= ((long) b[offset++] & 0xff) << 8;\n        y |= ((long) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack64(long x) {\n        byte[] b = new byte[8];\n        b[0] = (byte) ((x >> 56) & 0xff);\n        b[1] = (byte) ((x >> 48) & 0xff);\n        b[2] = (byte) ((x >> 40) & 0xff);\n        b[3] = (byte) ((x >> 32) & 0xff);\n        b[4] = (byte) ((x >> 24) & 0xff);\n        b[5] = (byte) ((x >> 16) & 0xff);\n        b[6] = (byte) ((x >> 8) & 0xff);\n        b[7] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static long unpack64(byte[] b) {\n        long y = 0;\n        y |= ((long) b[0] & 0xff) << 56;\n        y |= ((long) b[1] & 0xff) << 48;\n        y |= ((long) b[2] & 0xff) << 40;\n        y |= ((long) b[3] & 0xff) << 32;\n        y |= ((long) b[4] & 0xff) << 24;\n        y |= ((long) b[5] & 0xff) << 16;\n        y |= ((long) b[6] & 0xff) << 8;\n        y |= ((long) b[7] & 0xff);\n        return y;\n    }\n\n    /**\n     * Converts the specified float to four bytes.\n     * @param f the float array that is to be packed as a bytes.\n     */\n    public static byte[] packf(float f) {\n        return pack32(Float.floatToIntBits(f));\n    }\n\n    /**\n     * Converts the specified float array to an array of bytes.\n     * @param fv the float array that is to be packed as a byte array.\n     * @param start the offset in fv from which to start packing.\n     * @param count the number of floats to pack.\n     */\n    public static byte[] packfv(float[] fv, int start, int count) {\n        byte[] buf = new byte[count << 4];\n        count += start;\n        for (int i = start, j = 0; i < count; i++, j += 4) {\n            pack32(Float.floatToIntBits(fv[i]), buf, j);\n        }\n        return buf;\n    }\n\n    /**\n     * Converts the specified byte vector to an float.\n     * @param b the byte data that is to be unpacked as a float.\n     */\n    public static float unpackf(byte[] b) {\n        return Float.intBitsToFloat(unpack32(b));\n    }\n\n    /**\n     * Converts the specified integer to a byte vector.\n     * @param i the integer that is to be packed.\n     */\n    public static byte[] packi(int i) {\n        return pack32(i);\n    }\n\n    /**\n     * Converts the specified byte vector to an integer.\n     * @param b the byte data that is to be unpacked as an integer.\n     */\n    public static int unpacki(byte[] b) {\n        return unpack32(b);\n    }\n\n    /**\n     * Converts the specified long to a byte vector.\n     * @param l the long that is to be packed.\n     */\n    public static byte[] packl(long l) {\n        return pack64(l);\n    }\n\n    /**\n     * Converts the specified byte vector to a long.\n     * @param b the byte data that is to be unpacked as a long.\n     */\n    public static long unpackl(byte[] b) {\n        return unpack64(b);\n    }\n\n    /**\n     * Converts the specified double to a byte vector.\n     * @param d the double that is to be packed.\n     */\n    public static byte[] packd(double d) {\n        return pack64(Double.doubleToRawLongBits(d));\n    }\n\n    /**\n     * Converts the specified byte vector to an double.\n     * @param b the byte data that is to be unpacked as an double.\n     */\n    public static double unpackd(byte[] b) {\n        return Double.longBitsToDouble(unpack64(b));\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     * @param b the byte vector to put result in.\n     * @param offset the offset at which to put result.\n     */\n    public static void packs(String s, byte[] b, int offset) {\n        byte[] p = packs(s);\n        System.arraycopy(p, 0, b, offset, p.length);\n    }\n\n    /**\n     * Converts the specified byte vector to a string.\n     * @param b the byte vector containing the packed string.\n     * @param offset the offset at which to start unpacking.\n     * @param length the number of bytes to convert.\n     */\n    public static String unpacks(byte[] b, int offset, int length) {\n        try {\n            return new String(b, offset, length, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     */\n    public static byte[] packs(String s) {\n        try {\n            return s.getBytes(\"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified byte vector to a String.\n     * @param data the byte data that is to be unpacked as a String.\n     */\n    public static String unpacks(byte[] b) {\n        try {\n            return new String(b, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/util/PackerTest10.java",
		"test_prompt": "// PackerTest10.java\npackage util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Packer}.\n* It contains ten unit test cases for the {@link Packer#packfv(float[], int, int)} method.\n*/\nclass PackerTest10 {"
	},
	{
		"original_code": "// Packer.java\n/* $Id: Packer.java,v 1.3 2004/04/27 19:26:22 bja Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.3 $\n *\n */\npackage util;\n\n/**\n * This class provides a set of functions for converting data types from\n * their normal representation to byte arrays.\n */\npublic class Packer {\n\n    /**\n     * Packs n shorts of the short array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack16v(short[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 2) {\n            pack16(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n shorts of the byte array b into the specified short array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack16v(byte[] b, int s, short[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 2) {\n            v[d + i] = unpack16(b, s);\n        }\n    }\n\n    public static void pack16(short x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static short unpack16(byte[] b, int offset) {\n        short y = 0;\n        y |= ((short) b[offset++] & 0xff) << 8;\n        y |= ((short) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack16(short x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 8) & 0xff);\n        b[1] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static short unpack16(byte[] b) {\n        short y = 0;\n        y |= ((short) b[0] & 0xff) << 8;\n        y |= ((short) b[1] & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n integers of the integer array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack32v(int[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 4) {\n            pack32(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n integers of the byte array b into the specified integer\n     * array v, starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack32v(byte[] b, int s, int[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 4) {\n            v[d + i] = unpack32(b, s);\n        }\n    }\n\n    public static void pack32(int x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static int unpack32(byte[] b, int offset) {\n        int y = 0;\n        y |= ((int) b[offset++] & 0xff) << 24;\n        y |= ((int) b[offset++] & 0xff) << 16;\n        y |= ((int) b[offset++] & 0xff) << 8;\n        y |= ((int) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack32(int x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 24) & 0xff);\n        b[1] = (byte) ((x >> 16) & 0xff);\n        b[2] = (byte) ((x >> 8) & 0xff);\n        b[3] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static int unpack32(byte[] b) {\n        int y = 0;\n        y |= ((int) (b[0]) & 0xff) << 24;\n        y |= ((int) (b[1]) & 0xff) << 16;\n        y |= ((int) (b[2]) & 0xff) << 8;\n        y |= ((int) (b[3]) & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n longs in the long array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack64v(long[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 8) {\n            pack64(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n longs of the byte array b into the specified long array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack64v(byte[] b, int s, long[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 8) {\n            v[d + i] = unpack64(b, s);\n        }\n    }\n\n    public static void pack64(long x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 56) & 0xff);\n        b[offset++] = (byte) ((x >> 48) & 0xff);\n        b[offset++] = (byte) ((x >> 40) & 0xff);\n        b[offset++] = (byte) ((x >> 32) & 0xff);\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static long unpack64(byte[] b, int offset) {\n        long y = 0;\n        y |= ((long) b[offset++] & 0xff) << 56;\n        y |= ((long) b[offset++] & 0xff) << 48;\n        y |= ((long) b[offset++] & 0xff) << 40;\n        y |= ((long) b[offset++] & 0xff) << 32;\n        y |= ((long) b[offset++] & 0xff) << 24;\n        y |= ((long) b[offset++] & 0xff) << 16;\n        y |= ((long) b[offset++] & 0xff) << 8;\n        y |= ((long) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack64(long x) {\n        byte[] b = new byte[8];\n        b[0] = (byte) ((x >> 56) & 0xff);\n        b[1] = (byte) ((x >> 48) & 0xff);\n        b[2] = (byte) ((x >> 40) & 0xff);\n        b[3] = (byte) ((x >> 32) & 0xff);\n        b[4] = (byte) ((x >> 24) & 0xff);\n        b[5] = (byte) ((x >> 16) & 0xff);\n        b[6] = (byte) ((x >> 8) & 0xff);\n        b[7] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static long unpack64(byte[] b) {\n        long y = 0;\n        y |= ((long) b[0] & 0xff) << 56;\n        y |= ((long) b[1] & 0xff) << 48;\n        y |= ((long) b[2] & 0xff) << 40;\n        y |= ((long) b[3] & 0xff) << 32;\n        y |= ((long) b[4] & 0xff) << 24;\n        y |= ((long) b[5] & 0xff) << 16;\n        y |= ((long) b[6] & 0xff) << 8;\n        y |= ((long) b[7] & 0xff);\n        return y;\n    }\n\n    /**\n     * Converts the specified float to four bytes.\n     * @param f the float array that is to be packed as a bytes.\n     */\n    public static byte[] packf(float f) {\n        return pack32(Float.floatToIntBits(f));\n    }\n\n    /**\n     * Converts the specified float array to an array of bytes.\n     * @param fv the float array that is to be packed as a byte array.\n     * @param start the offset in fv from which to start packing.\n     * @param count the number of floats to pack.\n     */\n    public static byte[] packfv(float[] fv, int start, int count) {\n        byte[] buf = new byte[count << 4];\n        count += start;\n        for (int i = start, j = 0; i < count; i++, j += 4) {\n            pack32(Float.floatToIntBits(fv[i]), buf, j);\n        }\n        return buf;\n    }\n\n    /**\n     * Converts the specified byte vector to an float.\n     * @param b the byte data that is to be unpacked as a float.\n     */\n    public static float unpackf(byte[] b) {\n        return Float.intBitsToFloat(unpack32(b));\n    }\n\n    /**\n     * Converts the specified integer to a byte vector.\n     * @param i the integer that is to be packed.\n     */\n    public static byte[] packi(int i) {\n        return pack32(i);\n    }\n\n    /**\n     * Converts the specified byte vector to an integer.\n     * @param b the byte data that is to be unpacked as an integer.\n     */\n    public static int unpacki(byte[] b) {\n        return unpack32(b);\n    }\n\n    /**\n     * Converts the specified long to a byte vector.\n     * @param l the long that is to be packed.\n     */\n    public static byte[] packl(long l) {\n        return pack64(l);\n    }\n\n    /**\n     * Converts the specified byte vector to a long.\n     * @param b the byte data that is to be unpacked as a long.\n     */\n    public static long unpackl(byte[] b) {\n        return unpack64(b);\n    }\n\n    /**\n     * Converts the specified double to a byte vector.\n     * @param d the double that is to be packed.\n     */\n    public static byte[] packd(double d) {\n        return pack64(Double.doubleToRawLongBits(d));\n    }\n\n    /**\n     * Converts the specified byte vector to an double.\n     * @param b the byte data that is to be unpacked as an double.\n     */\n    public static double unpackd(byte[] b) {\n        return Double.longBitsToDouble(unpack64(b));\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     * @param b the byte vector to put result in.\n     * @param offset the offset at which to put result.\n     */\n    public static void packs(String s, byte[] b, int offset) {\n        byte[] p = packs(s);\n        System.arraycopy(p, 0, b, offset, p.length);\n    }\n\n    /**\n     * Converts the specified byte vector to a string.\n     * @param b the byte vector containing the packed string.\n     * @param offset the offset at which to start unpacking.\n     * @param length the number of bytes to convert.\n     */\n    public static String unpacks(byte[] b, int offset, int length) {\n        try {\n            return new String(b, offset, length, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     */\n    public static byte[] packs(String s) {\n        try {\n            return s.getBytes(\"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified byte vector to a String.\n     * @param data the byte data that is to be unpacked as a String.\n     */\n    public static String unpacks(byte[] b) {\n        try {\n            return new String(b, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/util/PackerTest11.java",
		"test_prompt": "// PackerTest11.java\npackage util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Packer}.\n* It contains ten unit test cases for the {@link Packer#unpackf(byte[])} method.\n*/\nclass PackerTest11 {"
	},
	{
		"original_code": "// Packer.java\n/* $Id: Packer.java,v 1.3 2004/04/27 19:26:22 bja Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.3 $\n *\n */\npackage util;\n\n/**\n * This class provides a set of functions for converting data types from\n * their normal representation to byte arrays.\n */\npublic class Packer {\n\n    /**\n     * Packs n shorts of the short array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack16v(short[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 2) {\n            pack16(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n shorts of the byte array b into the specified short array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack16v(byte[] b, int s, short[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 2) {\n            v[d + i] = unpack16(b, s);\n        }\n    }\n\n    public static void pack16(short x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static short unpack16(byte[] b, int offset) {\n        short y = 0;\n        y |= ((short) b[offset++] & 0xff) << 8;\n        y |= ((short) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack16(short x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 8) & 0xff);\n        b[1] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static short unpack16(byte[] b) {\n        short y = 0;\n        y |= ((short) b[0] & 0xff) << 8;\n        y |= ((short) b[1] & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n integers of the integer array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack32v(int[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 4) {\n            pack32(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n integers of the byte array b into the specified integer\n     * array v, starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack32v(byte[] b, int s, int[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 4) {\n            v[d + i] = unpack32(b, s);\n        }\n    }\n\n    public static void pack32(int x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static int unpack32(byte[] b, int offset) {\n        int y = 0;\n        y |= ((int) b[offset++] & 0xff) << 24;\n        y |= ((int) b[offset++] & 0xff) << 16;\n        y |= ((int) b[offset++] & 0xff) << 8;\n        y |= ((int) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack32(int x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 24) & 0xff);\n        b[1] = (byte) ((x >> 16) & 0xff);\n        b[2] = (byte) ((x >> 8) & 0xff);\n        b[3] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static int unpack32(byte[] b) {\n        int y = 0;\n        y |= ((int) (b[0]) & 0xff) << 24;\n        y |= ((int) (b[1]) & 0xff) << 16;\n        y |= ((int) (b[2]) & 0xff) << 8;\n        y |= ((int) (b[3]) & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n longs in the long array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack64v(long[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 8) {\n            pack64(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n longs of the byte array b into the specified long array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack64v(byte[] b, int s, long[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 8) {\n            v[d + i] = unpack64(b, s);\n        }\n    }\n\n    public static void pack64(long x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 56) & 0xff);\n        b[offset++] = (byte) ((x >> 48) & 0xff);\n        b[offset++] = (byte) ((x >> 40) & 0xff);\n        b[offset++] = (byte) ((x >> 32) & 0xff);\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static long unpack64(byte[] b, int offset) {\n        long y = 0;\n        y |= ((long) b[offset++] & 0xff) << 56;\n        y |= ((long) b[offset++] & 0xff) << 48;\n        y |= ((long) b[offset++] & 0xff) << 40;\n        y |= ((long) b[offset++] & 0xff) << 32;\n        y |= ((long) b[offset++] & 0xff) << 24;\n        y |= ((long) b[offset++] & 0xff) << 16;\n        y |= ((long) b[offset++] & 0xff) << 8;\n        y |= ((long) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack64(long x) {\n        byte[] b = new byte[8];\n        b[0] = (byte) ((x >> 56) & 0xff);\n        b[1] = (byte) ((x >> 48) & 0xff);\n        b[2] = (byte) ((x >> 40) & 0xff);\n        b[3] = (byte) ((x >> 32) & 0xff);\n        b[4] = (byte) ((x >> 24) & 0xff);\n        b[5] = (byte) ((x >> 16) & 0xff);\n        b[6] = (byte) ((x >> 8) & 0xff);\n        b[7] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static long unpack64(byte[] b) {\n        long y = 0;\n        y |= ((long) b[0] & 0xff) << 56;\n        y |= ((long) b[1] & 0xff) << 48;\n        y |= ((long) b[2] & 0xff) << 40;\n        y |= ((long) b[3] & 0xff) << 32;\n        y |= ((long) b[4] & 0xff) << 24;\n        y |= ((long) b[5] & 0xff) << 16;\n        y |= ((long) b[6] & 0xff) << 8;\n        y |= ((long) b[7] & 0xff);\n        return y;\n    }\n\n    /**\n     * Converts the specified float to four bytes.\n     * @param f the float array that is to be packed as a bytes.\n     */\n    public static byte[] packf(float f) {\n        return pack32(Float.floatToIntBits(f));\n    }\n\n    /**\n     * Converts the specified float array to an array of bytes.\n     * @param fv the float array that is to be packed as a byte array.\n     * @param start the offset in fv from which to start packing.\n     * @param count the number of floats to pack.\n     */\n    public static byte[] packfv(float[] fv, int start, int count) {\n        byte[] buf = new byte[count << 4];\n        count += start;\n        for (int i = start, j = 0; i < count; i++, j += 4) {\n            pack32(Float.floatToIntBits(fv[i]), buf, j);\n        }\n        return buf;\n    }\n\n    /**\n     * Converts the specified byte vector to an float.\n     * @param b the byte data that is to be unpacked as a float.\n     */\n    public static float unpackf(byte[] b) {\n        return Float.intBitsToFloat(unpack32(b));\n    }\n\n    /**\n     * Converts the specified integer to a byte vector.\n     * @param i the integer that is to be packed.\n     */\n    public static byte[] packi(int i) {\n        return pack32(i);\n    }\n\n    /**\n     * Converts the specified byte vector to an integer.\n     * @param b the byte data that is to be unpacked as an integer.\n     */\n    public static int unpacki(byte[] b) {\n        return unpack32(b);\n    }\n\n    /**\n     * Converts the specified long to a byte vector.\n     * @param l the long that is to be packed.\n     */\n    public static byte[] packl(long l) {\n        return pack64(l);\n    }\n\n    /**\n     * Converts the specified byte vector to a long.\n     * @param b the byte data that is to be unpacked as a long.\n     */\n    public static long unpackl(byte[] b) {\n        return unpack64(b);\n    }\n\n    /**\n     * Converts the specified double to a byte vector.\n     * @param d the double that is to be packed.\n     */\n    public static byte[] packd(double d) {\n        return pack64(Double.doubleToRawLongBits(d));\n    }\n\n    /**\n     * Converts the specified byte vector to an double.\n     * @param b the byte data that is to be unpacked as an double.\n     */\n    public static double unpackd(byte[] b) {\n        return Double.longBitsToDouble(unpack64(b));\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     * @param b the byte vector to put result in.\n     * @param offset the offset at which to put result.\n     */\n    public static void packs(String s, byte[] b, int offset) {\n        byte[] p = packs(s);\n        System.arraycopy(p, 0, b, offset, p.length);\n    }\n\n    /**\n     * Converts the specified byte vector to a string.\n     * @param b the byte vector containing the packed string.\n     * @param offset the offset at which to start unpacking.\n     * @param length the number of bytes to convert.\n     */\n    public static String unpacks(byte[] b, int offset, int length) {\n        try {\n            return new String(b, offset, length, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     */\n    public static byte[] packs(String s) {\n        try {\n            return s.getBytes(\"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified byte vector to a String.\n     * @param data the byte data that is to be unpacked as a String.\n     */\n    public static String unpacks(byte[] b) {\n        try {\n            return new String(b, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/util/PackerTest12.java",
		"test_prompt": "// PackerTest12.java\npackage util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Packer}.\n* It contains ten unit test cases for the {@link Packer#packi(int)} method.\n*/\nclass PackerTest12 {"
	},
	{
		"original_code": "// Packer.java\n/* $Id: Packer.java,v 1.3 2004/04/27 19:26:22 bja Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.3 $\n *\n */\npackage util;\n\n/**\n * This class provides a set of functions for converting data types from\n * their normal representation to byte arrays.\n */\npublic class Packer {\n\n    /**\n     * Packs n shorts of the short array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack16v(short[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 2) {\n            pack16(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n shorts of the byte array b into the specified short array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack16v(byte[] b, int s, short[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 2) {\n            v[d + i] = unpack16(b, s);\n        }\n    }\n\n    public static void pack16(short x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static short unpack16(byte[] b, int offset) {\n        short y = 0;\n        y |= ((short) b[offset++] & 0xff) << 8;\n        y |= ((short) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack16(short x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 8) & 0xff);\n        b[1] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static short unpack16(byte[] b) {\n        short y = 0;\n        y |= ((short) b[0] & 0xff) << 8;\n        y |= ((short) b[1] & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n integers of the integer array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack32v(int[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 4) {\n            pack32(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n integers of the byte array b into the specified integer\n     * array v, starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack32v(byte[] b, int s, int[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 4) {\n            v[d + i] = unpack32(b, s);\n        }\n    }\n\n    public static void pack32(int x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static int unpack32(byte[] b, int offset) {\n        int y = 0;\n        y |= ((int) b[offset++] & 0xff) << 24;\n        y |= ((int) b[offset++] & 0xff) << 16;\n        y |= ((int) b[offset++] & 0xff) << 8;\n        y |= ((int) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack32(int x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 24) & 0xff);\n        b[1] = (byte) ((x >> 16) & 0xff);\n        b[2] = (byte) ((x >> 8) & 0xff);\n        b[3] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static int unpack32(byte[] b) {\n        int y = 0;\n        y |= ((int) (b[0]) & 0xff) << 24;\n        y |= ((int) (b[1]) & 0xff) << 16;\n        y |= ((int) (b[2]) & 0xff) << 8;\n        y |= ((int) (b[3]) & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n longs in the long array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack64v(long[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 8) {\n            pack64(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n longs of the byte array b into the specified long array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack64v(byte[] b, int s, long[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 8) {\n            v[d + i] = unpack64(b, s);\n        }\n    }\n\n    public static void pack64(long x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 56) & 0xff);\n        b[offset++] = (byte) ((x >> 48) & 0xff);\n        b[offset++] = (byte) ((x >> 40) & 0xff);\n        b[offset++] = (byte) ((x >> 32) & 0xff);\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static long unpack64(byte[] b, int offset) {\n        long y = 0;\n        y |= ((long) b[offset++] & 0xff) << 56;\n        y |= ((long) b[offset++] & 0xff) << 48;\n        y |= ((long) b[offset++] & 0xff) << 40;\n        y |= ((long) b[offset++] & 0xff) << 32;\n        y |= ((long) b[offset++] & 0xff) << 24;\n        y |= ((long) b[offset++] & 0xff) << 16;\n        y |= ((long) b[offset++] & 0xff) << 8;\n        y |= ((long) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack64(long x) {\n        byte[] b = new byte[8];\n        b[0] = (byte) ((x >> 56) & 0xff);\n        b[1] = (byte) ((x >> 48) & 0xff);\n        b[2] = (byte) ((x >> 40) & 0xff);\n        b[3] = (byte) ((x >> 32) & 0xff);\n        b[4] = (byte) ((x >> 24) & 0xff);\n        b[5] = (byte) ((x >> 16) & 0xff);\n        b[6] = (byte) ((x >> 8) & 0xff);\n        b[7] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static long unpack64(byte[] b) {\n        long y = 0;\n        y |= ((long) b[0] & 0xff) << 56;\n        y |= ((long) b[1] & 0xff) << 48;\n        y |= ((long) b[2] & 0xff) << 40;\n        y |= ((long) b[3] & 0xff) << 32;\n        y |= ((long) b[4] & 0xff) << 24;\n        y |= ((long) b[5] & 0xff) << 16;\n        y |= ((long) b[6] & 0xff) << 8;\n        y |= ((long) b[7] & 0xff);\n        return y;\n    }\n\n    /**\n     * Converts the specified float to four bytes.\n     * @param f the float array that is to be packed as a bytes.\n     */\n    public static byte[] packf(float f) {\n        return pack32(Float.floatToIntBits(f));\n    }\n\n    /**\n     * Converts the specified float array to an array of bytes.\n     * @param fv the float array that is to be packed as a byte array.\n     * @param start the offset in fv from which to start packing.\n     * @param count the number of floats to pack.\n     */\n    public static byte[] packfv(float[] fv, int start, int count) {\n        byte[] buf = new byte[count << 4];\n        count += start;\n        for (int i = start, j = 0; i < count; i++, j += 4) {\n            pack32(Float.floatToIntBits(fv[i]), buf, j);\n        }\n        return buf;\n    }\n\n    /**\n     * Converts the specified byte vector to an float.\n     * @param b the byte data that is to be unpacked as a float.\n     */\n    public static float unpackf(byte[] b) {\n        return Float.intBitsToFloat(unpack32(b));\n    }\n\n    /**\n     * Converts the specified integer to a byte vector.\n     * @param i the integer that is to be packed.\n     */\n    public static byte[] packi(int i) {\n        return pack32(i);\n    }\n\n    /**\n     * Converts the specified byte vector to an integer.\n     * @param b the byte data that is to be unpacked as an integer.\n     */\n    public static int unpacki(byte[] b) {\n        return unpack32(b);\n    }\n\n    /**\n     * Converts the specified long to a byte vector.\n     * @param l the long that is to be packed.\n     */\n    public static byte[] packl(long l) {\n        return pack64(l);\n    }\n\n    /**\n     * Converts the specified byte vector to a long.\n     * @param b the byte data that is to be unpacked as a long.\n     */\n    public static long unpackl(byte[] b) {\n        return unpack64(b);\n    }\n\n    /**\n     * Converts the specified double to a byte vector.\n     * @param d the double that is to be packed.\n     */\n    public static byte[] packd(double d) {\n        return pack64(Double.doubleToRawLongBits(d));\n    }\n\n    /**\n     * Converts the specified byte vector to an double.\n     * @param b the byte data that is to be unpacked as an double.\n     */\n    public static double unpackd(byte[] b) {\n        return Double.longBitsToDouble(unpack64(b));\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     * @param b the byte vector to put result in.\n     * @param offset the offset at which to put result.\n     */\n    public static void packs(String s, byte[] b, int offset) {\n        byte[] p = packs(s);\n        System.arraycopy(p, 0, b, offset, p.length);\n    }\n\n    /**\n     * Converts the specified byte vector to a string.\n     * @param b the byte vector containing the packed string.\n     * @param offset the offset at which to start unpacking.\n     * @param length the number of bytes to convert.\n     */\n    public static String unpacks(byte[] b, int offset, int length) {\n        try {\n            return new String(b, offset, length, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     */\n    public static byte[] packs(String s) {\n        try {\n            return s.getBytes(\"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified byte vector to a String.\n     * @param data the byte data that is to be unpacked as a String.\n     */\n    public static String unpacks(byte[] b) {\n        try {\n            return new String(b, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/util/PackerTest13.java",
		"test_prompt": "// PackerTest13.java\npackage util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Packer}.\n* It contains ten unit test cases for the {@link Packer#unpacki(byte[])} method.\n*/\nclass PackerTest13 {"
	},
	{
		"original_code": "// Packer.java\n/* $Id: Packer.java,v 1.3 2004/04/27 19:26:22 bja Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.3 $\n *\n */\npackage util;\n\n/**\n * This class provides a set of functions for converting data types from\n * their normal representation to byte arrays.\n */\npublic class Packer {\n\n    /**\n     * Packs n shorts of the short array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack16v(short[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 2) {\n            pack16(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n shorts of the byte array b into the specified short array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack16v(byte[] b, int s, short[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 2) {\n            v[d + i] = unpack16(b, s);\n        }\n    }\n\n    public static void pack16(short x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static short unpack16(byte[] b, int offset) {\n        short y = 0;\n        y |= ((short) b[offset++] & 0xff) << 8;\n        y |= ((short) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack16(short x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 8) & 0xff);\n        b[1] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static short unpack16(byte[] b) {\n        short y = 0;\n        y |= ((short) b[0] & 0xff) << 8;\n        y |= ((short) b[1] & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n integers of the integer array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack32v(int[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 4) {\n            pack32(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n integers of the byte array b into the specified integer\n     * array v, starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack32v(byte[] b, int s, int[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 4) {\n            v[d + i] = unpack32(b, s);\n        }\n    }\n\n    public static void pack32(int x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static int unpack32(byte[] b, int offset) {\n        int y = 0;\n        y |= ((int) b[offset++] & 0xff) << 24;\n        y |= ((int) b[offset++] & 0xff) << 16;\n        y |= ((int) b[offset++] & 0xff) << 8;\n        y |= ((int) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack32(int x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 24) & 0xff);\n        b[1] = (byte) ((x >> 16) & 0xff);\n        b[2] = (byte) ((x >> 8) & 0xff);\n        b[3] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static int unpack32(byte[] b) {\n        int y = 0;\n        y |= ((int) (b[0]) & 0xff) << 24;\n        y |= ((int) (b[1]) & 0xff) << 16;\n        y |= ((int) (b[2]) & 0xff) << 8;\n        y |= ((int) (b[3]) & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n longs in the long array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack64v(long[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 8) {\n            pack64(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n longs of the byte array b into the specified long array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack64v(byte[] b, int s, long[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 8) {\n            v[d + i] = unpack64(b, s);\n        }\n    }\n\n    public static void pack64(long x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 56) & 0xff);\n        b[offset++] = (byte) ((x >> 48) & 0xff);\n        b[offset++] = (byte) ((x >> 40) & 0xff);\n        b[offset++] = (byte) ((x >> 32) & 0xff);\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static long unpack64(byte[] b, int offset) {\n        long y = 0;\n        y |= ((long) b[offset++] & 0xff) << 56;\n        y |= ((long) b[offset++] & 0xff) << 48;\n        y |= ((long) b[offset++] & 0xff) << 40;\n        y |= ((long) b[offset++] & 0xff) << 32;\n        y |= ((long) b[offset++] & 0xff) << 24;\n        y |= ((long) b[offset++] & 0xff) << 16;\n        y |= ((long) b[offset++] & 0xff) << 8;\n        y |= ((long) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack64(long x) {\n        byte[] b = new byte[8];\n        b[0] = (byte) ((x >> 56) & 0xff);\n        b[1] = (byte) ((x >> 48) & 0xff);\n        b[2] = (byte) ((x >> 40) & 0xff);\n        b[3] = (byte) ((x >> 32) & 0xff);\n        b[4] = (byte) ((x >> 24) & 0xff);\n        b[5] = (byte) ((x >> 16) & 0xff);\n        b[6] = (byte) ((x >> 8) & 0xff);\n        b[7] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static long unpack64(byte[] b) {\n        long y = 0;\n        y |= ((long) b[0] & 0xff) << 56;\n        y |= ((long) b[1] & 0xff) << 48;\n        y |= ((long) b[2] & 0xff) << 40;\n        y |= ((long) b[3] & 0xff) << 32;\n        y |= ((long) b[4] & 0xff) << 24;\n        y |= ((long) b[5] & 0xff) << 16;\n        y |= ((long) b[6] & 0xff) << 8;\n        y |= ((long) b[7] & 0xff);\n        return y;\n    }\n\n    /**\n     * Converts the specified float to four bytes.\n     * @param f the float array that is to be packed as a bytes.\n     */\n    public static byte[] packf(float f) {\n        return pack32(Float.floatToIntBits(f));\n    }\n\n    /**\n     * Converts the specified float array to an array of bytes.\n     * @param fv the float array that is to be packed as a byte array.\n     * @param start the offset in fv from which to start packing.\n     * @param count the number of floats to pack.\n     */\n    public static byte[] packfv(float[] fv, int start, int count) {\n        byte[] buf = new byte[count << 4];\n        count += start;\n        for (int i = start, j = 0; i < count; i++, j += 4) {\n            pack32(Float.floatToIntBits(fv[i]), buf, j);\n        }\n        return buf;\n    }\n\n    /**\n     * Converts the specified byte vector to an float.\n     * @param b the byte data that is to be unpacked as a float.\n     */\n    public static float unpackf(byte[] b) {\n        return Float.intBitsToFloat(unpack32(b));\n    }\n\n    /**\n     * Converts the specified integer to a byte vector.\n     * @param i the integer that is to be packed.\n     */\n    public static byte[] packi(int i) {\n        return pack32(i);\n    }\n\n    /**\n     * Converts the specified byte vector to an integer.\n     * @param b the byte data that is to be unpacked as an integer.\n     */\n    public static int unpacki(byte[] b) {\n        return unpack32(b);\n    }\n\n    /**\n     * Converts the specified long to a byte vector.\n     * @param l the long that is to be packed.\n     */\n    public static byte[] packl(long l) {\n        return pack64(l);\n    }\n\n    /**\n     * Converts the specified byte vector to a long.\n     * @param b the byte data that is to be unpacked as a long.\n     */\n    public static long unpackl(byte[] b) {\n        return unpack64(b);\n    }\n\n    /**\n     * Converts the specified double to a byte vector.\n     * @param d the double that is to be packed.\n     */\n    public static byte[] packd(double d) {\n        return pack64(Double.doubleToRawLongBits(d));\n    }\n\n    /**\n     * Converts the specified byte vector to an double.\n     * @param b the byte data that is to be unpacked as an double.\n     */\n    public static double unpackd(byte[] b) {\n        return Double.longBitsToDouble(unpack64(b));\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     * @param b the byte vector to put result in.\n     * @param offset the offset at which to put result.\n     */\n    public static void packs(String s, byte[] b, int offset) {\n        byte[] p = packs(s);\n        System.arraycopy(p, 0, b, offset, p.length);\n    }\n\n    /**\n     * Converts the specified byte vector to a string.\n     * @param b the byte vector containing the packed string.\n     * @param offset the offset at which to start unpacking.\n     * @param length the number of bytes to convert.\n     */\n    public static String unpacks(byte[] b, int offset, int length) {\n        try {\n            return new String(b, offset, length, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     */\n    public static byte[] packs(String s) {\n        try {\n            return s.getBytes(\"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified byte vector to a String.\n     * @param data the byte data that is to be unpacked as a String.\n     */\n    public static String unpacks(byte[] b) {\n        try {\n            return new String(b, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/util/PackerTest14.java",
		"test_prompt": "// PackerTest14.java\npackage util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Packer}.\n* It contains ten unit test cases for the {@link Packer#packl(long)} method.\n*/\nclass PackerTest14 {"
	},
	{
		"original_code": "// Packer.java\n/* $Id: Packer.java,v 1.3 2004/04/27 19:26:22 bja Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.3 $\n *\n */\npackage util;\n\n/**\n * This class provides a set of functions for converting data types from\n * their normal representation to byte arrays.\n */\npublic class Packer {\n\n    /**\n     * Packs n shorts of the short array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack16v(short[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 2) {\n            pack16(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n shorts of the byte array b into the specified short array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack16v(byte[] b, int s, short[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 2) {\n            v[d + i] = unpack16(b, s);\n        }\n    }\n\n    public static void pack16(short x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static short unpack16(byte[] b, int offset) {\n        short y = 0;\n        y |= ((short) b[offset++] & 0xff) << 8;\n        y |= ((short) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack16(short x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 8) & 0xff);\n        b[1] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static short unpack16(byte[] b) {\n        short y = 0;\n        y |= ((short) b[0] & 0xff) << 8;\n        y |= ((short) b[1] & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n integers of the integer array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack32v(int[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 4) {\n            pack32(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n integers of the byte array b into the specified integer\n     * array v, starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack32v(byte[] b, int s, int[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 4) {\n            v[d + i] = unpack32(b, s);\n        }\n    }\n\n    public static void pack32(int x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static int unpack32(byte[] b, int offset) {\n        int y = 0;\n        y |= ((int) b[offset++] & 0xff) << 24;\n        y |= ((int) b[offset++] & 0xff) << 16;\n        y |= ((int) b[offset++] & 0xff) << 8;\n        y |= ((int) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack32(int x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 24) & 0xff);\n        b[1] = (byte) ((x >> 16) & 0xff);\n        b[2] = (byte) ((x >> 8) & 0xff);\n        b[3] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static int unpack32(byte[] b) {\n        int y = 0;\n        y |= ((int) (b[0]) & 0xff) << 24;\n        y |= ((int) (b[1]) & 0xff) << 16;\n        y |= ((int) (b[2]) & 0xff) << 8;\n        y |= ((int) (b[3]) & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n longs in the long array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack64v(long[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 8) {\n            pack64(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n longs of the byte array b into the specified long array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack64v(byte[] b, int s, long[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 8) {\n            v[d + i] = unpack64(b, s);\n        }\n    }\n\n    public static void pack64(long x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 56) & 0xff);\n        b[offset++] = (byte) ((x >> 48) & 0xff);\n        b[offset++] = (byte) ((x >> 40) & 0xff);\n        b[offset++] = (byte) ((x >> 32) & 0xff);\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static long unpack64(byte[] b, int offset) {\n        long y = 0;\n        y |= ((long) b[offset++] & 0xff) << 56;\n        y |= ((long) b[offset++] & 0xff) << 48;\n        y |= ((long) b[offset++] & 0xff) << 40;\n        y |= ((long) b[offset++] & 0xff) << 32;\n        y |= ((long) b[offset++] & 0xff) << 24;\n        y |= ((long) b[offset++] & 0xff) << 16;\n        y |= ((long) b[offset++] & 0xff) << 8;\n        y |= ((long) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack64(long x) {\n        byte[] b = new byte[8];\n        b[0] = (byte) ((x >> 56) & 0xff);\n        b[1] = (byte) ((x >> 48) & 0xff);\n        b[2] = (byte) ((x >> 40) & 0xff);\n        b[3] = (byte) ((x >> 32) & 0xff);\n        b[4] = (byte) ((x >> 24) & 0xff);\n        b[5] = (byte) ((x >> 16) & 0xff);\n        b[6] = (byte) ((x >> 8) & 0xff);\n        b[7] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static long unpack64(byte[] b) {\n        long y = 0;\n        y |= ((long) b[0] & 0xff) << 56;\n        y |= ((long) b[1] & 0xff) << 48;\n        y |= ((long) b[2] & 0xff) << 40;\n        y |= ((long) b[3] & 0xff) << 32;\n        y |= ((long) b[4] & 0xff) << 24;\n        y |= ((long) b[5] & 0xff) << 16;\n        y |= ((long) b[6] & 0xff) << 8;\n        y |= ((long) b[7] & 0xff);\n        return y;\n    }\n\n    /**\n     * Converts the specified float to four bytes.\n     * @param f the float array that is to be packed as a bytes.\n     */\n    public static byte[] packf(float f) {\n        return pack32(Float.floatToIntBits(f));\n    }\n\n    /**\n     * Converts the specified float array to an array of bytes.\n     * @param fv the float array that is to be packed as a byte array.\n     * @param start the offset in fv from which to start packing.\n     * @param count the number of floats to pack.\n     */\n    public static byte[] packfv(float[] fv, int start, int count) {\n        byte[] buf = new byte[count << 4];\n        count += start;\n        for (int i = start, j = 0; i < count; i++, j += 4) {\n            pack32(Float.floatToIntBits(fv[i]), buf, j);\n        }\n        return buf;\n    }\n\n    /**\n     * Converts the specified byte vector to an float.\n     * @param b the byte data that is to be unpacked as a float.\n     */\n    public static float unpackf(byte[] b) {\n        return Float.intBitsToFloat(unpack32(b));\n    }\n\n    /**\n     * Converts the specified integer to a byte vector.\n     * @param i the integer that is to be packed.\n     */\n    public static byte[] packi(int i) {\n        return pack32(i);\n    }\n\n    /**\n     * Converts the specified byte vector to an integer.\n     * @param b the byte data that is to be unpacked as an integer.\n     */\n    public static int unpacki(byte[] b) {\n        return unpack32(b);\n    }\n\n    /**\n     * Converts the specified long to a byte vector.\n     * @param l the long that is to be packed.\n     */\n    public static byte[] packl(long l) {\n        return pack64(l);\n    }\n\n    /**\n     * Converts the specified byte vector to a long.\n     * @param b the byte data that is to be unpacked as a long.\n     */\n    public static long unpackl(byte[] b) {\n        return unpack64(b);\n    }\n\n    /**\n     * Converts the specified double to a byte vector.\n     * @param d the double that is to be packed.\n     */\n    public static byte[] packd(double d) {\n        return pack64(Double.doubleToRawLongBits(d));\n    }\n\n    /**\n     * Converts the specified byte vector to an double.\n     * @param b the byte data that is to be unpacked as an double.\n     */\n    public static double unpackd(byte[] b) {\n        return Double.longBitsToDouble(unpack64(b));\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     * @param b the byte vector to put result in.\n     * @param offset the offset at which to put result.\n     */\n    public static void packs(String s, byte[] b, int offset) {\n        byte[] p = packs(s);\n        System.arraycopy(p, 0, b, offset, p.length);\n    }\n\n    /**\n     * Converts the specified byte vector to a string.\n     * @param b the byte vector containing the packed string.\n     * @param offset the offset at which to start unpacking.\n     * @param length the number of bytes to convert.\n     */\n    public static String unpacks(byte[] b, int offset, int length) {\n        try {\n            return new String(b, offset, length, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     */\n    public static byte[] packs(String s) {\n        try {\n            return s.getBytes(\"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified byte vector to a String.\n     * @param data the byte data that is to be unpacked as a String.\n     */\n    public static String unpacks(byte[] b) {\n        try {\n            return new String(b, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/util/PackerTest15.java",
		"test_prompt": "// PackerTest15.java\npackage util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Packer}.\n* It contains ten unit test cases for the {@link Packer#unpackl(byte[])} method.\n*/\nclass PackerTest15 {"
	},
	{
		"original_code": "// Packer.java\n/* $Id: Packer.java,v 1.3 2004/04/27 19:26:22 bja Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.3 $\n *\n */\npackage util;\n\n/**\n * This class provides a set of functions for converting data types from\n * their normal representation to byte arrays.\n */\npublic class Packer {\n\n    /**\n     * Packs n shorts of the short array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack16v(short[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 2) {\n            pack16(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n shorts of the byte array b into the specified short array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack16v(byte[] b, int s, short[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 2) {\n            v[d + i] = unpack16(b, s);\n        }\n    }\n\n    public static void pack16(short x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static short unpack16(byte[] b, int offset) {\n        short y = 0;\n        y |= ((short) b[offset++] & 0xff) << 8;\n        y |= ((short) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack16(short x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 8) & 0xff);\n        b[1] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static short unpack16(byte[] b) {\n        short y = 0;\n        y |= ((short) b[0] & 0xff) << 8;\n        y |= ((short) b[1] & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n integers of the integer array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack32v(int[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 4) {\n            pack32(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n integers of the byte array b into the specified integer\n     * array v, starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack32v(byte[] b, int s, int[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 4) {\n            v[d + i] = unpack32(b, s);\n        }\n    }\n\n    public static void pack32(int x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static int unpack32(byte[] b, int offset) {\n        int y = 0;\n        y |= ((int) b[offset++] & 0xff) << 24;\n        y |= ((int) b[offset++] & 0xff) << 16;\n        y |= ((int) b[offset++] & 0xff) << 8;\n        y |= ((int) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack32(int x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 24) & 0xff);\n        b[1] = (byte) ((x >> 16) & 0xff);\n        b[2] = (byte) ((x >> 8) & 0xff);\n        b[3] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static int unpack32(byte[] b) {\n        int y = 0;\n        y |= ((int) (b[0]) & 0xff) << 24;\n        y |= ((int) (b[1]) & 0xff) << 16;\n        y |= ((int) (b[2]) & 0xff) << 8;\n        y |= ((int) (b[3]) & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n longs in the long array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack64v(long[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 8) {\n            pack64(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n longs of the byte array b into the specified long array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack64v(byte[] b, int s, long[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 8) {\n            v[d + i] = unpack64(b, s);\n        }\n    }\n\n    public static void pack64(long x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 56) & 0xff);\n        b[offset++] = (byte) ((x >> 48) & 0xff);\n        b[offset++] = (byte) ((x >> 40) & 0xff);\n        b[offset++] = (byte) ((x >> 32) & 0xff);\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static long unpack64(byte[] b, int offset) {\n        long y = 0;\n        y |= ((long) b[offset++] & 0xff) << 56;\n        y |= ((long) b[offset++] & 0xff) << 48;\n        y |= ((long) b[offset++] & 0xff) << 40;\n        y |= ((long) b[offset++] & 0xff) << 32;\n        y |= ((long) b[offset++] & 0xff) << 24;\n        y |= ((long) b[offset++] & 0xff) << 16;\n        y |= ((long) b[offset++] & 0xff) << 8;\n        y |= ((long) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack64(long x) {\n        byte[] b = new byte[8];\n        b[0] = (byte) ((x >> 56) & 0xff);\n        b[1] = (byte) ((x >> 48) & 0xff);\n        b[2] = (byte) ((x >> 40) & 0xff);\n        b[3] = (byte) ((x >> 32) & 0xff);\n        b[4] = (byte) ((x >> 24) & 0xff);\n        b[5] = (byte) ((x >> 16) & 0xff);\n        b[6] = (byte) ((x >> 8) & 0xff);\n        b[7] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static long unpack64(byte[] b) {\n        long y = 0;\n        y |= ((long) b[0] & 0xff) << 56;\n        y |= ((long) b[1] & 0xff) << 48;\n        y |= ((long) b[2] & 0xff) << 40;\n        y |= ((long) b[3] & 0xff) << 32;\n        y |= ((long) b[4] & 0xff) << 24;\n        y |= ((long) b[5] & 0xff) << 16;\n        y |= ((long) b[6] & 0xff) << 8;\n        y |= ((long) b[7] & 0xff);\n        return y;\n    }\n\n    /**\n     * Converts the specified float to four bytes.\n     * @param f the float array that is to be packed as a bytes.\n     */\n    public static byte[] packf(float f) {\n        return pack32(Float.floatToIntBits(f));\n    }\n\n    /**\n     * Converts the specified float array to an array of bytes.\n     * @param fv the float array that is to be packed as a byte array.\n     * @param start the offset in fv from which to start packing.\n     * @param count the number of floats to pack.\n     */\n    public static byte[] packfv(float[] fv, int start, int count) {\n        byte[] buf = new byte[count << 4];\n        count += start;\n        for (int i = start, j = 0; i < count; i++, j += 4) {\n            pack32(Float.floatToIntBits(fv[i]), buf, j);\n        }\n        return buf;\n    }\n\n    /**\n     * Converts the specified byte vector to an float.\n     * @param b the byte data that is to be unpacked as a float.\n     */\n    public static float unpackf(byte[] b) {\n        return Float.intBitsToFloat(unpack32(b));\n    }\n\n    /**\n     * Converts the specified integer to a byte vector.\n     * @param i the integer that is to be packed.\n     */\n    public static byte[] packi(int i) {\n        return pack32(i);\n    }\n\n    /**\n     * Converts the specified byte vector to an integer.\n     * @param b the byte data that is to be unpacked as an integer.\n     */\n    public static int unpacki(byte[] b) {\n        return unpack32(b);\n    }\n\n    /**\n     * Converts the specified long to a byte vector.\n     * @param l the long that is to be packed.\n     */\n    public static byte[] packl(long l) {\n        return pack64(l);\n    }\n\n    /**\n     * Converts the specified byte vector to a long.\n     * @param b the byte data that is to be unpacked as a long.\n     */\n    public static long unpackl(byte[] b) {\n        return unpack64(b);\n    }\n\n    /**\n     * Converts the specified double to a byte vector.\n     * @param d the double that is to be packed.\n     */\n    public static byte[] packd(double d) {\n        return pack64(Double.doubleToRawLongBits(d));\n    }\n\n    /**\n     * Converts the specified byte vector to an double.\n     * @param b the byte data that is to be unpacked as an double.\n     */\n    public static double unpackd(byte[] b) {\n        return Double.longBitsToDouble(unpack64(b));\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     * @param b the byte vector to put result in.\n     * @param offset the offset at which to put result.\n     */\n    public static void packs(String s, byte[] b, int offset) {\n        byte[] p = packs(s);\n        System.arraycopy(p, 0, b, offset, p.length);\n    }\n\n    /**\n     * Converts the specified byte vector to a string.\n     * @param b the byte vector containing the packed string.\n     * @param offset the offset at which to start unpacking.\n     * @param length the number of bytes to convert.\n     */\n    public static String unpacks(byte[] b, int offset, int length) {\n        try {\n            return new String(b, offset, length, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     */\n    public static byte[] packs(String s) {\n        try {\n            return s.getBytes(\"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified byte vector to a String.\n     * @param data the byte data that is to be unpacked as a String.\n     */\n    public static String unpacks(byte[] b) {\n        try {\n            return new String(b, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/util/PackerTest16.java",
		"test_prompt": "// PackerTest16.java\npackage util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Packer}.\n* It contains ten unit test cases for the {@link Packer#packd(double)} method.\n*/\nclass PackerTest16 {"
	},
	{
		"original_code": "// Packer.java\n/* $Id: Packer.java,v 1.3 2004/04/27 19:26:22 bja Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.3 $\n *\n */\npackage util;\n\n/**\n * This class provides a set of functions for converting data types from\n * their normal representation to byte arrays.\n */\npublic class Packer {\n\n    /**\n     * Packs n shorts of the short array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack16v(short[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 2) {\n            pack16(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n shorts of the byte array b into the specified short array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack16v(byte[] b, int s, short[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 2) {\n            v[d + i] = unpack16(b, s);\n        }\n    }\n\n    public static void pack16(short x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static short unpack16(byte[] b, int offset) {\n        short y = 0;\n        y |= ((short) b[offset++] & 0xff) << 8;\n        y |= ((short) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack16(short x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 8) & 0xff);\n        b[1] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static short unpack16(byte[] b) {\n        short y = 0;\n        y |= ((short) b[0] & 0xff) << 8;\n        y |= ((short) b[1] & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n integers of the integer array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack32v(int[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 4) {\n            pack32(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n integers of the byte array b into the specified integer\n     * array v, starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack32v(byte[] b, int s, int[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 4) {\n            v[d + i] = unpack32(b, s);\n        }\n    }\n\n    public static void pack32(int x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static int unpack32(byte[] b, int offset) {\n        int y = 0;\n        y |= ((int) b[offset++] & 0xff) << 24;\n        y |= ((int) b[offset++] & 0xff) << 16;\n        y |= ((int) b[offset++] & 0xff) << 8;\n        y |= ((int) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack32(int x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 24) & 0xff);\n        b[1] = (byte) ((x >> 16) & 0xff);\n        b[2] = (byte) ((x >> 8) & 0xff);\n        b[3] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static int unpack32(byte[] b) {\n        int y = 0;\n        y |= ((int) (b[0]) & 0xff) << 24;\n        y |= ((int) (b[1]) & 0xff) << 16;\n        y |= ((int) (b[2]) & 0xff) << 8;\n        y |= ((int) (b[3]) & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n longs in the long array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack64v(long[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 8) {\n            pack64(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n longs of the byte array b into the specified long array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack64v(byte[] b, int s, long[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 8) {\n            v[d + i] = unpack64(b, s);\n        }\n    }\n\n    public static void pack64(long x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 56) & 0xff);\n        b[offset++] = (byte) ((x >> 48) & 0xff);\n        b[offset++] = (byte) ((x >> 40) & 0xff);\n        b[offset++] = (byte) ((x >> 32) & 0xff);\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static long unpack64(byte[] b, int offset) {\n        long y = 0;\n        y |= ((long) b[offset++] & 0xff) << 56;\n        y |= ((long) b[offset++] & 0xff) << 48;\n        y |= ((long) b[offset++] & 0xff) << 40;\n        y |= ((long) b[offset++] & 0xff) << 32;\n        y |= ((long) b[offset++] & 0xff) << 24;\n        y |= ((long) b[offset++] & 0xff) << 16;\n        y |= ((long) b[offset++] & 0xff) << 8;\n        y |= ((long) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack64(long x) {\n        byte[] b = new byte[8];\n        b[0] = (byte) ((x >> 56) & 0xff);\n        b[1] = (byte) ((x >> 48) & 0xff);\n        b[2] = (byte) ((x >> 40) & 0xff);\n        b[3] = (byte) ((x >> 32) & 0xff);\n        b[4] = (byte) ((x >> 24) & 0xff);\n        b[5] = (byte) ((x >> 16) & 0xff);\n        b[6] = (byte) ((x >> 8) & 0xff);\n        b[7] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static long unpack64(byte[] b) {\n        long y = 0;\n        y |= ((long) b[0] & 0xff) << 56;\n        y |= ((long) b[1] & 0xff) << 48;\n        y |= ((long) b[2] & 0xff) << 40;\n        y |= ((long) b[3] & 0xff) << 32;\n        y |= ((long) b[4] & 0xff) << 24;\n        y |= ((long) b[5] & 0xff) << 16;\n        y |= ((long) b[6] & 0xff) << 8;\n        y |= ((long) b[7] & 0xff);\n        return y;\n    }\n\n    /**\n     * Converts the specified float to four bytes.\n     * @param f the float array that is to be packed as a bytes.\n     */\n    public static byte[] packf(float f) {\n        return pack32(Float.floatToIntBits(f));\n    }\n\n    /**\n     * Converts the specified float array to an array of bytes.\n     * @param fv the float array that is to be packed as a byte array.\n     * @param start the offset in fv from which to start packing.\n     * @param count the number of floats to pack.\n     */\n    public static byte[] packfv(float[] fv, int start, int count) {\n        byte[] buf = new byte[count << 4];\n        count += start;\n        for (int i = start, j = 0; i < count; i++, j += 4) {\n            pack32(Float.floatToIntBits(fv[i]), buf, j);\n        }\n        return buf;\n    }\n\n    /**\n     * Converts the specified byte vector to an float.\n     * @param b the byte data that is to be unpacked as a float.\n     */\n    public static float unpackf(byte[] b) {\n        return Float.intBitsToFloat(unpack32(b));\n    }\n\n    /**\n     * Converts the specified integer to a byte vector.\n     * @param i the integer that is to be packed.\n     */\n    public static byte[] packi(int i) {\n        return pack32(i);\n    }\n\n    /**\n     * Converts the specified byte vector to an integer.\n     * @param b the byte data that is to be unpacked as an integer.\n     */\n    public static int unpacki(byte[] b) {\n        return unpack32(b);\n    }\n\n    /**\n     * Converts the specified long to a byte vector.\n     * @param l the long that is to be packed.\n     */\n    public static byte[] packl(long l) {\n        return pack64(l);\n    }\n\n    /**\n     * Converts the specified byte vector to a long.\n     * @param b the byte data that is to be unpacked as a long.\n     */\n    public static long unpackl(byte[] b) {\n        return unpack64(b);\n    }\n\n    /**\n     * Converts the specified double to a byte vector.\n     * @param d the double that is to be packed.\n     */\n    public static byte[] packd(double d) {\n        return pack64(Double.doubleToRawLongBits(d));\n    }\n\n    /**\n     * Converts the specified byte vector to an double.\n     * @param b the byte data that is to be unpacked as an double.\n     */\n    public static double unpackd(byte[] b) {\n        return Double.longBitsToDouble(unpack64(b));\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     * @param b the byte vector to put result in.\n     * @param offset the offset at which to put result.\n     */\n    public static void packs(String s, byte[] b, int offset) {\n        byte[] p = packs(s);\n        System.arraycopy(p, 0, b, offset, p.length);\n    }\n\n    /**\n     * Converts the specified byte vector to a string.\n     * @param b the byte vector containing the packed string.\n     * @param offset the offset at which to start unpacking.\n     * @param length the number of bytes to convert.\n     */\n    public static String unpacks(byte[] b, int offset, int length) {\n        try {\n            return new String(b, offset, length, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     */\n    public static byte[] packs(String s) {\n        try {\n            return s.getBytes(\"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified byte vector to a String.\n     * @param data the byte data that is to be unpacked as a String.\n     */\n    public static String unpacks(byte[] b) {\n        try {\n            return new String(b, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/util/PackerTest17.java",
		"test_prompt": "// PackerTest17.java\npackage util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Packer}.\n* It contains ten unit test cases for the {@link Packer#unpackd(byte[])} method.\n*/\nclass PackerTest17 {"
	},
	{
		"original_code": "// Packer.java\n/* $Id: Packer.java,v 1.3 2004/04/27 19:26:22 bja Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.3 $\n *\n */\npackage util;\n\n/**\n * This class provides a set of functions for converting data types from\n * their normal representation to byte arrays.\n */\npublic class Packer {\n\n    /**\n     * Packs n shorts of the short array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack16v(short[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 2) {\n            pack16(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n shorts of the byte array b into the specified short array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack16v(byte[] b, int s, short[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 2) {\n            v[d + i] = unpack16(b, s);\n        }\n    }\n\n    public static void pack16(short x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static short unpack16(byte[] b, int offset) {\n        short y = 0;\n        y |= ((short) b[offset++] & 0xff) << 8;\n        y |= ((short) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack16(short x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 8) & 0xff);\n        b[1] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static short unpack16(byte[] b) {\n        short y = 0;\n        y |= ((short) b[0] & 0xff) << 8;\n        y |= ((short) b[1] & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n integers of the integer array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack32v(int[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 4) {\n            pack32(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n integers of the byte array b into the specified integer\n     * array v, starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack32v(byte[] b, int s, int[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 4) {\n            v[d + i] = unpack32(b, s);\n        }\n    }\n\n    public static void pack32(int x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static int unpack32(byte[] b, int offset) {\n        int y = 0;\n        y |= ((int) b[offset++] & 0xff) << 24;\n        y |= ((int) b[offset++] & 0xff) << 16;\n        y |= ((int) b[offset++] & 0xff) << 8;\n        y |= ((int) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack32(int x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 24) & 0xff);\n        b[1] = (byte) ((x >> 16) & 0xff);\n        b[2] = (byte) ((x >> 8) & 0xff);\n        b[3] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static int unpack32(byte[] b) {\n        int y = 0;\n        y |= ((int) (b[0]) & 0xff) << 24;\n        y |= ((int) (b[1]) & 0xff) << 16;\n        y |= ((int) (b[2]) & 0xff) << 8;\n        y |= ((int) (b[3]) & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n longs in the long array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack64v(long[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 8) {\n            pack64(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n longs of the byte array b into the specified long array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack64v(byte[] b, int s, long[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 8) {\n            v[d + i] = unpack64(b, s);\n        }\n    }\n\n    public static void pack64(long x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 56) & 0xff);\n        b[offset++] = (byte) ((x >> 48) & 0xff);\n        b[offset++] = (byte) ((x >> 40) & 0xff);\n        b[offset++] = (byte) ((x >> 32) & 0xff);\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static long unpack64(byte[] b, int offset) {\n        long y = 0;\n        y |= ((long) b[offset++] & 0xff) << 56;\n        y |= ((long) b[offset++] & 0xff) << 48;\n        y |= ((long) b[offset++] & 0xff) << 40;\n        y |= ((long) b[offset++] & 0xff) << 32;\n        y |= ((long) b[offset++] & 0xff) << 24;\n        y |= ((long) b[offset++] & 0xff) << 16;\n        y |= ((long) b[offset++] & 0xff) << 8;\n        y |= ((long) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack64(long x) {\n        byte[] b = new byte[8];\n        b[0] = (byte) ((x >> 56) & 0xff);\n        b[1] = (byte) ((x >> 48) & 0xff);\n        b[2] = (byte) ((x >> 40) & 0xff);\n        b[3] = (byte) ((x >> 32) & 0xff);\n        b[4] = (byte) ((x >> 24) & 0xff);\n        b[5] = (byte) ((x >> 16) & 0xff);\n        b[6] = (byte) ((x >> 8) & 0xff);\n        b[7] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static long unpack64(byte[] b) {\n        long y = 0;\n        y |= ((long) b[0] & 0xff) << 56;\n        y |= ((long) b[1] & 0xff) << 48;\n        y |= ((long) b[2] & 0xff) << 40;\n        y |= ((long) b[3] & 0xff) << 32;\n        y |= ((long) b[4] & 0xff) << 24;\n        y |= ((long) b[5] & 0xff) << 16;\n        y |= ((long) b[6] & 0xff) << 8;\n        y |= ((long) b[7] & 0xff);\n        return y;\n    }\n\n    /**\n     * Converts the specified float to four bytes.\n     * @param f the float array that is to be packed as a bytes.\n     */\n    public static byte[] packf(float f) {\n        return pack32(Float.floatToIntBits(f));\n    }\n\n    /**\n     * Converts the specified float array to an array of bytes.\n     * @param fv the float array that is to be packed as a byte array.\n     * @param start the offset in fv from which to start packing.\n     * @param count the number of floats to pack.\n     */\n    public static byte[] packfv(float[] fv, int start, int count) {\n        byte[] buf = new byte[count << 4];\n        count += start;\n        for (int i = start, j = 0; i < count; i++, j += 4) {\n            pack32(Float.floatToIntBits(fv[i]), buf, j);\n        }\n        return buf;\n    }\n\n    /**\n     * Converts the specified byte vector to an float.\n     * @param b the byte data that is to be unpacked as a float.\n     */\n    public static float unpackf(byte[] b) {\n        return Float.intBitsToFloat(unpack32(b));\n    }\n\n    /**\n     * Converts the specified integer to a byte vector.\n     * @param i the integer that is to be packed.\n     */\n    public static byte[] packi(int i) {\n        return pack32(i);\n    }\n\n    /**\n     * Converts the specified byte vector to an integer.\n     * @param b the byte data that is to be unpacked as an integer.\n     */\n    public static int unpacki(byte[] b) {\n        return unpack32(b);\n    }\n\n    /**\n     * Converts the specified long to a byte vector.\n     * @param l the long that is to be packed.\n     */\n    public static byte[] packl(long l) {\n        return pack64(l);\n    }\n\n    /**\n     * Converts the specified byte vector to a long.\n     * @param b the byte data that is to be unpacked as a long.\n     */\n    public static long unpackl(byte[] b) {\n        return unpack64(b);\n    }\n\n    /**\n     * Converts the specified double to a byte vector.\n     * @param d the double that is to be packed.\n     */\n    public static byte[] packd(double d) {\n        return pack64(Double.doubleToRawLongBits(d));\n    }\n\n    /**\n     * Converts the specified byte vector to an double.\n     * @param b the byte data that is to be unpacked as an double.\n     */\n    public static double unpackd(byte[] b) {\n        return Double.longBitsToDouble(unpack64(b));\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     * @param b the byte vector to put result in.\n     * @param offset the offset at which to put result.\n     */\n    public static void packs(String s, byte[] b, int offset) {\n        byte[] p = packs(s);\n        System.arraycopy(p, 0, b, offset, p.length);\n    }\n\n    /**\n     * Converts the specified byte vector to a string.\n     * @param b the byte vector containing the packed string.\n     * @param offset the offset at which to start unpacking.\n     * @param length the number of bytes to convert.\n     */\n    public static String unpacks(byte[] b, int offset, int length) {\n        try {\n            return new String(b, offset, length, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     */\n    public static byte[] packs(String s) {\n        try {\n            return s.getBytes(\"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified byte vector to a String.\n     * @param data the byte data that is to be unpacked as a String.\n     */\n    public static String unpacks(byte[] b) {\n        try {\n            return new String(b, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/util/PackerTest18.java",
		"test_prompt": "// PackerTest18.java\npackage util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Packer}.\n* It contains ten unit test cases for the {@link Packer#unpacks(byte[], int, int)} method.\n*/\nclass PackerTest18 {"
	},
	{
		"original_code": "// Packer.java\n/* $Id: Packer.java,v 1.3 2004/04/27 19:26:22 bja Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.3 $\n *\n */\npackage util;\n\n/**\n * This class provides a set of functions for converting data types from\n * their normal representation to byte arrays.\n */\npublic class Packer {\n\n    /**\n     * Packs n shorts of the short array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack16v(short[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 2) {\n            pack16(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n shorts of the byte array b into the specified short array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack16v(byte[] b, int s, short[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 2) {\n            v[d + i] = unpack16(b, s);\n        }\n    }\n\n    public static void pack16(short x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static short unpack16(byte[] b, int offset) {\n        short y = 0;\n        y |= ((short) b[offset++] & 0xff) << 8;\n        y |= ((short) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack16(short x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 8) & 0xff);\n        b[1] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static short unpack16(byte[] b) {\n        short y = 0;\n        y |= ((short) b[0] & 0xff) << 8;\n        y |= ((short) b[1] & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n integers of the integer array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack32v(int[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 4) {\n            pack32(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n integers of the byte array b into the specified integer\n     * array v, starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack32v(byte[] b, int s, int[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 4) {\n            v[d + i] = unpack32(b, s);\n        }\n    }\n\n    public static void pack32(int x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static int unpack32(byte[] b, int offset) {\n        int y = 0;\n        y |= ((int) b[offset++] & 0xff) << 24;\n        y |= ((int) b[offset++] & 0xff) << 16;\n        y |= ((int) b[offset++] & 0xff) << 8;\n        y |= ((int) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack32(int x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 24) & 0xff);\n        b[1] = (byte) ((x >> 16) & 0xff);\n        b[2] = (byte) ((x >> 8) & 0xff);\n        b[3] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static int unpack32(byte[] b) {\n        int y = 0;\n        y |= ((int) (b[0]) & 0xff) << 24;\n        y |= ((int) (b[1]) & 0xff) << 16;\n        y |= ((int) (b[2]) & 0xff) << 8;\n        y |= ((int) (b[3]) & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n longs in the long array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack64v(long[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 8) {\n            pack64(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n longs of the byte array b into the specified long array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack64v(byte[] b, int s, long[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 8) {\n            v[d + i] = unpack64(b, s);\n        }\n    }\n\n    public static void pack64(long x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 56) & 0xff);\n        b[offset++] = (byte) ((x >> 48) & 0xff);\n        b[offset++] = (byte) ((x >> 40) & 0xff);\n        b[offset++] = (byte) ((x >> 32) & 0xff);\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static long unpack64(byte[] b, int offset) {\n        long y = 0;\n        y |= ((long) b[offset++] & 0xff) << 56;\n        y |= ((long) b[offset++] & 0xff) << 48;\n        y |= ((long) b[offset++] & 0xff) << 40;\n        y |= ((long) b[offset++] & 0xff) << 32;\n        y |= ((long) b[offset++] & 0xff) << 24;\n        y |= ((long) b[offset++] & 0xff) << 16;\n        y |= ((long) b[offset++] & 0xff) << 8;\n        y |= ((long) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack64(long x) {\n        byte[] b = new byte[8];\n        b[0] = (byte) ((x >> 56) & 0xff);\n        b[1] = (byte) ((x >> 48) & 0xff);\n        b[2] = (byte) ((x >> 40) & 0xff);\n        b[3] = (byte) ((x >> 32) & 0xff);\n        b[4] = (byte) ((x >> 24) & 0xff);\n        b[5] = (byte) ((x >> 16) & 0xff);\n        b[6] = (byte) ((x >> 8) & 0xff);\n        b[7] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static long unpack64(byte[] b) {\n        long y = 0;\n        y |= ((long) b[0] & 0xff) << 56;\n        y |= ((long) b[1] & 0xff) << 48;\n        y |= ((long) b[2] & 0xff) << 40;\n        y |= ((long) b[3] & 0xff) << 32;\n        y |= ((long) b[4] & 0xff) << 24;\n        y |= ((long) b[5] & 0xff) << 16;\n        y |= ((long) b[6] & 0xff) << 8;\n        y |= ((long) b[7] & 0xff);\n        return y;\n    }\n\n    /**\n     * Converts the specified float to four bytes.\n     * @param f the float array that is to be packed as a bytes.\n     */\n    public static byte[] packf(float f) {\n        return pack32(Float.floatToIntBits(f));\n    }\n\n    /**\n     * Converts the specified float array to an array of bytes.\n     * @param fv the float array that is to be packed as a byte array.\n     * @param start the offset in fv from which to start packing.\n     * @param count the number of floats to pack.\n     */\n    public static byte[] packfv(float[] fv, int start, int count) {\n        byte[] buf = new byte[count << 4];\n        count += start;\n        for (int i = start, j = 0; i < count; i++, j += 4) {\n            pack32(Float.floatToIntBits(fv[i]), buf, j);\n        }\n        return buf;\n    }\n\n    /**\n     * Converts the specified byte vector to an float.\n     * @param b the byte data that is to be unpacked as a float.\n     */\n    public static float unpackf(byte[] b) {\n        return Float.intBitsToFloat(unpack32(b));\n    }\n\n    /**\n     * Converts the specified integer to a byte vector.\n     * @param i the integer that is to be packed.\n     */\n    public static byte[] packi(int i) {\n        return pack32(i);\n    }\n\n    /**\n     * Converts the specified byte vector to an integer.\n     * @param b the byte data that is to be unpacked as an integer.\n     */\n    public static int unpacki(byte[] b) {\n        return unpack32(b);\n    }\n\n    /**\n     * Converts the specified long to a byte vector.\n     * @param l the long that is to be packed.\n     */\n    public static byte[] packl(long l) {\n        return pack64(l);\n    }\n\n    /**\n     * Converts the specified byte vector to a long.\n     * @param b the byte data that is to be unpacked as a long.\n     */\n    public static long unpackl(byte[] b) {\n        return unpack64(b);\n    }\n\n    /**\n     * Converts the specified double to a byte vector.\n     * @param d the double that is to be packed.\n     */\n    public static byte[] packd(double d) {\n        return pack64(Double.doubleToRawLongBits(d));\n    }\n\n    /**\n     * Converts the specified byte vector to an double.\n     * @param b the byte data that is to be unpacked as an double.\n     */\n    public static double unpackd(byte[] b) {\n        return Double.longBitsToDouble(unpack64(b));\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     * @param b the byte vector to put result in.\n     * @param offset the offset at which to put result.\n     */\n    public static void packs(String s, byte[] b, int offset) {\n        byte[] p = packs(s);\n        System.arraycopy(p, 0, b, offset, p.length);\n    }\n\n    /**\n     * Converts the specified byte vector to a string.\n     * @param b the byte vector containing the packed string.\n     * @param offset the offset at which to start unpacking.\n     * @param length the number of bytes to convert.\n     */\n    public static String unpacks(byte[] b, int offset, int length) {\n        try {\n            return new String(b, offset, length, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     */\n    public static byte[] packs(String s) {\n        try {\n            return s.getBytes(\"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified byte vector to a String.\n     * @param data the byte data that is to be unpacked as a String.\n     */\n    public static String unpacks(byte[] b) {\n        try {\n            return new String(b, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/util/PackerTest19.java",
		"test_prompt": "// PackerTest19.java\npackage util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Packer}.\n* It contains ten unit test cases for the {@link Packer#packs(String)} method.\n*/\nclass PackerTest19 {"
	},
	{
		"original_code": "// Packer.java\n/* $Id: Packer.java,v 1.3 2004/04/27 19:26:22 bja Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.3 $\n *\n */\npackage util;\n\n/**\n * This class provides a set of functions for converting data types from\n * their normal representation to byte arrays.\n */\npublic class Packer {\n\n    /**\n     * Packs n shorts of the short array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack16v(short[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 2) {\n            pack16(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n shorts of the byte array b into the specified short array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack16v(byte[] b, int s, short[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 2) {\n            v[d + i] = unpack16(b, s);\n        }\n    }\n\n    public static void pack16(short x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static short unpack16(byte[] b, int offset) {\n        short y = 0;\n        y |= ((short) b[offset++] & 0xff) << 8;\n        y |= ((short) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack16(short x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 8) & 0xff);\n        b[1] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static short unpack16(byte[] b) {\n        short y = 0;\n        y |= ((short) b[0] & 0xff) << 8;\n        y |= ((short) b[1] & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n integers of the integer array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack32v(int[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 4) {\n            pack32(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n integers of the byte array b into the specified integer\n     * array v, starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack32v(byte[] b, int s, int[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 4) {\n            v[d + i] = unpack32(b, s);\n        }\n    }\n\n    public static void pack32(int x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static int unpack32(byte[] b, int offset) {\n        int y = 0;\n        y |= ((int) b[offset++] & 0xff) << 24;\n        y |= ((int) b[offset++] & 0xff) << 16;\n        y |= ((int) b[offset++] & 0xff) << 8;\n        y |= ((int) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack32(int x) {\n        byte[] b = new byte[4];\n        b[0] = (byte) ((x >> 24) & 0xff);\n        b[1] = (byte) ((x >> 16) & 0xff);\n        b[2] = (byte) ((x >> 8) & 0xff);\n        b[3] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static int unpack32(byte[] b) {\n        int y = 0;\n        y |= ((int) (b[0]) & 0xff) << 24;\n        y |= ((int) (b[1]) & 0xff) << 16;\n        y |= ((int) (b[2]) & 0xff) << 8;\n        y |= ((int) (b[3]) & 0xff);\n        return y;\n    }\n\n    /**\n     * Packs n longs in the long array v into the specified byte array b,\n     * starting at position s and putting result starting at d.\n     *\n     * @param v source array.\n     * @param s source offset.\n     * @param d destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void pack64v(long[] v, int s, byte[] b, int d, int n) {\n        for (int i = 0; i < n; i++, d += 8) {\n            pack64(v[s + i], b, d);\n        }\n    }\n\n    /**\n     * Unpacks n longs of the byte array b into the specified long array v,\n     * starting at position s and putting result starting at d.\n     *\n     * @param b source array.\n     * @param s source offset.\n     * @param v destination array.\n     * @param d destination offset.\n     * @param n number of values to convert.\n     */\n    public static void unpack64v(byte[] b, int s, long[] v, int d, int n) {\n        for (int i = 0; i < n; i++, s += 8) {\n            v[d + i] = unpack64(b, s);\n        }\n    }\n\n    public static void pack64(long x, byte[] b, int offset) {\n        b[offset++] = (byte) ((x >> 56) & 0xff);\n        b[offset++] = (byte) ((x >> 48) & 0xff);\n        b[offset++] = (byte) ((x >> 40) & 0xff);\n        b[offset++] = (byte) ((x >> 32) & 0xff);\n        b[offset++] = (byte) ((x >> 24) & 0xff);\n        b[offset++] = (byte) ((x >> 16) & 0xff);\n        b[offset++] = (byte) ((x >> 8) & 0xff);\n        b[offset++] = (byte) ((x) & 0xff);\n    }\n\n    public static long unpack64(byte[] b, int offset) {\n        long y = 0;\n        y |= ((long) b[offset++] & 0xff) << 56;\n        y |= ((long) b[offset++] & 0xff) << 48;\n        y |= ((long) b[offset++] & 0xff) << 40;\n        y |= ((long) b[offset++] & 0xff) << 32;\n        y |= ((long) b[offset++] & 0xff) << 24;\n        y |= ((long) b[offset++] & 0xff) << 16;\n        y |= ((long) b[offset++] & 0xff) << 8;\n        y |= ((long) b[offset++] & 0xff);\n        return y;\n    }\n\n    public static byte[] pack64(long x) {\n        byte[] b = new byte[8];\n        b[0] = (byte) ((x >> 56) & 0xff);\n        b[1] = (byte) ((x >> 48) & 0xff);\n        b[2] = (byte) ((x >> 40) & 0xff);\n        b[3] = (byte) ((x >> 32) & 0xff);\n        b[4] = (byte) ((x >> 24) & 0xff);\n        b[5] = (byte) ((x >> 16) & 0xff);\n        b[6] = (byte) ((x >> 8) & 0xff);\n        b[7] = (byte) ((x) & 0xff);\n        return b;\n    }\n\n    public static long unpack64(byte[] b) {\n        long y = 0;\n        y |= ((long) b[0] & 0xff) << 56;\n        y |= ((long) b[1] & 0xff) << 48;\n        y |= ((long) b[2] & 0xff) << 40;\n        y |= ((long) b[3] & 0xff) << 32;\n        y |= ((long) b[4] & 0xff) << 24;\n        y |= ((long) b[5] & 0xff) << 16;\n        y |= ((long) b[6] & 0xff) << 8;\n        y |= ((long) b[7] & 0xff);\n        return y;\n    }\n\n    /**\n     * Converts the specified float to four bytes.\n     * @param f the float array that is to be packed as a bytes.\n     */\n    public static byte[] packf(float f) {\n        return pack32(Float.floatToIntBits(f));\n    }\n\n    /**\n     * Converts the specified float array to an array of bytes.\n     * @param fv the float array that is to be packed as a byte array.\n     * @param start the offset in fv from which to start packing.\n     * @param count the number of floats to pack.\n     */\n    public static byte[] packfv(float[] fv, int start, int count) {\n        byte[] buf = new byte[count << 4];\n        count += start;\n        for (int i = start, j = 0; i < count; i++, j += 4) {\n            pack32(Float.floatToIntBits(fv[i]), buf, j);\n        }\n        return buf;\n    }\n\n    /**\n     * Converts the specified byte vector to an float.\n     * @param b the byte data that is to be unpacked as a float.\n     */\n    public static float unpackf(byte[] b) {\n        return Float.intBitsToFloat(unpack32(b));\n    }\n\n    /**\n     * Converts the specified integer to a byte vector.\n     * @param i the integer that is to be packed.\n     */\n    public static byte[] packi(int i) {\n        return pack32(i);\n    }\n\n    /**\n     * Converts the specified byte vector to an integer.\n     * @param b the byte data that is to be unpacked as an integer.\n     */\n    public static int unpacki(byte[] b) {\n        return unpack32(b);\n    }\n\n    /**\n     * Converts the specified long to a byte vector.\n     * @param l the long that is to be packed.\n     */\n    public static byte[] packl(long l) {\n        return pack64(l);\n    }\n\n    /**\n     * Converts the specified byte vector to a long.\n     * @param b the byte data that is to be unpacked as a long.\n     */\n    public static long unpackl(byte[] b) {\n        return unpack64(b);\n    }\n\n    /**\n     * Converts the specified double to a byte vector.\n     * @param d the double that is to be packed.\n     */\n    public static byte[] packd(double d) {\n        return pack64(Double.doubleToRawLongBits(d));\n    }\n\n    /**\n     * Converts the specified byte vector to an double.\n     * @param b the byte data that is to be unpacked as an double.\n     */\n    public static double unpackd(byte[] b) {\n        return Double.longBitsToDouble(unpack64(b));\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     * @param b the byte vector to put result in.\n     * @param offset the offset at which to put result.\n     */\n    public static void packs(String s, byte[] b, int offset) {\n        byte[] p = packs(s);\n        System.arraycopy(p, 0, b, offset, p.length);\n    }\n\n    /**\n     * Converts the specified byte vector to a string.\n     * @param b the byte vector containing the packed string.\n     * @param offset the offset at which to start unpacking.\n     * @param length the number of bytes to convert.\n     */\n    public static String unpacks(byte[] b, int offset, int length) {\n        try {\n            return new String(b, offset, length, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified string to a byte vector.\n     * @param s the string that is to be packed.\n     */\n    public static byte[] packs(String s) {\n        try {\n            return s.getBytes(\"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n\n    /**\n     * Converts the specified byte vector to a String.\n     * @param data the byte data that is to be unpacked as a String.\n     */\n    public static String unpacks(byte[] b) {\n        try {\n            return new String(b, \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            /* all jvm:s support UTF-8 */\n        }\n        return null;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/util/PackerTest20.java",
		"test_prompt": "// PackerTest20.java\npackage util;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Packer}.\n* It contains ten unit test cases for the {@link Packer#unpacks(byte[])} method.\n*/\nclass PackerTest20 {"
	},
	{
		"original_code": "// MessageFactory.java\n/* $Id: MessageFactory.java,v 1.2 2004/04/27 19:26:21 bja Exp $ */\npackage module;\n\nimport util.AbstractFactory;\nimport module.Message;\nimport java.util.ResourceBundle;\n\n/**\n * This class provides methods for creating Messages of various kind.\n * Messages created by this factory are managed, that is instances are\n * reused after they have been used.\n */\npublic class MessageFactory extends AbstractFactory<Message> {\n\n    /**\n     * The reference to the MessageFactory instance.\n     */\n    protected static MessageFactory instance = null;\n\n    /**\n     * Creates a new instance of the MessageFactory class.\n     */\n    private MessageFactory() {\n        super(new Message());\n        this.instance = this;\n    }\n\n    /**\n     * Returns a reference to new empty message. The message topic and\n     * data is set to null. The recipient field is set to default \"*\".\n     */\n    public Message createMessage() {\n        return createMessage(null, \"*\", null);\n    }\n\n    /**\n     * Returns the MessageFactory instance, currently the instance\n     * returned is that of the last created MessageFactory.\n     */\n    public static MessageFactory getInstance() {\n        return instance != null ? instance : new MessageFactory();\n    }\n\n    /**\n     * Create a new Message instance with the specified topic and data.\n     *\n     * @param topic The topic this messages is published to.\n     * @param data The data associated with this message.\n     */\n    public static Message createMessage(String topic, Object data) {\n        return createMessage(topic, \"*\", data);\n    }\n\n    /**\n     * Create a new Message instance with the specified topic,\n     * recipient, and data.\n     *\n     * @param topic The topic this messages is published to.\n     * @param recip The recipient of this message.\n     * @param data The data associated with this message.\n     */\n    public static Message createMessage(String topic, String recip, Object data) {\n        Message msg = getInstance().createObject();\n        msg.set(topic, recip, data);\n        return msg;\n    }\n\n    public static Message createUnloadMessage(String name) {\n        return createMessage(\"KERNEL\", \"UNLOAD \" + name);\n    }\n\n    /**\n     * @param localeKey\n     * @param args\n     */\n    public static Message createWarningMessage(String localeKey, Object... args) {\n        Message msg = getInstance().createObject();\n        try {\n            ResourceBundle bundle = ResourceBundle.getBundle(\"gangup\");\n            msg.set(\"WARNING\", \"*\", String.format(bundle.getString(localeKey), args));\n        } catch (Exception e) {\n            msg.set(\"WARNING\", \"*\", \"Reading string from locale failed: key=\" + localeKey + \"\\n\" + \"This probably means that you have an old or otherwise\\n\" + \"inaccurate locale file (maybe it's missing altogether)\\n\" + \"or that the classpath does not contain the directory.\");\n        }\n        return msg;\n    }\n\n    /**\n     * @param localeKey\n     * @param args\n     */\n    public static Message createErrorMessage(String localeKey, Object... args) {\n        Message msg = createWarningMessage(localeKey, args);\n        msg.setHeader(\"ERROR\");\n        return msg;\n    }\n\n    /**\n     * @param id\n     * @param addr\n     */\n    public static Message createConnectionDroppedMessage(int id, String addr) {\n        Message msg = getInstance().createObject();\n        msg.set(\"DROPPED\", \"*\", \"ID: \" + id + \" IP: \" + addr);\n        return msg;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/module/MessageFactoryTest0.java",
		"test_prompt": "// MessageFactoryTest0.java\npackage module;\n\nimport util.AbstractFactory;\nimport module.Message;\nimport java.util.ResourceBundle;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MessageFactory}.\n* It contains ten unit test cases for the {@link MessageFactory#createMessage()} method.\n*/\nclass MessageFactoryTest0 {"
	},
	{
		"original_code": "// MessageFactory.java\n/* $Id: MessageFactory.java,v 1.2 2004/04/27 19:26:21 bja Exp $ */\npackage module;\n\nimport util.AbstractFactory;\nimport module.Message;\nimport java.util.ResourceBundle;\n\n/**\n * This class provides methods for creating Messages of various kind.\n * Messages created by this factory are managed, that is instances are\n * reused after they have been used.\n */\npublic class MessageFactory extends AbstractFactory<Message> {\n\n    /**\n     * The reference to the MessageFactory instance.\n     */\n    protected static MessageFactory instance = null;\n\n    /**\n     * Creates a new instance of the MessageFactory class.\n     */\n    private MessageFactory() {\n        super(new Message());\n        this.instance = this;\n    }\n\n    /**\n     * Returns a reference to new empty message. The message topic and\n     * data is set to null. The recipient field is set to default \"*\".\n     */\n    public Message createMessage() {\n        return createMessage(null, \"*\", null);\n    }\n\n    /**\n     * Returns the MessageFactory instance, currently the instance\n     * returned is that of the last created MessageFactory.\n     */\n    public static MessageFactory getInstance() {\n        return instance != null ? instance : new MessageFactory();\n    }\n\n    /**\n     * Create a new Message instance with the specified topic and data.\n     *\n     * @param topic The topic this messages is published to.\n     * @param data The data associated with this message.\n     */\n    public static Message createMessage(String topic, Object data) {\n        return createMessage(topic, \"*\", data);\n    }\n\n    /**\n     * Create a new Message instance with the specified topic,\n     * recipient, and data.\n     *\n     * @param topic The topic this messages is published to.\n     * @param recip The recipient of this message.\n     * @param data The data associated with this message.\n     */\n    public static Message createMessage(String topic, String recip, Object data) {\n        Message msg = getInstance().createObject();\n        msg.set(topic, recip, data);\n        return msg;\n    }\n\n    public static Message createUnloadMessage(String name) {\n        return createMessage(\"KERNEL\", \"UNLOAD \" + name);\n    }\n\n    /**\n     * @param localeKey\n     * @param args\n     */\n    public static Message createWarningMessage(String localeKey, Object... args) {\n        Message msg = getInstance().createObject();\n        try {\n            ResourceBundle bundle = ResourceBundle.getBundle(\"gangup\");\n            msg.set(\"WARNING\", \"*\", String.format(bundle.getString(localeKey), args));\n        } catch (Exception e) {\n            msg.set(\"WARNING\", \"*\", \"Reading string from locale failed: key=\" + localeKey + \"\\n\" + \"This probably means that you have an old or otherwise\\n\" + \"inaccurate locale file (maybe it's missing altogether)\\n\" + \"or that the classpath does not contain the directory.\");\n        }\n        return msg;\n    }\n\n    /**\n     * @param localeKey\n     * @param args\n     */\n    public static Message createErrorMessage(String localeKey, Object... args) {\n        Message msg = createWarningMessage(localeKey, args);\n        msg.setHeader(\"ERROR\");\n        return msg;\n    }\n\n    /**\n     * @param id\n     * @param addr\n     */\n    public static Message createConnectionDroppedMessage(int id, String addr) {\n        Message msg = getInstance().createObject();\n        msg.set(\"DROPPED\", \"*\", \"ID: \" + id + \" IP: \" + addr);\n        return msg;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/module/MessageFactoryTest1.java",
		"test_prompt": "// MessageFactoryTest1.java\npackage module;\n\nimport util.AbstractFactory;\nimport module.Message;\nimport java.util.ResourceBundle;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MessageFactory}.\n* It contains ten unit test cases for the {@link MessageFactory#getInstance()} method.\n*/\nclass MessageFactoryTest1 {"
	},
	{
		"original_code": "// MessageFactory.java\n/* $Id: MessageFactory.java,v 1.2 2004/04/27 19:26:21 bja Exp $ */\npackage module;\n\nimport util.AbstractFactory;\nimport module.Message;\nimport java.util.ResourceBundle;\n\n/**\n * This class provides methods for creating Messages of various kind.\n * Messages created by this factory are managed, that is instances are\n * reused after they have been used.\n */\npublic class MessageFactory extends AbstractFactory<Message> {\n\n    /**\n     * The reference to the MessageFactory instance.\n     */\n    protected static MessageFactory instance = null;\n\n    /**\n     * Creates a new instance of the MessageFactory class.\n     */\n    private MessageFactory() {\n        super(new Message());\n        this.instance = this;\n    }\n\n    /**\n     * Returns a reference to new empty message. The message topic and\n     * data is set to null. The recipient field is set to default \"*\".\n     */\n    public Message createMessage() {\n        return createMessage(null, \"*\", null);\n    }\n\n    /**\n     * Returns the MessageFactory instance, currently the instance\n     * returned is that of the last created MessageFactory.\n     */\n    public static MessageFactory getInstance() {\n        return instance != null ? instance : new MessageFactory();\n    }\n\n    /**\n     * Create a new Message instance with the specified topic and data.\n     *\n     * @param topic The topic this messages is published to.\n     * @param data The data associated with this message.\n     */\n    public static Message createMessage(String topic, Object data) {\n        return createMessage(topic, \"*\", data);\n    }\n\n    /**\n     * Create a new Message instance with the specified topic,\n     * recipient, and data.\n     *\n     * @param topic The topic this messages is published to.\n     * @param recip The recipient of this message.\n     * @param data The data associated with this message.\n     */\n    public static Message createMessage(String topic, String recip, Object data) {\n        Message msg = getInstance().createObject();\n        msg.set(topic, recip, data);\n        return msg;\n    }\n\n    public static Message createUnloadMessage(String name) {\n        return createMessage(\"KERNEL\", \"UNLOAD \" + name);\n    }\n\n    /**\n     * @param localeKey\n     * @param args\n     */\n    public static Message createWarningMessage(String localeKey, Object... args) {\n        Message msg = getInstance().createObject();\n        try {\n            ResourceBundle bundle = ResourceBundle.getBundle(\"gangup\");\n            msg.set(\"WARNING\", \"*\", String.format(bundle.getString(localeKey), args));\n        } catch (Exception e) {\n            msg.set(\"WARNING\", \"*\", \"Reading string from locale failed: key=\" + localeKey + \"\\n\" + \"This probably means that you have an old or otherwise\\n\" + \"inaccurate locale file (maybe it's missing altogether)\\n\" + \"or that the classpath does not contain the directory.\");\n        }\n        return msg;\n    }\n\n    /**\n     * @param localeKey\n     * @param args\n     */\n    public static Message createErrorMessage(String localeKey, Object... args) {\n        Message msg = createWarningMessage(localeKey, args);\n        msg.setHeader(\"ERROR\");\n        return msg;\n    }\n\n    /**\n     * @param id\n     * @param addr\n     */\n    public static Message createConnectionDroppedMessage(int id, String addr) {\n        Message msg = getInstance().createObject();\n        msg.set(\"DROPPED\", \"*\", \"ID: \" + id + \" IP: \" + addr);\n        return msg;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/module/MessageFactoryTest2.java",
		"test_prompt": "// MessageFactoryTest2.java\npackage module;\n\nimport util.AbstractFactory;\nimport module.Message;\nimport java.util.ResourceBundle;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MessageFactory}.\n* It contains ten unit test cases for the {@link MessageFactory#createMessage(String, Object)} method.\n*/\nclass MessageFactoryTest2 {"
	},
	{
		"original_code": "// MessageFactory.java\n/* $Id: MessageFactory.java,v 1.2 2004/04/27 19:26:21 bja Exp $ */\npackage module;\n\nimport util.AbstractFactory;\nimport module.Message;\nimport java.util.ResourceBundle;\n\n/**\n * This class provides methods for creating Messages of various kind.\n * Messages created by this factory are managed, that is instances are\n * reused after they have been used.\n */\npublic class MessageFactory extends AbstractFactory<Message> {\n\n    /**\n     * The reference to the MessageFactory instance.\n     */\n    protected static MessageFactory instance = null;\n\n    /**\n     * Creates a new instance of the MessageFactory class.\n     */\n    private MessageFactory() {\n        super(new Message());\n        this.instance = this;\n    }\n\n    /**\n     * Returns a reference to new empty message. The message topic and\n     * data is set to null. The recipient field is set to default \"*\".\n     */\n    public Message createMessage() {\n        return createMessage(null, \"*\", null);\n    }\n\n    /**\n     * Returns the MessageFactory instance, currently the instance\n     * returned is that of the last created MessageFactory.\n     */\n    public static MessageFactory getInstance() {\n        return instance != null ? instance : new MessageFactory();\n    }\n\n    /**\n     * Create a new Message instance with the specified topic and data.\n     *\n     * @param topic The topic this messages is published to.\n     * @param data The data associated with this message.\n     */\n    public static Message createMessage(String topic, Object data) {\n        return createMessage(topic, \"*\", data);\n    }\n\n    /**\n     * Create a new Message instance with the specified topic,\n     * recipient, and data.\n     *\n     * @param topic The topic this messages is published to.\n     * @param recip The recipient of this message.\n     * @param data The data associated with this message.\n     */\n    public static Message createMessage(String topic, String recip, Object data) {\n        Message msg = getInstance().createObject();\n        msg.set(topic, recip, data);\n        return msg;\n    }\n\n    public static Message createUnloadMessage(String name) {\n        return createMessage(\"KERNEL\", \"UNLOAD \" + name);\n    }\n\n    /**\n     * @param localeKey\n     * @param args\n     */\n    public static Message createWarningMessage(String localeKey, Object... args) {\n        Message msg = getInstance().createObject();\n        try {\n            ResourceBundle bundle = ResourceBundle.getBundle(\"gangup\");\n            msg.set(\"WARNING\", \"*\", String.format(bundle.getString(localeKey), args));\n        } catch (Exception e) {\n            msg.set(\"WARNING\", \"*\", \"Reading string from locale failed: key=\" + localeKey + \"\\n\" + \"This probably means that you have an old or otherwise\\n\" + \"inaccurate locale file (maybe it's missing altogether)\\n\" + \"or that the classpath does not contain the directory.\");\n        }\n        return msg;\n    }\n\n    /**\n     * @param localeKey\n     * @param args\n     */\n    public static Message createErrorMessage(String localeKey, Object... args) {\n        Message msg = createWarningMessage(localeKey, args);\n        msg.setHeader(\"ERROR\");\n        return msg;\n    }\n\n    /**\n     * @param id\n     * @param addr\n     */\n    public static Message createConnectionDroppedMessage(int id, String addr) {\n        Message msg = getInstance().createObject();\n        msg.set(\"DROPPED\", \"*\", \"ID: \" + id + \" IP: \" + addr);\n        return msg;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/module/MessageFactoryTest3.java",
		"test_prompt": "// MessageFactoryTest3.java\npackage module;\n\nimport util.AbstractFactory;\nimport module.Message;\nimport java.util.ResourceBundle;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MessageFactory}.\n* It contains ten unit test cases for the {@link MessageFactory#createMessage(String, String, Object)} method.\n*/\nclass MessageFactoryTest3 {"
	},
	{
		"original_code": "// MessageFactory.java\n/* $Id: MessageFactory.java,v 1.2 2004/04/27 19:26:21 bja Exp $ */\npackage module;\n\nimport util.AbstractFactory;\nimport module.Message;\nimport java.util.ResourceBundle;\n\n/**\n * This class provides methods for creating Messages of various kind.\n * Messages created by this factory are managed, that is instances are\n * reused after they have been used.\n */\npublic class MessageFactory extends AbstractFactory<Message> {\n\n    /**\n     * The reference to the MessageFactory instance.\n     */\n    protected static MessageFactory instance = null;\n\n    /**\n     * Creates a new instance of the MessageFactory class.\n     */\n    private MessageFactory() {\n        super(new Message());\n        this.instance = this;\n    }\n\n    /**\n     * Returns a reference to new empty message. The message topic and\n     * data is set to null. The recipient field is set to default \"*\".\n     */\n    public Message createMessage() {\n        return createMessage(null, \"*\", null);\n    }\n\n    /**\n     * Returns the MessageFactory instance, currently the instance\n     * returned is that of the last created MessageFactory.\n     */\n    public static MessageFactory getInstance() {\n        return instance != null ? instance : new MessageFactory();\n    }\n\n    /**\n     * Create a new Message instance with the specified topic and data.\n     *\n     * @param topic The topic this messages is published to.\n     * @param data The data associated with this message.\n     */\n    public static Message createMessage(String topic, Object data) {\n        return createMessage(topic, \"*\", data);\n    }\n\n    /**\n     * Create a new Message instance with the specified topic,\n     * recipient, and data.\n     *\n     * @param topic The topic this messages is published to.\n     * @param recip The recipient of this message.\n     * @param data The data associated with this message.\n     */\n    public static Message createMessage(String topic, String recip, Object data) {\n        Message msg = getInstance().createObject();\n        msg.set(topic, recip, data);\n        return msg;\n    }\n\n    public static Message createUnloadMessage(String name) {\n        return createMessage(\"KERNEL\", \"UNLOAD \" + name);\n    }\n\n    /**\n     * @param localeKey\n     * @param args\n     */\n    public static Message createWarningMessage(String localeKey, Object... args) {\n        Message msg = getInstance().createObject();\n        try {\n            ResourceBundle bundle = ResourceBundle.getBundle(\"gangup\");\n            msg.set(\"WARNING\", \"*\", String.format(bundle.getString(localeKey), args));\n        } catch (Exception e) {\n            msg.set(\"WARNING\", \"*\", \"Reading string from locale failed: key=\" + localeKey + \"\\n\" + \"This probably means that you have an old or otherwise\\n\" + \"inaccurate locale file (maybe it's missing altogether)\\n\" + \"or that the classpath does not contain the directory.\");\n        }\n        return msg;\n    }\n\n    /**\n     * @param localeKey\n     * @param args\n     */\n    public static Message createErrorMessage(String localeKey, Object... args) {\n        Message msg = createWarningMessage(localeKey, args);\n        msg.setHeader(\"ERROR\");\n        return msg;\n    }\n\n    /**\n     * @param id\n     * @param addr\n     */\n    public static Message createConnectionDroppedMessage(int id, String addr) {\n        Message msg = getInstance().createObject();\n        msg.set(\"DROPPED\", \"*\", \"ID: \" + id + \" IP: \" + addr);\n        return msg;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/module/MessageFactoryTest4.java",
		"test_prompt": "// MessageFactoryTest4.java\npackage module;\n\nimport util.AbstractFactory;\nimport module.Message;\nimport java.util.ResourceBundle;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MessageFactory}.\n* It contains ten unit test cases for the {@link MessageFactory#createUnloadMessage(String)} method.\n*/\nclass MessageFactoryTest4 {"
	},
	{
		"original_code": "// MessageFactory.java\n/* $Id: MessageFactory.java,v 1.2 2004/04/27 19:26:21 bja Exp $ */\npackage module;\n\nimport util.AbstractFactory;\nimport module.Message;\nimport java.util.ResourceBundle;\n\n/**\n * This class provides methods for creating Messages of various kind.\n * Messages created by this factory are managed, that is instances are\n * reused after they have been used.\n */\npublic class MessageFactory extends AbstractFactory<Message> {\n\n    /**\n     * The reference to the MessageFactory instance.\n     */\n    protected static MessageFactory instance = null;\n\n    /**\n     * Creates a new instance of the MessageFactory class.\n     */\n    private MessageFactory() {\n        super(new Message());\n        this.instance = this;\n    }\n\n    /**\n     * Returns a reference to new empty message. The message topic and\n     * data is set to null. The recipient field is set to default \"*\".\n     */\n    public Message createMessage() {\n        return createMessage(null, \"*\", null);\n    }\n\n    /**\n     * Returns the MessageFactory instance, currently the instance\n     * returned is that of the last created MessageFactory.\n     */\n    public static MessageFactory getInstance() {\n        return instance != null ? instance : new MessageFactory();\n    }\n\n    /**\n     * Create a new Message instance with the specified topic and data.\n     *\n     * @param topic The topic this messages is published to.\n     * @param data The data associated with this message.\n     */\n    public static Message createMessage(String topic, Object data) {\n        return createMessage(topic, \"*\", data);\n    }\n\n    /**\n     * Create a new Message instance with the specified topic,\n     * recipient, and data.\n     *\n     * @param topic The topic this messages is published to.\n     * @param recip The recipient of this message.\n     * @param data The data associated with this message.\n     */\n    public static Message createMessage(String topic, String recip, Object data) {\n        Message msg = getInstance().createObject();\n        msg.set(topic, recip, data);\n        return msg;\n    }\n\n    public static Message createUnloadMessage(String name) {\n        return createMessage(\"KERNEL\", \"UNLOAD \" + name);\n    }\n\n    /**\n     * @param localeKey\n     * @param args\n     */\n    public static Message createWarningMessage(String localeKey, Object... args) {\n        Message msg = getInstance().createObject();\n        try {\n            ResourceBundle bundle = ResourceBundle.getBundle(\"gangup\");\n            msg.set(\"WARNING\", \"*\", String.format(bundle.getString(localeKey), args));\n        } catch (Exception e) {\n            msg.set(\"WARNING\", \"*\", \"Reading string from locale failed: key=\" + localeKey + \"\\n\" + \"This probably means that you have an old or otherwise\\n\" + \"inaccurate locale file (maybe it's missing altogether)\\n\" + \"or that the classpath does not contain the directory.\");\n        }\n        return msg;\n    }\n\n    /**\n     * @param localeKey\n     * @param args\n     */\n    public static Message createErrorMessage(String localeKey, Object... args) {\n        Message msg = createWarningMessage(localeKey, args);\n        msg.setHeader(\"ERROR\");\n        return msg;\n    }\n\n    /**\n     * @param id\n     * @param addr\n     */\n    public static Message createConnectionDroppedMessage(int id, String addr) {\n        Message msg = getInstance().createObject();\n        msg.set(\"DROPPED\", \"*\", \"ID: \" + id + \" IP: \" + addr);\n        return msg;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/module/MessageFactoryTest5.java",
		"test_prompt": "// MessageFactoryTest5.java\npackage module;\n\nimport util.AbstractFactory;\nimport module.Message;\nimport java.util.ResourceBundle;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MessageFactory}.\n* It contains ten unit test cases for the {@link MessageFactory#createWarningMessage(String, Object[])} method.\n*/\nclass MessageFactoryTest5 {"
	},
	{
		"original_code": "// MessageFactory.java\n/* $Id: MessageFactory.java,v 1.2 2004/04/27 19:26:21 bja Exp $ */\npackage module;\n\nimport util.AbstractFactory;\nimport module.Message;\nimport java.util.ResourceBundle;\n\n/**\n * This class provides methods for creating Messages of various kind.\n * Messages created by this factory are managed, that is instances are\n * reused after they have been used.\n */\npublic class MessageFactory extends AbstractFactory<Message> {\n\n    /**\n     * The reference to the MessageFactory instance.\n     */\n    protected static MessageFactory instance = null;\n\n    /**\n     * Creates a new instance of the MessageFactory class.\n     */\n    private MessageFactory() {\n        super(new Message());\n        this.instance = this;\n    }\n\n    /**\n     * Returns a reference to new empty message. The message topic and\n     * data is set to null. The recipient field is set to default \"*\".\n     */\n    public Message createMessage() {\n        return createMessage(null, \"*\", null);\n    }\n\n    /**\n     * Returns the MessageFactory instance, currently the instance\n     * returned is that of the last created MessageFactory.\n     */\n    public static MessageFactory getInstance() {\n        return instance != null ? instance : new MessageFactory();\n    }\n\n    /**\n     * Create a new Message instance with the specified topic and data.\n     *\n     * @param topic The topic this messages is published to.\n     * @param data The data associated with this message.\n     */\n    public static Message createMessage(String topic, Object data) {\n        return createMessage(topic, \"*\", data);\n    }\n\n    /**\n     * Create a new Message instance with the specified topic,\n     * recipient, and data.\n     *\n     * @param topic The topic this messages is published to.\n     * @param recip The recipient of this message.\n     * @param data The data associated with this message.\n     */\n    public static Message createMessage(String topic, String recip, Object data) {\n        Message msg = getInstance().createObject();\n        msg.set(topic, recip, data);\n        return msg;\n    }\n\n    public static Message createUnloadMessage(String name) {\n        return createMessage(\"KERNEL\", \"UNLOAD \" + name);\n    }\n\n    /**\n     * @param localeKey\n     * @param args\n     */\n    public static Message createWarningMessage(String localeKey, Object... args) {\n        Message msg = getInstance().createObject();\n        try {\n            ResourceBundle bundle = ResourceBundle.getBundle(\"gangup\");\n            msg.set(\"WARNING\", \"*\", String.format(bundle.getString(localeKey), args));\n        } catch (Exception e) {\n            msg.set(\"WARNING\", \"*\", \"Reading string from locale failed: key=\" + localeKey + \"\\n\" + \"This probably means that you have an old or otherwise\\n\" + \"inaccurate locale file (maybe it's missing altogether)\\n\" + \"or that the classpath does not contain the directory.\");\n        }\n        return msg;\n    }\n\n    /**\n     * @param localeKey\n     * @param args\n     */\n    public static Message createErrorMessage(String localeKey, Object... args) {\n        Message msg = createWarningMessage(localeKey, args);\n        msg.setHeader(\"ERROR\");\n        return msg;\n    }\n\n    /**\n     * @param id\n     * @param addr\n     */\n    public static Message createConnectionDroppedMessage(int id, String addr) {\n        Message msg = getInstance().createObject();\n        msg.set(\"DROPPED\", \"*\", \"ID: \" + id + \" IP: \" + addr);\n        return msg;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/module/MessageFactoryTest6.java",
		"test_prompt": "// MessageFactoryTest6.java\npackage module;\n\nimport util.AbstractFactory;\nimport module.Message;\nimport java.util.ResourceBundle;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MessageFactory}.\n* It contains ten unit test cases for the {@link MessageFactory#createErrorMessage(String, Object[])} method.\n*/\nclass MessageFactoryTest6 {"
	},
	{
		"original_code": "// MessageFactory.java\n/* $Id: MessageFactory.java,v 1.2 2004/04/27 19:26:21 bja Exp $ */\npackage module;\n\nimport util.AbstractFactory;\nimport module.Message;\nimport java.util.ResourceBundle;\n\n/**\n * This class provides methods for creating Messages of various kind.\n * Messages created by this factory are managed, that is instances are\n * reused after they have been used.\n */\npublic class MessageFactory extends AbstractFactory<Message> {\n\n    /**\n     * The reference to the MessageFactory instance.\n     */\n    protected static MessageFactory instance = null;\n\n    /**\n     * Creates a new instance of the MessageFactory class.\n     */\n    private MessageFactory() {\n        super(new Message());\n        this.instance = this;\n    }\n\n    /**\n     * Returns a reference to new empty message. The message topic and\n     * data is set to null. The recipient field is set to default \"*\".\n     */\n    public Message createMessage() {\n        return createMessage(null, \"*\", null);\n    }\n\n    /**\n     * Returns the MessageFactory instance, currently the instance\n     * returned is that of the last created MessageFactory.\n     */\n    public static MessageFactory getInstance() {\n        return instance != null ? instance : new MessageFactory();\n    }\n\n    /**\n     * Create a new Message instance with the specified topic and data.\n     *\n     * @param topic The topic this messages is published to.\n     * @param data The data associated with this message.\n     */\n    public static Message createMessage(String topic, Object data) {\n        return createMessage(topic, \"*\", data);\n    }\n\n    /**\n     * Create a new Message instance with the specified topic,\n     * recipient, and data.\n     *\n     * @param topic The topic this messages is published to.\n     * @param recip The recipient of this message.\n     * @param data The data associated with this message.\n     */\n    public static Message createMessage(String topic, String recip, Object data) {\n        Message msg = getInstance().createObject();\n        msg.set(topic, recip, data);\n        return msg;\n    }\n\n    public static Message createUnloadMessage(String name) {\n        return createMessage(\"KERNEL\", \"UNLOAD \" + name);\n    }\n\n    /**\n     * @param localeKey\n     * @param args\n     */\n    public static Message createWarningMessage(String localeKey, Object... args) {\n        Message msg = getInstance().createObject();\n        try {\n            ResourceBundle bundle = ResourceBundle.getBundle(\"gangup\");\n            msg.set(\"WARNING\", \"*\", String.format(bundle.getString(localeKey), args));\n        } catch (Exception e) {\n            msg.set(\"WARNING\", \"*\", \"Reading string from locale failed: key=\" + localeKey + \"\\n\" + \"This probably means that you have an old or otherwise\\n\" + \"inaccurate locale file (maybe it's missing altogether)\\n\" + \"or that the classpath does not contain the directory.\");\n        }\n        return msg;\n    }\n\n    /**\n     * @param localeKey\n     * @param args\n     */\n    public static Message createErrorMessage(String localeKey, Object... args) {\n        Message msg = createWarningMessage(localeKey, args);\n        msg.setHeader(\"ERROR\");\n        return msg;\n    }\n\n    /**\n     * @param id\n     * @param addr\n     */\n    public static Message createConnectionDroppedMessage(int id, String addr) {\n        Message msg = getInstance().createObject();\n        msg.set(\"DROPPED\", \"*\", \"ID: \" + id + \" IP: \" + addr);\n        return msg;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/module/MessageFactoryTest7.java",
		"test_prompt": "// MessageFactoryTest7.java\npackage module;\n\nimport util.AbstractFactory;\nimport module.Message;\nimport java.util.ResourceBundle;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MessageFactory}.\n* It contains ten unit test cases for the {@link MessageFactory#createConnectionDroppedMessage(int, String)} method.\n*/\nclass MessageFactoryTest7 {"
	},
	{
		"original_code": "// Message.java\n/* $Id: Message.java,v 1.6 2004/04/27 19:26:21 bja Exp $ \n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Emil Lundstr�m <emill@kth.se>\n * @version: $Revision: 1.6 $\n *\n */\npackage module;\n\nimport util.ManagedObject;\n\n/**\n * The Message class provides the common data link between modules. It's\n * sole purpose is to move data from one module to another.\n */\npublic class Message extends ManagedObject {\n\n    /**\n     * Enumeration of possible message states\n     */\n    public static final int UNDEFINED = 0;\n\n    public static final int CREATED = 1;\n\n    public static final int RECEIVED = 2;\n\n    public static final int DELIVERED = 4;\n\n    /**\n     * Default time to live in milliseconds.\n     */\n    public static final int TIME_TO_LIVE = 3000;\n\n    /**\n     * The number of instantiated messages.\n     */\n    private static long messages;\n\n    /**\n     * Integer that uniqely identifies this message.\n     */\n    long messageID;\n\n    /**\n     * Integer that uniqely identifies this session.\n     */\n    long sessionID;\n\n    /**\n     * The header or class of this message.\n     */\n    String header;\n\n    /**\n     * The name of the module this message orignitated from.\n     */\n    String sender;\n\n    /**\n     * The name of the module this message is destined for.\n     */\n    String recipient;\n\n    /**\n     * The content or data of this message.\n     */\n    Object body;\n\n    /**\n     * The time when this message was created.\n     */\n    long timestamp;\n\n    /**\n     * The maximum time to live in milliseconds.\n     */\n    long timetolive;\n\n    /**\n     * The current state of this message.\n     */\n    int state;\n\n    /**\n     * Create a new Message instance without topic and data.\n     */\n    public Message() {\n        //this(null, \"*\", null);\n    }\n\n    /**\n     * Create a new Message instance with the specified\n     * topic and data.\n     *\n     * @param topic The topic this messages is published to.\n     * @param data The data associated with this message.\n     */\n    public Message(String topic, Object data) {\n        this(topic, \"*\", data);\n    }\n\n    /**\n     * Create a new Message instance with the specified\n     * topic, recipient, and data.\n     *\n     * @param topic The topic this messages is published to.\n     * @param recipient The recipient of this message.\n     * @param data The data associated with this message.\n     */\n    public Message(String topic, String recipient, Object data) {\n        timestamp = System.currentTimeMillis();\n        timetolive = TIME_TO_LIVE;\n        state = CREATED;\n        this.header = topic;\n        this.recipient = recipient;\n        setBody(data);\n        ;\n        synchronized (this) {\n            messageID = messages++;\n        }\n        sessionID = messageID;\n        sender = null;\n    }\n\n    /**\n     * Set the content of this message to the specified values.\n     *\n     * @param topic\n     * @param recipient\n     * @param data\n     */\n    public void set(String topic, String recipient, Object data) {\n        timestamp = System.currentTimeMillis();\n        timetolive = TIME_TO_LIVE;\n        state = CREATED;\n        header = topic;\n        setBody(data);\n        ;\n        this.recipient = recipient;\n        synchronized (this) {\n            messageID = messages++;\n        }\n        sessionID = messageID;\n        sender = null;\n    }\n\n    public long getID() {\n        return messageID;\n    }\n\n    public long getSID() {\n        return sessionID;\n    }\n\n    public long getTTL() {\n        return timetolive;\n    }\n\n    public long getTimeStamp() {\n        return timestamp;\n    }\n\n    public int getState() {\n        return state;\n    }\n\n    /**\n     * Sets the topic attribute of this message to the specified value.\n     * @param name the name of the topic to send this message to.\n     */\n    public void setHeader(String topic) {\n        header = topic;\n    }\n\n    /**\n     * Returns The header of this message.\n     * @return The header of this message.\n     */\n    public String getHeader() {\n        return header == null ? \"\" : header;\n    }\n\n    /**\n     * Sets the body attribute of this message to the specified value.\n     * @param data the data associated with this message.\n     */\n    public void setBody(Object data) {\n        if (data instanceof ManagedObject) {\n            ((ManagedObject) data).ref();\n        }\n        body = data;\n    }\n\n    /**\n     * Returns The body of this message.\n     * @return The body of this message.\n     */\n    public Object getBody() {\n        return body == null ? \"\" : body;\n    }\n\n    /**\n     * Sets the sender attribute of this message to the specified value.\n     * @param name the name of the module that sent this message.\n     */\n    public void setSender(String name) {\n        sender = name;\n    }\n\n    /**\n     * Returns the name of the module this message originated from.\n     * @return The name of the module this message originated from.\n     */\n    public String getSender() {\n        return sender;\n    }\n\n    /**\n     * Returns the name of the module this message is destined for.\n     * @return The name of the module this message is destined for.\n     */\n    public String getRecipient() {\n        return recipient;\n    }\n\n    /**\n     * Sets the recipient attribute of this message to the specified value.\n     * @param name the name of the module that this message is destined for.\n     */\n    public void setRecipient(String name) {\n        recipient = name;\n    }\n\n    /**\n     * Sets the delivery state of this Message to the specified boolean.\n     * @param b The new delivery state of thie Message.\n     */\n    public void setDelivered(boolean b) {\n        if (b) {\n            state |= DELIVERED;\n        } else {\n            state &= ~DELIVERED;\n        }\n    }\n\n    /**\n     * Creates a new reply to this Message. Replies share the session key\n     * with the original Message.\n     *\n     * @param data The body of the returned Message.\n     */\n    public Message reply(Object data) {\n        Message m = new Message(header, sender, data);\n        m.sessionID = sessionID;\n        return m;\n    }\n\n    /**\n     * @return true if this Message has been delivered by the message\n     *         service, otherwise return false.\n     */\n    public boolean delivered() {\n        return (state & DELIVERED) != 0;\n    }\n\n    /**\n     * @return true if this Message has been received by the message\n     *         service, otherwise return false.\n     */\n    public boolean received() {\n        return (state & RECEIVED) != 0;\n    }\n\n    /**\n     * This method is invoked when the reference count for this object\n     * is set to zero, meaning no objects (modules) are referencing it,\n     * thus it's safe to change the content.\n     */\n    protected synchronized void consume() {\n        if (body instanceof ManagedObject) {\n            ((ManagedObject) body).unref();\n            //ManagedObject mo = (ManagedObject) body;\n            //if (mo.getIsManaged()) {\n            //\tmo.unref();\n            //}\n        }\n        super.consume();\n    }\n\n    public Message(util.ObjectManager m) {\n        super(m);\n    }\n\n    public Message clone() {\n        return new Message(manager);\n    }\n\n    /**\n     */\n    private Module sourceModule = null;\n\n    public void send() throws MessageDeliveryException {\n        if (sourceModule == null) {\n            throw new MessageDeliveryException(sourceModule, this, \"no source module\");\n        }\n        sourceModule.sendMessage(this);\n    }\n\n    /**\n     * @param source the module from which to send this message.\n     */\n    public void send(Module source) throws MessageDeliveryException {\n        source.sendMessage(this);\n    }\n\n    /**\n     * @param source the module from which to send this message.\n     */\n    public void sendFrom(Module source) throws MessageDeliveryException {\n        source.sendMessage(this);\n    }\n\n    /**\n     * @param destinatino the module to which to send this message.\n     */\n    public void sendTo(Module destination) throws MessageDeliveryException {\n        destination.receiveMessage(this);\n    }\n\n    /**\n     * Return a string representation of this Message.\n     * @return a string representation of this object.\n     */\n    public String toString() {\n        return \"Message[id=\" + messageID + \",session=\" + sessionID + \",head=\" + header + \",recip=\" + recipient + \",sender=\" + sender + \",state=\" + state + \",ttl=\" + timetolive + \",time=\" + timestamp + \",body=\" + body + \"]\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/module/MessageTest0.java",
		"test_prompt": "// MessageTest0.java\npackage module;\n\nimport util.ManagedObject;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Message}.\n* It contains ten unit test cases for the {@link Message#reply(Object)} method.\n*/\nclass MessageTest0 {"
	},
	{
		"original_code": "// Message.java\n/* $Id: Message.java,v 1.6 2004/04/27 19:26:21 bja Exp $ \n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Emil Lundstr�m <emill@kth.se>\n * @version: $Revision: 1.6 $\n *\n */\npackage module;\n\nimport util.ManagedObject;\n\n/**\n * The Message class provides the common data link between modules. It's\n * sole purpose is to move data from one module to another.\n */\npublic class Message extends ManagedObject {\n\n    /**\n     * Enumeration of possible message states\n     */\n    public static final int UNDEFINED = 0;\n\n    public static final int CREATED = 1;\n\n    public static final int RECEIVED = 2;\n\n    public static final int DELIVERED = 4;\n\n    /**\n     * Default time to live in milliseconds.\n     */\n    public static final int TIME_TO_LIVE = 3000;\n\n    /**\n     * The number of instantiated messages.\n     */\n    private static long messages;\n\n    /**\n     * Integer that uniqely identifies this message.\n     */\n    long messageID;\n\n    /**\n     * Integer that uniqely identifies this session.\n     */\n    long sessionID;\n\n    /**\n     * The header or class of this message.\n     */\n    String header;\n\n    /**\n     * The name of the module this message orignitated from.\n     */\n    String sender;\n\n    /**\n     * The name of the module this message is destined for.\n     */\n    String recipient;\n\n    /**\n     * The content or data of this message.\n     */\n    Object body;\n\n    /**\n     * The time when this message was created.\n     */\n    long timestamp;\n\n    /**\n     * The maximum time to live in milliseconds.\n     */\n    long timetolive;\n\n    /**\n     * The current state of this message.\n     */\n    int state;\n\n    /**\n     * Create a new Message instance without topic and data.\n     */\n    public Message() {\n        //this(null, \"*\", null);\n    }\n\n    /**\n     * Create a new Message instance with the specified\n     * topic and data.\n     *\n     * @param topic The topic this messages is published to.\n     * @param data The data associated with this message.\n     */\n    public Message(String topic, Object data) {\n        this(topic, \"*\", data);\n    }\n\n    /**\n     * Create a new Message instance with the specified\n     * topic, recipient, and data.\n     *\n     * @param topic The topic this messages is published to.\n     * @param recipient The recipient of this message.\n     * @param data The data associated with this message.\n     */\n    public Message(String topic, String recipient, Object data) {\n        timestamp = System.currentTimeMillis();\n        timetolive = TIME_TO_LIVE;\n        state = CREATED;\n        this.header = topic;\n        this.recipient = recipient;\n        setBody(data);\n        ;\n        synchronized (this) {\n            messageID = messages++;\n        }\n        sessionID = messageID;\n        sender = null;\n    }\n\n    /**\n     * Set the content of this message to the specified values.\n     *\n     * @param topic\n     * @param recipient\n     * @param data\n     */\n    public void set(String topic, String recipient, Object data) {\n        timestamp = System.currentTimeMillis();\n        timetolive = TIME_TO_LIVE;\n        state = CREATED;\n        header = topic;\n        setBody(data);\n        ;\n        this.recipient = recipient;\n        synchronized (this) {\n            messageID = messages++;\n        }\n        sessionID = messageID;\n        sender = null;\n    }\n\n    public long getID() {\n        return messageID;\n    }\n\n    public long getSID() {\n        return sessionID;\n    }\n\n    public long getTTL() {\n        return timetolive;\n    }\n\n    public long getTimeStamp() {\n        return timestamp;\n    }\n\n    public int getState() {\n        return state;\n    }\n\n    /**\n     * Sets the topic attribute of this message to the specified value.\n     * @param name the name of the topic to send this message to.\n     */\n    public void setHeader(String topic) {\n        header = topic;\n    }\n\n    /**\n     * Returns The header of this message.\n     * @return The header of this message.\n     */\n    public String getHeader() {\n        return header == null ? \"\" : header;\n    }\n\n    /**\n     * Sets the body attribute of this message to the specified value.\n     * @param data the data associated with this message.\n     */\n    public void setBody(Object data) {\n        if (data instanceof ManagedObject) {\n            ((ManagedObject) data).ref();\n        }\n        body = data;\n    }\n\n    /**\n     * Returns The body of this message.\n     * @return The body of this message.\n     */\n    public Object getBody() {\n        return body == null ? \"\" : body;\n    }\n\n    /**\n     * Sets the sender attribute of this message to the specified value.\n     * @param name the name of the module that sent this message.\n     */\n    public void setSender(String name) {\n        sender = name;\n    }\n\n    /**\n     * Returns the name of the module this message originated from.\n     * @return The name of the module this message originated from.\n     */\n    public String getSender() {\n        return sender;\n    }\n\n    /**\n     * Returns the name of the module this message is destined for.\n     * @return The name of the module this message is destined for.\n     */\n    public String getRecipient() {\n        return recipient;\n    }\n\n    /**\n     * Sets the recipient attribute of this message to the specified value.\n     * @param name the name of the module that this message is destined for.\n     */\n    public void setRecipient(String name) {\n        recipient = name;\n    }\n\n    /**\n     * Sets the delivery state of this Message to the specified boolean.\n     * @param b The new delivery state of thie Message.\n     */\n    public void setDelivered(boolean b) {\n        if (b) {\n            state |= DELIVERED;\n        } else {\n            state &= ~DELIVERED;\n        }\n    }\n\n    /**\n     * Creates a new reply to this Message. Replies share the session key\n     * with the original Message.\n     *\n     * @param data The body of the returned Message.\n     */\n    public Message reply(Object data) {\n        Message m = new Message(header, sender, data);\n        m.sessionID = sessionID;\n        return m;\n    }\n\n    /**\n     * @return true if this Message has been delivered by the message\n     *         service, otherwise return false.\n     */\n    public boolean delivered() {\n        return (state & DELIVERED) != 0;\n    }\n\n    /**\n     * @return true if this Message has been received by the message\n     *         service, otherwise return false.\n     */\n    public boolean received() {\n        return (state & RECEIVED) != 0;\n    }\n\n    /**\n     * This method is invoked when the reference count for this object\n     * is set to zero, meaning no objects (modules) are referencing it,\n     * thus it's safe to change the content.\n     */\n    protected synchronized void consume() {\n        if (body instanceof ManagedObject) {\n            ((ManagedObject) body).unref();\n            //ManagedObject mo = (ManagedObject) body;\n            //if (mo.getIsManaged()) {\n            //\tmo.unref();\n            //}\n        }\n        super.consume();\n    }\n\n    public Message(util.ObjectManager m) {\n        super(m);\n    }\n\n    public Message clone() {\n        return new Message(manager);\n    }\n\n    /**\n     */\n    private Module sourceModule = null;\n\n    public void send() throws MessageDeliveryException {\n        if (sourceModule == null) {\n            throw new MessageDeliveryException(sourceModule, this, \"no source module\");\n        }\n        sourceModule.sendMessage(this);\n    }\n\n    /**\n     * @param source the module from which to send this message.\n     */\n    public void send(Module source) throws MessageDeliveryException {\n        source.sendMessage(this);\n    }\n\n    /**\n     * @param source the module from which to send this message.\n     */\n    public void sendFrom(Module source) throws MessageDeliveryException {\n        source.sendMessage(this);\n    }\n\n    /**\n     * @param destinatino the module to which to send this message.\n     */\n    public void sendTo(Module destination) throws MessageDeliveryException {\n        destination.receiveMessage(this);\n    }\n\n    /**\n     * Return a string representation of this Message.\n     * @return a string representation of this object.\n     */\n    public String toString() {\n        return \"Message[id=\" + messageID + \",session=\" + sessionID + \",head=\" + header + \",recip=\" + recipient + \",sender=\" + sender + \",state=\" + state + \",ttl=\" + timetolive + \",time=\" + timestamp + \",body=\" + body + \"]\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/module/MessageTest1.java",
		"test_prompt": "// MessageTest1.java\npackage module;\n\nimport util.ManagedObject;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Message}.\n* It contains ten unit test cases for the {@link Message#delivered()} method.\n*/\nclass MessageTest1 {"
	},
	{
		"original_code": "// Message.java\n/* $Id: Message.java,v 1.6 2004/04/27 19:26:21 bja Exp $ \n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Emil Lundstr�m <emill@kth.se>\n * @version: $Revision: 1.6 $\n *\n */\npackage module;\n\nimport util.ManagedObject;\n\n/**\n * The Message class provides the common data link between modules. It's\n * sole purpose is to move data from one module to another.\n */\npublic class Message extends ManagedObject {\n\n    /**\n     * Enumeration of possible message states\n     */\n    public static final int UNDEFINED = 0;\n\n    public static final int CREATED = 1;\n\n    public static final int RECEIVED = 2;\n\n    public static final int DELIVERED = 4;\n\n    /**\n     * Default time to live in milliseconds.\n     */\n    public static final int TIME_TO_LIVE = 3000;\n\n    /**\n     * The number of instantiated messages.\n     */\n    private static long messages;\n\n    /**\n     * Integer that uniqely identifies this message.\n     */\n    long messageID;\n\n    /**\n     * Integer that uniqely identifies this session.\n     */\n    long sessionID;\n\n    /**\n     * The header or class of this message.\n     */\n    String header;\n\n    /**\n     * The name of the module this message orignitated from.\n     */\n    String sender;\n\n    /**\n     * The name of the module this message is destined for.\n     */\n    String recipient;\n\n    /**\n     * The content or data of this message.\n     */\n    Object body;\n\n    /**\n     * The time when this message was created.\n     */\n    long timestamp;\n\n    /**\n     * The maximum time to live in milliseconds.\n     */\n    long timetolive;\n\n    /**\n     * The current state of this message.\n     */\n    int state;\n\n    /**\n     * Create a new Message instance without topic and data.\n     */\n    public Message() {\n        //this(null, \"*\", null);\n    }\n\n    /**\n     * Create a new Message instance with the specified\n     * topic and data.\n     *\n     * @param topic The topic this messages is published to.\n     * @param data The data associated with this message.\n     */\n    public Message(String topic, Object data) {\n        this(topic, \"*\", data);\n    }\n\n    /**\n     * Create a new Message instance with the specified\n     * topic, recipient, and data.\n     *\n     * @param topic The topic this messages is published to.\n     * @param recipient The recipient of this message.\n     * @param data The data associated with this message.\n     */\n    public Message(String topic, String recipient, Object data) {\n        timestamp = System.currentTimeMillis();\n        timetolive = TIME_TO_LIVE;\n        state = CREATED;\n        this.header = topic;\n        this.recipient = recipient;\n        setBody(data);\n        ;\n        synchronized (this) {\n            messageID = messages++;\n        }\n        sessionID = messageID;\n        sender = null;\n    }\n\n    /**\n     * Set the content of this message to the specified values.\n     *\n     * @param topic\n     * @param recipient\n     * @param data\n     */\n    public void set(String topic, String recipient, Object data) {\n        timestamp = System.currentTimeMillis();\n        timetolive = TIME_TO_LIVE;\n        state = CREATED;\n        header = topic;\n        setBody(data);\n        ;\n        this.recipient = recipient;\n        synchronized (this) {\n            messageID = messages++;\n        }\n        sessionID = messageID;\n        sender = null;\n    }\n\n    public long getID() {\n        return messageID;\n    }\n\n    public long getSID() {\n        return sessionID;\n    }\n\n    public long getTTL() {\n        return timetolive;\n    }\n\n    public long getTimeStamp() {\n        return timestamp;\n    }\n\n    public int getState() {\n        return state;\n    }\n\n    /**\n     * Sets the topic attribute of this message to the specified value.\n     * @param name the name of the topic to send this message to.\n     */\n    public void setHeader(String topic) {\n        header = topic;\n    }\n\n    /**\n     * Returns The header of this message.\n     * @return The header of this message.\n     */\n    public String getHeader() {\n        return header == null ? \"\" : header;\n    }\n\n    /**\n     * Sets the body attribute of this message to the specified value.\n     * @param data the data associated with this message.\n     */\n    public void setBody(Object data) {\n        if (data instanceof ManagedObject) {\n            ((ManagedObject) data).ref();\n        }\n        body = data;\n    }\n\n    /**\n     * Returns The body of this message.\n     * @return The body of this message.\n     */\n    public Object getBody() {\n        return body == null ? \"\" : body;\n    }\n\n    /**\n     * Sets the sender attribute of this message to the specified value.\n     * @param name the name of the module that sent this message.\n     */\n    public void setSender(String name) {\n        sender = name;\n    }\n\n    /**\n     * Returns the name of the module this message originated from.\n     * @return The name of the module this message originated from.\n     */\n    public String getSender() {\n        return sender;\n    }\n\n    /**\n     * Returns the name of the module this message is destined for.\n     * @return The name of the module this message is destined for.\n     */\n    public String getRecipient() {\n        return recipient;\n    }\n\n    /**\n     * Sets the recipient attribute of this message to the specified value.\n     * @param name the name of the module that this message is destined for.\n     */\n    public void setRecipient(String name) {\n        recipient = name;\n    }\n\n    /**\n     * Sets the delivery state of this Message to the specified boolean.\n     * @param b The new delivery state of thie Message.\n     */\n    public void setDelivered(boolean b) {\n        if (b) {\n            state |= DELIVERED;\n        } else {\n            state &= ~DELIVERED;\n        }\n    }\n\n    /**\n     * Creates a new reply to this Message. Replies share the session key\n     * with the original Message.\n     *\n     * @param data The body of the returned Message.\n     */\n    public Message reply(Object data) {\n        Message m = new Message(header, sender, data);\n        m.sessionID = sessionID;\n        return m;\n    }\n\n    /**\n     * @return true if this Message has been delivered by the message\n     *         service, otherwise return false.\n     */\n    public boolean delivered() {\n        return (state & DELIVERED) != 0;\n    }\n\n    /**\n     * @return true if this Message has been received by the message\n     *         service, otherwise return false.\n     */\n    public boolean received() {\n        return (state & RECEIVED) != 0;\n    }\n\n    /**\n     * This method is invoked when the reference count for this object\n     * is set to zero, meaning no objects (modules) are referencing it,\n     * thus it's safe to change the content.\n     */\n    protected synchronized void consume() {\n        if (body instanceof ManagedObject) {\n            ((ManagedObject) body).unref();\n            //ManagedObject mo = (ManagedObject) body;\n            //if (mo.getIsManaged()) {\n            //\tmo.unref();\n            //}\n        }\n        super.consume();\n    }\n\n    public Message(util.ObjectManager m) {\n        super(m);\n    }\n\n    public Message clone() {\n        return new Message(manager);\n    }\n\n    /**\n     */\n    private Module sourceModule = null;\n\n    public void send() throws MessageDeliveryException {\n        if (sourceModule == null) {\n            throw new MessageDeliveryException(sourceModule, this, \"no source module\");\n        }\n        sourceModule.sendMessage(this);\n    }\n\n    /**\n     * @param source the module from which to send this message.\n     */\n    public void send(Module source) throws MessageDeliveryException {\n        source.sendMessage(this);\n    }\n\n    /**\n     * @param source the module from which to send this message.\n     */\n    public void sendFrom(Module source) throws MessageDeliveryException {\n        source.sendMessage(this);\n    }\n\n    /**\n     * @param destinatino the module to which to send this message.\n     */\n    public void sendTo(Module destination) throws MessageDeliveryException {\n        destination.receiveMessage(this);\n    }\n\n    /**\n     * Return a string representation of this Message.\n     * @return a string representation of this object.\n     */\n    public String toString() {\n        return \"Message[id=\" + messageID + \",session=\" + sessionID + \",head=\" + header + \",recip=\" + recipient + \",sender=\" + sender + \",state=\" + state + \",ttl=\" + timetolive + \",time=\" + timestamp + \",body=\" + body + \"]\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/module/MessageTest2.java",
		"test_prompt": "// MessageTest2.java\npackage module;\n\nimport util.ManagedObject;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Message}.\n* It contains ten unit test cases for the {@link Message#received()} method.\n*/\nclass MessageTest2 {"
	},
	{
		"original_code": "// Message.java\n/* $Id: Message.java,v 1.6 2004/04/27 19:26:21 bja Exp $ \n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Emil Lundstr�m <emill@kth.se>\n * @version: $Revision: 1.6 $\n *\n */\npackage module;\n\nimport util.ManagedObject;\n\n/**\n * The Message class provides the common data link between modules. It's\n * sole purpose is to move data from one module to another.\n */\npublic class Message extends ManagedObject {\n\n    /**\n     * Enumeration of possible message states\n     */\n    public static final int UNDEFINED = 0;\n\n    public static final int CREATED = 1;\n\n    public static final int RECEIVED = 2;\n\n    public static final int DELIVERED = 4;\n\n    /**\n     * Default time to live in milliseconds.\n     */\n    public static final int TIME_TO_LIVE = 3000;\n\n    /**\n     * The number of instantiated messages.\n     */\n    private static long messages;\n\n    /**\n     * Integer that uniqely identifies this message.\n     */\n    long messageID;\n\n    /**\n     * Integer that uniqely identifies this session.\n     */\n    long sessionID;\n\n    /**\n     * The header or class of this message.\n     */\n    String header;\n\n    /**\n     * The name of the module this message orignitated from.\n     */\n    String sender;\n\n    /**\n     * The name of the module this message is destined for.\n     */\n    String recipient;\n\n    /**\n     * The content or data of this message.\n     */\n    Object body;\n\n    /**\n     * The time when this message was created.\n     */\n    long timestamp;\n\n    /**\n     * The maximum time to live in milliseconds.\n     */\n    long timetolive;\n\n    /**\n     * The current state of this message.\n     */\n    int state;\n\n    /**\n     * Create a new Message instance without topic and data.\n     */\n    public Message() {\n        //this(null, \"*\", null);\n    }\n\n    /**\n     * Create a new Message instance with the specified\n     * topic and data.\n     *\n     * @param topic The topic this messages is published to.\n     * @param data The data associated with this message.\n     */\n    public Message(String topic, Object data) {\n        this(topic, \"*\", data);\n    }\n\n    /**\n     * Create a new Message instance with the specified\n     * topic, recipient, and data.\n     *\n     * @param topic The topic this messages is published to.\n     * @param recipient The recipient of this message.\n     * @param data The data associated with this message.\n     */\n    public Message(String topic, String recipient, Object data) {\n        timestamp = System.currentTimeMillis();\n        timetolive = TIME_TO_LIVE;\n        state = CREATED;\n        this.header = topic;\n        this.recipient = recipient;\n        setBody(data);\n        ;\n        synchronized (this) {\n            messageID = messages++;\n        }\n        sessionID = messageID;\n        sender = null;\n    }\n\n    /**\n     * Set the content of this message to the specified values.\n     *\n     * @param topic\n     * @param recipient\n     * @param data\n     */\n    public void set(String topic, String recipient, Object data) {\n        timestamp = System.currentTimeMillis();\n        timetolive = TIME_TO_LIVE;\n        state = CREATED;\n        header = topic;\n        setBody(data);\n        ;\n        this.recipient = recipient;\n        synchronized (this) {\n            messageID = messages++;\n        }\n        sessionID = messageID;\n        sender = null;\n    }\n\n    public long getID() {\n        return messageID;\n    }\n\n    public long getSID() {\n        return sessionID;\n    }\n\n    public long getTTL() {\n        return timetolive;\n    }\n\n    public long getTimeStamp() {\n        return timestamp;\n    }\n\n    public int getState() {\n        return state;\n    }\n\n    /**\n     * Sets the topic attribute of this message to the specified value.\n     * @param name the name of the topic to send this message to.\n     */\n    public void setHeader(String topic) {\n        header = topic;\n    }\n\n    /**\n     * Returns The header of this message.\n     * @return The header of this message.\n     */\n    public String getHeader() {\n        return header == null ? \"\" : header;\n    }\n\n    /**\n     * Sets the body attribute of this message to the specified value.\n     * @param data the data associated with this message.\n     */\n    public void setBody(Object data) {\n        if (data instanceof ManagedObject) {\n            ((ManagedObject) data).ref();\n        }\n        body = data;\n    }\n\n    /**\n     * Returns The body of this message.\n     * @return The body of this message.\n     */\n    public Object getBody() {\n        return body == null ? \"\" : body;\n    }\n\n    /**\n     * Sets the sender attribute of this message to the specified value.\n     * @param name the name of the module that sent this message.\n     */\n    public void setSender(String name) {\n        sender = name;\n    }\n\n    /**\n     * Returns the name of the module this message originated from.\n     * @return The name of the module this message originated from.\n     */\n    public String getSender() {\n        return sender;\n    }\n\n    /**\n     * Returns the name of the module this message is destined for.\n     * @return The name of the module this message is destined for.\n     */\n    public String getRecipient() {\n        return recipient;\n    }\n\n    /**\n     * Sets the recipient attribute of this message to the specified value.\n     * @param name the name of the module that this message is destined for.\n     */\n    public void setRecipient(String name) {\n        recipient = name;\n    }\n\n    /**\n     * Sets the delivery state of this Message to the specified boolean.\n     * @param b The new delivery state of thie Message.\n     */\n    public void setDelivered(boolean b) {\n        if (b) {\n            state |= DELIVERED;\n        } else {\n            state &= ~DELIVERED;\n        }\n    }\n\n    /**\n     * Creates a new reply to this Message. Replies share the session key\n     * with the original Message.\n     *\n     * @param data The body of the returned Message.\n     */\n    public Message reply(Object data) {\n        Message m = new Message(header, sender, data);\n        m.sessionID = sessionID;\n        return m;\n    }\n\n    /**\n     * @return true if this Message has been delivered by the message\n     *         service, otherwise return false.\n     */\n    public boolean delivered() {\n        return (state & DELIVERED) != 0;\n    }\n\n    /**\n     * @return true if this Message has been received by the message\n     *         service, otherwise return false.\n     */\n    public boolean received() {\n        return (state & RECEIVED) != 0;\n    }\n\n    /**\n     * This method is invoked when the reference count for this object\n     * is set to zero, meaning no objects (modules) are referencing it,\n     * thus it's safe to change the content.\n     */\n    protected synchronized void consume() {\n        if (body instanceof ManagedObject) {\n            ((ManagedObject) body).unref();\n            //ManagedObject mo = (ManagedObject) body;\n            //if (mo.getIsManaged()) {\n            //\tmo.unref();\n            //}\n        }\n        super.consume();\n    }\n\n    public Message(util.ObjectManager m) {\n        super(m);\n    }\n\n    public Message clone() {\n        return new Message(manager);\n    }\n\n    /**\n     */\n    private Module sourceModule = null;\n\n    public void send() throws MessageDeliveryException {\n        if (sourceModule == null) {\n            throw new MessageDeliveryException(sourceModule, this, \"no source module\");\n        }\n        sourceModule.sendMessage(this);\n    }\n\n    /**\n     * @param source the module from which to send this message.\n     */\n    public void send(Module source) throws MessageDeliveryException {\n        source.sendMessage(this);\n    }\n\n    /**\n     * @param source the module from which to send this message.\n     */\n    public void sendFrom(Module source) throws MessageDeliveryException {\n        source.sendMessage(this);\n    }\n\n    /**\n     * @param destinatino the module to which to send this message.\n     */\n    public void sendTo(Module destination) throws MessageDeliveryException {\n        destination.receiveMessage(this);\n    }\n\n    /**\n     * Return a string representation of this Message.\n     * @return a string representation of this object.\n     */\n    public String toString() {\n        return \"Message[id=\" + messageID + \",session=\" + sessionID + \",head=\" + header + \",recip=\" + recipient + \",sender=\" + sender + \",state=\" + state + \",ttl=\" + timetolive + \",time=\" + timestamp + \",body=\" + body + \"]\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/module/MessageTest3.java",
		"test_prompt": "// MessageTest3.java\npackage module;\n\nimport util.ManagedObject;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Message}.\n* It contains ten unit test cases for the {@link Message#clone()} method.\n*/\nclass MessageTest3 {"
	},
	{
		"original_code": "// BasicRules.java\n/*\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties.\n *\n * @author: Rasmus Ahlberg\n *\n */\npackage module;\n\nimport java.util.*;\nimport state.*;\n\npublic class BasicRules implements RuleSet {\n\n    BasicRules() {\n    }\n\n    public boolean checkRules(Action action, GameState state) {\n        Player actor = state.player(action.getActor());\n        Player target = state.player(action.getTarget());\n        if (state.getGameState() == GameState.STATE_WAITING)\n            return false;\n        if (actor == null || actor.isDead())\n            return false;\n        if (action.getAction() != Action.ACTION_PART && action.getAction() != Action.ACTION_MOVE && (target == null || target.isDead())) {\n            return false;\n        }\n        switch(action.getAction()) {\n            case Action.ACTION_PART:\n                if (actor.isBoss())\n                    return false;\n                break;\n            case Action.ACTION_ATTACK:\n                if (state.getGameState() == GameState.STATE_WARMUP)\n                    return false;\n                if (actor == target)\n                    return false;\n                if (!actor.isBoss())\n                    return false;\n                if (!target.isBoss())\n                    return false;\n                break;\n            case Action.ACTION_JOIN:\n                if (actor == target)\n                    return false;\n                if (!actor.isBoss())\n                    return false;\n                if (target.gangBoss() == actor)\n                    return false;\n                break;\n            case Action.ACTION_JOIN_APPLY:\n                if (actor == target)\n                    return false;\n                if (!actor.isBoss())\n                    return false;\n                if (target.gangBoss() == actor)\n                    return false;\n                break;\n            case Action.ACTION_JOIN_INVITE:\n                if (actor == target)\n                    return false;\n                if (!target.isBoss())\n                    return false;\n                if (actor.gangBoss() == target)\n                    return false;\n                break;\n            case Action.ACTION_JOIN_AGREE:\n                if (actor == target)\n                    return false;\n                if (!actor.isBoss())\n                    return false;\n                if (!target.isJoinOK(actor, true))\n                    return false;\n                break;\n            case Action.ACTION_JOIN_ALLOW:\n                if (actor == target)\n                    return false;\n                if (!target.isBoss())\n                    return false;\n                if (!target.isJoinOK(actor, false))\n                    return false;\n                break;\n            case Action.ACTION_KICK:\n                if (actor == target)\n                    return false;\n                if (actor != target.boss)\n                    return false;\n                break;\n        }\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/module/BasicRulesTest.java",
		"test_prompt": "// BasicRulesTest.java\npackage module;\n\nimport java.util.*;\nimport state.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BasicRules}.\n* It contains ten unit test cases for the {@link BasicRules#checkRules(Action, GameState)} method.\n*/\nclass BasicRulesTest {"
	},
	{
		"original_code": "// AbstractModule.java\n/* $Id: AbstractModule.java,v 1.8 2004/05/04 23:08:22 emill Exp $ \n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Emil Lundstr�m <emill@kth.se>\n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.8 $\n *\n */\npackage module;\n\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ResourceBundle;\nimport java.util.Locale;\n\n@cvs(file = \"$RCSfile: AbstractModule.java,v $\", revision = \"$Revision: 1.8 $\", date = \"$Date: 2004/05/04 23:08:22 $\", author = \"$Author: emill $\", tag = \"$Name:  $\", build = \"\")\n@mod(name = \"AbstractModule\", topics = \"\", cmds = \"\", desc = \"This is module serves as abstract base class for other \" + \"modules to faciliate creation of new modules. It cannot \" + \"be instatiated directly.\")\npublic abstract class /**\n * This class provides skeletal implementation of the Module interface.\n * Inorder to implement the Module interface it is ...\n */\nAbstractModule implements Module {\n\n    /**\n     * Reference to the kernel of this module.\n     */\n    protected Kernel kernel;\n\n    /**\n     * The message queue used for storing incoming messages.\n     */\n    private List<Message> messages;\n\n    /**\n     * The number of instances of this class.\n     */\n    private static int moduleCount;\n\n    /**\n     * The ID of an instance of this module.\n     */\n    protected int moduleID;\n\n    /**\n     * Contains module specific information.\n     */\n    protected ModuleInfo modinfo;\n\n    /**\n     * Localized strings.\n     */\n    protected ResourceBundle locale;\n\n    /**\n     * true if this module is not (or should not be) running.\n     */\n    private boolean done;\n\n    /**\n     * The thread associated with this module.\n     */\n    private Thread thread;\n\n    /**\n     * Create a new instance of this Module. The module have to register\n     * with a Kernel in order to receive any messages.\n     */\n    public AbstractModule() {\n        synchronized (this) {\n            moduleID = moduleCount++;\n        }\n        /* Get the locale specific resource file. */\n        locale = ResourceBundle.getBundle(\"gangup\", Locale.getDefault());\n        /* Initialize this class' ModuleInfo structure. Values are\n\t   retrieved from the cvs and mod annotations made above. */\n        modinfo = new ModuleInfo(this);\n        /* Initialize message queue */\n        messages = Collections.synchronizedList(new LinkedList<Message>());\n    }\n\n    /**\n     * Create a new instance of this Module and register with the\n     * specified kernel in the default class.\n     *\n     * Right now, generally module constructors should take the kernel\n     * module as an argument.\n     *\n     * @param krn The kernel associated with this module.\n     */\n    public AbstractModule(Kernel krn) throws ModuleRegisterException {\n        this();\n        register(krn);\n    }\n\n    /**\n     * Create a new instance of this Module and register with the\n     * specified kernel and class.\n     *\n     * @param krn The kernel associated with this module.\n     * @param cls The class this module should be registered in.\n     */\n    public AbstractModule(Kernel krn, String cls) throws ModuleRegisterException, ModuleSubscriptionException {\n        this(krn);\n        subscribe(cls);\n    }\n\n    /**\n     * Register the specified kernel. A module is required to register with\n     * the kernel in order to subscribe to messages and in turn communicate\n     * with other modules.\n     *\n     * @param krn The kernel that this module should registered with.\n     * @throws ModuleRegisterException if the module is already registered.\n     */\n    public void register(Module krn) throws ModuleRegisterException {\n        if (krn instanceof Kernel) {\n            krn.register(this);\n            kernel = (Kernel) krn;\n        }\n    }\n\n    /**\n     * Unregister from specified Kernel. An unused module should unregister\n     * with the kernel so that all references to that module will be freed.\n     *\n     * @param krn The kernel with which we wish to unregister.\n     * @throws ModuleRegisterException if the module is not registered.\n     */\n    public void unregister(Module krn) throws ModuleRegisterException {\n        if (krn instanceof Kernel) {\n            krn.unregister(this);\n        }\n    }\n\n    /**\n     * Subscribes this module to all messages within the specified\n     * topic. When a module subscibes to a certain topic it notifies\n     * the kernel that it is interrested in receiving all messages\n     * that has the given topic.\n     *\n     * @param topic The topic on which to subscribe.\n     */\n    protected void subscribe(String topic) throws ModuleSubscriptionException {\n        if (topic != null) {\n            kernel.subscribe(this, topic);\n        }\n    }\n\n    /**\n     * Start executing the run method in a separate thread. This method\n     * is invoked automatically be the Kernel when the module is loaded\n     * and should not be invoked manually.\n     */\n    public void start() {\n        thread = new Thread(this, modinfo.name);\n        thread.start();\n    }\n\n    /**\n     * This is this module's thread entry point. It handles most of the\n     * common module functionality. Subclasses should not override this\n     * method in order to customize the module's behavior. Instead the\n     * subclasses should implement the init(), step(), and free() methods.\n     */\n    public void run() {\n        init();\n        done = false;\n        while (!done) {\n            try {\n                processMessages();\n                step();\n                Thread.sleep(100);\n            } catch (Exception e) {\n                System.err.println(e);\n                // e.printStackTrace();\n            }\n        }\n        free();\n    }\n\n    /**\n     * Terminate the current thread. This method should be called if\n     * the module wishes to terminate its main processing thread.\n     */\n    protected final void exit() {\n        /* wonder if unregistering and unsubscribing should be \n\t   placed here? */\n        done = true;\n    }\n\n    /**\n     * Method to run recurrently in the loop of run(). This method\n     * should never be blocking, lest the module will not be able to\n     * process any messages.\n     */\n    protected void step() {\n    }\n\n    /**\n     * Initialization method for modules. Using init() is recommended\n     * instead of overloading the constructor.\n     */\n    protected void init() {\n    }\n\n    /**\n     * Exit method for modules. This method is invoked after a call to\n     * the @see exit() method. Modules should overload this method with\n     * code to do a proper exit.\n     */\n    protected void free() {\n    }\n\n    /**\n     * Handles what should done with messages sent to this module.\n     *\n     * @param msg The message to be processed.\n     */\n    protected void processMessage(Message msg) {\n    }\n\n    /**\n     * Handles what should done with kernel messages sent to this module.\n     *\n     * @param msg The message to be processed.\n     */\n    protected void processKernelMessage(Message msg) throws MessageProcessingException {\n        if (msg == null || msg.body == null) {\n            throw new MessageProcessingException(msg, \"invalid message!\");\n        }\n        try {\n            if (msg.body.equals(\"REGISTERED\")) {\n                subscribe(modinfo.topics);\n            } else if (msg.body.equals(\"UNREGISTERED\")) {\n                exit();\n            }\n        } catch (Exception e) {\n            sendMessage(new Message(\"WARNING\", \"unable to subscribe!\"));\n            throw new MessageProcessingException(msg, e);\n        }\n    }\n\n    /**\n     * Processes and removes the messages in the queue. The messages are\n     * processed in the order they were received.\n     */\n    private void processMessages() throws MessageProcessingException {\n        Message m = null;\n        try {\n            while (!messages.isEmpty()) {\n                m = messages.remove(0);\n                if (m.header.equals(\"KERNEL\")) {\n                    processKernelMessage(m);\n                } else {\n                    processMessage(m);\n                }\n                m.unref();\n                m = null;\n            }\n        } catch (Exception e) {\n            if (m != null) {\n                m.unref();\n            }\n            throw new MessageProcessingException(e);\n        }\n    }\n\n    /**\n     * Delivers the specified message to the kernel. At the moment there's\n     * no way of telling if the message got delivered or not.\n     *\n     * @param msg The message to be delivered.\n     */\n    public void sendMessage(/*AndIDontCareIfItDoesntWork*/\n    Message msg) {\n        try {\n            msg.sender = modinfo.name;\n            kernel.receiveMessage(msg);\n        } catch (MessageDeliveryException e) {\n            // catch it here, it breaks to many modules if we were to\n            // let it propagate right now.\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * Called by the kernel to put a Message in this module's queue.\n     *\n     * @param msg The message that was received.\n     */\n    public void receiveMessage(Message msg) {\n        msg.ref();\n        messages.add(msg);\n    }\n\n    /**\n     * Requests the specified query from the specified topic. Observe that\n     * if there are more than one module answering a specific request, only\n     * the first one will be returned.\n     *\n     * @param msg The message containing the request.\n     *\n     * @throws MessageTimeoutException\n     * If the request times out before we receive any replies.\n     */\n    public Message request(Message msg) throws MessageTimeoutException {\n        try {\n            Message r = null;\n            int latestIndex = -1;\n            long timeout = System.currentTimeMillis() + msg.timetolive;\n            sendMessage(msg);\n            /* Wait until we receive a response to our request or until\n\t       the specified timeout occurs. */\n            while (System.currentTimeMillis() < timeout) {\n                if (!messages.isEmpty()) {\n                    for (int i = messages.size() - 1; i > latestIndex; i--) {\n                        r = messages.get(i);\n                        if (r.sessionID == msg.sessionID && r.messageID != msg.messageID) {\n                            messages.remove(r);\n                            r.unref();\n                            return r;\n                        }\n                    }\n                    latestIndex = messages.size() - 1;\n                    /* Keep processing other messages. */\n                    /*\n\t\t    if (r.header.equals(\"KERNEL\")) {\n\t\t\tprocessKernelMessage(r);\n\t\t    } else {\n\t\t\tprocessMessage(r);\n\t\t    }\n\n\t\t    r.unref(); */\n                    // Thread.currentThread().yield();\n                }\n                Thread.sleep(10);\n            }\n        } catch (Exception e) {\n            // throw new MessageRequestException(e);\n        } finally {\n            msg.unref();\n        }\n        throw new MessageTimeoutException(\"Sorry, your request timed out!\");\n    }\n\n    /**\n     * Requests the specified query from the specified topic. Observe that\n     * if there are more than one module answering a specific request, only\n     * the first one will be honored.\n     *\n     * @param topic The topic in which to make the request.\n     * @param query The request to be made.\n     *\n     * @throws MessageTimeoutException\n     * If the request times out before we receive any replies.\n     */\n    public Message request(String topic, String query) throws MessageTimeoutException {\n        return request(new Message(topic, query));\n    }\n\n    /**\n     * Returns the Kernel associated with this Module.\n     * @return the Kernel associated with this Module.\n     */\n    public Kernel getKernel() {\n        return kernel;\n    }\n\n    /**\n     * Returns the thread associated with this module.\n     * @return The thread associated with this module.\n     */\n    public Thread getThread() {\n        return thread;\n    }\n\n    /**\n     * Returns the module info associated whith this module.\n     * @return the module info associated whith this module.\n     */\n    public ModuleInfo info() {\n        return modinfo;\n    }\n\n    /**\n     */\n    public String toString() {\n        return \"\" + modinfo.name + \"[id=\" + moduleID + \"]\";\n    }\n\n    /**\n     */\n    protected void finalize() {\n        System.err.println(toString() + \" finalized!\");\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/module/AbstractModuleTest0.java",
		"test_prompt": "// AbstractModuleTest0.java\npackage module;\n\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ResourceBundle;\nimport java.util.Locale;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractModule}.\n* It contains ten unit test cases for the {@link AbstractModule#request(Message)} method.\n*/\nclass AbstractModuleTest0 {"
	},
	{
		"original_code": "// AbstractModule.java\n/* $Id: AbstractModule.java,v 1.8 2004/05/04 23:08:22 emill Exp $ \n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Emil Lundstr�m <emill@kth.se>\n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.8 $\n *\n */\npackage module;\n\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ResourceBundle;\nimport java.util.Locale;\n\n@cvs(file = \"$RCSfile: AbstractModule.java,v $\", revision = \"$Revision: 1.8 $\", date = \"$Date: 2004/05/04 23:08:22 $\", author = \"$Author: emill $\", tag = \"$Name:  $\", build = \"\")\n@mod(name = \"AbstractModule\", topics = \"\", cmds = \"\", desc = \"This is module serves as abstract base class for other \" + \"modules to faciliate creation of new modules. It cannot \" + \"be instatiated directly.\")\npublic abstract class /**\n * This class provides skeletal implementation of the Module interface.\n * Inorder to implement the Module interface it is ...\n */\nAbstractModule implements Module {\n\n    /**\n     * Reference to the kernel of this module.\n     */\n    protected Kernel kernel;\n\n    /**\n     * The message queue used for storing incoming messages.\n     */\n    private List<Message> messages;\n\n    /**\n     * The number of instances of this class.\n     */\n    private static int moduleCount;\n\n    /**\n     * The ID of an instance of this module.\n     */\n    protected int moduleID;\n\n    /**\n     * Contains module specific information.\n     */\n    protected ModuleInfo modinfo;\n\n    /**\n     * Localized strings.\n     */\n    protected ResourceBundle locale;\n\n    /**\n     * true if this module is not (or should not be) running.\n     */\n    private boolean done;\n\n    /**\n     * The thread associated with this module.\n     */\n    private Thread thread;\n\n    /**\n     * Create a new instance of this Module. The module have to register\n     * with a Kernel in order to receive any messages.\n     */\n    public AbstractModule() {\n        synchronized (this) {\n            moduleID = moduleCount++;\n        }\n        /* Get the locale specific resource file. */\n        locale = ResourceBundle.getBundle(\"gangup\", Locale.getDefault());\n        /* Initialize this class' ModuleInfo structure. Values are\n\t   retrieved from the cvs and mod annotations made above. */\n        modinfo = new ModuleInfo(this);\n        /* Initialize message queue */\n        messages = Collections.synchronizedList(new LinkedList<Message>());\n    }\n\n    /**\n     * Create a new instance of this Module and register with the\n     * specified kernel in the default class.\n     *\n     * Right now, generally module constructors should take the kernel\n     * module as an argument.\n     *\n     * @param krn The kernel associated with this module.\n     */\n    public AbstractModule(Kernel krn) throws ModuleRegisterException {\n        this();\n        register(krn);\n    }\n\n    /**\n     * Create a new instance of this Module and register with the\n     * specified kernel and class.\n     *\n     * @param krn The kernel associated with this module.\n     * @param cls The class this module should be registered in.\n     */\n    public AbstractModule(Kernel krn, String cls) throws ModuleRegisterException, ModuleSubscriptionException {\n        this(krn);\n        subscribe(cls);\n    }\n\n    /**\n     * Register the specified kernel. A module is required to register with\n     * the kernel in order to subscribe to messages and in turn communicate\n     * with other modules.\n     *\n     * @param krn The kernel that this module should registered with.\n     * @throws ModuleRegisterException if the module is already registered.\n     */\n    public void register(Module krn) throws ModuleRegisterException {\n        if (krn instanceof Kernel) {\n            krn.register(this);\n            kernel = (Kernel) krn;\n        }\n    }\n\n    /**\n     * Unregister from specified Kernel. An unused module should unregister\n     * with the kernel so that all references to that module will be freed.\n     *\n     * @param krn The kernel with which we wish to unregister.\n     * @throws ModuleRegisterException if the module is not registered.\n     */\n    public void unregister(Module krn) throws ModuleRegisterException {\n        if (krn instanceof Kernel) {\n            krn.unregister(this);\n        }\n    }\n\n    /**\n     * Subscribes this module to all messages within the specified\n     * topic. When a module subscibes to a certain topic it notifies\n     * the kernel that it is interrested in receiving all messages\n     * that has the given topic.\n     *\n     * @param topic The topic on which to subscribe.\n     */\n    protected void subscribe(String topic) throws ModuleSubscriptionException {\n        if (topic != null) {\n            kernel.subscribe(this, topic);\n        }\n    }\n\n    /**\n     * Start executing the run method in a separate thread. This method\n     * is invoked automatically be the Kernel when the module is loaded\n     * and should not be invoked manually.\n     */\n    public void start() {\n        thread = new Thread(this, modinfo.name);\n        thread.start();\n    }\n\n    /**\n     * This is this module's thread entry point. It handles most of the\n     * common module functionality. Subclasses should not override this\n     * method in order to customize the module's behavior. Instead the\n     * subclasses should implement the init(), step(), and free() methods.\n     */\n    public void run() {\n        init();\n        done = false;\n        while (!done) {\n            try {\n                processMessages();\n                step();\n                Thread.sleep(100);\n            } catch (Exception e) {\n                System.err.println(e);\n                // e.printStackTrace();\n            }\n        }\n        free();\n    }\n\n    /**\n     * Terminate the current thread. This method should be called if\n     * the module wishes to terminate its main processing thread.\n     */\n    protected final void exit() {\n        /* wonder if unregistering and unsubscribing should be \n\t   placed here? */\n        done = true;\n    }\n\n    /**\n     * Method to run recurrently in the loop of run(). This method\n     * should never be blocking, lest the module will not be able to\n     * process any messages.\n     */\n    protected void step() {\n    }\n\n    /**\n     * Initialization method for modules. Using init() is recommended\n     * instead of overloading the constructor.\n     */\n    protected void init() {\n    }\n\n    /**\n     * Exit method for modules. This method is invoked after a call to\n     * the @see exit() method. Modules should overload this method with\n     * code to do a proper exit.\n     */\n    protected void free() {\n    }\n\n    /**\n     * Handles what should done with messages sent to this module.\n     *\n     * @param msg The message to be processed.\n     */\n    protected void processMessage(Message msg) {\n    }\n\n    /**\n     * Handles what should done with kernel messages sent to this module.\n     *\n     * @param msg The message to be processed.\n     */\n    protected void processKernelMessage(Message msg) throws MessageProcessingException {\n        if (msg == null || msg.body == null) {\n            throw new MessageProcessingException(msg, \"invalid message!\");\n        }\n        try {\n            if (msg.body.equals(\"REGISTERED\")) {\n                subscribe(modinfo.topics);\n            } else if (msg.body.equals(\"UNREGISTERED\")) {\n                exit();\n            }\n        } catch (Exception e) {\n            sendMessage(new Message(\"WARNING\", \"unable to subscribe!\"));\n            throw new MessageProcessingException(msg, e);\n        }\n    }\n\n    /**\n     * Processes and removes the messages in the queue. The messages are\n     * processed in the order they were received.\n     */\n    private void processMessages() throws MessageProcessingException {\n        Message m = null;\n        try {\n            while (!messages.isEmpty()) {\n                m = messages.remove(0);\n                if (m.header.equals(\"KERNEL\")) {\n                    processKernelMessage(m);\n                } else {\n                    processMessage(m);\n                }\n                m.unref();\n                m = null;\n            }\n        } catch (Exception e) {\n            if (m != null) {\n                m.unref();\n            }\n            throw new MessageProcessingException(e);\n        }\n    }\n\n    /**\n     * Delivers the specified message to the kernel. At the moment there's\n     * no way of telling if the message got delivered or not.\n     *\n     * @param msg The message to be delivered.\n     */\n    public void sendMessage(/*AndIDontCareIfItDoesntWork*/\n    Message msg) {\n        try {\n            msg.sender = modinfo.name;\n            kernel.receiveMessage(msg);\n        } catch (MessageDeliveryException e) {\n            // catch it here, it breaks to many modules if we were to\n            // let it propagate right now.\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * Called by the kernel to put a Message in this module's queue.\n     *\n     * @param msg The message that was received.\n     */\n    public void receiveMessage(Message msg) {\n        msg.ref();\n        messages.add(msg);\n    }\n\n    /**\n     * Requests the specified query from the specified topic. Observe that\n     * if there are more than one module answering a specific request, only\n     * the first one will be returned.\n     *\n     * @param msg The message containing the request.\n     *\n     * @throws MessageTimeoutException\n     * If the request times out before we receive any replies.\n     */\n    public Message request(Message msg) throws MessageTimeoutException {\n        try {\n            Message r = null;\n            int latestIndex = -1;\n            long timeout = System.currentTimeMillis() + msg.timetolive;\n            sendMessage(msg);\n            /* Wait until we receive a response to our request or until\n\t       the specified timeout occurs. */\n            while (System.currentTimeMillis() < timeout) {\n                if (!messages.isEmpty()) {\n                    for (int i = messages.size() - 1; i > latestIndex; i--) {\n                        r = messages.get(i);\n                        if (r.sessionID == msg.sessionID && r.messageID != msg.messageID) {\n                            messages.remove(r);\n                            r.unref();\n                            return r;\n                        }\n                    }\n                    latestIndex = messages.size() - 1;\n                    /* Keep processing other messages. */\n                    /*\n\t\t    if (r.header.equals(\"KERNEL\")) {\n\t\t\tprocessKernelMessage(r);\n\t\t    } else {\n\t\t\tprocessMessage(r);\n\t\t    }\n\n\t\t    r.unref(); */\n                    // Thread.currentThread().yield();\n                }\n                Thread.sleep(10);\n            }\n        } catch (Exception e) {\n            // throw new MessageRequestException(e);\n        } finally {\n            msg.unref();\n        }\n        throw new MessageTimeoutException(\"Sorry, your request timed out!\");\n    }\n\n    /**\n     * Requests the specified query from the specified topic. Observe that\n     * if there are more than one module answering a specific request, only\n     * the first one will be honored.\n     *\n     * @param topic The topic in which to make the request.\n     * @param query The request to be made.\n     *\n     * @throws MessageTimeoutException\n     * If the request times out before we receive any replies.\n     */\n    public Message request(String topic, String query) throws MessageTimeoutException {\n        return request(new Message(topic, query));\n    }\n\n    /**\n     * Returns the Kernel associated with this Module.\n     * @return the Kernel associated with this Module.\n     */\n    public Kernel getKernel() {\n        return kernel;\n    }\n\n    /**\n     * Returns the thread associated with this module.\n     * @return The thread associated with this module.\n     */\n    public Thread getThread() {\n        return thread;\n    }\n\n    /**\n     * Returns the module info associated whith this module.\n     * @return the module info associated whith this module.\n     */\n    public ModuleInfo info() {\n        return modinfo;\n    }\n\n    /**\n     */\n    public String toString() {\n        return \"\" + modinfo.name + \"[id=\" + moduleID + \"]\";\n    }\n\n    /**\n     */\n    protected void finalize() {\n        System.err.println(toString() + \" finalized!\");\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/module/AbstractModuleTest1.java",
		"test_prompt": "// AbstractModuleTest1.java\npackage module;\n\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ResourceBundle;\nimport java.util.Locale;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractModule}.\n* It contains ten unit test cases for the {@link AbstractModule#request(String, String)} method.\n*/\nclass AbstractModuleTest1 {"
	},
	{
		"original_code": "// AbstractModule.java\n/* $Id: AbstractModule.java,v 1.8 2004/05/04 23:08:22 emill Exp $ \n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Emil Lundstr�m <emill@kth.se>\n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.8 $\n *\n */\npackage module;\n\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ResourceBundle;\nimport java.util.Locale;\n\n@cvs(file = \"$RCSfile: AbstractModule.java,v $\", revision = \"$Revision: 1.8 $\", date = \"$Date: 2004/05/04 23:08:22 $\", author = \"$Author: emill $\", tag = \"$Name:  $\", build = \"\")\n@mod(name = \"AbstractModule\", topics = \"\", cmds = \"\", desc = \"This is module serves as abstract base class for other \" + \"modules to faciliate creation of new modules. It cannot \" + \"be instatiated directly.\")\npublic abstract class /**\n * This class provides skeletal implementation of the Module interface.\n * Inorder to implement the Module interface it is ...\n */\nAbstractModule implements Module {\n\n    /**\n     * Reference to the kernel of this module.\n     */\n    protected Kernel kernel;\n\n    /**\n     * The message queue used for storing incoming messages.\n     */\n    private List<Message> messages;\n\n    /**\n     * The number of instances of this class.\n     */\n    private static int moduleCount;\n\n    /**\n     * The ID of an instance of this module.\n     */\n    protected int moduleID;\n\n    /**\n     * Contains module specific information.\n     */\n    protected ModuleInfo modinfo;\n\n    /**\n     * Localized strings.\n     */\n    protected ResourceBundle locale;\n\n    /**\n     * true if this module is not (or should not be) running.\n     */\n    private boolean done;\n\n    /**\n     * The thread associated with this module.\n     */\n    private Thread thread;\n\n    /**\n     * Create a new instance of this Module. The module have to register\n     * with a Kernel in order to receive any messages.\n     */\n    public AbstractModule() {\n        synchronized (this) {\n            moduleID = moduleCount++;\n        }\n        /* Get the locale specific resource file. */\n        locale = ResourceBundle.getBundle(\"gangup\", Locale.getDefault());\n        /* Initialize this class' ModuleInfo structure. Values are\n\t   retrieved from the cvs and mod annotations made above. */\n        modinfo = new ModuleInfo(this);\n        /* Initialize message queue */\n        messages = Collections.synchronizedList(new LinkedList<Message>());\n    }\n\n    /**\n     * Create a new instance of this Module and register with the\n     * specified kernel in the default class.\n     *\n     * Right now, generally module constructors should take the kernel\n     * module as an argument.\n     *\n     * @param krn The kernel associated with this module.\n     */\n    public AbstractModule(Kernel krn) throws ModuleRegisterException {\n        this();\n        register(krn);\n    }\n\n    /**\n     * Create a new instance of this Module and register with the\n     * specified kernel and class.\n     *\n     * @param krn The kernel associated with this module.\n     * @param cls The class this module should be registered in.\n     */\n    public AbstractModule(Kernel krn, String cls) throws ModuleRegisterException, ModuleSubscriptionException {\n        this(krn);\n        subscribe(cls);\n    }\n\n    /**\n     * Register the specified kernel. A module is required to register with\n     * the kernel in order to subscribe to messages and in turn communicate\n     * with other modules.\n     *\n     * @param krn The kernel that this module should registered with.\n     * @throws ModuleRegisterException if the module is already registered.\n     */\n    public void register(Module krn) throws ModuleRegisterException {\n        if (krn instanceof Kernel) {\n            krn.register(this);\n            kernel = (Kernel) krn;\n        }\n    }\n\n    /**\n     * Unregister from specified Kernel. An unused module should unregister\n     * with the kernel so that all references to that module will be freed.\n     *\n     * @param krn The kernel with which we wish to unregister.\n     * @throws ModuleRegisterException if the module is not registered.\n     */\n    public void unregister(Module krn) throws ModuleRegisterException {\n        if (krn instanceof Kernel) {\n            krn.unregister(this);\n        }\n    }\n\n    /**\n     * Subscribes this module to all messages within the specified\n     * topic. When a module subscibes to a certain topic it notifies\n     * the kernel that it is interrested in receiving all messages\n     * that has the given topic.\n     *\n     * @param topic The topic on which to subscribe.\n     */\n    protected void subscribe(String topic) throws ModuleSubscriptionException {\n        if (topic != null) {\n            kernel.subscribe(this, topic);\n        }\n    }\n\n    /**\n     * Start executing the run method in a separate thread. This method\n     * is invoked automatically be the Kernel when the module is loaded\n     * and should not be invoked manually.\n     */\n    public void start() {\n        thread = new Thread(this, modinfo.name);\n        thread.start();\n    }\n\n    /**\n     * This is this module's thread entry point. It handles most of the\n     * common module functionality. Subclasses should not override this\n     * method in order to customize the module's behavior. Instead the\n     * subclasses should implement the init(), step(), and free() methods.\n     */\n    public void run() {\n        init();\n        done = false;\n        while (!done) {\n            try {\n                processMessages();\n                step();\n                Thread.sleep(100);\n            } catch (Exception e) {\n                System.err.println(e);\n                // e.printStackTrace();\n            }\n        }\n        free();\n    }\n\n    /**\n     * Terminate the current thread. This method should be called if\n     * the module wishes to terminate its main processing thread.\n     */\n    protected final void exit() {\n        /* wonder if unregistering and unsubscribing should be \n\t   placed here? */\n        done = true;\n    }\n\n    /**\n     * Method to run recurrently in the loop of run(). This method\n     * should never be blocking, lest the module will not be able to\n     * process any messages.\n     */\n    protected void step() {\n    }\n\n    /**\n     * Initialization method for modules. Using init() is recommended\n     * instead of overloading the constructor.\n     */\n    protected void init() {\n    }\n\n    /**\n     * Exit method for modules. This method is invoked after a call to\n     * the @see exit() method. Modules should overload this method with\n     * code to do a proper exit.\n     */\n    protected void free() {\n    }\n\n    /**\n     * Handles what should done with messages sent to this module.\n     *\n     * @param msg The message to be processed.\n     */\n    protected void processMessage(Message msg) {\n    }\n\n    /**\n     * Handles what should done with kernel messages sent to this module.\n     *\n     * @param msg The message to be processed.\n     */\n    protected void processKernelMessage(Message msg) throws MessageProcessingException {\n        if (msg == null || msg.body == null) {\n            throw new MessageProcessingException(msg, \"invalid message!\");\n        }\n        try {\n            if (msg.body.equals(\"REGISTERED\")) {\n                subscribe(modinfo.topics);\n            } else if (msg.body.equals(\"UNREGISTERED\")) {\n                exit();\n            }\n        } catch (Exception e) {\n            sendMessage(new Message(\"WARNING\", \"unable to subscribe!\"));\n            throw new MessageProcessingException(msg, e);\n        }\n    }\n\n    /**\n     * Processes and removes the messages in the queue. The messages are\n     * processed in the order they were received.\n     */\n    private void processMessages() throws MessageProcessingException {\n        Message m = null;\n        try {\n            while (!messages.isEmpty()) {\n                m = messages.remove(0);\n                if (m.header.equals(\"KERNEL\")) {\n                    processKernelMessage(m);\n                } else {\n                    processMessage(m);\n                }\n                m.unref();\n                m = null;\n            }\n        } catch (Exception e) {\n            if (m != null) {\n                m.unref();\n            }\n            throw new MessageProcessingException(e);\n        }\n    }\n\n    /**\n     * Delivers the specified message to the kernel. At the moment there's\n     * no way of telling if the message got delivered or not.\n     *\n     * @param msg The message to be delivered.\n     */\n    public void sendMessage(/*AndIDontCareIfItDoesntWork*/\n    Message msg) {\n        try {\n            msg.sender = modinfo.name;\n            kernel.receiveMessage(msg);\n        } catch (MessageDeliveryException e) {\n            // catch it here, it breaks to many modules if we were to\n            // let it propagate right now.\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * Called by the kernel to put a Message in this module's queue.\n     *\n     * @param msg The message that was received.\n     */\n    public void receiveMessage(Message msg) {\n        msg.ref();\n        messages.add(msg);\n    }\n\n    /**\n     * Requests the specified query from the specified topic. Observe that\n     * if there are more than one module answering a specific request, only\n     * the first one will be returned.\n     *\n     * @param msg The message containing the request.\n     *\n     * @throws MessageTimeoutException\n     * If the request times out before we receive any replies.\n     */\n    public Message request(Message msg) throws MessageTimeoutException {\n        try {\n            Message r = null;\n            int latestIndex = -1;\n            long timeout = System.currentTimeMillis() + msg.timetolive;\n            sendMessage(msg);\n            /* Wait until we receive a response to our request or until\n\t       the specified timeout occurs. */\n            while (System.currentTimeMillis() < timeout) {\n                if (!messages.isEmpty()) {\n                    for (int i = messages.size() - 1; i > latestIndex; i--) {\n                        r = messages.get(i);\n                        if (r.sessionID == msg.sessionID && r.messageID != msg.messageID) {\n                            messages.remove(r);\n                            r.unref();\n                            return r;\n                        }\n                    }\n                    latestIndex = messages.size() - 1;\n                    /* Keep processing other messages. */\n                    /*\n\t\t    if (r.header.equals(\"KERNEL\")) {\n\t\t\tprocessKernelMessage(r);\n\t\t    } else {\n\t\t\tprocessMessage(r);\n\t\t    }\n\n\t\t    r.unref(); */\n                    // Thread.currentThread().yield();\n                }\n                Thread.sleep(10);\n            }\n        } catch (Exception e) {\n            // throw new MessageRequestException(e);\n        } finally {\n            msg.unref();\n        }\n        throw new MessageTimeoutException(\"Sorry, your request timed out!\");\n    }\n\n    /**\n     * Requests the specified query from the specified topic. Observe that\n     * if there are more than one module answering a specific request, only\n     * the first one will be honored.\n     *\n     * @param topic The topic in which to make the request.\n     * @param query The request to be made.\n     *\n     * @throws MessageTimeoutException\n     * If the request times out before we receive any replies.\n     */\n    public Message request(String topic, String query) throws MessageTimeoutException {\n        return request(new Message(topic, query));\n    }\n\n    /**\n     * Returns the Kernel associated with this Module.\n     * @return the Kernel associated with this Module.\n     */\n    public Kernel getKernel() {\n        return kernel;\n    }\n\n    /**\n     * Returns the thread associated with this module.\n     * @return The thread associated with this module.\n     */\n    public Thread getThread() {\n        return thread;\n    }\n\n    /**\n     * Returns the module info associated whith this module.\n     * @return the module info associated whith this module.\n     */\n    public ModuleInfo info() {\n        return modinfo;\n    }\n\n    /**\n     */\n    public String toString() {\n        return \"\" + modinfo.name + \"[id=\" + moduleID + \"]\";\n    }\n\n    /**\n     */\n    protected void finalize() {\n        System.err.println(toString() + \" finalized!\");\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/module/AbstractModuleTest2.java",
		"test_prompt": "// AbstractModuleTest2.java\npackage module;\n\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ResourceBundle;\nimport java.util.Locale;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractModule}.\n* It contains ten unit test cases for the {@link AbstractModule#info()} method.\n*/\nclass AbstractModuleTest2 {"
	},
	{
		"original_code": "// IRCProxyModule.java\n/* $Id: IRCProxyModule.java,v 1.3 2004/04/27 19:26:21 bja Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.3 $\n *\n */\npackage module;\n\nimport java.util.*;\nimport java.util.regex.*;\nimport java.net.*;\nimport java.io.*;\nimport state.*;\n\n@cvs(file = \"$RCSfile: IRCProxyModule.java,v $\", revision = \"$Revision: 1.3 $\", date = \"$Date: 2004/04/27 19:26:21 $\", author = \"$Author: bja $\", tag = \"$Name:  $\", build = \"\")\n@mod(name = \"IRCProxyModule\", topics = \"IRC IRCC IRCQ\", cmds = \"\", desc = \"Simple IRC proxy for debugging.\")\nclass /**\n * The IRCProxyModle class provides methods for communicating using the\n * IRC network.\n */\nIRCProxyModule extends AbstractModule {\n\n    /**\n     * The session used for communicating with the IRC server.\n     */\n    private IRCSession session;\n\n    /**\n     * Pattern used by this module to filter input.\n     */\n    private Pattern[] pattern;\n\n    /**\n     * Contains the users that automatically shall receive op.\n     */\n    private HashSet<String> oplist;\n\n    /**\n     * Localized strings.\n     */\n    protected ResourceBundle locale;\n\n    /**\n     * Contains module specific information.\n     */\n    protected ModuleInfo modinfo;\n\n    /**\n     * Create a new instance of the IRCProxyModule.\n     */\n    public IRCProxyModule() {\n    }\n\n    /**\n     * Create a new instance of the IRCProxyModule with the specified\n     * argument.\n     *\n     * @param krn The Kernel associated with this instance.\n     * @throws ModuleRegisterException If the registration fails.\n     */\n    public IRCProxyModule(Kernel krn) throws ModuleRegisterException {\n        super(krn);\n    }\n\n    /**\n     * Connects to a IRC network using default values for nick, channel,\n     * server, and port from the configuration file.\n     *\n     * @return If succesful, the IRCSession associated with the server.\n     *\n     * @throws UnknownHostException\n     * @throws IOException\n     */\n    public IRCSession ircConnect() {\n        try {\n            String[] val;\n            Message r;\n            r = request(\"CONFIG\", \"GETS IRCProxy nick,channel,server,port\");\n            val = ((String) r.body).split(\"\\n\");\n            session = ircConnect(val[0], val[2], Integer.parseInt(val[3]));\n            session.join(val[1]);\n        } catch (UnknownHostException e) {\n            e.printStackTrace(System.err);\n        } catch (IOException e) {\n            e.printStackTrace(System.err);\n        } catch (MessageTimeoutException e) {\n            e.printStackTrace(System.err);\n        } catch (NullPointerException e) {\n            e.printStackTrace(System.err);\n        }\n        return session;\n    }\n\n    /**\n     * Connects to a IRC server on the specified host and port.\n     *\n     * @param nick The nickname to use in this session.\n     * @param host The hostname of the server.\n     * @param port The port to connect to.\n     *\n     * @return If succesful, the IRCSession associated with the server.\n     *\n     * @throws UnknownHostException\n     * @throws IOException\n     */\n    public IRCSession ircConnect(String nick, String host, int port) throws UnknownHostException, IOException {\n        return new IRCSession(nick, host, port);\n    }\n\n    /**\n     * Disconnects from the current IRC server.\n     */\n    public void ircDisconnect() {\n        session.close();\n        session = null;\n    }\n\n    /**\n     * Sends the specified message to the specified channel.\n     *\n     * @param msg The message that is to be sent.\n     * @param chan The channel to which the message should be sent.\n     */\n    public void ircSendMessage(String msg, String chan) {\n        session.send(msg, chan);\n    }\n\n    /**\n     */\n    protected void init() {\n        /* Get the locale specific resource file. */\n        locale = ResourceBundle.getBundle(\"gangup\", Locale.getDefault());\n        /* Initialize this class' ModuleInfo structure. Values are\n\t   retrieved from the cvs and mod annotations made above. */\n        // see bugs!\n        modinfo = new ModuleInfo(this);\n        oplist = new HashSet<String>();\n        oplist.add(\"bja\");\n        oplist.add(\"istari\");\n        oplist.add(\"takashi\");\n        oplist.add(\"njursten\");\n        oplist.add(\"bartek\");\n        pattern = new Pattern[10];\n        pattern[0] = Pattern.compile(\"PING :(.+)\");\n        pattern[1] = Pattern.compile(\".*IRCProxy: ([A-Za-z0-9]+) (.+)\");\n        pattern[2] = Pattern.compile(\".* (PRIVMSG #[A-Za-z0-9]+) .*\");\n    }\n\n    /**\n     */\n    protected void step() {\n        Matcher m = null;\n        if (session == null) {\n            return;\n        }\n        /* nothing to do */\n        try {\n            String[] tmp = null;\n            String str = session.recv(false);\n            if (str.length() == 0) {\n                return;\n            }\n            System.out.println(str);\n            /* Check for the server ping request. */\n            m = pattern[0].matcher(str);\n            if (m.matches()) {\n                session.quote(\"PONG \" + m.group(1));\n                System.out.println(\"PONG \" + m.group(1));\n            }\n            tmp = str.split(\" \");\n            /* Check for user specified commands. */\n            if (tmp.length > 3 && tmp[1].contains(\"PRIVMSG\") && tmp[3].startsWith(\":!\")) {\n                String cmd = tmp[3].substring(2);\n                String arg = \"\";\n                session.channel(tmp[2]);\n                if (cmd.equals(\"help\")) {\n                    session.send(\"There is no help yet!\");\n                }\n                if (cmd.equals(\"quote\")) {\n                    if (tmp.length < 5) {\n                        session.send(\"usage: quote MESSAGE\");\n                    } else {\n                        for (int i = 4; i < tmp.length; arg += tmp[i++] + \" \") ;\n                        session.quote(arg);\n                    }\n                }\n                if (cmd.equals(\"send\")) {\n                    if (tmp.length < 6) {\n                        session.send(\"usage: send HEAD BODY\");\n                    } else {\n                        for (int i = 5; i < tmp.length; arg += tmp[i++] + \" \") ;\n                        sendMessage(new Message(tmp[4], arg));\n                    }\n                }\n                if (cmd.equals(\"action\")) {\n                    if (tmp.length < 8) {\n                        session.send(\"usage: action HEAD action actor target\");\n                    } else {\n                        try {\n                            sendMessage(new Message(tmp[4], new Action(Integer.parseInt(tmp[5]), Integer.parseInt(tmp[6]), Integer.parseInt(tmp[7]))));\n                        } catch (NumberFormatException nfe) {\n                            session.send(\"error: action/actor/target \" + \"isn't an int.\");\n                        }\n                    }\n                }\n                if (cmd.equals(\"event\")) {\n                    if (tmp.length < 8) {\n                        session.send(\"usage: event HEAD event actor target\");\n                    } else {\n                        try {\n                            sendMessage(new Message(tmp[4], new NetworkData(null, new GameEvent(Integer.parseInt(tmp[6]), Integer.parseInt(tmp[7]), Integer.parseInt(tmp[5])))));\n                        } catch (NumberFormatException nfe) {\n                            session.send(\"error: event/actor/target \" + \"isn't an int.\");\n                        }\n                    }\n                }\n                if (cmd.equals(\"textmessage\")) {\n                    if (tmp.length < 9) {\n                        session.send(\"usage: textmessage HEAD messagetype actor target text\");\n                    } else {\n                        try {\n                            sendMessage(new Message(tmp[4], new TextMessage(Integer.parseInt(tmp[6]), Integer.parseInt(tmp[7]), Integer.parseInt(tmp[5]), tmp[8])));\n                        } catch (NumberFormatException nfe) {\n                            session.send(\"error: action/actor/target \" + \"isn't an int.\");\n                        }\n                    }\n                }\n                if (cmd.equals(\"join\")) {\n                    if (tmp.length < 5) {\n                        session.send(\"usage: join CHANNEL\");\n                    } else {\n                        session.join(tmp[4]);\n                    }\n                }\n                if (cmd.equals(\"part\")) {\n                    if (tmp.length < 5) {\n                        session.send(\"usage: part CHANNEL\");\n                    } else {\n                        session.part(tmp[4]);\n                    }\n                }\n                if (cmd.equals(\"chan\")) {\n                    if (tmp.length < 5) {\n                        session.send(\"usage: chan CHANNEL\");\n                    } else {\n                        session.channel(tmp[4]);\n                    }\n                }\n                if (cmd.equals(\"quit\")) {\n                    session.close();\n                    exit();\n                }\n            }\n            /* Check for new Messages to deliver. */\n            m = pattern[1].matcher(str);\n            if (m.matches()) {\n                Message msg = new Message(m.group(1), m.group(2));\n                sendMessage(msg);\n            }\n        } catch (IOException e) {\n            e.printStackTrace(System.err);\n        }\n    }\n\n    /**\n     * Processes the specified message.\n     * @param m The message to process.\n     */\n    protected void processMessage(Message m) {\n        String[] data = ((String) m.body).split(\" \");\n        if (m.header.equals(\"IRCQ\")) {\n            session.quote(m.body.toString());\n        } else if (m.header.equals(\"IRC\")) {\n            session.send(m.body.toString());\n        }\n    }\n}\n\n/**\n * This class provides a simple wrapper around the IRC protocol. A class\n * that wishes to use IRC simply has to create a new instance of this\n * class and then use the send and recv methods.\n */\nclass IRCSession {\n\n    private static final String CRLF = \"\\r\\n\";\n\n    private static final String EMPTY = \"\";\n\n    Socket socket;\n\n    PrintWriter out;\n\n    BufferedReader in;\n\n    String chan = null;\n\n    String nick = null;\n\n    /**\n     * @param nick\n     * @param host\n     * @param port\n     */\n    public IRCSession(String nick, String host, int port) throws UnknownHostException, IOException {\n        socket = open(nick, host, port);\n    }\n\n    /**\n     * Send the specified message to the current channel or user.\n     * @param msg The message that is to be sent.\n     */\n    public void send(String msg) {\n        quote(\"PRIVMSG \" + chan + \" :\" + msg);\n    }\n\n    /**\n     * Send the specified message to the specified channel or user.\n     * @param msg The message that is to be sent.\n     * @param dst The channel or user to send message to.\n     */\n    public void send(String msg, String dst) {\n        quote(\"PRIVMSG \" + dst + \" :\" + msg);\n    }\n\n    /**\n     * @param msg The message that is to be sent.\n     */\n    public void quote(String msg) {\n        out.print(msg + CRLF);\n        out.flush();\n    }\n\n    /**\n     * @param block True if this method should block.\n     * @return The received message.\n     */\n    public String recv(boolean block) throws IOException {\n        if (block || in.ready()) {\n            return in.readLine();\n        } else {\n            return EMPTY;\n        }\n    }\n\n    /**\n     * Joins the specified channel.\n     *\n     * @param chan The channel to join.\n     */\n    public void join(String chan) {\n        this.chan = chan;\n        quote(\"JOIN \" + chan);\n    }\n\n    /**\n     * Parts with the specified channel.\n     *\n     * @param chan The channel to part with.\n     */\n    public void part(String chan) {\n        quote(\"PART \" + chan);\n    }\n\n    /**\n     * Sets the currently active channel.\n     *\n     * @param chan The channel to part with.\n     */\n    public void channel(String chan) {\n        this.chan = chan;\n    }\n\n    /**\n     * Sends the pong reply to the ping request from server.\n     * @param ping The ping request made by the server.\n     */\n    public void pong(String ping) {\n        quote(ping.replace('I', 'O'));\n    }\n\n    /**\n     * @param nick\n     * @param host\n     * @param port\n     */\n    public Socket open(String nick, String host, int port) throws UnknownHostException, IOException {\n        Socket sock = new Socket(host, port);\n        String str = null;\n        boolean done = false;\n        OutputStreamWriter osw;\n        InputStreamReader isr;\n        osw = new OutputStreamWriter(sock.getOutputStream());\n        isr = new InputStreamReader(sock.getInputStream());\n        this.out = new PrintWriter(new BufferedWriter(osw));\n        this.in = new BufferedReader(isr);\n        this.nick = nick;\n        quote(\"NICK \" + nick);\n        quote(\"USER jvm arachnid \" + host + \" :IRCProxyModule\\r\\n\");\n        // fixme - not all servers use this!\n        do {\n            str = in.readLine();\n            System.err.println(str);\n        } while (!str.contains(\"PING\") && !str.contains(\"Welcome\"));\n        if (str.contains(\"PING\")) {\n            pong(str);\n        }\n        return sock;\n    }\n\n    /**\n     * @throws IOException\n     */\n    public void close() /* throws IOException */\n    {\n        quote(\"QUIT\");\n        try {\n            out.flush();\n            socket.shutdownInput();\n            socket.shutdownOutput();\n            in.close();\n            out.close();\n            socket.close();\n        } catch (SocketException e) {\n        } catch (IOException e) {\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/module/IRCProxyModuleTest0.java",
		"test_prompt": "// IRCProxyModuleTest0.java\npackage module;\n\nimport java.util.*;\nimport java.util.regex.*;\nimport java.net.*;\nimport java.io.*;\nimport state.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link IRCProxyModule}.\n* It contains ten unit test cases for the {@link IRCProxyModule#ircConnect()} method.\n*/\nclass IRCProxyModuleTest0 {"
	},
	{
		"original_code": "// IRCProxyModule.java\n/* $Id: IRCProxyModule.java,v 1.3 2004/04/27 19:26:21 bja Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.3 $\n *\n */\npackage module;\n\nimport java.util.*;\nimport java.util.regex.*;\nimport java.net.*;\nimport java.io.*;\nimport state.*;\n\n@cvs(file = \"$RCSfile: IRCProxyModule.java,v $\", revision = \"$Revision: 1.3 $\", date = \"$Date: 2004/04/27 19:26:21 $\", author = \"$Author: bja $\", tag = \"$Name:  $\", build = \"\")\n@mod(name = \"IRCProxyModule\", topics = \"IRC IRCC IRCQ\", cmds = \"\", desc = \"Simple IRC proxy for debugging.\")\nclass /**\n * The IRCProxyModle class provides methods for communicating using the\n * IRC network.\n */\nIRCProxyModule extends AbstractModule {\n\n    /**\n     * The session used for communicating with the IRC server.\n     */\n    private IRCSession session;\n\n    /**\n     * Pattern used by this module to filter input.\n     */\n    private Pattern[] pattern;\n\n    /**\n     * Contains the users that automatically shall receive op.\n     */\n    private HashSet<String> oplist;\n\n    /**\n     * Localized strings.\n     */\n    protected ResourceBundle locale;\n\n    /**\n     * Contains module specific information.\n     */\n    protected ModuleInfo modinfo;\n\n    /**\n     * Create a new instance of the IRCProxyModule.\n     */\n    public IRCProxyModule() {\n    }\n\n    /**\n     * Create a new instance of the IRCProxyModule with the specified\n     * argument.\n     *\n     * @param krn The Kernel associated with this instance.\n     * @throws ModuleRegisterException If the registration fails.\n     */\n    public IRCProxyModule(Kernel krn) throws ModuleRegisterException {\n        super(krn);\n    }\n\n    /**\n     * Connects to a IRC network using default values for nick, channel,\n     * server, and port from the configuration file.\n     *\n     * @return If succesful, the IRCSession associated with the server.\n     *\n     * @throws UnknownHostException\n     * @throws IOException\n     */\n    public IRCSession ircConnect() {\n        try {\n            String[] val;\n            Message r;\n            r = request(\"CONFIG\", \"GETS IRCProxy nick,channel,server,port\");\n            val = ((String) r.body).split(\"\\n\");\n            session = ircConnect(val[0], val[2], Integer.parseInt(val[3]));\n            session.join(val[1]);\n        } catch (UnknownHostException e) {\n            e.printStackTrace(System.err);\n        } catch (IOException e) {\n            e.printStackTrace(System.err);\n        } catch (MessageTimeoutException e) {\n            e.printStackTrace(System.err);\n        } catch (NullPointerException e) {\n            e.printStackTrace(System.err);\n        }\n        return session;\n    }\n\n    /**\n     * Connects to a IRC server on the specified host and port.\n     *\n     * @param nick The nickname to use in this session.\n     * @param host The hostname of the server.\n     * @param port The port to connect to.\n     *\n     * @return If succesful, the IRCSession associated with the server.\n     *\n     * @throws UnknownHostException\n     * @throws IOException\n     */\n    public IRCSession ircConnect(String nick, String host, int port) throws UnknownHostException, IOException {\n        return new IRCSession(nick, host, port);\n    }\n\n    /**\n     * Disconnects from the current IRC server.\n     */\n    public void ircDisconnect() {\n        session.close();\n        session = null;\n    }\n\n    /**\n     * Sends the specified message to the specified channel.\n     *\n     * @param msg The message that is to be sent.\n     * @param chan The channel to which the message should be sent.\n     */\n    public void ircSendMessage(String msg, String chan) {\n        session.send(msg, chan);\n    }\n\n    /**\n     */\n    protected void init() {\n        /* Get the locale specific resource file. */\n        locale = ResourceBundle.getBundle(\"gangup\", Locale.getDefault());\n        /* Initialize this class' ModuleInfo structure. Values are\n\t   retrieved from the cvs and mod annotations made above. */\n        // see bugs!\n        modinfo = new ModuleInfo(this);\n        oplist = new HashSet<String>();\n        oplist.add(\"bja\");\n        oplist.add(\"istari\");\n        oplist.add(\"takashi\");\n        oplist.add(\"njursten\");\n        oplist.add(\"bartek\");\n        pattern = new Pattern[10];\n        pattern[0] = Pattern.compile(\"PING :(.+)\");\n        pattern[1] = Pattern.compile(\".*IRCProxy: ([A-Za-z0-9]+) (.+)\");\n        pattern[2] = Pattern.compile(\".* (PRIVMSG #[A-Za-z0-9]+) .*\");\n    }\n\n    /**\n     */\n    protected void step() {\n        Matcher m = null;\n        if (session == null) {\n            return;\n        }\n        /* nothing to do */\n        try {\n            String[] tmp = null;\n            String str = session.recv(false);\n            if (str.length() == 0) {\n                return;\n            }\n            System.out.println(str);\n            /* Check for the server ping request. */\n            m = pattern[0].matcher(str);\n            if (m.matches()) {\n                session.quote(\"PONG \" + m.group(1));\n                System.out.println(\"PONG \" + m.group(1));\n            }\n            tmp = str.split(\" \");\n            /* Check for user specified commands. */\n            if (tmp.length > 3 && tmp[1].contains(\"PRIVMSG\") && tmp[3].startsWith(\":!\")) {\n                String cmd = tmp[3].substring(2);\n                String arg = \"\";\n                session.channel(tmp[2]);\n                if (cmd.equals(\"help\")) {\n                    session.send(\"There is no help yet!\");\n                }\n                if (cmd.equals(\"quote\")) {\n                    if (tmp.length < 5) {\n                        session.send(\"usage: quote MESSAGE\");\n                    } else {\n                        for (int i = 4; i < tmp.length; arg += tmp[i++] + \" \") ;\n                        session.quote(arg);\n                    }\n                }\n                if (cmd.equals(\"send\")) {\n                    if (tmp.length < 6) {\n                        session.send(\"usage: send HEAD BODY\");\n                    } else {\n                        for (int i = 5; i < tmp.length; arg += tmp[i++] + \" \") ;\n                        sendMessage(new Message(tmp[4], arg));\n                    }\n                }\n                if (cmd.equals(\"action\")) {\n                    if (tmp.length < 8) {\n                        session.send(\"usage: action HEAD action actor target\");\n                    } else {\n                        try {\n                            sendMessage(new Message(tmp[4], new Action(Integer.parseInt(tmp[5]), Integer.parseInt(tmp[6]), Integer.parseInt(tmp[7]))));\n                        } catch (NumberFormatException nfe) {\n                            session.send(\"error: action/actor/target \" + \"isn't an int.\");\n                        }\n                    }\n                }\n                if (cmd.equals(\"event\")) {\n                    if (tmp.length < 8) {\n                        session.send(\"usage: event HEAD event actor target\");\n                    } else {\n                        try {\n                            sendMessage(new Message(tmp[4], new NetworkData(null, new GameEvent(Integer.parseInt(tmp[6]), Integer.parseInt(tmp[7]), Integer.parseInt(tmp[5])))));\n                        } catch (NumberFormatException nfe) {\n                            session.send(\"error: event/actor/target \" + \"isn't an int.\");\n                        }\n                    }\n                }\n                if (cmd.equals(\"textmessage\")) {\n                    if (tmp.length < 9) {\n                        session.send(\"usage: textmessage HEAD messagetype actor target text\");\n                    } else {\n                        try {\n                            sendMessage(new Message(tmp[4], new TextMessage(Integer.parseInt(tmp[6]), Integer.parseInt(tmp[7]), Integer.parseInt(tmp[5]), tmp[8])));\n                        } catch (NumberFormatException nfe) {\n                            session.send(\"error: action/actor/target \" + \"isn't an int.\");\n                        }\n                    }\n                }\n                if (cmd.equals(\"join\")) {\n                    if (tmp.length < 5) {\n                        session.send(\"usage: join CHANNEL\");\n                    } else {\n                        session.join(tmp[4]);\n                    }\n                }\n                if (cmd.equals(\"part\")) {\n                    if (tmp.length < 5) {\n                        session.send(\"usage: part CHANNEL\");\n                    } else {\n                        session.part(tmp[4]);\n                    }\n                }\n                if (cmd.equals(\"chan\")) {\n                    if (tmp.length < 5) {\n                        session.send(\"usage: chan CHANNEL\");\n                    } else {\n                        session.channel(tmp[4]);\n                    }\n                }\n                if (cmd.equals(\"quit\")) {\n                    session.close();\n                    exit();\n                }\n            }\n            /* Check for new Messages to deliver. */\n            m = pattern[1].matcher(str);\n            if (m.matches()) {\n                Message msg = new Message(m.group(1), m.group(2));\n                sendMessage(msg);\n            }\n        } catch (IOException e) {\n            e.printStackTrace(System.err);\n        }\n    }\n\n    /**\n     * Processes the specified message.\n     * @param m The message to process.\n     */\n    protected void processMessage(Message m) {\n        String[] data = ((String) m.body).split(\" \");\n        if (m.header.equals(\"IRCQ\")) {\n            session.quote(m.body.toString());\n        } else if (m.header.equals(\"IRC\")) {\n            session.send(m.body.toString());\n        }\n    }\n}\n\n/**\n * This class provides a simple wrapper around the IRC protocol. A class\n * that wishes to use IRC simply has to create a new instance of this\n * class and then use the send and recv methods.\n */\nclass IRCSession {\n\n    private static final String CRLF = \"\\r\\n\";\n\n    private static final String EMPTY = \"\";\n\n    Socket socket;\n\n    PrintWriter out;\n\n    BufferedReader in;\n\n    String chan = null;\n\n    String nick = null;\n\n    /**\n     * @param nick\n     * @param host\n     * @param port\n     */\n    public IRCSession(String nick, String host, int port) throws UnknownHostException, IOException {\n        socket = open(nick, host, port);\n    }\n\n    /**\n     * Send the specified message to the current channel or user.\n     * @param msg The message that is to be sent.\n     */\n    public void send(String msg) {\n        quote(\"PRIVMSG \" + chan + \" :\" + msg);\n    }\n\n    /**\n     * Send the specified message to the specified channel or user.\n     * @param msg The message that is to be sent.\n     * @param dst The channel or user to send message to.\n     */\n    public void send(String msg, String dst) {\n        quote(\"PRIVMSG \" + dst + \" :\" + msg);\n    }\n\n    /**\n     * @param msg The message that is to be sent.\n     */\n    public void quote(String msg) {\n        out.print(msg + CRLF);\n        out.flush();\n    }\n\n    /**\n     * @param block True if this method should block.\n     * @return The received message.\n     */\n    public String recv(boolean block) throws IOException {\n        if (block || in.ready()) {\n            return in.readLine();\n        } else {\n            return EMPTY;\n        }\n    }\n\n    /**\n     * Joins the specified channel.\n     *\n     * @param chan The channel to join.\n     */\n    public void join(String chan) {\n        this.chan = chan;\n        quote(\"JOIN \" + chan);\n    }\n\n    /**\n     * Parts with the specified channel.\n     *\n     * @param chan The channel to part with.\n     */\n    public void part(String chan) {\n        quote(\"PART \" + chan);\n    }\n\n    /**\n     * Sets the currently active channel.\n     *\n     * @param chan The channel to part with.\n     */\n    public void channel(String chan) {\n        this.chan = chan;\n    }\n\n    /**\n     * Sends the pong reply to the ping request from server.\n     * @param ping The ping request made by the server.\n     */\n    public void pong(String ping) {\n        quote(ping.replace('I', 'O'));\n    }\n\n    /**\n     * @param nick\n     * @param host\n     * @param port\n     */\n    public Socket open(String nick, String host, int port) throws UnknownHostException, IOException {\n        Socket sock = new Socket(host, port);\n        String str = null;\n        boolean done = false;\n        OutputStreamWriter osw;\n        InputStreamReader isr;\n        osw = new OutputStreamWriter(sock.getOutputStream());\n        isr = new InputStreamReader(sock.getInputStream());\n        this.out = new PrintWriter(new BufferedWriter(osw));\n        this.in = new BufferedReader(isr);\n        this.nick = nick;\n        quote(\"NICK \" + nick);\n        quote(\"USER jvm arachnid \" + host + \" :IRCProxyModule\\r\\n\");\n        // fixme - not all servers use this!\n        do {\n            str = in.readLine();\n            System.err.println(str);\n        } while (!str.contains(\"PING\") && !str.contains(\"Welcome\"));\n        if (str.contains(\"PING\")) {\n            pong(str);\n        }\n        return sock;\n    }\n\n    /**\n     * @throws IOException\n     */\n    public void close() /* throws IOException */\n    {\n        quote(\"QUIT\");\n        try {\n            out.flush();\n            socket.shutdownInput();\n            socket.shutdownOutput();\n            in.close();\n            out.close();\n            socket.close();\n        } catch (SocketException e) {\n        } catch (IOException e) {\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/module/IRCProxyModuleTest1.java",
		"test_prompt": "// IRCProxyModuleTest1.java\npackage module;\n\nimport java.util.*;\nimport java.util.regex.*;\nimport java.net.*;\nimport java.io.*;\nimport state.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link IRCProxyModule}.\n* It contains ten unit test cases for the {@link IRCProxyModule#ircConnect(String, String, int)} method.\n*/\nclass IRCProxyModuleTest1 {"
	},
	{
		"original_code": "// ServerNetworkModule.java\n/* $Id: ServerNetworkModule.java,v 1.7 2004/05/05 17:15:30 bja Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Emil Lundstr�m <emillkth.se>\n * @version: $Revision: 1.7 $\n *\n */\npackage module;\n\nimport java.io.IOException;\nimport java.util.LinkedList;\nimport java.util.ResourceBundle;\nimport java.util.Locale;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.net.ServerSocket;\nimport state.*;\nimport static util.Unpacker.unpack;\nimport static module.MessageFactory.*;\n\n@cvs(file = \"$RCSfile: ServerNetworkModule.java,v $\", revision = \"$Revision: 1.7 $\", date = \"$Date: 2004/05/05 17:15:30 $\", author = \"$Author: bja $\", tag = \"$Name:  $\", build = \"\")\n@mod(name = \"ServerNetworkModule\", topics = \"NETWORK SETALLOWCONNECT\", cmds = \"DUMP\", desc = \"\")\nclass /**\n * Provides the network part of the server. For n clients, this module\n * will consist of a total of n+2 threads.\n */\nServerNetworkModule extends AbstractModule implements NetworkModule {\n\n    /**\n     * Default port to listen for connections on.\n     */\n    static final int DEFAULT_PORT = 1119;\n\n    /**\n     * The thread listening for new tcp/ip connections.\n     */\n    ServerConnectionListener theListener;\n\n    /**\n     * List of active connections.\n     */\n    Connection[] connections;\n\n    /* Number of active connections. */\n    int numconns = 0;\n\n    /* Do we allow connections to this server? */\n    private boolean allowConnections = false;\n\n    /**\n     * Creates a new instance of this module. This constructor is usually\n     * called from the kernel when it wishes to load a module dynamically.\n     *\n     * @throws ModuleRegisterException If you have a broken Java interpreter.\n     */\n    public ServerNetworkModule() throws ModuleRegisterException {\n    }\n\n    /**\n     * Initialization method for modules. Using init() is recommended\n     * instead of overloading the constructor.\n     */\n    protected void init() {\n        int port = DEFAULT_PORT;\n        Message reply = null;\n        Message error = null;\n        connections = new Connection[GameState.MAX_PLAYER_LIMIT];\n        try {\n            reply = request(\"CONFIG\", \"GET ServerNetwork port\");\n            port = Integer.parseInt((String) reply.body);\n        } catch (MessageTimeoutException e) {\n            error = createWarningMessage(\"_SRV_GET_PORT_FAILED\");\n        } catch (NumberFormatException e) {\n            error = createWarningMessage(\"_SRV_INVALID_PORT\", DEFAULT_PORT);\n        } catch (NullPointerException e) {\n            error = createWarningMessage(\"_UNKNOWN_EXCEPTION\" + e);\n        } finally {\n            try {\n                error.send(this);\n            } catch (MessageDeliveryException e) {\n                System.err.println(\"ServerNetworkModule.init(): \" + error.getHeader() + \" \" + error.getBody());\n            } catch (NullPointerException e) {\n                // meaning there were no errors.\n            }\n        }\n        try {\n            theListener = new ServerConnectionListener(this, port);\n            theListener.start();\n        } catch (IOException e) {\n            Message m = null;\n            try {\n                m = createErrorMessage(\"_SRV_BIND_PORT_FAILED\", port);\n                m.send(this);\n                // unload module here!! correct way of doing it?\n                m = createUnloadMessage(modinfo.name);\n                m.send(this);\n            } catch (MessageDeliveryException x) {\n                System.err.println(\"ServerNetworkModule.init(): \" + m.getHeader() + \" \" + m.getBody());\n            }\n        }\n        allowConnections = true;\n    }\n\n    /**\n     * This method is invoked once for every Message in the input queue.\n     * Normally this is where module specific message handling is performed.\n     *\n     * @param msg The Message that is to be processed.\n     */\n    protected void processMessage(Message msg) {\n        /* Handle network messages. */\n        //System.err.println(\"ServerNetworkModule.processMessage()\");\n        if (msg.header.equals(\"NETWORK\")) {\n            //System.err.println(\"sending NetworkMessage\");\n            sendNetworkMessage((NetworkData) msg.body);\n        } else if (msg.header.equals(\"SETALLOWCONNECT\")) {\n            allowConnections = (Boolean) msg.body;\n        }\n    }\n\n    /**\n     * Makes sure to terminate all connections.\n     */\n    protected void free() {\n        // stop listener\n        try {\n            theListener.exit();\n            // stop connections\n            for (Connection c : connections) {\n                if (c != null) {\n                    c.exit();\n                }\n            }\n        } catch (NullPointerException e) {\n            e.printStackTrace(System.err);\n        } catch (Exception e) {\n            e.printStackTrace(System.err);\n        }\n    }\n\n    /**\n     * Adds a new connection and gives it an id. Also sends a\n     * CONNECTED Message.\n     */\n    protected synchronized void addConnection(Socket sock) {\n        if (numconns == GameState.MAX_PLAYER_LIMIT || !allowConnections) {\n            // server full. simply close connection for now.\n            try {\n                sock.close();\n            } catch (IOException e) {\n                // doesn't matter\n            }\n        } else {\n            numconns++;\n            int t = -1;\n            // grab the first free id\n            while (connections[++t] != null) ;\n            connections[t] = new Connection(this, sock, t);\n            connections[t].start();\n            sendMessage(new Message(\"CONNECTED\", \"ID: \" + t + \" \" + \"IP: \" + sock.getInetAddress().getHostAddress()));\n        }\n    }\n\n    /**\n     * Removes a connection. Also sends a DROPPED Message.\n     */\n    public synchronized void deleteConnection(Connection c) {\n        Message m = null;\n        for (int i = 0; i < GameState.MAX_PLAYER_LIMIT; i++) {\n            if (c == connections[i]) {\n                numconns--;\n                connections[i] = null;\n                c.exit();\n                try {\n                    String host = c.getSocket().getInetAddress().getHostAddress();\n                    m = createConnectionDroppedMessage(i, host);\n                    m.send(this);\n                } catch (MessageDeliveryException e) {\n                    if (m != null) {\n                        System.err.println(\"ServerNetworkModule.deleteConnection(): \" + m);\n                    }\n                }\n                break;\n            }\n        }\n    }\n\n    public void receiveNetworkMessage(int type, byte[] data, int id) throws NetworkException {\n        try {\n            sendMessage(new Message(\"FROM_NETWORK\", unpack(type, data, id)));\n        } catch (PackingException e) {\n            throw new NetworkException(e);\n        }\n    }\n\n    public boolean allowConnections() {\n        return allowConnections;\n    }\n\n    protected void sendNetworkMessage(NetworkData d) {\n        Packable p = d.getData();\n        byte[] data = p.pack();\n        /* Send only to provided recipients. */\n        if (d.getRecipients() != null) {\n            for (int id : d.getRecipients()) {\n                if (connections[id] != null) {\n                    connections[id].send(p.type(), data);\n                }\n            }\n        } else /* Send to everyone. */\n        {\n            for (Connection c : connections) {\n                if (c != null) {\n                    c.send(p.type(), data);\n                }\n            }\n        }\n    }\n}\n\n/**\n * ServerConnnectionListener is a thread that is constantly waiting\n * for new clients to connect.\n */\nclass ServerConnectionListener extends Thread {\n\n    /**\n     * The ServerNetworkModule to which this listener belongs.\n     */\n    private ServerNetworkModule parent;\n\n    /**\n     * The ServerSocket that listens for connections.\n     */\n    private ServerSocket listenSocket;\n\n    /**\n     * When done is true, this thread should be terminated.\n     */\n    private boolean done = false;\n\n    /**\n     * Creates a new instance of the ServerConnectionListener.\n     *\n     * @throws IOException at failure of binding requested port.\n     */\n    public ServerConnectionListener(ServerNetworkModule par, int port) throws IOException {\n        parent = par;\n        listenSocket = new ServerSocket(port);\n    }\n\n    /**\n     * Loop function for this thread. Constantly listens for new\n     * connection, adds them as a new ServerConnection and sends them\n     * back to the parent ServerNetworkModule\n     */\n    public void run() {\n        while (!done) {\n            try {\n                Socket newsock = listenSocket.accept();\n                parent.addConnection(newsock);\n            } catch (SocketException e) {\n                /* A SocketException is thrown when exit() is called\n                   and the listenSocket needs to be closed. Do\n                   nothing. */\n                System.err.println(\"ServerConnectionListener.run(): \" + \"SocketException: \" + e.getMessage());\n            } catch (IOException e) {\n                parent.sendMessage(new Message(\"WARNING\", parent.locale.getString(\"_SRVCON_CONNECTION_FAILED\")));\n            }\n        }\n    }\n\n    /**\n     * Terminates this thread.\n     */\n    public void exit() {\n        done = true;\n        try {\n            listenSocket.close();\n        } catch (IOException e) {\n            parent.sendMessage(new Message(\"WARNING\", parent.locale.getString(\"_SRVCON_CLOSE_FAILED\")));\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/module/ServerNetworkModuleTest.java",
		"test_prompt": "// ServerNetworkModuleTest.java\npackage module;\n\nimport java.io.IOException;\nimport java.util.LinkedList;\nimport java.util.ResourceBundle;\nimport java.util.Locale;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.net.ServerSocket;\nimport state.*;\nimport static util.Unpacker.unpack;\nimport static module.MessageFactory.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ServerNetworkModule}.\n* It contains ten unit test cases for the {@link ServerNetworkModule#allowConnections()} method.\n*/\nclass ServerNetworkModuleTest {"
	},
	{
		"original_code": "// Kernel.java\n/* $Id: Kernel.java,v 1.7 2004/05/01 23:20:45 bja Exp $ \n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Emil Lundstr�m <emill@kth.se>\n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.7 $\n *\n */\npackage module;\n\nimport java.util.Collection;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Collections;\n\n@cvs(file = \"$RCSfile: Kernel.java,v $\", revision = \"$Revision: 1.7 $\", date = \"$Date: 2004/05/01 23:20:45 $\", author = \"$Author: bja $\", tag = \"$Name:  $\", build = \"\")\n@mod(name = \"Kernel\", topics = \"KERNEL\", cmds = \"DUMP LOAD UNLOAD LIST EXISTS\", desc = \"This class provides a message delivery system. It's primary task is \" + \"to manage loaded modules. It has methods for loading and unloading \" + \"modules, subscribing and unsubscribing modules to specified topics, \" + \"and for creating and destroying sessions.\")\npublic class /**\n * This class provides a message delivery system. It's primary task is to\n * manage loaded modules. It has methods for loading and unloading modules,\n * subscribing and unsubscribing modules to specified topics, and for creating\n * and destroying sessions.\n */\nKernel implements Module {\n\n    /**\n     * Topic to subcribers lookup table.\n     */\n    private Hashtable<String, Vector<Module>> subscribers;\n\n    /**\n     * Module name lookup table.\n     */\n    private Hashtable<String, Module> modules;\n\n    /**\n     * Message queue.\n     */\n    private List<Message> messages;\n\n    /**\n     * The thread associated with this module.\n     */\n    private Thread thread;\n\n    /**\n     * Contains module specific information.\n     */\n    private ModuleInfo modinfo = new ModuleInfo(this);\n\n    /**\n     * Specifies whether the Kernel should stop running.\n     */\n    private boolean done = false;\n\n    /**\n     * Create a new instance of the Kernel module. There has to be at least\n     * one kernel up and running in order to have messages processed.\n     */\n    public Kernel() {\n        /* Create the lookup table of module subscriptions */\n        subscribers = new Hashtable<String, Vector<Module>>();\n        /* Create the table of registered modules */\n        modules = new Hashtable<String, Module>();\n        /* Initialize message queue */\n        messages = Collections.synchronizedList(new LinkedList<Message>());\n        /* fixme - for now! */\n        start();\n    }\n\n    /**\n     * Start executing the run method in a separate thread. This method\n     * is invoked automatically be the Kernel when the module is loaded\n     * and should not be invoked manually.\n     */\n    public void start() {\n        thread = new Thread(this, modinfo.name);\n        thread.start();\n    }\n\n    /**\n     * This is the kernels main thread routine. Its sole purpose is to\n     * regularly process the messagequeue.\n     */\n    public void run() {\n        while (!done) {\n            try {\n                processMessages();\n                thread.sleep(10);\n            } catch (Exception e) {\n                System.err.println(e);\n            }\n        }\n    }\n\n    /**\n     * Load and register the specified module. This method provides\n     * a mechanism for dynamically loading modules to the runtime.\n     *\n     * @param name The name of the module that is to be loaded.\n     * @throws ModuleLoadException If an exception occurred.\n     */\n    public void loadModule(String name) throws ModuleLoadException {\n        try {\n            Class c = getClass().forName(name);\n            Module m = (Module) c.newInstance();\n            m.register(this);\n            m.start();\n        } catch (Exception e) {\n            throw new ModuleLoadException(e);\n        }\n    }\n\n    /**\n     * Unload and unregister the specified module. Modules that are not\n     * needed any more may be unloaded from the kernel to save resources.\n     *\n     * @param mod The module that is to be unloaded.\n     *\n     * @throws ModuleRegisterException If an register exception occurred.\n     * @throws ModuleUnloadException If an exception occurred.\n     */\n    public void unloadModule(Module mod) throws ModuleRegisterException {\n        unregister(mod);\n    }\n\n    /**\n     * Unload and unregister the specified module. Modules that are not\n     * needed any more may be unloaded from the kernel to save resources.\n     *\n     * @param name The name of the module that is to be unloaded.\n     *\n     * @throws ModuleUnloadException If an exception occurred.\n     */\n    public void unloadModule(String name) throws ModuleUnloadException {\n        try {\n            Module m = modules.get(name);\n            unloadModule(m);\n            m.getThread().join(100);\n            m = null;\n        } catch (Exception e) {\n            throw new ModuleUnloadException(\"mod=\" + name, e);\n        }\n    }\n\n    /**\n     * Register the specified module with this kernel. A module is required\n     * to register with the kernel in order to subscribe to messages and\n     * in turn communicate with other modules.\n     *\n     * @param mod The module that is to be registered.\n     * @throws ModuleRegisterException if the module has already registered.\n     */\n    public void register(Module m) throws ModuleRegisterException {\n        Message msg = null;\n        System.err.println(\"KERNEL REGISTERED: \" + m);\n        try {\n            if (modules.containsKey(m.info().name)) {\n                throw new ModuleRegisterException(m, \"A module with that name has already been registered: \" + \"name=\" + m.info().name);\n            }\n            // Add the module to the collection of registered modules.\n            modules.put(m.info().name, m);\n            // Let the module know it has been registered.\n            //sendMessage(m, new Message(\"KERNEL\",\"REGISTERED\"));\n            msg = MessageFactory.createMessage(\"KERNEL\", m.getClass().getName(), \"REGISTERED\");\n            // MessageFactory.getInstance().sendRegisterMessage(this, m);\n            sendMessage(m, msg);\n        } catch (ModuleRegisterException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new ModuleRegisterException(m, e);\n        } finally {\n            if (msg != null)\n                msg.unref();\n        }\n    }\n\n    /**\n     * Unregister the specified module. An unused module should unregister\n     * with the kernel so that all references to that module will be freed.\n     *\n     * @param mod The module that is to be unregistered.\n     * @throws ModuleRegisterException if the module is not registered.\n     */\n    public void unregister(Module m) throws ModuleRegisterException {\n        try {\n            if (!modules.containsKey(m.info().name)) {\n                throw new ModuleRegisterException(m, \"Not registered!\");\n            }\n            // maybe this should be synchronized\n            unsubscribe(m);\n            modules.remove(m.info().name);\n            //MessageFactory.getInstance().sendUnregisterMessage(this, m);\n            sendMessage(m, new Message(\"KERNEL\", \"UNREGISTERED\"));\n        } catch (ModuleRegisterException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new ModuleRegisterException(m, e);\n        }\n    }\n\n    /**\n     * Adds module as a subscriber of all messages with the\n     * specified topic.\n     *\n     * @param mod The module that is to subscribe to topic.\n     * @param topic The topic that should be subscribed to.\n     */\n    public void subscribe(Module mod, String topics) throws ModuleSubscriptionException {\n        try {\n            String[] top = topics.split(\"(,|\\\\s+)\");\n            for (int i = 0; i < top.length; i++) {\n                if (subscribers.containsKey(top[i])) {\n                    subscribers.get(top[i]).add(mod);\n                } else {\n                    Vector<Module> nv = new Vector<Module>();\n                    nv.add(mod);\n                    subscribers.put(top[i], nv);\n                }\n            }\n        } catch (Exception e) {\n            throw new ModuleSubscriptionException(mod, \"topics=\" + topics, e);\n        }\n    }\n\n    /**\n     * Unsubscribes the specified module from every topic it is\n     * subscribing to. Modules will still receive messages from\n     * the kernel though.\n     *\n     * @param mod The module that is to be unsubscribed.\n     */\n    public void unsubscribe(Module mod) {\n        // fixme - this is really ugly, O(t+ts) may easily be O(t)!\n        for (Vector v : subscribers.values()) {\n            v.remove(mod);\n        }\n    }\n\n    /**\n     * Unsubscribes the specified module from the given topic. Modules may\n     * call this method to instruct the kernel that they do not whish to\n     * receive messages in the specified topic.\n     *\n     * @param mod The module that is to be unsubscribed from topic.\n     * @param topic The topic from which we wish to unsubscribe.\n     *\n     * @throws ModuleSubscriptionException If either the topic or module are\n     * null.\n     */\n    public void unsubscribe(Module mod, String topic) throws ModuleSubscriptionException {\n        try {\n            if (subscribers.containsKey(topic)) {\n                Vector t = subscribers.get(topic);\n                t.remove(mod);\n                if (t.size() == 0) {\n                    subscribers.remove(topic);\n                }\n            }\n        } catch (Exception e) {\n            throw new ModuleSubscriptionException(e);\n        }\n    }\n\n    /**\n     * Requests the specified query from the specified topic. Observe that\n     * if there are more than one module answering a specific request, only\n     * the first one will be returned.\n     *\n     * @deprecated Requests are currently not used by the Kernel.\n     *\n     * @param mod The module that should receive the request.\n     * @param key A string containing the actual request.\n     */\n    public Object request(String mod, String key) throws MessageTimeoutException {\n        throw new MessageTimeoutException(\"Requests are not implemented\");\n    }\n\n    /**\n     * Requests the specified query from the specified topic. Observe that\n     * if there are more than one module answering a specific request, only\n     * the first one will be returned.\n     *\n     * @deprecated Requests are currently not used by the Kernel.\n     *\n     * @param msg The message containing the request.\n     *\n     * @throws MessageTimeoutException\n     * If the request times out before we receive any replies.\n     */\n    public Message request(Message msg) throws MessageTimeoutException {\n        throw new MessageTimeoutException(\"Sorry, requests are not implemented in Kernel\");\n    }\n\n    /**\n     */\n    public ModuleInfo info() {\n        return modinfo;\n    }\n\n    /**\n     * Delivers the specified message to the kernel.\n     * @param msg The message to be delivered.\n     * @throws MessageDeliveryException if message could not be delivered.\n     */\n    public void sendMessage(Message msg) throws MessageDeliveryException {\n        try {\n            sendMessage(modules.get(msg.recipient), msg);\n        } catch (Exception e) {\n            throw new MessageDeliveryException(e);\n        }\n    }\n\n    /**\n     * Delivers the specified message to the given module.\n     *\n     * @param mod the module that should receive the message.\n     * @param msg the message that should be sent.\n     * @throws MessageDeliveryException if message could not be delivered.\n     */\n    private void sendMessage(Module mod, Message msg) throws MessageDeliveryException {\n        try {\n            mod.receiveMessage(msg);\n        } catch (Exception e) {\n            throw new MessageDeliveryException(mod, msg, e);\n        }\n    }\n\n    /**\n     * Receives a message from another module. This function is public\n     * and should be called from the other module.\n     *\n     * @param msg The message to receive.\n     */\n    public void receiveMessage(Message msg) throws MessageDeliveryException {\n        try {\n            msg.ref();\n            messages.add(msg);\n            //msg.setState(Message.SENT);\n        } catch (Exception e) {\n            msg.unref();\n            throw new MessageDeliveryException(this, msg, e);\n        }\n    }\n\n    /**\n     * Handles what should done with messages sent to this module.\n     *\n     * @param msg The message to be processed.\n     * @throws Exception if the processing failed for this message.\n     */\n    protected void processMessage(Message msg) throws Exception {\n        String[] cmd = null;\n        cmd = ((String) msg.body).split(\" \");\n        if (cmd.length == 0) {\n            return;\n        }\n        if (cmd[0].equals(\"LOAD\")) {\n            loadModule(cmd[1]);\n            return;\n        }\n        if (cmd[0].equals(\"UNLOAD\")) {\n            unloadModule(cmd[1]);\n            return;\n        }\n        if (cmd[0].equals(\"DUMP\")) {\n            sendMessage(modules.get(msg.sender), msg.reply(modules.toString()));\n            sendMessage(modules.get(msg.sender), msg.reply(subscribers.toString()));\n            return;\n        }\n    }\n\n    /**\n     * Process messages from the message queue.\n     *\n     * @throws MessageProcessingException if processing failed for any\n     * message in the message queue.\n     */\n    private void processMessages() throws MessageProcessingException {\n        Message msg = null;\n        Module dst = null;\n        try {\n            while (!messages.isEmpty()) {\n                msg = messages.remove(0);\n                /* intercept messages destined for the kernel */\n                if (msg.header.equals(\"KERNEL\")) {\n                    processMessage(msg);\n                }\n                /* try sending message directly to recipient, if not null,\n\t\t   otherwise send to everyone that is subscribing to the\n\t\t   specified topic. */\n                dst = modules.get(msg.getRecipient());\n                if (dst != null) {\n                    sendMessage(dst, msg);\n                } else if (subscribers.containsKey(msg.getHeader())) {\n                    sendMessageNotify(subscribers.get(msg.getHeader()), msg);\n                }\n                /* Notify modules subscribing on all Message classes. */\n                if (subscribers.containsKey(\"*\")) {\n                    sendMessageNotify(subscribers.get(\"*\"), msg);\n                }\n                msg.setDelivered(true);\n                msg.unref();\n            }\n        } catch (Exception e) {\n            if (msg != null) {\n                msg.unref();\n            }\n            throw new MessageProcessingException(msg, e);\n        }\n    }\n\n    /**\n     * Sends the specified message to the given collection of modules.\n     * The modules are notified of the delivery (i.e. the thread is notified.)\n     *\n     * @param mods the modules that should receive the message.\n     * @param msg the message that should be delivered.\n     * @throws MessageDeliveryException if the message could not be delivered.\n     */\n    public void sendMessageNotify(Collection<Module> mods, Message msg) throws MessageDeliveryException {\n        for (Module mod : mods) {\n            sendMessage(mod, msg);\n            synchronized (mod) {\n                mod.notify();\n            }\n        }\n    }\n\n    /**\n     * Returns the Kernel associated with this Module.\n     * @return the Kernel associated with this Module.\n     */\n    public Kernel getKernel() {\n        return null;\n    }\n\n    /**\n     * Returns the thread associated with this module.\n     * @return The thread associated with this module.\n     */\n    public Thread getThread() {\n        return thread;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/module/KernelTest0.java",
		"test_prompt": "// KernelTest0.java\npackage module;\n\nimport java.util.Collection;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Collections;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Kernel}.\n* It contains ten unit test cases for the {@link Kernel#request(String, String)} method.\n*/\nclass KernelTest0 {"
	},
	{
		"original_code": "// Kernel.java\n/* $Id: Kernel.java,v 1.7 2004/05/01 23:20:45 bja Exp $ \n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Emil Lundstr�m <emill@kth.se>\n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.7 $\n *\n */\npackage module;\n\nimport java.util.Collection;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Collections;\n\n@cvs(file = \"$RCSfile: Kernel.java,v $\", revision = \"$Revision: 1.7 $\", date = \"$Date: 2004/05/01 23:20:45 $\", author = \"$Author: bja $\", tag = \"$Name:  $\", build = \"\")\n@mod(name = \"Kernel\", topics = \"KERNEL\", cmds = \"DUMP LOAD UNLOAD LIST EXISTS\", desc = \"This class provides a message delivery system. It's primary task is \" + \"to manage loaded modules. It has methods for loading and unloading \" + \"modules, subscribing and unsubscribing modules to specified topics, \" + \"and for creating and destroying sessions.\")\npublic class /**\n * This class provides a message delivery system. It's primary task is to\n * manage loaded modules. It has methods for loading and unloading modules,\n * subscribing and unsubscribing modules to specified topics, and for creating\n * and destroying sessions.\n */\nKernel implements Module {\n\n    /**\n     * Topic to subcribers lookup table.\n     */\n    private Hashtable<String, Vector<Module>> subscribers;\n\n    /**\n     * Module name lookup table.\n     */\n    private Hashtable<String, Module> modules;\n\n    /**\n     * Message queue.\n     */\n    private List<Message> messages;\n\n    /**\n     * The thread associated with this module.\n     */\n    private Thread thread;\n\n    /**\n     * Contains module specific information.\n     */\n    private ModuleInfo modinfo = new ModuleInfo(this);\n\n    /**\n     * Specifies whether the Kernel should stop running.\n     */\n    private boolean done = false;\n\n    /**\n     * Create a new instance of the Kernel module. There has to be at least\n     * one kernel up and running in order to have messages processed.\n     */\n    public Kernel() {\n        /* Create the lookup table of module subscriptions */\n        subscribers = new Hashtable<String, Vector<Module>>();\n        /* Create the table of registered modules */\n        modules = new Hashtable<String, Module>();\n        /* Initialize message queue */\n        messages = Collections.synchronizedList(new LinkedList<Message>());\n        /* fixme - for now! */\n        start();\n    }\n\n    /**\n     * Start executing the run method in a separate thread. This method\n     * is invoked automatically be the Kernel when the module is loaded\n     * and should not be invoked manually.\n     */\n    public void start() {\n        thread = new Thread(this, modinfo.name);\n        thread.start();\n    }\n\n    /**\n     * This is the kernels main thread routine. Its sole purpose is to\n     * regularly process the messagequeue.\n     */\n    public void run() {\n        while (!done) {\n            try {\n                processMessages();\n                thread.sleep(10);\n            } catch (Exception e) {\n                System.err.println(e);\n            }\n        }\n    }\n\n    /**\n     * Load and register the specified module. This method provides\n     * a mechanism for dynamically loading modules to the runtime.\n     *\n     * @param name The name of the module that is to be loaded.\n     * @throws ModuleLoadException If an exception occurred.\n     */\n    public void loadModule(String name) throws ModuleLoadException {\n        try {\n            Class c = getClass().forName(name);\n            Module m = (Module) c.newInstance();\n            m.register(this);\n            m.start();\n        } catch (Exception e) {\n            throw new ModuleLoadException(e);\n        }\n    }\n\n    /**\n     * Unload and unregister the specified module. Modules that are not\n     * needed any more may be unloaded from the kernel to save resources.\n     *\n     * @param mod The module that is to be unloaded.\n     *\n     * @throws ModuleRegisterException If an register exception occurred.\n     * @throws ModuleUnloadException If an exception occurred.\n     */\n    public void unloadModule(Module mod) throws ModuleRegisterException {\n        unregister(mod);\n    }\n\n    /**\n     * Unload and unregister the specified module. Modules that are not\n     * needed any more may be unloaded from the kernel to save resources.\n     *\n     * @param name The name of the module that is to be unloaded.\n     *\n     * @throws ModuleUnloadException If an exception occurred.\n     */\n    public void unloadModule(String name) throws ModuleUnloadException {\n        try {\n            Module m = modules.get(name);\n            unloadModule(m);\n            m.getThread().join(100);\n            m = null;\n        } catch (Exception e) {\n            throw new ModuleUnloadException(\"mod=\" + name, e);\n        }\n    }\n\n    /**\n     * Register the specified module with this kernel. A module is required\n     * to register with the kernel in order to subscribe to messages and\n     * in turn communicate with other modules.\n     *\n     * @param mod The module that is to be registered.\n     * @throws ModuleRegisterException if the module has already registered.\n     */\n    public void register(Module m) throws ModuleRegisterException {\n        Message msg = null;\n        System.err.println(\"KERNEL REGISTERED: \" + m);\n        try {\n            if (modules.containsKey(m.info().name)) {\n                throw new ModuleRegisterException(m, \"A module with that name has already been registered: \" + \"name=\" + m.info().name);\n            }\n            // Add the module to the collection of registered modules.\n            modules.put(m.info().name, m);\n            // Let the module know it has been registered.\n            //sendMessage(m, new Message(\"KERNEL\",\"REGISTERED\"));\n            msg = MessageFactory.createMessage(\"KERNEL\", m.getClass().getName(), \"REGISTERED\");\n            // MessageFactory.getInstance().sendRegisterMessage(this, m);\n            sendMessage(m, msg);\n        } catch (ModuleRegisterException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new ModuleRegisterException(m, e);\n        } finally {\n            if (msg != null)\n                msg.unref();\n        }\n    }\n\n    /**\n     * Unregister the specified module. An unused module should unregister\n     * with the kernel so that all references to that module will be freed.\n     *\n     * @param mod The module that is to be unregistered.\n     * @throws ModuleRegisterException if the module is not registered.\n     */\n    public void unregister(Module m) throws ModuleRegisterException {\n        try {\n            if (!modules.containsKey(m.info().name)) {\n                throw new ModuleRegisterException(m, \"Not registered!\");\n            }\n            // maybe this should be synchronized\n            unsubscribe(m);\n            modules.remove(m.info().name);\n            //MessageFactory.getInstance().sendUnregisterMessage(this, m);\n            sendMessage(m, new Message(\"KERNEL\", \"UNREGISTERED\"));\n        } catch (ModuleRegisterException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new ModuleRegisterException(m, e);\n        }\n    }\n\n    /**\n     * Adds module as a subscriber of all messages with the\n     * specified topic.\n     *\n     * @param mod The module that is to subscribe to topic.\n     * @param topic The topic that should be subscribed to.\n     */\n    public void subscribe(Module mod, String topics) throws ModuleSubscriptionException {\n        try {\n            String[] top = topics.split(\"(,|\\\\s+)\");\n            for (int i = 0; i < top.length; i++) {\n                if (subscribers.containsKey(top[i])) {\n                    subscribers.get(top[i]).add(mod);\n                } else {\n                    Vector<Module> nv = new Vector<Module>();\n                    nv.add(mod);\n                    subscribers.put(top[i], nv);\n                }\n            }\n        } catch (Exception e) {\n            throw new ModuleSubscriptionException(mod, \"topics=\" + topics, e);\n        }\n    }\n\n    /**\n     * Unsubscribes the specified module from every topic it is\n     * subscribing to. Modules will still receive messages from\n     * the kernel though.\n     *\n     * @param mod The module that is to be unsubscribed.\n     */\n    public void unsubscribe(Module mod) {\n        // fixme - this is really ugly, O(t+ts) may easily be O(t)!\n        for (Vector v : subscribers.values()) {\n            v.remove(mod);\n        }\n    }\n\n    /**\n     * Unsubscribes the specified module from the given topic. Modules may\n     * call this method to instruct the kernel that they do not whish to\n     * receive messages in the specified topic.\n     *\n     * @param mod The module that is to be unsubscribed from topic.\n     * @param topic The topic from which we wish to unsubscribe.\n     *\n     * @throws ModuleSubscriptionException If either the topic or module are\n     * null.\n     */\n    public void unsubscribe(Module mod, String topic) throws ModuleSubscriptionException {\n        try {\n            if (subscribers.containsKey(topic)) {\n                Vector t = subscribers.get(topic);\n                t.remove(mod);\n                if (t.size() == 0) {\n                    subscribers.remove(topic);\n                }\n            }\n        } catch (Exception e) {\n            throw new ModuleSubscriptionException(e);\n        }\n    }\n\n    /**\n     * Requests the specified query from the specified topic. Observe that\n     * if there are more than one module answering a specific request, only\n     * the first one will be returned.\n     *\n     * @deprecated Requests are currently not used by the Kernel.\n     *\n     * @param mod The module that should receive the request.\n     * @param key A string containing the actual request.\n     */\n    public Object request(String mod, String key) throws MessageTimeoutException {\n        throw new MessageTimeoutException(\"Requests are not implemented\");\n    }\n\n    /**\n     * Requests the specified query from the specified topic. Observe that\n     * if there are more than one module answering a specific request, only\n     * the first one will be returned.\n     *\n     * @deprecated Requests are currently not used by the Kernel.\n     *\n     * @param msg The message containing the request.\n     *\n     * @throws MessageTimeoutException\n     * If the request times out before we receive any replies.\n     */\n    public Message request(Message msg) throws MessageTimeoutException {\n        throw new MessageTimeoutException(\"Sorry, requests are not implemented in Kernel\");\n    }\n\n    /**\n     */\n    public ModuleInfo info() {\n        return modinfo;\n    }\n\n    /**\n     * Delivers the specified message to the kernel.\n     * @param msg The message to be delivered.\n     * @throws MessageDeliveryException if message could not be delivered.\n     */\n    public void sendMessage(Message msg) throws MessageDeliveryException {\n        try {\n            sendMessage(modules.get(msg.recipient), msg);\n        } catch (Exception e) {\n            throw new MessageDeliveryException(e);\n        }\n    }\n\n    /**\n     * Delivers the specified message to the given module.\n     *\n     * @param mod the module that should receive the message.\n     * @param msg the message that should be sent.\n     * @throws MessageDeliveryException if message could not be delivered.\n     */\n    private void sendMessage(Module mod, Message msg) throws MessageDeliveryException {\n        try {\n            mod.receiveMessage(msg);\n        } catch (Exception e) {\n            throw new MessageDeliveryException(mod, msg, e);\n        }\n    }\n\n    /**\n     * Receives a message from another module. This function is public\n     * and should be called from the other module.\n     *\n     * @param msg The message to receive.\n     */\n    public void receiveMessage(Message msg) throws MessageDeliveryException {\n        try {\n            msg.ref();\n            messages.add(msg);\n            //msg.setState(Message.SENT);\n        } catch (Exception e) {\n            msg.unref();\n            throw new MessageDeliveryException(this, msg, e);\n        }\n    }\n\n    /**\n     * Handles what should done with messages sent to this module.\n     *\n     * @param msg The message to be processed.\n     * @throws Exception if the processing failed for this message.\n     */\n    protected void processMessage(Message msg) throws Exception {\n        String[] cmd = null;\n        cmd = ((String) msg.body).split(\" \");\n        if (cmd.length == 0) {\n            return;\n        }\n        if (cmd[0].equals(\"LOAD\")) {\n            loadModule(cmd[1]);\n            return;\n        }\n        if (cmd[0].equals(\"UNLOAD\")) {\n            unloadModule(cmd[1]);\n            return;\n        }\n        if (cmd[0].equals(\"DUMP\")) {\n            sendMessage(modules.get(msg.sender), msg.reply(modules.toString()));\n            sendMessage(modules.get(msg.sender), msg.reply(subscribers.toString()));\n            return;\n        }\n    }\n\n    /**\n     * Process messages from the message queue.\n     *\n     * @throws MessageProcessingException if processing failed for any\n     * message in the message queue.\n     */\n    private void processMessages() throws MessageProcessingException {\n        Message msg = null;\n        Module dst = null;\n        try {\n            while (!messages.isEmpty()) {\n                msg = messages.remove(0);\n                /* intercept messages destined for the kernel */\n                if (msg.header.equals(\"KERNEL\")) {\n                    processMessage(msg);\n                }\n                /* try sending message directly to recipient, if not null,\n\t\t   otherwise send to everyone that is subscribing to the\n\t\t   specified topic. */\n                dst = modules.get(msg.getRecipient());\n                if (dst != null) {\n                    sendMessage(dst, msg);\n                } else if (subscribers.containsKey(msg.getHeader())) {\n                    sendMessageNotify(subscribers.get(msg.getHeader()), msg);\n                }\n                /* Notify modules subscribing on all Message classes. */\n                if (subscribers.containsKey(\"*\")) {\n                    sendMessageNotify(subscribers.get(\"*\"), msg);\n                }\n                msg.setDelivered(true);\n                msg.unref();\n            }\n        } catch (Exception e) {\n            if (msg != null) {\n                msg.unref();\n            }\n            throw new MessageProcessingException(msg, e);\n        }\n    }\n\n    /**\n     * Sends the specified message to the given collection of modules.\n     * The modules are notified of the delivery (i.e. the thread is notified.)\n     *\n     * @param mods the modules that should receive the message.\n     * @param msg the message that should be delivered.\n     * @throws MessageDeliveryException if the message could not be delivered.\n     */\n    public void sendMessageNotify(Collection<Module> mods, Message msg) throws MessageDeliveryException {\n        for (Module mod : mods) {\n            sendMessage(mod, msg);\n            synchronized (mod) {\n                mod.notify();\n            }\n        }\n    }\n\n    /**\n     * Returns the Kernel associated with this Module.\n     * @return the Kernel associated with this Module.\n     */\n    public Kernel getKernel() {\n        return null;\n    }\n\n    /**\n     * Returns the thread associated with this module.\n     * @return The thread associated with this module.\n     */\n    public Thread getThread() {\n        return thread;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/module/KernelTest1.java",
		"test_prompt": "// KernelTest1.java\npackage module;\n\nimport java.util.Collection;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Collections;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Kernel}.\n* It contains ten unit test cases for the {@link Kernel#request(Message)} method.\n*/\nclass KernelTest1 {"
	},
	{
		"original_code": "// Kernel.java\n/* $Id: Kernel.java,v 1.7 2004/05/01 23:20:45 bja Exp $ \n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Emil Lundstr�m <emill@kth.se>\n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.7 $\n *\n */\npackage module;\n\nimport java.util.Collection;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Collections;\n\n@cvs(file = \"$RCSfile: Kernel.java,v $\", revision = \"$Revision: 1.7 $\", date = \"$Date: 2004/05/01 23:20:45 $\", author = \"$Author: bja $\", tag = \"$Name:  $\", build = \"\")\n@mod(name = \"Kernel\", topics = \"KERNEL\", cmds = \"DUMP LOAD UNLOAD LIST EXISTS\", desc = \"This class provides a message delivery system. It's primary task is \" + \"to manage loaded modules. It has methods for loading and unloading \" + \"modules, subscribing and unsubscribing modules to specified topics, \" + \"and for creating and destroying sessions.\")\npublic class /**\n * This class provides a message delivery system. It's primary task is to\n * manage loaded modules. It has methods for loading and unloading modules,\n * subscribing and unsubscribing modules to specified topics, and for creating\n * and destroying sessions.\n */\nKernel implements Module {\n\n    /**\n     * Topic to subcribers lookup table.\n     */\n    private Hashtable<String, Vector<Module>> subscribers;\n\n    /**\n     * Module name lookup table.\n     */\n    private Hashtable<String, Module> modules;\n\n    /**\n     * Message queue.\n     */\n    private List<Message> messages;\n\n    /**\n     * The thread associated with this module.\n     */\n    private Thread thread;\n\n    /**\n     * Contains module specific information.\n     */\n    private ModuleInfo modinfo = new ModuleInfo(this);\n\n    /**\n     * Specifies whether the Kernel should stop running.\n     */\n    private boolean done = false;\n\n    /**\n     * Create a new instance of the Kernel module. There has to be at least\n     * one kernel up and running in order to have messages processed.\n     */\n    public Kernel() {\n        /* Create the lookup table of module subscriptions */\n        subscribers = new Hashtable<String, Vector<Module>>();\n        /* Create the table of registered modules */\n        modules = new Hashtable<String, Module>();\n        /* Initialize message queue */\n        messages = Collections.synchronizedList(new LinkedList<Message>());\n        /* fixme - for now! */\n        start();\n    }\n\n    /**\n     * Start executing the run method in a separate thread. This method\n     * is invoked automatically be the Kernel when the module is loaded\n     * and should not be invoked manually.\n     */\n    public void start() {\n        thread = new Thread(this, modinfo.name);\n        thread.start();\n    }\n\n    /**\n     * This is the kernels main thread routine. Its sole purpose is to\n     * regularly process the messagequeue.\n     */\n    public void run() {\n        while (!done) {\n            try {\n                processMessages();\n                thread.sleep(10);\n            } catch (Exception e) {\n                System.err.println(e);\n            }\n        }\n    }\n\n    /**\n     * Load and register the specified module. This method provides\n     * a mechanism for dynamically loading modules to the runtime.\n     *\n     * @param name The name of the module that is to be loaded.\n     * @throws ModuleLoadException If an exception occurred.\n     */\n    public void loadModule(String name) throws ModuleLoadException {\n        try {\n            Class c = getClass().forName(name);\n            Module m = (Module) c.newInstance();\n            m.register(this);\n            m.start();\n        } catch (Exception e) {\n            throw new ModuleLoadException(e);\n        }\n    }\n\n    /**\n     * Unload and unregister the specified module. Modules that are not\n     * needed any more may be unloaded from the kernel to save resources.\n     *\n     * @param mod The module that is to be unloaded.\n     *\n     * @throws ModuleRegisterException If an register exception occurred.\n     * @throws ModuleUnloadException If an exception occurred.\n     */\n    public void unloadModule(Module mod) throws ModuleRegisterException {\n        unregister(mod);\n    }\n\n    /**\n     * Unload and unregister the specified module. Modules that are not\n     * needed any more may be unloaded from the kernel to save resources.\n     *\n     * @param name The name of the module that is to be unloaded.\n     *\n     * @throws ModuleUnloadException If an exception occurred.\n     */\n    public void unloadModule(String name) throws ModuleUnloadException {\n        try {\n            Module m = modules.get(name);\n            unloadModule(m);\n            m.getThread().join(100);\n            m = null;\n        } catch (Exception e) {\n            throw new ModuleUnloadException(\"mod=\" + name, e);\n        }\n    }\n\n    /**\n     * Register the specified module with this kernel. A module is required\n     * to register with the kernel in order to subscribe to messages and\n     * in turn communicate with other modules.\n     *\n     * @param mod The module that is to be registered.\n     * @throws ModuleRegisterException if the module has already registered.\n     */\n    public void register(Module m) throws ModuleRegisterException {\n        Message msg = null;\n        System.err.println(\"KERNEL REGISTERED: \" + m);\n        try {\n            if (modules.containsKey(m.info().name)) {\n                throw new ModuleRegisterException(m, \"A module with that name has already been registered: \" + \"name=\" + m.info().name);\n            }\n            // Add the module to the collection of registered modules.\n            modules.put(m.info().name, m);\n            // Let the module know it has been registered.\n            //sendMessage(m, new Message(\"KERNEL\",\"REGISTERED\"));\n            msg = MessageFactory.createMessage(\"KERNEL\", m.getClass().getName(), \"REGISTERED\");\n            // MessageFactory.getInstance().sendRegisterMessage(this, m);\n            sendMessage(m, msg);\n        } catch (ModuleRegisterException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new ModuleRegisterException(m, e);\n        } finally {\n            if (msg != null)\n                msg.unref();\n        }\n    }\n\n    /**\n     * Unregister the specified module. An unused module should unregister\n     * with the kernel so that all references to that module will be freed.\n     *\n     * @param mod The module that is to be unregistered.\n     * @throws ModuleRegisterException if the module is not registered.\n     */\n    public void unregister(Module m) throws ModuleRegisterException {\n        try {\n            if (!modules.containsKey(m.info().name)) {\n                throw new ModuleRegisterException(m, \"Not registered!\");\n            }\n            // maybe this should be synchronized\n            unsubscribe(m);\n            modules.remove(m.info().name);\n            //MessageFactory.getInstance().sendUnregisterMessage(this, m);\n            sendMessage(m, new Message(\"KERNEL\", \"UNREGISTERED\"));\n        } catch (ModuleRegisterException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new ModuleRegisterException(m, e);\n        }\n    }\n\n    /**\n     * Adds module as a subscriber of all messages with the\n     * specified topic.\n     *\n     * @param mod The module that is to subscribe to topic.\n     * @param topic The topic that should be subscribed to.\n     */\n    public void subscribe(Module mod, String topics) throws ModuleSubscriptionException {\n        try {\n            String[] top = topics.split(\"(,|\\\\s+)\");\n            for (int i = 0; i < top.length; i++) {\n                if (subscribers.containsKey(top[i])) {\n                    subscribers.get(top[i]).add(mod);\n                } else {\n                    Vector<Module> nv = new Vector<Module>();\n                    nv.add(mod);\n                    subscribers.put(top[i], nv);\n                }\n            }\n        } catch (Exception e) {\n            throw new ModuleSubscriptionException(mod, \"topics=\" + topics, e);\n        }\n    }\n\n    /**\n     * Unsubscribes the specified module from every topic it is\n     * subscribing to. Modules will still receive messages from\n     * the kernel though.\n     *\n     * @param mod The module that is to be unsubscribed.\n     */\n    public void unsubscribe(Module mod) {\n        // fixme - this is really ugly, O(t+ts) may easily be O(t)!\n        for (Vector v : subscribers.values()) {\n            v.remove(mod);\n        }\n    }\n\n    /**\n     * Unsubscribes the specified module from the given topic. Modules may\n     * call this method to instruct the kernel that they do not whish to\n     * receive messages in the specified topic.\n     *\n     * @param mod The module that is to be unsubscribed from topic.\n     * @param topic The topic from which we wish to unsubscribe.\n     *\n     * @throws ModuleSubscriptionException If either the topic or module are\n     * null.\n     */\n    public void unsubscribe(Module mod, String topic) throws ModuleSubscriptionException {\n        try {\n            if (subscribers.containsKey(topic)) {\n                Vector t = subscribers.get(topic);\n                t.remove(mod);\n                if (t.size() == 0) {\n                    subscribers.remove(topic);\n                }\n            }\n        } catch (Exception e) {\n            throw new ModuleSubscriptionException(e);\n        }\n    }\n\n    /**\n     * Requests the specified query from the specified topic. Observe that\n     * if there are more than one module answering a specific request, only\n     * the first one will be returned.\n     *\n     * @deprecated Requests are currently not used by the Kernel.\n     *\n     * @param mod The module that should receive the request.\n     * @param key A string containing the actual request.\n     */\n    public Object request(String mod, String key) throws MessageTimeoutException {\n        throw new MessageTimeoutException(\"Requests are not implemented\");\n    }\n\n    /**\n     * Requests the specified query from the specified topic. Observe that\n     * if there are more than one module answering a specific request, only\n     * the first one will be returned.\n     *\n     * @deprecated Requests are currently not used by the Kernel.\n     *\n     * @param msg The message containing the request.\n     *\n     * @throws MessageTimeoutException\n     * If the request times out before we receive any replies.\n     */\n    public Message request(Message msg) throws MessageTimeoutException {\n        throw new MessageTimeoutException(\"Sorry, requests are not implemented in Kernel\");\n    }\n\n    /**\n     */\n    public ModuleInfo info() {\n        return modinfo;\n    }\n\n    /**\n     * Delivers the specified message to the kernel.\n     * @param msg The message to be delivered.\n     * @throws MessageDeliveryException if message could not be delivered.\n     */\n    public void sendMessage(Message msg) throws MessageDeliveryException {\n        try {\n            sendMessage(modules.get(msg.recipient), msg);\n        } catch (Exception e) {\n            throw new MessageDeliveryException(e);\n        }\n    }\n\n    /**\n     * Delivers the specified message to the given module.\n     *\n     * @param mod the module that should receive the message.\n     * @param msg the message that should be sent.\n     * @throws MessageDeliveryException if message could not be delivered.\n     */\n    private void sendMessage(Module mod, Message msg) throws MessageDeliveryException {\n        try {\n            mod.receiveMessage(msg);\n        } catch (Exception e) {\n            throw new MessageDeliveryException(mod, msg, e);\n        }\n    }\n\n    /**\n     * Receives a message from another module. This function is public\n     * and should be called from the other module.\n     *\n     * @param msg The message to receive.\n     */\n    public void receiveMessage(Message msg) throws MessageDeliveryException {\n        try {\n            msg.ref();\n            messages.add(msg);\n            //msg.setState(Message.SENT);\n        } catch (Exception e) {\n            msg.unref();\n            throw new MessageDeliveryException(this, msg, e);\n        }\n    }\n\n    /**\n     * Handles what should done with messages sent to this module.\n     *\n     * @param msg The message to be processed.\n     * @throws Exception if the processing failed for this message.\n     */\n    protected void processMessage(Message msg) throws Exception {\n        String[] cmd = null;\n        cmd = ((String) msg.body).split(\" \");\n        if (cmd.length == 0) {\n            return;\n        }\n        if (cmd[0].equals(\"LOAD\")) {\n            loadModule(cmd[1]);\n            return;\n        }\n        if (cmd[0].equals(\"UNLOAD\")) {\n            unloadModule(cmd[1]);\n            return;\n        }\n        if (cmd[0].equals(\"DUMP\")) {\n            sendMessage(modules.get(msg.sender), msg.reply(modules.toString()));\n            sendMessage(modules.get(msg.sender), msg.reply(subscribers.toString()));\n            return;\n        }\n    }\n\n    /**\n     * Process messages from the message queue.\n     *\n     * @throws MessageProcessingException if processing failed for any\n     * message in the message queue.\n     */\n    private void processMessages() throws MessageProcessingException {\n        Message msg = null;\n        Module dst = null;\n        try {\n            while (!messages.isEmpty()) {\n                msg = messages.remove(0);\n                /* intercept messages destined for the kernel */\n                if (msg.header.equals(\"KERNEL\")) {\n                    processMessage(msg);\n                }\n                /* try sending message directly to recipient, if not null,\n\t\t   otherwise send to everyone that is subscribing to the\n\t\t   specified topic. */\n                dst = modules.get(msg.getRecipient());\n                if (dst != null) {\n                    sendMessage(dst, msg);\n                } else if (subscribers.containsKey(msg.getHeader())) {\n                    sendMessageNotify(subscribers.get(msg.getHeader()), msg);\n                }\n                /* Notify modules subscribing on all Message classes. */\n                if (subscribers.containsKey(\"*\")) {\n                    sendMessageNotify(subscribers.get(\"*\"), msg);\n                }\n                msg.setDelivered(true);\n                msg.unref();\n            }\n        } catch (Exception e) {\n            if (msg != null) {\n                msg.unref();\n            }\n            throw new MessageProcessingException(msg, e);\n        }\n    }\n\n    /**\n     * Sends the specified message to the given collection of modules.\n     * The modules are notified of the delivery (i.e. the thread is notified.)\n     *\n     * @param mods the modules that should receive the message.\n     * @param msg the message that should be delivered.\n     * @throws MessageDeliveryException if the message could not be delivered.\n     */\n    public void sendMessageNotify(Collection<Module> mods, Message msg) throws MessageDeliveryException {\n        for (Module mod : mods) {\n            sendMessage(mod, msg);\n            synchronized (mod) {\n                mod.notify();\n            }\n        }\n    }\n\n    /**\n     * Returns the Kernel associated with this Module.\n     * @return the Kernel associated with this Module.\n     */\n    public Kernel getKernel() {\n        return null;\n    }\n\n    /**\n     * Returns the thread associated with this module.\n     * @return The thread associated with this module.\n     */\n    public Thread getThread() {\n        return thread;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/module/KernelTest2.java",
		"test_prompt": "// KernelTest2.java\npackage module;\n\nimport java.util.Collection;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Collections;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Kernel}.\n* It contains ten unit test cases for the {@link Kernel#info()} method.\n*/\nclass KernelTest2 {"
	},
	{
		"original_code": "// BasicMessageRules.java\n/*\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties.\n *\n * @author: Rasmus Ahlberg\n *\n */\npackage module;\n\nimport java.util.*;\nimport state.*;\n\npublic class BasicMessageRules implements MessageRuleSet {\n\n    BasicMessageRules() {\n    }\n\n    public boolean checkRules(TextMessage textm, GameState state) {\n        Player actor = state.player(textm.getActor());\n        Player target = state.player(textm.getTarget());\n        if (actor == null)\n            return false;\n        // dead players don't have gangs\n        if (actor.isDead() && textm.getMessageType() == TextMessage.GROUP)\n            return false;\n        if (textm.getMessageType() == TextMessage.PRIVATE) {\n            // not allowed to message yourself\n            if (actor == target)\n                return false;\n            // target not allowed to be null for priv message.\n            if (target == null)\n                return false;\n            // make sure target is on the same side of river Styx.\n            if (target.isDead() != actor.isDead())\n                return false;\n        }\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/module/BasicMessageRulesTest.java",
		"test_prompt": "// BasicMessageRulesTest.java\npackage module;\n\nimport java.util.*;\nimport state.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BasicMessageRules}.\n* It contains ten unit test cases for the {@link BasicMessageRules#checkRules(TextMessage, GameState)} method.\n*/\nclass BasicMessageRulesTest {"
	},
	{
		"original_code": "// Party.java\n/* $Id: Party.java,v 1.2 2004/03/31 21:12:03 bja Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Rasmus Ahlberg <ahlbgerg@kth.se>\n * @version: $Revision: 1.2 $\n *\n */\npackage state;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * A party in the tree view. Generally, all parties used will be of\n * class Player (which extends Party).\n */\npublic class Party {\n\n    /**\n     * The party id\n     */\n    int id;\n\n    /**\n     * The supergroup.\n     */\n    public Party boss;\n\n    /**\n     * The first subgroup.\n     */\n    public Party head;\n\n    /**\n     * The next group at the same level.\n     */\n    public Party next;\n\n    /**\n     * The previous group at the same level.\n     */\n    public Party prev;\n\n    /**\n     * Creates a new instance of the Party class. All fields are set\n     * to null, except id which is set to -1.\n     */\n    public Party() {\n        this(-1);\n    }\n\n    public Party(int id) {\n        this.id = id;\n        this.boss = null;\n        this.head = null;\n        this.next = null;\n        this.prev = null;\n    }\n\n    /**\n     * Used to determine whether this player is the current boss of\n     * his gang.\n     *\n     * @return <i>true</i> if this player currently has no\n     * boss. Otherwise <i>false</i>.\n     */\n    public boolean isBoss() {\n        return boss == null;\n    }\n\n    /**\n     * Returns the boss of current gang.\n     */\n    public Party gangBoss() {\n        if (isBoss()) {\n            return this;\n        } else {\n            return boss.gangBoss();\n        }\n    }\n\n    /**\n     * Add a group as a subgroup to this group. Does not check whether\n     * a join is allowed or not.\n     *\n     * @param p The party to be added.\n     */\n    public void add(Party p) {\n        try {\n            p.boss = this;\n            p.next = head;\n            p.prev = null;\n            if (head != null) {\n                head.prev = p;\n            }\n            head = p;\n        } catch (NullPointerException e) {\n            e.printStackTrace(System.err);\n        }\n    }\n\n    /**\n     * Remove a group as a subgroup to this group. Does not check\n     * whether given group is a subgroup.\n     *\n     * @param p The party to be removed.\n     */\n    public void remove(Party p) {\n        if (p != null) {\n            if (p.prev != null) {\n                p.prev.next = p.next;\n            } else {\n                head = p.next;\n            }\n            if (p.next != null) {\n                p.next.prev = p.prev;\n            }\n            p.next = null;\n            p.prev = null;\n            p.boss = null;\n        }\n    }\n\n    /**\n     * Returns a LinkedList representation of the current subparty. A\n     * subparty includes the current Party plus all its childrens\n     * subparties.\n     */\n    public LinkedList<Party> getSubparty() {\n        LinkedList<Party> plist = new LinkedList<Party>();\n        Party tmp;\n        plist.add(this);\n        for (tmp = head; tmp != null; tmp = tmp.next) {\n            plist.addAll(tmp.getSubparty());\n        }\n        return plist;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public String toString() {\n        return \"\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/state/PartyTest0.java",
		"test_prompt": "// PartyTest0.java\npackage state;\n\nimport java.io.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Party}.\n* It contains ten unit test cases for the {@link Party#isBoss()} method.\n*/\nclass PartyTest0 {"
	},
	{
		"original_code": "// Party.java\n/* $Id: Party.java,v 1.2 2004/03/31 21:12:03 bja Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Rasmus Ahlberg <ahlbgerg@kth.se>\n * @version: $Revision: 1.2 $\n *\n */\npackage state;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * A party in the tree view. Generally, all parties used will be of\n * class Player (which extends Party).\n */\npublic class Party {\n\n    /**\n     * The party id\n     */\n    int id;\n\n    /**\n     * The supergroup.\n     */\n    public Party boss;\n\n    /**\n     * The first subgroup.\n     */\n    public Party head;\n\n    /**\n     * The next group at the same level.\n     */\n    public Party next;\n\n    /**\n     * The previous group at the same level.\n     */\n    public Party prev;\n\n    /**\n     * Creates a new instance of the Party class. All fields are set\n     * to null, except id which is set to -1.\n     */\n    public Party() {\n        this(-1);\n    }\n\n    public Party(int id) {\n        this.id = id;\n        this.boss = null;\n        this.head = null;\n        this.next = null;\n        this.prev = null;\n    }\n\n    /**\n     * Used to determine whether this player is the current boss of\n     * his gang.\n     *\n     * @return <i>true</i> if this player currently has no\n     * boss. Otherwise <i>false</i>.\n     */\n    public boolean isBoss() {\n        return boss == null;\n    }\n\n    /**\n     * Returns the boss of current gang.\n     */\n    public Party gangBoss() {\n        if (isBoss()) {\n            return this;\n        } else {\n            return boss.gangBoss();\n        }\n    }\n\n    /**\n     * Add a group as a subgroup to this group. Does not check whether\n     * a join is allowed or not.\n     *\n     * @param p The party to be added.\n     */\n    public void add(Party p) {\n        try {\n            p.boss = this;\n            p.next = head;\n            p.prev = null;\n            if (head != null) {\n                head.prev = p;\n            }\n            head = p;\n        } catch (NullPointerException e) {\n            e.printStackTrace(System.err);\n        }\n    }\n\n    /**\n     * Remove a group as a subgroup to this group. Does not check\n     * whether given group is a subgroup.\n     *\n     * @param p The party to be removed.\n     */\n    public void remove(Party p) {\n        if (p != null) {\n            if (p.prev != null) {\n                p.prev.next = p.next;\n            } else {\n                head = p.next;\n            }\n            if (p.next != null) {\n                p.next.prev = p.prev;\n            }\n            p.next = null;\n            p.prev = null;\n            p.boss = null;\n        }\n    }\n\n    /**\n     * Returns a LinkedList representation of the current subparty. A\n     * subparty includes the current Party plus all its childrens\n     * subparties.\n     */\n    public LinkedList<Party> getSubparty() {\n        LinkedList<Party> plist = new LinkedList<Party>();\n        Party tmp;\n        plist.add(this);\n        for (tmp = head; tmp != null; tmp = tmp.next) {\n            plist.addAll(tmp.getSubparty());\n        }\n        return plist;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public String toString() {\n        return \"\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/state/PartyTest1.java",
		"test_prompt": "// PartyTest1.java\npackage state;\n\nimport java.io.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Party}.\n* It contains ten unit test cases for the {@link Party#gangBoss()} method.\n*/\nclass PartyTest1 {"
	},
	{
		"original_code": "// TextMessage.java\n/* $Id: TextMessage.java,v 1.3 2004/04/30 23:35:13 emill Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Emil Lundstr�m <emill@kth.se>\n * @version: $Revision: 1.3 $\n *\n */\npackage state;\n\nimport java.io.UnsupportedEncodingException;\n\n/**\n * Class for TextMessages, i.e. messages used for the chat.\n */\npublic class TextMessage implements Packable {\n\n    private int actor;\n\n    private int target;\n\n    private int messagetype;\n\n    private String text;\n\n    private long time;\n\n    public final static int GENERAL = 0;\n\n    public final static int GROUP = 1;\n\n    public final static int PRIVATE = 2;\n\n    public final int type = Packable.TEXT_MESSAGE;\n\n    /**\n     * Creates a new TextMessage.\n     */\n    public TextMessage(int actor, int target, int messagetype, String text) {\n        this.actor = actor;\n        this.target = target;\n        this.messagetype = messagetype;\n        this.text = text;\n    }\n\n    /**\n     * Creates a new empty TextMessage. Empty messages cannot be sent\n     * over the network, and will throw a NullPointerException if\n     * done.\n     */\n    public TextMessage() {\n        this(-1, -1, -1, null);\n    }\n\n    /**\n     * Sets the actor of this Action object.\n     */\n    public void setActor(int actor) {\n        this.actor = actor;\n    }\n\n    public int getActor() {\n        return actor;\n    }\n\n    public int getTarget() {\n        return target;\n    }\n\n    public int getMessageType() {\n        return messagetype;\n    }\n\n    public String getText() {\n        return text;\n    }\n\n    public long getTime() {\n        return time;\n    }\n\n    public void setTime(long l) {\n        time = l;\n    }\n\n    public int type() {\n        return Packable.TEXT_MESSAGE;\n    }\n\n    /**\n     * Converts a TextMessage into a byte array representation.\n     *\n     * @param msg The message to be converted.\n     * @return The resulting byte array.\n     */\n    public byte[] pack() {\n        //TextMessage msg = (TextMessage) p;\n        byte[] data = null;\n        try {\n            byte[] t2 = text.getBytes(\"UTF-8\");\n            data = new byte[t2.length + 3];\n            System.arraycopy(t2, 0, data, 3, t2.length);\n            data[0] = (byte) actor;\n            data[1] = (byte) target;\n            data[2] = (byte) messagetype;\n        } catch (UnsupportedEncodingException e) {\n            /* All javavms are required to implement UTF-8 */\n        }\n        return data;\n    }\n\n    /**\n     * Converts a byte array back into a TextMessage.\n     *\n     * @param data The byte array to be converted.\n     * @return The resultning message.\n     */\n    public void unpack(byte[] data) {\n        try {\n            this.actor = (int) data[0];\n            this.target = (int) data[1];\n            this.messagetype = (int) data[2];\n            byte[] textbytes = new byte[data.length - 3];\n            System.arraycopy(data, 3, textbytes, 0, data.length - 3);\n            this.text = new String(textbytes, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            /* All javavms are required to implement UTF-8 */\n        }\n    }\n\n    public String toString() {\n        return \"TextMessage[\" + actor + \",\" + target + \",\" + messagetype + \",\" + text + \"]\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/state/TextMessageTest0.java",
		"test_prompt": "// TextMessageTest0.java\npackage state;\n\nimport java.io.UnsupportedEncodingException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TextMessage}.\n* It contains ten unit test cases for the {@link TextMessage#type()} method.\n*/\nclass TextMessageTest0 {"
	},
	{
		"original_code": "// TextMessage.java\n/* $Id: TextMessage.java,v 1.3 2004/04/30 23:35:13 emill Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Emil Lundstr�m <emill@kth.se>\n * @version: $Revision: 1.3 $\n *\n */\npackage state;\n\nimport java.io.UnsupportedEncodingException;\n\n/**\n * Class for TextMessages, i.e. messages used for the chat.\n */\npublic class TextMessage implements Packable {\n\n    private int actor;\n\n    private int target;\n\n    private int messagetype;\n\n    private String text;\n\n    private long time;\n\n    public final static int GENERAL = 0;\n\n    public final static int GROUP = 1;\n\n    public final static int PRIVATE = 2;\n\n    public final int type = Packable.TEXT_MESSAGE;\n\n    /**\n     * Creates a new TextMessage.\n     */\n    public TextMessage(int actor, int target, int messagetype, String text) {\n        this.actor = actor;\n        this.target = target;\n        this.messagetype = messagetype;\n        this.text = text;\n    }\n\n    /**\n     * Creates a new empty TextMessage. Empty messages cannot be sent\n     * over the network, and will throw a NullPointerException if\n     * done.\n     */\n    public TextMessage() {\n        this(-1, -1, -1, null);\n    }\n\n    /**\n     * Sets the actor of this Action object.\n     */\n    public void setActor(int actor) {\n        this.actor = actor;\n    }\n\n    public int getActor() {\n        return actor;\n    }\n\n    public int getTarget() {\n        return target;\n    }\n\n    public int getMessageType() {\n        return messagetype;\n    }\n\n    public String getText() {\n        return text;\n    }\n\n    public long getTime() {\n        return time;\n    }\n\n    public void setTime(long l) {\n        time = l;\n    }\n\n    public int type() {\n        return Packable.TEXT_MESSAGE;\n    }\n\n    /**\n     * Converts a TextMessage into a byte array representation.\n     *\n     * @param msg The message to be converted.\n     * @return The resulting byte array.\n     */\n    public byte[] pack() {\n        //TextMessage msg = (TextMessage) p;\n        byte[] data = null;\n        try {\n            byte[] t2 = text.getBytes(\"UTF-8\");\n            data = new byte[t2.length + 3];\n            System.arraycopy(t2, 0, data, 3, t2.length);\n            data[0] = (byte) actor;\n            data[1] = (byte) target;\n            data[2] = (byte) messagetype;\n        } catch (UnsupportedEncodingException e) {\n            /* All javavms are required to implement UTF-8 */\n        }\n        return data;\n    }\n\n    /**\n     * Converts a byte array back into a TextMessage.\n     *\n     * @param data The byte array to be converted.\n     * @return The resultning message.\n     */\n    public void unpack(byte[] data) {\n        try {\n            this.actor = (int) data[0];\n            this.target = (int) data[1];\n            this.messagetype = (int) data[2];\n            byte[] textbytes = new byte[data.length - 3];\n            System.arraycopy(data, 3, textbytes, 0, data.length - 3);\n            this.text = new String(textbytes, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            /* All javavms are required to implement UTF-8 */\n        }\n    }\n\n    public String toString() {\n        return \"TextMessage[\" + actor + \",\" + target + \",\" + messagetype + \",\" + text + \"]\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/state/TextMessageTest1.java",
		"test_prompt": "// TextMessageTest1.java\npackage state;\n\nimport java.io.UnsupportedEncodingException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TextMessage}.\n* It contains ten unit test cases for the {@link TextMessage#pack()} method.\n*/\nclass TextMessageTest1 {"
	},
	{
		"original_code": "// ActionFactory.java\n/* $Id: ActionFactory.java,v 1.2 2004/04/27 19:26:22 bja Exp $ */\npackage state;\n\nimport util.AbstractFactory;\nimport util.ObjectManager;\nimport util.ManagedObject;\n\npublic class ActionFactory extends AbstractFactory<Action> {\n\n    /**\n     * The reference to the MessageFactory instance.\n     */\n    protected static ActionFactory instance = null;\n\n    /**\n     * Creates a new instance of the ActionFactory class.\n     */\n    private ActionFactory() {\n        super(new Action());\n    }\n\n    /**\n     * Creates a new default Action with the specified arguments.\n     *\n     * @param type The type of Action to create.\n     * @param actor The actorID associated with this Action.\n     * @param target The targetID associated with this Action.\n     * @return a new Action instance with the specified arguments.\n     */\n    public Action createAction(int type, int actor, int target) {\n        Action action = createObject();\n        action.set(type, actor, target, (byte) 0, (byte) 0, (byte) 0);\n        System.err.println(\"ActionFactory.createAction(): size = \" + getStockCount());\n        return action;\n    }\n\n    /**\n     * Creates a new move Action with the specified arguments.\n     *\n     * @param actor The actorID associated with this Action.\n     * @param x the x coordinate of the destination point.\n     * @param y the y coordinate of the destination point.\n     * @param z the z coordinate of the destination point.\n     * @return a new move Action with the specified arguments.\n     */\n    public Action createMoveAction(int actor, byte x, byte y, byte z) {\n        Action action = createObject();\n        action.set(Action.ACTION_MOVE, actor, -1, x, y, z);\n        System.err.println(\"ActionFactory.createAction(): size = \" + getStockCount());\n        return action;\n    }\n\n    /**\n     * Returns the ActionFactory instance, currently the instance\n     * returned is that of the last created MessageFactory.\n     */\n    public static ActionFactory getInstance() {\n        return instance != null ? instance : new ActionFactory();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/state/ActionFactoryTest0.java",
		"test_prompt": "// ActionFactoryTest0.java\npackage state;\n\nimport util.AbstractFactory;\nimport util.ObjectManager;\nimport util.ManagedObject;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ActionFactory}.\n* It contains ten unit test cases for the {@link ActionFactory#createAction(int, int, int)} method.\n*/\nclass ActionFactoryTest0 {"
	},
	{
		"original_code": "// ActionFactory.java\n/* $Id: ActionFactory.java,v 1.2 2004/04/27 19:26:22 bja Exp $ */\npackage state;\n\nimport util.AbstractFactory;\nimport util.ObjectManager;\nimport util.ManagedObject;\n\npublic class ActionFactory extends AbstractFactory<Action> {\n\n    /**\n     * The reference to the MessageFactory instance.\n     */\n    protected static ActionFactory instance = null;\n\n    /**\n     * Creates a new instance of the ActionFactory class.\n     */\n    private ActionFactory() {\n        super(new Action());\n    }\n\n    /**\n     * Creates a new default Action with the specified arguments.\n     *\n     * @param type The type of Action to create.\n     * @param actor The actorID associated with this Action.\n     * @param target The targetID associated with this Action.\n     * @return a new Action instance with the specified arguments.\n     */\n    public Action createAction(int type, int actor, int target) {\n        Action action = createObject();\n        action.set(type, actor, target, (byte) 0, (byte) 0, (byte) 0);\n        System.err.println(\"ActionFactory.createAction(): size = \" + getStockCount());\n        return action;\n    }\n\n    /**\n     * Creates a new move Action with the specified arguments.\n     *\n     * @param actor The actorID associated with this Action.\n     * @param x the x coordinate of the destination point.\n     * @param y the y coordinate of the destination point.\n     * @param z the z coordinate of the destination point.\n     * @return a new move Action with the specified arguments.\n     */\n    public Action createMoveAction(int actor, byte x, byte y, byte z) {\n        Action action = createObject();\n        action.set(Action.ACTION_MOVE, actor, -1, x, y, z);\n        System.err.println(\"ActionFactory.createAction(): size = \" + getStockCount());\n        return action;\n    }\n\n    /**\n     * Returns the ActionFactory instance, currently the instance\n     * returned is that of the last created MessageFactory.\n     */\n    public static ActionFactory getInstance() {\n        return instance != null ? instance : new ActionFactory();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/state/ActionFactoryTest1.java",
		"test_prompt": "// ActionFactoryTest1.java\npackage state;\n\nimport util.AbstractFactory;\nimport util.ObjectManager;\nimport util.ManagedObject;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ActionFactory}.\n* It contains ten unit test cases for the {@link ActionFactory#createMoveAction(int, byte, byte, byte)} method.\n*/\nclass ActionFactoryTest1 {"
	},
	{
		"original_code": "// ActionFactory.java\n/* $Id: ActionFactory.java,v 1.2 2004/04/27 19:26:22 bja Exp $ */\npackage state;\n\nimport util.AbstractFactory;\nimport util.ObjectManager;\nimport util.ManagedObject;\n\npublic class ActionFactory extends AbstractFactory<Action> {\n\n    /**\n     * The reference to the MessageFactory instance.\n     */\n    protected static ActionFactory instance = null;\n\n    /**\n     * Creates a new instance of the ActionFactory class.\n     */\n    private ActionFactory() {\n        super(new Action());\n    }\n\n    /**\n     * Creates a new default Action with the specified arguments.\n     *\n     * @param type The type of Action to create.\n     * @param actor The actorID associated with this Action.\n     * @param target The targetID associated with this Action.\n     * @return a new Action instance with the specified arguments.\n     */\n    public Action createAction(int type, int actor, int target) {\n        Action action = createObject();\n        action.set(type, actor, target, (byte) 0, (byte) 0, (byte) 0);\n        System.err.println(\"ActionFactory.createAction(): size = \" + getStockCount());\n        return action;\n    }\n\n    /**\n     * Creates a new move Action with the specified arguments.\n     *\n     * @param actor The actorID associated with this Action.\n     * @param x the x coordinate of the destination point.\n     * @param y the y coordinate of the destination point.\n     * @param z the z coordinate of the destination point.\n     * @return a new move Action with the specified arguments.\n     */\n    public Action createMoveAction(int actor, byte x, byte y, byte z) {\n        Action action = createObject();\n        action.set(Action.ACTION_MOVE, actor, -1, x, y, z);\n        System.err.println(\"ActionFactory.createAction(): size = \" + getStockCount());\n        return action;\n    }\n\n    /**\n     * Returns the ActionFactory instance, currently the instance\n     * returned is that of the last created MessageFactory.\n     */\n    public static ActionFactory getInstance() {\n        return instance != null ? instance : new ActionFactory();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/state/ActionFactoryTest2.java",
		"test_prompt": "// ActionFactoryTest2.java\npackage state;\n\nimport util.AbstractFactory;\nimport util.ObjectManager;\nimport util.ManagedObject;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ActionFactory}.\n* It contains ten unit test cases for the {@link ActionFactory#getInstance()} method.\n*/\nclass ActionFactoryTest2 {"
	},
	{
		"original_code": "// GameEvent.java\n/* $Id: GameEvent.java,v 1.6 2004/04/30 23:35:12 emill Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Emil Lundstr�m <emill@kth.se>\n * @version: $Revision: 1.6 $\n *\n */\npackage state;\n\nimport java.io.UnsupportedEncodingException;\n\n/**\n * Class for game events to be sent to the clients.\n *\n * Possible events include:\n *\n * GameEvent.FIGHT\n * <i>actor</i>'s group defeated <i>target</i>'s group in a fight.\n * GameEvent.JOIN\n * <i>actor</i> joined <i>target</i>'s group.\n * GameEvent.APPLY\n * <i>actor</i> wants to join <i>target</i>'s group.\n * GameEvent.INVITE\n * <i>actor</i> invites <i>target</i> to join.\n * GameEvent.WARMUP\n * The warmup time has started. <i>actor</i> and <i>target</i> are undefined.\n * GameEvent.START\n * The game is now started. <i>actor</i> and <i>target</i> are undefined.\n * GameEvent.END\n * The game has now ended. <i>actor</i> and <i>target</i> are undefined.\n * GameEvent.DROP\n * <i>actor</i> was dropped from the game.\n */\npublic class GameEvent implements Packable {\n\n    /**\n     * Actor\n     */\n    private int actor;\n\n    /**\n     * Target of the action. @see GameEvent\n     */\n    private int target;\n\n    /**\n     * Event type! Can be of values:\n     * FIGHT, JOIN, APPLY, INVITE, START, END, DROP, PART.\n     */\n    private int eventtype;\n\n    /**\n     * Relative time to gamestart.\n     */\n    private long time;\n\n    public final int type = Packable.GAME_EVENT;\n\n    public final static int FIGHT = 0;\n\n    public final static int JOIN = 1;\n\n    public final static int APPLY = 2;\n\n    public final static int INVITE = 3;\n\n    public final static int START = 4;\n\n    public final static int END = 5;\n\n    public final static int DROP = 6;\n\n    public final static int PART = 7;\n\n    public final static int MOVE = 8;\n\n    public final static int KICK = 9;\n\n    public final static int WARMUP = 10;\n\n    /**\n     * Creates a new GameEvent.\n     */\n    public GameEvent(int actor, int target, int eventtype) {\n        this.actor = actor;\n        this.target = target;\n        this.eventtype = eventtype;\n    }\n\n    /**\n     * Creates a new GameEvent.\n     */\n    public GameEvent(int actor, int target, int eventtype, int time) {\n        this(actor, target, eventtype);\n        this.time = time;\n    }\n\n    /**\n     * Creates a new empty GameEvent. Empty events cannot be sent over\n     * the network, and will throw a NullPointerException if done.\n     */\n    public GameEvent() {\n        this(-1, -1, -1);\n    }\n\n    /**\n     * Creates a new empty GameEvent. Empty events cannot be sent over\n     * the network, and will throw a NullPointerException if done.\n     */\n    public GameEvent(long time) {\n        this(-1, -1, -1);\n        this.time = time;\n    }\n\n    public int getActor() {\n        return actor;\n    }\n\n    public int getTarget() {\n        return target;\n    }\n\n    public int getEventType() {\n        return eventtype;\n    }\n\n    public long getTime() {\n        return time;\n    }\n\n    public void setTime(long l) {\n        time = l;\n    }\n\n    /**\n     * Sets the actor, target, and eventType of this Action to the\n     * specified values;\n     *\n     * @param actor the Actor performing this action.\n     * @param target the Target receiving this action.\n     * @param etype the type of action.\n     */\n    public void setAction(int actor, int target, int etype) {\n        this.actor = actor;\n        this.target = target;\n        this.eventtype = etype;\n    }\n\n    public int type() {\n        return Packable.GAME_EVENT;\n    }\n\n    /**\n     * Converts a GameEvent into a byte array representation.\n     *\n     * @param msg The message to be converted.\n     * @return The resulting byte array.\n     */\n    public byte[] pack() {\n        byte[] data = new byte[3];\n        data[0] = (byte) actor;\n        data[1] = (byte) target;\n        data[2] = (byte) eventtype;\n        return data;\n    }\n\n    /**\n     * Converts a byte array back into a GameEvent.\n     *\n     * @param data The byte array to be converted.\n     * @return The resultning message.\n     */\n    public void unpack(byte[] data) {\n        this.actor = (int) data[0];\n        this.target = (int) data[1];\n        this.eventtype = (int) data[2];\n    }\n\n    public String toString() {\n        return \"GameEvent[\" + eventtype + \",\" + actor + \",\" + target + \"]\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/state/GameEventTest0.java",
		"test_prompt": "// GameEventTest0.java\npackage state;\n\nimport java.io.UnsupportedEncodingException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GameEvent}.\n* It contains ten unit test cases for the {@link GameEvent#type()} method.\n*/\nclass GameEventTest0 {"
	},
	{
		"original_code": "// GameEvent.java\n/* $Id: GameEvent.java,v 1.6 2004/04/30 23:35:12 emill Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Emil Lundstr�m <emill@kth.se>\n * @version: $Revision: 1.6 $\n *\n */\npackage state;\n\nimport java.io.UnsupportedEncodingException;\n\n/**\n * Class for game events to be sent to the clients.\n *\n * Possible events include:\n *\n * GameEvent.FIGHT\n * <i>actor</i>'s group defeated <i>target</i>'s group in a fight.\n * GameEvent.JOIN\n * <i>actor</i> joined <i>target</i>'s group.\n * GameEvent.APPLY\n * <i>actor</i> wants to join <i>target</i>'s group.\n * GameEvent.INVITE\n * <i>actor</i> invites <i>target</i> to join.\n * GameEvent.WARMUP\n * The warmup time has started. <i>actor</i> and <i>target</i> are undefined.\n * GameEvent.START\n * The game is now started. <i>actor</i> and <i>target</i> are undefined.\n * GameEvent.END\n * The game has now ended. <i>actor</i> and <i>target</i> are undefined.\n * GameEvent.DROP\n * <i>actor</i> was dropped from the game.\n */\npublic class GameEvent implements Packable {\n\n    /**\n     * Actor\n     */\n    private int actor;\n\n    /**\n     * Target of the action. @see GameEvent\n     */\n    private int target;\n\n    /**\n     * Event type! Can be of values:\n     * FIGHT, JOIN, APPLY, INVITE, START, END, DROP, PART.\n     */\n    private int eventtype;\n\n    /**\n     * Relative time to gamestart.\n     */\n    private long time;\n\n    public final int type = Packable.GAME_EVENT;\n\n    public final static int FIGHT = 0;\n\n    public final static int JOIN = 1;\n\n    public final static int APPLY = 2;\n\n    public final static int INVITE = 3;\n\n    public final static int START = 4;\n\n    public final static int END = 5;\n\n    public final static int DROP = 6;\n\n    public final static int PART = 7;\n\n    public final static int MOVE = 8;\n\n    public final static int KICK = 9;\n\n    public final static int WARMUP = 10;\n\n    /**\n     * Creates a new GameEvent.\n     */\n    public GameEvent(int actor, int target, int eventtype) {\n        this.actor = actor;\n        this.target = target;\n        this.eventtype = eventtype;\n    }\n\n    /**\n     * Creates a new GameEvent.\n     */\n    public GameEvent(int actor, int target, int eventtype, int time) {\n        this(actor, target, eventtype);\n        this.time = time;\n    }\n\n    /**\n     * Creates a new empty GameEvent. Empty events cannot be sent over\n     * the network, and will throw a NullPointerException if done.\n     */\n    public GameEvent() {\n        this(-1, -1, -1);\n    }\n\n    /**\n     * Creates a new empty GameEvent. Empty events cannot be sent over\n     * the network, and will throw a NullPointerException if done.\n     */\n    public GameEvent(long time) {\n        this(-1, -1, -1);\n        this.time = time;\n    }\n\n    public int getActor() {\n        return actor;\n    }\n\n    public int getTarget() {\n        return target;\n    }\n\n    public int getEventType() {\n        return eventtype;\n    }\n\n    public long getTime() {\n        return time;\n    }\n\n    public void setTime(long l) {\n        time = l;\n    }\n\n    /**\n     * Sets the actor, target, and eventType of this Action to the\n     * specified values;\n     *\n     * @param actor the Actor performing this action.\n     * @param target the Target receiving this action.\n     * @param etype the type of action.\n     */\n    public void setAction(int actor, int target, int etype) {\n        this.actor = actor;\n        this.target = target;\n        this.eventtype = etype;\n    }\n\n    public int type() {\n        return Packable.GAME_EVENT;\n    }\n\n    /**\n     * Converts a GameEvent into a byte array representation.\n     *\n     * @param msg The message to be converted.\n     * @return The resulting byte array.\n     */\n    public byte[] pack() {\n        byte[] data = new byte[3];\n        data[0] = (byte) actor;\n        data[1] = (byte) target;\n        data[2] = (byte) eventtype;\n        return data;\n    }\n\n    /**\n     * Converts a byte array back into a GameEvent.\n     *\n     * @param data The byte array to be converted.\n     * @return The resultning message.\n     */\n    public void unpack(byte[] data) {\n        this.actor = (int) data[0];\n        this.target = (int) data[1];\n        this.eventtype = (int) data[2];\n    }\n\n    public String toString() {\n        return \"GameEvent[\" + eventtype + \",\" + actor + \",\" + target + \"]\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/state/GameEventTest1.java",
		"test_prompt": "// GameEventTest1.java\npackage state;\n\nimport java.io.UnsupportedEncodingException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GameEvent}.\n* It contains ten unit test cases for the {@link GameEvent#pack()} method.\n*/\nclass GameEventTest1 {"
	},
	{
		"original_code": "// Player.java\n/* $Id: Player.java,v 1.20 2004/05/05 23:45:20 njursten Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Rasmus Ahlberg <ahlbgerg@kth.se>\n * @version: $Revision: 1.20 $\n *\n */\npackage state;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * Represents a player in the game world.\n */\npublic class Player extends Party implements Packable {\n\n    /**\n     * The tolerance to decide whether a player has reached its\n     *        destination. If x or y distance to target is less than\n     *        TOLERANCE, no move in that direction is triggered.\n     */\n    public static final float TOLERANCE = 0.2f;\n\n    /**\n     * The distance to move in one step.\n     */\n    public static final float MOVE_DISTANCE = 0.1f;\n\n    /**\n     * Number to verify against when unpacking.\n     */\n    public static final short MAGIC_NO = 0x1337;\n\n    /* Strength of this player */\n    private int strength;\n\n    /* Picture of this player */\n    private int pictureid;\n\n    /* True if this player is alive */\n    private boolean alive;\n\n    /* The time when this user died. */\n    private long deathtime;\n\n    /* World coordinates of this player. */\n    private float x = 10.0f, y = 0.0f, z;\n\n    /**\n     * List to keep track of allowed joins\n     */\n    private Hashtable<Integer, JoinInfo> joinlist;\n\n    /**\n     * Size of player class when packed (not including length of name)\n     */\n    private int packsize = 10;\n\n    /**\n     * Reference to the packed data.\n     */\n    private byte[] data;\n\n    /**\n     * True if referenced data is _not_ up to date.\n     */\n    private boolean dirty;\n\n    /**\n     * Name of the player.\n     */\n    private String name;\n\n    /**\n     * False if this player has dropped from the game.\n     */\n    private boolean connected;\n\n    /**\n     * The IP of the player.\n     */\n    private String ip;\n\n    /**\n     * Amount of money the user has earned.\n     */\n    private float money;\n\n    /**\n     * Class used to keep track of when a user was invited or applied\n     * to join a group.\n     */\n    private class JoinInfo {\n\n        long time;\n\n        boolean invite;\n\n        JoinInfo(boolean invited) {\n            time = System.currentTimeMillis();\n            invite = invited;\n        }\n    }\n\n    /**\n     * Creates a new empty instance of the Player class without an\n     * id. Note that a call to GameState.player(pidFor(new Player()))\n     * will return null.\n     */\n    public Player() {\n        this(-1);\n    }\n\n    /**\n     * Creates a new player with the given id.\n     * @param id the associated id of this player.\n     */\n    public Player(int id) {\n        super(id);\n        this.strength = 1;\n        this.pictureid = 0;\n        this.alive = true;\n        this.dirty = true;\n        this.name = \"Player\" + id;\n        this.deathtime = 0;\n        this.connected = true;\n        this.ip = \"0.0.0.0\";\n        this.joinlist = new Hashtable<Integer, JoinInfo>();\n    }\n\n    public void reset(boolean newGame) {\n        this.joinlist = new Hashtable<Integer, JoinInfo>();\n        this.alive = true;\n        this.dirty = true;\n        this.deathtime = 0;\n        this.boss = null;\n        this.head = null;\n        this.next = null;\n        this.prev = null;\n        if (newGame) {\n            money = 0;\n        }\n    }\n\n    /**\n     */\n    public Player(int id, String name, int pictureid) {\n        this(id);\n        this.name = name;\n        this.pictureid = pictureid;\n        System.err.println(id + \" \" + name + \" \" + pictureid);\n    }\n\n    /**\n     */\n    public Player(int id, String ip, String name, int pictureid) {\n        this(id, name, pictureid);\n        this.ip = ip;\n    }\n\n    public Player(int id, String ip, String name, int pid, int strength) {\n        this(id, ip, name, pid);\n        this.strength = strength;\n    }\n\n    public boolean isConnected() {\n        return connected;\n    }\n\n    public void setConnected(boolean conned) {\n        connected = conned;\n    }\n\n    /**\n     * Returns the current strength of the gang this player is part of.\n     * @return the total strength of this players gang.\n     */\n    public int gangStrength() {\n        int str = 0;\n        LinkedList<Party> gang = gangBoss().getSubparty();\n        for (Party p : gang) {\n            str += ((Player) p).strength;\n        }\n        return str;\n    }\n\n    public void setDead(long deathtime, boolean alive) {\n        this.deathtime = deathtime;\n        this.alive = alive;\n    }\n\n    public void setDead() {\n        setDead(System.currentTimeMillis());\n    }\n\n    public void setDead(long deathtime) {\n        setDead(deathtime, false);\n    }\n\n    public boolean isDead() {\n        return !alive;\n    }\n\n    public long getTimeOfDeath() {\n        return deathtime;\n    }\n\n    public int getStrength() {\n        return strength;\n    }\n\n    /**\n     * Sets the amount of money this player has earned\n     */\n    public void setMoney(float money) {\n        this.money = money;\n    }\n\n    /**\n     * Returns amount of money this player has earned\n     */\n    public float getMoney() {\n        return money;\n    }\n\n    /**\n     * Returns player IP.\n     */\n    public String getIP() {\n        return ip;\n    }\n\n    /**\n     * Returns player name.\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns player picture id.\n     */\n    public int getPictureId() {\n        return pictureid;\n    }\n\n    /**\n     * Returns player x coordinate.\n     */\n    public float getX() {\n        return x;\n    }\n\n    /**\n     * Returns player y coordinate.\n     */\n    public float getY() {\n        return y;\n    }\n\n    /**\n     * Returns player z coordinate.\n     */\n    public float getZ() {\n        return z;\n    }\n\n    /**\n     * Sets player y coordinate.\n     */\n    public void setY(float f) {\n        y = f;\n    }\n\n    /**\n     * Sets player x coordinate.\n     */\n    public void setX(float f) {\n        x = f;\n    }\n\n    /**\n     * Sets player z coordinate.\n     */\n    public void setZ(float f) {\n        z = f;\n    }\n\n    /**\n     * Checks if player <i>joiner</i> is allowed to join the current player.\n     * If <i>invited</i> is set it will be checked if <i>joiner</i> was\n     * invited, otherwise it'll be checked if <i>joiner</i> applied.\n     */\n    public boolean isJoinOK(Player joiner, boolean invited) {\n        if (joinlist.containsKey(joiner.getId())) {\n            JoinInfo jinfo = joinlist.get(joiner.getId());\n            // change 15000 to either a constant defined at top of\n            // file or a variable read from config\n            if (jinfo.time + 15000 > System.currentTimeMillis() && jinfo.invite == invited)\n                return true;\n        }\n        return false;\n    }\n\n    public void setJoinOK(Player joiner, boolean invited) {\n        JoinInfo jinfo = new JoinInfo(invited);\n        joinlist.put(joiner.id, jinfo);\n    }\n\n    /**\n     * Packs this player into the specified stream.\n     * @param out the stream to write this player to.\n     */\n    public void pack(DataOutputStream out) throws IOException {\n        out.writeShort(MAGIC_NO);\n        out.writeByte(id);\n        out.writeShort(strength);\n        out.writeShort(pictureid);\n        out.writeFloat(x);\n        out.writeFloat(y);\n        out.writeFloat(z);\n        out.writeUTF(name);\n    }\n\n    /**\n     * Unpack and set player data from the specified stream.\n     * @param in the stream to read data from.\n     * @return true if data was successfully unpacked.\n     */\n    public boolean unpack(DataInputStream in) {\n        Player tmp = null;\n        try {\n            /* Verify that stream really contains player data. */\n            if (in.readShort() != MAGIC_NO) {\n                System.err.println(\"Player.unpack(): *** WARNING *** \" + \"data is not of proper type!\");\n                return false;\n            }\n            /* Try unpacking the data to a temporary variable before\n\t       commiting the changes. */\n            tmp = new Player();\n            tmp.id = in.readByte();\n            tmp.strength = in.readShort();\n            tmp.pictureid = in.readShort();\n            tmp.x = in.readFloat();\n            tmp.y = in.readFloat();\n            tmp.z = in.readFloat();\n            tmp.name = in.readUTF();\n        } catch (EOFException e) {\n            System.err.println(\"Player.unpack(): *** WARNING *** [EOF] \" + \"data was incomplete: \" + e.getMessage());\n            return false;\n        } catch (IOException e) {\n            System.err.println(\"Player.unpack(): *** WARNING *** [IO] \" + \"failed to unpack data: \" + e.getMessage());\n            return false;\n        }\n        /* Apply the unpacked data. */\n        id = tmp.id;\n        name = tmp.name;\n        strength = tmp.strength;\n        pictureid = tmp.pictureid;\n        x = tmp.x;\n        y = tmp.y;\n        z = tmp.z;\n        return true;\n    }\n\n    /**\n     * Returns an unambigious byte-array representation of this\n     * object.\n     *\n     * @deprecated\n     * @return The resulting byte array.\n     */\n    public byte[] pack() {\n        try {\n            ByteArrayOutputStream buf = new ByteArrayOutputStream();\n            DataOutputStream out = new DataOutputStream(buf);\n            pack(out);\n            out.close();\n            return buf.toByteArray();\n        } catch (IOException e) {\n            System.err.println(\"Player.pack(): *** ERROR *** [IO] \" + \"pack failed! current state is \" + \"inconsistent: \" + e.getMessage());\n        }\n        return null;\n    }\n\n    /**\n     * Unpacks an array previously created with pack() and puts in\n     * this object.\n     *\n     * @deprecated\n     * @param b the byte array to be unpacked.\n     */\n    public void unpack(byte[] b) {\n        unpack(new DataInputStream(new ByteArrayInputStream(b)));\n    }\n\n    /**\n     * Returns the type of the packable.\n     * @return The resulting byte array.\n     */\n    public int type() {\n        return Packable.PLAYER;\n    }\n\n    public String toString() {\n        return name;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/state/PlayerTest0.java",
		"test_prompt": "// PlayerTest0.java\npackage state;\n\nimport java.io.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Player}.\n* It contains ten unit test cases for the {@link Player#isConnected()} method.\n*/\nclass PlayerTest0 {"
	},
	{
		"original_code": "// Player.java\n/* $Id: Player.java,v 1.20 2004/05/05 23:45:20 njursten Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Rasmus Ahlberg <ahlbgerg@kth.se>\n * @version: $Revision: 1.20 $\n *\n */\npackage state;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * Represents a player in the game world.\n */\npublic class Player extends Party implements Packable {\n\n    /**\n     * The tolerance to decide whether a player has reached its\n     *        destination. If x or y distance to target is less than\n     *        TOLERANCE, no move in that direction is triggered.\n     */\n    public static final float TOLERANCE = 0.2f;\n\n    /**\n     * The distance to move in one step.\n     */\n    public static final float MOVE_DISTANCE = 0.1f;\n\n    /**\n     * Number to verify against when unpacking.\n     */\n    public static final short MAGIC_NO = 0x1337;\n\n    /* Strength of this player */\n    private int strength;\n\n    /* Picture of this player */\n    private int pictureid;\n\n    /* True if this player is alive */\n    private boolean alive;\n\n    /* The time when this user died. */\n    private long deathtime;\n\n    /* World coordinates of this player. */\n    private float x = 10.0f, y = 0.0f, z;\n\n    /**\n     * List to keep track of allowed joins\n     */\n    private Hashtable<Integer, JoinInfo> joinlist;\n\n    /**\n     * Size of player class when packed (not including length of name)\n     */\n    private int packsize = 10;\n\n    /**\n     * Reference to the packed data.\n     */\n    private byte[] data;\n\n    /**\n     * True if referenced data is _not_ up to date.\n     */\n    private boolean dirty;\n\n    /**\n     * Name of the player.\n     */\n    private String name;\n\n    /**\n     * False if this player has dropped from the game.\n     */\n    private boolean connected;\n\n    /**\n     * The IP of the player.\n     */\n    private String ip;\n\n    /**\n     * Amount of money the user has earned.\n     */\n    private float money;\n\n    /**\n     * Class used to keep track of when a user was invited or applied\n     * to join a group.\n     */\n    private class JoinInfo {\n\n        long time;\n\n        boolean invite;\n\n        JoinInfo(boolean invited) {\n            time = System.currentTimeMillis();\n            invite = invited;\n        }\n    }\n\n    /**\n     * Creates a new empty instance of the Player class without an\n     * id. Note that a call to GameState.player(pidFor(new Player()))\n     * will return null.\n     */\n    public Player() {\n        this(-1);\n    }\n\n    /**\n     * Creates a new player with the given id.\n     * @param id the associated id of this player.\n     */\n    public Player(int id) {\n        super(id);\n        this.strength = 1;\n        this.pictureid = 0;\n        this.alive = true;\n        this.dirty = true;\n        this.name = \"Player\" + id;\n        this.deathtime = 0;\n        this.connected = true;\n        this.ip = \"0.0.0.0\";\n        this.joinlist = new Hashtable<Integer, JoinInfo>();\n    }\n\n    public void reset(boolean newGame) {\n        this.joinlist = new Hashtable<Integer, JoinInfo>();\n        this.alive = true;\n        this.dirty = true;\n        this.deathtime = 0;\n        this.boss = null;\n        this.head = null;\n        this.next = null;\n        this.prev = null;\n        if (newGame) {\n            money = 0;\n        }\n    }\n\n    /**\n     */\n    public Player(int id, String name, int pictureid) {\n        this(id);\n        this.name = name;\n        this.pictureid = pictureid;\n        System.err.println(id + \" \" + name + \" \" + pictureid);\n    }\n\n    /**\n     */\n    public Player(int id, String ip, String name, int pictureid) {\n        this(id, name, pictureid);\n        this.ip = ip;\n    }\n\n    public Player(int id, String ip, String name, int pid, int strength) {\n        this(id, ip, name, pid);\n        this.strength = strength;\n    }\n\n    public boolean isConnected() {\n        return connected;\n    }\n\n    public void setConnected(boolean conned) {\n        connected = conned;\n    }\n\n    /**\n     * Returns the current strength of the gang this player is part of.\n     * @return the total strength of this players gang.\n     */\n    public int gangStrength() {\n        int str = 0;\n        LinkedList<Party> gang = gangBoss().getSubparty();\n        for (Party p : gang) {\n            str += ((Player) p).strength;\n        }\n        return str;\n    }\n\n    public void setDead(long deathtime, boolean alive) {\n        this.deathtime = deathtime;\n        this.alive = alive;\n    }\n\n    public void setDead() {\n        setDead(System.currentTimeMillis());\n    }\n\n    public void setDead(long deathtime) {\n        setDead(deathtime, false);\n    }\n\n    public boolean isDead() {\n        return !alive;\n    }\n\n    public long getTimeOfDeath() {\n        return deathtime;\n    }\n\n    public int getStrength() {\n        return strength;\n    }\n\n    /**\n     * Sets the amount of money this player has earned\n     */\n    public void setMoney(float money) {\n        this.money = money;\n    }\n\n    /**\n     * Returns amount of money this player has earned\n     */\n    public float getMoney() {\n        return money;\n    }\n\n    /**\n     * Returns player IP.\n     */\n    public String getIP() {\n        return ip;\n    }\n\n    /**\n     * Returns player name.\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns player picture id.\n     */\n    public int getPictureId() {\n        return pictureid;\n    }\n\n    /**\n     * Returns player x coordinate.\n     */\n    public float getX() {\n        return x;\n    }\n\n    /**\n     * Returns player y coordinate.\n     */\n    public float getY() {\n        return y;\n    }\n\n    /**\n     * Returns player z coordinate.\n     */\n    public float getZ() {\n        return z;\n    }\n\n    /**\n     * Sets player y coordinate.\n     */\n    public void setY(float f) {\n        y = f;\n    }\n\n    /**\n     * Sets player x coordinate.\n     */\n    public void setX(float f) {\n        x = f;\n    }\n\n    /**\n     * Sets player z coordinate.\n     */\n    public void setZ(float f) {\n        z = f;\n    }\n\n    /**\n     * Checks if player <i>joiner</i> is allowed to join the current player.\n     * If <i>invited</i> is set it will be checked if <i>joiner</i> was\n     * invited, otherwise it'll be checked if <i>joiner</i> applied.\n     */\n    public boolean isJoinOK(Player joiner, boolean invited) {\n        if (joinlist.containsKey(joiner.getId())) {\n            JoinInfo jinfo = joinlist.get(joiner.getId());\n            // change 15000 to either a constant defined at top of\n            // file or a variable read from config\n            if (jinfo.time + 15000 > System.currentTimeMillis() && jinfo.invite == invited)\n                return true;\n        }\n        return false;\n    }\n\n    public void setJoinOK(Player joiner, boolean invited) {\n        JoinInfo jinfo = new JoinInfo(invited);\n        joinlist.put(joiner.id, jinfo);\n    }\n\n    /**\n     * Packs this player into the specified stream.\n     * @param out the stream to write this player to.\n     */\n    public void pack(DataOutputStream out) throws IOException {\n        out.writeShort(MAGIC_NO);\n        out.writeByte(id);\n        out.writeShort(strength);\n        out.writeShort(pictureid);\n        out.writeFloat(x);\n        out.writeFloat(y);\n        out.writeFloat(z);\n        out.writeUTF(name);\n    }\n\n    /**\n     * Unpack and set player data from the specified stream.\n     * @param in the stream to read data from.\n     * @return true if data was successfully unpacked.\n     */\n    public boolean unpack(DataInputStream in) {\n        Player tmp = null;\n        try {\n            /* Verify that stream really contains player data. */\n            if (in.readShort() != MAGIC_NO) {\n                System.err.println(\"Player.unpack(): *** WARNING *** \" + \"data is not of proper type!\");\n                return false;\n            }\n            /* Try unpacking the data to a temporary variable before\n\t       commiting the changes. */\n            tmp = new Player();\n            tmp.id = in.readByte();\n            tmp.strength = in.readShort();\n            tmp.pictureid = in.readShort();\n            tmp.x = in.readFloat();\n            tmp.y = in.readFloat();\n            tmp.z = in.readFloat();\n            tmp.name = in.readUTF();\n        } catch (EOFException e) {\n            System.err.println(\"Player.unpack(): *** WARNING *** [EOF] \" + \"data was incomplete: \" + e.getMessage());\n            return false;\n        } catch (IOException e) {\n            System.err.println(\"Player.unpack(): *** WARNING *** [IO] \" + \"failed to unpack data: \" + e.getMessage());\n            return false;\n        }\n        /* Apply the unpacked data. */\n        id = tmp.id;\n        name = tmp.name;\n        strength = tmp.strength;\n        pictureid = tmp.pictureid;\n        x = tmp.x;\n        y = tmp.y;\n        z = tmp.z;\n        return true;\n    }\n\n    /**\n     * Returns an unambigious byte-array representation of this\n     * object.\n     *\n     * @deprecated\n     * @return The resulting byte array.\n     */\n    public byte[] pack() {\n        try {\n            ByteArrayOutputStream buf = new ByteArrayOutputStream();\n            DataOutputStream out = new DataOutputStream(buf);\n            pack(out);\n            out.close();\n            return buf.toByteArray();\n        } catch (IOException e) {\n            System.err.println(\"Player.pack(): *** ERROR *** [IO] \" + \"pack failed! current state is \" + \"inconsistent: \" + e.getMessage());\n        }\n        return null;\n    }\n\n    /**\n     * Unpacks an array previously created with pack() and puts in\n     * this object.\n     *\n     * @deprecated\n     * @param b the byte array to be unpacked.\n     */\n    public void unpack(byte[] b) {\n        unpack(new DataInputStream(new ByteArrayInputStream(b)));\n    }\n\n    /**\n     * Returns the type of the packable.\n     * @return The resulting byte array.\n     */\n    public int type() {\n        return Packable.PLAYER;\n    }\n\n    public String toString() {\n        return name;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/state/PlayerTest1.java",
		"test_prompt": "// PlayerTest1.java\npackage state;\n\nimport java.io.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Player}.\n* It contains ten unit test cases for the {@link Player#gangStrength()} method.\n*/\nclass PlayerTest1 {"
	},
	{
		"original_code": "// Player.java\n/* $Id: Player.java,v 1.20 2004/05/05 23:45:20 njursten Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Rasmus Ahlberg <ahlbgerg@kth.se>\n * @version: $Revision: 1.20 $\n *\n */\npackage state;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * Represents a player in the game world.\n */\npublic class Player extends Party implements Packable {\n\n    /**\n     * The tolerance to decide whether a player has reached its\n     *        destination. If x or y distance to target is less than\n     *        TOLERANCE, no move in that direction is triggered.\n     */\n    public static final float TOLERANCE = 0.2f;\n\n    /**\n     * The distance to move in one step.\n     */\n    public static final float MOVE_DISTANCE = 0.1f;\n\n    /**\n     * Number to verify against when unpacking.\n     */\n    public static final short MAGIC_NO = 0x1337;\n\n    /* Strength of this player */\n    private int strength;\n\n    /* Picture of this player */\n    private int pictureid;\n\n    /* True if this player is alive */\n    private boolean alive;\n\n    /* The time when this user died. */\n    private long deathtime;\n\n    /* World coordinates of this player. */\n    private float x = 10.0f, y = 0.0f, z;\n\n    /**\n     * List to keep track of allowed joins\n     */\n    private Hashtable<Integer, JoinInfo> joinlist;\n\n    /**\n     * Size of player class when packed (not including length of name)\n     */\n    private int packsize = 10;\n\n    /**\n     * Reference to the packed data.\n     */\n    private byte[] data;\n\n    /**\n     * True if referenced data is _not_ up to date.\n     */\n    private boolean dirty;\n\n    /**\n     * Name of the player.\n     */\n    private String name;\n\n    /**\n     * False if this player has dropped from the game.\n     */\n    private boolean connected;\n\n    /**\n     * The IP of the player.\n     */\n    private String ip;\n\n    /**\n     * Amount of money the user has earned.\n     */\n    private float money;\n\n    /**\n     * Class used to keep track of when a user was invited or applied\n     * to join a group.\n     */\n    private class JoinInfo {\n\n        long time;\n\n        boolean invite;\n\n        JoinInfo(boolean invited) {\n            time = System.currentTimeMillis();\n            invite = invited;\n        }\n    }\n\n    /**\n     * Creates a new empty instance of the Player class without an\n     * id. Note that a call to GameState.player(pidFor(new Player()))\n     * will return null.\n     */\n    public Player() {\n        this(-1);\n    }\n\n    /**\n     * Creates a new player with the given id.\n     * @param id the associated id of this player.\n     */\n    public Player(int id) {\n        super(id);\n        this.strength = 1;\n        this.pictureid = 0;\n        this.alive = true;\n        this.dirty = true;\n        this.name = \"Player\" + id;\n        this.deathtime = 0;\n        this.connected = true;\n        this.ip = \"0.0.0.0\";\n        this.joinlist = new Hashtable<Integer, JoinInfo>();\n    }\n\n    public void reset(boolean newGame) {\n        this.joinlist = new Hashtable<Integer, JoinInfo>();\n        this.alive = true;\n        this.dirty = true;\n        this.deathtime = 0;\n        this.boss = null;\n        this.head = null;\n        this.next = null;\n        this.prev = null;\n        if (newGame) {\n            money = 0;\n        }\n    }\n\n    /**\n     */\n    public Player(int id, String name, int pictureid) {\n        this(id);\n        this.name = name;\n        this.pictureid = pictureid;\n        System.err.println(id + \" \" + name + \" \" + pictureid);\n    }\n\n    /**\n     */\n    public Player(int id, String ip, String name, int pictureid) {\n        this(id, name, pictureid);\n        this.ip = ip;\n    }\n\n    public Player(int id, String ip, String name, int pid, int strength) {\n        this(id, ip, name, pid);\n        this.strength = strength;\n    }\n\n    public boolean isConnected() {\n        return connected;\n    }\n\n    public void setConnected(boolean conned) {\n        connected = conned;\n    }\n\n    /**\n     * Returns the current strength of the gang this player is part of.\n     * @return the total strength of this players gang.\n     */\n    public int gangStrength() {\n        int str = 0;\n        LinkedList<Party> gang = gangBoss().getSubparty();\n        for (Party p : gang) {\n            str += ((Player) p).strength;\n        }\n        return str;\n    }\n\n    public void setDead(long deathtime, boolean alive) {\n        this.deathtime = deathtime;\n        this.alive = alive;\n    }\n\n    public void setDead() {\n        setDead(System.currentTimeMillis());\n    }\n\n    public void setDead(long deathtime) {\n        setDead(deathtime, false);\n    }\n\n    public boolean isDead() {\n        return !alive;\n    }\n\n    public long getTimeOfDeath() {\n        return deathtime;\n    }\n\n    public int getStrength() {\n        return strength;\n    }\n\n    /**\n     * Sets the amount of money this player has earned\n     */\n    public void setMoney(float money) {\n        this.money = money;\n    }\n\n    /**\n     * Returns amount of money this player has earned\n     */\n    public float getMoney() {\n        return money;\n    }\n\n    /**\n     * Returns player IP.\n     */\n    public String getIP() {\n        return ip;\n    }\n\n    /**\n     * Returns player name.\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns player picture id.\n     */\n    public int getPictureId() {\n        return pictureid;\n    }\n\n    /**\n     * Returns player x coordinate.\n     */\n    public float getX() {\n        return x;\n    }\n\n    /**\n     * Returns player y coordinate.\n     */\n    public float getY() {\n        return y;\n    }\n\n    /**\n     * Returns player z coordinate.\n     */\n    public float getZ() {\n        return z;\n    }\n\n    /**\n     * Sets player y coordinate.\n     */\n    public void setY(float f) {\n        y = f;\n    }\n\n    /**\n     * Sets player x coordinate.\n     */\n    public void setX(float f) {\n        x = f;\n    }\n\n    /**\n     * Sets player z coordinate.\n     */\n    public void setZ(float f) {\n        z = f;\n    }\n\n    /**\n     * Checks if player <i>joiner</i> is allowed to join the current player.\n     * If <i>invited</i> is set it will be checked if <i>joiner</i> was\n     * invited, otherwise it'll be checked if <i>joiner</i> applied.\n     */\n    public boolean isJoinOK(Player joiner, boolean invited) {\n        if (joinlist.containsKey(joiner.getId())) {\n            JoinInfo jinfo = joinlist.get(joiner.getId());\n            // change 15000 to either a constant defined at top of\n            // file or a variable read from config\n            if (jinfo.time + 15000 > System.currentTimeMillis() && jinfo.invite == invited)\n                return true;\n        }\n        return false;\n    }\n\n    public void setJoinOK(Player joiner, boolean invited) {\n        JoinInfo jinfo = new JoinInfo(invited);\n        joinlist.put(joiner.id, jinfo);\n    }\n\n    /**\n     * Packs this player into the specified stream.\n     * @param out the stream to write this player to.\n     */\n    public void pack(DataOutputStream out) throws IOException {\n        out.writeShort(MAGIC_NO);\n        out.writeByte(id);\n        out.writeShort(strength);\n        out.writeShort(pictureid);\n        out.writeFloat(x);\n        out.writeFloat(y);\n        out.writeFloat(z);\n        out.writeUTF(name);\n    }\n\n    /**\n     * Unpack and set player data from the specified stream.\n     * @param in the stream to read data from.\n     * @return true if data was successfully unpacked.\n     */\n    public boolean unpack(DataInputStream in) {\n        Player tmp = null;\n        try {\n            /* Verify that stream really contains player data. */\n            if (in.readShort() != MAGIC_NO) {\n                System.err.println(\"Player.unpack(): *** WARNING *** \" + \"data is not of proper type!\");\n                return false;\n            }\n            /* Try unpacking the data to a temporary variable before\n\t       commiting the changes. */\n            tmp = new Player();\n            tmp.id = in.readByte();\n            tmp.strength = in.readShort();\n            tmp.pictureid = in.readShort();\n            tmp.x = in.readFloat();\n            tmp.y = in.readFloat();\n            tmp.z = in.readFloat();\n            tmp.name = in.readUTF();\n        } catch (EOFException e) {\n            System.err.println(\"Player.unpack(): *** WARNING *** [EOF] \" + \"data was incomplete: \" + e.getMessage());\n            return false;\n        } catch (IOException e) {\n            System.err.println(\"Player.unpack(): *** WARNING *** [IO] \" + \"failed to unpack data: \" + e.getMessage());\n            return false;\n        }\n        /* Apply the unpacked data. */\n        id = tmp.id;\n        name = tmp.name;\n        strength = tmp.strength;\n        pictureid = tmp.pictureid;\n        x = tmp.x;\n        y = tmp.y;\n        z = tmp.z;\n        return true;\n    }\n\n    /**\n     * Returns an unambigious byte-array representation of this\n     * object.\n     *\n     * @deprecated\n     * @return The resulting byte array.\n     */\n    public byte[] pack() {\n        try {\n            ByteArrayOutputStream buf = new ByteArrayOutputStream();\n            DataOutputStream out = new DataOutputStream(buf);\n            pack(out);\n            out.close();\n            return buf.toByteArray();\n        } catch (IOException e) {\n            System.err.println(\"Player.pack(): *** ERROR *** [IO] \" + \"pack failed! current state is \" + \"inconsistent: \" + e.getMessage());\n        }\n        return null;\n    }\n\n    /**\n     * Unpacks an array previously created with pack() and puts in\n     * this object.\n     *\n     * @deprecated\n     * @param b the byte array to be unpacked.\n     */\n    public void unpack(byte[] b) {\n        unpack(new DataInputStream(new ByteArrayInputStream(b)));\n    }\n\n    /**\n     * Returns the type of the packable.\n     * @return The resulting byte array.\n     */\n    public int type() {\n        return Packable.PLAYER;\n    }\n\n    public String toString() {\n        return name;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/state/PlayerTest2.java",
		"test_prompt": "// PlayerTest2.java\npackage state;\n\nimport java.io.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Player}.\n* It contains ten unit test cases for the {@link Player#isDead()} method.\n*/\nclass PlayerTest2 {"
	},
	{
		"original_code": "// Player.java\n/* $Id: Player.java,v 1.20 2004/05/05 23:45:20 njursten Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Rasmus Ahlberg <ahlbgerg@kth.se>\n * @version: $Revision: 1.20 $\n *\n */\npackage state;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * Represents a player in the game world.\n */\npublic class Player extends Party implements Packable {\n\n    /**\n     * The tolerance to decide whether a player has reached its\n     *        destination. If x or y distance to target is less than\n     *        TOLERANCE, no move in that direction is triggered.\n     */\n    public static final float TOLERANCE = 0.2f;\n\n    /**\n     * The distance to move in one step.\n     */\n    public static final float MOVE_DISTANCE = 0.1f;\n\n    /**\n     * Number to verify against when unpacking.\n     */\n    public static final short MAGIC_NO = 0x1337;\n\n    /* Strength of this player */\n    private int strength;\n\n    /* Picture of this player */\n    private int pictureid;\n\n    /* True if this player is alive */\n    private boolean alive;\n\n    /* The time when this user died. */\n    private long deathtime;\n\n    /* World coordinates of this player. */\n    private float x = 10.0f, y = 0.0f, z;\n\n    /**\n     * List to keep track of allowed joins\n     */\n    private Hashtable<Integer, JoinInfo> joinlist;\n\n    /**\n     * Size of player class when packed (not including length of name)\n     */\n    private int packsize = 10;\n\n    /**\n     * Reference to the packed data.\n     */\n    private byte[] data;\n\n    /**\n     * True if referenced data is _not_ up to date.\n     */\n    private boolean dirty;\n\n    /**\n     * Name of the player.\n     */\n    private String name;\n\n    /**\n     * False if this player has dropped from the game.\n     */\n    private boolean connected;\n\n    /**\n     * The IP of the player.\n     */\n    private String ip;\n\n    /**\n     * Amount of money the user has earned.\n     */\n    private float money;\n\n    /**\n     * Class used to keep track of when a user was invited or applied\n     * to join a group.\n     */\n    private class JoinInfo {\n\n        long time;\n\n        boolean invite;\n\n        JoinInfo(boolean invited) {\n            time = System.currentTimeMillis();\n            invite = invited;\n        }\n    }\n\n    /**\n     * Creates a new empty instance of the Player class without an\n     * id. Note that a call to GameState.player(pidFor(new Player()))\n     * will return null.\n     */\n    public Player() {\n        this(-1);\n    }\n\n    /**\n     * Creates a new player with the given id.\n     * @param id the associated id of this player.\n     */\n    public Player(int id) {\n        super(id);\n        this.strength = 1;\n        this.pictureid = 0;\n        this.alive = true;\n        this.dirty = true;\n        this.name = \"Player\" + id;\n        this.deathtime = 0;\n        this.connected = true;\n        this.ip = \"0.0.0.0\";\n        this.joinlist = new Hashtable<Integer, JoinInfo>();\n    }\n\n    public void reset(boolean newGame) {\n        this.joinlist = new Hashtable<Integer, JoinInfo>();\n        this.alive = true;\n        this.dirty = true;\n        this.deathtime = 0;\n        this.boss = null;\n        this.head = null;\n        this.next = null;\n        this.prev = null;\n        if (newGame) {\n            money = 0;\n        }\n    }\n\n    /**\n     */\n    public Player(int id, String name, int pictureid) {\n        this(id);\n        this.name = name;\n        this.pictureid = pictureid;\n        System.err.println(id + \" \" + name + \" \" + pictureid);\n    }\n\n    /**\n     */\n    public Player(int id, String ip, String name, int pictureid) {\n        this(id, name, pictureid);\n        this.ip = ip;\n    }\n\n    public Player(int id, String ip, String name, int pid, int strength) {\n        this(id, ip, name, pid);\n        this.strength = strength;\n    }\n\n    public boolean isConnected() {\n        return connected;\n    }\n\n    public void setConnected(boolean conned) {\n        connected = conned;\n    }\n\n    /**\n     * Returns the current strength of the gang this player is part of.\n     * @return the total strength of this players gang.\n     */\n    public int gangStrength() {\n        int str = 0;\n        LinkedList<Party> gang = gangBoss().getSubparty();\n        for (Party p : gang) {\n            str += ((Player) p).strength;\n        }\n        return str;\n    }\n\n    public void setDead(long deathtime, boolean alive) {\n        this.deathtime = deathtime;\n        this.alive = alive;\n    }\n\n    public void setDead() {\n        setDead(System.currentTimeMillis());\n    }\n\n    public void setDead(long deathtime) {\n        setDead(deathtime, false);\n    }\n\n    public boolean isDead() {\n        return !alive;\n    }\n\n    public long getTimeOfDeath() {\n        return deathtime;\n    }\n\n    public int getStrength() {\n        return strength;\n    }\n\n    /**\n     * Sets the amount of money this player has earned\n     */\n    public void setMoney(float money) {\n        this.money = money;\n    }\n\n    /**\n     * Returns amount of money this player has earned\n     */\n    public float getMoney() {\n        return money;\n    }\n\n    /**\n     * Returns player IP.\n     */\n    public String getIP() {\n        return ip;\n    }\n\n    /**\n     * Returns player name.\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns player picture id.\n     */\n    public int getPictureId() {\n        return pictureid;\n    }\n\n    /**\n     * Returns player x coordinate.\n     */\n    public float getX() {\n        return x;\n    }\n\n    /**\n     * Returns player y coordinate.\n     */\n    public float getY() {\n        return y;\n    }\n\n    /**\n     * Returns player z coordinate.\n     */\n    public float getZ() {\n        return z;\n    }\n\n    /**\n     * Sets player y coordinate.\n     */\n    public void setY(float f) {\n        y = f;\n    }\n\n    /**\n     * Sets player x coordinate.\n     */\n    public void setX(float f) {\n        x = f;\n    }\n\n    /**\n     * Sets player z coordinate.\n     */\n    public void setZ(float f) {\n        z = f;\n    }\n\n    /**\n     * Checks if player <i>joiner</i> is allowed to join the current player.\n     * If <i>invited</i> is set it will be checked if <i>joiner</i> was\n     * invited, otherwise it'll be checked if <i>joiner</i> applied.\n     */\n    public boolean isJoinOK(Player joiner, boolean invited) {\n        if (joinlist.containsKey(joiner.getId())) {\n            JoinInfo jinfo = joinlist.get(joiner.getId());\n            // change 15000 to either a constant defined at top of\n            // file or a variable read from config\n            if (jinfo.time + 15000 > System.currentTimeMillis() && jinfo.invite == invited)\n                return true;\n        }\n        return false;\n    }\n\n    public void setJoinOK(Player joiner, boolean invited) {\n        JoinInfo jinfo = new JoinInfo(invited);\n        joinlist.put(joiner.id, jinfo);\n    }\n\n    /**\n     * Packs this player into the specified stream.\n     * @param out the stream to write this player to.\n     */\n    public void pack(DataOutputStream out) throws IOException {\n        out.writeShort(MAGIC_NO);\n        out.writeByte(id);\n        out.writeShort(strength);\n        out.writeShort(pictureid);\n        out.writeFloat(x);\n        out.writeFloat(y);\n        out.writeFloat(z);\n        out.writeUTF(name);\n    }\n\n    /**\n     * Unpack and set player data from the specified stream.\n     * @param in the stream to read data from.\n     * @return true if data was successfully unpacked.\n     */\n    public boolean unpack(DataInputStream in) {\n        Player tmp = null;\n        try {\n            /* Verify that stream really contains player data. */\n            if (in.readShort() != MAGIC_NO) {\n                System.err.println(\"Player.unpack(): *** WARNING *** \" + \"data is not of proper type!\");\n                return false;\n            }\n            /* Try unpacking the data to a temporary variable before\n\t       commiting the changes. */\n            tmp = new Player();\n            tmp.id = in.readByte();\n            tmp.strength = in.readShort();\n            tmp.pictureid = in.readShort();\n            tmp.x = in.readFloat();\n            tmp.y = in.readFloat();\n            tmp.z = in.readFloat();\n            tmp.name = in.readUTF();\n        } catch (EOFException e) {\n            System.err.println(\"Player.unpack(): *** WARNING *** [EOF] \" + \"data was incomplete: \" + e.getMessage());\n            return false;\n        } catch (IOException e) {\n            System.err.println(\"Player.unpack(): *** WARNING *** [IO] \" + \"failed to unpack data: \" + e.getMessage());\n            return false;\n        }\n        /* Apply the unpacked data. */\n        id = tmp.id;\n        name = tmp.name;\n        strength = tmp.strength;\n        pictureid = tmp.pictureid;\n        x = tmp.x;\n        y = tmp.y;\n        z = tmp.z;\n        return true;\n    }\n\n    /**\n     * Returns an unambigious byte-array representation of this\n     * object.\n     *\n     * @deprecated\n     * @return The resulting byte array.\n     */\n    public byte[] pack() {\n        try {\n            ByteArrayOutputStream buf = new ByteArrayOutputStream();\n            DataOutputStream out = new DataOutputStream(buf);\n            pack(out);\n            out.close();\n            return buf.toByteArray();\n        } catch (IOException e) {\n            System.err.println(\"Player.pack(): *** ERROR *** [IO] \" + \"pack failed! current state is \" + \"inconsistent: \" + e.getMessage());\n        }\n        return null;\n    }\n\n    /**\n     * Unpacks an array previously created with pack() and puts in\n     * this object.\n     *\n     * @deprecated\n     * @param b the byte array to be unpacked.\n     */\n    public void unpack(byte[] b) {\n        unpack(new DataInputStream(new ByteArrayInputStream(b)));\n    }\n\n    /**\n     * Returns the type of the packable.\n     * @return The resulting byte array.\n     */\n    public int type() {\n        return Packable.PLAYER;\n    }\n\n    public String toString() {\n        return name;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/state/PlayerTest3.java",
		"test_prompt": "// PlayerTest3.java\npackage state;\n\nimport java.io.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Player}.\n* It contains ten unit test cases for the {@link Player#isJoinOK(Player, boolean)} method.\n*/\nclass PlayerTest3 {"
	},
	{
		"original_code": "// Player.java\n/* $Id: Player.java,v 1.20 2004/05/05 23:45:20 njursten Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Rasmus Ahlberg <ahlbgerg@kth.se>\n * @version: $Revision: 1.20 $\n *\n */\npackage state;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * Represents a player in the game world.\n */\npublic class Player extends Party implements Packable {\n\n    /**\n     * The tolerance to decide whether a player has reached its\n     *        destination. If x or y distance to target is less than\n     *        TOLERANCE, no move in that direction is triggered.\n     */\n    public static final float TOLERANCE = 0.2f;\n\n    /**\n     * The distance to move in one step.\n     */\n    public static final float MOVE_DISTANCE = 0.1f;\n\n    /**\n     * Number to verify against when unpacking.\n     */\n    public static final short MAGIC_NO = 0x1337;\n\n    /* Strength of this player */\n    private int strength;\n\n    /* Picture of this player */\n    private int pictureid;\n\n    /* True if this player is alive */\n    private boolean alive;\n\n    /* The time when this user died. */\n    private long deathtime;\n\n    /* World coordinates of this player. */\n    private float x = 10.0f, y = 0.0f, z;\n\n    /**\n     * List to keep track of allowed joins\n     */\n    private Hashtable<Integer, JoinInfo> joinlist;\n\n    /**\n     * Size of player class when packed (not including length of name)\n     */\n    private int packsize = 10;\n\n    /**\n     * Reference to the packed data.\n     */\n    private byte[] data;\n\n    /**\n     * True if referenced data is _not_ up to date.\n     */\n    private boolean dirty;\n\n    /**\n     * Name of the player.\n     */\n    private String name;\n\n    /**\n     * False if this player has dropped from the game.\n     */\n    private boolean connected;\n\n    /**\n     * The IP of the player.\n     */\n    private String ip;\n\n    /**\n     * Amount of money the user has earned.\n     */\n    private float money;\n\n    /**\n     * Class used to keep track of when a user was invited or applied\n     * to join a group.\n     */\n    private class JoinInfo {\n\n        long time;\n\n        boolean invite;\n\n        JoinInfo(boolean invited) {\n            time = System.currentTimeMillis();\n            invite = invited;\n        }\n    }\n\n    /**\n     * Creates a new empty instance of the Player class without an\n     * id. Note that a call to GameState.player(pidFor(new Player()))\n     * will return null.\n     */\n    public Player() {\n        this(-1);\n    }\n\n    /**\n     * Creates a new player with the given id.\n     * @param id the associated id of this player.\n     */\n    public Player(int id) {\n        super(id);\n        this.strength = 1;\n        this.pictureid = 0;\n        this.alive = true;\n        this.dirty = true;\n        this.name = \"Player\" + id;\n        this.deathtime = 0;\n        this.connected = true;\n        this.ip = \"0.0.0.0\";\n        this.joinlist = new Hashtable<Integer, JoinInfo>();\n    }\n\n    public void reset(boolean newGame) {\n        this.joinlist = new Hashtable<Integer, JoinInfo>();\n        this.alive = true;\n        this.dirty = true;\n        this.deathtime = 0;\n        this.boss = null;\n        this.head = null;\n        this.next = null;\n        this.prev = null;\n        if (newGame) {\n            money = 0;\n        }\n    }\n\n    /**\n     */\n    public Player(int id, String name, int pictureid) {\n        this(id);\n        this.name = name;\n        this.pictureid = pictureid;\n        System.err.println(id + \" \" + name + \" \" + pictureid);\n    }\n\n    /**\n     */\n    public Player(int id, String ip, String name, int pictureid) {\n        this(id, name, pictureid);\n        this.ip = ip;\n    }\n\n    public Player(int id, String ip, String name, int pid, int strength) {\n        this(id, ip, name, pid);\n        this.strength = strength;\n    }\n\n    public boolean isConnected() {\n        return connected;\n    }\n\n    public void setConnected(boolean conned) {\n        connected = conned;\n    }\n\n    /**\n     * Returns the current strength of the gang this player is part of.\n     * @return the total strength of this players gang.\n     */\n    public int gangStrength() {\n        int str = 0;\n        LinkedList<Party> gang = gangBoss().getSubparty();\n        for (Party p : gang) {\n            str += ((Player) p).strength;\n        }\n        return str;\n    }\n\n    public void setDead(long deathtime, boolean alive) {\n        this.deathtime = deathtime;\n        this.alive = alive;\n    }\n\n    public void setDead() {\n        setDead(System.currentTimeMillis());\n    }\n\n    public void setDead(long deathtime) {\n        setDead(deathtime, false);\n    }\n\n    public boolean isDead() {\n        return !alive;\n    }\n\n    public long getTimeOfDeath() {\n        return deathtime;\n    }\n\n    public int getStrength() {\n        return strength;\n    }\n\n    /**\n     * Sets the amount of money this player has earned\n     */\n    public void setMoney(float money) {\n        this.money = money;\n    }\n\n    /**\n     * Returns amount of money this player has earned\n     */\n    public float getMoney() {\n        return money;\n    }\n\n    /**\n     * Returns player IP.\n     */\n    public String getIP() {\n        return ip;\n    }\n\n    /**\n     * Returns player name.\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns player picture id.\n     */\n    public int getPictureId() {\n        return pictureid;\n    }\n\n    /**\n     * Returns player x coordinate.\n     */\n    public float getX() {\n        return x;\n    }\n\n    /**\n     * Returns player y coordinate.\n     */\n    public float getY() {\n        return y;\n    }\n\n    /**\n     * Returns player z coordinate.\n     */\n    public float getZ() {\n        return z;\n    }\n\n    /**\n     * Sets player y coordinate.\n     */\n    public void setY(float f) {\n        y = f;\n    }\n\n    /**\n     * Sets player x coordinate.\n     */\n    public void setX(float f) {\n        x = f;\n    }\n\n    /**\n     * Sets player z coordinate.\n     */\n    public void setZ(float f) {\n        z = f;\n    }\n\n    /**\n     * Checks if player <i>joiner</i> is allowed to join the current player.\n     * If <i>invited</i> is set it will be checked if <i>joiner</i> was\n     * invited, otherwise it'll be checked if <i>joiner</i> applied.\n     */\n    public boolean isJoinOK(Player joiner, boolean invited) {\n        if (joinlist.containsKey(joiner.getId())) {\n            JoinInfo jinfo = joinlist.get(joiner.getId());\n            // change 15000 to either a constant defined at top of\n            // file or a variable read from config\n            if (jinfo.time + 15000 > System.currentTimeMillis() && jinfo.invite == invited)\n                return true;\n        }\n        return false;\n    }\n\n    public void setJoinOK(Player joiner, boolean invited) {\n        JoinInfo jinfo = new JoinInfo(invited);\n        joinlist.put(joiner.id, jinfo);\n    }\n\n    /**\n     * Packs this player into the specified stream.\n     * @param out the stream to write this player to.\n     */\n    public void pack(DataOutputStream out) throws IOException {\n        out.writeShort(MAGIC_NO);\n        out.writeByte(id);\n        out.writeShort(strength);\n        out.writeShort(pictureid);\n        out.writeFloat(x);\n        out.writeFloat(y);\n        out.writeFloat(z);\n        out.writeUTF(name);\n    }\n\n    /**\n     * Unpack and set player data from the specified stream.\n     * @param in the stream to read data from.\n     * @return true if data was successfully unpacked.\n     */\n    public boolean unpack(DataInputStream in) {\n        Player tmp = null;\n        try {\n            /* Verify that stream really contains player data. */\n            if (in.readShort() != MAGIC_NO) {\n                System.err.println(\"Player.unpack(): *** WARNING *** \" + \"data is not of proper type!\");\n                return false;\n            }\n            /* Try unpacking the data to a temporary variable before\n\t       commiting the changes. */\n            tmp = new Player();\n            tmp.id = in.readByte();\n            tmp.strength = in.readShort();\n            tmp.pictureid = in.readShort();\n            tmp.x = in.readFloat();\n            tmp.y = in.readFloat();\n            tmp.z = in.readFloat();\n            tmp.name = in.readUTF();\n        } catch (EOFException e) {\n            System.err.println(\"Player.unpack(): *** WARNING *** [EOF] \" + \"data was incomplete: \" + e.getMessage());\n            return false;\n        } catch (IOException e) {\n            System.err.println(\"Player.unpack(): *** WARNING *** [IO] \" + \"failed to unpack data: \" + e.getMessage());\n            return false;\n        }\n        /* Apply the unpacked data. */\n        id = tmp.id;\n        name = tmp.name;\n        strength = tmp.strength;\n        pictureid = tmp.pictureid;\n        x = tmp.x;\n        y = tmp.y;\n        z = tmp.z;\n        return true;\n    }\n\n    /**\n     * Returns an unambigious byte-array representation of this\n     * object.\n     *\n     * @deprecated\n     * @return The resulting byte array.\n     */\n    public byte[] pack() {\n        try {\n            ByteArrayOutputStream buf = new ByteArrayOutputStream();\n            DataOutputStream out = new DataOutputStream(buf);\n            pack(out);\n            out.close();\n            return buf.toByteArray();\n        } catch (IOException e) {\n            System.err.println(\"Player.pack(): *** ERROR *** [IO] \" + \"pack failed! current state is \" + \"inconsistent: \" + e.getMessage());\n        }\n        return null;\n    }\n\n    /**\n     * Unpacks an array previously created with pack() and puts in\n     * this object.\n     *\n     * @deprecated\n     * @param b the byte array to be unpacked.\n     */\n    public void unpack(byte[] b) {\n        unpack(new DataInputStream(new ByteArrayInputStream(b)));\n    }\n\n    /**\n     * Returns the type of the packable.\n     * @return The resulting byte array.\n     */\n    public int type() {\n        return Packable.PLAYER;\n    }\n\n    public String toString() {\n        return name;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/state/PlayerTest4.java",
		"test_prompt": "// PlayerTest4.java\npackage state;\n\nimport java.io.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Player}.\n* It contains ten unit test cases for the {@link Player#unpack(DataInputStream)} method.\n*/\nclass PlayerTest4 {"
	},
	{
		"original_code": "// Player.java\n/* $Id: Player.java,v 1.20 2004/05/05 23:45:20 njursten Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Rasmus Ahlberg <ahlbgerg@kth.se>\n * @version: $Revision: 1.20 $\n *\n */\npackage state;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * Represents a player in the game world.\n */\npublic class Player extends Party implements Packable {\n\n    /**\n     * The tolerance to decide whether a player has reached its\n     *        destination. If x or y distance to target is less than\n     *        TOLERANCE, no move in that direction is triggered.\n     */\n    public static final float TOLERANCE = 0.2f;\n\n    /**\n     * The distance to move in one step.\n     */\n    public static final float MOVE_DISTANCE = 0.1f;\n\n    /**\n     * Number to verify against when unpacking.\n     */\n    public static final short MAGIC_NO = 0x1337;\n\n    /* Strength of this player */\n    private int strength;\n\n    /* Picture of this player */\n    private int pictureid;\n\n    /* True if this player is alive */\n    private boolean alive;\n\n    /* The time when this user died. */\n    private long deathtime;\n\n    /* World coordinates of this player. */\n    private float x = 10.0f, y = 0.0f, z;\n\n    /**\n     * List to keep track of allowed joins\n     */\n    private Hashtable<Integer, JoinInfo> joinlist;\n\n    /**\n     * Size of player class when packed (not including length of name)\n     */\n    private int packsize = 10;\n\n    /**\n     * Reference to the packed data.\n     */\n    private byte[] data;\n\n    /**\n     * True if referenced data is _not_ up to date.\n     */\n    private boolean dirty;\n\n    /**\n     * Name of the player.\n     */\n    private String name;\n\n    /**\n     * False if this player has dropped from the game.\n     */\n    private boolean connected;\n\n    /**\n     * The IP of the player.\n     */\n    private String ip;\n\n    /**\n     * Amount of money the user has earned.\n     */\n    private float money;\n\n    /**\n     * Class used to keep track of when a user was invited or applied\n     * to join a group.\n     */\n    private class JoinInfo {\n\n        long time;\n\n        boolean invite;\n\n        JoinInfo(boolean invited) {\n            time = System.currentTimeMillis();\n            invite = invited;\n        }\n    }\n\n    /**\n     * Creates a new empty instance of the Player class without an\n     * id. Note that a call to GameState.player(pidFor(new Player()))\n     * will return null.\n     */\n    public Player() {\n        this(-1);\n    }\n\n    /**\n     * Creates a new player with the given id.\n     * @param id the associated id of this player.\n     */\n    public Player(int id) {\n        super(id);\n        this.strength = 1;\n        this.pictureid = 0;\n        this.alive = true;\n        this.dirty = true;\n        this.name = \"Player\" + id;\n        this.deathtime = 0;\n        this.connected = true;\n        this.ip = \"0.0.0.0\";\n        this.joinlist = new Hashtable<Integer, JoinInfo>();\n    }\n\n    public void reset(boolean newGame) {\n        this.joinlist = new Hashtable<Integer, JoinInfo>();\n        this.alive = true;\n        this.dirty = true;\n        this.deathtime = 0;\n        this.boss = null;\n        this.head = null;\n        this.next = null;\n        this.prev = null;\n        if (newGame) {\n            money = 0;\n        }\n    }\n\n    /**\n     */\n    public Player(int id, String name, int pictureid) {\n        this(id);\n        this.name = name;\n        this.pictureid = pictureid;\n        System.err.println(id + \" \" + name + \" \" + pictureid);\n    }\n\n    /**\n     */\n    public Player(int id, String ip, String name, int pictureid) {\n        this(id, name, pictureid);\n        this.ip = ip;\n    }\n\n    public Player(int id, String ip, String name, int pid, int strength) {\n        this(id, ip, name, pid);\n        this.strength = strength;\n    }\n\n    public boolean isConnected() {\n        return connected;\n    }\n\n    public void setConnected(boolean conned) {\n        connected = conned;\n    }\n\n    /**\n     * Returns the current strength of the gang this player is part of.\n     * @return the total strength of this players gang.\n     */\n    public int gangStrength() {\n        int str = 0;\n        LinkedList<Party> gang = gangBoss().getSubparty();\n        for (Party p : gang) {\n            str += ((Player) p).strength;\n        }\n        return str;\n    }\n\n    public void setDead(long deathtime, boolean alive) {\n        this.deathtime = deathtime;\n        this.alive = alive;\n    }\n\n    public void setDead() {\n        setDead(System.currentTimeMillis());\n    }\n\n    public void setDead(long deathtime) {\n        setDead(deathtime, false);\n    }\n\n    public boolean isDead() {\n        return !alive;\n    }\n\n    public long getTimeOfDeath() {\n        return deathtime;\n    }\n\n    public int getStrength() {\n        return strength;\n    }\n\n    /**\n     * Sets the amount of money this player has earned\n     */\n    public void setMoney(float money) {\n        this.money = money;\n    }\n\n    /**\n     * Returns amount of money this player has earned\n     */\n    public float getMoney() {\n        return money;\n    }\n\n    /**\n     * Returns player IP.\n     */\n    public String getIP() {\n        return ip;\n    }\n\n    /**\n     * Returns player name.\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns player picture id.\n     */\n    public int getPictureId() {\n        return pictureid;\n    }\n\n    /**\n     * Returns player x coordinate.\n     */\n    public float getX() {\n        return x;\n    }\n\n    /**\n     * Returns player y coordinate.\n     */\n    public float getY() {\n        return y;\n    }\n\n    /**\n     * Returns player z coordinate.\n     */\n    public float getZ() {\n        return z;\n    }\n\n    /**\n     * Sets player y coordinate.\n     */\n    public void setY(float f) {\n        y = f;\n    }\n\n    /**\n     * Sets player x coordinate.\n     */\n    public void setX(float f) {\n        x = f;\n    }\n\n    /**\n     * Sets player z coordinate.\n     */\n    public void setZ(float f) {\n        z = f;\n    }\n\n    /**\n     * Checks if player <i>joiner</i> is allowed to join the current player.\n     * If <i>invited</i> is set it will be checked if <i>joiner</i> was\n     * invited, otherwise it'll be checked if <i>joiner</i> applied.\n     */\n    public boolean isJoinOK(Player joiner, boolean invited) {\n        if (joinlist.containsKey(joiner.getId())) {\n            JoinInfo jinfo = joinlist.get(joiner.getId());\n            // change 15000 to either a constant defined at top of\n            // file or a variable read from config\n            if (jinfo.time + 15000 > System.currentTimeMillis() && jinfo.invite == invited)\n                return true;\n        }\n        return false;\n    }\n\n    public void setJoinOK(Player joiner, boolean invited) {\n        JoinInfo jinfo = new JoinInfo(invited);\n        joinlist.put(joiner.id, jinfo);\n    }\n\n    /**\n     * Packs this player into the specified stream.\n     * @param out the stream to write this player to.\n     */\n    public void pack(DataOutputStream out) throws IOException {\n        out.writeShort(MAGIC_NO);\n        out.writeByte(id);\n        out.writeShort(strength);\n        out.writeShort(pictureid);\n        out.writeFloat(x);\n        out.writeFloat(y);\n        out.writeFloat(z);\n        out.writeUTF(name);\n    }\n\n    /**\n     * Unpack and set player data from the specified stream.\n     * @param in the stream to read data from.\n     * @return true if data was successfully unpacked.\n     */\n    public boolean unpack(DataInputStream in) {\n        Player tmp = null;\n        try {\n            /* Verify that stream really contains player data. */\n            if (in.readShort() != MAGIC_NO) {\n                System.err.println(\"Player.unpack(): *** WARNING *** \" + \"data is not of proper type!\");\n                return false;\n            }\n            /* Try unpacking the data to a temporary variable before\n\t       commiting the changes. */\n            tmp = new Player();\n            tmp.id = in.readByte();\n            tmp.strength = in.readShort();\n            tmp.pictureid = in.readShort();\n            tmp.x = in.readFloat();\n            tmp.y = in.readFloat();\n            tmp.z = in.readFloat();\n            tmp.name = in.readUTF();\n        } catch (EOFException e) {\n            System.err.println(\"Player.unpack(): *** WARNING *** [EOF] \" + \"data was incomplete: \" + e.getMessage());\n            return false;\n        } catch (IOException e) {\n            System.err.println(\"Player.unpack(): *** WARNING *** [IO] \" + \"failed to unpack data: \" + e.getMessage());\n            return false;\n        }\n        /* Apply the unpacked data. */\n        id = tmp.id;\n        name = tmp.name;\n        strength = tmp.strength;\n        pictureid = tmp.pictureid;\n        x = tmp.x;\n        y = tmp.y;\n        z = tmp.z;\n        return true;\n    }\n\n    /**\n     * Returns an unambigious byte-array representation of this\n     * object.\n     *\n     * @deprecated\n     * @return The resulting byte array.\n     */\n    public byte[] pack() {\n        try {\n            ByteArrayOutputStream buf = new ByteArrayOutputStream();\n            DataOutputStream out = new DataOutputStream(buf);\n            pack(out);\n            out.close();\n            return buf.toByteArray();\n        } catch (IOException e) {\n            System.err.println(\"Player.pack(): *** ERROR *** [IO] \" + \"pack failed! current state is \" + \"inconsistent: \" + e.getMessage());\n        }\n        return null;\n    }\n\n    /**\n     * Unpacks an array previously created with pack() and puts in\n     * this object.\n     *\n     * @deprecated\n     * @param b the byte array to be unpacked.\n     */\n    public void unpack(byte[] b) {\n        unpack(new DataInputStream(new ByteArrayInputStream(b)));\n    }\n\n    /**\n     * Returns the type of the packable.\n     * @return The resulting byte array.\n     */\n    public int type() {\n        return Packable.PLAYER;\n    }\n\n    public String toString() {\n        return name;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/state/PlayerTest5.java",
		"test_prompt": "// PlayerTest5.java\npackage state;\n\nimport java.io.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Player}.\n* It contains ten unit test cases for the {@link Player#pack()} method.\n*/\nclass PlayerTest5 {"
	},
	{
		"original_code": "// Player.java\n/* $Id: Player.java,v 1.20 2004/05/05 23:45:20 njursten Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Rasmus Ahlberg <ahlbgerg@kth.se>\n * @version: $Revision: 1.20 $\n *\n */\npackage state;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * Represents a player in the game world.\n */\npublic class Player extends Party implements Packable {\n\n    /**\n     * The tolerance to decide whether a player has reached its\n     *        destination. If x or y distance to target is less than\n     *        TOLERANCE, no move in that direction is triggered.\n     */\n    public static final float TOLERANCE = 0.2f;\n\n    /**\n     * The distance to move in one step.\n     */\n    public static final float MOVE_DISTANCE = 0.1f;\n\n    /**\n     * Number to verify against when unpacking.\n     */\n    public static final short MAGIC_NO = 0x1337;\n\n    /* Strength of this player */\n    private int strength;\n\n    /* Picture of this player */\n    private int pictureid;\n\n    /* True if this player is alive */\n    private boolean alive;\n\n    /* The time when this user died. */\n    private long deathtime;\n\n    /* World coordinates of this player. */\n    private float x = 10.0f, y = 0.0f, z;\n\n    /**\n     * List to keep track of allowed joins\n     */\n    private Hashtable<Integer, JoinInfo> joinlist;\n\n    /**\n     * Size of player class when packed (not including length of name)\n     */\n    private int packsize = 10;\n\n    /**\n     * Reference to the packed data.\n     */\n    private byte[] data;\n\n    /**\n     * True if referenced data is _not_ up to date.\n     */\n    private boolean dirty;\n\n    /**\n     * Name of the player.\n     */\n    private String name;\n\n    /**\n     * False if this player has dropped from the game.\n     */\n    private boolean connected;\n\n    /**\n     * The IP of the player.\n     */\n    private String ip;\n\n    /**\n     * Amount of money the user has earned.\n     */\n    private float money;\n\n    /**\n     * Class used to keep track of when a user was invited or applied\n     * to join a group.\n     */\n    private class JoinInfo {\n\n        long time;\n\n        boolean invite;\n\n        JoinInfo(boolean invited) {\n            time = System.currentTimeMillis();\n            invite = invited;\n        }\n    }\n\n    /**\n     * Creates a new empty instance of the Player class without an\n     * id. Note that a call to GameState.player(pidFor(new Player()))\n     * will return null.\n     */\n    public Player() {\n        this(-1);\n    }\n\n    /**\n     * Creates a new player with the given id.\n     * @param id the associated id of this player.\n     */\n    public Player(int id) {\n        super(id);\n        this.strength = 1;\n        this.pictureid = 0;\n        this.alive = true;\n        this.dirty = true;\n        this.name = \"Player\" + id;\n        this.deathtime = 0;\n        this.connected = true;\n        this.ip = \"0.0.0.0\";\n        this.joinlist = new Hashtable<Integer, JoinInfo>();\n    }\n\n    public void reset(boolean newGame) {\n        this.joinlist = new Hashtable<Integer, JoinInfo>();\n        this.alive = true;\n        this.dirty = true;\n        this.deathtime = 0;\n        this.boss = null;\n        this.head = null;\n        this.next = null;\n        this.prev = null;\n        if (newGame) {\n            money = 0;\n        }\n    }\n\n    /**\n     */\n    public Player(int id, String name, int pictureid) {\n        this(id);\n        this.name = name;\n        this.pictureid = pictureid;\n        System.err.println(id + \" \" + name + \" \" + pictureid);\n    }\n\n    /**\n     */\n    public Player(int id, String ip, String name, int pictureid) {\n        this(id, name, pictureid);\n        this.ip = ip;\n    }\n\n    public Player(int id, String ip, String name, int pid, int strength) {\n        this(id, ip, name, pid);\n        this.strength = strength;\n    }\n\n    public boolean isConnected() {\n        return connected;\n    }\n\n    public void setConnected(boolean conned) {\n        connected = conned;\n    }\n\n    /**\n     * Returns the current strength of the gang this player is part of.\n     * @return the total strength of this players gang.\n     */\n    public int gangStrength() {\n        int str = 0;\n        LinkedList<Party> gang = gangBoss().getSubparty();\n        for (Party p : gang) {\n            str += ((Player) p).strength;\n        }\n        return str;\n    }\n\n    public void setDead(long deathtime, boolean alive) {\n        this.deathtime = deathtime;\n        this.alive = alive;\n    }\n\n    public void setDead() {\n        setDead(System.currentTimeMillis());\n    }\n\n    public void setDead(long deathtime) {\n        setDead(deathtime, false);\n    }\n\n    public boolean isDead() {\n        return !alive;\n    }\n\n    public long getTimeOfDeath() {\n        return deathtime;\n    }\n\n    public int getStrength() {\n        return strength;\n    }\n\n    /**\n     * Sets the amount of money this player has earned\n     */\n    public void setMoney(float money) {\n        this.money = money;\n    }\n\n    /**\n     * Returns amount of money this player has earned\n     */\n    public float getMoney() {\n        return money;\n    }\n\n    /**\n     * Returns player IP.\n     */\n    public String getIP() {\n        return ip;\n    }\n\n    /**\n     * Returns player name.\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns player picture id.\n     */\n    public int getPictureId() {\n        return pictureid;\n    }\n\n    /**\n     * Returns player x coordinate.\n     */\n    public float getX() {\n        return x;\n    }\n\n    /**\n     * Returns player y coordinate.\n     */\n    public float getY() {\n        return y;\n    }\n\n    /**\n     * Returns player z coordinate.\n     */\n    public float getZ() {\n        return z;\n    }\n\n    /**\n     * Sets player y coordinate.\n     */\n    public void setY(float f) {\n        y = f;\n    }\n\n    /**\n     * Sets player x coordinate.\n     */\n    public void setX(float f) {\n        x = f;\n    }\n\n    /**\n     * Sets player z coordinate.\n     */\n    public void setZ(float f) {\n        z = f;\n    }\n\n    /**\n     * Checks if player <i>joiner</i> is allowed to join the current player.\n     * If <i>invited</i> is set it will be checked if <i>joiner</i> was\n     * invited, otherwise it'll be checked if <i>joiner</i> applied.\n     */\n    public boolean isJoinOK(Player joiner, boolean invited) {\n        if (joinlist.containsKey(joiner.getId())) {\n            JoinInfo jinfo = joinlist.get(joiner.getId());\n            // change 15000 to either a constant defined at top of\n            // file or a variable read from config\n            if (jinfo.time + 15000 > System.currentTimeMillis() && jinfo.invite == invited)\n                return true;\n        }\n        return false;\n    }\n\n    public void setJoinOK(Player joiner, boolean invited) {\n        JoinInfo jinfo = new JoinInfo(invited);\n        joinlist.put(joiner.id, jinfo);\n    }\n\n    /**\n     * Packs this player into the specified stream.\n     * @param out the stream to write this player to.\n     */\n    public void pack(DataOutputStream out) throws IOException {\n        out.writeShort(MAGIC_NO);\n        out.writeByte(id);\n        out.writeShort(strength);\n        out.writeShort(pictureid);\n        out.writeFloat(x);\n        out.writeFloat(y);\n        out.writeFloat(z);\n        out.writeUTF(name);\n    }\n\n    /**\n     * Unpack and set player data from the specified stream.\n     * @param in the stream to read data from.\n     * @return true if data was successfully unpacked.\n     */\n    public boolean unpack(DataInputStream in) {\n        Player tmp = null;\n        try {\n            /* Verify that stream really contains player data. */\n            if (in.readShort() != MAGIC_NO) {\n                System.err.println(\"Player.unpack(): *** WARNING *** \" + \"data is not of proper type!\");\n                return false;\n            }\n            /* Try unpacking the data to a temporary variable before\n\t       commiting the changes. */\n            tmp = new Player();\n            tmp.id = in.readByte();\n            tmp.strength = in.readShort();\n            tmp.pictureid = in.readShort();\n            tmp.x = in.readFloat();\n            tmp.y = in.readFloat();\n            tmp.z = in.readFloat();\n            tmp.name = in.readUTF();\n        } catch (EOFException e) {\n            System.err.println(\"Player.unpack(): *** WARNING *** [EOF] \" + \"data was incomplete: \" + e.getMessage());\n            return false;\n        } catch (IOException e) {\n            System.err.println(\"Player.unpack(): *** WARNING *** [IO] \" + \"failed to unpack data: \" + e.getMessage());\n            return false;\n        }\n        /* Apply the unpacked data. */\n        id = tmp.id;\n        name = tmp.name;\n        strength = tmp.strength;\n        pictureid = tmp.pictureid;\n        x = tmp.x;\n        y = tmp.y;\n        z = tmp.z;\n        return true;\n    }\n\n    /**\n     * Returns an unambigious byte-array representation of this\n     * object.\n     *\n     * @deprecated\n     * @return The resulting byte array.\n     */\n    public byte[] pack() {\n        try {\n            ByteArrayOutputStream buf = new ByteArrayOutputStream();\n            DataOutputStream out = new DataOutputStream(buf);\n            pack(out);\n            out.close();\n            return buf.toByteArray();\n        } catch (IOException e) {\n            System.err.println(\"Player.pack(): *** ERROR *** [IO] \" + \"pack failed! current state is \" + \"inconsistent: \" + e.getMessage());\n        }\n        return null;\n    }\n\n    /**\n     * Unpacks an array previously created with pack() and puts in\n     * this object.\n     *\n     * @deprecated\n     * @param b the byte array to be unpacked.\n     */\n    public void unpack(byte[] b) {\n        unpack(new DataInputStream(new ByteArrayInputStream(b)));\n    }\n\n    /**\n     * Returns the type of the packable.\n     * @return The resulting byte array.\n     */\n    public int type() {\n        return Packable.PLAYER;\n    }\n\n    public String toString() {\n        return name;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/state/PlayerTest6.java",
		"test_prompt": "// PlayerTest6.java\npackage state;\n\nimport java.io.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Player}.\n* It contains ten unit test cases for the {@link Player#type()} method.\n*/\nclass PlayerTest6 {"
	},
	{
		"original_code": "// Action.java\n/* $Id: Action.java,v 1.4 2004/04/27 19:26:22 bja Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Emil Lundstr�m <emill@kth.se>\n * @version: $Revision: 1.4 $\n *\n */\npackage state;\n\nimport java.io.UnsupportedEncodingException;\nimport java.io.DataOutputStream;\nimport java.io.DataInputStream;\nimport java.io.ByteArrayInputStream;\nimport util.TaintedByteArrayOutputStream;\nimport util.TaintedByteArrayInputStream;\nimport util.ManagedObject;\nimport util.ObjectManager;\n\n/**\n * Interface for all objects that are packable, i.e. objects that are\n * to be sent over the network.\n */\npublic class Action extends ManagedObject implements Packable {\n\n    public final static int ACTION_JOIN = 0;\n\n    public final static int ACTION_PART = 1;\n\n    public final static int ACTION_ATTACK = 2;\n\n    public final static int ACTION_JOIN_APPLY = 3;\n\n    public final static int ACTION_JOIN_INVITE = 4;\n\n    public final static int ACTION_JOIN_ALLOW = 5;\n\n    public final static int ACTION_JOIN_AGREE = 6;\n\n    public final static int ACTION_MOVE = 7;\n\n    public final static int ACTION_KICK = 8;\n\n    /**\n     * Number used by the network module to identify\n     * a piece of data as being an Action.\n     */\n    private static final int PACK_TYPE = Packable.ACTION;\n\n    /**\n     * The actor (i.e. the Player that invkoked the action).\n     */\n    private int actor;\n\n    /**\n     * The target (i.e. the Player the action is invoked on).\n     */\n    private int target;\n\n    /**\n     * The type of action this is.\n     */\n    private int action;\n\n    /**\n     * The destination associated with a ACTION_MOVE.\n     */\n    private byte destX, destY, destZ;\n\n    /**\n     * Utility classes, not part of the Action.\n     */\n    private TaintedByteArrayOutputStream byteOutputStream;\n\n    private TaintedByteArrayInputStream byteInputStream;\n\n    private DataOutputStream outputStream;\n\n    private DataInputStream inputStream;\n\n    /**\n     * The manager associated with this Action, if any.\n     */\n    private ObjectManager manager = null;\n\n    /**\n     * Create a new instance of the Action class. Fields are set to\n     * default values. The action, actor, and target are set to -1.\n     */\n    public Action() {\n        this(-1, -1, -1);\n    }\n\n    /**\n     * @param action\n     * @param actor\n     * @param target\n     */\n    public Action(int action, int actor, int target) {\n        this.actor = actor;\n        this.action = action;\n        this.target = target;\n        byteOutputStream = new TaintedByteArrayOutputStream();\n        outputStream = new DataOutputStream(byteOutputStream);\n        byteInputStream = new TaintedByteArrayInputStream();\n        inputStream = new DataInputStream(byteInputStream);\n    }\n\n    /**\n     */\n    public Action(int action, int actor, byte x, byte y, byte z) {\n        this(action, actor, -1);\n        this.destX = x;\n        this.destY = y;\n        this.destZ = z;\n    }\n\n    /**\n     */\n    public void set(int action, int actor, int target, byte x, byte y, byte z) {\n        this.actor = actor;\n        this.action = action;\n        this.target = target;\n        this.destX = x;\n        this.destY = y;\n        this.destZ = z;\n    }\n\n    /**\n     * Sets the actor of this Action object.\n     */\n    public void setActor(int actor) {\n        this.actor = actor;\n    }\n\n    /**\n     * Returns the action of the Action object.\n     *\n     * @return The action byte.\n     */\n    public int getAction() {\n        return action;\n    }\n\n    /**\n     * Returns the actor trying to perform this Action.\n     *\n     * @return The actor byte.\n     */\n    public int getActor() {\n        return actor;\n    }\n\n    /**\n     * Returns the target of the action.\n     *\n     * @return The target byte.\n     */\n    public int getTarget() {\n        return target;\n    }\n\n    /**\n     * Returns the type of Packable this is. This number is used by the\n     * network module to identify a piece of data coming from the network\n     * as being an Action.\n     *\n     * @return the type of Packable this is.\n     */\n    public int type() {\n        return PACK_TYPE;\n    }\n\n    /**\n     * Packs this Action into the specified stream.\n     * @param out the stream to write this player to.\n     * @throws PackingException if the packing failed.\n     */\n    public void pack(DataOutputStream out) throws PackingException {\n        try {\n            //out.writeByte(PACK_TYPE);\n            out.writeByte(actor);\n            out.writeByte(target);\n            out.writeByte(action);\n            /* Pack the waypoints associated with this action if any. */\n            /* fixme - this should really be subclassed, but the Action design \n\t       has not been finalized, so until then we do it here, *sigh*. */\n            if (action == ACTION_MOVE) {\n                out.writeByte(destX);\n                out.writeByte(destY);\n                out.writeByte(destZ);\n                //out.writeByte(this.numOfWaypoints);\n                //out.writeFloat(wp[0]);\n                //out.writeFloat(wp[1]);\n                //out.writeFloat(wp[2]);\n                // waypoints are stored as offsets\n                //for (byte[] wp : waypoints) {\n                //}\n            }\n        } catch (Exception e) {\n            throw new PackingException(e);\n        }\n    }\n\n    /**\n     * Unpack and set action data from the specified stream.\n     * @param in the stream to read data from.\n     * @throws PackingException if the unpacking failed.\n     */\n    public void unpack(DataInputStream in) throws PackingException {\n        try {\n            /*\n\t    byte packType = in.readByte();\n\n\t    if (PACK_TYPE != packType) {\n\t\tthrow new PackingException(\n\t\t    String.format(\n\t\t\t\"Action.unpack(): *** ERROR *** \" +\n\t\t\t\"Data is not of correct packable type: \" +\n\t\t\t\"got %d should be %d\", packType, PACK_TYPE));\n\t    }\n\t    */\n            actor = in.readByte();\n            target = in.readByte();\n            action = in.readByte();\n            if (action == ACTION_MOVE) {\n                destX = in.readByte();\n                destY = in.readByte();\n                destZ = in.readByte();\n            }\n        } catch (Exception e) {\n            //if (e instanceof PackingException) throw (PackingException) e;\n            throw new PackingException(e);\n        }\n    }\n\n    /**\n     * Returns a byte array representation of this Action.\n     *\n     * @return The resulting byte array.\n     */\n    public byte[] pack() /* throws PackingException */\n    {\n        try {\n            byteOutputStream.reset();\n            pack(outputStream);\n            return byteOutputStream.toByteArray();\n        } catch (PackingException e) {\n            System.err.println(e.getMessage());\n        }\n        return null;\n    }\n\n    /**\n     * Unpacks an array previously created with pack() and puts in\n     * this object.\n     *\n     * @deprecated\n     * @param b the byte array to be unpacked.\n     */\n    public void unpack(byte[] b) /* throws PackingException */\n    {\n        try {\n            byteInputStream.setByteArray(b);\n            unpack(inputStream);\n        } catch (PackingException e) {\n            // caught here since letting it propagate would break\n            // things in other modules.\n            System.err.println(\"Action.unpack(): *** ERROR *** [IO] \" + \"unpack failed! current state is \" + \"inconsistent: \" + e.getMessage());\n        }\n    }\n\n    public Action clone() {\n        Action a = new Action();\n        a.setManager(manager);\n        return a;\n    }\n\n    public String toString() {\n        return String.format(\"Action[type=%d,action=%s,actor=%s,target=%s,\" + \"destX=%d,destY=%d,destZ=%d]\", PACK_TYPE, action, actor, target, destX, destY, destZ);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/state/ActionTest0.java",
		"test_prompt": "// ActionTest0.java\npackage state;\n\nimport java.io.UnsupportedEncodingException;\nimport java.io.DataOutputStream;\nimport java.io.DataInputStream;\nimport java.io.ByteArrayInputStream;\nimport util.TaintedByteArrayOutputStream;\nimport util.TaintedByteArrayInputStream;\nimport util.ManagedObject;\nimport util.ObjectManager;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Action}.\n* It contains ten unit test cases for the {@link Action#type()} method.\n*/\nclass ActionTest0 {"
	},
	{
		"original_code": "// Action.java\n/* $Id: Action.java,v 1.4 2004/04/27 19:26:22 bja Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Emil Lundstr�m <emill@kth.se>\n * @version: $Revision: 1.4 $\n *\n */\npackage state;\n\nimport java.io.UnsupportedEncodingException;\nimport java.io.DataOutputStream;\nimport java.io.DataInputStream;\nimport java.io.ByteArrayInputStream;\nimport util.TaintedByteArrayOutputStream;\nimport util.TaintedByteArrayInputStream;\nimport util.ManagedObject;\nimport util.ObjectManager;\n\n/**\n * Interface for all objects that are packable, i.e. objects that are\n * to be sent over the network.\n */\npublic class Action extends ManagedObject implements Packable {\n\n    public final static int ACTION_JOIN = 0;\n\n    public final static int ACTION_PART = 1;\n\n    public final static int ACTION_ATTACK = 2;\n\n    public final static int ACTION_JOIN_APPLY = 3;\n\n    public final static int ACTION_JOIN_INVITE = 4;\n\n    public final static int ACTION_JOIN_ALLOW = 5;\n\n    public final static int ACTION_JOIN_AGREE = 6;\n\n    public final static int ACTION_MOVE = 7;\n\n    public final static int ACTION_KICK = 8;\n\n    /**\n     * Number used by the network module to identify\n     * a piece of data as being an Action.\n     */\n    private static final int PACK_TYPE = Packable.ACTION;\n\n    /**\n     * The actor (i.e. the Player that invkoked the action).\n     */\n    private int actor;\n\n    /**\n     * The target (i.e. the Player the action is invoked on).\n     */\n    private int target;\n\n    /**\n     * The type of action this is.\n     */\n    private int action;\n\n    /**\n     * The destination associated with a ACTION_MOVE.\n     */\n    private byte destX, destY, destZ;\n\n    /**\n     * Utility classes, not part of the Action.\n     */\n    private TaintedByteArrayOutputStream byteOutputStream;\n\n    private TaintedByteArrayInputStream byteInputStream;\n\n    private DataOutputStream outputStream;\n\n    private DataInputStream inputStream;\n\n    /**\n     * The manager associated with this Action, if any.\n     */\n    private ObjectManager manager = null;\n\n    /**\n     * Create a new instance of the Action class. Fields are set to\n     * default values. The action, actor, and target are set to -1.\n     */\n    public Action() {\n        this(-1, -1, -1);\n    }\n\n    /**\n     * @param action\n     * @param actor\n     * @param target\n     */\n    public Action(int action, int actor, int target) {\n        this.actor = actor;\n        this.action = action;\n        this.target = target;\n        byteOutputStream = new TaintedByteArrayOutputStream();\n        outputStream = new DataOutputStream(byteOutputStream);\n        byteInputStream = new TaintedByteArrayInputStream();\n        inputStream = new DataInputStream(byteInputStream);\n    }\n\n    /**\n     */\n    public Action(int action, int actor, byte x, byte y, byte z) {\n        this(action, actor, -1);\n        this.destX = x;\n        this.destY = y;\n        this.destZ = z;\n    }\n\n    /**\n     */\n    public void set(int action, int actor, int target, byte x, byte y, byte z) {\n        this.actor = actor;\n        this.action = action;\n        this.target = target;\n        this.destX = x;\n        this.destY = y;\n        this.destZ = z;\n    }\n\n    /**\n     * Sets the actor of this Action object.\n     */\n    public void setActor(int actor) {\n        this.actor = actor;\n    }\n\n    /**\n     * Returns the action of the Action object.\n     *\n     * @return The action byte.\n     */\n    public int getAction() {\n        return action;\n    }\n\n    /**\n     * Returns the actor trying to perform this Action.\n     *\n     * @return The actor byte.\n     */\n    public int getActor() {\n        return actor;\n    }\n\n    /**\n     * Returns the target of the action.\n     *\n     * @return The target byte.\n     */\n    public int getTarget() {\n        return target;\n    }\n\n    /**\n     * Returns the type of Packable this is. This number is used by the\n     * network module to identify a piece of data coming from the network\n     * as being an Action.\n     *\n     * @return the type of Packable this is.\n     */\n    public int type() {\n        return PACK_TYPE;\n    }\n\n    /**\n     * Packs this Action into the specified stream.\n     * @param out the stream to write this player to.\n     * @throws PackingException if the packing failed.\n     */\n    public void pack(DataOutputStream out) throws PackingException {\n        try {\n            //out.writeByte(PACK_TYPE);\n            out.writeByte(actor);\n            out.writeByte(target);\n            out.writeByte(action);\n            /* Pack the waypoints associated with this action if any. */\n            /* fixme - this should really be subclassed, but the Action design \n\t       has not been finalized, so until then we do it here, *sigh*. */\n            if (action == ACTION_MOVE) {\n                out.writeByte(destX);\n                out.writeByte(destY);\n                out.writeByte(destZ);\n                //out.writeByte(this.numOfWaypoints);\n                //out.writeFloat(wp[0]);\n                //out.writeFloat(wp[1]);\n                //out.writeFloat(wp[2]);\n                // waypoints are stored as offsets\n                //for (byte[] wp : waypoints) {\n                //}\n            }\n        } catch (Exception e) {\n            throw new PackingException(e);\n        }\n    }\n\n    /**\n     * Unpack and set action data from the specified stream.\n     * @param in the stream to read data from.\n     * @throws PackingException if the unpacking failed.\n     */\n    public void unpack(DataInputStream in) throws PackingException {\n        try {\n            /*\n\t    byte packType = in.readByte();\n\n\t    if (PACK_TYPE != packType) {\n\t\tthrow new PackingException(\n\t\t    String.format(\n\t\t\t\"Action.unpack(): *** ERROR *** \" +\n\t\t\t\"Data is not of correct packable type: \" +\n\t\t\t\"got %d should be %d\", packType, PACK_TYPE));\n\t    }\n\t    */\n            actor = in.readByte();\n            target = in.readByte();\n            action = in.readByte();\n            if (action == ACTION_MOVE) {\n                destX = in.readByte();\n                destY = in.readByte();\n                destZ = in.readByte();\n            }\n        } catch (Exception e) {\n            //if (e instanceof PackingException) throw (PackingException) e;\n            throw new PackingException(e);\n        }\n    }\n\n    /**\n     * Returns a byte array representation of this Action.\n     *\n     * @return The resulting byte array.\n     */\n    public byte[] pack() /* throws PackingException */\n    {\n        try {\n            byteOutputStream.reset();\n            pack(outputStream);\n            return byteOutputStream.toByteArray();\n        } catch (PackingException e) {\n            System.err.println(e.getMessage());\n        }\n        return null;\n    }\n\n    /**\n     * Unpacks an array previously created with pack() and puts in\n     * this object.\n     *\n     * @deprecated\n     * @param b the byte array to be unpacked.\n     */\n    public void unpack(byte[] b) /* throws PackingException */\n    {\n        try {\n            byteInputStream.setByteArray(b);\n            unpack(inputStream);\n        } catch (PackingException e) {\n            // caught here since letting it propagate would break\n            // things in other modules.\n            System.err.println(\"Action.unpack(): *** ERROR *** [IO] \" + \"unpack failed! current state is \" + \"inconsistent: \" + e.getMessage());\n        }\n    }\n\n    public Action clone() {\n        Action a = new Action();\n        a.setManager(manager);\n        return a;\n    }\n\n    public String toString() {\n        return String.format(\"Action[type=%d,action=%s,actor=%s,target=%s,\" + \"destX=%d,destY=%d,destZ=%d]\", PACK_TYPE, action, actor, target, destX, destY, destZ);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/state/ActionTest1.java",
		"test_prompt": "// ActionTest1.java\npackage state;\n\nimport java.io.UnsupportedEncodingException;\nimport java.io.DataOutputStream;\nimport java.io.DataInputStream;\nimport java.io.ByteArrayInputStream;\nimport util.TaintedByteArrayOutputStream;\nimport util.TaintedByteArrayInputStream;\nimport util.ManagedObject;\nimport util.ObjectManager;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Action}.\n* It contains ten unit test cases for the {@link Action#pack()} method.\n*/\nclass ActionTest1 {"
	},
	{
		"original_code": "// Action.java\n/* $Id: Action.java,v 1.4 2004/04/27 19:26:22 bja Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Emil Lundstr�m <emill@kth.se>\n * @version: $Revision: 1.4 $\n *\n */\npackage state;\n\nimport java.io.UnsupportedEncodingException;\nimport java.io.DataOutputStream;\nimport java.io.DataInputStream;\nimport java.io.ByteArrayInputStream;\nimport util.TaintedByteArrayOutputStream;\nimport util.TaintedByteArrayInputStream;\nimport util.ManagedObject;\nimport util.ObjectManager;\n\n/**\n * Interface for all objects that are packable, i.e. objects that are\n * to be sent over the network.\n */\npublic class Action extends ManagedObject implements Packable {\n\n    public final static int ACTION_JOIN = 0;\n\n    public final static int ACTION_PART = 1;\n\n    public final static int ACTION_ATTACK = 2;\n\n    public final static int ACTION_JOIN_APPLY = 3;\n\n    public final static int ACTION_JOIN_INVITE = 4;\n\n    public final static int ACTION_JOIN_ALLOW = 5;\n\n    public final static int ACTION_JOIN_AGREE = 6;\n\n    public final static int ACTION_MOVE = 7;\n\n    public final static int ACTION_KICK = 8;\n\n    /**\n     * Number used by the network module to identify\n     * a piece of data as being an Action.\n     */\n    private static final int PACK_TYPE = Packable.ACTION;\n\n    /**\n     * The actor (i.e. the Player that invkoked the action).\n     */\n    private int actor;\n\n    /**\n     * The target (i.e. the Player the action is invoked on).\n     */\n    private int target;\n\n    /**\n     * The type of action this is.\n     */\n    private int action;\n\n    /**\n     * The destination associated with a ACTION_MOVE.\n     */\n    private byte destX, destY, destZ;\n\n    /**\n     * Utility classes, not part of the Action.\n     */\n    private TaintedByteArrayOutputStream byteOutputStream;\n\n    private TaintedByteArrayInputStream byteInputStream;\n\n    private DataOutputStream outputStream;\n\n    private DataInputStream inputStream;\n\n    /**\n     * The manager associated with this Action, if any.\n     */\n    private ObjectManager manager = null;\n\n    /**\n     * Create a new instance of the Action class. Fields are set to\n     * default values. The action, actor, and target are set to -1.\n     */\n    public Action() {\n        this(-1, -1, -1);\n    }\n\n    /**\n     * @param action\n     * @param actor\n     * @param target\n     */\n    public Action(int action, int actor, int target) {\n        this.actor = actor;\n        this.action = action;\n        this.target = target;\n        byteOutputStream = new TaintedByteArrayOutputStream();\n        outputStream = new DataOutputStream(byteOutputStream);\n        byteInputStream = new TaintedByteArrayInputStream();\n        inputStream = new DataInputStream(byteInputStream);\n    }\n\n    /**\n     */\n    public Action(int action, int actor, byte x, byte y, byte z) {\n        this(action, actor, -1);\n        this.destX = x;\n        this.destY = y;\n        this.destZ = z;\n    }\n\n    /**\n     */\n    public void set(int action, int actor, int target, byte x, byte y, byte z) {\n        this.actor = actor;\n        this.action = action;\n        this.target = target;\n        this.destX = x;\n        this.destY = y;\n        this.destZ = z;\n    }\n\n    /**\n     * Sets the actor of this Action object.\n     */\n    public void setActor(int actor) {\n        this.actor = actor;\n    }\n\n    /**\n     * Returns the action of the Action object.\n     *\n     * @return The action byte.\n     */\n    public int getAction() {\n        return action;\n    }\n\n    /**\n     * Returns the actor trying to perform this Action.\n     *\n     * @return The actor byte.\n     */\n    public int getActor() {\n        return actor;\n    }\n\n    /**\n     * Returns the target of the action.\n     *\n     * @return The target byte.\n     */\n    public int getTarget() {\n        return target;\n    }\n\n    /**\n     * Returns the type of Packable this is. This number is used by the\n     * network module to identify a piece of data coming from the network\n     * as being an Action.\n     *\n     * @return the type of Packable this is.\n     */\n    public int type() {\n        return PACK_TYPE;\n    }\n\n    /**\n     * Packs this Action into the specified stream.\n     * @param out the stream to write this player to.\n     * @throws PackingException if the packing failed.\n     */\n    public void pack(DataOutputStream out) throws PackingException {\n        try {\n            //out.writeByte(PACK_TYPE);\n            out.writeByte(actor);\n            out.writeByte(target);\n            out.writeByte(action);\n            /* Pack the waypoints associated with this action if any. */\n            /* fixme - this should really be subclassed, but the Action design \n\t       has not been finalized, so until then we do it here, *sigh*. */\n            if (action == ACTION_MOVE) {\n                out.writeByte(destX);\n                out.writeByte(destY);\n                out.writeByte(destZ);\n                //out.writeByte(this.numOfWaypoints);\n                //out.writeFloat(wp[0]);\n                //out.writeFloat(wp[1]);\n                //out.writeFloat(wp[2]);\n                // waypoints are stored as offsets\n                //for (byte[] wp : waypoints) {\n                //}\n            }\n        } catch (Exception e) {\n            throw new PackingException(e);\n        }\n    }\n\n    /**\n     * Unpack and set action data from the specified stream.\n     * @param in the stream to read data from.\n     * @throws PackingException if the unpacking failed.\n     */\n    public void unpack(DataInputStream in) throws PackingException {\n        try {\n            /*\n\t    byte packType = in.readByte();\n\n\t    if (PACK_TYPE != packType) {\n\t\tthrow new PackingException(\n\t\t    String.format(\n\t\t\t\"Action.unpack(): *** ERROR *** \" +\n\t\t\t\"Data is not of correct packable type: \" +\n\t\t\t\"got %d should be %d\", packType, PACK_TYPE));\n\t    }\n\t    */\n            actor = in.readByte();\n            target = in.readByte();\n            action = in.readByte();\n            if (action == ACTION_MOVE) {\n                destX = in.readByte();\n                destY = in.readByte();\n                destZ = in.readByte();\n            }\n        } catch (Exception e) {\n            //if (e instanceof PackingException) throw (PackingException) e;\n            throw new PackingException(e);\n        }\n    }\n\n    /**\n     * Returns a byte array representation of this Action.\n     *\n     * @return The resulting byte array.\n     */\n    public byte[] pack() /* throws PackingException */\n    {\n        try {\n            byteOutputStream.reset();\n            pack(outputStream);\n            return byteOutputStream.toByteArray();\n        } catch (PackingException e) {\n            System.err.println(e.getMessage());\n        }\n        return null;\n    }\n\n    /**\n     * Unpacks an array previously created with pack() and puts in\n     * this object.\n     *\n     * @deprecated\n     * @param b the byte array to be unpacked.\n     */\n    public void unpack(byte[] b) /* throws PackingException */\n    {\n        try {\n            byteInputStream.setByteArray(b);\n            unpack(inputStream);\n        } catch (PackingException e) {\n            // caught here since letting it propagate would break\n            // things in other modules.\n            System.err.println(\"Action.unpack(): *** ERROR *** [IO] \" + \"unpack failed! current state is \" + \"inconsistent: \" + e.getMessage());\n        }\n    }\n\n    public Action clone() {\n        Action a = new Action();\n        a.setManager(manager);\n        return a;\n    }\n\n    public String toString() {\n        return String.format(\"Action[type=%d,action=%s,actor=%s,target=%s,\" + \"destX=%d,destY=%d,destZ=%d]\", PACK_TYPE, action, actor, target, destX, destY, destZ);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/state/ActionTest2.java",
		"test_prompt": "// ActionTest2.java\npackage state;\n\nimport java.io.UnsupportedEncodingException;\nimport java.io.DataOutputStream;\nimport java.io.DataInputStream;\nimport java.io.ByteArrayInputStream;\nimport util.TaintedByteArrayOutputStream;\nimport util.TaintedByteArrayInputStream;\nimport util.ManagedObject;\nimport util.ObjectManager;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Action}.\n* It contains ten unit test cases for the {@link Action#clone()} method.\n*/\nclass ActionTest2 {"
	},
	{
		"original_code": "// GameState.java\n/* $Id: GameState.java,v 1.30 2004/05/05 23:45:19 njursten Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Rasmus Ahlberg <ahlbgerg@kth.se>\n * @version: $Revision: 1.30 $\n *\n */\npackage state;\n\nimport java.util.*;\nimport java.io.*;\n\n/**\n * The state of the game. Includes the gang tree, all players stats\n * and more. Implements Observable for whenever a change in the state\n * is detected.\n */\npublic class GameState extends Observable implements Packable {\n\n    /**\n     * Maximum number of players.\n     */\n    public static final int MAX_PLAYER_LIMIT = 128;\n\n    /**\n     * Number to verify against when unpacking.\n     */\n    private static final short MAGIC_NO = 0x3BBA;\n\n    /**\n     * List of known players.\n     */\n    private Player[] players;\n\n    /**\n     * Total number of known players.\n     */\n    private int numOfPlayers;\n\n    /**\n     * Number of dead players\n     */\n    private int numDead;\n\n    /**\n     * Save when a game is started.\n     */\n    private long gamestart;\n\n    /**\n     * Current state of the game\n     */\n    private int gamestate;\n\n    /**\n     * Waiting for players to join\n     */\n    public static final int STATE_WAITING = 1;\n\n    /**\n     * Warmup time. No attacks possible.\n     */\n    public static final int STATE_WARMUP = 2;\n\n    /**\n     * A game is in progress.\n     */\n    public static final int STATE_PLAYING = 3;\n\n    /**\n     * Game has ended.\n     */\n    public static final int STATE_ENDED = 4;\n\n    /**\n     * The current player for this client. null for the server.\n     */\n    private Player me;\n\n    /**\n     * Minimum time to wait before making next move\n     */\n    private long mintimemove;\n\n    /**\n     * Number of rounds to play\n     */\n    private int totalRounds;\n\n    /**\n     * Current round number\n     */\n    private int currentRound;\n\n    /**\n     * Keep track of when last move of a user was done\n     */\n    private Hashtable<Integer, Long> lastmove;\n\n    /**\n     * Creates a new instance of the GameState class.\n     */\n    public GameState() {\n        this(15000);\n    }\n\n    /**\n     * Creates a new instance of the GameState class.\n     * @param mintimemove How long a user must wait between attack moves.\n     */\n    public GameState(long mintimemove) {\n        players = new Player[MAX_PLAYER_LIMIT];\n        numOfPlayers = 0;\n        numDead = 0;\n        gamestart = 0;\n        gamestate = STATE_WAITING;\n        currentRound = 1;\n        totalRounds = 1;\n        this.mintimemove = mintimemove;\n        lastmove = new Hashtable<Integer, Long>();\n    }\n\n    public void reset(boolean newGame) {\n        numDead = 0;\n        for (int i = 0; i < players.length; i++) {\n            if (players[i] == null)\n                continue;\n            if (!players[i].isConnected()) {\n                if (newGame) {\n                    players[i] = null;\n                    numOfPlayers--;\n                } else {\n                    players[i].reset(newGame);\n                    setDead(players[i]);\n                }\n            } else {\n                players[i].reset(newGame);\n            }\n        }\n        if (newGame)\n            currentRound = 1;\n        lastmove = new Hashtable<Integer, Long>();\n    }\n\n    public void setTotalRounds(int totalRounds) {\n        this.totalRounds = totalRounds;\n    }\n\n    public int getTotalRounds() {\n        return totalRounds;\n    }\n\n    public void setCurrentRound(int currentRound) {\n        this.currentRound = currentRound;\n    }\n\n    public int getCurrentRound() {\n        return currentRound;\n    }\n\n    /**\n     * Returns the state of the game. Ie, warmup, running, waiting for users.\n     * Use the predefined values defined as STATE_* in this class.\n     */\n    public int getGameState() {\n        return gamestate;\n    }\n\n    /**\n     * Sets the state of the game. Ie, warmup, running, waiting for users.\n     * Use the predefined values defined as STATE_* in this class.\n     */\n    public void setGameState(int gamestate) {\n        this.gamestate = gamestate;\n        System.err.println(\"Notifying observers...:\" + this.gamestate);\n        setChanged();\n        notifyObservers(new Integer(gamestate));\n    }\n\n    /**\n     * Check if enough time has passed since last move.\n     */\n    public boolean isMoveTimeOK(Player player) {\n        if (lastmove.containsKey(player.getId())) {\n            long time = lastmove.get(new Integer(player.getId()));\n            if (time + mintimemove > System.currentTimeMillis())\n                return false;\n        }\n        return true;\n    }\n\n    /**\n     * Update the time when player last made an attack move.\n     */\n    public void updateLastMove(Player player) {\n        lastmove.put(player.getId(), System.currentTimeMillis());\n    }\n\n    /**\n     * Adds the specified player to the list of known players.\n     *\n     * @param p The player that is to be added.\n     */\n    public void addPlayer(Player p) {\n        try {\n            if (players[p.getId()] != null) {\n                /* throw new GameStateException(\"PlayerID exists!\"); */\n                System.err.println(\"GameState.addPlayer(): PlayerID exists!\");\n                return;\n            }\n            players[p.getId()] = p;\n            numOfPlayers++;\n            updateLastMove(p);\n            setChanged();\n            notifyObservers();\n        } catch (IndexOutOfBoundsException e) {\n            System.err.println(\"GameState.addPlayer(): \" + \"PlayerID '\" + p.id + \"' out of the allowed \" + \"range 0 - \" + MAX_PLAYER_LIMIT);\n        } catch (NullPointerException e) {\n            e.printStackTrace(System.err);\n        }\n    }\n\n    /**\n     * Removes the specified player from the list of known players.\n     *\n     * @param p The player that is to be removed.\n     */\n    public void removePlayer(Player p) {\n        try {\n            if (players[p.getId()] == null) {\n                /* throw new GameStateException(\"PlayerID doesn't exist!\"); */\n                System.err.println(\"GameState.removePlayer(): \" + \"PlayerID doesn't exist!\");\n            }\n            if (!p.isBoss()) {\n                part(p.boss, p);\n            }\n            while (p.head != null) {\n                part(p, p.head);\n            }\n            if (gamestate == STATE_WAITING) {\n                players[p.getId()] = null;\n                numOfPlayers--;\n            } else {\n                setDead(p);\n                p.setConnected(false);\n            }\n            setChanged();\n            notifyObservers(p);\n        } catch (IndexOutOfBoundsException e) {\n            System.err.println(\"GameState.removePlayer(): \" + \"PlayerID '\" + p.getId() + \"' out of the allowed \" + \"range 0 - \" + MAX_PLAYER_LIMIT);\n        } catch (NullPointerException e) {\n            e.printStackTrace(System.err);\n        }\n    }\n\n    /**\n     * Adds a party to another party's underling list. This\n     * automatically merges the two parties' gangs.\n     *\n     * @param parent The Party whose gang the child joined.\n     * @param child The Party which joined the parent's gang.\n     */\n    public void join(Party parent, Party child) {\n        try {\n            parent.add(child);\n            setChanged();\n            notifyObservers(child);\n        } catch (NullPointerException e) {\n            System.err.println(\"GameState.join(): parent=\" + parent + \" \" + \"child=\" + child);\n            e.printStackTrace(System.err);\n        }\n    }\n\n    /**\n     * Removes a party from another party's underling list. The\n     * parties that were previously member of the parting party's gang\n     * before the join will also part with it, provided they are still\n     * in the party's underling list.\n     *\n     * @param parent The Party whose gang the child parts from.\n     * @param child The Party which parted the parent's gang.\n     */\n    public void part(Party parent, Party child) {\n        try {\n            parent.remove(child);\n            setChanged();\n            notifyObservers(child);\n        } catch (NullPointerException e) {\n            e.printStackTrace(System.err);\n        }\n    }\n\n    /**\n     * Returns the player at int id. If player id is out of bounds for\n     * the player array, or if no player exists with given id, null is\n     * returned. This is consequent with pidFor(Player p) which\n     * returns -1 when passed a null value.\n     *\n     * @param id The id of the player that is to be found.\n     * @return The Player with the right id. -1 if no player could be\n     * found.\n     */\n    public Player player(int id) {\n        if (id < 0 || id >= MAX_PLAYER_LIMIT)\n            return null;\n        return players[id];\n    }\n\n    public Player[] players() {\n        return players;\n    }\n\n    public void setMe(Player p) {\n        me = p;\n    }\n\n    public Player getMe() {\n        return me;\n    }\n\n    public int getNumOfPlayers() {\n        return numOfPlayers;\n    }\n\n    public void reload() {\n        setChanged();\n        notifyObservers(this);\n    }\n\n    /**\n     * Sets a player's state to dead and increases the dead players\n     * counter.\n     *\n     * @param p The dead Player.\n     * @param deathtime The time of death of the player.\n     */\n    public void setDead(Player p, long deathtime) {\n        if (p != null && !p.isDead()) {\n            numDead++;\n            p.setDead(deathtime);\n            setChanged();\n            notifyObservers(p);\n        }\n    }\n\n    public void setDead(Player p) {\n        setDead(p, System.currentTimeMillis());\n    }\n\n    /**\n     * Updates a player's world coordinates in the specified\n     * direction.\n     *\n     * @param p The player.\n     * @param direction The direction. As specified by the\n     * ANSI-DIRECTIONAL-STANDARD 8-55-155.\n     * @deprecated does nothing in gl gui\n     */\n    public void move(Player p, int direction) {\n        /*\n\tfloat dirx = 0;\n\tfloat diry = 0;\n\t\n\tif ((direction & 0x1) != 0) {\n\t    diry -= Player.MOVE_DISTANCE;\n\t}\n\tif ((direction & 0x2) != 0) {\n\t    dirx -= Player.MOVE_DISTANCE;\n\t}\n\tif ((direction & 0x4) != 0) {\n\t    diry += Player.MOVE_DISTANCE;\n\t}\n\tif ((direction & 0x8) != 0) {\n\t    dirx += Player.MOVE_DISTANCE;\n\t}\n\t\n\tp.setX(p.getX() + dirx);\n\tp.setY(p.getY() + diry);\n\tSystem.err.println(\"New player pos:\" + p.getX() + \",\" + p.getY() + \" \" + dirx + \" \" + diry);\n\tsetChanged();\n\tnotifyObservers(p);\n\t*/\n    }\n\n    /**\n     * Returns number of dead players.\n     *\n     * @return the number of dead players.\n     */\n    public int getNumDead() {\n        return numDead;\n    }\n\n    /**\n     * Returns when the game was started.\n     *\n     * @return The system time when game was started. -1 when game is\n     * not yet started.\n     */\n    public long getGamestart() {\n        return gamestart;\n    }\n\n    public void setGamestart(long l) {\n        gamestart = l;\n    }\n\n    /**\n     * Packs the entire GameState structure into a byte array.\n     * @return array of bytes representing the packed object.\n     */\n    public byte[] pack() {\n        ByteArrayOutputStream buf = new ByteArrayOutputStream();\n        DataOutputStream out = new DataOutputStream(buf);\n        Player p = null;\n        try {\n            int numplayers = numOfPlayers;\n            for (int i = 0; i < players.length; i++) {\n                if (players[i] != null && !players[i].isConnected())\n                    numplayers--;\n            }\n            out.writeShort(MAGIC_NO);\n            out.writeByte(gamestate);\n            out.writeByte(numplayers);\n            for (int i = 0, k = -1; i < numOfPlayers; i++) {\n                // fixme - fix this!\n                // exceptions are caught\n                while (players[++k] == null) ;\n                p = players[k];\n                if (!p.isConnected())\n                    continue;\n                p.pack(out);\n                out.writeByte(pidOf(p.boss));\n                out.writeByte(pidOf(p.next));\n                out.writeByte(pidOf(p.prev));\n                out.writeByte(pidOf(p.head));\n            }\n        } catch (IOException e) {\n            System.err.println(\"GameState.pack(): *** WARNING *** [IO] \" + \"failed to pack data: \" + e.getMessage());\n            return null;\n        } catch (ArrayIndexOutOfBoundsException e) {\n            System.err.println(\"GameState.pack(): *** ERROR *** [IDX] \" + \"failed to pack data: \" + e.getMessage());\n            return null;\n        }\n        return buf.toByteArray();\n    }\n\n    /**\n     * Unpacks the current state from the given array.\n     * @param b the byte array from which to read.\n     */\n    public void unpack(byte[] b) {\n        try {\n            DataInputStream in = new DataInputStream(new ByteArrayInputStream(b));\n            /* read and verify magic number */\n            if (in.readShort() != MAGIC_NO) {\n                /* throw new PackableException(); */\n                System.err.println(\"GameState.unpack(): *** WARNING *** \" + \"data is not of proper type!\");\n                return;\n            }\n            gamestate = in.readByte();\n            // number of players.\n            int n = in.readByte();\n            /* fixme - data should be read to a temporary place and then\n\t       verified, after which it should be commited. */\n            Player p = null;\n            for (int i = 0; i < n; i++) {\n                in.mark(3);\n                // magic number is checked in Player.unpack().\n                in.readShort();\n                p = playerAt(in.readByte());\n                in.reset();\n                if (p.unpack(in)) {\n                    p.boss = playerAt(in.readByte());\n                    p.next = playerAt(in.readByte());\n                    p.prev = playerAt(in.readByte());\n                    p.head = playerAt(in.readByte());\n                } else {\n                    System.err.println(\"GameState.unpack(): *** ERROR *** \" + \"data is incomplete! current state \" + \"is inconsistent!\");\n                }\n            }\n        } catch (EOFException e) {\n            System.err.println(\"GameState.unpack(): *** ERROR *** [EOF] \" + \"data is incomplete! current state is \" + \"inconsistent: \" + e.getMessage());\n        } catch (IOException e) {\n            System.err.println(\"GameState.unpack(): *** ERROR *** [IO] \" + \"unpack data failed! current state is \" + \"inconsistent: \" + e.getMessage());\n        }\n    }\n\n    public int type() {\n        return Packable.GAME_STATE;\n    }\n\n    /**\n     * Returns the player whith the specified id. If a player doesn't exist\n     * with that id doesn't exist, a new player is created and returned. If\n     * id is outside the allowed range, null is returned.\n     *\n     * @return the player with the specified id, or null if id is\n     *         outside allowed range.\n     */\n    private Player playerAt(int id) {\n        Player p = null;\n        try {\n            p = players[id];\n            if (p == null) {\n                p = new Player(id);\n                addPlayer(p);\n            }\n        } catch (ArrayIndexOutOfBoundsException e) {\n            //System.err.println(\"GameState.playerAt(): \" +\n            //\t\t       \"Invalid Player ID specified: \" + id);\n        }\n        return p;\n    }\n\n    /**\n     * Returns the id of the specified player.\n     *\n     * @param p The player for which id is returned.\n     * @return The\n     */\n    private int pidOf(Party p) {\n        if (p == null)\n            return -1;\n        return p.getId();\n    }\n\n    /**\n     * Returns a string representation of GameState. This includes a\n     * full view of the tree.\n     */\n    public String toString() {\n        StringBuffer str = new StringBuffer(\"GameState[\");\n        boolean first = true;\n        for (int i = 0, t = -1; i < numOfPlayers; i++) {\n            while (++t < players.length && players[t] == null) ;\n            if (t >= players.length) {\n                return \"ERR,\" + numOfPlayers + \"]\";\n            }\n            if (first) {\n                str.append(players[t]);\n                first = false;\n            } else {\n                str.append(\" , \" + players[t]);\n            }\n        }\n        return str + \"]\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/state/GameStateTest0.java",
		"test_prompt": "// GameStateTest0.java\npackage state;\n\nimport java.util.*;\nimport java.io.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GameState}.\n* It contains ten unit test cases for the {@link GameState#isMoveTimeOK(Player)} method.\n*/\nclass GameStateTest0 {"
	},
	{
		"original_code": "// GameState.java\n/* $Id: GameState.java,v 1.30 2004/05/05 23:45:19 njursten Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Rasmus Ahlberg <ahlbgerg@kth.se>\n * @version: $Revision: 1.30 $\n *\n */\npackage state;\n\nimport java.util.*;\nimport java.io.*;\n\n/**\n * The state of the game. Includes the gang tree, all players stats\n * and more. Implements Observable for whenever a change in the state\n * is detected.\n */\npublic class GameState extends Observable implements Packable {\n\n    /**\n     * Maximum number of players.\n     */\n    public static final int MAX_PLAYER_LIMIT = 128;\n\n    /**\n     * Number to verify against when unpacking.\n     */\n    private static final short MAGIC_NO = 0x3BBA;\n\n    /**\n     * List of known players.\n     */\n    private Player[] players;\n\n    /**\n     * Total number of known players.\n     */\n    private int numOfPlayers;\n\n    /**\n     * Number of dead players\n     */\n    private int numDead;\n\n    /**\n     * Save when a game is started.\n     */\n    private long gamestart;\n\n    /**\n     * Current state of the game\n     */\n    private int gamestate;\n\n    /**\n     * Waiting for players to join\n     */\n    public static final int STATE_WAITING = 1;\n\n    /**\n     * Warmup time. No attacks possible.\n     */\n    public static final int STATE_WARMUP = 2;\n\n    /**\n     * A game is in progress.\n     */\n    public static final int STATE_PLAYING = 3;\n\n    /**\n     * Game has ended.\n     */\n    public static final int STATE_ENDED = 4;\n\n    /**\n     * The current player for this client. null for the server.\n     */\n    private Player me;\n\n    /**\n     * Minimum time to wait before making next move\n     */\n    private long mintimemove;\n\n    /**\n     * Number of rounds to play\n     */\n    private int totalRounds;\n\n    /**\n     * Current round number\n     */\n    private int currentRound;\n\n    /**\n     * Keep track of when last move of a user was done\n     */\n    private Hashtable<Integer, Long> lastmove;\n\n    /**\n     * Creates a new instance of the GameState class.\n     */\n    public GameState() {\n        this(15000);\n    }\n\n    /**\n     * Creates a new instance of the GameState class.\n     * @param mintimemove How long a user must wait between attack moves.\n     */\n    public GameState(long mintimemove) {\n        players = new Player[MAX_PLAYER_LIMIT];\n        numOfPlayers = 0;\n        numDead = 0;\n        gamestart = 0;\n        gamestate = STATE_WAITING;\n        currentRound = 1;\n        totalRounds = 1;\n        this.mintimemove = mintimemove;\n        lastmove = new Hashtable<Integer, Long>();\n    }\n\n    public void reset(boolean newGame) {\n        numDead = 0;\n        for (int i = 0; i < players.length; i++) {\n            if (players[i] == null)\n                continue;\n            if (!players[i].isConnected()) {\n                if (newGame) {\n                    players[i] = null;\n                    numOfPlayers--;\n                } else {\n                    players[i].reset(newGame);\n                    setDead(players[i]);\n                }\n            } else {\n                players[i].reset(newGame);\n            }\n        }\n        if (newGame)\n            currentRound = 1;\n        lastmove = new Hashtable<Integer, Long>();\n    }\n\n    public void setTotalRounds(int totalRounds) {\n        this.totalRounds = totalRounds;\n    }\n\n    public int getTotalRounds() {\n        return totalRounds;\n    }\n\n    public void setCurrentRound(int currentRound) {\n        this.currentRound = currentRound;\n    }\n\n    public int getCurrentRound() {\n        return currentRound;\n    }\n\n    /**\n     * Returns the state of the game. Ie, warmup, running, waiting for users.\n     * Use the predefined values defined as STATE_* in this class.\n     */\n    public int getGameState() {\n        return gamestate;\n    }\n\n    /**\n     * Sets the state of the game. Ie, warmup, running, waiting for users.\n     * Use the predefined values defined as STATE_* in this class.\n     */\n    public void setGameState(int gamestate) {\n        this.gamestate = gamestate;\n        System.err.println(\"Notifying observers...:\" + this.gamestate);\n        setChanged();\n        notifyObservers(new Integer(gamestate));\n    }\n\n    /**\n     * Check if enough time has passed since last move.\n     */\n    public boolean isMoveTimeOK(Player player) {\n        if (lastmove.containsKey(player.getId())) {\n            long time = lastmove.get(new Integer(player.getId()));\n            if (time + mintimemove > System.currentTimeMillis())\n                return false;\n        }\n        return true;\n    }\n\n    /**\n     * Update the time when player last made an attack move.\n     */\n    public void updateLastMove(Player player) {\n        lastmove.put(player.getId(), System.currentTimeMillis());\n    }\n\n    /**\n     * Adds the specified player to the list of known players.\n     *\n     * @param p The player that is to be added.\n     */\n    public void addPlayer(Player p) {\n        try {\n            if (players[p.getId()] != null) {\n                /* throw new GameStateException(\"PlayerID exists!\"); */\n                System.err.println(\"GameState.addPlayer(): PlayerID exists!\");\n                return;\n            }\n            players[p.getId()] = p;\n            numOfPlayers++;\n            updateLastMove(p);\n            setChanged();\n            notifyObservers();\n        } catch (IndexOutOfBoundsException e) {\n            System.err.println(\"GameState.addPlayer(): \" + \"PlayerID '\" + p.id + \"' out of the allowed \" + \"range 0 - \" + MAX_PLAYER_LIMIT);\n        } catch (NullPointerException e) {\n            e.printStackTrace(System.err);\n        }\n    }\n\n    /**\n     * Removes the specified player from the list of known players.\n     *\n     * @param p The player that is to be removed.\n     */\n    public void removePlayer(Player p) {\n        try {\n            if (players[p.getId()] == null) {\n                /* throw new GameStateException(\"PlayerID doesn't exist!\"); */\n                System.err.println(\"GameState.removePlayer(): \" + \"PlayerID doesn't exist!\");\n            }\n            if (!p.isBoss()) {\n                part(p.boss, p);\n            }\n            while (p.head != null) {\n                part(p, p.head);\n            }\n            if (gamestate == STATE_WAITING) {\n                players[p.getId()] = null;\n                numOfPlayers--;\n            } else {\n                setDead(p);\n                p.setConnected(false);\n            }\n            setChanged();\n            notifyObservers(p);\n        } catch (IndexOutOfBoundsException e) {\n            System.err.println(\"GameState.removePlayer(): \" + \"PlayerID '\" + p.getId() + \"' out of the allowed \" + \"range 0 - \" + MAX_PLAYER_LIMIT);\n        } catch (NullPointerException e) {\n            e.printStackTrace(System.err);\n        }\n    }\n\n    /**\n     * Adds a party to another party's underling list. This\n     * automatically merges the two parties' gangs.\n     *\n     * @param parent The Party whose gang the child joined.\n     * @param child The Party which joined the parent's gang.\n     */\n    public void join(Party parent, Party child) {\n        try {\n            parent.add(child);\n            setChanged();\n            notifyObservers(child);\n        } catch (NullPointerException e) {\n            System.err.println(\"GameState.join(): parent=\" + parent + \" \" + \"child=\" + child);\n            e.printStackTrace(System.err);\n        }\n    }\n\n    /**\n     * Removes a party from another party's underling list. The\n     * parties that were previously member of the parting party's gang\n     * before the join will also part with it, provided they are still\n     * in the party's underling list.\n     *\n     * @param parent The Party whose gang the child parts from.\n     * @param child The Party which parted the parent's gang.\n     */\n    public void part(Party parent, Party child) {\n        try {\n            parent.remove(child);\n            setChanged();\n            notifyObservers(child);\n        } catch (NullPointerException e) {\n            e.printStackTrace(System.err);\n        }\n    }\n\n    /**\n     * Returns the player at int id. If player id is out of bounds for\n     * the player array, or if no player exists with given id, null is\n     * returned. This is consequent with pidFor(Player p) which\n     * returns -1 when passed a null value.\n     *\n     * @param id The id of the player that is to be found.\n     * @return The Player with the right id. -1 if no player could be\n     * found.\n     */\n    public Player player(int id) {\n        if (id < 0 || id >= MAX_PLAYER_LIMIT)\n            return null;\n        return players[id];\n    }\n\n    public Player[] players() {\n        return players;\n    }\n\n    public void setMe(Player p) {\n        me = p;\n    }\n\n    public Player getMe() {\n        return me;\n    }\n\n    public int getNumOfPlayers() {\n        return numOfPlayers;\n    }\n\n    public void reload() {\n        setChanged();\n        notifyObservers(this);\n    }\n\n    /**\n     * Sets a player's state to dead and increases the dead players\n     * counter.\n     *\n     * @param p The dead Player.\n     * @param deathtime The time of death of the player.\n     */\n    public void setDead(Player p, long deathtime) {\n        if (p != null && !p.isDead()) {\n            numDead++;\n            p.setDead(deathtime);\n            setChanged();\n            notifyObservers(p);\n        }\n    }\n\n    public void setDead(Player p) {\n        setDead(p, System.currentTimeMillis());\n    }\n\n    /**\n     * Updates a player's world coordinates in the specified\n     * direction.\n     *\n     * @param p The player.\n     * @param direction The direction. As specified by the\n     * ANSI-DIRECTIONAL-STANDARD 8-55-155.\n     * @deprecated does nothing in gl gui\n     */\n    public void move(Player p, int direction) {\n        /*\n\tfloat dirx = 0;\n\tfloat diry = 0;\n\t\n\tif ((direction & 0x1) != 0) {\n\t    diry -= Player.MOVE_DISTANCE;\n\t}\n\tif ((direction & 0x2) != 0) {\n\t    dirx -= Player.MOVE_DISTANCE;\n\t}\n\tif ((direction & 0x4) != 0) {\n\t    diry += Player.MOVE_DISTANCE;\n\t}\n\tif ((direction & 0x8) != 0) {\n\t    dirx += Player.MOVE_DISTANCE;\n\t}\n\t\n\tp.setX(p.getX() + dirx);\n\tp.setY(p.getY() + diry);\n\tSystem.err.println(\"New player pos:\" + p.getX() + \",\" + p.getY() + \" \" + dirx + \" \" + diry);\n\tsetChanged();\n\tnotifyObservers(p);\n\t*/\n    }\n\n    /**\n     * Returns number of dead players.\n     *\n     * @return the number of dead players.\n     */\n    public int getNumDead() {\n        return numDead;\n    }\n\n    /**\n     * Returns when the game was started.\n     *\n     * @return The system time when game was started. -1 when game is\n     * not yet started.\n     */\n    public long getGamestart() {\n        return gamestart;\n    }\n\n    public void setGamestart(long l) {\n        gamestart = l;\n    }\n\n    /**\n     * Packs the entire GameState structure into a byte array.\n     * @return array of bytes representing the packed object.\n     */\n    public byte[] pack() {\n        ByteArrayOutputStream buf = new ByteArrayOutputStream();\n        DataOutputStream out = new DataOutputStream(buf);\n        Player p = null;\n        try {\n            int numplayers = numOfPlayers;\n            for (int i = 0; i < players.length; i++) {\n                if (players[i] != null && !players[i].isConnected())\n                    numplayers--;\n            }\n            out.writeShort(MAGIC_NO);\n            out.writeByte(gamestate);\n            out.writeByte(numplayers);\n            for (int i = 0, k = -1; i < numOfPlayers; i++) {\n                // fixme - fix this!\n                // exceptions are caught\n                while (players[++k] == null) ;\n                p = players[k];\n                if (!p.isConnected())\n                    continue;\n                p.pack(out);\n                out.writeByte(pidOf(p.boss));\n                out.writeByte(pidOf(p.next));\n                out.writeByte(pidOf(p.prev));\n                out.writeByte(pidOf(p.head));\n            }\n        } catch (IOException e) {\n            System.err.println(\"GameState.pack(): *** WARNING *** [IO] \" + \"failed to pack data: \" + e.getMessage());\n            return null;\n        } catch (ArrayIndexOutOfBoundsException e) {\n            System.err.println(\"GameState.pack(): *** ERROR *** [IDX] \" + \"failed to pack data: \" + e.getMessage());\n            return null;\n        }\n        return buf.toByteArray();\n    }\n\n    /**\n     * Unpacks the current state from the given array.\n     * @param b the byte array from which to read.\n     */\n    public void unpack(byte[] b) {\n        try {\n            DataInputStream in = new DataInputStream(new ByteArrayInputStream(b));\n            /* read and verify magic number */\n            if (in.readShort() != MAGIC_NO) {\n                /* throw new PackableException(); */\n                System.err.println(\"GameState.unpack(): *** WARNING *** \" + \"data is not of proper type!\");\n                return;\n            }\n            gamestate = in.readByte();\n            // number of players.\n            int n = in.readByte();\n            /* fixme - data should be read to a temporary place and then\n\t       verified, after which it should be commited. */\n            Player p = null;\n            for (int i = 0; i < n; i++) {\n                in.mark(3);\n                // magic number is checked in Player.unpack().\n                in.readShort();\n                p = playerAt(in.readByte());\n                in.reset();\n                if (p.unpack(in)) {\n                    p.boss = playerAt(in.readByte());\n                    p.next = playerAt(in.readByte());\n                    p.prev = playerAt(in.readByte());\n                    p.head = playerAt(in.readByte());\n                } else {\n                    System.err.println(\"GameState.unpack(): *** ERROR *** \" + \"data is incomplete! current state \" + \"is inconsistent!\");\n                }\n            }\n        } catch (EOFException e) {\n            System.err.println(\"GameState.unpack(): *** ERROR *** [EOF] \" + \"data is incomplete! current state is \" + \"inconsistent: \" + e.getMessage());\n        } catch (IOException e) {\n            System.err.println(\"GameState.unpack(): *** ERROR *** [IO] \" + \"unpack data failed! current state is \" + \"inconsistent: \" + e.getMessage());\n        }\n    }\n\n    public int type() {\n        return Packable.GAME_STATE;\n    }\n\n    /**\n     * Returns the player whith the specified id. If a player doesn't exist\n     * with that id doesn't exist, a new player is created and returned. If\n     * id is outside the allowed range, null is returned.\n     *\n     * @return the player with the specified id, or null if id is\n     *         outside allowed range.\n     */\n    private Player playerAt(int id) {\n        Player p = null;\n        try {\n            p = players[id];\n            if (p == null) {\n                p = new Player(id);\n                addPlayer(p);\n            }\n        } catch (ArrayIndexOutOfBoundsException e) {\n            //System.err.println(\"GameState.playerAt(): \" +\n            //\t\t       \"Invalid Player ID specified: \" + id);\n        }\n        return p;\n    }\n\n    /**\n     * Returns the id of the specified player.\n     *\n     * @param p The player for which id is returned.\n     * @return The\n     */\n    private int pidOf(Party p) {\n        if (p == null)\n            return -1;\n        return p.getId();\n    }\n\n    /**\n     * Returns a string representation of GameState. This includes a\n     * full view of the tree.\n     */\n    public String toString() {\n        StringBuffer str = new StringBuffer(\"GameState[\");\n        boolean first = true;\n        for (int i = 0, t = -1; i < numOfPlayers; i++) {\n            while (++t < players.length && players[t] == null) ;\n            if (t >= players.length) {\n                return \"ERR,\" + numOfPlayers + \"]\";\n            }\n            if (first) {\n                str.append(players[t]);\n                first = false;\n            } else {\n                str.append(\" , \" + players[t]);\n            }\n        }\n        return str + \"]\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/state/GameStateTest1.java",
		"test_prompt": "// GameStateTest1.java\npackage state;\n\nimport java.util.*;\nimport java.io.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GameState}.\n* It contains ten unit test cases for the {@link GameState#player(int)} method.\n*/\nclass GameStateTest1 {"
	},
	{
		"original_code": "// GameState.java\n/* $Id: GameState.java,v 1.30 2004/05/05 23:45:19 njursten Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Rasmus Ahlberg <ahlbgerg@kth.se>\n * @version: $Revision: 1.30 $\n *\n */\npackage state;\n\nimport java.util.*;\nimport java.io.*;\n\n/**\n * The state of the game. Includes the gang tree, all players stats\n * and more. Implements Observable for whenever a change in the state\n * is detected.\n */\npublic class GameState extends Observable implements Packable {\n\n    /**\n     * Maximum number of players.\n     */\n    public static final int MAX_PLAYER_LIMIT = 128;\n\n    /**\n     * Number to verify against when unpacking.\n     */\n    private static final short MAGIC_NO = 0x3BBA;\n\n    /**\n     * List of known players.\n     */\n    private Player[] players;\n\n    /**\n     * Total number of known players.\n     */\n    private int numOfPlayers;\n\n    /**\n     * Number of dead players\n     */\n    private int numDead;\n\n    /**\n     * Save when a game is started.\n     */\n    private long gamestart;\n\n    /**\n     * Current state of the game\n     */\n    private int gamestate;\n\n    /**\n     * Waiting for players to join\n     */\n    public static final int STATE_WAITING = 1;\n\n    /**\n     * Warmup time. No attacks possible.\n     */\n    public static final int STATE_WARMUP = 2;\n\n    /**\n     * A game is in progress.\n     */\n    public static final int STATE_PLAYING = 3;\n\n    /**\n     * Game has ended.\n     */\n    public static final int STATE_ENDED = 4;\n\n    /**\n     * The current player for this client. null for the server.\n     */\n    private Player me;\n\n    /**\n     * Minimum time to wait before making next move\n     */\n    private long mintimemove;\n\n    /**\n     * Number of rounds to play\n     */\n    private int totalRounds;\n\n    /**\n     * Current round number\n     */\n    private int currentRound;\n\n    /**\n     * Keep track of when last move of a user was done\n     */\n    private Hashtable<Integer, Long> lastmove;\n\n    /**\n     * Creates a new instance of the GameState class.\n     */\n    public GameState() {\n        this(15000);\n    }\n\n    /**\n     * Creates a new instance of the GameState class.\n     * @param mintimemove How long a user must wait between attack moves.\n     */\n    public GameState(long mintimemove) {\n        players = new Player[MAX_PLAYER_LIMIT];\n        numOfPlayers = 0;\n        numDead = 0;\n        gamestart = 0;\n        gamestate = STATE_WAITING;\n        currentRound = 1;\n        totalRounds = 1;\n        this.mintimemove = mintimemove;\n        lastmove = new Hashtable<Integer, Long>();\n    }\n\n    public void reset(boolean newGame) {\n        numDead = 0;\n        for (int i = 0; i < players.length; i++) {\n            if (players[i] == null)\n                continue;\n            if (!players[i].isConnected()) {\n                if (newGame) {\n                    players[i] = null;\n                    numOfPlayers--;\n                } else {\n                    players[i].reset(newGame);\n                    setDead(players[i]);\n                }\n            } else {\n                players[i].reset(newGame);\n            }\n        }\n        if (newGame)\n            currentRound = 1;\n        lastmove = new Hashtable<Integer, Long>();\n    }\n\n    public void setTotalRounds(int totalRounds) {\n        this.totalRounds = totalRounds;\n    }\n\n    public int getTotalRounds() {\n        return totalRounds;\n    }\n\n    public void setCurrentRound(int currentRound) {\n        this.currentRound = currentRound;\n    }\n\n    public int getCurrentRound() {\n        return currentRound;\n    }\n\n    /**\n     * Returns the state of the game. Ie, warmup, running, waiting for users.\n     * Use the predefined values defined as STATE_* in this class.\n     */\n    public int getGameState() {\n        return gamestate;\n    }\n\n    /**\n     * Sets the state of the game. Ie, warmup, running, waiting for users.\n     * Use the predefined values defined as STATE_* in this class.\n     */\n    public void setGameState(int gamestate) {\n        this.gamestate = gamestate;\n        System.err.println(\"Notifying observers...:\" + this.gamestate);\n        setChanged();\n        notifyObservers(new Integer(gamestate));\n    }\n\n    /**\n     * Check if enough time has passed since last move.\n     */\n    public boolean isMoveTimeOK(Player player) {\n        if (lastmove.containsKey(player.getId())) {\n            long time = lastmove.get(new Integer(player.getId()));\n            if (time + mintimemove > System.currentTimeMillis())\n                return false;\n        }\n        return true;\n    }\n\n    /**\n     * Update the time when player last made an attack move.\n     */\n    public void updateLastMove(Player player) {\n        lastmove.put(player.getId(), System.currentTimeMillis());\n    }\n\n    /**\n     * Adds the specified player to the list of known players.\n     *\n     * @param p The player that is to be added.\n     */\n    public void addPlayer(Player p) {\n        try {\n            if (players[p.getId()] != null) {\n                /* throw new GameStateException(\"PlayerID exists!\"); */\n                System.err.println(\"GameState.addPlayer(): PlayerID exists!\");\n                return;\n            }\n            players[p.getId()] = p;\n            numOfPlayers++;\n            updateLastMove(p);\n            setChanged();\n            notifyObservers();\n        } catch (IndexOutOfBoundsException e) {\n            System.err.println(\"GameState.addPlayer(): \" + \"PlayerID '\" + p.id + \"' out of the allowed \" + \"range 0 - \" + MAX_PLAYER_LIMIT);\n        } catch (NullPointerException e) {\n            e.printStackTrace(System.err);\n        }\n    }\n\n    /**\n     * Removes the specified player from the list of known players.\n     *\n     * @param p The player that is to be removed.\n     */\n    public void removePlayer(Player p) {\n        try {\n            if (players[p.getId()] == null) {\n                /* throw new GameStateException(\"PlayerID doesn't exist!\"); */\n                System.err.println(\"GameState.removePlayer(): \" + \"PlayerID doesn't exist!\");\n            }\n            if (!p.isBoss()) {\n                part(p.boss, p);\n            }\n            while (p.head != null) {\n                part(p, p.head);\n            }\n            if (gamestate == STATE_WAITING) {\n                players[p.getId()] = null;\n                numOfPlayers--;\n            } else {\n                setDead(p);\n                p.setConnected(false);\n            }\n            setChanged();\n            notifyObservers(p);\n        } catch (IndexOutOfBoundsException e) {\n            System.err.println(\"GameState.removePlayer(): \" + \"PlayerID '\" + p.getId() + \"' out of the allowed \" + \"range 0 - \" + MAX_PLAYER_LIMIT);\n        } catch (NullPointerException e) {\n            e.printStackTrace(System.err);\n        }\n    }\n\n    /**\n     * Adds a party to another party's underling list. This\n     * automatically merges the two parties' gangs.\n     *\n     * @param parent The Party whose gang the child joined.\n     * @param child The Party which joined the parent's gang.\n     */\n    public void join(Party parent, Party child) {\n        try {\n            parent.add(child);\n            setChanged();\n            notifyObservers(child);\n        } catch (NullPointerException e) {\n            System.err.println(\"GameState.join(): parent=\" + parent + \" \" + \"child=\" + child);\n            e.printStackTrace(System.err);\n        }\n    }\n\n    /**\n     * Removes a party from another party's underling list. The\n     * parties that were previously member of the parting party's gang\n     * before the join will also part with it, provided they are still\n     * in the party's underling list.\n     *\n     * @param parent The Party whose gang the child parts from.\n     * @param child The Party which parted the parent's gang.\n     */\n    public void part(Party parent, Party child) {\n        try {\n            parent.remove(child);\n            setChanged();\n            notifyObservers(child);\n        } catch (NullPointerException e) {\n            e.printStackTrace(System.err);\n        }\n    }\n\n    /**\n     * Returns the player at int id. If player id is out of bounds for\n     * the player array, or if no player exists with given id, null is\n     * returned. This is consequent with pidFor(Player p) which\n     * returns -1 when passed a null value.\n     *\n     * @param id The id of the player that is to be found.\n     * @return The Player with the right id. -1 if no player could be\n     * found.\n     */\n    public Player player(int id) {\n        if (id < 0 || id >= MAX_PLAYER_LIMIT)\n            return null;\n        return players[id];\n    }\n\n    public Player[] players() {\n        return players;\n    }\n\n    public void setMe(Player p) {\n        me = p;\n    }\n\n    public Player getMe() {\n        return me;\n    }\n\n    public int getNumOfPlayers() {\n        return numOfPlayers;\n    }\n\n    public void reload() {\n        setChanged();\n        notifyObservers(this);\n    }\n\n    /**\n     * Sets a player's state to dead and increases the dead players\n     * counter.\n     *\n     * @param p The dead Player.\n     * @param deathtime The time of death of the player.\n     */\n    public void setDead(Player p, long deathtime) {\n        if (p != null && !p.isDead()) {\n            numDead++;\n            p.setDead(deathtime);\n            setChanged();\n            notifyObservers(p);\n        }\n    }\n\n    public void setDead(Player p) {\n        setDead(p, System.currentTimeMillis());\n    }\n\n    /**\n     * Updates a player's world coordinates in the specified\n     * direction.\n     *\n     * @param p The player.\n     * @param direction The direction. As specified by the\n     * ANSI-DIRECTIONAL-STANDARD 8-55-155.\n     * @deprecated does nothing in gl gui\n     */\n    public void move(Player p, int direction) {\n        /*\n\tfloat dirx = 0;\n\tfloat diry = 0;\n\t\n\tif ((direction & 0x1) != 0) {\n\t    diry -= Player.MOVE_DISTANCE;\n\t}\n\tif ((direction & 0x2) != 0) {\n\t    dirx -= Player.MOVE_DISTANCE;\n\t}\n\tif ((direction & 0x4) != 0) {\n\t    diry += Player.MOVE_DISTANCE;\n\t}\n\tif ((direction & 0x8) != 0) {\n\t    dirx += Player.MOVE_DISTANCE;\n\t}\n\t\n\tp.setX(p.getX() + dirx);\n\tp.setY(p.getY() + diry);\n\tSystem.err.println(\"New player pos:\" + p.getX() + \",\" + p.getY() + \" \" + dirx + \" \" + diry);\n\tsetChanged();\n\tnotifyObservers(p);\n\t*/\n    }\n\n    /**\n     * Returns number of dead players.\n     *\n     * @return the number of dead players.\n     */\n    public int getNumDead() {\n        return numDead;\n    }\n\n    /**\n     * Returns when the game was started.\n     *\n     * @return The system time when game was started. -1 when game is\n     * not yet started.\n     */\n    public long getGamestart() {\n        return gamestart;\n    }\n\n    public void setGamestart(long l) {\n        gamestart = l;\n    }\n\n    /**\n     * Packs the entire GameState structure into a byte array.\n     * @return array of bytes representing the packed object.\n     */\n    public byte[] pack() {\n        ByteArrayOutputStream buf = new ByteArrayOutputStream();\n        DataOutputStream out = new DataOutputStream(buf);\n        Player p = null;\n        try {\n            int numplayers = numOfPlayers;\n            for (int i = 0; i < players.length; i++) {\n                if (players[i] != null && !players[i].isConnected())\n                    numplayers--;\n            }\n            out.writeShort(MAGIC_NO);\n            out.writeByte(gamestate);\n            out.writeByte(numplayers);\n            for (int i = 0, k = -1; i < numOfPlayers; i++) {\n                // fixme - fix this!\n                // exceptions are caught\n                while (players[++k] == null) ;\n                p = players[k];\n                if (!p.isConnected())\n                    continue;\n                p.pack(out);\n                out.writeByte(pidOf(p.boss));\n                out.writeByte(pidOf(p.next));\n                out.writeByte(pidOf(p.prev));\n                out.writeByte(pidOf(p.head));\n            }\n        } catch (IOException e) {\n            System.err.println(\"GameState.pack(): *** WARNING *** [IO] \" + \"failed to pack data: \" + e.getMessage());\n            return null;\n        } catch (ArrayIndexOutOfBoundsException e) {\n            System.err.println(\"GameState.pack(): *** ERROR *** [IDX] \" + \"failed to pack data: \" + e.getMessage());\n            return null;\n        }\n        return buf.toByteArray();\n    }\n\n    /**\n     * Unpacks the current state from the given array.\n     * @param b the byte array from which to read.\n     */\n    public void unpack(byte[] b) {\n        try {\n            DataInputStream in = new DataInputStream(new ByteArrayInputStream(b));\n            /* read and verify magic number */\n            if (in.readShort() != MAGIC_NO) {\n                /* throw new PackableException(); */\n                System.err.println(\"GameState.unpack(): *** WARNING *** \" + \"data is not of proper type!\");\n                return;\n            }\n            gamestate = in.readByte();\n            // number of players.\n            int n = in.readByte();\n            /* fixme - data should be read to a temporary place and then\n\t       verified, after which it should be commited. */\n            Player p = null;\n            for (int i = 0; i < n; i++) {\n                in.mark(3);\n                // magic number is checked in Player.unpack().\n                in.readShort();\n                p = playerAt(in.readByte());\n                in.reset();\n                if (p.unpack(in)) {\n                    p.boss = playerAt(in.readByte());\n                    p.next = playerAt(in.readByte());\n                    p.prev = playerAt(in.readByte());\n                    p.head = playerAt(in.readByte());\n                } else {\n                    System.err.println(\"GameState.unpack(): *** ERROR *** \" + \"data is incomplete! current state \" + \"is inconsistent!\");\n                }\n            }\n        } catch (EOFException e) {\n            System.err.println(\"GameState.unpack(): *** ERROR *** [EOF] \" + \"data is incomplete! current state is \" + \"inconsistent: \" + e.getMessage());\n        } catch (IOException e) {\n            System.err.println(\"GameState.unpack(): *** ERROR *** [IO] \" + \"unpack data failed! current state is \" + \"inconsistent: \" + e.getMessage());\n        }\n    }\n\n    public int type() {\n        return Packable.GAME_STATE;\n    }\n\n    /**\n     * Returns the player whith the specified id. If a player doesn't exist\n     * with that id doesn't exist, a new player is created and returned. If\n     * id is outside the allowed range, null is returned.\n     *\n     * @return the player with the specified id, or null if id is\n     *         outside allowed range.\n     */\n    private Player playerAt(int id) {\n        Player p = null;\n        try {\n            p = players[id];\n            if (p == null) {\n                p = new Player(id);\n                addPlayer(p);\n            }\n        } catch (ArrayIndexOutOfBoundsException e) {\n            //System.err.println(\"GameState.playerAt(): \" +\n            //\t\t       \"Invalid Player ID specified: \" + id);\n        }\n        return p;\n    }\n\n    /**\n     * Returns the id of the specified player.\n     *\n     * @param p The player for which id is returned.\n     * @return The\n     */\n    private int pidOf(Party p) {\n        if (p == null)\n            return -1;\n        return p.getId();\n    }\n\n    /**\n     * Returns a string representation of GameState. This includes a\n     * full view of the tree.\n     */\n    public String toString() {\n        StringBuffer str = new StringBuffer(\"GameState[\");\n        boolean first = true;\n        for (int i = 0, t = -1; i < numOfPlayers; i++) {\n            while (++t < players.length && players[t] == null) ;\n            if (t >= players.length) {\n                return \"ERR,\" + numOfPlayers + \"]\";\n            }\n            if (first) {\n                str.append(players[t]);\n                first = false;\n            } else {\n                str.append(\" , \" + players[t]);\n            }\n        }\n        return str + \"]\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/state/GameStateTest2.java",
		"test_prompt": "// GameStateTest2.java\npackage state;\n\nimport java.util.*;\nimport java.io.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GameState}.\n* It contains ten unit test cases for the {@link GameState#players()} method.\n*/\nclass GameStateTest2 {"
	},
	{
		"original_code": "// GameState.java\n/* $Id: GameState.java,v 1.30 2004/05/05 23:45:19 njursten Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Rasmus Ahlberg <ahlbgerg@kth.se>\n * @version: $Revision: 1.30 $\n *\n */\npackage state;\n\nimport java.util.*;\nimport java.io.*;\n\n/**\n * The state of the game. Includes the gang tree, all players stats\n * and more. Implements Observable for whenever a change in the state\n * is detected.\n */\npublic class GameState extends Observable implements Packable {\n\n    /**\n     * Maximum number of players.\n     */\n    public static final int MAX_PLAYER_LIMIT = 128;\n\n    /**\n     * Number to verify against when unpacking.\n     */\n    private static final short MAGIC_NO = 0x3BBA;\n\n    /**\n     * List of known players.\n     */\n    private Player[] players;\n\n    /**\n     * Total number of known players.\n     */\n    private int numOfPlayers;\n\n    /**\n     * Number of dead players\n     */\n    private int numDead;\n\n    /**\n     * Save when a game is started.\n     */\n    private long gamestart;\n\n    /**\n     * Current state of the game\n     */\n    private int gamestate;\n\n    /**\n     * Waiting for players to join\n     */\n    public static final int STATE_WAITING = 1;\n\n    /**\n     * Warmup time. No attacks possible.\n     */\n    public static final int STATE_WARMUP = 2;\n\n    /**\n     * A game is in progress.\n     */\n    public static final int STATE_PLAYING = 3;\n\n    /**\n     * Game has ended.\n     */\n    public static final int STATE_ENDED = 4;\n\n    /**\n     * The current player for this client. null for the server.\n     */\n    private Player me;\n\n    /**\n     * Minimum time to wait before making next move\n     */\n    private long mintimemove;\n\n    /**\n     * Number of rounds to play\n     */\n    private int totalRounds;\n\n    /**\n     * Current round number\n     */\n    private int currentRound;\n\n    /**\n     * Keep track of when last move of a user was done\n     */\n    private Hashtable<Integer, Long> lastmove;\n\n    /**\n     * Creates a new instance of the GameState class.\n     */\n    public GameState() {\n        this(15000);\n    }\n\n    /**\n     * Creates a new instance of the GameState class.\n     * @param mintimemove How long a user must wait between attack moves.\n     */\n    public GameState(long mintimemove) {\n        players = new Player[MAX_PLAYER_LIMIT];\n        numOfPlayers = 0;\n        numDead = 0;\n        gamestart = 0;\n        gamestate = STATE_WAITING;\n        currentRound = 1;\n        totalRounds = 1;\n        this.mintimemove = mintimemove;\n        lastmove = new Hashtable<Integer, Long>();\n    }\n\n    public void reset(boolean newGame) {\n        numDead = 0;\n        for (int i = 0; i < players.length; i++) {\n            if (players[i] == null)\n                continue;\n            if (!players[i].isConnected()) {\n                if (newGame) {\n                    players[i] = null;\n                    numOfPlayers--;\n                } else {\n                    players[i].reset(newGame);\n                    setDead(players[i]);\n                }\n            } else {\n                players[i].reset(newGame);\n            }\n        }\n        if (newGame)\n            currentRound = 1;\n        lastmove = new Hashtable<Integer, Long>();\n    }\n\n    public void setTotalRounds(int totalRounds) {\n        this.totalRounds = totalRounds;\n    }\n\n    public int getTotalRounds() {\n        return totalRounds;\n    }\n\n    public void setCurrentRound(int currentRound) {\n        this.currentRound = currentRound;\n    }\n\n    public int getCurrentRound() {\n        return currentRound;\n    }\n\n    /**\n     * Returns the state of the game. Ie, warmup, running, waiting for users.\n     * Use the predefined values defined as STATE_* in this class.\n     */\n    public int getGameState() {\n        return gamestate;\n    }\n\n    /**\n     * Sets the state of the game. Ie, warmup, running, waiting for users.\n     * Use the predefined values defined as STATE_* in this class.\n     */\n    public void setGameState(int gamestate) {\n        this.gamestate = gamestate;\n        System.err.println(\"Notifying observers...:\" + this.gamestate);\n        setChanged();\n        notifyObservers(new Integer(gamestate));\n    }\n\n    /**\n     * Check if enough time has passed since last move.\n     */\n    public boolean isMoveTimeOK(Player player) {\n        if (lastmove.containsKey(player.getId())) {\n            long time = lastmove.get(new Integer(player.getId()));\n            if (time + mintimemove > System.currentTimeMillis())\n                return false;\n        }\n        return true;\n    }\n\n    /**\n     * Update the time when player last made an attack move.\n     */\n    public void updateLastMove(Player player) {\n        lastmove.put(player.getId(), System.currentTimeMillis());\n    }\n\n    /**\n     * Adds the specified player to the list of known players.\n     *\n     * @param p The player that is to be added.\n     */\n    public void addPlayer(Player p) {\n        try {\n            if (players[p.getId()] != null) {\n                /* throw new GameStateException(\"PlayerID exists!\"); */\n                System.err.println(\"GameState.addPlayer(): PlayerID exists!\");\n                return;\n            }\n            players[p.getId()] = p;\n            numOfPlayers++;\n            updateLastMove(p);\n            setChanged();\n            notifyObservers();\n        } catch (IndexOutOfBoundsException e) {\n            System.err.println(\"GameState.addPlayer(): \" + \"PlayerID '\" + p.id + \"' out of the allowed \" + \"range 0 - \" + MAX_PLAYER_LIMIT);\n        } catch (NullPointerException e) {\n            e.printStackTrace(System.err);\n        }\n    }\n\n    /**\n     * Removes the specified player from the list of known players.\n     *\n     * @param p The player that is to be removed.\n     */\n    public void removePlayer(Player p) {\n        try {\n            if (players[p.getId()] == null) {\n                /* throw new GameStateException(\"PlayerID doesn't exist!\"); */\n                System.err.println(\"GameState.removePlayer(): \" + \"PlayerID doesn't exist!\");\n            }\n            if (!p.isBoss()) {\n                part(p.boss, p);\n            }\n            while (p.head != null) {\n                part(p, p.head);\n            }\n            if (gamestate == STATE_WAITING) {\n                players[p.getId()] = null;\n                numOfPlayers--;\n            } else {\n                setDead(p);\n                p.setConnected(false);\n            }\n            setChanged();\n            notifyObservers(p);\n        } catch (IndexOutOfBoundsException e) {\n            System.err.println(\"GameState.removePlayer(): \" + \"PlayerID '\" + p.getId() + \"' out of the allowed \" + \"range 0 - \" + MAX_PLAYER_LIMIT);\n        } catch (NullPointerException e) {\n            e.printStackTrace(System.err);\n        }\n    }\n\n    /**\n     * Adds a party to another party's underling list. This\n     * automatically merges the two parties' gangs.\n     *\n     * @param parent The Party whose gang the child joined.\n     * @param child The Party which joined the parent's gang.\n     */\n    public void join(Party parent, Party child) {\n        try {\n            parent.add(child);\n            setChanged();\n            notifyObservers(child);\n        } catch (NullPointerException e) {\n            System.err.println(\"GameState.join(): parent=\" + parent + \" \" + \"child=\" + child);\n            e.printStackTrace(System.err);\n        }\n    }\n\n    /**\n     * Removes a party from another party's underling list. The\n     * parties that were previously member of the parting party's gang\n     * before the join will also part with it, provided they are still\n     * in the party's underling list.\n     *\n     * @param parent The Party whose gang the child parts from.\n     * @param child The Party which parted the parent's gang.\n     */\n    public void part(Party parent, Party child) {\n        try {\n            parent.remove(child);\n            setChanged();\n            notifyObservers(child);\n        } catch (NullPointerException e) {\n            e.printStackTrace(System.err);\n        }\n    }\n\n    /**\n     * Returns the player at int id. If player id is out of bounds for\n     * the player array, or if no player exists with given id, null is\n     * returned. This is consequent with pidFor(Player p) which\n     * returns -1 when passed a null value.\n     *\n     * @param id The id of the player that is to be found.\n     * @return The Player with the right id. -1 if no player could be\n     * found.\n     */\n    public Player player(int id) {\n        if (id < 0 || id >= MAX_PLAYER_LIMIT)\n            return null;\n        return players[id];\n    }\n\n    public Player[] players() {\n        return players;\n    }\n\n    public void setMe(Player p) {\n        me = p;\n    }\n\n    public Player getMe() {\n        return me;\n    }\n\n    public int getNumOfPlayers() {\n        return numOfPlayers;\n    }\n\n    public void reload() {\n        setChanged();\n        notifyObservers(this);\n    }\n\n    /**\n     * Sets a player's state to dead and increases the dead players\n     * counter.\n     *\n     * @param p The dead Player.\n     * @param deathtime The time of death of the player.\n     */\n    public void setDead(Player p, long deathtime) {\n        if (p != null && !p.isDead()) {\n            numDead++;\n            p.setDead(deathtime);\n            setChanged();\n            notifyObservers(p);\n        }\n    }\n\n    public void setDead(Player p) {\n        setDead(p, System.currentTimeMillis());\n    }\n\n    /**\n     * Updates a player's world coordinates in the specified\n     * direction.\n     *\n     * @param p The player.\n     * @param direction The direction. As specified by the\n     * ANSI-DIRECTIONAL-STANDARD 8-55-155.\n     * @deprecated does nothing in gl gui\n     */\n    public void move(Player p, int direction) {\n        /*\n\tfloat dirx = 0;\n\tfloat diry = 0;\n\t\n\tif ((direction & 0x1) != 0) {\n\t    diry -= Player.MOVE_DISTANCE;\n\t}\n\tif ((direction & 0x2) != 0) {\n\t    dirx -= Player.MOVE_DISTANCE;\n\t}\n\tif ((direction & 0x4) != 0) {\n\t    diry += Player.MOVE_DISTANCE;\n\t}\n\tif ((direction & 0x8) != 0) {\n\t    dirx += Player.MOVE_DISTANCE;\n\t}\n\t\n\tp.setX(p.getX() + dirx);\n\tp.setY(p.getY() + diry);\n\tSystem.err.println(\"New player pos:\" + p.getX() + \",\" + p.getY() + \" \" + dirx + \" \" + diry);\n\tsetChanged();\n\tnotifyObservers(p);\n\t*/\n    }\n\n    /**\n     * Returns number of dead players.\n     *\n     * @return the number of dead players.\n     */\n    public int getNumDead() {\n        return numDead;\n    }\n\n    /**\n     * Returns when the game was started.\n     *\n     * @return The system time when game was started. -1 when game is\n     * not yet started.\n     */\n    public long getGamestart() {\n        return gamestart;\n    }\n\n    public void setGamestart(long l) {\n        gamestart = l;\n    }\n\n    /**\n     * Packs the entire GameState structure into a byte array.\n     * @return array of bytes representing the packed object.\n     */\n    public byte[] pack() {\n        ByteArrayOutputStream buf = new ByteArrayOutputStream();\n        DataOutputStream out = new DataOutputStream(buf);\n        Player p = null;\n        try {\n            int numplayers = numOfPlayers;\n            for (int i = 0; i < players.length; i++) {\n                if (players[i] != null && !players[i].isConnected())\n                    numplayers--;\n            }\n            out.writeShort(MAGIC_NO);\n            out.writeByte(gamestate);\n            out.writeByte(numplayers);\n            for (int i = 0, k = -1; i < numOfPlayers; i++) {\n                // fixme - fix this!\n                // exceptions are caught\n                while (players[++k] == null) ;\n                p = players[k];\n                if (!p.isConnected())\n                    continue;\n                p.pack(out);\n                out.writeByte(pidOf(p.boss));\n                out.writeByte(pidOf(p.next));\n                out.writeByte(pidOf(p.prev));\n                out.writeByte(pidOf(p.head));\n            }\n        } catch (IOException e) {\n            System.err.println(\"GameState.pack(): *** WARNING *** [IO] \" + \"failed to pack data: \" + e.getMessage());\n            return null;\n        } catch (ArrayIndexOutOfBoundsException e) {\n            System.err.println(\"GameState.pack(): *** ERROR *** [IDX] \" + \"failed to pack data: \" + e.getMessage());\n            return null;\n        }\n        return buf.toByteArray();\n    }\n\n    /**\n     * Unpacks the current state from the given array.\n     * @param b the byte array from which to read.\n     */\n    public void unpack(byte[] b) {\n        try {\n            DataInputStream in = new DataInputStream(new ByteArrayInputStream(b));\n            /* read and verify magic number */\n            if (in.readShort() != MAGIC_NO) {\n                /* throw new PackableException(); */\n                System.err.println(\"GameState.unpack(): *** WARNING *** \" + \"data is not of proper type!\");\n                return;\n            }\n            gamestate = in.readByte();\n            // number of players.\n            int n = in.readByte();\n            /* fixme - data should be read to a temporary place and then\n\t       verified, after which it should be commited. */\n            Player p = null;\n            for (int i = 0; i < n; i++) {\n                in.mark(3);\n                // magic number is checked in Player.unpack().\n                in.readShort();\n                p = playerAt(in.readByte());\n                in.reset();\n                if (p.unpack(in)) {\n                    p.boss = playerAt(in.readByte());\n                    p.next = playerAt(in.readByte());\n                    p.prev = playerAt(in.readByte());\n                    p.head = playerAt(in.readByte());\n                } else {\n                    System.err.println(\"GameState.unpack(): *** ERROR *** \" + \"data is incomplete! current state \" + \"is inconsistent!\");\n                }\n            }\n        } catch (EOFException e) {\n            System.err.println(\"GameState.unpack(): *** ERROR *** [EOF] \" + \"data is incomplete! current state is \" + \"inconsistent: \" + e.getMessage());\n        } catch (IOException e) {\n            System.err.println(\"GameState.unpack(): *** ERROR *** [IO] \" + \"unpack data failed! current state is \" + \"inconsistent: \" + e.getMessage());\n        }\n    }\n\n    public int type() {\n        return Packable.GAME_STATE;\n    }\n\n    /**\n     * Returns the player whith the specified id. If a player doesn't exist\n     * with that id doesn't exist, a new player is created and returned. If\n     * id is outside the allowed range, null is returned.\n     *\n     * @return the player with the specified id, or null if id is\n     *         outside allowed range.\n     */\n    private Player playerAt(int id) {\n        Player p = null;\n        try {\n            p = players[id];\n            if (p == null) {\n                p = new Player(id);\n                addPlayer(p);\n            }\n        } catch (ArrayIndexOutOfBoundsException e) {\n            //System.err.println(\"GameState.playerAt(): \" +\n            //\t\t       \"Invalid Player ID specified: \" + id);\n        }\n        return p;\n    }\n\n    /**\n     * Returns the id of the specified player.\n     *\n     * @param p The player for which id is returned.\n     * @return The\n     */\n    private int pidOf(Party p) {\n        if (p == null)\n            return -1;\n        return p.getId();\n    }\n\n    /**\n     * Returns a string representation of GameState. This includes a\n     * full view of the tree.\n     */\n    public String toString() {\n        StringBuffer str = new StringBuffer(\"GameState[\");\n        boolean first = true;\n        for (int i = 0, t = -1; i < numOfPlayers; i++) {\n            while (++t < players.length && players[t] == null) ;\n            if (t >= players.length) {\n                return \"ERR,\" + numOfPlayers + \"]\";\n            }\n            if (first) {\n                str.append(players[t]);\n                first = false;\n            } else {\n                str.append(\" , \" + players[t]);\n            }\n        }\n        return str + \"]\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/state/GameStateTest3.java",
		"test_prompt": "// GameStateTest3.java\npackage state;\n\nimport java.util.*;\nimport java.io.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GameState}.\n* It contains ten unit test cases for the {@link GameState#pack()} method.\n*/\nclass GameStateTest3 {"
	},
	{
		"original_code": "// GameState.java\n/* $Id: GameState.java,v 1.30 2004/05/05 23:45:19 njursten Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Rasmus Ahlberg <ahlbgerg@kth.se>\n * @version: $Revision: 1.30 $\n *\n */\npackage state;\n\nimport java.util.*;\nimport java.io.*;\n\n/**\n * The state of the game. Includes the gang tree, all players stats\n * and more. Implements Observable for whenever a change in the state\n * is detected.\n */\npublic class GameState extends Observable implements Packable {\n\n    /**\n     * Maximum number of players.\n     */\n    public static final int MAX_PLAYER_LIMIT = 128;\n\n    /**\n     * Number to verify against when unpacking.\n     */\n    private static final short MAGIC_NO = 0x3BBA;\n\n    /**\n     * List of known players.\n     */\n    private Player[] players;\n\n    /**\n     * Total number of known players.\n     */\n    private int numOfPlayers;\n\n    /**\n     * Number of dead players\n     */\n    private int numDead;\n\n    /**\n     * Save when a game is started.\n     */\n    private long gamestart;\n\n    /**\n     * Current state of the game\n     */\n    private int gamestate;\n\n    /**\n     * Waiting for players to join\n     */\n    public static final int STATE_WAITING = 1;\n\n    /**\n     * Warmup time. No attacks possible.\n     */\n    public static final int STATE_WARMUP = 2;\n\n    /**\n     * A game is in progress.\n     */\n    public static final int STATE_PLAYING = 3;\n\n    /**\n     * Game has ended.\n     */\n    public static final int STATE_ENDED = 4;\n\n    /**\n     * The current player for this client. null for the server.\n     */\n    private Player me;\n\n    /**\n     * Minimum time to wait before making next move\n     */\n    private long mintimemove;\n\n    /**\n     * Number of rounds to play\n     */\n    private int totalRounds;\n\n    /**\n     * Current round number\n     */\n    private int currentRound;\n\n    /**\n     * Keep track of when last move of a user was done\n     */\n    private Hashtable<Integer, Long> lastmove;\n\n    /**\n     * Creates a new instance of the GameState class.\n     */\n    public GameState() {\n        this(15000);\n    }\n\n    /**\n     * Creates a new instance of the GameState class.\n     * @param mintimemove How long a user must wait between attack moves.\n     */\n    public GameState(long mintimemove) {\n        players = new Player[MAX_PLAYER_LIMIT];\n        numOfPlayers = 0;\n        numDead = 0;\n        gamestart = 0;\n        gamestate = STATE_WAITING;\n        currentRound = 1;\n        totalRounds = 1;\n        this.mintimemove = mintimemove;\n        lastmove = new Hashtable<Integer, Long>();\n    }\n\n    public void reset(boolean newGame) {\n        numDead = 0;\n        for (int i = 0; i < players.length; i++) {\n            if (players[i] == null)\n                continue;\n            if (!players[i].isConnected()) {\n                if (newGame) {\n                    players[i] = null;\n                    numOfPlayers--;\n                } else {\n                    players[i].reset(newGame);\n                    setDead(players[i]);\n                }\n            } else {\n                players[i].reset(newGame);\n            }\n        }\n        if (newGame)\n            currentRound = 1;\n        lastmove = new Hashtable<Integer, Long>();\n    }\n\n    public void setTotalRounds(int totalRounds) {\n        this.totalRounds = totalRounds;\n    }\n\n    public int getTotalRounds() {\n        return totalRounds;\n    }\n\n    public void setCurrentRound(int currentRound) {\n        this.currentRound = currentRound;\n    }\n\n    public int getCurrentRound() {\n        return currentRound;\n    }\n\n    /**\n     * Returns the state of the game. Ie, warmup, running, waiting for users.\n     * Use the predefined values defined as STATE_* in this class.\n     */\n    public int getGameState() {\n        return gamestate;\n    }\n\n    /**\n     * Sets the state of the game. Ie, warmup, running, waiting for users.\n     * Use the predefined values defined as STATE_* in this class.\n     */\n    public void setGameState(int gamestate) {\n        this.gamestate = gamestate;\n        System.err.println(\"Notifying observers...:\" + this.gamestate);\n        setChanged();\n        notifyObservers(new Integer(gamestate));\n    }\n\n    /**\n     * Check if enough time has passed since last move.\n     */\n    public boolean isMoveTimeOK(Player player) {\n        if (lastmove.containsKey(player.getId())) {\n            long time = lastmove.get(new Integer(player.getId()));\n            if (time + mintimemove > System.currentTimeMillis())\n                return false;\n        }\n        return true;\n    }\n\n    /**\n     * Update the time when player last made an attack move.\n     */\n    public void updateLastMove(Player player) {\n        lastmove.put(player.getId(), System.currentTimeMillis());\n    }\n\n    /**\n     * Adds the specified player to the list of known players.\n     *\n     * @param p The player that is to be added.\n     */\n    public void addPlayer(Player p) {\n        try {\n            if (players[p.getId()] != null) {\n                /* throw new GameStateException(\"PlayerID exists!\"); */\n                System.err.println(\"GameState.addPlayer(): PlayerID exists!\");\n                return;\n            }\n            players[p.getId()] = p;\n            numOfPlayers++;\n            updateLastMove(p);\n            setChanged();\n            notifyObservers();\n        } catch (IndexOutOfBoundsException e) {\n            System.err.println(\"GameState.addPlayer(): \" + \"PlayerID '\" + p.id + \"' out of the allowed \" + \"range 0 - \" + MAX_PLAYER_LIMIT);\n        } catch (NullPointerException e) {\n            e.printStackTrace(System.err);\n        }\n    }\n\n    /**\n     * Removes the specified player from the list of known players.\n     *\n     * @param p The player that is to be removed.\n     */\n    public void removePlayer(Player p) {\n        try {\n            if (players[p.getId()] == null) {\n                /* throw new GameStateException(\"PlayerID doesn't exist!\"); */\n                System.err.println(\"GameState.removePlayer(): \" + \"PlayerID doesn't exist!\");\n            }\n            if (!p.isBoss()) {\n                part(p.boss, p);\n            }\n            while (p.head != null) {\n                part(p, p.head);\n            }\n            if (gamestate == STATE_WAITING) {\n                players[p.getId()] = null;\n                numOfPlayers--;\n            } else {\n                setDead(p);\n                p.setConnected(false);\n            }\n            setChanged();\n            notifyObservers(p);\n        } catch (IndexOutOfBoundsException e) {\n            System.err.println(\"GameState.removePlayer(): \" + \"PlayerID '\" + p.getId() + \"' out of the allowed \" + \"range 0 - \" + MAX_PLAYER_LIMIT);\n        } catch (NullPointerException e) {\n            e.printStackTrace(System.err);\n        }\n    }\n\n    /**\n     * Adds a party to another party's underling list. This\n     * automatically merges the two parties' gangs.\n     *\n     * @param parent The Party whose gang the child joined.\n     * @param child The Party which joined the parent's gang.\n     */\n    public void join(Party parent, Party child) {\n        try {\n            parent.add(child);\n            setChanged();\n            notifyObservers(child);\n        } catch (NullPointerException e) {\n            System.err.println(\"GameState.join(): parent=\" + parent + \" \" + \"child=\" + child);\n            e.printStackTrace(System.err);\n        }\n    }\n\n    /**\n     * Removes a party from another party's underling list. The\n     * parties that were previously member of the parting party's gang\n     * before the join will also part with it, provided they are still\n     * in the party's underling list.\n     *\n     * @param parent The Party whose gang the child parts from.\n     * @param child The Party which parted the parent's gang.\n     */\n    public void part(Party parent, Party child) {\n        try {\n            parent.remove(child);\n            setChanged();\n            notifyObservers(child);\n        } catch (NullPointerException e) {\n            e.printStackTrace(System.err);\n        }\n    }\n\n    /**\n     * Returns the player at int id. If player id is out of bounds for\n     * the player array, or if no player exists with given id, null is\n     * returned. This is consequent with pidFor(Player p) which\n     * returns -1 when passed a null value.\n     *\n     * @param id The id of the player that is to be found.\n     * @return The Player with the right id. -1 if no player could be\n     * found.\n     */\n    public Player player(int id) {\n        if (id < 0 || id >= MAX_PLAYER_LIMIT)\n            return null;\n        return players[id];\n    }\n\n    public Player[] players() {\n        return players;\n    }\n\n    public void setMe(Player p) {\n        me = p;\n    }\n\n    public Player getMe() {\n        return me;\n    }\n\n    public int getNumOfPlayers() {\n        return numOfPlayers;\n    }\n\n    public void reload() {\n        setChanged();\n        notifyObservers(this);\n    }\n\n    /**\n     * Sets a player's state to dead and increases the dead players\n     * counter.\n     *\n     * @param p The dead Player.\n     * @param deathtime The time of death of the player.\n     */\n    public void setDead(Player p, long deathtime) {\n        if (p != null && !p.isDead()) {\n            numDead++;\n            p.setDead(deathtime);\n            setChanged();\n            notifyObservers(p);\n        }\n    }\n\n    public void setDead(Player p) {\n        setDead(p, System.currentTimeMillis());\n    }\n\n    /**\n     * Updates a player's world coordinates in the specified\n     * direction.\n     *\n     * @param p The player.\n     * @param direction The direction. As specified by the\n     * ANSI-DIRECTIONAL-STANDARD 8-55-155.\n     * @deprecated does nothing in gl gui\n     */\n    public void move(Player p, int direction) {\n        /*\n\tfloat dirx = 0;\n\tfloat diry = 0;\n\t\n\tif ((direction & 0x1) != 0) {\n\t    diry -= Player.MOVE_DISTANCE;\n\t}\n\tif ((direction & 0x2) != 0) {\n\t    dirx -= Player.MOVE_DISTANCE;\n\t}\n\tif ((direction & 0x4) != 0) {\n\t    diry += Player.MOVE_DISTANCE;\n\t}\n\tif ((direction & 0x8) != 0) {\n\t    dirx += Player.MOVE_DISTANCE;\n\t}\n\t\n\tp.setX(p.getX() + dirx);\n\tp.setY(p.getY() + diry);\n\tSystem.err.println(\"New player pos:\" + p.getX() + \",\" + p.getY() + \" \" + dirx + \" \" + diry);\n\tsetChanged();\n\tnotifyObservers(p);\n\t*/\n    }\n\n    /**\n     * Returns number of dead players.\n     *\n     * @return the number of dead players.\n     */\n    public int getNumDead() {\n        return numDead;\n    }\n\n    /**\n     * Returns when the game was started.\n     *\n     * @return The system time when game was started. -1 when game is\n     * not yet started.\n     */\n    public long getGamestart() {\n        return gamestart;\n    }\n\n    public void setGamestart(long l) {\n        gamestart = l;\n    }\n\n    /**\n     * Packs the entire GameState structure into a byte array.\n     * @return array of bytes representing the packed object.\n     */\n    public byte[] pack() {\n        ByteArrayOutputStream buf = new ByteArrayOutputStream();\n        DataOutputStream out = new DataOutputStream(buf);\n        Player p = null;\n        try {\n            int numplayers = numOfPlayers;\n            for (int i = 0; i < players.length; i++) {\n                if (players[i] != null && !players[i].isConnected())\n                    numplayers--;\n            }\n            out.writeShort(MAGIC_NO);\n            out.writeByte(gamestate);\n            out.writeByte(numplayers);\n            for (int i = 0, k = -1; i < numOfPlayers; i++) {\n                // fixme - fix this!\n                // exceptions are caught\n                while (players[++k] == null) ;\n                p = players[k];\n                if (!p.isConnected())\n                    continue;\n                p.pack(out);\n                out.writeByte(pidOf(p.boss));\n                out.writeByte(pidOf(p.next));\n                out.writeByte(pidOf(p.prev));\n                out.writeByte(pidOf(p.head));\n            }\n        } catch (IOException e) {\n            System.err.println(\"GameState.pack(): *** WARNING *** [IO] \" + \"failed to pack data: \" + e.getMessage());\n            return null;\n        } catch (ArrayIndexOutOfBoundsException e) {\n            System.err.println(\"GameState.pack(): *** ERROR *** [IDX] \" + \"failed to pack data: \" + e.getMessage());\n            return null;\n        }\n        return buf.toByteArray();\n    }\n\n    /**\n     * Unpacks the current state from the given array.\n     * @param b the byte array from which to read.\n     */\n    public void unpack(byte[] b) {\n        try {\n            DataInputStream in = new DataInputStream(new ByteArrayInputStream(b));\n            /* read and verify magic number */\n            if (in.readShort() != MAGIC_NO) {\n                /* throw new PackableException(); */\n                System.err.println(\"GameState.unpack(): *** WARNING *** \" + \"data is not of proper type!\");\n                return;\n            }\n            gamestate = in.readByte();\n            // number of players.\n            int n = in.readByte();\n            /* fixme - data should be read to a temporary place and then\n\t       verified, after which it should be commited. */\n            Player p = null;\n            for (int i = 0; i < n; i++) {\n                in.mark(3);\n                // magic number is checked in Player.unpack().\n                in.readShort();\n                p = playerAt(in.readByte());\n                in.reset();\n                if (p.unpack(in)) {\n                    p.boss = playerAt(in.readByte());\n                    p.next = playerAt(in.readByte());\n                    p.prev = playerAt(in.readByte());\n                    p.head = playerAt(in.readByte());\n                } else {\n                    System.err.println(\"GameState.unpack(): *** ERROR *** \" + \"data is incomplete! current state \" + \"is inconsistent!\");\n                }\n            }\n        } catch (EOFException e) {\n            System.err.println(\"GameState.unpack(): *** ERROR *** [EOF] \" + \"data is incomplete! current state is \" + \"inconsistent: \" + e.getMessage());\n        } catch (IOException e) {\n            System.err.println(\"GameState.unpack(): *** ERROR *** [IO] \" + \"unpack data failed! current state is \" + \"inconsistent: \" + e.getMessage());\n        }\n    }\n\n    public int type() {\n        return Packable.GAME_STATE;\n    }\n\n    /**\n     * Returns the player whith the specified id. If a player doesn't exist\n     * with that id doesn't exist, a new player is created and returned. If\n     * id is outside the allowed range, null is returned.\n     *\n     * @return the player with the specified id, or null if id is\n     *         outside allowed range.\n     */\n    private Player playerAt(int id) {\n        Player p = null;\n        try {\n            p = players[id];\n            if (p == null) {\n                p = new Player(id);\n                addPlayer(p);\n            }\n        } catch (ArrayIndexOutOfBoundsException e) {\n            //System.err.println(\"GameState.playerAt(): \" +\n            //\t\t       \"Invalid Player ID specified: \" + id);\n        }\n        return p;\n    }\n\n    /**\n     * Returns the id of the specified player.\n     *\n     * @param p The player for which id is returned.\n     * @return The\n     */\n    private int pidOf(Party p) {\n        if (p == null)\n            return -1;\n        return p.getId();\n    }\n\n    /**\n     * Returns a string representation of GameState. This includes a\n     * full view of the tree.\n     */\n    public String toString() {\n        StringBuffer str = new StringBuffer(\"GameState[\");\n        boolean first = true;\n        for (int i = 0, t = -1; i < numOfPlayers; i++) {\n            while (++t < players.length && players[t] == null) ;\n            if (t >= players.length) {\n                return \"ERR,\" + numOfPlayers + \"]\";\n            }\n            if (first) {\n                str.append(players[t]);\n                first = false;\n            } else {\n                str.append(\" , \" + players[t]);\n            }\n        }\n        return str + \"]\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/state/GameStateTest4.java",
		"test_prompt": "// GameStateTest4.java\npackage state;\n\nimport java.util.*;\nimport java.io.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GameState}.\n* It contains ten unit test cases for the {@link GameState#type()} method.\n*/\nclass GameStateTest4 {"
	},
	{
		"original_code": "// VisibilityMap.java\n/* VisibilityMap.java v0.1 (06/17/2002)\n *\n * Copyright (C) 2002, Joel Andersson <bja@kth.se>\n * \n * This software is hereby expressly placed in the public domain.\n * Share and enjoy.\n */\npackage map;\n\nimport java.util.Vector;\n\npublic abstract class VisibilityMap extends AbstractMap {\n\n    /**\n     * Creates a new instance of this class with the specified\n     * attributes.\n     *\n     * @param min the minimum cost of accessing a node.\n     * @param max the maximum cost of accessing a node.\n     */\n    protected VisibilityMap(float min, float max) {\n        super(min, max);\n    }\n\n    /**\n     * Determines the line of sight, if any, between the source and\n     * target nodes.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a line of sight is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the start and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws PathNotFoundException if no such path could be found.\n     * @throws NullPointerException if either start or finish is null.\n     */\n    public Path lineOfSight(Node source, Node target) throws PathNotFoundException {\n        float dx = target.getX() - source.getX();\n        float dy = target.getY() - source.getY();\n        int signx = dx < 0 ? -1 : 1;\n        int signy = dy < 0 ? -1 : 1;\n        // Absolute value of dx and dy.\n        int ax = (int) (signx * dx);\n        int ay = (int) (signy * dy);\n        // Determine the slope of the straight line from source to\n        // target. The slope is given as a function of the variable\n        // that has the least angle.\n        float kx = (ax > ay) ? signx : ((float) dx / (float) dy) * signy;\n        float ky = (ax > ay) ? ((float) dy / (float) dx) * signx : signy;\n        int maxlen = (int) (ax > ay ? ax : ay);\n        Node p = source;\n        reset();\n        for (int i = 1; i < maxlen; i++) {\n            Node n = getNodeAt((source.getX() + i * kx), (source.getY() + i * ky), source.getZ());\n            if (n.getCost() >= maxCost) {\n                throw new PathNotFoundException();\n            }\n            n.setParent(p);\n            p = n;\n        }\n        return new DefaultPath(p);\n    }\n\n    /**\n     * Determines the field of vision from the source in the given\n     * direction and with the given spread, perf, and distance.\n     *\n     * @param source The node from which to start.\n     * @param direction The direction in degrees of the line of sight.\n     * @param spread The spread in degrees of the field.\n     * @param perf The perf of the field.\n     * @param distance The maximum distance.\n     *\n     * @throws NullPointerException if source is null.\n     */\n    public void fieldOfVision(Node source, float direction, float spread, float perf, float distance) {\n        float alpha = (float) (direction * Math.PI / 180);\n        float delta = (float) (spread * Math.PI / 180);\n        Vector open = new Vector();\n        reset();\n        source.setVisibility(1.0f);\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(0);\n            Node[] child = current.getAllChildren();\n            current.setOpen(true);\n            for (int i = 0; i < child.length; i++) {\n                float dx = child[i].getX() - source.getX();\n                float dy = child[i].getY() - source.getY();\n                // XXX - this is not working! Cells are not correctly\n                // vis:ed if dx > 0. Not sure why.\n                float beta = (float) Math.atan2(-dy, dx);\n                beta = beta < 0 ? (float) (2 * Math.PI + beta) : beta;\n                if (Math.sqrt(dx * dx + dy * dy) > distance) {\n                    continue;\n                }\n                if (beta < Math.min(alpha + delta, alpha - delta)) {\n                    continue;\n                }\n                if (beta > Math.max(alpha + delta, alpha - delta)) {\n                    continue;\n                }\n                if (child[i].isOpen() || child[i].isClosed()) {\n                    continue;\n                }\n                if (isVisible(child[i], source)) {\n                    child[i].setOpen(true);\n                    child[i].setVisibility(1.0f);\n                    open.add(child[i]);\n                }\n            }\n            current.setClosed(true);\n        }\n    }\n\n    /**\n     * Determines all nodes that are visible from source and are\n     * within the given limit. A Node is considered visible if\n     * there exist straight line path leading to it from the source.\n     *\n     * @param source the source node.\n     * @param limit the limit of the search.\n     */\n    public void fieldOfVision(Node source, float limit) {\n        Vector open = new Vector();\n        reset();\n        source.setTotal(0);\n        source.setVisibility(1.0f);\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(0);\n            Node[] child = current.getAllChildren();\n            if (current.getTotal() > limit) {\n                continue;\n            }\n            for (int i = 0; i < child.length; i++) {\n                if (child[i] == null || child[i].isClosed()) {\n                    continue;\n                }\n                if (!child[i].isOpen() && isVisible(child[i], source)) {\n                    child[i].setTotal(heuristic(child[i], source));\n                    child[i].setVisibility((limit - child[i].getTotal()) / limit);\n                    child[i].setOpen(true);\n                    open.add(child[i]);\n                }\n            }\n            current.setClosed(true);\n        }\n    }\n\n    /**\n     * Determines whether the target node is visible from the\n     * source node (ie. there is a straight line connecting the\n     * nodes which does not fall on any obstacles.)\n     *\n     * @param source the source node.\n     * @param target the target node.\n     *\n     * @return true if the target node is visible from the source.\n     */\n    public boolean isVisible(Node source, Node target) {\n        float dx = target.getX() - source.getX();\n        float dy = target.getY() - source.getY();\n        int signx = dx < 0 ? -1 : 1;\n        int signy = dy < 0 ? -1 : 1;\n        float ax = signx * dx;\n        float ay = signy * dy;\n        // As we are using tiles with an extension in the plane to\n        // display points in the grid there is a certain error in\n        // the calculated line of sight that must be considered.\n        //\n        //    dx  dy  (dx < dy) | cx cy\n        //   -------------------+-------\n        //     -   -    false   |  0  1\n        //     -   -     true   |  1  0\n        //     -   +    false   |  0  0\n        //     -   +     true   |  1  1\n        //     +   -    false   |  1  1\n        //     +   -     true   |  0  1\n        //     +   +    false   |  1  0\n        //     +   +     true   |  0  1\n        float kx = (ax > ay) ? signx : ((float) dx / (float) dy) * signy;\n        float ky = (ax > ay) ? ((float) dy / (float) dx) * signx : signy;\n        int maxlen = (int) (ax > ay ? ax : ay);\n        for (int i = 1; i < maxlen; i++) {\n            Node n = getNodeAt((source.getX() + i * kx + .5f), (source.getY() + i * ky + .5f), (source.getZ()));\n            if (n.getCost() >= maxCost) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Straightens the given path by repeatedly removing all\n     * intermediet nodes that exist between two nodes that are\n     * visible from each other.\n     *\n     * @param path the path to be straighten out.\n     */\n    public Path coalescePath(Path path) {\n        if (path.isEmpty()) {\n            return path;\n        }\n        // fixme - remove unnecessary code.\n        Node[] p1 = path.asNodeArray();\n        //smoothPath(p1, 0, p1.length-1, 4);\n        Node[] p2 = p1;\n        Node p = p2[p2.length - 1];\n        Node q = p.getParent();\n        // Coalesce neighboring nodes that are visible from each other.\n        // Greedy algorithm to coalesce a chain of visible nodes.\n        while (q != null) {\n            Node t = q;\n            while (q != null && isVisible(p, q)) {\n                p.setParent(q);\n                t = q;\n                q = q.getParent();\n            }\n            if (q != null) {\n                p = t;\n                q = q.getParent();\n            }\n        }\n        return new DefaultPath(p2[p2.length - 1]);\n    }\n\n    /**\n     * Straightens a subinterval of the given path by repeatedly\n     * removing all intermediet nodes that exist between two nodes\n     * that are visible from each other.\n     *\n     * @param path the path to be straighten out.\n     * @param low the low end of the subinterval.\n     * @param high the high end of subinterval.\n     * @param strength the number of iterations.\n     */\n    public Node[] smoothPath(Node[] path, int low, int high, int strength) {\n        if ((low < 0 || high > path.length) && low < high || strength < 0) {\n            return path;\n        }\n        if (isVisible(path[low], path[high])) {\n            if (path[high] != path[low]) {\n                path[high].setParent(path[low]);\n            }\n        } else {\n            smoothPath(path, low, ((low + high) / 2) - 1, strength - 1);\n            smoothPath(path, ((low + high) / 2), high, strength - 1);\n        }\n        return path;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/map/VisibilityMapTest0.java",
		"test_prompt": "// VisibilityMapTest0.java\npackage map;\n\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link VisibilityMap}.\n* It contains ten unit test cases for the {@link VisibilityMap#lineOfSight(Node, Node)} method.\n*/\nclass VisibilityMapTest0 {"
	},
	{
		"original_code": "// VisibilityMap.java\n/* VisibilityMap.java v0.1 (06/17/2002)\n *\n * Copyright (C) 2002, Joel Andersson <bja@kth.se>\n * \n * This software is hereby expressly placed in the public domain.\n * Share and enjoy.\n */\npackage map;\n\nimport java.util.Vector;\n\npublic abstract class VisibilityMap extends AbstractMap {\n\n    /**\n     * Creates a new instance of this class with the specified\n     * attributes.\n     *\n     * @param min the minimum cost of accessing a node.\n     * @param max the maximum cost of accessing a node.\n     */\n    protected VisibilityMap(float min, float max) {\n        super(min, max);\n    }\n\n    /**\n     * Determines the line of sight, if any, between the source and\n     * target nodes.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a line of sight is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the start and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws PathNotFoundException if no such path could be found.\n     * @throws NullPointerException if either start or finish is null.\n     */\n    public Path lineOfSight(Node source, Node target) throws PathNotFoundException {\n        float dx = target.getX() - source.getX();\n        float dy = target.getY() - source.getY();\n        int signx = dx < 0 ? -1 : 1;\n        int signy = dy < 0 ? -1 : 1;\n        // Absolute value of dx and dy.\n        int ax = (int) (signx * dx);\n        int ay = (int) (signy * dy);\n        // Determine the slope of the straight line from source to\n        // target. The slope is given as a function of the variable\n        // that has the least angle.\n        float kx = (ax > ay) ? signx : ((float) dx / (float) dy) * signy;\n        float ky = (ax > ay) ? ((float) dy / (float) dx) * signx : signy;\n        int maxlen = (int) (ax > ay ? ax : ay);\n        Node p = source;\n        reset();\n        for (int i = 1; i < maxlen; i++) {\n            Node n = getNodeAt((source.getX() + i * kx), (source.getY() + i * ky), source.getZ());\n            if (n.getCost() >= maxCost) {\n                throw new PathNotFoundException();\n            }\n            n.setParent(p);\n            p = n;\n        }\n        return new DefaultPath(p);\n    }\n\n    /**\n     * Determines the field of vision from the source in the given\n     * direction and with the given spread, perf, and distance.\n     *\n     * @param source The node from which to start.\n     * @param direction The direction in degrees of the line of sight.\n     * @param spread The spread in degrees of the field.\n     * @param perf The perf of the field.\n     * @param distance The maximum distance.\n     *\n     * @throws NullPointerException if source is null.\n     */\n    public void fieldOfVision(Node source, float direction, float spread, float perf, float distance) {\n        float alpha = (float) (direction * Math.PI / 180);\n        float delta = (float) (spread * Math.PI / 180);\n        Vector open = new Vector();\n        reset();\n        source.setVisibility(1.0f);\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(0);\n            Node[] child = current.getAllChildren();\n            current.setOpen(true);\n            for (int i = 0; i < child.length; i++) {\n                float dx = child[i].getX() - source.getX();\n                float dy = child[i].getY() - source.getY();\n                // XXX - this is not working! Cells are not correctly\n                // vis:ed if dx > 0. Not sure why.\n                float beta = (float) Math.atan2(-dy, dx);\n                beta = beta < 0 ? (float) (2 * Math.PI + beta) : beta;\n                if (Math.sqrt(dx * dx + dy * dy) > distance) {\n                    continue;\n                }\n                if (beta < Math.min(alpha + delta, alpha - delta)) {\n                    continue;\n                }\n                if (beta > Math.max(alpha + delta, alpha - delta)) {\n                    continue;\n                }\n                if (child[i].isOpen() || child[i].isClosed()) {\n                    continue;\n                }\n                if (isVisible(child[i], source)) {\n                    child[i].setOpen(true);\n                    child[i].setVisibility(1.0f);\n                    open.add(child[i]);\n                }\n            }\n            current.setClosed(true);\n        }\n    }\n\n    /**\n     * Determines all nodes that are visible from source and are\n     * within the given limit. A Node is considered visible if\n     * there exist straight line path leading to it from the source.\n     *\n     * @param source the source node.\n     * @param limit the limit of the search.\n     */\n    public void fieldOfVision(Node source, float limit) {\n        Vector open = new Vector();\n        reset();\n        source.setTotal(0);\n        source.setVisibility(1.0f);\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(0);\n            Node[] child = current.getAllChildren();\n            if (current.getTotal() > limit) {\n                continue;\n            }\n            for (int i = 0; i < child.length; i++) {\n                if (child[i] == null || child[i].isClosed()) {\n                    continue;\n                }\n                if (!child[i].isOpen() && isVisible(child[i], source)) {\n                    child[i].setTotal(heuristic(child[i], source));\n                    child[i].setVisibility((limit - child[i].getTotal()) / limit);\n                    child[i].setOpen(true);\n                    open.add(child[i]);\n                }\n            }\n            current.setClosed(true);\n        }\n    }\n\n    /**\n     * Determines whether the target node is visible from the\n     * source node (ie. there is a straight line connecting the\n     * nodes which does not fall on any obstacles.)\n     *\n     * @param source the source node.\n     * @param target the target node.\n     *\n     * @return true if the target node is visible from the source.\n     */\n    public boolean isVisible(Node source, Node target) {\n        float dx = target.getX() - source.getX();\n        float dy = target.getY() - source.getY();\n        int signx = dx < 0 ? -1 : 1;\n        int signy = dy < 0 ? -1 : 1;\n        float ax = signx * dx;\n        float ay = signy * dy;\n        // As we are using tiles with an extension in the plane to\n        // display points in the grid there is a certain error in\n        // the calculated line of sight that must be considered.\n        //\n        //    dx  dy  (dx < dy) | cx cy\n        //   -------------------+-------\n        //     -   -    false   |  0  1\n        //     -   -     true   |  1  0\n        //     -   +    false   |  0  0\n        //     -   +     true   |  1  1\n        //     +   -    false   |  1  1\n        //     +   -     true   |  0  1\n        //     +   +    false   |  1  0\n        //     +   +     true   |  0  1\n        float kx = (ax > ay) ? signx : ((float) dx / (float) dy) * signy;\n        float ky = (ax > ay) ? ((float) dy / (float) dx) * signx : signy;\n        int maxlen = (int) (ax > ay ? ax : ay);\n        for (int i = 1; i < maxlen; i++) {\n            Node n = getNodeAt((source.getX() + i * kx + .5f), (source.getY() + i * ky + .5f), (source.getZ()));\n            if (n.getCost() >= maxCost) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Straightens the given path by repeatedly removing all\n     * intermediet nodes that exist between two nodes that are\n     * visible from each other.\n     *\n     * @param path the path to be straighten out.\n     */\n    public Path coalescePath(Path path) {\n        if (path.isEmpty()) {\n            return path;\n        }\n        // fixme - remove unnecessary code.\n        Node[] p1 = path.asNodeArray();\n        //smoothPath(p1, 0, p1.length-1, 4);\n        Node[] p2 = p1;\n        Node p = p2[p2.length - 1];\n        Node q = p.getParent();\n        // Coalesce neighboring nodes that are visible from each other.\n        // Greedy algorithm to coalesce a chain of visible nodes.\n        while (q != null) {\n            Node t = q;\n            while (q != null && isVisible(p, q)) {\n                p.setParent(q);\n                t = q;\n                q = q.getParent();\n            }\n            if (q != null) {\n                p = t;\n                q = q.getParent();\n            }\n        }\n        return new DefaultPath(p2[p2.length - 1]);\n    }\n\n    /**\n     * Straightens a subinterval of the given path by repeatedly\n     * removing all intermediet nodes that exist between two nodes\n     * that are visible from each other.\n     *\n     * @param path the path to be straighten out.\n     * @param low the low end of the subinterval.\n     * @param high the high end of subinterval.\n     * @param strength the number of iterations.\n     */\n    public Node[] smoothPath(Node[] path, int low, int high, int strength) {\n        if ((low < 0 || high > path.length) && low < high || strength < 0) {\n            return path;\n        }\n        if (isVisible(path[low], path[high])) {\n            if (path[high] != path[low]) {\n                path[high].setParent(path[low]);\n            }\n        } else {\n            smoothPath(path, low, ((low + high) / 2) - 1, strength - 1);\n            smoothPath(path, ((low + high) / 2), high, strength - 1);\n        }\n        return path;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/map/VisibilityMapTest1.java",
		"test_prompt": "// VisibilityMapTest1.java\npackage map;\n\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link VisibilityMap}.\n* It contains ten unit test cases for the {@link VisibilityMap#isVisible(Node, Node)} method.\n*/\nclass VisibilityMapTest1 {"
	},
	{
		"original_code": "// VisibilityMap.java\n/* VisibilityMap.java v0.1 (06/17/2002)\n *\n * Copyright (C) 2002, Joel Andersson <bja@kth.se>\n * \n * This software is hereby expressly placed in the public domain.\n * Share and enjoy.\n */\npackage map;\n\nimport java.util.Vector;\n\npublic abstract class VisibilityMap extends AbstractMap {\n\n    /**\n     * Creates a new instance of this class with the specified\n     * attributes.\n     *\n     * @param min the minimum cost of accessing a node.\n     * @param max the maximum cost of accessing a node.\n     */\n    protected VisibilityMap(float min, float max) {\n        super(min, max);\n    }\n\n    /**\n     * Determines the line of sight, if any, between the source and\n     * target nodes.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a line of sight is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the start and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws PathNotFoundException if no such path could be found.\n     * @throws NullPointerException if either start or finish is null.\n     */\n    public Path lineOfSight(Node source, Node target) throws PathNotFoundException {\n        float dx = target.getX() - source.getX();\n        float dy = target.getY() - source.getY();\n        int signx = dx < 0 ? -1 : 1;\n        int signy = dy < 0 ? -1 : 1;\n        // Absolute value of dx and dy.\n        int ax = (int) (signx * dx);\n        int ay = (int) (signy * dy);\n        // Determine the slope of the straight line from source to\n        // target. The slope is given as a function of the variable\n        // that has the least angle.\n        float kx = (ax > ay) ? signx : ((float) dx / (float) dy) * signy;\n        float ky = (ax > ay) ? ((float) dy / (float) dx) * signx : signy;\n        int maxlen = (int) (ax > ay ? ax : ay);\n        Node p = source;\n        reset();\n        for (int i = 1; i < maxlen; i++) {\n            Node n = getNodeAt((source.getX() + i * kx), (source.getY() + i * ky), source.getZ());\n            if (n.getCost() >= maxCost) {\n                throw new PathNotFoundException();\n            }\n            n.setParent(p);\n            p = n;\n        }\n        return new DefaultPath(p);\n    }\n\n    /**\n     * Determines the field of vision from the source in the given\n     * direction and with the given spread, perf, and distance.\n     *\n     * @param source The node from which to start.\n     * @param direction The direction in degrees of the line of sight.\n     * @param spread The spread in degrees of the field.\n     * @param perf The perf of the field.\n     * @param distance The maximum distance.\n     *\n     * @throws NullPointerException if source is null.\n     */\n    public void fieldOfVision(Node source, float direction, float spread, float perf, float distance) {\n        float alpha = (float) (direction * Math.PI / 180);\n        float delta = (float) (spread * Math.PI / 180);\n        Vector open = new Vector();\n        reset();\n        source.setVisibility(1.0f);\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(0);\n            Node[] child = current.getAllChildren();\n            current.setOpen(true);\n            for (int i = 0; i < child.length; i++) {\n                float dx = child[i].getX() - source.getX();\n                float dy = child[i].getY() - source.getY();\n                // XXX - this is not working! Cells are not correctly\n                // vis:ed if dx > 0. Not sure why.\n                float beta = (float) Math.atan2(-dy, dx);\n                beta = beta < 0 ? (float) (2 * Math.PI + beta) : beta;\n                if (Math.sqrt(dx * dx + dy * dy) > distance) {\n                    continue;\n                }\n                if (beta < Math.min(alpha + delta, alpha - delta)) {\n                    continue;\n                }\n                if (beta > Math.max(alpha + delta, alpha - delta)) {\n                    continue;\n                }\n                if (child[i].isOpen() || child[i].isClosed()) {\n                    continue;\n                }\n                if (isVisible(child[i], source)) {\n                    child[i].setOpen(true);\n                    child[i].setVisibility(1.0f);\n                    open.add(child[i]);\n                }\n            }\n            current.setClosed(true);\n        }\n    }\n\n    /**\n     * Determines all nodes that are visible from source and are\n     * within the given limit. A Node is considered visible if\n     * there exist straight line path leading to it from the source.\n     *\n     * @param source the source node.\n     * @param limit the limit of the search.\n     */\n    public void fieldOfVision(Node source, float limit) {\n        Vector open = new Vector();\n        reset();\n        source.setTotal(0);\n        source.setVisibility(1.0f);\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(0);\n            Node[] child = current.getAllChildren();\n            if (current.getTotal() > limit) {\n                continue;\n            }\n            for (int i = 0; i < child.length; i++) {\n                if (child[i] == null || child[i].isClosed()) {\n                    continue;\n                }\n                if (!child[i].isOpen() && isVisible(child[i], source)) {\n                    child[i].setTotal(heuristic(child[i], source));\n                    child[i].setVisibility((limit - child[i].getTotal()) / limit);\n                    child[i].setOpen(true);\n                    open.add(child[i]);\n                }\n            }\n            current.setClosed(true);\n        }\n    }\n\n    /**\n     * Determines whether the target node is visible from the\n     * source node (ie. there is a straight line connecting the\n     * nodes which does not fall on any obstacles.)\n     *\n     * @param source the source node.\n     * @param target the target node.\n     *\n     * @return true if the target node is visible from the source.\n     */\n    public boolean isVisible(Node source, Node target) {\n        float dx = target.getX() - source.getX();\n        float dy = target.getY() - source.getY();\n        int signx = dx < 0 ? -1 : 1;\n        int signy = dy < 0 ? -1 : 1;\n        float ax = signx * dx;\n        float ay = signy * dy;\n        // As we are using tiles with an extension in the plane to\n        // display points in the grid there is a certain error in\n        // the calculated line of sight that must be considered.\n        //\n        //    dx  dy  (dx < dy) | cx cy\n        //   -------------------+-------\n        //     -   -    false   |  0  1\n        //     -   -     true   |  1  0\n        //     -   +    false   |  0  0\n        //     -   +     true   |  1  1\n        //     +   -    false   |  1  1\n        //     +   -     true   |  0  1\n        //     +   +    false   |  1  0\n        //     +   +     true   |  0  1\n        float kx = (ax > ay) ? signx : ((float) dx / (float) dy) * signy;\n        float ky = (ax > ay) ? ((float) dy / (float) dx) * signx : signy;\n        int maxlen = (int) (ax > ay ? ax : ay);\n        for (int i = 1; i < maxlen; i++) {\n            Node n = getNodeAt((source.getX() + i * kx + .5f), (source.getY() + i * ky + .5f), (source.getZ()));\n            if (n.getCost() >= maxCost) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Straightens the given path by repeatedly removing all\n     * intermediet nodes that exist between two nodes that are\n     * visible from each other.\n     *\n     * @param path the path to be straighten out.\n     */\n    public Path coalescePath(Path path) {\n        if (path.isEmpty()) {\n            return path;\n        }\n        // fixme - remove unnecessary code.\n        Node[] p1 = path.asNodeArray();\n        //smoothPath(p1, 0, p1.length-1, 4);\n        Node[] p2 = p1;\n        Node p = p2[p2.length - 1];\n        Node q = p.getParent();\n        // Coalesce neighboring nodes that are visible from each other.\n        // Greedy algorithm to coalesce a chain of visible nodes.\n        while (q != null) {\n            Node t = q;\n            while (q != null && isVisible(p, q)) {\n                p.setParent(q);\n                t = q;\n                q = q.getParent();\n            }\n            if (q != null) {\n                p = t;\n                q = q.getParent();\n            }\n        }\n        return new DefaultPath(p2[p2.length - 1]);\n    }\n\n    /**\n     * Straightens a subinterval of the given path by repeatedly\n     * removing all intermediet nodes that exist between two nodes\n     * that are visible from each other.\n     *\n     * @param path the path to be straighten out.\n     * @param low the low end of the subinterval.\n     * @param high the high end of subinterval.\n     * @param strength the number of iterations.\n     */\n    public Node[] smoothPath(Node[] path, int low, int high, int strength) {\n        if ((low < 0 || high > path.length) && low < high || strength < 0) {\n            return path;\n        }\n        if (isVisible(path[low], path[high])) {\n            if (path[high] != path[low]) {\n                path[high].setParent(path[low]);\n            }\n        } else {\n            smoothPath(path, low, ((low + high) / 2) - 1, strength - 1);\n            smoothPath(path, ((low + high) / 2), high, strength - 1);\n        }\n        return path;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/map/VisibilityMapTest2.java",
		"test_prompt": "// VisibilityMapTest2.java\npackage map;\n\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link VisibilityMap}.\n* It contains ten unit test cases for the {@link VisibilityMap#coalescePath(Path)} method.\n*/\nclass VisibilityMapTest2 {"
	},
	{
		"original_code": "// VisibilityMap.java\n/* VisibilityMap.java v0.1 (06/17/2002)\n *\n * Copyright (C) 2002, Joel Andersson <bja@kth.se>\n * \n * This software is hereby expressly placed in the public domain.\n * Share and enjoy.\n */\npackage map;\n\nimport java.util.Vector;\n\npublic abstract class VisibilityMap extends AbstractMap {\n\n    /**\n     * Creates a new instance of this class with the specified\n     * attributes.\n     *\n     * @param min the minimum cost of accessing a node.\n     * @param max the maximum cost of accessing a node.\n     */\n    protected VisibilityMap(float min, float max) {\n        super(min, max);\n    }\n\n    /**\n     * Determines the line of sight, if any, between the source and\n     * target nodes.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a line of sight is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the start and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws PathNotFoundException if no such path could be found.\n     * @throws NullPointerException if either start or finish is null.\n     */\n    public Path lineOfSight(Node source, Node target) throws PathNotFoundException {\n        float dx = target.getX() - source.getX();\n        float dy = target.getY() - source.getY();\n        int signx = dx < 0 ? -1 : 1;\n        int signy = dy < 0 ? -1 : 1;\n        // Absolute value of dx and dy.\n        int ax = (int) (signx * dx);\n        int ay = (int) (signy * dy);\n        // Determine the slope of the straight line from source to\n        // target. The slope is given as a function of the variable\n        // that has the least angle.\n        float kx = (ax > ay) ? signx : ((float) dx / (float) dy) * signy;\n        float ky = (ax > ay) ? ((float) dy / (float) dx) * signx : signy;\n        int maxlen = (int) (ax > ay ? ax : ay);\n        Node p = source;\n        reset();\n        for (int i = 1; i < maxlen; i++) {\n            Node n = getNodeAt((source.getX() + i * kx), (source.getY() + i * ky), source.getZ());\n            if (n.getCost() >= maxCost) {\n                throw new PathNotFoundException();\n            }\n            n.setParent(p);\n            p = n;\n        }\n        return new DefaultPath(p);\n    }\n\n    /**\n     * Determines the field of vision from the source in the given\n     * direction and with the given spread, perf, and distance.\n     *\n     * @param source The node from which to start.\n     * @param direction The direction in degrees of the line of sight.\n     * @param spread The spread in degrees of the field.\n     * @param perf The perf of the field.\n     * @param distance The maximum distance.\n     *\n     * @throws NullPointerException if source is null.\n     */\n    public void fieldOfVision(Node source, float direction, float spread, float perf, float distance) {\n        float alpha = (float) (direction * Math.PI / 180);\n        float delta = (float) (spread * Math.PI / 180);\n        Vector open = new Vector();\n        reset();\n        source.setVisibility(1.0f);\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(0);\n            Node[] child = current.getAllChildren();\n            current.setOpen(true);\n            for (int i = 0; i < child.length; i++) {\n                float dx = child[i].getX() - source.getX();\n                float dy = child[i].getY() - source.getY();\n                // XXX - this is not working! Cells are not correctly\n                // vis:ed if dx > 0. Not sure why.\n                float beta = (float) Math.atan2(-dy, dx);\n                beta = beta < 0 ? (float) (2 * Math.PI + beta) : beta;\n                if (Math.sqrt(dx * dx + dy * dy) > distance) {\n                    continue;\n                }\n                if (beta < Math.min(alpha + delta, alpha - delta)) {\n                    continue;\n                }\n                if (beta > Math.max(alpha + delta, alpha - delta)) {\n                    continue;\n                }\n                if (child[i].isOpen() || child[i].isClosed()) {\n                    continue;\n                }\n                if (isVisible(child[i], source)) {\n                    child[i].setOpen(true);\n                    child[i].setVisibility(1.0f);\n                    open.add(child[i]);\n                }\n            }\n            current.setClosed(true);\n        }\n    }\n\n    /**\n     * Determines all nodes that are visible from source and are\n     * within the given limit. A Node is considered visible if\n     * there exist straight line path leading to it from the source.\n     *\n     * @param source the source node.\n     * @param limit the limit of the search.\n     */\n    public void fieldOfVision(Node source, float limit) {\n        Vector open = new Vector();\n        reset();\n        source.setTotal(0);\n        source.setVisibility(1.0f);\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(0);\n            Node[] child = current.getAllChildren();\n            if (current.getTotal() > limit) {\n                continue;\n            }\n            for (int i = 0; i < child.length; i++) {\n                if (child[i] == null || child[i].isClosed()) {\n                    continue;\n                }\n                if (!child[i].isOpen() && isVisible(child[i], source)) {\n                    child[i].setTotal(heuristic(child[i], source));\n                    child[i].setVisibility((limit - child[i].getTotal()) / limit);\n                    child[i].setOpen(true);\n                    open.add(child[i]);\n                }\n            }\n            current.setClosed(true);\n        }\n    }\n\n    /**\n     * Determines whether the target node is visible from the\n     * source node (ie. there is a straight line connecting the\n     * nodes which does not fall on any obstacles.)\n     *\n     * @param source the source node.\n     * @param target the target node.\n     *\n     * @return true if the target node is visible from the source.\n     */\n    public boolean isVisible(Node source, Node target) {\n        float dx = target.getX() - source.getX();\n        float dy = target.getY() - source.getY();\n        int signx = dx < 0 ? -1 : 1;\n        int signy = dy < 0 ? -1 : 1;\n        float ax = signx * dx;\n        float ay = signy * dy;\n        // As we are using tiles with an extension in the plane to\n        // display points in the grid there is a certain error in\n        // the calculated line of sight that must be considered.\n        //\n        //    dx  dy  (dx < dy) | cx cy\n        //   -------------------+-------\n        //     -   -    false   |  0  1\n        //     -   -     true   |  1  0\n        //     -   +    false   |  0  0\n        //     -   +     true   |  1  1\n        //     +   -    false   |  1  1\n        //     +   -     true   |  0  1\n        //     +   +    false   |  1  0\n        //     +   +     true   |  0  1\n        float kx = (ax > ay) ? signx : ((float) dx / (float) dy) * signy;\n        float ky = (ax > ay) ? ((float) dy / (float) dx) * signx : signy;\n        int maxlen = (int) (ax > ay ? ax : ay);\n        for (int i = 1; i < maxlen; i++) {\n            Node n = getNodeAt((source.getX() + i * kx + .5f), (source.getY() + i * ky + .5f), (source.getZ()));\n            if (n.getCost() >= maxCost) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Straightens the given path by repeatedly removing all\n     * intermediet nodes that exist between two nodes that are\n     * visible from each other.\n     *\n     * @param path the path to be straighten out.\n     */\n    public Path coalescePath(Path path) {\n        if (path.isEmpty()) {\n            return path;\n        }\n        // fixme - remove unnecessary code.\n        Node[] p1 = path.asNodeArray();\n        //smoothPath(p1, 0, p1.length-1, 4);\n        Node[] p2 = p1;\n        Node p = p2[p2.length - 1];\n        Node q = p.getParent();\n        // Coalesce neighboring nodes that are visible from each other.\n        // Greedy algorithm to coalesce a chain of visible nodes.\n        while (q != null) {\n            Node t = q;\n            while (q != null && isVisible(p, q)) {\n                p.setParent(q);\n                t = q;\n                q = q.getParent();\n            }\n            if (q != null) {\n                p = t;\n                q = q.getParent();\n            }\n        }\n        return new DefaultPath(p2[p2.length - 1]);\n    }\n\n    /**\n     * Straightens a subinterval of the given path by repeatedly\n     * removing all intermediet nodes that exist between two nodes\n     * that are visible from each other.\n     *\n     * @param path the path to be straighten out.\n     * @param low the low end of the subinterval.\n     * @param high the high end of subinterval.\n     * @param strength the number of iterations.\n     */\n    public Node[] smoothPath(Node[] path, int low, int high, int strength) {\n        if ((low < 0 || high > path.length) && low < high || strength < 0) {\n            return path;\n        }\n        if (isVisible(path[low], path[high])) {\n            if (path[high] != path[low]) {\n                path[high].setParent(path[low]);\n            }\n        } else {\n            smoothPath(path, low, ((low + high) / 2) - 1, strength - 1);\n            smoothPath(path, ((low + high) / 2), high, strength - 1);\n        }\n        return path;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/map/VisibilityMapTest3.java",
		"test_prompt": "// VisibilityMapTest3.java\npackage map;\n\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link VisibilityMap}.\n* It contains ten unit test cases for the {@link VisibilityMap#smoothPath(Node[], int, int, int)} method.\n*/\nclass VisibilityMapTest3 {"
	},
	{
		"original_code": "// TileMap.java\n/* TileMap.java v0.2 (06/14/2002)\n *\n * Copyright (C) 2002, Joel Andersson <bja@kth.se>\n * \n * This software is hereby expressly placed in the public domain.\n * Share and enjoy.\n */\npackage map;\n\nimport java.io.*;\nimport java.awt.*;\nimport java.awt.image.*;\nimport java.util.*;\n\n/**\n * The <code>Map</code> class represents an W by H grid area where each cell\n * in the grid can be referenced by two integers, x and y, corresponding to\n * the horizontal position and vertical position of the cell respectively.\n */\npublic class TileMap extends VisibilityMap {\n\n    /**\n     * The internal representation of the map.\n     */\n    protected Node[][] grid;\n\n    /**\n     * The size of the tiles in this map.\n     */\n    protected int tileSize;\n\n    protected int numOfCols;\n\n    protected int numOfRows;\n\n    /**\n     * Creates a new map from the specified fileName with the number\n     * of subdivisions given by tileSize.\n     *\n     * @param fileName The file from which to create the map.\n     * @param tileSize The size of the tiles in this map.\n     */\n    public TileMap(String fileName, int tileSize) throws IOException {\n        this(1.0f / 15.0f, 1.0f, fileName, tileSize);\n    }\n\n    /**\n     * Creates a new map from the specified fileName with the number\n     * of subdivisions given by tileSize.\n     *\n     * @param fileName The file from which to create the map.\n     * @param tileSize The size of the tiles in this map.\n     */\n    public TileMap(float min, float max, String fileName, int tileSize) throws IOException {\n        super(min, max);\n        this.tileSize = tileSize;\n        open(fileName);\n    }\n\n    /**\n     * Returns the <code>Node</code> at the given coordinates.\n     *\n     * @param x The horizontal coordinate.\n     * @param y The vertical coordinate.\n     * @return The <code>Node</code> at the given coordinates.\n     */\n    public Node getNodeAt(int x, int y) {\n        return grid[y][x];\n    }\n\n    public Node getNodeAt(float x, float y, float z) {\n        return grid[(int) (y / tileSize)][(int) (x / tileSize)];\n    }\n\n    /**\n     * Returns the width of the map.\n     * @return The width of the map.\n     */\n    public int getWidth() {\n        return grid[0].length;\n    }\n\n    /**\n     * Returns the height of the map.\n     * @return The height of the map.\n     */\n    public int getHeight() {\n        return grid.length;\n    }\n\n    /**\n     * Restores the internal state of each processed node to\n     * its default state.\n     */\n    public final void reset() {\n        for (int y = 0; y < grid.length; y++) {\n            for (int x = 0; x < grid[0].length; x++) {\n                grid[y][x].setParent(null);\n                grid[y][x].setTotal(0.0f);\n                grid[y][x].setScore(0.0f);\n                grid[y][x].setVisible(false);\n                grid[y][x].setOpen(false);\n                grid[y][x].setClosed(false);\n            }\n        }\n    }\n\n    /**\n     * Searches for a path connecting the nodes given by their coordinates.\n     *\n     * @param x0 The horizontal position of the source node.\n     * @param y0 The vertical position of the source node.\n     * @param x1 The horizontal position of the destination node.\n     * @param y1 The vertical position of the destination node.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     */\n    public Path search(int x0, int y0, int x1, int y1) throws PathNotFoundException {\n        return search(getNodeAt(x0, y0), getNodeAt(x1, y1));\n    }\n\n    /**\n     * Searches for a path connecting the source node with the target\n     * node.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the start and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws PathNotFoundException if no such path could be found.\n     * @throws NullPointerException if either start or finish is null.\n     */\n    public Path search(Node source, Node target) throws PathNotFoundException {\n        return aStarSearch2(source, target);\n    }\n\n    /**\n     * Calculate the Euclidian distance from <code>source</code>\n     * to <code>target</code>.\n     *\n     * @param source The source node.\n     * @param target The target node.\n     */\n    protected float heuristic(Node source, Node target) {\n        float dx = target.getX() - source.getX();\n        float dy = target.getY() - source.getY();\n        return (float) Math.sqrt(dx * dx + dy * dy);\n    }\n\n    /**\n     * Determines the actual cost of crossing the edge between\n     * the given adjectant nodes. If the nodes are not adjectant\n     * the returned cost is unspecified.\n     *\n     * @param source The source node.\n     * @param target The target node.\n     */\n    protected float cost(Node source, Node target) {\n        return target.getCost() * heuristic(source, target);\n    }\n\n    /**\n     * Open and parse the file given by fileName. The file should be in\n     * a supported map format.\n     *\n     * @param fileName The file to read.\n     */\n    protected void open(String fileName) throws IOException {\n        // System.err.println(\"TileMap.open()\");\n        BufferedReader in = new BufferedReader(new FileReader(fileName));\n        StreamTokenizer st = new StreamTokenizer(in);\n        int j = 0, i = 0;\n        int[] tmp = new int[3];\n        // throw away tile info\n        int numOfTiles = Integer.parseInt(in.readLine());\n        for (i = 0; i < numOfTiles; i++) {\n            in.readLine();\n        }\n        // throw away obj info\n        int numOfObjs = Integer.parseInt(in.readLine());\n        for (i = 0; i < numOfObjs; i++) {\n            in.readLine();\n        }\n        numOfCols = Integer.parseInt(in.readLine());\n        numOfRows = Integer.parseInt(in.readLine());\n        grid = new Node[numOfRows][numOfCols];\n        for (i = 0; i < numOfRows; i++) {\n            for (j = 0; j < numOfCols; j++) {\n                grid[i][j] = new DefaultNode(null, 0, j, i);\n                grid[i][j].setCost(1);\n            }\n        }\n        i = j = 0;\n        while (st.nextToken() != st.TT_EOF) {\n            if (j >= tmp.length) {\n                grid[tmp[1]][tmp[0]].setCost(tmp[2]);\n                //\t\tgrid[tmp[1]][tmp[0]].setX(tmp[0]);\n                //\t\tgrid[tmp[1]][tmp[0]].setY(tmp[1]);\n                j = 0;\n            }\n            tmp[j++] = (int) st.nval;\n        }\n        if (j == tmp.length) {\n            grid[tmp[1]][tmp[0]].setCost(tmp[2]);\n            //\t    grid[tmp[1]][tmp[0]].setX((float)tmp[0]);\n            //\t    grid[tmp[1]][tmp[0]].setY((float)tmp[1]);\n            //\t    System.err.println(\"TileMap.open(): Missing end of line!\");\n        }\n        in.close();\n        buildGraph();\n    }\n\n    private void buildGraph() {\n        int i = 0;\n        int j = 0;\n        grid[i][j].addChildNode(grid[i][j + 1]);\n        grid[i][j].addChildNode(grid[i + 1][j]);\n        grid[i][j].addChildNode(grid[i + 1][j + 1]);\n        i = 0;\n        j = numOfCols - 1;\n        grid[i][j].addChildNode(grid[i][j - 1]);\n        grid[i][j].addChildNode(grid[i + 1][j]);\n        grid[i][j].addChildNode(grid[i + 1][j - 1]);\n        i = numOfRows - 1;\n        j = 0;\n        grid[i][j].addChildNode(grid[i][j + 1]);\n        grid[i][j].addChildNode(grid[i - 1][j]);\n        grid[i][j].addChildNode(grid[i - 1][j + 1]);\n        i = numOfRows - 1;\n        j = numOfCols - 1;\n        grid[i][j].addChildNode(grid[i][j - 1]);\n        grid[i][j].addChildNode(grid[i - 1][j]);\n        grid[i][j].addChildNode(grid[i - 1][j - 1]);\n        for (i = 1; i < numOfRows - 1; i++) {\n            grid[i][0].addChildNode(grid[i][1]);\n            grid[i][0].addChildNode(grid[i - 1][1]);\n            grid[i][0].addChildNode(grid[i + 1][1]);\n            grid[i][numOfCols - 1].addChildNode(grid[i][numOfCols - 2]);\n            grid[i][numOfCols - 1].addChildNode(grid[i - 1][numOfCols - 2]);\n            grid[i][numOfCols - 1].addChildNode(grid[i + 1][numOfCols - 2]);\n        }\n        for (j = 1; j < numOfCols - 1; j++) {\n            grid[0][j].addChildNode(grid[1][j]);\n            grid[0][j].addChildNode(grid[1][j + 1]);\n            grid[0][j].addChildNode(grid[1][j - 1]);\n            grid[numOfRows - 1][j].addChildNode(grid[numOfRows - 2][j]);\n            grid[numOfRows - 1][j].addChildNode(grid[numOfRows - 2][j + 1]);\n            grid[numOfRows - 1][j].addChildNode(grid[numOfRows - 2][j - 1]);\n        }\n        for (i = 1; i < numOfRows - 1; i++) {\n            for (j = 1; j < numOfCols - 1; j++) {\n                grid[i][j].addChildNode(grid[i - 1][j]);\n                grid[i][j].addChildNode(grid[i + 1][j]);\n                grid[i][j].addChildNode(grid[i - 1][j - 1]);\n                grid[i][j].addChildNode(grid[i - 1][j + 1]);\n                grid[i][j].addChildNode(grid[i][j - 1]);\n                grid[i][j].addChildNode(grid[i][j + 1]);\n                grid[i][j].addChildNode(grid[i - 1][j - 1]);\n                grid[i][j].addChildNode(grid[i + 1][j + 1]);\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/map/TileMapTest0.java",
		"test_prompt": "// TileMapTest0.java\npackage map;\n\nimport java.io.*;\nimport java.awt.*;\nimport java.awt.image.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TileMap}.\n* It contains ten unit test cases for the {@link TileMap#search(int, int, int, int)} method.\n*/\nclass TileMapTest0 {"
	},
	{
		"original_code": "// TileMap.java\n/* TileMap.java v0.2 (06/14/2002)\n *\n * Copyright (C) 2002, Joel Andersson <bja@kth.se>\n * \n * This software is hereby expressly placed in the public domain.\n * Share and enjoy.\n */\npackage map;\n\nimport java.io.*;\nimport java.awt.*;\nimport java.awt.image.*;\nimport java.util.*;\n\n/**\n * The <code>Map</code> class represents an W by H grid area where each cell\n * in the grid can be referenced by two integers, x and y, corresponding to\n * the horizontal position and vertical position of the cell respectively.\n */\npublic class TileMap extends VisibilityMap {\n\n    /**\n     * The internal representation of the map.\n     */\n    protected Node[][] grid;\n\n    /**\n     * The size of the tiles in this map.\n     */\n    protected int tileSize;\n\n    protected int numOfCols;\n\n    protected int numOfRows;\n\n    /**\n     * Creates a new map from the specified fileName with the number\n     * of subdivisions given by tileSize.\n     *\n     * @param fileName The file from which to create the map.\n     * @param tileSize The size of the tiles in this map.\n     */\n    public TileMap(String fileName, int tileSize) throws IOException {\n        this(1.0f / 15.0f, 1.0f, fileName, tileSize);\n    }\n\n    /**\n     * Creates a new map from the specified fileName with the number\n     * of subdivisions given by tileSize.\n     *\n     * @param fileName The file from which to create the map.\n     * @param tileSize The size of the tiles in this map.\n     */\n    public TileMap(float min, float max, String fileName, int tileSize) throws IOException {\n        super(min, max);\n        this.tileSize = tileSize;\n        open(fileName);\n    }\n\n    /**\n     * Returns the <code>Node</code> at the given coordinates.\n     *\n     * @param x The horizontal coordinate.\n     * @param y The vertical coordinate.\n     * @return The <code>Node</code> at the given coordinates.\n     */\n    public Node getNodeAt(int x, int y) {\n        return grid[y][x];\n    }\n\n    public Node getNodeAt(float x, float y, float z) {\n        return grid[(int) (y / tileSize)][(int) (x / tileSize)];\n    }\n\n    /**\n     * Returns the width of the map.\n     * @return The width of the map.\n     */\n    public int getWidth() {\n        return grid[0].length;\n    }\n\n    /**\n     * Returns the height of the map.\n     * @return The height of the map.\n     */\n    public int getHeight() {\n        return grid.length;\n    }\n\n    /**\n     * Restores the internal state of each processed node to\n     * its default state.\n     */\n    public final void reset() {\n        for (int y = 0; y < grid.length; y++) {\n            for (int x = 0; x < grid[0].length; x++) {\n                grid[y][x].setParent(null);\n                grid[y][x].setTotal(0.0f);\n                grid[y][x].setScore(0.0f);\n                grid[y][x].setVisible(false);\n                grid[y][x].setOpen(false);\n                grid[y][x].setClosed(false);\n            }\n        }\n    }\n\n    /**\n     * Searches for a path connecting the nodes given by their coordinates.\n     *\n     * @param x0 The horizontal position of the source node.\n     * @param y0 The vertical position of the source node.\n     * @param x1 The horizontal position of the destination node.\n     * @param y1 The vertical position of the destination node.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     */\n    public Path search(int x0, int y0, int x1, int y1) throws PathNotFoundException {\n        return search(getNodeAt(x0, y0), getNodeAt(x1, y1));\n    }\n\n    /**\n     * Searches for a path connecting the source node with the target\n     * node.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the start and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws PathNotFoundException if no such path could be found.\n     * @throws NullPointerException if either start or finish is null.\n     */\n    public Path search(Node source, Node target) throws PathNotFoundException {\n        return aStarSearch2(source, target);\n    }\n\n    /**\n     * Calculate the Euclidian distance from <code>source</code>\n     * to <code>target</code>.\n     *\n     * @param source The source node.\n     * @param target The target node.\n     */\n    protected float heuristic(Node source, Node target) {\n        float dx = target.getX() - source.getX();\n        float dy = target.getY() - source.getY();\n        return (float) Math.sqrt(dx * dx + dy * dy);\n    }\n\n    /**\n     * Determines the actual cost of crossing the edge between\n     * the given adjectant nodes. If the nodes are not adjectant\n     * the returned cost is unspecified.\n     *\n     * @param source The source node.\n     * @param target The target node.\n     */\n    protected float cost(Node source, Node target) {\n        return target.getCost() * heuristic(source, target);\n    }\n\n    /**\n     * Open and parse the file given by fileName. The file should be in\n     * a supported map format.\n     *\n     * @param fileName The file to read.\n     */\n    protected void open(String fileName) throws IOException {\n        // System.err.println(\"TileMap.open()\");\n        BufferedReader in = new BufferedReader(new FileReader(fileName));\n        StreamTokenizer st = new StreamTokenizer(in);\n        int j = 0, i = 0;\n        int[] tmp = new int[3];\n        // throw away tile info\n        int numOfTiles = Integer.parseInt(in.readLine());\n        for (i = 0; i < numOfTiles; i++) {\n            in.readLine();\n        }\n        // throw away obj info\n        int numOfObjs = Integer.parseInt(in.readLine());\n        for (i = 0; i < numOfObjs; i++) {\n            in.readLine();\n        }\n        numOfCols = Integer.parseInt(in.readLine());\n        numOfRows = Integer.parseInt(in.readLine());\n        grid = new Node[numOfRows][numOfCols];\n        for (i = 0; i < numOfRows; i++) {\n            for (j = 0; j < numOfCols; j++) {\n                grid[i][j] = new DefaultNode(null, 0, j, i);\n                grid[i][j].setCost(1);\n            }\n        }\n        i = j = 0;\n        while (st.nextToken() != st.TT_EOF) {\n            if (j >= tmp.length) {\n                grid[tmp[1]][tmp[0]].setCost(tmp[2]);\n                //\t\tgrid[tmp[1]][tmp[0]].setX(tmp[0]);\n                //\t\tgrid[tmp[1]][tmp[0]].setY(tmp[1]);\n                j = 0;\n            }\n            tmp[j++] = (int) st.nval;\n        }\n        if (j == tmp.length) {\n            grid[tmp[1]][tmp[0]].setCost(tmp[2]);\n            //\t    grid[tmp[1]][tmp[0]].setX((float)tmp[0]);\n            //\t    grid[tmp[1]][tmp[0]].setY((float)tmp[1]);\n            //\t    System.err.println(\"TileMap.open(): Missing end of line!\");\n        }\n        in.close();\n        buildGraph();\n    }\n\n    private void buildGraph() {\n        int i = 0;\n        int j = 0;\n        grid[i][j].addChildNode(grid[i][j + 1]);\n        grid[i][j].addChildNode(grid[i + 1][j]);\n        grid[i][j].addChildNode(grid[i + 1][j + 1]);\n        i = 0;\n        j = numOfCols - 1;\n        grid[i][j].addChildNode(grid[i][j - 1]);\n        grid[i][j].addChildNode(grid[i + 1][j]);\n        grid[i][j].addChildNode(grid[i + 1][j - 1]);\n        i = numOfRows - 1;\n        j = 0;\n        grid[i][j].addChildNode(grid[i][j + 1]);\n        grid[i][j].addChildNode(grid[i - 1][j]);\n        grid[i][j].addChildNode(grid[i - 1][j + 1]);\n        i = numOfRows - 1;\n        j = numOfCols - 1;\n        grid[i][j].addChildNode(grid[i][j - 1]);\n        grid[i][j].addChildNode(grid[i - 1][j]);\n        grid[i][j].addChildNode(grid[i - 1][j - 1]);\n        for (i = 1; i < numOfRows - 1; i++) {\n            grid[i][0].addChildNode(grid[i][1]);\n            grid[i][0].addChildNode(grid[i - 1][1]);\n            grid[i][0].addChildNode(grid[i + 1][1]);\n            grid[i][numOfCols - 1].addChildNode(grid[i][numOfCols - 2]);\n            grid[i][numOfCols - 1].addChildNode(grid[i - 1][numOfCols - 2]);\n            grid[i][numOfCols - 1].addChildNode(grid[i + 1][numOfCols - 2]);\n        }\n        for (j = 1; j < numOfCols - 1; j++) {\n            grid[0][j].addChildNode(grid[1][j]);\n            grid[0][j].addChildNode(grid[1][j + 1]);\n            grid[0][j].addChildNode(grid[1][j - 1]);\n            grid[numOfRows - 1][j].addChildNode(grid[numOfRows - 2][j]);\n            grid[numOfRows - 1][j].addChildNode(grid[numOfRows - 2][j + 1]);\n            grid[numOfRows - 1][j].addChildNode(grid[numOfRows - 2][j - 1]);\n        }\n        for (i = 1; i < numOfRows - 1; i++) {\n            for (j = 1; j < numOfCols - 1; j++) {\n                grid[i][j].addChildNode(grid[i - 1][j]);\n                grid[i][j].addChildNode(grid[i + 1][j]);\n                grid[i][j].addChildNode(grid[i - 1][j - 1]);\n                grid[i][j].addChildNode(grid[i - 1][j + 1]);\n                grid[i][j].addChildNode(grid[i][j - 1]);\n                grid[i][j].addChildNode(grid[i][j + 1]);\n                grid[i][j].addChildNode(grid[i - 1][j - 1]);\n                grid[i][j].addChildNode(grid[i + 1][j + 1]);\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/map/TileMapTest1.java",
		"test_prompt": "// TileMapTest1.java\npackage map;\n\nimport java.io.*;\nimport java.awt.*;\nimport java.awt.image.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TileMap}.\n* It contains ten unit test cases for the {@link TileMap#search(Node, Node)} method.\n*/\nclass TileMapTest1 {"
	},
	{
		"original_code": "// DefaultPath.java\n/* DefaultPath.java v0.1 (06/16/2002)\n *\n * Copyright (C) 2002, Joel Andersson <bja@kth.se>\n * \n * This software is hereby expressly placed in the public domain.\n * Share and enjoy.\n */\npackage map;\n\nimport java.util.Vector;\nimport java.util.Iterator;\n\npublic class DefaultPath implements Path {\n\n    private final Vector path;\n\n    public DefaultPath() {\n        path = new Vector();\n    }\n\n    public DefaultPath(Node n) {\n        path = new Vector();\n        construct(n);\n    }\n\n    public DefaultPath(Path p) {\n        path = new Vector();\n        Iterator it = p.iterator();\n        while (it.hasNext()) {\n            path.add(it.next());\n        }\n    }\n\n    public DefaultPath(Node[] array) {\n        this(array[array.length - 1]);\n    }\n\n    public void construct(Node n) {\n        path.removeAllElements();\n        while (n != null && n.getParent() != null) {\n            path.insertElementAt(n, 0);\n            n = n.getParent();\n        }\n    }\n\n    public void reconstruct() {\n        if (path.size() > 2) {\n            construct((Node) path.remove(path.size() - 1));\n        }\n    }\n\n    public int length() {\n        return path.size();\n    }\n\n    public boolean isEmpty() {\n        return path.isEmpty();\n    }\n\n    public Node next() {\n        return (Node) path.remove(0);\n    }\n\n    public Iterator iterator() {\n        return path.iterator();\n    }\n\n    public Node[] asNodeArray() {\n        return (Node[]) path.toArray(new Node[path.size()]);\n    }\n\n    public String toString() {\n        Iterator it = iterator();\n        String ret = \"\";\n        while (it.hasNext()) {\n            Node n = (Node) it.next();\n            ret += n.toString() + \"\\n\";\n        }\n        return ret;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/map/DefaultPathTest0.java",
		"test_prompt": "// DefaultPathTest0.java\npackage map;\n\nimport java.util.Vector;\nimport java.util.Iterator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DefaultPath}.\n* It contains ten unit test cases for the {@link DefaultPath#length()} method.\n*/\nclass DefaultPathTest0 {"
	},
	{
		"original_code": "// DefaultPath.java\n/* DefaultPath.java v0.1 (06/16/2002)\n *\n * Copyright (C) 2002, Joel Andersson <bja@kth.se>\n * \n * This software is hereby expressly placed in the public domain.\n * Share and enjoy.\n */\npackage map;\n\nimport java.util.Vector;\nimport java.util.Iterator;\n\npublic class DefaultPath implements Path {\n\n    private final Vector path;\n\n    public DefaultPath() {\n        path = new Vector();\n    }\n\n    public DefaultPath(Node n) {\n        path = new Vector();\n        construct(n);\n    }\n\n    public DefaultPath(Path p) {\n        path = new Vector();\n        Iterator it = p.iterator();\n        while (it.hasNext()) {\n            path.add(it.next());\n        }\n    }\n\n    public DefaultPath(Node[] array) {\n        this(array[array.length - 1]);\n    }\n\n    public void construct(Node n) {\n        path.removeAllElements();\n        while (n != null && n.getParent() != null) {\n            path.insertElementAt(n, 0);\n            n = n.getParent();\n        }\n    }\n\n    public void reconstruct() {\n        if (path.size() > 2) {\n            construct((Node) path.remove(path.size() - 1));\n        }\n    }\n\n    public int length() {\n        return path.size();\n    }\n\n    public boolean isEmpty() {\n        return path.isEmpty();\n    }\n\n    public Node next() {\n        return (Node) path.remove(0);\n    }\n\n    public Iterator iterator() {\n        return path.iterator();\n    }\n\n    public Node[] asNodeArray() {\n        return (Node[]) path.toArray(new Node[path.size()]);\n    }\n\n    public String toString() {\n        Iterator it = iterator();\n        String ret = \"\";\n        while (it.hasNext()) {\n            Node n = (Node) it.next();\n            ret += n.toString() + \"\\n\";\n        }\n        return ret;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/map/DefaultPathTest1.java",
		"test_prompt": "// DefaultPathTest1.java\npackage map;\n\nimport java.util.Vector;\nimport java.util.Iterator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DefaultPath}.\n* It contains ten unit test cases for the {@link DefaultPath#isEmpty()} method.\n*/\nclass DefaultPathTest1 {"
	},
	{
		"original_code": "// DefaultPath.java\n/* DefaultPath.java v0.1 (06/16/2002)\n *\n * Copyright (C) 2002, Joel Andersson <bja@kth.se>\n * \n * This software is hereby expressly placed in the public domain.\n * Share and enjoy.\n */\npackage map;\n\nimport java.util.Vector;\nimport java.util.Iterator;\n\npublic class DefaultPath implements Path {\n\n    private final Vector path;\n\n    public DefaultPath() {\n        path = new Vector();\n    }\n\n    public DefaultPath(Node n) {\n        path = new Vector();\n        construct(n);\n    }\n\n    public DefaultPath(Path p) {\n        path = new Vector();\n        Iterator it = p.iterator();\n        while (it.hasNext()) {\n            path.add(it.next());\n        }\n    }\n\n    public DefaultPath(Node[] array) {\n        this(array[array.length - 1]);\n    }\n\n    public void construct(Node n) {\n        path.removeAllElements();\n        while (n != null && n.getParent() != null) {\n            path.insertElementAt(n, 0);\n            n = n.getParent();\n        }\n    }\n\n    public void reconstruct() {\n        if (path.size() > 2) {\n            construct((Node) path.remove(path.size() - 1));\n        }\n    }\n\n    public int length() {\n        return path.size();\n    }\n\n    public boolean isEmpty() {\n        return path.isEmpty();\n    }\n\n    public Node next() {\n        return (Node) path.remove(0);\n    }\n\n    public Iterator iterator() {\n        return path.iterator();\n    }\n\n    public Node[] asNodeArray() {\n        return (Node[]) path.toArray(new Node[path.size()]);\n    }\n\n    public String toString() {\n        Iterator it = iterator();\n        String ret = \"\";\n        while (it.hasNext()) {\n            Node n = (Node) it.next();\n            ret += n.toString() + \"\\n\";\n        }\n        return ret;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/map/DefaultPathTest2.java",
		"test_prompt": "// DefaultPathTest2.java\npackage map;\n\nimport java.util.Vector;\nimport java.util.Iterator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DefaultPath}.\n* It contains ten unit test cases for the {@link DefaultPath#next()} method.\n*/\nclass DefaultPathTest2 {"
	},
	{
		"original_code": "// DefaultPath.java\n/* DefaultPath.java v0.1 (06/16/2002)\n *\n * Copyright (C) 2002, Joel Andersson <bja@kth.se>\n * \n * This software is hereby expressly placed in the public domain.\n * Share and enjoy.\n */\npackage map;\n\nimport java.util.Vector;\nimport java.util.Iterator;\n\npublic class DefaultPath implements Path {\n\n    private final Vector path;\n\n    public DefaultPath() {\n        path = new Vector();\n    }\n\n    public DefaultPath(Node n) {\n        path = new Vector();\n        construct(n);\n    }\n\n    public DefaultPath(Path p) {\n        path = new Vector();\n        Iterator it = p.iterator();\n        while (it.hasNext()) {\n            path.add(it.next());\n        }\n    }\n\n    public DefaultPath(Node[] array) {\n        this(array[array.length - 1]);\n    }\n\n    public void construct(Node n) {\n        path.removeAllElements();\n        while (n != null && n.getParent() != null) {\n            path.insertElementAt(n, 0);\n            n = n.getParent();\n        }\n    }\n\n    public void reconstruct() {\n        if (path.size() > 2) {\n            construct((Node) path.remove(path.size() - 1));\n        }\n    }\n\n    public int length() {\n        return path.size();\n    }\n\n    public boolean isEmpty() {\n        return path.isEmpty();\n    }\n\n    public Node next() {\n        return (Node) path.remove(0);\n    }\n\n    public Iterator iterator() {\n        return path.iterator();\n    }\n\n    public Node[] asNodeArray() {\n        return (Node[]) path.toArray(new Node[path.size()]);\n    }\n\n    public String toString() {\n        Iterator it = iterator();\n        String ret = \"\";\n        while (it.hasNext()) {\n            Node n = (Node) it.next();\n            ret += n.toString() + \"\\n\";\n        }\n        return ret;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/map/DefaultPathTest3.java",
		"test_prompt": "// DefaultPathTest3.java\npackage map;\n\nimport java.util.Vector;\nimport java.util.Iterator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DefaultPath}.\n* It contains ten unit test cases for the {@link DefaultPath#iterator()} method.\n*/\nclass DefaultPathTest3 {"
	},
	{
		"original_code": "// DefaultPath.java\n/* DefaultPath.java v0.1 (06/16/2002)\n *\n * Copyright (C) 2002, Joel Andersson <bja@kth.se>\n * \n * This software is hereby expressly placed in the public domain.\n * Share and enjoy.\n */\npackage map;\n\nimport java.util.Vector;\nimport java.util.Iterator;\n\npublic class DefaultPath implements Path {\n\n    private final Vector path;\n\n    public DefaultPath() {\n        path = new Vector();\n    }\n\n    public DefaultPath(Node n) {\n        path = new Vector();\n        construct(n);\n    }\n\n    public DefaultPath(Path p) {\n        path = new Vector();\n        Iterator it = p.iterator();\n        while (it.hasNext()) {\n            path.add(it.next());\n        }\n    }\n\n    public DefaultPath(Node[] array) {\n        this(array[array.length - 1]);\n    }\n\n    public void construct(Node n) {\n        path.removeAllElements();\n        while (n != null && n.getParent() != null) {\n            path.insertElementAt(n, 0);\n            n = n.getParent();\n        }\n    }\n\n    public void reconstruct() {\n        if (path.size() > 2) {\n            construct((Node) path.remove(path.size() - 1));\n        }\n    }\n\n    public int length() {\n        return path.size();\n    }\n\n    public boolean isEmpty() {\n        return path.isEmpty();\n    }\n\n    public Node next() {\n        return (Node) path.remove(0);\n    }\n\n    public Iterator iterator() {\n        return path.iterator();\n    }\n\n    public Node[] asNodeArray() {\n        return (Node[]) path.toArray(new Node[path.size()]);\n    }\n\n    public String toString() {\n        Iterator it = iterator();\n        String ret = \"\";\n        while (it.hasNext()) {\n            Node n = (Node) it.next();\n            ret += n.toString() + \"\\n\";\n        }\n        return ret;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/map/DefaultPathTest4.java",
		"test_prompt": "// DefaultPathTest4.java\npackage map;\n\nimport java.util.Vector;\nimport java.util.Iterator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DefaultPath}.\n* It contains ten unit test cases for the {@link DefaultPath#asNodeArray()} method.\n*/\nclass DefaultPathTest4 {"
	},
	{
		"original_code": "// DefaultNode.java\n/* MapNode.java v0.1 (06/16/2002)\n *\n * Copyright (C) 2002, Joel Andersson <bja@kth.se>\n * \n * This software is hereby expressly placed in the public domain.\n * Share and enjoy.\n */\npackage map;\n\nimport java.util.Vector;\n\n/**\n * The <code>DefaultNode</code> class represents an internal map node. Each\n * cell in the map consists of a <code>DefaultNode</code>.\n */\npublic class DefaultNode implements Node {\n\n    /**\n     * The bitmask associated with this node.\n     */\n    public long bits;\n\n    /**\n     * The parent of this node.\n     */\n    protected Node parent;\n\n    /**\n     * The child nodes of this node.\n     */\n    protected Vector children;\n\n    /**\n     * The cost associated with this node.\n     */\n    protected float cost;\n\n    /**\n     * The total cost associate with this node.\n     */\n    protected float total;\n\n    /**\n     * The score associated with this node.\n     */\n    protected float score;\n\n    /**\n     * The current state of this node.\n     */\n    protected int state;\n\n    /**\n     * The horizontal component of this node.\n     */\n    protected float x;\n\n    /**\n     * The vertical component of this node.\n     */\n    protected float y;\n\n    /**\n     * The z coordinate of this node.\n     */\n    protected float z;\n\n    /**\n     * Specifies whether this node is currently visible.\n     */\n    protected float visibility;\n\n    /**\n     * Creates a new <code>DefaultNode</code>.\n     */\n    public DefaultNode() {\n        this(null);\n    }\n\n    /**\n     * Creates a new <code>DefaultNode</code> with the specified\n     * parent node. The node is initially positionend at (0,0) and\n     * is not solid.\n     *\n     * @param parent The parent of this node.\n     */\n    public DefaultNode(Node parent) {\n        this(null, 0, 0, 0);\n    }\n\n    /**\n     * Creates a new <code>DefaultNode</code> with the specified\n     * parent and attributes.\n     *\n     * @param parent The parent of this node.\n     * @param bits The flags associated with this node.\n     * @param x The horizontal component of this node.\n     * @param y The vertical component of this node.\n     */\n    public DefaultNode(Node parent, long bits, int x, int y) {\n        this.parent = parent;\n        this.bits = bits;\n        this.x = x;\n        this.y = y;\n        this.state = UNSET;\n        this.total = score = cost = 0;\n        children = new Vector();\n    }\n\n    /**\n     * Adds a child node to this node.\n     * @param n The node to add.\n     */\n    public void addChildNode(Node n) {\n        children.add(n);\n    }\n\n    /**\n     * Sets a specific child node given by index to the Node\n     * given by n.\n     *\n     * @param index The index of the child to change.\n     * @param n The node to set in the place of index.\n     */\n    public void setChildNode(int index, Node node) {\n        children.set(index, node);\n    }\n\n    /**\n     * Returns the child at the specified location <code>index</code>.\n     * @return The child at the specified location <code>index</code>.\n     */\n    public Node getChildNode(int index) {\n        return (Node) children.get(index);\n    }\n\n    /**\n     * Returns the children of this <code>Node</code>.\n     * @return The children of this <code>Node</code>.\n     */\n    public Node[] getAllChildren() {\n        Node[] temp = new Node[children.size()];\n        children.copyInto(temp);\n        return temp;\n    }\n\n    /**\n     * Sets the parent of this node to the specified node.\n     * @param n The new parent node.\n     */\n    public void setParent(Node n) {\n        parent = n;\n    }\n\n    /**\n     * Returns this nodes parent.\n     * @return this nodes parent.\n     */\n    public Node getParent() {\n        return parent;\n    }\n\n    /**\n     * Sets the positional coordinates of this node to the\n     * specified values.\n     *\n     * @param x The horizontal component.\n     * @param y The vertical component.\n     */\n    public void setLocation(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public void setLocation(float x, float y, float z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n\n    /**\n     * Returns the horizontal component of this node.\n     * @return the horizontal component of this node.\n     */\n    public float getX() {\n        return x;\n    }\n\n    /**\n     * Returns the vertical component of this node.\n     * @return the vettical component of this node.\n     */\n    public float getY() {\n        return y;\n    }\n\n    /**\n     * Returns the z coordinate of this node.\n     * @return the z coordinate of this node.\n     */\n    public float getZ() {\n        return z;\n    }\n\n    public void setX(float x) {\n        this.x = x;\n    }\n\n    public void setY(float y) {\n        this.y = y;\n    }\n\n    public void setZ(float z) {\n        this.z = z;\n    }\n\n    /**\n     * Sets the cost associated with entering this node.\n     * @param cost the cost associated with entering this node.\n     */\n    public void setCost(float cost) {\n        this.cost = cost;\n    }\n\n    /**\n     * Returns the cost associated with entering this node.\n     * @return The cost associated with entering this node.\n     */\n    public float getCost() {\n        return cost;\n    }\n\n    /**\n     * Sets the total cost associated with this node. The\n     * total cost is the cost of travelling from the start\n     * node to this node.\n     *\n     * @param total The total cost to be associated with\n     *              this node.\n     */\n    public void setTotal(float total) {\n        this.total = total;\n    }\n\n    /**\n     * Returns the total cost associated with this node.\n     * @return The total cost associated with this node.\n     */\n    public float getTotal() {\n        return total;\n    }\n\n    /**\n     * Sets the score associated with this node. The score\n     * determines how good this node is in relation to other\n     * nodes and is used for ordering them amongst each other.\n     *\n     * @param score The score to be associated with this node.\n     */\n    public void setScore(float score) {\n        this.score = score;\n    }\n\n    /**\n     * Returns the score associated with this node.\n     * @return the score associated with this node.\n     */\n    public float getScore() {\n        return score;\n    }\n\n    /**\n     * Specifies whether this node has already been processed\n     * and no longer is considered for further processing.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node has been processed.\n     */\n    public void setClosed(boolean b) {\n        state = b ? state | CLOSED : state & ~CLOSED;\n    }\n\n    /**\n     * Returns true if this node has been processed.\n     * @return True if this node has been processed.\n     */\n    public boolean isClosed() {\n        return (state & CLOSED) > 0;\n    }\n\n    /**\n     * Specifies whether this node is currently being\n     * considered for further processing.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is currently open.\n     */\n    public void setOpen(boolean b) {\n        state = b ? state | OPEN : state & ~OPEN;\n    }\n\n    /**\n     * Returns true if this node is currently being\n     * considered for further processing.\n     *\n     * @return True if this node is open.\n     */\n    public boolean isOpen() {\n        return (state & OPEN) > 0;\n    }\n\n    /**\n     * Sets the data associated with this node. The handles\n     * the way the node is displayed.\n     *\n     * @param data The data to be associated with this node.\n     */\n    public void setData(long data) {\n        this.bits = data;\n    }\n\n    /**\n     * Retrieves the data associated with this node.\n     * @return the data associated with this node.\n     */\n    public long getData() {\n        return bits;\n    }\n\n    /**\n     * Specifies whether this node is solid (ie. the\n     * cost of entering the node is infinite.)\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is solid.\n     */\n    public void setSolid(boolean b) {\n        throw new RuntimeException(\"Method not implemented!\");\n    }\n\n    /**\n     * Returns whether this node is considered solid (ie. the\n     * cost of entering the node is infinite.)\n     *\n     * @return True if this node is solid.\n     */\n    public boolean isSolid() {\n        throw new RuntimeException(\"Method not implemented!\");\n    }\n\n    /**\n     * Specifies whether this node is currently visible.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is currently visible.\n     */\n    public void setVisible(boolean b) {\n        this.visibility = b ? 1.0f : 0.0f;\n    }\n\n    /**\n     * Returns whether this node is considered visible.\n     * @return True if this node is visible.\n     */\n    public boolean isVisible() {\n        return visibility > 0.0f;\n    }\n\n    /**\n     * Sets the degree of visibility of this node.\n     * @param value the degree of visibility.\n     */\n    public void setVisibility(float value) {\n        this.visibility = value;\n    }\n\n    /**\n     * Returns the current degree of visibility of this node.\n     * @return the current degree of visibility of this node.\n     */\n    public float getVisibility() {\n        return visibility;\n    }\n\n    /**\n     * Compares this Node with the specified Object for order.\n     * Note: This method imposes ordering which is inconsistant\n     * with equals.\n     *\n     * @param obj The object which is to be compared.\n     * @return An integer value of -1, 0, or 1, as this node\n     *         is less than, equal to, or greater than obj.\n     *\n     * @throws ClassCastException if obj is not of type Node.\n     */\n    public int compareTo(Object obj) {\n        return compareTo((DefaultNode) obj);\n    }\n\n    public int compareTo(DefaultNode n) {\n        return score < n.score ? -1 : (score > n.score ? 1 : 0);\n    }\n\n    public String toString() {\n        return \"DefaultNode[x=\" + x + \",y=\" + y + \",score=\" + score + \"]\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/map/DefaultNodeTest0.java",
		"test_prompt": "// DefaultNodeTest0.java\npackage map;\n\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DefaultNode}.\n* It contains ten unit test cases for the {@link DefaultNode#isClosed()} method.\n*/\nclass DefaultNodeTest0 {"
	},
	{
		"original_code": "// DefaultNode.java\n/* MapNode.java v0.1 (06/16/2002)\n *\n * Copyright (C) 2002, Joel Andersson <bja@kth.se>\n * \n * This software is hereby expressly placed in the public domain.\n * Share and enjoy.\n */\npackage map;\n\nimport java.util.Vector;\n\n/**\n * The <code>DefaultNode</code> class represents an internal map node. Each\n * cell in the map consists of a <code>DefaultNode</code>.\n */\npublic class DefaultNode implements Node {\n\n    /**\n     * The bitmask associated with this node.\n     */\n    public long bits;\n\n    /**\n     * The parent of this node.\n     */\n    protected Node parent;\n\n    /**\n     * The child nodes of this node.\n     */\n    protected Vector children;\n\n    /**\n     * The cost associated with this node.\n     */\n    protected float cost;\n\n    /**\n     * The total cost associate with this node.\n     */\n    protected float total;\n\n    /**\n     * The score associated with this node.\n     */\n    protected float score;\n\n    /**\n     * The current state of this node.\n     */\n    protected int state;\n\n    /**\n     * The horizontal component of this node.\n     */\n    protected float x;\n\n    /**\n     * The vertical component of this node.\n     */\n    protected float y;\n\n    /**\n     * The z coordinate of this node.\n     */\n    protected float z;\n\n    /**\n     * Specifies whether this node is currently visible.\n     */\n    protected float visibility;\n\n    /**\n     * Creates a new <code>DefaultNode</code>.\n     */\n    public DefaultNode() {\n        this(null);\n    }\n\n    /**\n     * Creates a new <code>DefaultNode</code> with the specified\n     * parent node. The node is initially positionend at (0,0) and\n     * is not solid.\n     *\n     * @param parent The parent of this node.\n     */\n    public DefaultNode(Node parent) {\n        this(null, 0, 0, 0);\n    }\n\n    /**\n     * Creates a new <code>DefaultNode</code> with the specified\n     * parent and attributes.\n     *\n     * @param parent The parent of this node.\n     * @param bits The flags associated with this node.\n     * @param x The horizontal component of this node.\n     * @param y The vertical component of this node.\n     */\n    public DefaultNode(Node parent, long bits, int x, int y) {\n        this.parent = parent;\n        this.bits = bits;\n        this.x = x;\n        this.y = y;\n        this.state = UNSET;\n        this.total = score = cost = 0;\n        children = new Vector();\n    }\n\n    /**\n     * Adds a child node to this node.\n     * @param n The node to add.\n     */\n    public void addChildNode(Node n) {\n        children.add(n);\n    }\n\n    /**\n     * Sets a specific child node given by index to the Node\n     * given by n.\n     *\n     * @param index The index of the child to change.\n     * @param n The node to set in the place of index.\n     */\n    public void setChildNode(int index, Node node) {\n        children.set(index, node);\n    }\n\n    /**\n     * Returns the child at the specified location <code>index</code>.\n     * @return The child at the specified location <code>index</code>.\n     */\n    public Node getChildNode(int index) {\n        return (Node) children.get(index);\n    }\n\n    /**\n     * Returns the children of this <code>Node</code>.\n     * @return The children of this <code>Node</code>.\n     */\n    public Node[] getAllChildren() {\n        Node[] temp = new Node[children.size()];\n        children.copyInto(temp);\n        return temp;\n    }\n\n    /**\n     * Sets the parent of this node to the specified node.\n     * @param n The new parent node.\n     */\n    public void setParent(Node n) {\n        parent = n;\n    }\n\n    /**\n     * Returns this nodes parent.\n     * @return this nodes parent.\n     */\n    public Node getParent() {\n        return parent;\n    }\n\n    /**\n     * Sets the positional coordinates of this node to the\n     * specified values.\n     *\n     * @param x The horizontal component.\n     * @param y The vertical component.\n     */\n    public void setLocation(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public void setLocation(float x, float y, float z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n\n    /**\n     * Returns the horizontal component of this node.\n     * @return the horizontal component of this node.\n     */\n    public float getX() {\n        return x;\n    }\n\n    /**\n     * Returns the vertical component of this node.\n     * @return the vettical component of this node.\n     */\n    public float getY() {\n        return y;\n    }\n\n    /**\n     * Returns the z coordinate of this node.\n     * @return the z coordinate of this node.\n     */\n    public float getZ() {\n        return z;\n    }\n\n    public void setX(float x) {\n        this.x = x;\n    }\n\n    public void setY(float y) {\n        this.y = y;\n    }\n\n    public void setZ(float z) {\n        this.z = z;\n    }\n\n    /**\n     * Sets the cost associated with entering this node.\n     * @param cost the cost associated with entering this node.\n     */\n    public void setCost(float cost) {\n        this.cost = cost;\n    }\n\n    /**\n     * Returns the cost associated with entering this node.\n     * @return The cost associated with entering this node.\n     */\n    public float getCost() {\n        return cost;\n    }\n\n    /**\n     * Sets the total cost associated with this node. The\n     * total cost is the cost of travelling from the start\n     * node to this node.\n     *\n     * @param total The total cost to be associated with\n     *              this node.\n     */\n    public void setTotal(float total) {\n        this.total = total;\n    }\n\n    /**\n     * Returns the total cost associated with this node.\n     * @return The total cost associated with this node.\n     */\n    public float getTotal() {\n        return total;\n    }\n\n    /**\n     * Sets the score associated with this node. The score\n     * determines how good this node is in relation to other\n     * nodes and is used for ordering them amongst each other.\n     *\n     * @param score The score to be associated with this node.\n     */\n    public void setScore(float score) {\n        this.score = score;\n    }\n\n    /**\n     * Returns the score associated with this node.\n     * @return the score associated with this node.\n     */\n    public float getScore() {\n        return score;\n    }\n\n    /**\n     * Specifies whether this node has already been processed\n     * and no longer is considered for further processing.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node has been processed.\n     */\n    public void setClosed(boolean b) {\n        state = b ? state | CLOSED : state & ~CLOSED;\n    }\n\n    /**\n     * Returns true if this node has been processed.\n     * @return True if this node has been processed.\n     */\n    public boolean isClosed() {\n        return (state & CLOSED) > 0;\n    }\n\n    /**\n     * Specifies whether this node is currently being\n     * considered for further processing.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is currently open.\n     */\n    public void setOpen(boolean b) {\n        state = b ? state | OPEN : state & ~OPEN;\n    }\n\n    /**\n     * Returns true if this node is currently being\n     * considered for further processing.\n     *\n     * @return True if this node is open.\n     */\n    public boolean isOpen() {\n        return (state & OPEN) > 0;\n    }\n\n    /**\n     * Sets the data associated with this node. The handles\n     * the way the node is displayed.\n     *\n     * @param data The data to be associated with this node.\n     */\n    public void setData(long data) {\n        this.bits = data;\n    }\n\n    /**\n     * Retrieves the data associated with this node.\n     * @return the data associated with this node.\n     */\n    public long getData() {\n        return bits;\n    }\n\n    /**\n     * Specifies whether this node is solid (ie. the\n     * cost of entering the node is infinite.)\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is solid.\n     */\n    public void setSolid(boolean b) {\n        throw new RuntimeException(\"Method not implemented!\");\n    }\n\n    /**\n     * Returns whether this node is considered solid (ie. the\n     * cost of entering the node is infinite.)\n     *\n     * @return True if this node is solid.\n     */\n    public boolean isSolid() {\n        throw new RuntimeException(\"Method not implemented!\");\n    }\n\n    /**\n     * Specifies whether this node is currently visible.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is currently visible.\n     */\n    public void setVisible(boolean b) {\n        this.visibility = b ? 1.0f : 0.0f;\n    }\n\n    /**\n     * Returns whether this node is considered visible.\n     * @return True if this node is visible.\n     */\n    public boolean isVisible() {\n        return visibility > 0.0f;\n    }\n\n    /**\n     * Sets the degree of visibility of this node.\n     * @param value the degree of visibility.\n     */\n    public void setVisibility(float value) {\n        this.visibility = value;\n    }\n\n    /**\n     * Returns the current degree of visibility of this node.\n     * @return the current degree of visibility of this node.\n     */\n    public float getVisibility() {\n        return visibility;\n    }\n\n    /**\n     * Compares this Node with the specified Object for order.\n     * Note: This method imposes ordering which is inconsistant\n     * with equals.\n     *\n     * @param obj The object which is to be compared.\n     * @return An integer value of -1, 0, or 1, as this node\n     *         is less than, equal to, or greater than obj.\n     *\n     * @throws ClassCastException if obj is not of type Node.\n     */\n    public int compareTo(Object obj) {\n        return compareTo((DefaultNode) obj);\n    }\n\n    public int compareTo(DefaultNode n) {\n        return score < n.score ? -1 : (score > n.score ? 1 : 0);\n    }\n\n    public String toString() {\n        return \"DefaultNode[x=\" + x + \",y=\" + y + \",score=\" + score + \"]\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/map/DefaultNodeTest1.java",
		"test_prompt": "// DefaultNodeTest1.java\npackage map;\n\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DefaultNode}.\n* It contains ten unit test cases for the {@link DefaultNode#isOpen()} method.\n*/\nclass DefaultNodeTest1 {"
	},
	{
		"original_code": "// DefaultNode.java\n/* MapNode.java v0.1 (06/16/2002)\n *\n * Copyright (C) 2002, Joel Andersson <bja@kth.se>\n * \n * This software is hereby expressly placed in the public domain.\n * Share and enjoy.\n */\npackage map;\n\nimport java.util.Vector;\n\n/**\n * The <code>DefaultNode</code> class represents an internal map node. Each\n * cell in the map consists of a <code>DefaultNode</code>.\n */\npublic class DefaultNode implements Node {\n\n    /**\n     * The bitmask associated with this node.\n     */\n    public long bits;\n\n    /**\n     * The parent of this node.\n     */\n    protected Node parent;\n\n    /**\n     * The child nodes of this node.\n     */\n    protected Vector children;\n\n    /**\n     * The cost associated with this node.\n     */\n    protected float cost;\n\n    /**\n     * The total cost associate with this node.\n     */\n    protected float total;\n\n    /**\n     * The score associated with this node.\n     */\n    protected float score;\n\n    /**\n     * The current state of this node.\n     */\n    protected int state;\n\n    /**\n     * The horizontal component of this node.\n     */\n    protected float x;\n\n    /**\n     * The vertical component of this node.\n     */\n    protected float y;\n\n    /**\n     * The z coordinate of this node.\n     */\n    protected float z;\n\n    /**\n     * Specifies whether this node is currently visible.\n     */\n    protected float visibility;\n\n    /**\n     * Creates a new <code>DefaultNode</code>.\n     */\n    public DefaultNode() {\n        this(null);\n    }\n\n    /**\n     * Creates a new <code>DefaultNode</code> with the specified\n     * parent node. The node is initially positionend at (0,0) and\n     * is not solid.\n     *\n     * @param parent The parent of this node.\n     */\n    public DefaultNode(Node parent) {\n        this(null, 0, 0, 0);\n    }\n\n    /**\n     * Creates a new <code>DefaultNode</code> with the specified\n     * parent and attributes.\n     *\n     * @param parent The parent of this node.\n     * @param bits The flags associated with this node.\n     * @param x The horizontal component of this node.\n     * @param y The vertical component of this node.\n     */\n    public DefaultNode(Node parent, long bits, int x, int y) {\n        this.parent = parent;\n        this.bits = bits;\n        this.x = x;\n        this.y = y;\n        this.state = UNSET;\n        this.total = score = cost = 0;\n        children = new Vector();\n    }\n\n    /**\n     * Adds a child node to this node.\n     * @param n The node to add.\n     */\n    public void addChildNode(Node n) {\n        children.add(n);\n    }\n\n    /**\n     * Sets a specific child node given by index to the Node\n     * given by n.\n     *\n     * @param index The index of the child to change.\n     * @param n The node to set in the place of index.\n     */\n    public void setChildNode(int index, Node node) {\n        children.set(index, node);\n    }\n\n    /**\n     * Returns the child at the specified location <code>index</code>.\n     * @return The child at the specified location <code>index</code>.\n     */\n    public Node getChildNode(int index) {\n        return (Node) children.get(index);\n    }\n\n    /**\n     * Returns the children of this <code>Node</code>.\n     * @return The children of this <code>Node</code>.\n     */\n    public Node[] getAllChildren() {\n        Node[] temp = new Node[children.size()];\n        children.copyInto(temp);\n        return temp;\n    }\n\n    /**\n     * Sets the parent of this node to the specified node.\n     * @param n The new parent node.\n     */\n    public void setParent(Node n) {\n        parent = n;\n    }\n\n    /**\n     * Returns this nodes parent.\n     * @return this nodes parent.\n     */\n    public Node getParent() {\n        return parent;\n    }\n\n    /**\n     * Sets the positional coordinates of this node to the\n     * specified values.\n     *\n     * @param x The horizontal component.\n     * @param y The vertical component.\n     */\n    public void setLocation(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public void setLocation(float x, float y, float z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n\n    /**\n     * Returns the horizontal component of this node.\n     * @return the horizontal component of this node.\n     */\n    public float getX() {\n        return x;\n    }\n\n    /**\n     * Returns the vertical component of this node.\n     * @return the vettical component of this node.\n     */\n    public float getY() {\n        return y;\n    }\n\n    /**\n     * Returns the z coordinate of this node.\n     * @return the z coordinate of this node.\n     */\n    public float getZ() {\n        return z;\n    }\n\n    public void setX(float x) {\n        this.x = x;\n    }\n\n    public void setY(float y) {\n        this.y = y;\n    }\n\n    public void setZ(float z) {\n        this.z = z;\n    }\n\n    /**\n     * Sets the cost associated with entering this node.\n     * @param cost the cost associated with entering this node.\n     */\n    public void setCost(float cost) {\n        this.cost = cost;\n    }\n\n    /**\n     * Returns the cost associated with entering this node.\n     * @return The cost associated with entering this node.\n     */\n    public float getCost() {\n        return cost;\n    }\n\n    /**\n     * Sets the total cost associated with this node. The\n     * total cost is the cost of travelling from the start\n     * node to this node.\n     *\n     * @param total The total cost to be associated with\n     *              this node.\n     */\n    public void setTotal(float total) {\n        this.total = total;\n    }\n\n    /**\n     * Returns the total cost associated with this node.\n     * @return The total cost associated with this node.\n     */\n    public float getTotal() {\n        return total;\n    }\n\n    /**\n     * Sets the score associated with this node. The score\n     * determines how good this node is in relation to other\n     * nodes and is used for ordering them amongst each other.\n     *\n     * @param score The score to be associated with this node.\n     */\n    public void setScore(float score) {\n        this.score = score;\n    }\n\n    /**\n     * Returns the score associated with this node.\n     * @return the score associated with this node.\n     */\n    public float getScore() {\n        return score;\n    }\n\n    /**\n     * Specifies whether this node has already been processed\n     * and no longer is considered for further processing.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node has been processed.\n     */\n    public void setClosed(boolean b) {\n        state = b ? state | CLOSED : state & ~CLOSED;\n    }\n\n    /**\n     * Returns true if this node has been processed.\n     * @return True if this node has been processed.\n     */\n    public boolean isClosed() {\n        return (state & CLOSED) > 0;\n    }\n\n    /**\n     * Specifies whether this node is currently being\n     * considered for further processing.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is currently open.\n     */\n    public void setOpen(boolean b) {\n        state = b ? state | OPEN : state & ~OPEN;\n    }\n\n    /**\n     * Returns true if this node is currently being\n     * considered for further processing.\n     *\n     * @return True if this node is open.\n     */\n    public boolean isOpen() {\n        return (state & OPEN) > 0;\n    }\n\n    /**\n     * Sets the data associated with this node. The handles\n     * the way the node is displayed.\n     *\n     * @param data The data to be associated with this node.\n     */\n    public void setData(long data) {\n        this.bits = data;\n    }\n\n    /**\n     * Retrieves the data associated with this node.\n     * @return the data associated with this node.\n     */\n    public long getData() {\n        return bits;\n    }\n\n    /**\n     * Specifies whether this node is solid (ie. the\n     * cost of entering the node is infinite.)\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is solid.\n     */\n    public void setSolid(boolean b) {\n        throw new RuntimeException(\"Method not implemented!\");\n    }\n\n    /**\n     * Returns whether this node is considered solid (ie. the\n     * cost of entering the node is infinite.)\n     *\n     * @return True if this node is solid.\n     */\n    public boolean isSolid() {\n        throw new RuntimeException(\"Method not implemented!\");\n    }\n\n    /**\n     * Specifies whether this node is currently visible.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is currently visible.\n     */\n    public void setVisible(boolean b) {\n        this.visibility = b ? 1.0f : 0.0f;\n    }\n\n    /**\n     * Returns whether this node is considered visible.\n     * @return True if this node is visible.\n     */\n    public boolean isVisible() {\n        return visibility > 0.0f;\n    }\n\n    /**\n     * Sets the degree of visibility of this node.\n     * @param value the degree of visibility.\n     */\n    public void setVisibility(float value) {\n        this.visibility = value;\n    }\n\n    /**\n     * Returns the current degree of visibility of this node.\n     * @return the current degree of visibility of this node.\n     */\n    public float getVisibility() {\n        return visibility;\n    }\n\n    /**\n     * Compares this Node with the specified Object for order.\n     * Note: This method imposes ordering which is inconsistant\n     * with equals.\n     *\n     * @param obj The object which is to be compared.\n     * @return An integer value of -1, 0, or 1, as this node\n     *         is less than, equal to, or greater than obj.\n     *\n     * @throws ClassCastException if obj is not of type Node.\n     */\n    public int compareTo(Object obj) {\n        return compareTo((DefaultNode) obj);\n    }\n\n    public int compareTo(DefaultNode n) {\n        return score < n.score ? -1 : (score > n.score ? 1 : 0);\n    }\n\n    public String toString() {\n        return \"DefaultNode[x=\" + x + \",y=\" + y + \",score=\" + score + \"]\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/map/DefaultNodeTest2.java",
		"test_prompt": "// DefaultNodeTest2.java\npackage map;\n\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DefaultNode}.\n* It contains ten unit test cases for the {@link DefaultNode#isSolid()} method.\n*/\nclass DefaultNodeTest2 {"
	},
	{
		"original_code": "// DefaultNode.java\n/* MapNode.java v0.1 (06/16/2002)\n *\n * Copyright (C) 2002, Joel Andersson <bja@kth.se>\n * \n * This software is hereby expressly placed in the public domain.\n * Share and enjoy.\n */\npackage map;\n\nimport java.util.Vector;\n\n/**\n * The <code>DefaultNode</code> class represents an internal map node. Each\n * cell in the map consists of a <code>DefaultNode</code>.\n */\npublic class DefaultNode implements Node {\n\n    /**\n     * The bitmask associated with this node.\n     */\n    public long bits;\n\n    /**\n     * The parent of this node.\n     */\n    protected Node parent;\n\n    /**\n     * The child nodes of this node.\n     */\n    protected Vector children;\n\n    /**\n     * The cost associated with this node.\n     */\n    protected float cost;\n\n    /**\n     * The total cost associate with this node.\n     */\n    protected float total;\n\n    /**\n     * The score associated with this node.\n     */\n    protected float score;\n\n    /**\n     * The current state of this node.\n     */\n    protected int state;\n\n    /**\n     * The horizontal component of this node.\n     */\n    protected float x;\n\n    /**\n     * The vertical component of this node.\n     */\n    protected float y;\n\n    /**\n     * The z coordinate of this node.\n     */\n    protected float z;\n\n    /**\n     * Specifies whether this node is currently visible.\n     */\n    protected float visibility;\n\n    /**\n     * Creates a new <code>DefaultNode</code>.\n     */\n    public DefaultNode() {\n        this(null);\n    }\n\n    /**\n     * Creates a new <code>DefaultNode</code> with the specified\n     * parent node. The node is initially positionend at (0,0) and\n     * is not solid.\n     *\n     * @param parent The parent of this node.\n     */\n    public DefaultNode(Node parent) {\n        this(null, 0, 0, 0);\n    }\n\n    /**\n     * Creates a new <code>DefaultNode</code> with the specified\n     * parent and attributes.\n     *\n     * @param parent The parent of this node.\n     * @param bits The flags associated with this node.\n     * @param x The horizontal component of this node.\n     * @param y The vertical component of this node.\n     */\n    public DefaultNode(Node parent, long bits, int x, int y) {\n        this.parent = parent;\n        this.bits = bits;\n        this.x = x;\n        this.y = y;\n        this.state = UNSET;\n        this.total = score = cost = 0;\n        children = new Vector();\n    }\n\n    /**\n     * Adds a child node to this node.\n     * @param n The node to add.\n     */\n    public void addChildNode(Node n) {\n        children.add(n);\n    }\n\n    /**\n     * Sets a specific child node given by index to the Node\n     * given by n.\n     *\n     * @param index The index of the child to change.\n     * @param n The node to set in the place of index.\n     */\n    public void setChildNode(int index, Node node) {\n        children.set(index, node);\n    }\n\n    /**\n     * Returns the child at the specified location <code>index</code>.\n     * @return The child at the specified location <code>index</code>.\n     */\n    public Node getChildNode(int index) {\n        return (Node) children.get(index);\n    }\n\n    /**\n     * Returns the children of this <code>Node</code>.\n     * @return The children of this <code>Node</code>.\n     */\n    public Node[] getAllChildren() {\n        Node[] temp = new Node[children.size()];\n        children.copyInto(temp);\n        return temp;\n    }\n\n    /**\n     * Sets the parent of this node to the specified node.\n     * @param n The new parent node.\n     */\n    public void setParent(Node n) {\n        parent = n;\n    }\n\n    /**\n     * Returns this nodes parent.\n     * @return this nodes parent.\n     */\n    public Node getParent() {\n        return parent;\n    }\n\n    /**\n     * Sets the positional coordinates of this node to the\n     * specified values.\n     *\n     * @param x The horizontal component.\n     * @param y The vertical component.\n     */\n    public void setLocation(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public void setLocation(float x, float y, float z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n\n    /**\n     * Returns the horizontal component of this node.\n     * @return the horizontal component of this node.\n     */\n    public float getX() {\n        return x;\n    }\n\n    /**\n     * Returns the vertical component of this node.\n     * @return the vettical component of this node.\n     */\n    public float getY() {\n        return y;\n    }\n\n    /**\n     * Returns the z coordinate of this node.\n     * @return the z coordinate of this node.\n     */\n    public float getZ() {\n        return z;\n    }\n\n    public void setX(float x) {\n        this.x = x;\n    }\n\n    public void setY(float y) {\n        this.y = y;\n    }\n\n    public void setZ(float z) {\n        this.z = z;\n    }\n\n    /**\n     * Sets the cost associated with entering this node.\n     * @param cost the cost associated with entering this node.\n     */\n    public void setCost(float cost) {\n        this.cost = cost;\n    }\n\n    /**\n     * Returns the cost associated with entering this node.\n     * @return The cost associated with entering this node.\n     */\n    public float getCost() {\n        return cost;\n    }\n\n    /**\n     * Sets the total cost associated with this node. The\n     * total cost is the cost of travelling from the start\n     * node to this node.\n     *\n     * @param total The total cost to be associated with\n     *              this node.\n     */\n    public void setTotal(float total) {\n        this.total = total;\n    }\n\n    /**\n     * Returns the total cost associated with this node.\n     * @return The total cost associated with this node.\n     */\n    public float getTotal() {\n        return total;\n    }\n\n    /**\n     * Sets the score associated with this node. The score\n     * determines how good this node is in relation to other\n     * nodes and is used for ordering them amongst each other.\n     *\n     * @param score The score to be associated with this node.\n     */\n    public void setScore(float score) {\n        this.score = score;\n    }\n\n    /**\n     * Returns the score associated with this node.\n     * @return the score associated with this node.\n     */\n    public float getScore() {\n        return score;\n    }\n\n    /**\n     * Specifies whether this node has already been processed\n     * and no longer is considered for further processing.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node has been processed.\n     */\n    public void setClosed(boolean b) {\n        state = b ? state | CLOSED : state & ~CLOSED;\n    }\n\n    /**\n     * Returns true if this node has been processed.\n     * @return True if this node has been processed.\n     */\n    public boolean isClosed() {\n        return (state & CLOSED) > 0;\n    }\n\n    /**\n     * Specifies whether this node is currently being\n     * considered for further processing.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is currently open.\n     */\n    public void setOpen(boolean b) {\n        state = b ? state | OPEN : state & ~OPEN;\n    }\n\n    /**\n     * Returns true if this node is currently being\n     * considered for further processing.\n     *\n     * @return True if this node is open.\n     */\n    public boolean isOpen() {\n        return (state & OPEN) > 0;\n    }\n\n    /**\n     * Sets the data associated with this node. The handles\n     * the way the node is displayed.\n     *\n     * @param data The data to be associated with this node.\n     */\n    public void setData(long data) {\n        this.bits = data;\n    }\n\n    /**\n     * Retrieves the data associated with this node.\n     * @return the data associated with this node.\n     */\n    public long getData() {\n        return bits;\n    }\n\n    /**\n     * Specifies whether this node is solid (ie. the\n     * cost of entering the node is infinite.)\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is solid.\n     */\n    public void setSolid(boolean b) {\n        throw new RuntimeException(\"Method not implemented!\");\n    }\n\n    /**\n     * Returns whether this node is considered solid (ie. the\n     * cost of entering the node is infinite.)\n     *\n     * @return True if this node is solid.\n     */\n    public boolean isSolid() {\n        throw new RuntimeException(\"Method not implemented!\");\n    }\n\n    /**\n     * Specifies whether this node is currently visible.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is currently visible.\n     */\n    public void setVisible(boolean b) {\n        this.visibility = b ? 1.0f : 0.0f;\n    }\n\n    /**\n     * Returns whether this node is considered visible.\n     * @return True if this node is visible.\n     */\n    public boolean isVisible() {\n        return visibility > 0.0f;\n    }\n\n    /**\n     * Sets the degree of visibility of this node.\n     * @param value the degree of visibility.\n     */\n    public void setVisibility(float value) {\n        this.visibility = value;\n    }\n\n    /**\n     * Returns the current degree of visibility of this node.\n     * @return the current degree of visibility of this node.\n     */\n    public float getVisibility() {\n        return visibility;\n    }\n\n    /**\n     * Compares this Node with the specified Object for order.\n     * Note: This method imposes ordering which is inconsistant\n     * with equals.\n     *\n     * @param obj The object which is to be compared.\n     * @return An integer value of -1, 0, or 1, as this node\n     *         is less than, equal to, or greater than obj.\n     *\n     * @throws ClassCastException if obj is not of type Node.\n     */\n    public int compareTo(Object obj) {\n        return compareTo((DefaultNode) obj);\n    }\n\n    public int compareTo(DefaultNode n) {\n        return score < n.score ? -1 : (score > n.score ? 1 : 0);\n    }\n\n    public String toString() {\n        return \"DefaultNode[x=\" + x + \",y=\" + y + \",score=\" + score + \"]\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/map/DefaultNodeTest3.java",
		"test_prompt": "// DefaultNodeTest3.java\npackage map;\n\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DefaultNode}.\n* It contains ten unit test cases for the {@link DefaultNode#isVisible()} method.\n*/\nclass DefaultNodeTest3 {"
	},
	{
		"original_code": "// DefaultNode.java\n/* MapNode.java v0.1 (06/16/2002)\n *\n * Copyright (C) 2002, Joel Andersson <bja@kth.se>\n * \n * This software is hereby expressly placed in the public domain.\n * Share and enjoy.\n */\npackage map;\n\nimport java.util.Vector;\n\n/**\n * The <code>DefaultNode</code> class represents an internal map node. Each\n * cell in the map consists of a <code>DefaultNode</code>.\n */\npublic class DefaultNode implements Node {\n\n    /**\n     * The bitmask associated with this node.\n     */\n    public long bits;\n\n    /**\n     * The parent of this node.\n     */\n    protected Node parent;\n\n    /**\n     * The child nodes of this node.\n     */\n    protected Vector children;\n\n    /**\n     * The cost associated with this node.\n     */\n    protected float cost;\n\n    /**\n     * The total cost associate with this node.\n     */\n    protected float total;\n\n    /**\n     * The score associated with this node.\n     */\n    protected float score;\n\n    /**\n     * The current state of this node.\n     */\n    protected int state;\n\n    /**\n     * The horizontal component of this node.\n     */\n    protected float x;\n\n    /**\n     * The vertical component of this node.\n     */\n    protected float y;\n\n    /**\n     * The z coordinate of this node.\n     */\n    protected float z;\n\n    /**\n     * Specifies whether this node is currently visible.\n     */\n    protected float visibility;\n\n    /**\n     * Creates a new <code>DefaultNode</code>.\n     */\n    public DefaultNode() {\n        this(null);\n    }\n\n    /**\n     * Creates a new <code>DefaultNode</code> with the specified\n     * parent node. The node is initially positionend at (0,0) and\n     * is not solid.\n     *\n     * @param parent The parent of this node.\n     */\n    public DefaultNode(Node parent) {\n        this(null, 0, 0, 0);\n    }\n\n    /**\n     * Creates a new <code>DefaultNode</code> with the specified\n     * parent and attributes.\n     *\n     * @param parent The parent of this node.\n     * @param bits The flags associated with this node.\n     * @param x The horizontal component of this node.\n     * @param y The vertical component of this node.\n     */\n    public DefaultNode(Node parent, long bits, int x, int y) {\n        this.parent = parent;\n        this.bits = bits;\n        this.x = x;\n        this.y = y;\n        this.state = UNSET;\n        this.total = score = cost = 0;\n        children = new Vector();\n    }\n\n    /**\n     * Adds a child node to this node.\n     * @param n The node to add.\n     */\n    public void addChildNode(Node n) {\n        children.add(n);\n    }\n\n    /**\n     * Sets a specific child node given by index to the Node\n     * given by n.\n     *\n     * @param index The index of the child to change.\n     * @param n The node to set in the place of index.\n     */\n    public void setChildNode(int index, Node node) {\n        children.set(index, node);\n    }\n\n    /**\n     * Returns the child at the specified location <code>index</code>.\n     * @return The child at the specified location <code>index</code>.\n     */\n    public Node getChildNode(int index) {\n        return (Node) children.get(index);\n    }\n\n    /**\n     * Returns the children of this <code>Node</code>.\n     * @return The children of this <code>Node</code>.\n     */\n    public Node[] getAllChildren() {\n        Node[] temp = new Node[children.size()];\n        children.copyInto(temp);\n        return temp;\n    }\n\n    /**\n     * Sets the parent of this node to the specified node.\n     * @param n The new parent node.\n     */\n    public void setParent(Node n) {\n        parent = n;\n    }\n\n    /**\n     * Returns this nodes parent.\n     * @return this nodes parent.\n     */\n    public Node getParent() {\n        return parent;\n    }\n\n    /**\n     * Sets the positional coordinates of this node to the\n     * specified values.\n     *\n     * @param x The horizontal component.\n     * @param y The vertical component.\n     */\n    public void setLocation(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public void setLocation(float x, float y, float z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n\n    /**\n     * Returns the horizontal component of this node.\n     * @return the horizontal component of this node.\n     */\n    public float getX() {\n        return x;\n    }\n\n    /**\n     * Returns the vertical component of this node.\n     * @return the vettical component of this node.\n     */\n    public float getY() {\n        return y;\n    }\n\n    /**\n     * Returns the z coordinate of this node.\n     * @return the z coordinate of this node.\n     */\n    public float getZ() {\n        return z;\n    }\n\n    public void setX(float x) {\n        this.x = x;\n    }\n\n    public void setY(float y) {\n        this.y = y;\n    }\n\n    public void setZ(float z) {\n        this.z = z;\n    }\n\n    /**\n     * Sets the cost associated with entering this node.\n     * @param cost the cost associated with entering this node.\n     */\n    public void setCost(float cost) {\n        this.cost = cost;\n    }\n\n    /**\n     * Returns the cost associated with entering this node.\n     * @return The cost associated with entering this node.\n     */\n    public float getCost() {\n        return cost;\n    }\n\n    /**\n     * Sets the total cost associated with this node. The\n     * total cost is the cost of travelling from the start\n     * node to this node.\n     *\n     * @param total The total cost to be associated with\n     *              this node.\n     */\n    public void setTotal(float total) {\n        this.total = total;\n    }\n\n    /**\n     * Returns the total cost associated with this node.\n     * @return The total cost associated with this node.\n     */\n    public float getTotal() {\n        return total;\n    }\n\n    /**\n     * Sets the score associated with this node. The score\n     * determines how good this node is in relation to other\n     * nodes and is used for ordering them amongst each other.\n     *\n     * @param score The score to be associated with this node.\n     */\n    public void setScore(float score) {\n        this.score = score;\n    }\n\n    /**\n     * Returns the score associated with this node.\n     * @return the score associated with this node.\n     */\n    public float getScore() {\n        return score;\n    }\n\n    /**\n     * Specifies whether this node has already been processed\n     * and no longer is considered for further processing.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node has been processed.\n     */\n    public void setClosed(boolean b) {\n        state = b ? state | CLOSED : state & ~CLOSED;\n    }\n\n    /**\n     * Returns true if this node has been processed.\n     * @return True if this node has been processed.\n     */\n    public boolean isClosed() {\n        return (state & CLOSED) > 0;\n    }\n\n    /**\n     * Specifies whether this node is currently being\n     * considered for further processing.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is currently open.\n     */\n    public void setOpen(boolean b) {\n        state = b ? state | OPEN : state & ~OPEN;\n    }\n\n    /**\n     * Returns true if this node is currently being\n     * considered for further processing.\n     *\n     * @return True if this node is open.\n     */\n    public boolean isOpen() {\n        return (state & OPEN) > 0;\n    }\n\n    /**\n     * Sets the data associated with this node. The handles\n     * the way the node is displayed.\n     *\n     * @param data The data to be associated with this node.\n     */\n    public void setData(long data) {\n        this.bits = data;\n    }\n\n    /**\n     * Retrieves the data associated with this node.\n     * @return the data associated with this node.\n     */\n    public long getData() {\n        return bits;\n    }\n\n    /**\n     * Specifies whether this node is solid (ie. the\n     * cost of entering the node is infinite.)\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is solid.\n     */\n    public void setSolid(boolean b) {\n        throw new RuntimeException(\"Method not implemented!\");\n    }\n\n    /**\n     * Returns whether this node is considered solid (ie. the\n     * cost of entering the node is infinite.)\n     *\n     * @return True if this node is solid.\n     */\n    public boolean isSolid() {\n        throw new RuntimeException(\"Method not implemented!\");\n    }\n\n    /**\n     * Specifies whether this node is currently visible.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is currently visible.\n     */\n    public void setVisible(boolean b) {\n        this.visibility = b ? 1.0f : 0.0f;\n    }\n\n    /**\n     * Returns whether this node is considered visible.\n     * @return True if this node is visible.\n     */\n    public boolean isVisible() {\n        return visibility > 0.0f;\n    }\n\n    /**\n     * Sets the degree of visibility of this node.\n     * @param value the degree of visibility.\n     */\n    public void setVisibility(float value) {\n        this.visibility = value;\n    }\n\n    /**\n     * Returns the current degree of visibility of this node.\n     * @return the current degree of visibility of this node.\n     */\n    public float getVisibility() {\n        return visibility;\n    }\n\n    /**\n     * Compares this Node with the specified Object for order.\n     * Note: This method imposes ordering which is inconsistant\n     * with equals.\n     *\n     * @param obj The object which is to be compared.\n     * @return An integer value of -1, 0, or 1, as this node\n     *         is less than, equal to, or greater than obj.\n     *\n     * @throws ClassCastException if obj is not of type Node.\n     */\n    public int compareTo(Object obj) {\n        return compareTo((DefaultNode) obj);\n    }\n\n    public int compareTo(DefaultNode n) {\n        return score < n.score ? -1 : (score > n.score ? 1 : 0);\n    }\n\n    public String toString() {\n        return \"DefaultNode[x=\" + x + \",y=\" + y + \",score=\" + score + \"]\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/map/DefaultNodeTest4.java",
		"test_prompt": "// DefaultNodeTest4.java\npackage map;\n\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DefaultNode}.\n* It contains ten unit test cases for the {@link DefaultNode#compareTo(Object)} method.\n*/\nclass DefaultNodeTest4 {"
	},
	{
		"original_code": "// DefaultNode.java\n/* MapNode.java v0.1 (06/16/2002)\n *\n * Copyright (C) 2002, Joel Andersson <bja@kth.se>\n * \n * This software is hereby expressly placed in the public domain.\n * Share and enjoy.\n */\npackage map;\n\nimport java.util.Vector;\n\n/**\n * The <code>DefaultNode</code> class represents an internal map node. Each\n * cell in the map consists of a <code>DefaultNode</code>.\n */\npublic class DefaultNode implements Node {\n\n    /**\n     * The bitmask associated with this node.\n     */\n    public long bits;\n\n    /**\n     * The parent of this node.\n     */\n    protected Node parent;\n\n    /**\n     * The child nodes of this node.\n     */\n    protected Vector children;\n\n    /**\n     * The cost associated with this node.\n     */\n    protected float cost;\n\n    /**\n     * The total cost associate with this node.\n     */\n    protected float total;\n\n    /**\n     * The score associated with this node.\n     */\n    protected float score;\n\n    /**\n     * The current state of this node.\n     */\n    protected int state;\n\n    /**\n     * The horizontal component of this node.\n     */\n    protected float x;\n\n    /**\n     * The vertical component of this node.\n     */\n    protected float y;\n\n    /**\n     * The z coordinate of this node.\n     */\n    protected float z;\n\n    /**\n     * Specifies whether this node is currently visible.\n     */\n    protected float visibility;\n\n    /**\n     * Creates a new <code>DefaultNode</code>.\n     */\n    public DefaultNode() {\n        this(null);\n    }\n\n    /**\n     * Creates a new <code>DefaultNode</code> with the specified\n     * parent node. The node is initially positionend at (0,0) and\n     * is not solid.\n     *\n     * @param parent The parent of this node.\n     */\n    public DefaultNode(Node parent) {\n        this(null, 0, 0, 0);\n    }\n\n    /**\n     * Creates a new <code>DefaultNode</code> with the specified\n     * parent and attributes.\n     *\n     * @param parent The parent of this node.\n     * @param bits The flags associated with this node.\n     * @param x The horizontal component of this node.\n     * @param y The vertical component of this node.\n     */\n    public DefaultNode(Node parent, long bits, int x, int y) {\n        this.parent = parent;\n        this.bits = bits;\n        this.x = x;\n        this.y = y;\n        this.state = UNSET;\n        this.total = score = cost = 0;\n        children = new Vector();\n    }\n\n    /**\n     * Adds a child node to this node.\n     * @param n The node to add.\n     */\n    public void addChildNode(Node n) {\n        children.add(n);\n    }\n\n    /**\n     * Sets a specific child node given by index to the Node\n     * given by n.\n     *\n     * @param index The index of the child to change.\n     * @param n The node to set in the place of index.\n     */\n    public void setChildNode(int index, Node node) {\n        children.set(index, node);\n    }\n\n    /**\n     * Returns the child at the specified location <code>index</code>.\n     * @return The child at the specified location <code>index</code>.\n     */\n    public Node getChildNode(int index) {\n        return (Node) children.get(index);\n    }\n\n    /**\n     * Returns the children of this <code>Node</code>.\n     * @return The children of this <code>Node</code>.\n     */\n    public Node[] getAllChildren() {\n        Node[] temp = new Node[children.size()];\n        children.copyInto(temp);\n        return temp;\n    }\n\n    /**\n     * Sets the parent of this node to the specified node.\n     * @param n The new parent node.\n     */\n    public void setParent(Node n) {\n        parent = n;\n    }\n\n    /**\n     * Returns this nodes parent.\n     * @return this nodes parent.\n     */\n    public Node getParent() {\n        return parent;\n    }\n\n    /**\n     * Sets the positional coordinates of this node to the\n     * specified values.\n     *\n     * @param x The horizontal component.\n     * @param y The vertical component.\n     */\n    public void setLocation(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public void setLocation(float x, float y, float z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n\n    /**\n     * Returns the horizontal component of this node.\n     * @return the horizontal component of this node.\n     */\n    public float getX() {\n        return x;\n    }\n\n    /**\n     * Returns the vertical component of this node.\n     * @return the vettical component of this node.\n     */\n    public float getY() {\n        return y;\n    }\n\n    /**\n     * Returns the z coordinate of this node.\n     * @return the z coordinate of this node.\n     */\n    public float getZ() {\n        return z;\n    }\n\n    public void setX(float x) {\n        this.x = x;\n    }\n\n    public void setY(float y) {\n        this.y = y;\n    }\n\n    public void setZ(float z) {\n        this.z = z;\n    }\n\n    /**\n     * Sets the cost associated with entering this node.\n     * @param cost the cost associated with entering this node.\n     */\n    public void setCost(float cost) {\n        this.cost = cost;\n    }\n\n    /**\n     * Returns the cost associated with entering this node.\n     * @return The cost associated with entering this node.\n     */\n    public float getCost() {\n        return cost;\n    }\n\n    /**\n     * Sets the total cost associated with this node. The\n     * total cost is the cost of travelling from the start\n     * node to this node.\n     *\n     * @param total The total cost to be associated with\n     *              this node.\n     */\n    public void setTotal(float total) {\n        this.total = total;\n    }\n\n    /**\n     * Returns the total cost associated with this node.\n     * @return The total cost associated with this node.\n     */\n    public float getTotal() {\n        return total;\n    }\n\n    /**\n     * Sets the score associated with this node. The score\n     * determines how good this node is in relation to other\n     * nodes and is used for ordering them amongst each other.\n     *\n     * @param score The score to be associated with this node.\n     */\n    public void setScore(float score) {\n        this.score = score;\n    }\n\n    /**\n     * Returns the score associated with this node.\n     * @return the score associated with this node.\n     */\n    public float getScore() {\n        return score;\n    }\n\n    /**\n     * Specifies whether this node has already been processed\n     * and no longer is considered for further processing.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node has been processed.\n     */\n    public void setClosed(boolean b) {\n        state = b ? state | CLOSED : state & ~CLOSED;\n    }\n\n    /**\n     * Returns true if this node has been processed.\n     * @return True if this node has been processed.\n     */\n    public boolean isClosed() {\n        return (state & CLOSED) > 0;\n    }\n\n    /**\n     * Specifies whether this node is currently being\n     * considered for further processing.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is currently open.\n     */\n    public void setOpen(boolean b) {\n        state = b ? state | OPEN : state & ~OPEN;\n    }\n\n    /**\n     * Returns true if this node is currently being\n     * considered for further processing.\n     *\n     * @return True if this node is open.\n     */\n    public boolean isOpen() {\n        return (state & OPEN) > 0;\n    }\n\n    /**\n     * Sets the data associated with this node. The handles\n     * the way the node is displayed.\n     *\n     * @param data The data to be associated with this node.\n     */\n    public void setData(long data) {\n        this.bits = data;\n    }\n\n    /**\n     * Retrieves the data associated with this node.\n     * @return the data associated with this node.\n     */\n    public long getData() {\n        return bits;\n    }\n\n    /**\n     * Specifies whether this node is solid (ie. the\n     * cost of entering the node is infinite.)\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is solid.\n     */\n    public void setSolid(boolean b) {\n        throw new RuntimeException(\"Method not implemented!\");\n    }\n\n    /**\n     * Returns whether this node is considered solid (ie. the\n     * cost of entering the node is infinite.)\n     *\n     * @return True if this node is solid.\n     */\n    public boolean isSolid() {\n        throw new RuntimeException(\"Method not implemented!\");\n    }\n\n    /**\n     * Specifies whether this node is currently visible.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is currently visible.\n     */\n    public void setVisible(boolean b) {\n        this.visibility = b ? 1.0f : 0.0f;\n    }\n\n    /**\n     * Returns whether this node is considered visible.\n     * @return True if this node is visible.\n     */\n    public boolean isVisible() {\n        return visibility > 0.0f;\n    }\n\n    /**\n     * Sets the degree of visibility of this node.\n     * @param value the degree of visibility.\n     */\n    public void setVisibility(float value) {\n        this.visibility = value;\n    }\n\n    /**\n     * Returns the current degree of visibility of this node.\n     * @return the current degree of visibility of this node.\n     */\n    public float getVisibility() {\n        return visibility;\n    }\n\n    /**\n     * Compares this Node with the specified Object for order.\n     * Note: This method imposes ordering which is inconsistant\n     * with equals.\n     *\n     * @param obj The object which is to be compared.\n     * @return An integer value of -1, 0, or 1, as this node\n     *         is less than, equal to, or greater than obj.\n     *\n     * @throws ClassCastException if obj is not of type Node.\n     */\n    public int compareTo(Object obj) {\n        return compareTo((DefaultNode) obj);\n    }\n\n    public int compareTo(DefaultNode n) {\n        return score < n.score ? -1 : (score > n.score ? 1 : 0);\n    }\n\n    public String toString() {\n        return \"DefaultNode[x=\" + x + \",y=\" + y + \",score=\" + score + \"]\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/map/DefaultNodeTest5.java",
		"test_prompt": "// DefaultNodeTest5.java\npackage map;\n\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DefaultNode}.\n* It contains ten unit test cases for the {@link DefaultNode#compareTo(DefaultNode)} method.\n*/\nclass DefaultNodeTest5 {"
	},
	{
		"original_code": "// DirtyNode.java\n/* DirtyNode.java v0.1 (06/16/2002)\n *\n * Copyright (C) 2002, Joel Andersson <bja@kth.se>\n * \n * This software is hereby expressly placed in the public domain.\n * Share and enjoy.\n */\npackage map;\n\npublic final class DirtyNode implements Node {\n\n    /**\n     * The parent of this node.\n     */\n    public DirtyNode parent;\n\n    /**\n     * The child nodes of this node.\n     */\n    public DirtyNode[] children;\n\n    /**\n     * The cost associated with this node.\n     */\n    public float cost;\n\n    /**\n     * The total cost associate with this node.\n     */\n    public float total;\n\n    /**\n     * The score associated with this node.\n     */\n    public float score;\n\n    /**\n     * The current state of this node.\n     */\n    public int state;\n\n    /**\n     * The bitmask associated with this node.\n     */\n    public long bits;\n\n    /**\n     * The horizontal component of this node.\n     */\n    public float x;\n\n    /**\n     * The vertical component of this node.\n     */\n    public float y;\n\n    /**\n     * The z coordinate of this node.\n     */\n    public float z;\n\n    /**\n     * Specifies whether this node is visible.\n     */\n    public float visibility;\n\n    /**\n     * The number of children of this node.\n     */\n    private int numOfChildren;\n\n    /**\n     * Creates a new DirtyNode with the specified tile.\n     * @param tile The tile to be associated with the node.\n     */\n    public DirtyNode(long bits) {\n        this(bits, 0, 0);\n    }\n\n    /**\n     * Creates a new DirtyNode with the specified attributes.\n     * @param tile The tile to be associated with the node.\n     * @param bits The bits to be associated with the node.\n     * @param x The horizontal component of this node.\n     * @param y The vertical component of this node.\n     */\n    public DirtyNode(long bits, int x, int y) {\n        this.bits = bits;\n        this.x = x;\n        this.y = y;\n        this.numOfChildren = 0;\n        this.children = new DirtyNode[8];\n    }\n\n    /**\n     * Adds the specified node as a child to this node.\n     * @param n The node to add.\n     */\n    public void addChildNode(Node n) {\n        children[numOfChildren++] = (DirtyNode) n;\n    }\n\n    /**\n     * Sets the child of this node given by index to the\n     * specified Node.\n     *\n     * @param index The index of the child to change.\n     * @param n The node to set in the place of index.\n     */\n    public void setChildNode(int index, Node n) {\n        children[index] = (DirtyNode) n;\n    }\n\n    /**\n     * Returns the child at the specified location <code>index</code>.\n     * @return The child at the specified location <code>index</code>.\n     */\n    public Node getChildNode(int index) {\n        return children[index];\n    }\n\n    /**\n     * Returns the children of this <code>Node</code>. The order\n     * of the child nodes returned is unspecified.\n     *\n     * @return The children of this <code>Node</code>.\n     */\n    public Node[] getAllChildren() {\n        return children;\n    }\n\n    /**\n     * Sets the parent of this node to the specified node.\n     * @param parent The new parent node.\n     */\n    public void setParent(Node parent) {\n        this.parent = (DirtyNode) parent;\n    }\n\n    /**\n     * Returns this nodes parent.\n     * @return this nodes parent.\n     */\n    public Node getParent() {\n        return parent;\n    }\n\n    /**\n     * Sets the positional coordinates of this node to the\n     * specified values.\n     *\n     * @param x The horizontal component.\n     * @param y The vertical component.\n     */\n    public void setLocation(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public void setLocation(float x, float y, float z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n\n    /**\n     * Returns the horizontal position of this node.\n     * @return the horizontal position of this node.\n     */\n    public float getX() {\n        return x;\n    }\n\n    /**\n     * Returns the vertical position of this node.\n     * @return the vettical position of this node.\n     */\n    public float getY() {\n        return y;\n    }\n\n    /**\n     * Returns the z coordinate of this node.\n     * @return the z coordinate of this node.\n     */\n    public float getZ() {\n        return z;\n    }\n\n    public void setX(float x) {\n        this.x = x;\n    }\n\n    public void setY(float y) {\n        this.y = y;\n    }\n\n    public void setZ(float z) {\n        this.z = z;\n    }\n\n    /**\n     * Sets the cost associated with entering this node.\n     * @param cost the cost associated with entering this node.\n     */\n    public void setCost(float cost) {\n        this.cost = cost;\n    }\n\n    /**\n     * Returns the cost associated with entering this node.\n     * @return The cost associated with entering this node.\n     */\n    public float getCost() {\n        return cost;\n    }\n\n    /**\n     * Sets the total cost associated with this node. The\n     * total cost is the cost of travelling from the start\n     * node to this node.\n     *\n     * @param total The total cost to be associated with\n     *              this node.\n     */\n    public void setTotal(float total) {\n        this.total = total;\n    }\n\n    /**\n     * Returns the total cost associated with this node.\n     * @return The total cost associated with this node.\n     */\n    public float getTotal() {\n        return total;\n    }\n\n    /**\n     * Sets the score associated with this node. The score\n     * determines how good this node is in relation to other\n     * nodes and is used for ordering them amongst each other.\n     *\n     * @param score The score to be associated with this node.\n     */\n    public void setScore(float score) {\n        this.score = score;\n    }\n\n    /**\n     * Returns the score associated with this node.\n     * @return the score associated with this node.\n     */\n    public float getScore() {\n        return score;\n    }\n\n    /**\n     * Specifies whether this node has already been processed\n     * and no longer is considered for further processing.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node has been processed.\n     */\n    public void setClosed(boolean b) {\n        state = b ? state | CLOSED : state & ~CLOSED;\n    }\n\n    /**\n     * Returns true if this node has been processed.\n     * @return True if this node has been processed.\n     */\n    public boolean isClosed() {\n        return (state & CLOSED) > 0;\n    }\n\n    /**\n     * Specifies whether this node is currently being\n     * considered for further processing.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is currently open.\n     */\n    public void setOpen(boolean b) {\n        state = b ? state | OPEN : state & ~OPEN;\n    }\n\n    /**\n     * Returns true if this node is currently being\n     * considered for further processing.\n     *\n     * @return True if this node is open.\n     */\n    public boolean isOpen() {\n        return (state & OPEN) > 0;\n    }\n\n    /**\n     * Sets the data associated with this node. The handles\n     * the way the node is displayed.\n     *\n     * @param data The data to be associated with this node.\n     */\n    public void setData(long data) {\n        this.bits = data;\n    }\n\n    /**\n     * Retrieves the data associated with this node.\n     * @return the data associated with this node.\n     */\n    public long getData() {\n        return bits;\n    }\n\n    /**\n     * Specifies whether this node is solid (ie. the\n     * cost of entering the node is infinite.)\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is solid.\n     */\n    public void setSolid(boolean b) {\n        throw new RuntimeException(\"Method not implemented!\");\n    }\n\n    /**\n     * Returns whether this node is considered solid (ie. the\n     * cost of entering the node is infinite.)\n     *\n     * @return True if this node is solid.\n     */\n    public boolean isSolid() {\n        throw new RuntimeException(\"Method not implemented!\");\n    }\n\n    /**\n     * Specifies whether this node is currently visible.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is currently visible.\n     */\n    public void setVisible(boolean b) {\n        this.visibility = b ? 1.0f : 0.0f;\n    }\n\n    /**\n     * Returns whether this node is considered visible.\n     * @return True if this node is visible.\n     */\n    public boolean isVisible() {\n        return visibility > 0.0f;\n    }\n\n    /**\n     * Sets the degree of visibility of this node.\n     * @param value the degree of visibility.\n     */\n    public void setVisibility(float value) {\n        this.visibility = value;\n    }\n\n    /**\n     * Returns the current degree of visibility of this node.\n     * @return the current degree of visibility of this node.\n     */\n    public float getVisibility() {\n        return visibility;\n    }\n\n    /**\n     * Compares this Node with the specified Object for order.\n     * <b>Note</b>: This method imposes ordering which is\n     * inconsistant with equals.\n     *\n     * @param obj The object which is to be compared.\n     * @return An integer value of -1, 0, or 1, as this node\n     *         is less than, equal to, or greater than obj.\n     *\n     * @throws ClassCastException if obj is not of type Node.\n     */\n    public int compareTo(Object obj) {\n        return compareTo((DirtyNode) obj);\n    }\n\n    public int compareTo(DirtyNode n) {\n        return score < n.score ? -1 : (score > n.score ? 1 : 0);\n    }\n\n    /**\n     * Compares this node with the specified object for equality.\n     * Two nodes are considered equal if they have the same map\n     * coordinates.\n     *\n     * @param obj The node which is to be compared.\n     * @return True if obj is of type node and has the same map\n     *         coordinate as this node. Otherwise return false.\n     */\n    public boolean equals(Object obj) {\n        return equals((DirtyNode) obj);\n    }\n\n    public boolean equals(DirtyNode n) {\n        return x == n.x && y == n.y;\n    }\n\n    /**\n     * Returns a string representation of this <code>Node</code>.\n     * @return a string representation of this <code>Node</code>.\n     */\n    public String toString() {\n        return \"DirtyNode[x=\" + x + \",y=\" + y + \",score=\" + score + \"]\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/map/DirtyNodeTest0.java",
		"test_prompt": "// DirtyNodeTest0.java\npackage map;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DirtyNode}.\n* It contains ten unit test cases for the {@link DirtyNode#isClosed()} method.\n*/\nclass DirtyNodeTest0 {"
	},
	{
		"original_code": "// DirtyNode.java\n/* DirtyNode.java v0.1 (06/16/2002)\n *\n * Copyright (C) 2002, Joel Andersson <bja@kth.se>\n * \n * This software is hereby expressly placed in the public domain.\n * Share and enjoy.\n */\npackage map;\n\npublic final class DirtyNode implements Node {\n\n    /**\n     * The parent of this node.\n     */\n    public DirtyNode parent;\n\n    /**\n     * The child nodes of this node.\n     */\n    public DirtyNode[] children;\n\n    /**\n     * The cost associated with this node.\n     */\n    public float cost;\n\n    /**\n     * The total cost associate with this node.\n     */\n    public float total;\n\n    /**\n     * The score associated with this node.\n     */\n    public float score;\n\n    /**\n     * The current state of this node.\n     */\n    public int state;\n\n    /**\n     * The bitmask associated with this node.\n     */\n    public long bits;\n\n    /**\n     * The horizontal component of this node.\n     */\n    public float x;\n\n    /**\n     * The vertical component of this node.\n     */\n    public float y;\n\n    /**\n     * The z coordinate of this node.\n     */\n    public float z;\n\n    /**\n     * Specifies whether this node is visible.\n     */\n    public float visibility;\n\n    /**\n     * The number of children of this node.\n     */\n    private int numOfChildren;\n\n    /**\n     * Creates a new DirtyNode with the specified tile.\n     * @param tile The tile to be associated with the node.\n     */\n    public DirtyNode(long bits) {\n        this(bits, 0, 0);\n    }\n\n    /**\n     * Creates a new DirtyNode with the specified attributes.\n     * @param tile The tile to be associated with the node.\n     * @param bits The bits to be associated with the node.\n     * @param x The horizontal component of this node.\n     * @param y The vertical component of this node.\n     */\n    public DirtyNode(long bits, int x, int y) {\n        this.bits = bits;\n        this.x = x;\n        this.y = y;\n        this.numOfChildren = 0;\n        this.children = new DirtyNode[8];\n    }\n\n    /**\n     * Adds the specified node as a child to this node.\n     * @param n The node to add.\n     */\n    public void addChildNode(Node n) {\n        children[numOfChildren++] = (DirtyNode) n;\n    }\n\n    /**\n     * Sets the child of this node given by index to the\n     * specified Node.\n     *\n     * @param index The index of the child to change.\n     * @param n The node to set in the place of index.\n     */\n    public void setChildNode(int index, Node n) {\n        children[index] = (DirtyNode) n;\n    }\n\n    /**\n     * Returns the child at the specified location <code>index</code>.\n     * @return The child at the specified location <code>index</code>.\n     */\n    public Node getChildNode(int index) {\n        return children[index];\n    }\n\n    /**\n     * Returns the children of this <code>Node</code>. The order\n     * of the child nodes returned is unspecified.\n     *\n     * @return The children of this <code>Node</code>.\n     */\n    public Node[] getAllChildren() {\n        return children;\n    }\n\n    /**\n     * Sets the parent of this node to the specified node.\n     * @param parent The new parent node.\n     */\n    public void setParent(Node parent) {\n        this.parent = (DirtyNode) parent;\n    }\n\n    /**\n     * Returns this nodes parent.\n     * @return this nodes parent.\n     */\n    public Node getParent() {\n        return parent;\n    }\n\n    /**\n     * Sets the positional coordinates of this node to the\n     * specified values.\n     *\n     * @param x The horizontal component.\n     * @param y The vertical component.\n     */\n    public void setLocation(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public void setLocation(float x, float y, float z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n\n    /**\n     * Returns the horizontal position of this node.\n     * @return the horizontal position of this node.\n     */\n    public float getX() {\n        return x;\n    }\n\n    /**\n     * Returns the vertical position of this node.\n     * @return the vettical position of this node.\n     */\n    public float getY() {\n        return y;\n    }\n\n    /**\n     * Returns the z coordinate of this node.\n     * @return the z coordinate of this node.\n     */\n    public float getZ() {\n        return z;\n    }\n\n    public void setX(float x) {\n        this.x = x;\n    }\n\n    public void setY(float y) {\n        this.y = y;\n    }\n\n    public void setZ(float z) {\n        this.z = z;\n    }\n\n    /**\n     * Sets the cost associated with entering this node.\n     * @param cost the cost associated with entering this node.\n     */\n    public void setCost(float cost) {\n        this.cost = cost;\n    }\n\n    /**\n     * Returns the cost associated with entering this node.\n     * @return The cost associated with entering this node.\n     */\n    public float getCost() {\n        return cost;\n    }\n\n    /**\n     * Sets the total cost associated with this node. The\n     * total cost is the cost of travelling from the start\n     * node to this node.\n     *\n     * @param total The total cost to be associated with\n     *              this node.\n     */\n    public void setTotal(float total) {\n        this.total = total;\n    }\n\n    /**\n     * Returns the total cost associated with this node.\n     * @return The total cost associated with this node.\n     */\n    public float getTotal() {\n        return total;\n    }\n\n    /**\n     * Sets the score associated with this node. The score\n     * determines how good this node is in relation to other\n     * nodes and is used for ordering them amongst each other.\n     *\n     * @param score The score to be associated with this node.\n     */\n    public void setScore(float score) {\n        this.score = score;\n    }\n\n    /**\n     * Returns the score associated with this node.\n     * @return the score associated with this node.\n     */\n    public float getScore() {\n        return score;\n    }\n\n    /**\n     * Specifies whether this node has already been processed\n     * and no longer is considered for further processing.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node has been processed.\n     */\n    public void setClosed(boolean b) {\n        state = b ? state | CLOSED : state & ~CLOSED;\n    }\n\n    /**\n     * Returns true if this node has been processed.\n     * @return True if this node has been processed.\n     */\n    public boolean isClosed() {\n        return (state & CLOSED) > 0;\n    }\n\n    /**\n     * Specifies whether this node is currently being\n     * considered for further processing.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is currently open.\n     */\n    public void setOpen(boolean b) {\n        state = b ? state | OPEN : state & ~OPEN;\n    }\n\n    /**\n     * Returns true if this node is currently being\n     * considered for further processing.\n     *\n     * @return True if this node is open.\n     */\n    public boolean isOpen() {\n        return (state & OPEN) > 0;\n    }\n\n    /**\n     * Sets the data associated with this node. The handles\n     * the way the node is displayed.\n     *\n     * @param data The data to be associated with this node.\n     */\n    public void setData(long data) {\n        this.bits = data;\n    }\n\n    /**\n     * Retrieves the data associated with this node.\n     * @return the data associated with this node.\n     */\n    public long getData() {\n        return bits;\n    }\n\n    /**\n     * Specifies whether this node is solid (ie. the\n     * cost of entering the node is infinite.)\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is solid.\n     */\n    public void setSolid(boolean b) {\n        throw new RuntimeException(\"Method not implemented!\");\n    }\n\n    /**\n     * Returns whether this node is considered solid (ie. the\n     * cost of entering the node is infinite.)\n     *\n     * @return True if this node is solid.\n     */\n    public boolean isSolid() {\n        throw new RuntimeException(\"Method not implemented!\");\n    }\n\n    /**\n     * Specifies whether this node is currently visible.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is currently visible.\n     */\n    public void setVisible(boolean b) {\n        this.visibility = b ? 1.0f : 0.0f;\n    }\n\n    /**\n     * Returns whether this node is considered visible.\n     * @return True if this node is visible.\n     */\n    public boolean isVisible() {\n        return visibility > 0.0f;\n    }\n\n    /**\n     * Sets the degree of visibility of this node.\n     * @param value the degree of visibility.\n     */\n    public void setVisibility(float value) {\n        this.visibility = value;\n    }\n\n    /**\n     * Returns the current degree of visibility of this node.\n     * @return the current degree of visibility of this node.\n     */\n    public float getVisibility() {\n        return visibility;\n    }\n\n    /**\n     * Compares this Node with the specified Object for order.\n     * <b>Note</b>: This method imposes ordering which is\n     * inconsistant with equals.\n     *\n     * @param obj The object which is to be compared.\n     * @return An integer value of -1, 0, or 1, as this node\n     *         is less than, equal to, or greater than obj.\n     *\n     * @throws ClassCastException if obj is not of type Node.\n     */\n    public int compareTo(Object obj) {\n        return compareTo((DirtyNode) obj);\n    }\n\n    public int compareTo(DirtyNode n) {\n        return score < n.score ? -1 : (score > n.score ? 1 : 0);\n    }\n\n    /**\n     * Compares this node with the specified object for equality.\n     * Two nodes are considered equal if they have the same map\n     * coordinates.\n     *\n     * @param obj The node which is to be compared.\n     * @return True if obj is of type node and has the same map\n     *         coordinate as this node. Otherwise return false.\n     */\n    public boolean equals(Object obj) {\n        return equals((DirtyNode) obj);\n    }\n\n    public boolean equals(DirtyNode n) {\n        return x == n.x && y == n.y;\n    }\n\n    /**\n     * Returns a string representation of this <code>Node</code>.\n     * @return a string representation of this <code>Node</code>.\n     */\n    public String toString() {\n        return \"DirtyNode[x=\" + x + \",y=\" + y + \",score=\" + score + \"]\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/map/DirtyNodeTest1.java",
		"test_prompt": "// DirtyNodeTest1.java\npackage map;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DirtyNode}.\n* It contains ten unit test cases for the {@link DirtyNode#isOpen()} method.\n*/\nclass DirtyNodeTest1 {"
	},
	{
		"original_code": "// DirtyNode.java\n/* DirtyNode.java v0.1 (06/16/2002)\n *\n * Copyright (C) 2002, Joel Andersson <bja@kth.se>\n * \n * This software is hereby expressly placed in the public domain.\n * Share and enjoy.\n */\npackage map;\n\npublic final class DirtyNode implements Node {\n\n    /**\n     * The parent of this node.\n     */\n    public DirtyNode parent;\n\n    /**\n     * The child nodes of this node.\n     */\n    public DirtyNode[] children;\n\n    /**\n     * The cost associated with this node.\n     */\n    public float cost;\n\n    /**\n     * The total cost associate with this node.\n     */\n    public float total;\n\n    /**\n     * The score associated with this node.\n     */\n    public float score;\n\n    /**\n     * The current state of this node.\n     */\n    public int state;\n\n    /**\n     * The bitmask associated with this node.\n     */\n    public long bits;\n\n    /**\n     * The horizontal component of this node.\n     */\n    public float x;\n\n    /**\n     * The vertical component of this node.\n     */\n    public float y;\n\n    /**\n     * The z coordinate of this node.\n     */\n    public float z;\n\n    /**\n     * Specifies whether this node is visible.\n     */\n    public float visibility;\n\n    /**\n     * The number of children of this node.\n     */\n    private int numOfChildren;\n\n    /**\n     * Creates a new DirtyNode with the specified tile.\n     * @param tile The tile to be associated with the node.\n     */\n    public DirtyNode(long bits) {\n        this(bits, 0, 0);\n    }\n\n    /**\n     * Creates a new DirtyNode with the specified attributes.\n     * @param tile The tile to be associated with the node.\n     * @param bits The bits to be associated with the node.\n     * @param x The horizontal component of this node.\n     * @param y The vertical component of this node.\n     */\n    public DirtyNode(long bits, int x, int y) {\n        this.bits = bits;\n        this.x = x;\n        this.y = y;\n        this.numOfChildren = 0;\n        this.children = new DirtyNode[8];\n    }\n\n    /**\n     * Adds the specified node as a child to this node.\n     * @param n The node to add.\n     */\n    public void addChildNode(Node n) {\n        children[numOfChildren++] = (DirtyNode) n;\n    }\n\n    /**\n     * Sets the child of this node given by index to the\n     * specified Node.\n     *\n     * @param index The index of the child to change.\n     * @param n The node to set in the place of index.\n     */\n    public void setChildNode(int index, Node n) {\n        children[index] = (DirtyNode) n;\n    }\n\n    /**\n     * Returns the child at the specified location <code>index</code>.\n     * @return The child at the specified location <code>index</code>.\n     */\n    public Node getChildNode(int index) {\n        return children[index];\n    }\n\n    /**\n     * Returns the children of this <code>Node</code>. The order\n     * of the child nodes returned is unspecified.\n     *\n     * @return The children of this <code>Node</code>.\n     */\n    public Node[] getAllChildren() {\n        return children;\n    }\n\n    /**\n     * Sets the parent of this node to the specified node.\n     * @param parent The new parent node.\n     */\n    public void setParent(Node parent) {\n        this.parent = (DirtyNode) parent;\n    }\n\n    /**\n     * Returns this nodes parent.\n     * @return this nodes parent.\n     */\n    public Node getParent() {\n        return parent;\n    }\n\n    /**\n     * Sets the positional coordinates of this node to the\n     * specified values.\n     *\n     * @param x The horizontal component.\n     * @param y The vertical component.\n     */\n    public void setLocation(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public void setLocation(float x, float y, float z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n\n    /**\n     * Returns the horizontal position of this node.\n     * @return the horizontal position of this node.\n     */\n    public float getX() {\n        return x;\n    }\n\n    /**\n     * Returns the vertical position of this node.\n     * @return the vettical position of this node.\n     */\n    public float getY() {\n        return y;\n    }\n\n    /**\n     * Returns the z coordinate of this node.\n     * @return the z coordinate of this node.\n     */\n    public float getZ() {\n        return z;\n    }\n\n    public void setX(float x) {\n        this.x = x;\n    }\n\n    public void setY(float y) {\n        this.y = y;\n    }\n\n    public void setZ(float z) {\n        this.z = z;\n    }\n\n    /**\n     * Sets the cost associated with entering this node.\n     * @param cost the cost associated with entering this node.\n     */\n    public void setCost(float cost) {\n        this.cost = cost;\n    }\n\n    /**\n     * Returns the cost associated with entering this node.\n     * @return The cost associated with entering this node.\n     */\n    public float getCost() {\n        return cost;\n    }\n\n    /**\n     * Sets the total cost associated with this node. The\n     * total cost is the cost of travelling from the start\n     * node to this node.\n     *\n     * @param total The total cost to be associated with\n     *              this node.\n     */\n    public void setTotal(float total) {\n        this.total = total;\n    }\n\n    /**\n     * Returns the total cost associated with this node.\n     * @return The total cost associated with this node.\n     */\n    public float getTotal() {\n        return total;\n    }\n\n    /**\n     * Sets the score associated with this node. The score\n     * determines how good this node is in relation to other\n     * nodes and is used for ordering them amongst each other.\n     *\n     * @param score The score to be associated with this node.\n     */\n    public void setScore(float score) {\n        this.score = score;\n    }\n\n    /**\n     * Returns the score associated with this node.\n     * @return the score associated with this node.\n     */\n    public float getScore() {\n        return score;\n    }\n\n    /**\n     * Specifies whether this node has already been processed\n     * and no longer is considered for further processing.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node has been processed.\n     */\n    public void setClosed(boolean b) {\n        state = b ? state | CLOSED : state & ~CLOSED;\n    }\n\n    /**\n     * Returns true if this node has been processed.\n     * @return True if this node has been processed.\n     */\n    public boolean isClosed() {\n        return (state & CLOSED) > 0;\n    }\n\n    /**\n     * Specifies whether this node is currently being\n     * considered for further processing.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is currently open.\n     */\n    public void setOpen(boolean b) {\n        state = b ? state | OPEN : state & ~OPEN;\n    }\n\n    /**\n     * Returns true if this node is currently being\n     * considered for further processing.\n     *\n     * @return True if this node is open.\n     */\n    public boolean isOpen() {\n        return (state & OPEN) > 0;\n    }\n\n    /**\n     * Sets the data associated with this node. The handles\n     * the way the node is displayed.\n     *\n     * @param data The data to be associated with this node.\n     */\n    public void setData(long data) {\n        this.bits = data;\n    }\n\n    /**\n     * Retrieves the data associated with this node.\n     * @return the data associated with this node.\n     */\n    public long getData() {\n        return bits;\n    }\n\n    /**\n     * Specifies whether this node is solid (ie. the\n     * cost of entering the node is infinite.)\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is solid.\n     */\n    public void setSolid(boolean b) {\n        throw new RuntimeException(\"Method not implemented!\");\n    }\n\n    /**\n     * Returns whether this node is considered solid (ie. the\n     * cost of entering the node is infinite.)\n     *\n     * @return True if this node is solid.\n     */\n    public boolean isSolid() {\n        throw new RuntimeException(\"Method not implemented!\");\n    }\n\n    /**\n     * Specifies whether this node is currently visible.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is currently visible.\n     */\n    public void setVisible(boolean b) {\n        this.visibility = b ? 1.0f : 0.0f;\n    }\n\n    /**\n     * Returns whether this node is considered visible.\n     * @return True if this node is visible.\n     */\n    public boolean isVisible() {\n        return visibility > 0.0f;\n    }\n\n    /**\n     * Sets the degree of visibility of this node.\n     * @param value the degree of visibility.\n     */\n    public void setVisibility(float value) {\n        this.visibility = value;\n    }\n\n    /**\n     * Returns the current degree of visibility of this node.\n     * @return the current degree of visibility of this node.\n     */\n    public float getVisibility() {\n        return visibility;\n    }\n\n    /**\n     * Compares this Node with the specified Object for order.\n     * <b>Note</b>: This method imposes ordering which is\n     * inconsistant with equals.\n     *\n     * @param obj The object which is to be compared.\n     * @return An integer value of -1, 0, or 1, as this node\n     *         is less than, equal to, or greater than obj.\n     *\n     * @throws ClassCastException if obj is not of type Node.\n     */\n    public int compareTo(Object obj) {\n        return compareTo((DirtyNode) obj);\n    }\n\n    public int compareTo(DirtyNode n) {\n        return score < n.score ? -1 : (score > n.score ? 1 : 0);\n    }\n\n    /**\n     * Compares this node with the specified object for equality.\n     * Two nodes are considered equal if they have the same map\n     * coordinates.\n     *\n     * @param obj The node which is to be compared.\n     * @return True if obj is of type node and has the same map\n     *         coordinate as this node. Otherwise return false.\n     */\n    public boolean equals(Object obj) {\n        return equals((DirtyNode) obj);\n    }\n\n    public boolean equals(DirtyNode n) {\n        return x == n.x && y == n.y;\n    }\n\n    /**\n     * Returns a string representation of this <code>Node</code>.\n     * @return a string representation of this <code>Node</code>.\n     */\n    public String toString() {\n        return \"DirtyNode[x=\" + x + \",y=\" + y + \",score=\" + score + \"]\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/map/DirtyNodeTest2.java",
		"test_prompt": "// DirtyNodeTest2.java\npackage map;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DirtyNode}.\n* It contains ten unit test cases for the {@link DirtyNode#isSolid()} method.\n*/\nclass DirtyNodeTest2 {"
	},
	{
		"original_code": "// DirtyNode.java\n/* DirtyNode.java v0.1 (06/16/2002)\n *\n * Copyright (C) 2002, Joel Andersson <bja@kth.se>\n * \n * This software is hereby expressly placed in the public domain.\n * Share and enjoy.\n */\npackage map;\n\npublic final class DirtyNode implements Node {\n\n    /**\n     * The parent of this node.\n     */\n    public DirtyNode parent;\n\n    /**\n     * The child nodes of this node.\n     */\n    public DirtyNode[] children;\n\n    /**\n     * The cost associated with this node.\n     */\n    public float cost;\n\n    /**\n     * The total cost associate with this node.\n     */\n    public float total;\n\n    /**\n     * The score associated with this node.\n     */\n    public float score;\n\n    /**\n     * The current state of this node.\n     */\n    public int state;\n\n    /**\n     * The bitmask associated with this node.\n     */\n    public long bits;\n\n    /**\n     * The horizontal component of this node.\n     */\n    public float x;\n\n    /**\n     * The vertical component of this node.\n     */\n    public float y;\n\n    /**\n     * The z coordinate of this node.\n     */\n    public float z;\n\n    /**\n     * Specifies whether this node is visible.\n     */\n    public float visibility;\n\n    /**\n     * The number of children of this node.\n     */\n    private int numOfChildren;\n\n    /**\n     * Creates a new DirtyNode with the specified tile.\n     * @param tile The tile to be associated with the node.\n     */\n    public DirtyNode(long bits) {\n        this(bits, 0, 0);\n    }\n\n    /**\n     * Creates a new DirtyNode with the specified attributes.\n     * @param tile The tile to be associated with the node.\n     * @param bits The bits to be associated with the node.\n     * @param x The horizontal component of this node.\n     * @param y The vertical component of this node.\n     */\n    public DirtyNode(long bits, int x, int y) {\n        this.bits = bits;\n        this.x = x;\n        this.y = y;\n        this.numOfChildren = 0;\n        this.children = new DirtyNode[8];\n    }\n\n    /**\n     * Adds the specified node as a child to this node.\n     * @param n The node to add.\n     */\n    public void addChildNode(Node n) {\n        children[numOfChildren++] = (DirtyNode) n;\n    }\n\n    /**\n     * Sets the child of this node given by index to the\n     * specified Node.\n     *\n     * @param index The index of the child to change.\n     * @param n The node to set in the place of index.\n     */\n    public void setChildNode(int index, Node n) {\n        children[index] = (DirtyNode) n;\n    }\n\n    /**\n     * Returns the child at the specified location <code>index</code>.\n     * @return The child at the specified location <code>index</code>.\n     */\n    public Node getChildNode(int index) {\n        return children[index];\n    }\n\n    /**\n     * Returns the children of this <code>Node</code>. The order\n     * of the child nodes returned is unspecified.\n     *\n     * @return The children of this <code>Node</code>.\n     */\n    public Node[] getAllChildren() {\n        return children;\n    }\n\n    /**\n     * Sets the parent of this node to the specified node.\n     * @param parent The new parent node.\n     */\n    public void setParent(Node parent) {\n        this.parent = (DirtyNode) parent;\n    }\n\n    /**\n     * Returns this nodes parent.\n     * @return this nodes parent.\n     */\n    public Node getParent() {\n        return parent;\n    }\n\n    /**\n     * Sets the positional coordinates of this node to the\n     * specified values.\n     *\n     * @param x The horizontal component.\n     * @param y The vertical component.\n     */\n    public void setLocation(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public void setLocation(float x, float y, float z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n\n    /**\n     * Returns the horizontal position of this node.\n     * @return the horizontal position of this node.\n     */\n    public float getX() {\n        return x;\n    }\n\n    /**\n     * Returns the vertical position of this node.\n     * @return the vettical position of this node.\n     */\n    public float getY() {\n        return y;\n    }\n\n    /**\n     * Returns the z coordinate of this node.\n     * @return the z coordinate of this node.\n     */\n    public float getZ() {\n        return z;\n    }\n\n    public void setX(float x) {\n        this.x = x;\n    }\n\n    public void setY(float y) {\n        this.y = y;\n    }\n\n    public void setZ(float z) {\n        this.z = z;\n    }\n\n    /**\n     * Sets the cost associated with entering this node.\n     * @param cost the cost associated with entering this node.\n     */\n    public void setCost(float cost) {\n        this.cost = cost;\n    }\n\n    /**\n     * Returns the cost associated with entering this node.\n     * @return The cost associated with entering this node.\n     */\n    public float getCost() {\n        return cost;\n    }\n\n    /**\n     * Sets the total cost associated with this node. The\n     * total cost is the cost of travelling from the start\n     * node to this node.\n     *\n     * @param total The total cost to be associated with\n     *              this node.\n     */\n    public void setTotal(float total) {\n        this.total = total;\n    }\n\n    /**\n     * Returns the total cost associated with this node.\n     * @return The total cost associated with this node.\n     */\n    public float getTotal() {\n        return total;\n    }\n\n    /**\n     * Sets the score associated with this node. The score\n     * determines how good this node is in relation to other\n     * nodes and is used for ordering them amongst each other.\n     *\n     * @param score The score to be associated with this node.\n     */\n    public void setScore(float score) {\n        this.score = score;\n    }\n\n    /**\n     * Returns the score associated with this node.\n     * @return the score associated with this node.\n     */\n    public float getScore() {\n        return score;\n    }\n\n    /**\n     * Specifies whether this node has already been processed\n     * and no longer is considered for further processing.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node has been processed.\n     */\n    public void setClosed(boolean b) {\n        state = b ? state | CLOSED : state & ~CLOSED;\n    }\n\n    /**\n     * Returns true if this node has been processed.\n     * @return True if this node has been processed.\n     */\n    public boolean isClosed() {\n        return (state & CLOSED) > 0;\n    }\n\n    /**\n     * Specifies whether this node is currently being\n     * considered for further processing.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is currently open.\n     */\n    public void setOpen(boolean b) {\n        state = b ? state | OPEN : state & ~OPEN;\n    }\n\n    /**\n     * Returns true if this node is currently being\n     * considered for further processing.\n     *\n     * @return True if this node is open.\n     */\n    public boolean isOpen() {\n        return (state & OPEN) > 0;\n    }\n\n    /**\n     * Sets the data associated with this node. The handles\n     * the way the node is displayed.\n     *\n     * @param data The data to be associated with this node.\n     */\n    public void setData(long data) {\n        this.bits = data;\n    }\n\n    /**\n     * Retrieves the data associated with this node.\n     * @return the data associated with this node.\n     */\n    public long getData() {\n        return bits;\n    }\n\n    /**\n     * Specifies whether this node is solid (ie. the\n     * cost of entering the node is infinite.)\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is solid.\n     */\n    public void setSolid(boolean b) {\n        throw new RuntimeException(\"Method not implemented!\");\n    }\n\n    /**\n     * Returns whether this node is considered solid (ie. the\n     * cost of entering the node is infinite.)\n     *\n     * @return True if this node is solid.\n     */\n    public boolean isSolid() {\n        throw new RuntimeException(\"Method not implemented!\");\n    }\n\n    /**\n     * Specifies whether this node is currently visible.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is currently visible.\n     */\n    public void setVisible(boolean b) {\n        this.visibility = b ? 1.0f : 0.0f;\n    }\n\n    /**\n     * Returns whether this node is considered visible.\n     * @return True if this node is visible.\n     */\n    public boolean isVisible() {\n        return visibility > 0.0f;\n    }\n\n    /**\n     * Sets the degree of visibility of this node.\n     * @param value the degree of visibility.\n     */\n    public void setVisibility(float value) {\n        this.visibility = value;\n    }\n\n    /**\n     * Returns the current degree of visibility of this node.\n     * @return the current degree of visibility of this node.\n     */\n    public float getVisibility() {\n        return visibility;\n    }\n\n    /**\n     * Compares this Node with the specified Object for order.\n     * <b>Note</b>: This method imposes ordering which is\n     * inconsistant with equals.\n     *\n     * @param obj The object which is to be compared.\n     * @return An integer value of -1, 0, or 1, as this node\n     *         is less than, equal to, or greater than obj.\n     *\n     * @throws ClassCastException if obj is not of type Node.\n     */\n    public int compareTo(Object obj) {\n        return compareTo((DirtyNode) obj);\n    }\n\n    public int compareTo(DirtyNode n) {\n        return score < n.score ? -1 : (score > n.score ? 1 : 0);\n    }\n\n    /**\n     * Compares this node with the specified object for equality.\n     * Two nodes are considered equal if they have the same map\n     * coordinates.\n     *\n     * @param obj The node which is to be compared.\n     * @return True if obj is of type node and has the same map\n     *         coordinate as this node. Otherwise return false.\n     */\n    public boolean equals(Object obj) {\n        return equals((DirtyNode) obj);\n    }\n\n    public boolean equals(DirtyNode n) {\n        return x == n.x && y == n.y;\n    }\n\n    /**\n     * Returns a string representation of this <code>Node</code>.\n     * @return a string representation of this <code>Node</code>.\n     */\n    public String toString() {\n        return \"DirtyNode[x=\" + x + \",y=\" + y + \",score=\" + score + \"]\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/map/DirtyNodeTest3.java",
		"test_prompt": "// DirtyNodeTest3.java\npackage map;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DirtyNode}.\n* It contains ten unit test cases for the {@link DirtyNode#isVisible()} method.\n*/\nclass DirtyNodeTest3 {"
	},
	{
		"original_code": "// DirtyNode.java\n/* DirtyNode.java v0.1 (06/16/2002)\n *\n * Copyright (C) 2002, Joel Andersson <bja@kth.se>\n * \n * This software is hereby expressly placed in the public domain.\n * Share and enjoy.\n */\npackage map;\n\npublic final class DirtyNode implements Node {\n\n    /**\n     * The parent of this node.\n     */\n    public DirtyNode parent;\n\n    /**\n     * The child nodes of this node.\n     */\n    public DirtyNode[] children;\n\n    /**\n     * The cost associated with this node.\n     */\n    public float cost;\n\n    /**\n     * The total cost associate with this node.\n     */\n    public float total;\n\n    /**\n     * The score associated with this node.\n     */\n    public float score;\n\n    /**\n     * The current state of this node.\n     */\n    public int state;\n\n    /**\n     * The bitmask associated with this node.\n     */\n    public long bits;\n\n    /**\n     * The horizontal component of this node.\n     */\n    public float x;\n\n    /**\n     * The vertical component of this node.\n     */\n    public float y;\n\n    /**\n     * The z coordinate of this node.\n     */\n    public float z;\n\n    /**\n     * Specifies whether this node is visible.\n     */\n    public float visibility;\n\n    /**\n     * The number of children of this node.\n     */\n    private int numOfChildren;\n\n    /**\n     * Creates a new DirtyNode with the specified tile.\n     * @param tile The tile to be associated with the node.\n     */\n    public DirtyNode(long bits) {\n        this(bits, 0, 0);\n    }\n\n    /**\n     * Creates a new DirtyNode with the specified attributes.\n     * @param tile The tile to be associated with the node.\n     * @param bits The bits to be associated with the node.\n     * @param x The horizontal component of this node.\n     * @param y The vertical component of this node.\n     */\n    public DirtyNode(long bits, int x, int y) {\n        this.bits = bits;\n        this.x = x;\n        this.y = y;\n        this.numOfChildren = 0;\n        this.children = new DirtyNode[8];\n    }\n\n    /**\n     * Adds the specified node as a child to this node.\n     * @param n The node to add.\n     */\n    public void addChildNode(Node n) {\n        children[numOfChildren++] = (DirtyNode) n;\n    }\n\n    /**\n     * Sets the child of this node given by index to the\n     * specified Node.\n     *\n     * @param index The index of the child to change.\n     * @param n The node to set in the place of index.\n     */\n    public void setChildNode(int index, Node n) {\n        children[index] = (DirtyNode) n;\n    }\n\n    /**\n     * Returns the child at the specified location <code>index</code>.\n     * @return The child at the specified location <code>index</code>.\n     */\n    public Node getChildNode(int index) {\n        return children[index];\n    }\n\n    /**\n     * Returns the children of this <code>Node</code>. The order\n     * of the child nodes returned is unspecified.\n     *\n     * @return The children of this <code>Node</code>.\n     */\n    public Node[] getAllChildren() {\n        return children;\n    }\n\n    /**\n     * Sets the parent of this node to the specified node.\n     * @param parent The new parent node.\n     */\n    public void setParent(Node parent) {\n        this.parent = (DirtyNode) parent;\n    }\n\n    /**\n     * Returns this nodes parent.\n     * @return this nodes parent.\n     */\n    public Node getParent() {\n        return parent;\n    }\n\n    /**\n     * Sets the positional coordinates of this node to the\n     * specified values.\n     *\n     * @param x The horizontal component.\n     * @param y The vertical component.\n     */\n    public void setLocation(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public void setLocation(float x, float y, float z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n\n    /**\n     * Returns the horizontal position of this node.\n     * @return the horizontal position of this node.\n     */\n    public float getX() {\n        return x;\n    }\n\n    /**\n     * Returns the vertical position of this node.\n     * @return the vettical position of this node.\n     */\n    public float getY() {\n        return y;\n    }\n\n    /**\n     * Returns the z coordinate of this node.\n     * @return the z coordinate of this node.\n     */\n    public float getZ() {\n        return z;\n    }\n\n    public void setX(float x) {\n        this.x = x;\n    }\n\n    public void setY(float y) {\n        this.y = y;\n    }\n\n    public void setZ(float z) {\n        this.z = z;\n    }\n\n    /**\n     * Sets the cost associated with entering this node.\n     * @param cost the cost associated with entering this node.\n     */\n    public void setCost(float cost) {\n        this.cost = cost;\n    }\n\n    /**\n     * Returns the cost associated with entering this node.\n     * @return The cost associated with entering this node.\n     */\n    public float getCost() {\n        return cost;\n    }\n\n    /**\n     * Sets the total cost associated with this node. The\n     * total cost is the cost of travelling from the start\n     * node to this node.\n     *\n     * @param total The total cost to be associated with\n     *              this node.\n     */\n    public void setTotal(float total) {\n        this.total = total;\n    }\n\n    /**\n     * Returns the total cost associated with this node.\n     * @return The total cost associated with this node.\n     */\n    public float getTotal() {\n        return total;\n    }\n\n    /**\n     * Sets the score associated with this node. The score\n     * determines how good this node is in relation to other\n     * nodes and is used for ordering them amongst each other.\n     *\n     * @param score The score to be associated with this node.\n     */\n    public void setScore(float score) {\n        this.score = score;\n    }\n\n    /**\n     * Returns the score associated with this node.\n     * @return the score associated with this node.\n     */\n    public float getScore() {\n        return score;\n    }\n\n    /**\n     * Specifies whether this node has already been processed\n     * and no longer is considered for further processing.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node has been processed.\n     */\n    public void setClosed(boolean b) {\n        state = b ? state | CLOSED : state & ~CLOSED;\n    }\n\n    /**\n     * Returns true if this node has been processed.\n     * @return True if this node has been processed.\n     */\n    public boolean isClosed() {\n        return (state & CLOSED) > 0;\n    }\n\n    /**\n     * Specifies whether this node is currently being\n     * considered for further processing.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is currently open.\n     */\n    public void setOpen(boolean b) {\n        state = b ? state | OPEN : state & ~OPEN;\n    }\n\n    /**\n     * Returns true if this node is currently being\n     * considered for further processing.\n     *\n     * @return True if this node is open.\n     */\n    public boolean isOpen() {\n        return (state & OPEN) > 0;\n    }\n\n    /**\n     * Sets the data associated with this node. The handles\n     * the way the node is displayed.\n     *\n     * @param data The data to be associated with this node.\n     */\n    public void setData(long data) {\n        this.bits = data;\n    }\n\n    /**\n     * Retrieves the data associated with this node.\n     * @return the data associated with this node.\n     */\n    public long getData() {\n        return bits;\n    }\n\n    /**\n     * Specifies whether this node is solid (ie. the\n     * cost of entering the node is infinite.)\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is solid.\n     */\n    public void setSolid(boolean b) {\n        throw new RuntimeException(\"Method not implemented!\");\n    }\n\n    /**\n     * Returns whether this node is considered solid (ie. the\n     * cost of entering the node is infinite.)\n     *\n     * @return True if this node is solid.\n     */\n    public boolean isSolid() {\n        throw new RuntimeException(\"Method not implemented!\");\n    }\n\n    /**\n     * Specifies whether this node is currently visible.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is currently visible.\n     */\n    public void setVisible(boolean b) {\n        this.visibility = b ? 1.0f : 0.0f;\n    }\n\n    /**\n     * Returns whether this node is considered visible.\n     * @return True if this node is visible.\n     */\n    public boolean isVisible() {\n        return visibility > 0.0f;\n    }\n\n    /**\n     * Sets the degree of visibility of this node.\n     * @param value the degree of visibility.\n     */\n    public void setVisibility(float value) {\n        this.visibility = value;\n    }\n\n    /**\n     * Returns the current degree of visibility of this node.\n     * @return the current degree of visibility of this node.\n     */\n    public float getVisibility() {\n        return visibility;\n    }\n\n    /**\n     * Compares this Node with the specified Object for order.\n     * <b>Note</b>: This method imposes ordering which is\n     * inconsistant with equals.\n     *\n     * @param obj The object which is to be compared.\n     * @return An integer value of -1, 0, or 1, as this node\n     *         is less than, equal to, or greater than obj.\n     *\n     * @throws ClassCastException if obj is not of type Node.\n     */\n    public int compareTo(Object obj) {\n        return compareTo((DirtyNode) obj);\n    }\n\n    public int compareTo(DirtyNode n) {\n        return score < n.score ? -1 : (score > n.score ? 1 : 0);\n    }\n\n    /**\n     * Compares this node with the specified object for equality.\n     * Two nodes are considered equal if they have the same map\n     * coordinates.\n     *\n     * @param obj The node which is to be compared.\n     * @return True if obj is of type node and has the same map\n     *         coordinate as this node. Otherwise return false.\n     */\n    public boolean equals(Object obj) {\n        return equals((DirtyNode) obj);\n    }\n\n    public boolean equals(DirtyNode n) {\n        return x == n.x && y == n.y;\n    }\n\n    /**\n     * Returns a string representation of this <code>Node</code>.\n     * @return a string representation of this <code>Node</code>.\n     */\n    public String toString() {\n        return \"DirtyNode[x=\" + x + \",y=\" + y + \",score=\" + score + \"]\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/map/DirtyNodeTest4.java",
		"test_prompt": "// DirtyNodeTest4.java\npackage map;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DirtyNode}.\n* It contains ten unit test cases for the {@link DirtyNode#compareTo(Object)} method.\n*/\nclass DirtyNodeTest4 {"
	},
	{
		"original_code": "// DirtyNode.java\n/* DirtyNode.java v0.1 (06/16/2002)\n *\n * Copyright (C) 2002, Joel Andersson <bja@kth.se>\n * \n * This software is hereby expressly placed in the public domain.\n * Share and enjoy.\n */\npackage map;\n\npublic final class DirtyNode implements Node {\n\n    /**\n     * The parent of this node.\n     */\n    public DirtyNode parent;\n\n    /**\n     * The child nodes of this node.\n     */\n    public DirtyNode[] children;\n\n    /**\n     * The cost associated with this node.\n     */\n    public float cost;\n\n    /**\n     * The total cost associate with this node.\n     */\n    public float total;\n\n    /**\n     * The score associated with this node.\n     */\n    public float score;\n\n    /**\n     * The current state of this node.\n     */\n    public int state;\n\n    /**\n     * The bitmask associated with this node.\n     */\n    public long bits;\n\n    /**\n     * The horizontal component of this node.\n     */\n    public float x;\n\n    /**\n     * The vertical component of this node.\n     */\n    public float y;\n\n    /**\n     * The z coordinate of this node.\n     */\n    public float z;\n\n    /**\n     * Specifies whether this node is visible.\n     */\n    public float visibility;\n\n    /**\n     * The number of children of this node.\n     */\n    private int numOfChildren;\n\n    /**\n     * Creates a new DirtyNode with the specified tile.\n     * @param tile The tile to be associated with the node.\n     */\n    public DirtyNode(long bits) {\n        this(bits, 0, 0);\n    }\n\n    /**\n     * Creates a new DirtyNode with the specified attributes.\n     * @param tile The tile to be associated with the node.\n     * @param bits The bits to be associated with the node.\n     * @param x The horizontal component of this node.\n     * @param y The vertical component of this node.\n     */\n    public DirtyNode(long bits, int x, int y) {\n        this.bits = bits;\n        this.x = x;\n        this.y = y;\n        this.numOfChildren = 0;\n        this.children = new DirtyNode[8];\n    }\n\n    /**\n     * Adds the specified node as a child to this node.\n     * @param n The node to add.\n     */\n    public void addChildNode(Node n) {\n        children[numOfChildren++] = (DirtyNode) n;\n    }\n\n    /**\n     * Sets the child of this node given by index to the\n     * specified Node.\n     *\n     * @param index The index of the child to change.\n     * @param n The node to set in the place of index.\n     */\n    public void setChildNode(int index, Node n) {\n        children[index] = (DirtyNode) n;\n    }\n\n    /**\n     * Returns the child at the specified location <code>index</code>.\n     * @return The child at the specified location <code>index</code>.\n     */\n    public Node getChildNode(int index) {\n        return children[index];\n    }\n\n    /**\n     * Returns the children of this <code>Node</code>. The order\n     * of the child nodes returned is unspecified.\n     *\n     * @return The children of this <code>Node</code>.\n     */\n    public Node[] getAllChildren() {\n        return children;\n    }\n\n    /**\n     * Sets the parent of this node to the specified node.\n     * @param parent The new parent node.\n     */\n    public void setParent(Node parent) {\n        this.parent = (DirtyNode) parent;\n    }\n\n    /**\n     * Returns this nodes parent.\n     * @return this nodes parent.\n     */\n    public Node getParent() {\n        return parent;\n    }\n\n    /**\n     * Sets the positional coordinates of this node to the\n     * specified values.\n     *\n     * @param x The horizontal component.\n     * @param y The vertical component.\n     */\n    public void setLocation(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public void setLocation(float x, float y, float z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n\n    /**\n     * Returns the horizontal position of this node.\n     * @return the horizontal position of this node.\n     */\n    public float getX() {\n        return x;\n    }\n\n    /**\n     * Returns the vertical position of this node.\n     * @return the vettical position of this node.\n     */\n    public float getY() {\n        return y;\n    }\n\n    /**\n     * Returns the z coordinate of this node.\n     * @return the z coordinate of this node.\n     */\n    public float getZ() {\n        return z;\n    }\n\n    public void setX(float x) {\n        this.x = x;\n    }\n\n    public void setY(float y) {\n        this.y = y;\n    }\n\n    public void setZ(float z) {\n        this.z = z;\n    }\n\n    /**\n     * Sets the cost associated with entering this node.\n     * @param cost the cost associated with entering this node.\n     */\n    public void setCost(float cost) {\n        this.cost = cost;\n    }\n\n    /**\n     * Returns the cost associated with entering this node.\n     * @return The cost associated with entering this node.\n     */\n    public float getCost() {\n        return cost;\n    }\n\n    /**\n     * Sets the total cost associated with this node. The\n     * total cost is the cost of travelling from the start\n     * node to this node.\n     *\n     * @param total The total cost to be associated with\n     *              this node.\n     */\n    public void setTotal(float total) {\n        this.total = total;\n    }\n\n    /**\n     * Returns the total cost associated with this node.\n     * @return The total cost associated with this node.\n     */\n    public float getTotal() {\n        return total;\n    }\n\n    /**\n     * Sets the score associated with this node. The score\n     * determines how good this node is in relation to other\n     * nodes and is used for ordering them amongst each other.\n     *\n     * @param score The score to be associated with this node.\n     */\n    public void setScore(float score) {\n        this.score = score;\n    }\n\n    /**\n     * Returns the score associated with this node.\n     * @return the score associated with this node.\n     */\n    public float getScore() {\n        return score;\n    }\n\n    /**\n     * Specifies whether this node has already been processed\n     * and no longer is considered for further processing.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node has been processed.\n     */\n    public void setClosed(boolean b) {\n        state = b ? state | CLOSED : state & ~CLOSED;\n    }\n\n    /**\n     * Returns true if this node has been processed.\n     * @return True if this node has been processed.\n     */\n    public boolean isClosed() {\n        return (state & CLOSED) > 0;\n    }\n\n    /**\n     * Specifies whether this node is currently being\n     * considered for further processing.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is currently open.\n     */\n    public void setOpen(boolean b) {\n        state = b ? state | OPEN : state & ~OPEN;\n    }\n\n    /**\n     * Returns true if this node is currently being\n     * considered for further processing.\n     *\n     * @return True if this node is open.\n     */\n    public boolean isOpen() {\n        return (state & OPEN) > 0;\n    }\n\n    /**\n     * Sets the data associated with this node. The handles\n     * the way the node is displayed.\n     *\n     * @param data The data to be associated with this node.\n     */\n    public void setData(long data) {\n        this.bits = data;\n    }\n\n    /**\n     * Retrieves the data associated with this node.\n     * @return the data associated with this node.\n     */\n    public long getData() {\n        return bits;\n    }\n\n    /**\n     * Specifies whether this node is solid (ie. the\n     * cost of entering the node is infinite.)\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is solid.\n     */\n    public void setSolid(boolean b) {\n        throw new RuntimeException(\"Method not implemented!\");\n    }\n\n    /**\n     * Returns whether this node is considered solid (ie. the\n     * cost of entering the node is infinite.)\n     *\n     * @return True if this node is solid.\n     */\n    public boolean isSolid() {\n        throw new RuntimeException(\"Method not implemented!\");\n    }\n\n    /**\n     * Specifies whether this node is currently visible.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is currently visible.\n     */\n    public void setVisible(boolean b) {\n        this.visibility = b ? 1.0f : 0.0f;\n    }\n\n    /**\n     * Returns whether this node is considered visible.\n     * @return True if this node is visible.\n     */\n    public boolean isVisible() {\n        return visibility > 0.0f;\n    }\n\n    /**\n     * Sets the degree of visibility of this node.\n     * @param value the degree of visibility.\n     */\n    public void setVisibility(float value) {\n        this.visibility = value;\n    }\n\n    /**\n     * Returns the current degree of visibility of this node.\n     * @return the current degree of visibility of this node.\n     */\n    public float getVisibility() {\n        return visibility;\n    }\n\n    /**\n     * Compares this Node with the specified Object for order.\n     * <b>Note</b>: This method imposes ordering which is\n     * inconsistant with equals.\n     *\n     * @param obj The object which is to be compared.\n     * @return An integer value of -1, 0, or 1, as this node\n     *         is less than, equal to, or greater than obj.\n     *\n     * @throws ClassCastException if obj is not of type Node.\n     */\n    public int compareTo(Object obj) {\n        return compareTo((DirtyNode) obj);\n    }\n\n    public int compareTo(DirtyNode n) {\n        return score < n.score ? -1 : (score > n.score ? 1 : 0);\n    }\n\n    /**\n     * Compares this node with the specified object for equality.\n     * Two nodes are considered equal if they have the same map\n     * coordinates.\n     *\n     * @param obj The node which is to be compared.\n     * @return True if obj is of type node and has the same map\n     *         coordinate as this node. Otherwise return false.\n     */\n    public boolean equals(Object obj) {\n        return equals((DirtyNode) obj);\n    }\n\n    public boolean equals(DirtyNode n) {\n        return x == n.x && y == n.y;\n    }\n\n    /**\n     * Returns a string representation of this <code>Node</code>.\n     * @return a string representation of this <code>Node</code>.\n     */\n    public String toString() {\n        return \"DirtyNode[x=\" + x + \",y=\" + y + \",score=\" + score + \"]\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/map/DirtyNodeTest5.java",
		"test_prompt": "// DirtyNodeTest5.java\npackage map;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DirtyNode}.\n* It contains ten unit test cases for the {@link DirtyNode#compareTo(DirtyNode)} method.\n*/\nclass DirtyNodeTest5 {"
	},
	{
		"original_code": "// DirtyNode.java\n/* DirtyNode.java v0.1 (06/16/2002)\n *\n * Copyright (C) 2002, Joel Andersson <bja@kth.se>\n * \n * This software is hereby expressly placed in the public domain.\n * Share and enjoy.\n */\npackage map;\n\npublic final class DirtyNode implements Node {\n\n    /**\n     * The parent of this node.\n     */\n    public DirtyNode parent;\n\n    /**\n     * The child nodes of this node.\n     */\n    public DirtyNode[] children;\n\n    /**\n     * The cost associated with this node.\n     */\n    public float cost;\n\n    /**\n     * The total cost associate with this node.\n     */\n    public float total;\n\n    /**\n     * The score associated with this node.\n     */\n    public float score;\n\n    /**\n     * The current state of this node.\n     */\n    public int state;\n\n    /**\n     * The bitmask associated with this node.\n     */\n    public long bits;\n\n    /**\n     * The horizontal component of this node.\n     */\n    public float x;\n\n    /**\n     * The vertical component of this node.\n     */\n    public float y;\n\n    /**\n     * The z coordinate of this node.\n     */\n    public float z;\n\n    /**\n     * Specifies whether this node is visible.\n     */\n    public float visibility;\n\n    /**\n     * The number of children of this node.\n     */\n    private int numOfChildren;\n\n    /**\n     * Creates a new DirtyNode with the specified tile.\n     * @param tile The tile to be associated with the node.\n     */\n    public DirtyNode(long bits) {\n        this(bits, 0, 0);\n    }\n\n    /**\n     * Creates a new DirtyNode with the specified attributes.\n     * @param tile The tile to be associated with the node.\n     * @param bits The bits to be associated with the node.\n     * @param x The horizontal component of this node.\n     * @param y The vertical component of this node.\n     */\n    public DirtyNode(long bits, int x, int y) {\n        this.bits = bits;\n        this.x = x;\n        this.y = y;\n        this.numOfChildren = 0;\n        this.children = new DirtyNode[8];\n    }\n\n    /**\n     * Adds the specified node as a child to this node.\n     * @param n The node to add.\n     */\n    public void addChildNode(Node n) {\n        children[numOfChildren++] = (DirtyNode) n;\n    }\n\n    /**\n     * Sets the child of this node given by index to the\n     * specified Node.\n     *\n     * @param index The index of the child to change.\n     * @param n The node to set in the place of index.\n     */\n    public void setChildNode(int index, Node n) {\n        children[index] = (DirtyNode) n;\n    }\n\n    /**\n     * Returns the child at the specified location <code>index</code>.\n     * @return The child at the specified location <code>index</code>.\n     */\n    public Node getChildNode(int index) {\n        return children[index];\n    }\n\n    /**\n     * Returns the children of this <code>Node</code>. The order\n     * of the child nodes returned is unspecified.\n     *\n     * @return The children of this <code>Node</code>.\n     */\n    public Node[] getAllChildren() {\n        return children;\n    }\n\n    /**\n     * Sets the parent of this node to the specified node.\n     * @param parent The new parent node.\n     */\n    public void setParent(Node parent) {\n        this.parent = (DirtyNode) parent;\n    }\n\n    /**\n     * Returns this nodes parent.\n     * @return this nodes parent.\n     */\n    public Node getParent() {\n        return parent;\n    }\n\n    /**\n     * Sets the positional coordinates of this node to the\n     * specified values.\n     *\n     * @param x The horizontal component.\n     * @param y The vertical component.\n     */\n    public void setLocation(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public void setLocation(float x, float y, float z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n\n    /**\n     * Returns the horizontal position of this node.\n     * @return the horizontal position of this node.\n     */\n    public float getX() {\n        return x;\n    }\n\n    /**\n     * Returns the vertical position of this node.\n     * @return the vettical position of this node.\n     */\n    public float getY() {\n        return y;\n    }\n\n    /**\n     * Returns the z coordinate of this node.\n     * @return the z coordinate of this node.\n     */\n    public float getZ() {\n        return z;\n    }\n\n    public void setX(float x) {\n        this.x = x;\n    }\n\n    public void setY(float y) {\n        this.y = y;\n    }\n\n    public void setZ(float z) {\n        this.z = z;\n    }\n\n    /**\n     * Sets the cost associated with entering this node.\n     * @param cost the cost associated with entering this node.\n     */\n    public void setCost(float cost) {\n        this.cost = cost;\n    }\n\n    /**\n     * Returns the cost associated with entering this node.\n     * @return The cost associated with entering this node.\n     */\n    public float getCost() {\n        return cost;\n    }\n\n    /**\n     * Sets the total cost associated with this node. The\n     * total cost is the cost of travelling from the start\n     * node to this node.\n     *\n     * @param total The total cost to be associated with\n     *              this node.\n     */\n    public void setTotal(float total) {\n        this.total = total;\n    }\n\n    /**\n     * Returns the total cost associated with this node.\n     * @return The total cost associated with this node.\n     */\n    public float getTotal() {\n        return total;\n    }\n\n    /**\n     * Sets the score associated with this node. The score\n     * determines how good this node is in relation to other\n     * nodes and is used for ordering them amongst each other.\n     *\n     * @param score The score to be associated with this node.\n     */\n    public void setScore(float score) {\n        this.score = score;\n    }\n\n    /**\n     * Returns the score associated with this node.\n     * @return the score associated with this node.\n     */\n    public float getScore() {\n        return score;\n    }\n\n    /**\n     * Specifies whether this node has already been processed\n     * and no longer is considered for further processing.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node has been processed.\n     */\n    public void setClosed(boolean b) {\n        state = b ? state | CLOSED : state & ~CLOSED;\n    }\n\n    /**\n     * Returns true if this node has been processed.\n     * @return True if this node has been processed.\n     */\n    public boolean isClosed() {\n        return (state & CLOSED) > 0;\n    }\n\n    /**\n     * Specifies whether this node is currently being\n     * considered for further processing.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is currently open.\n     */\n    public void setOpen(boolean b) {\n        state = b ? state | OPEN : state & ~OPEN;\n    }\n\n    /**\n     * Returns true if this node is currently being\n     * considered for further processing.\n     *\n     * @return True if this node is open.\n     */\n    public boolean isOpen() {\n        return (state & OPEN) > 0;\n    }\n\n    /**\n     * Sets the data associated with this node. The handles\n     * the way the node is displayed.\n     *\n     * @param data The data to be associated with this node.\n     */\n    public void setData(long data) {\n        this.bits = data;\n    }\n\n    /**\n     * Retrieves the data associated with this node.\n     * @return the data associated with this node.\n     */\n    public long getData() {\n        return bits;\n    }\n\n    /**\n     * Specifies whether this node is solid (ie. the\n     * cost of entering the node is infinite.)\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is solid.\n     */\n    public void setSolid(boolean b) {\n        throw new RuntimeException(\"Method not implemented!\");\n    }\n\n    /**\n     * Returns whether this node is considered solid (ie. the\n     * cost of entering the node is infinite.)\n     *\n     * @return True if this node is solid.\n     */\n    public boolean isSolid() {\n        throw new RuntimeException(\"Method not implemented!\");\n    }\n\n    /**\n     * Specifies whether this node is currently visible.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is currently visible.\n     */\n    public void setVisible(boolean b) {\n        this.visibility = b ? 1.0f : 0.0f;\n    }\n\n    /**\n     * Returns whether this node is considered visible.\n     * @return True if this node is visible.\n     */\n    public boolean isVisible() {\n        return visibility > 0.0f;\n    }\n\n    /**\n     * Sets the degree of visibility of this node.\n     * @param value the degree of visibility.\n     */\n    public void setVisibility(float value) {\n        this.visibility = value;\n    }\n\n    /**\n     * Returns the current degree of visibility of this node.\n     * @return the current degree of visibility of this node.\n     */\n    public float getVisibility() {\n        return visibility;\n    }\n\n    /**\n     * Compares this Node with the specified Object for order.\n     * <b>Note</b>: This method imposes ordering which is\n     * inconsistant with equals.\n     *\n     * @param obj The object which is to be compared.\n     * @return An integer value of -1, 0, or 1, as this node\n     *         is less than, equal to, or greater than obj.\n     *\n     * @throws ClassCastException if obj is not of type Node.\n     */\n    public int compareTo(Object obj) {\n        return compareTo((DirtyNode) obj);\n    }\n\n    public int compareTo(DirtyNode n) {\n        return score < n.score ? -1 : (score > n.score ? 1 : 0);\n    }\n\n    /**\n     * Compares this node with the specified object for equality.\n     * Two nodes are considered equal if they have the same map\n     * coordinates.\n     *\n     * @param obj The node which is to be compared.\n     * @return True if obj is of type node and has the same map\n     *         coordinate as this node. Otherwise return false.\n     */\n    public boolean equals(Object obj) {\n        return equals((DirtyNode) obj);\n    }\n\n    public boolean equals(DirtyNode n) {\n        return x == n.x && y == n.y;\n    }\n\n    /**\n     * Returns a string representation of this <code>Node</code>.\n     * @return a string representation of this <code>Node</code>.\n     */\n    public String toString() {\n        return \"DirtyNode[x=\" + x + \",y=\" + y + \",score=\" + score + \"]\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/map/DirtyNodeTest6.java",
		"test_prompt": "// DirtyNodeTest6.java\npackage map;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DirtyNode}.\n* It contains ten unit test cases for the {@link DirtyNode#equals(Object)} method.\n*/\nclass DirtyNodeTest6 {"
	},
	{
		"original_code": "// DirtyNode.java\n/* DirtyNode.java v0.1 (06/16/2002)\n *\n * Copyright (C) 2002, Joel Andersson <bja@kth.se>\n * \n * This software is hereby expressly placed in the public domain.\n * Share and enjoy.\n */\npackage map;\n\npublic final class DirtyNode implements Node {\n\n    /**\n     * The parent of this node.\n     */\n    public DirtyNode parent;\n\n    /**\n     * The child nodes of this node.\n     */\n    public DirtyNode[] children;\n\n    /**\n     * The cost associated with this node.\n     */\n    public float cost;\n\n    /**\n     * The total cost associate with this node.\n     */\n    public float total;\n\n    /**\n     * The score associated with this node.\n     */\n    public float score;\n\n    /**\n     * The current state of this node.\n     */\n    public int state;\n\n    /**\n     * The bitmask associated with this node.\n     */\n    public long bits;\n\n    /**\n     * The horizontal component of this node.\n     */\n    public float x;\n\n    /**\n     * The vertical component of this node.\n     */\n    public float y;\n\n    /**\n     * The z coordinate of this node.\n     */\n    public float z;\n\n    /**\n     * Specifies whether this node is visible.\n     */\n    public float visibility;\n\n    /**\n     * The number of children of this node.\n     */\n    private int numOfChildren;\n\n    /**\n     * Creates a new DirtyNode with the specified tile.\n     * @param tile The tile to be associated with the node.\n     */\n    public DirtyNode(long bits) {\n        this(bits, 0, 0);\n    }\n\n    /**\n     * Creates a new DirtyNode with the specified attributes.\n     * @param tile The tile to be associated with the node.\n     * @param bits The bits to be associated with the node.\n     * @param x The horizontal component of this node.\n     * @param y The vertical component of this node.\n     */\n    public DirtyNode(long bits, int x, int y) {\n        this.bits = bits;\n        this.x = x;\n        this.y = y;\n        this.numOfChildren = 0;\n        this.children = new DirtyNode[8];\n    }\n\n    /**\n     * Adds the specified node as a child to this node.\n     * @param n The node to add.\n     */\n    public void addChildNode(Node n) {\n        children[numOfChildren++] = (DirtyNode) n;\n    }\n\n    /**\n     * Sets the child of this node given by index to the\n     * specified Node.\n     *\n     * @param index The index of the child to change.\n     * @param n The node to set in the place of index.\n     */\n    public void setChildNode(int index, Node n) {\n        children[index] = (DirtyNode) n;\n    }\n\n    /**\n     * Returns the child at the specified location <code>index</code>.\n     * @return The child at the specified location <code>index</code>.\n     */\n    public Node getChildNode(int index) {\n        return children[index];\n    }\n\n    /**\n     * Returns the children of this <code>Node</code>. The order\n     * of the child nodes returned is unspecified.\n     *\n     * @return The children of this <code>Node</code>.\n     */\n    public Node[] getAllChildren() {\n        return children;\n    }\n\n    /**\n     * Sets the parent of this node to the specified node.\n     * @param parent The new parent node.\n     */\n    public void setParent(Node parent) {\n        this.parent = (DirtyNode) parent;\n    }\n\n    /**\n     * Returns this nodes parent.\n     * @return this nodes parent.\n     */\n    public Node getParent() {\n        return parent;\n    }\n\n    /**\n     * Sets the positional coordinates of this node to the\n     * specified values.\n     *\n     * @param x The horizontal component.\n     * @param y The vertical component.\n     */\n    public void setLocation(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public void setLocation(float x, float y, float z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n\n    /**\n     * Returns the horizontal position of this node.\n     * @return the horizontal position of this node.\n     */\n    public float getX() {\n        return x;\n    }\n\n    /**\n     * Returns the vertical position of this node.\n     * @return the vettical position of this node.\n     */\n    public float getY() {\n        return y;\n    }\n\n    /**\n     * Returns the z coordinate of this node.\n     * @return the z coordinate of this node.\n     */\n    public float getZ() {\n        return z;\n    }\n\n    public void setX(float x) {\n        this.x = x;\n    }\n\n    public void setY(float y) {\n        this.y = y;\n    }\n\n    public void setZ(float z) {\n        this.z = z;\n    }\n\n    /**\n     * Sets the cost associated with entering this node.\n     * @param cost the cost associated with entering this node.\n     */\n    public void setCost(float cost) {\n        this.cost = cost;\n    }\n\n    /**\n     * Returns the cost associated with entering this node.\n     * @return The cost associated with entering this node.\n     */\n    public float getCost() {\n        return cost;\n    }\n\n    /**\n     * Sets the total cost associated with this node. The\n     * total cost is the cost of travelling from the start\n     * node to this node.\n     *\n     * @param total The total cost to be associated with\n     *              this node.\n     */\n    public void setTotal(float total) {\n        this.total = total;\n    }\n\n    /**\n     * Returns the total cost associated with this node.\n     * @return The total cost associated with this node.\n     */\n    public float getTotal() {\n        return total;\n    }\n\n    /**\n     * Sets the score associated with this node. The score\n     * determines how good this node is in relation to other\n     * nodes and is used for ordering them amongst each other.\n     *\n     * @param score The score to be associated with this node.\n     */\n    public void setScore(float score) {\n        this.score = score;\n    }\n\n    /**\n     * Returns the score associated with this node.\n     * @return the score associated with this node.\n     */\n    public float getScore() {\n        return score;\n    }\n\n    /**\n     * Specifies whether this node has already been processed\n     * and no longer is considered for further processing.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node has been processed.\n     */\n    public void setClosed(boolean b) {\n        state = b ? state | CLOSED : state & ~CLOSED;\n    }\n\n    /**\n     * Returns true if this node has been processed.\n     * @return True if this node has been processed.\n     */\n    public boolean isClosed() {\n        return (state & CLOSED) > 0;\n    }\n\n    /**\n     * Specifies whether this node is currently being\n     * considered for further processing.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is currently open.\n     */\n    public void setOpen(boolean b) {\n        state = b ? state | OPEN : state & ~OPEN;\n    }\n\n    /**\n     * Returns true if this node is currently being\n     * considered for further processing.\n     *\n     * @return True if this node is open.\n     */\n    public boolean isOpen() {\n        return (state & OPEN) > 0;\n    }\n\n    /**\n     * Sets the data associated with this node. The handles\n     * the way the node is displayed.\n     *\n     * @param data The data to be associated with this node.\n     */\n    public void setData(long data) {\n        this.bits = data;\n    }\n\n    /**\n     * Retrieves the data associated with this node.\n     * @return the data associated with this node.\n     */\n    public long getData() {\n        return bits;\n    }\n\n    /**\n     * Specifies whether this node is solid (ie. the\n     * cost of entering the node is infinite.)\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is solid.\n     */\n    public void setSolid(boolean b) {\n        throw new RuntimeException(\"Method not implemented!\");\n    }\n\n    /**\n     * Returns whether this node is considered solid (ie. the\n     * cost of entering the node is infinite.)\n     *\n     * @return True if this node is solid.\n     */\n    public boolean isSolid() {\n        throw new RuntimeException(\"Method not implemented!\");\n    }\n\n    /**\n     * Specifies whether this node is currently visible.\n     *\n     * @param b A boolean value that specifies whether\n     *          this node is currently visible.\n     */\n    public void setVisible(boolean b) {\n        this.visibility = b ? 1.0f : 0.0f;\n    }\n\n    /**\n     * Returns whether this node is considered visible.\n     * @return True if this node is visible.\n     */\n    public boolean isVisible() {\n        return visibility > 0.0f;\n    }\n\n    /**\n     * Sets the degree of visibility of this node.\n     * @param value the degree of visibility.\n     */\n    public void setVisibility(float value) {\n        this.visibility = value;\n    }\n\n    /**\n     * Returns the current degree of visibility of this node.\n     * @return the current degree of visibility of this node.\n     */\n    public float getVisibility() {\n        return visibility;\n    }\n\n    /**\n     * Compares this Node with the specified Object for order.\n     * <b>Note</b>: This method imposes ordering which is\n     * inconsistant with equals.\n     *\n     * @param obj The object which is to be compared.\n     * @return An integer value of -1, 0, or 1, as this node\n     *         is less than, equal to, or greater than obj.\n     *\n     * @throws ClassCastException if obj is not of type Node.\n     */\n    public int compareTo(Object obj) {\n        return compareTo((DirtyNode) obj);\n    }\n\n    public int compareTo(DirtyNode n) {\n        return score < n.score ? -1 : (score > n.score ? 1 : 0);\n    }\n\n    /**\n     * Compares this node with the specified object for equality.\n     * Two nodes are considered equal if they have the same map\n     * coordinates.\n     *\n     * @param obj The node which is to be compared.\n     * @return True if obj is of type node and has the same map\n     *         coordinate as this node. Otherwise return false.\n     */\n    public boolean equals(Object obj) {\n        return equals((DirtyNode) obj);\n    }\n\n    public boolean equals(DirtyNode n) {\n        return x == n.x && y == n.y;\n    }\n\n    /**\n     * Returns a string representation of this <code>Node</code>.\n     * @return a string representation of this <code>Node</code>.\n     */\n    public String toString() {\n        return \"DirtyNode[x=\" + x + \",y=\" + y + \",score=\" + score + \"]\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/map/DirtyNodeTest7.java",
		"test_prompt": "// DirtyNodeTest7.java\npackage map;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DirtyNode}.\n* It contains ten unit test cases for the {@link DirtyNode#equals(DirtyNode)} method.\n*/\nclass DirtyNodeTest7 {"
	},
	{
		"original_code": "// AbstractMap.java\n/* AbstractMap.java v0.1 (06/17/2002)\n *\n * Copyright (C) 2002, Joel Andersson <bja@kth.se>\n * \n * This software is hereby expressly placed in the public domain.\n * Share and enjoy.\n */\npackage map;\n\nimport java.util.Vector;\nimport java.util.PriorityQueue;\n\n//import bja.util.PriorityQueue;\npublic abstract class AbstractMap implements Map {\n\n    /**\n     * The square root of 2.0f.\n     */\n    protected static final float MATH_SQRT_2 = 1.41421356f;\n\n    /**\n     * The minimum cost associated with accessing a node in this map.\n     */\n    protected static float minCost;\n\n    /**\n     * The maximum cost associated with accessing a node in this map.\n     */\n    protected static float maxCost;\n\n    /**\n     * Creates a new instance of this class.\n     */\n    protected AbstractMap() {\n        minCost = 0.1f;\n        maxCost = 1.0f;\n    }\n\n    /**\n     * Creates a new instance of this class with the specified\n     * attributes.\n     *\n     * @param min the minimum cost of accessing a node.\n     * @param max the maximum cost of accessing a node.\n     */\n    protected AbstractMap(float min, float max) {\n        minCost = min;\n        maxCost = max;\n    }\n\n    /**\n     * Search for the shortest path connecting the source node with\n     * the target node. This algorithm is guaranteed to find the\n     * optimal shortest path, if it exist, provided that the heuristic\n     * function is admissible.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path aStarSearch(Node source, Node target) throws PathNotFoundException {\n        PriorityQueue open = new PriorityQueue();\n        reset();\n        source.setTotal(0.0f);\n        source.setScore(minCost * heuristic(source, target));\n        open.add(source);\n        while (open.size() != 0) {\n            Node current = (Node) open.poll();\n            current.setOpen(false);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // calculate the accumulated total cost of moving\n                // from the source to this child.\n                float total = current.getTotal() + cost(current, child[i]);\n                // skip nodes that are currently being processed and\n                // which have a lower total cost from the source.\n                if (child[i].isOpen() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // skip nodes that have already been processed and\n                // which have a lower total cost from the source.\n                if (child[i].isClosed() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // a new shorter path to this child was found. update\n                // the node and add it to the list of open nodes if\n                // it isn't already open.\n                float score = total + minCost * heuristic(child[i], target);\n                child[i].setParent(current);\n                child[i].setTotal(total);\n                child[i].setScore(score);\n                if (child[i].isClosed()) {\n                    child[i].setClosed(false);\n                }\n                if (!child[i].isOpen()) {\n                    open.add(child[i]);\n                    child[i].setOpen(true);\n                }\n            }\n            current.setClosed(true);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * Search for the shortest path connecting the source node with\n     * the target node. This algorithm is guaranteed to find the\n     * optimal shortest path, if it exist, provided that the heuristic\n     * function is admissible.\n     *\n     * This is a slightly faster implementation of the A* algorithm than\n     * the above using a sorted array to store the open nodes instead of\n     * a PriorityQueue.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path aStarSearch2(Node source, Node target) throws PathNotFoundException {\n        int n = 0;\n        Node[] open = new Node[16];\n        reset();\n        source.setTotal(0.0f);\n        source.setScore(minCost * heuristic(source, target));\n        open[n++] = source;\n        while (n > 0) {\n            Node current = open[--n];\n            current.setOpen(false);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // calculate the accumulated total cost of moving\n                // from source to this child.\n                float total = current.getTotal() + cost(current, child[i]);\n                // skip nodes that are currently being processed and\n                // which have a lower total cost from source.\n                if (child[i].isOpen() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // skip nodes that have already been processed and\n                // which have a lower total cost from source.\n                if (child[i].isClosed() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // a new shorter path to this child was found. update\n                // the node and add it to the list of open nodes if\n                // it isn't already open.\n                float score = total + minCost * heuristic(child[i], target);\n                child[i].setParent(current);\n                child[i].setTotal(total);\n                child[i].setScore(score);\n                if (child[i].isClosed()) {\n                    child[i].setClosed(false);\n                }\n                if (!child[i].isOpen()) {\n                    int l = 0;\n                    int r = n - 1;\n                    int m = 0;\n                    int t = 0;\n                    // search for place to insert new node.\n                    while (l <= r) {\n                        m = (l + r) / 2;\n                        t = -child[i].compareTo(open[m]);\n                        if (t < 0) {\n                            r = m - 1;\n                        } else if (t > 0) {\n                            l = m + 1;\n                        } else {\n                            break;\n                        }\n                    }\n                    m = m < 0 ? 0 : m;\n                    // if the buffer is full allocate space for some\n                    // more nodes. make it twice as large as it was.\n                    if (n > open.length - 2) {\n                        Node[] temp = open;\n                        open = new Node[temp.length << 1];\n                        System.arraycopy(temp, 0, open, 0, temp.length);\n                    }\n                    System.arraycopy(open, m, open, m + 1, n - m);\n                    child[i].setOpen(true);\n                    open[m] = child[i];\n                    n = n + 1;\n                }\n            }\n            current.setClosed(true);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * Search for the shortest path connecting the source node with\n     * the target node. This algorithm is guaranteed to find the\n     * optimal shortest path, if it exist, provided that the heuristic\n     * function is admissible.\n     *\n     * This is a slightly faster implementation of the A* algorithm than\n     * the above using a sorted array to store the open nodes instead of\n     * a PriorityQueue and using DirtyNodes instead of the DefaultNodes.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public Path aStarSearch3(DirtyNode source, DirtyNode target) throws PathNotFoundException {\n        DirtyNode[] open = new DirtyNode[32];\n        int n = 0;\n        reset();\n        //float dx = Math.abs(target.x - source.x);\n        //float dy = Math.abs(target.y - source.y);\n        //float h  = Math.min(dx, dy) + MATH_SQRT_2 * Math.abs(dx - dy);\n        float dx = target.x - source.x;\n        float dy = target.y - source.y;\n        float h = (float) Math.sqrt(dx * dx + dy * dy);\n        source.total = 0.0f;\n        source.score = minCost * h;\n        //source.score = minCost * heuristic(source, target);\n        open[n++] = source;\n        while (n > 0) {\n            DirtyNode current = open[--n];\n            current.state ^= Node.OPEN;\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            DirtyNode[] child = current.children;\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].cost >= maxCost) {\n                    continue;\n                }\n                // calculate the accumulated total cost of moving\n                // from source to this child.\n                float weight = (i % 2 == 0) ? 1 : MATH_SQRT_2;\n                float total = current.total + weight * child[i].cost;\n                //float total = current.total + cost(current, child[i]);\n                // skip nodes that are currently being processed and\n                // which have a lower total cost from source.\n                if ((child[i].state & Node.OPEN) > 0 && child[i].total <= total) {\n                    continue;\n                }\n                // skip nodes that have already been processed and\n                // which have a lower total cost from source.\n                if ((child[i].state & Node.CLOSED) > 0 && child[i].total <= total) {\n                    continue;\n                }\n                // a new shorter path to this child was found. update\n                // the node and add it to the list of open nodes if\n                // it isn't already open.\n                //dx = Math.abs(child[i].x - source.x);\n                //dy = Math.abs(child[i].y - source.y);\n                //h  = Math.min(dx, dy) + MATH_SQRT_2 * Math.abs(dx - dy);\n                dx = child[i].x - target.x;\n                dy = child[i].y - target.y;\n                h = (float) Math.sqrt(dx * dx + dy * dy);\n                float score = total + minCost * h;\n                //float score = total + minCost * heuristic(current, child[i]);\n                child[i].parent = current;\n                child[i].total = total;\n                child[i].score = score;\n                if ((child[i].state & Node.CLOSED) > 0) {\n                    child[i].state ^= Node.CLOSED;\n                }\n                if ((child[i].state & Node.OPEN) == 0) {\n                    int l = 0;\n                    int r = n - 1;\n                    int m = 0;\n                    int t = 0;\n                    // search the open array for a place to insert new\n                    // node. the array is ordered in reverse natural order.\n                    while (l <= r) {\n                        m = (l + r) / 2;\n                        t = child[i].score < open[m].score ? 1 : (child[i].score > open[m].score ? -1 : 0);\n                        if (t < 0) {\n                            r = m - 1;\n                        } else if (t > 0) {\n                            l = m + 1;\n                        } else {\n                            break;\n                        }\n                    }\n                    m = m < 0 ? 0 : m;\n                    // if the buffer is full allocate space for some\n                    // more nodes. make it twice as large as it was.\n                    if (n > open.length - 2) {\n                        DirtyNode[] temp = open;\n                        open = new DirtyNode[temp.length << 1];\n                        System.arraycopy(temp, 0, open, 0, temp.length);\n                    }\n                    System.arraycopy(open, m, open, m + 1, n - m);\n                    child[i].state ^= Node.OPEN;\n                    open[m] = child[i];\n                    n = n + 1;\n                }\n            }\n            current.state ^= Node.CLOSED;\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", t=\" + target);\n    }\n\n    /**\n     * Search for the path connecting the source node with the target node.\n     * This algorithm does not take into account the cost of accessing each\n     * node, only the estimated remaining distance to target is considered.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path bestFirstSearch(Node source, Node target) throws PathNotFoundException {\n        Vector open = new Vector();\n        reset();\n        source.setScore(0.0f);\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(0);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // skip nodes that are currently being processed and\n                // which have a lower total cost from source.\n                if (child[i].isOpen() || child[i].isClosed()) {\n                    continue;\n                }\n                // estimate the remaining distance to target.\n                float score = minCost * heuristic(child[i], target);\n                child[i].setParent(current);\n                child[i].setScore(score);\n                int j = java.util.Collections.binarySearch(open, child[i]);\n                if (j < 0) {\n                    j = -j > open.size() ? open.size() : -j;\n                    open.insertElementAt(child[i], j);\n                    child[i].setOpen(true);\n                    child[i].setClosed(false);\n                }\n            }\n            current.setClosed(true);\n            current.setOpen(false);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * Search for the shortest path connecting the source node with\n     * the target node. This algorithm is guaranteed to find the\n     * optimal shortest path, if it exist.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path dijkstraSearch(Node source, Node target) throws PathNotFoundException {\n        Vector open = new Vector();\n        reset();\n        source.setTotal(0.0f);\n        source.setScore(0.0f);\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(0);\n            current.setOpen(false);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // calculate the accumulated total cost of moving\n                // from source to this child.\n                float total = current.getTotal() + cost(current, child[i]);\n                // skip nodes that are currently being processed and\n                // which have a lower total cost from source.\n                if (child[i].isOpen() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // skip nodes that have already been processed and\n                // which have a lower total cost from source.\n                if (child[i].isClosed() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // a new shorter path to this child was found. update\n                // the node and add it to the list of open nodes if\n                // it isn't already open.\n                child[i].setParent(current);\n                child[i].setTotal(total);\n                child[i].setScore(total);\n                if (child[i].isClosed()) {\n                    child[i].setClosed(false);\n                }\n                if (!child[i].isOpen()) {\n                    open.add(child[i]);\n                    child[i].setOpen(true);\n                }\n            }\n            current.setClosed(true);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * Search for the path connecting the source node with the target node.\n     * This algorithm does not take into account the cost of accessing each\n     * node.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path breadthFirstSearch(Node source, Node target) throws PathNotFoundException {\n        Vector open = new Vector();\n        reset();\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(0);\n            current.setOpen(false);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // skip nodes that are currently being processed and\n                // nodes that have already been processed.\n                if (child[i].isOpen() || child[i].isClosed()) {\n                    continue;\n                }\n                child[i].setParent(current);\n                if (!child[i].isOpen()) {\n                    child[i].setOpen(true);\n                    open.add(child[i]);\n                }\n            }\n            current.setClosed(true);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * Search for the path connecting the source node with the target node.\n     * This algorithm does not take into account the cost of accessing each\n     * node.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path depthFirstSearch(Node source, Node target) throws PathNotFoundException {\n        Vector open = new Vector();\n        reset();\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(open.size() - 1);\n            current.setOpen(false);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // skip nodes that are currently being processed and\n                // nodes that have already been processed.\n                if (child[i].isOpen() || child[i].isClosed()) {\n                    continue;\n                }\n                child[i].setParent(current);\n                if (!child[i].isOpen()) {\n                    open.add(child[i]);\n                    child[i].setOpen(true);\n                }\n            }\n            current.setClosed(true);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * The associated heuristic function for this map. Estimates\n     * the remaining distance from node a to node b.\n     *\n     * @param a The first node.\n     * @param b The second node.\n     */\n    protected abstract float heuristic(Node a, Node b);\n\n    /**\n     * Determines the actual cost of crossing the edge between\n     * the given adjectant nodes. If the nodes are not adjectant\n     * the returned cost is unspecified.\n     *\n     * @param source The source node.\n     * @param target The target node.\n     */\n    protected abstract float cost(Node source, Node target);\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/map/AbstractMapTest0.java",
		"test_prompt": "// AbstractMapTest0.java\npackage map;\n\nimport java.util.Vector;\nimport java.util.PriorityQueue;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractMap}.\n* It contains ten unit test cases for the {@link AbstractMap#aStarSearch(Node, Node)} method.\n*/\nclass AbstractMapTest0 {"
	},
	{
		"original_code": "// AbstractMap.java\n/* AbstractMap.java v0.1 (06/17/2002)\n *\n * Copyright (C) 2002, Joel Andersson <bja@kth.se>\n * \n * This software is hereby expressly placed in the public domain.\n * Share and enjoy.\n */\npackage map;\n\nimport java.util.Vector;\nimport java.util.PriorityQueue;\n\n//import bja.util.PriorityQueue;\npublic abstract class AbstractMap implements Map {\n\n    /**\n     * The square root of 2.0f.\n     */\n    protected static final float MATH_SQRT_2 = 1.41421356f;\n\n    /**\n     * The minimum cost associated with accessing a node in this map.\n     */\n    protected static float minCost;\n\n    /**\n     * The maximum cost associated with accessing a node in this map.\n     */\n    protected static float maxCost;\n\n    /**\n     * Creates a new instance of this class.\n     */\n    protected AbstractMap() {\n        minCost = 0.1f;\n        maxCost = 1.0f;\n    }\n\n    /**\n     * Creates a new instance of this class with the specified\n     * attributes.\n     *\n     * @param min the minimum cost of accessing a node.\n     * @param max the maximum cost of accessing a node.\n     */\n    protected AbstractMap(float min, float max) {\n        minCost = min;\n        maxCost = max;\n    }\n\n    /**\n     * Search for the shortest path connecting the source node with\n     * the target node. This algorithm is guaranteed to find the\n     * optimal shortest path, if it exist, provided that the heuristic\n     * function is admissible.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path aStarSearch(Node source, Node target) throws PathNotFoundException {\n        PriorityQueue open = new PriorityQueue();\n        reset();\n        source.setTotal(0.0f);\n        source.setScore(minCost * heuristic(source, target));\n        open.add(source);\n        while (open.size() != 0) {\n            Node current = (Node) open.poll();\n            current.setOpen(false);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // calculate the accumulated total cost of moving\n                // from the source to this child.\n                float total = current.getTotal() + cost(current, child[i]);\n                // skip nodes that are currently being processed and\n                // which have a lower total cost from the source.\n                if (child[i].isOpen() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // skip nodes that have already been processed and\n                // which have a lower total cost from the source.\n                if (child[i].isClosed() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // a new shorter path to this child was found. update\n                // the node and add it to the list of open nodes if\n                // it isn't already open.\n                float score = total + minCost * heuristic(child[i], target);\n                child[i].setParent(current);\n                child[i].setTotal(total);\n                child[i].setScore(score);\n                if (child[i].isClosed()) {\n                    child[i].setClosed(false);\n                }\n                if (!child[i].isOpen()) {\n                    open.add(child[i]);\n                    child[i].setOpen(true);\n                }\n            }\n            current.setClosed(true);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * Search for the shortest path connecting the source node with\n     * the target node. This algorithm is guaranteed to find the\n     * optimal shortest path, if it exist, provided that the heuristic\n     * function is admissible.\n     *\n     * This is a slightly faster implementation of the A* algorithm than\n     * the above using a sorted array to store the open nodes instead of\n     * a PriorityQueue.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path aStarSearch2(Node source, Node target) throws PathNotFoundException {\n        int n = 0;\n        Node[] open = new Node[16];\n        reset();\n        source.setTotal(0.0f);\n        source.setScore(minCost * heuristic(source, target));\n        open[n++] = source;\n        while (n > 0) {\n            Node current = open[--n];\n            current.setOpen(false);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // calculate the accumulated total cost of moving\n                // from source to this child.\n                float total = current.getTotal() + cost(current, child[i]);\n                // skip nodes that are currently being processed and\n                // which have a lower total cost from source.\n                if (child[i].isOpen() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // skip nodes that have already been processed and\n                // which have a lower total cost from source.\n                if (child[i].isClosed() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // a new shorter path to this child was found. update\n                // the node and add it to the list of open nodes if\n                // it isn't already open.\n                float score = total + minCost * heuristic(child[i], target);\n                child[i].setParent(current);\n                child[i].setTotal(total);\n                child[i].setScore(score);\n                if (child[i].isClosed()) {\n                    child[i].setClosed(false);\n                }\n                if (!child[i].isOpen()) {\n                    int l = 0;\n                    int r = n - 1;\n                    int m = 0;\n                    int t = 0;\n                    // search for place to insert new node.\n                    while (l <= r) {\n                        m = (l + r) / 2;\n                        t = -child[i].compareTo(open[m]);\n                        if (t < 0) {\n                            r = m - 1;\n                        } else if (t > 0) {\n                            l = m + 1;\n                        } else {\n                            break;\n                        }\n                    }\n                    m = m < 0 ? 0 : m;\n                    // if the buffer is full allocate space for some\n                    // more nodes. make it twice as large as it was.\n                    if (n > open.length - 2) {\n                        Node[] temp = open;\n                        open = new Node[temp.length << 1];\n                        System.arraycopy(temp, 0, open, 0, temp.length);\n                    }\n                    System.arraycopy(open, m, open, m + 1, n - m);\n                    child[i].setOpen(true);\n                    open[m] = child[i];\n                    n = n + 1;\n                }\n            }\n            current.setClosed(true);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * Search for the shortest path connecting the source node with\n     * the target node. This algorithm is guaranteed to find the\n     * optimal shortest path, if it exist, provided that the heuristic\n     * function is admissible.\n     *\n     * This is a slightly faster implementation of the A* algorithm than\n     * the above using a sorted array to store the open nodes instead of\n     * a PriorityQueue and using DirtyNodes instead of the DefaultNodes.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public Path aStarSearch3(DirtyNode source, DirtyNode target) throws PathNotFoundException {\n        DirtyNode[] open = new DirtyNode[32];\n        int n = 0;\n        reset();\n        //float dx = Math.abs(target.x - source.x);\n        //float dy = Math.abs(target.y - source.y);\n        //float h  = Math.min(dx, dy) + MATH_SQRT_2 * Math.abs(dx - dy);\n        float dx = target.x - source.x;\n        float dy = target.y - source.y;\n        float h = (float) Math.sqrt(dx * dx + dy * dy);\n        source.total = 0.0f;\n        source.score = minCost * h;\n        //source.score = minCost * heuristic(source, target);\n        open[n++] = source;\n        while (n > 0) {\n            DirtyNode current = open[--n];\n            current.state ^= Node.OPEN;\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            DirtyNode[] child = current.children;\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].cost >= maxCost) {\n                    continue;\n                }\n                // calculate the accumulated total cost of moving\n                // from source to this child.\n                float weight = (i % 2 == 0) ? 1 : MATH_SQRT_2;\n                float total = current.total + weight * child[i].cost;\n                //float total = current.total + cost(current, child[i]);\n                // skip nodes that are currently being processed and\n                // which have a lower total cost from source.\n                if ((child[i].state & Node.OPEN) > 0 && child[i].total <= total) {\n                    continue;\n                }\n                // skip nodes that have already been processed and\n                // which have a lower total cost from source.\n                if ((child[i].state & Node.CLOSED) > 0 && child[i].total <= total) {\n                    continue;\n                }\n                // a new shorter path to this child was found. update\n                // the node and add it to the list of open nodes if\n                // it isn't already open.\n                //dx = Math.abs(child[i].x - source.x);\n                //dy = Math.abs(child[i].y - source.y);\n                //h  = Math.min(dx, dy) + MATH_SQRT_2 * Math.abs(dx - dy);\n                dx = child[i].x - target.x;\n                dy = child[i].y - target.y;\n                h = (float) Math.sqrt(dx * dx + dy * dy);\n                float score = total + minCost * h;\n                //float score = total + minCost * heuristic(current, child[i]);\n                child[i].parent = current;\n                child[i].total = total;\n                child[i].score = score;\n                if ((child[i].state & Node.CLOSED) > 0) {\n                    child[i].state ^= Node.CLOSED;\n                }\n                if ((child[i].state & Node.OPEN) == 0) {\n                    int l = 0;\n                    int r = n - 1;\n                    int m = 0;\n                    int t = 0;\n                    // search the open array for a place to insert new\n                    // node. the array is ordered in reverse natural order.\n                    while (l <= r) {\n                        m = (l + r) / 2;\n                        t = child[i].score < open[m].score ? 1 : (child[i].score > open[m].score ? -1 : 0);\n                        if (t < 0) {\n                            r = m - 1;\n                        } else if (t > 0) {\n                            l = m + 1;\n                        } else {\n                            break;\n                        }\n                    }\n                    m = m < 0 ? 0 : m;\n                    // if the buffer is full allocate space for some\n                    // more nodes. make it twice as large as it was.\n                    if (n > open.length - 2) {\n                        DirtyNode[] temp = open;\n                        open = new DirtyNode[temp.length << 1];\n                        System.arraycopy(temp, 0, open, 0, temp.length);\n                    }\n                    System.arraycopy(open, m, open, m + 1, n - m);\n                    child[i].state ^= Node.OPEN;\n                    open[m] = child[i];\n                    n = n + 1;\n                }\n            }\n            current.state ^= Node.CLOSED;\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", t=\" + target);\n    }\n\n    /**\n     * Search for the path connecting the source node with the target node.\n     * This algorithm does not take into account the cost of accessing each\n     * node, only the estimated remaining distance to target is considered.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path bestFirstSearch(Node source, Node target) throws PathNotFoundException {\n        Vector open = new Vector();\n        reset();\n        source.setScore(0.0f);\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(0);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // skip nodes that are currently being processed and\n                // which have a lower total cost from source.\n                if (child[i].isOpen() || child[i].isClosed()) {\n                    continue;\n                }\n                // estimate the remaining distance to target.\n                float score = minCost * heuristic(child[i], target);\n                child[i].setParent(current);\n                child[i].setScore(score);\n                int j = java.util.Collections.binarySearch(open, child[i]);\n                if (j < 0) {\n                    j = -j > open.size() ? open.size() : -j;\n                    open.insertElementAt(child[i], j);\n                    child[i].setOpen(true);\n                    child[i].setClosed(false);\n                }\n            }\n            current.setClosed(true);\n            current.setOpen(false);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * Search for the shortest path connecting the source node with\n     * the target node. This algorithm is guaranteed to find the\n     * optimal shortest path, if it exist.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path dijkstraSearch(Node source, Node target) throws PathNotFoundException {\n        Vector open = new Vector();\n        reset();\n        source.setTotal(0.0f);\n        source.setScore(0.0f);\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(0);\n            current.setOpen(false);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // calculate the accumulated total cost of moving\n                // from source to this child.\n                float total = current.getTotal() + cost(current, child[i]);\n                // skip nodes that are currently being processed and\n                // which have a lower total cost from source.\n                if (child[i].isOpen() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // skip nodes that have already been processed and\n                // which have a lower total cost from source.\n                if (child[i].isClosed() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // a new shorter path to this child was found. update\n                // the node and add it to the list of open nodes if\n                // it isn't already open.\n                child[i].setParent(current);\n                child[i].setTotal(total);\n                child[i].setScore(total);\n                if (child[i].isClosed()) {\n                    child[i].setClosed(false);\n                }\n                if (!child[i].isOpen()) {\n                    open.add(child[i]);\n                    child[i].setOpen(true);\n                }\n            }\n            current.setClosed(true);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * Search for the path connecting the source node with the target node.\n     * This algorithm does not take into account the cost of accessing each\n     * node.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path breadthFirstSearch(Node source, Node target) throws PathNotFoundException {\n        Vector open = new Vector();\n        reset();\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(0);\n            current.setOpen(false);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // skip nodes that are currently being processed and\n                // nodes that have already been processed.\n                if (child[i].isOpen() || child[i].isClosed()) {\n                    continue;\n                }\n                child[i].setParent(current);\n                if (!child[i].isOpen()) {\n                    child[i].setOpen(true);\n                    open.add(child[i]);\n                }\n            }\n            current.setClosed(true);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * Search for the path connecting the source node with the target node.\n     * This algorithm does not take into account the cost of accessing each\n     * node.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path depthFirstSearch(Node source, Node target) throws PathNotFoundException {\n        Vector open = new Vector();\n        reset();\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(open.size() - 1);\n            current.setOpen(false);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // skip nodes that are currently being processed and\n                // nodes that have already been processed.\n                if (child[i].isOpen() || child[i].isClosed()) {\n                    continue;\n                }\n                child[i].setParent(current);\n                if (!child[i].isOpen()) {\n                    open.add(child[i]);\n                    child[i].setOpen(true);\n                }\n            }\n            current.setClosed(true);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * The associated heuristic function for this map. Estimates\n     * the remaining distance from node a to node b.\n     *\n     * @param a The first node.\n     * @param b The second node.\n     */\n    protected abstract float heuristic(Node a, Node b);\n\n    /**\n     * Determines the actual cost of crossing the edge between\n     * the given adjectant nodes. If the nodes are not adjectant\n     * the returned cost is unspecified.\n     *\n     * @param source The source node.\n     * @param target The target node.\n     */\n    protected abstract float cost(Node source, Node target);\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/map/AbstractMapTest1.java",
		"test_prompt": "// AbstractMapTest1.java\npackage map;\n\nimport java.util.Vector;\nimport java.util.PriorityQueue;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractMap}.\n* It contains ten unit test cases for the {@link AbstractMap#aStarSearch2(Node, Node)} method.\n*/\nclass AbstractMapTest1 {"
	},
	{
		"original_code": "// AbstractMap.java\n/* AbstractMap.java v0.1 (06/17/2002)\n *\n * Copyright (C) 2002, Joel Andersson <bja@kth.se>\n * \n * This software is hereby expressly placed in the public domain.\n * Share and enjoy.\n */\npackage map;\n\nimport java.util.Vector;\nimport java.util.PriorityQueue;\n\n//import bja.util.PriorityQueue;\npublic abstract class AbstractMap implements Map {\n\n    /**\n     * The square root of 2.0f.\n     */\n    protected static final float MATH_SQRT_2 = 1.41421356f;\n\n    /**\n     * The minimum cost associated with accessing a node in this map.\n     */\n    protected static float minCost;\n\n    /**\n     * The maximum cost associated with accessing a node in this map.\n     */\n    protected static float maxCost;\n\n    /**\n     * Creates a new instance of this class.\n     */\n    protected AbstractMap() {\n        minCost = 0.1f;\n        maxCost = 1.0f;\n    }\n\n    /**\n     * Creates a new instance of this class with the specified\n     * attributes.\n     *\n     * @param min the minimum cost of accessing a node.\n     * @param max the maximum cost of accessing a node.\n     */\n    protected AbstractMap(float min, float max) {\n        minCost = min;\n        maxCost = max;\n    }\n\n    /**\n     * Search for the shortest path connecting the source node with\n     * the target node. This algorithm is guaranteed to find the\n     * optimal shortest path, if it exist, provided that the heuristic\n     * function is admissible.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path aStarSearch(Node source, Node target) throws PathNotFoundException {\n        PriorityQueue open = new PriorityQueue();\n        reset();\n        source.setTotal(0.0f);\n        source.setScore(minCost * heuristic(source, target));\n        open.add(source);\n        while (open.size() != 0) {\n            Node current = (Node) open.poll();\n            current.setOpen(false);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // calculate the accumulated total cost of moving\n                // from the source to this child.\n                float total = current.getTotal() + cost(current, child[i]);\n                // skip nodes that are currently being processed and\n                // which have a lower total cost from the source.\n                if (child[i].isOpen() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // skip nodes that have already been processed and\n                // which have a lower total cost from the source.\n                if (child[i].isClosed() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // a new shorter path to this child was found. update\n                // the node and add it to the list of open nodes if\n                // it isn't already open.\n                float score = total + minCost * heuristic(child[i], target);\n                child[i].setParent(current);\n                child[i].setTotal(total);\n                child[i].setScore(score);\n                if (child[i].isClosed()) {\n                    child[i].setClosed(false);\n                }\n                if (!child[i].isOpen()) {\n                    open.add(child[i]);\n                    child[i].setOpen(true);\n                }\n            }\n            current.setClosed(true);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * Search for the shortest path connecting the source node with\n     * the target node. This algorithm is guaranteed to find the\n     * optimal shortest path, if it exist, provided that the heuristic\n     * function is admissible.\n     *\n     * This is a slightly faster implementation of the A* algorithm than\n     * the above using a sorted array to store the open nodes instead of\n     * a PriorityQueue.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path aStarSearch2(Node source, Node target) throws PathNotFoundException {\n        int n = 0;\n        Node[] open = new Node[16];\n        reset();\n        source.setTotal(0.0f);\n        source.setScore(minCost * heuristic(source, target));\n        open[n++] = source;\n        while (n > 0) {\n            Node current = open[--n];\n            current.setOpen(false);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // calculate the accumulated total cost of moving\n                // from source to this child.\n                float total = current.getTotal() + cost(current, child[i]);\n                // skip nodes that are currently being processed and\n                // which have a lower total cost from source.\n                if (child[i].isOpen() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // skip nodes that have already been processed and\n                // which have a lower total cost from source.\n                if (child[i].isClosed() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // a new shorter path to this child was found. update\n                // the node and add it to the list of open nodes if\n                // it isn't already open.\n                float score = total + minCost * heuristic(child[i], target);\n                child[i].setParent(current);\n                child[i].setTotal(total);\n                child[i].setScore(score);\n                if (child[i].isClosed()) {\n                    child[i].setClosed(false);\n                }\n                if (!child[i].isOpen()) {\n                    int l = 0;\n                    int r = n - 1;\n                    int m = 0;\n                    int t = 0;\n                    // search for place to insert new node.\n                    while (l <= r) {\n                        m = (l + r) / 2;\n                        t = -child[i].compareTo(open[m]);\n                        if (t < 0) {\n                            r = m - 1;\n                        } else if (t > 0) {\n                            l = m + 1;\n                        } else {\n                            break;\n                        }\n                    }\n                    m = m < 0 ? 0 : m;\n                    // if the buffer is full allocate space for some\n                    // more nodes. make it twice as large as it was.\n                    if (n > open.length - 2) {\n                        Node[] temp = open;\n                        open = new Node[temp.length << 1];\n                        System.arraycopy(temp, 0, open, 0, temp.length);\n                    }\n                    System.arraycopy(open, m, open, m + 1, n - m);\n                    child[i].setOpen(true);\n                    open[m] = child[i];\n                    n = n + 1;\n                }\n            }\n            current.setClosed(true);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * Search for the shortest path connecting the source node with\n     * the target node. This algorithm is guaranteed to find the\n     * optimal shortest path, if it exist, provided that the heuristic\n     * function is admissible.\n     *\n     * This is a slightly faster implementation of the A* algorithm than\n     * the above using a sorted array to store the open nodes instead of\n     * a PriorityQueue and using DirtyNodes instead of the DefaultNodes.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public Path aStarSearch3(DirtyNode source, DirtyNode target) throws PathNotFoundException {\n        DirtyNode[] open = new DirtyNode[32];\n        int n = 0;\n        reset();\n        //float dx = Math.abs(target.x - source.x);\n        //float dy = Math.abs(target.y - source.y);\n        //float h  = Math.min(dx, dy) + MATH_SQRT_2 * Math.abs(dx - dy);\n        float dx = target.x - source.x;\n        float dy = target.y - source.y;\n        float h = (float) Math.sqrt(dx * dx + dy * dy);\n        source.total = 0.0f;\n        source.score = minCost * h;\n        //source.score = minCost * heuristic(source, target);\n        open[n++] = source;\n        while (n > 0) {\n            DirtyNode current = open[--n];\n            current.state ^= Node.OPEN;\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            DirtyNode[] child = current.children;\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].cost >= maxCost) {\n                    continue;\n                }\n                // calculate the accumulated total cost of moving\n                // from source to this child.\n                float weight = (i % 2 == 0) ? 1 : MATH_SQRT_2;\n                float total = current.total + weight * child[i].cost;\n                //float total = current.total + cost(current, child[i]);\n                // skip nodes that are currently being processed and\n                // which have a lower total cost from source.\n                if ((child[i].state & Node.OPEN) > 0 && child[i].total <= total) {\n                    continue;\n                }\n                // skip nodes that have already been processed and\n                // which have a lower total cost from source.\n                if ((child[i].state & Node.CLOSED) > 0 && child[i].total <= total) {\n                    continue;\n                }\n                // a new shorter path to this child was found. update\n                // the node and add it to the list of open nodes if\n                // it isn't already open.\n                //dx = Math.abs(child[i].x - source.x);\n                //dy = Math.abs(child[i].y - source.y);\n                //h  = Math.min(dx, dy) + MATH_SQRT_2 * Math.abs(dx - dy);\n                dx = child[i].x - target.x;\n                dy = child[i].y - target.y;\n                h = (float) Math.sqrt(dx * dx + dy * dy);\n                float score = total + minCost * h;\n                //float score = total + minCost * heuristic(current, child[i]);\n                child[i].parent = current;\n                child[i].total = total;\n                child[i].score = score;\n                if ((child[i].state & Node.CLOSED) > 0) {\n                    child[i].state ^= Node.CLOSED;\n                }\n                if ((child[i].state & Node.OPEN) == 0) {\n                    int l = 0;\n                    int r = n - 1;\n                    int m = 0;\n                    int t = 0;\n                    // search the open array for a place to insert new\n                    // node. the array is ordered in reverse natural order.\n                    while (l <= r) {\n                        m = (l + r) / 2;\n                        t = child[i].score < open[m].score ? 1 : (child[i].score > open[m].score ? -1 : 0);\n                        if (t < 0) {\n                            r = m - 1;\n                        } else if (t > 0) {\n                            l = m + 1;\n                        } else {\n                            break;\n                        }\n                    }\n                    m = m < 0 ? 0 : m;\n                    // if the buffer is full allocate space for some\n                    // more nodes. make it twice as large as it was.\n                    if (n > open.length - 2) {\n                        DirtyNode[] temp = open;\n                        open = new DirtyNode[temp.length << 1];\n                        System.arraycopy(temp, 0, open, 0, temp.length);\n                    }\n                    System.arraycopy(open, m, open, m + 1, n - m);\n                    child[i].state ^= Node.OPEN;\n                    open[m] = child[i];\n                    n = n + 1;\n                }\n            }\n            current.state ^= Node.CLOSED;\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", t=\" + target);\n    }\n\n    /**\n     * Search for the path connecting the source node with the target node.\n     * This algorithm does not take into account the cost of accessing each\n     * node, only the estimated remaining distance to target is considered.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path bestFirstSearch(Node source, Node target) throws PathNotFoundException {\n        Vector open = new Vector();\n        reset();\n        source.setScore(0.0f);\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(0);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // skip nodes that are currently being processed and\n                // which have a lower total cost from source.\n                if (child[i].isOpen() || child[i].isClosed()) {\n                    continue;\n                }\n                // estimate the remaining distance to target.\n                float score = minCost * heuristic(child[i], target);\n                child[i].setParent(current);\n                child[i].setScore(score);\n                int j = java.util.Collections.binarySearch(open, child[i]);\n                if (j < 0) {\n                    j = -j > open.size() ? open.size() : -j;\n                    open.insertElementAt(child[i], j);\n                    child[i].setOpen(true);\n                    child[i].setClosed(false);\n                }\n            }\n            current.setClosed(true);\n            current.setOpen(false);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * Search for the shortest path connecting the source node with\n     * the target node. This algorithm is guaranteed to find the\n     * optimal shortest path, if it exist.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path dijkstraSearch(Node source, Node target) throws PathNotFoundException {\n        Vector open = new Vector();\n        reset();\n        source.setTotal(0.0f);\n        source.setScore(0.0f);\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(0);\n            current.setOpen(false);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // calculate the accumulated total cost of moving\n                // from source to this child.\n                float total = current.getTotal() + cost(current, child[i]);\n                // skip nodes that are currently being processed and\n                // which have a lower total cost from source.\n                if (child[i].isOpen() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // skip nodes that have already been processed and\n                // which have a lower total cost from source.\n                if (child[i].isClosed() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // a new shorter path to this child was found. update\n                // the node and add it to the list of open nodes if\n                // it isn't already open.\n                child[i].setParent(current);\n                child[i].setTotal(total);\n                child[i].setScore(total);\n                if (child[i].isClosed()) {\n                    child[i].setClosed(false);\n                }\n                if (!child[i].isOpen()) {\n                    open.add(child[i]);\n                    child[i].setOpen(true);\n                }\n            }\n            current.setClosed(true);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * Search for the path connecting the source node with the target node.\n     * This algorithm does not take into account the cost of accessing each\n     * node.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path breadthFirstSearch(Node source, Node target) throws PathNotFoundException {\n        Vector open = new Vector();\n        reset();\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(0);\n            current.setOpen(false);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // skip nodes that are currently being processed and\n                // nodes that have already been processed.\n                if (child[i].isOpen() || child[i].isClosed()) {\n                    continue;\n                }\n                child[i].setParent(current);\n                if (!child[i].isOpen()) {\n                    child[i].setOpen(true);\n                    open.add(child[i]);\n                }\n            }\n            current.setClosed(true);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * Search for the path connecting the source node with the target node.\n     * This algorithm does not take into account the cost of accessing each\n     * node.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path depthFirstSearch(Node source, Node target) throws PathNotFoundException {\n        Vector open = new Vector();\n        reset();\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(open.size() - 1);\n            current.setOpen(false);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // skip nodes that are currently being processed and\n                // nodes that have already been processed.\n                if (child[i].isOpen() || child[i].isClosed()) {\n                    continue;\n                }\n                child[i].setParent(current);\n                if (!child[i].isOpen()) {\n                    open.add(child[i]);\n                    child[i].setOpen(true);\n                }\n            }\n            current.setClosed(true);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * The associated heuristic function for this map. Estimates\n     * the remaining distance from node a to node b.\n     *\n     * @param a The first node.\n     * @param b The second node.\n     */\n    protected abstract float heuristic(Node a, Node b);\n\n    /**\n     * Determines the actual cost of crossing the edge between\n     * the given adjectant nodes. If the nodes are not adjectant\n     * the returned cost is unspecified.\n     *\n     * @param source The source node.\n     * @param target The target node.\n     */\n    protected abstract float cost(Node source, Node target);\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/map/AbstractMapTest2.java",
		"test_prompt": "// AbstractMapTest2.java\npackage map;\n\nimport java.util.Vector;\nimport java.util.PriorityQueue;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractMap}.\n* It contains ten unit test cases for the {@link AbstractMap#aStarSearch3(DirtyNode, DirtyNode)} method.\n*/\nclass AbstractMapTest2 {"
	},
	{
		"original_code": "// AbstractMap.java\n/* AbstractMap.java v0.1 (06/17/2002)\n *\n * Copyright (C) 2002, Joel Andersson <bja@kth.se>\n * \n * This software is hereby expressly placed in the public domain.\n * Share and enjoy.\n */\npackage map;\n\nimport java.util.Vector;\nimport java.util.PriorityQueue;\n\n//import bja.util.PriorityQueue;\npublic abstract class AbstractMap implements Map {\n\n    /**\n     * The square root of 2.0f.\n     */\n    protected static final float MATH_SQRT_2 = 1.41421356f;\n\n    /**\n     * The minimum cost associated with accessing a node in this map.\n     */\n    protected static float minCost;\n\n    /**\n     * The maximum cost associated with accessing a node in this map.\n     */\n    protected static float maxCost;\n\n    /**\n     * Creates a new instance of this class.\n     */\n    protected AbstractMap() {\n        minCost = 0.1f;\n        maxCost = 1.0f;\n    }\n\n    /**\n     * Creates a new instance of this class with the specified\n     * attributes.\n     *\n     * @param min the minimum cost of accessing a node.\n     * @param max the maximum cost of accessing a node.\n     */\n    protected AbstractMap(float min, float max) {\n        minCost = min;\n        maxCost = max;\n    }\n\n    /**\n     * Search for the shortest path connecting the source node with\n     * the target node. This algorithm is guaranteed to find the\n     * optimal shortest path, if it exist, provided that the heuristic\n     * function is admissible.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path aStarSearch(Node source, Node target) throws PathNotFoundException {\n        PriorityQueue open = new PriorityQueue();\n        reset();\n        source.setTotal(0.0f);\n        source.setScore(minCost * heuristic(source, target));\n        open.add(source);\n        while (open.size() != 0) {\n            Node current = (Node) open.poll();\n            current.setOpen(false);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // calculate the accumulated total cost of moving\n                // from the source to this child.\n                float total = current.getTotal() + cost(current, child[i]);\n                // skip nodes that are currently being processed and\n                // which have a lower total cost from the source.\n                if (child[i].isOpen() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // skip nodes that have already been processed and\n                // which have a lower total cost from the source.\n                if (child[i].isClosed() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // a new shorter path to this child was found. update\n                // the node and add it to the list of open nodes if\n                // it isn't already open.\n                float score = total + minCost * heuristic(child[i], target);\n                child[i].setParent(current);\n                child[i].setTotal(total);\n                child[i].setScore(score);\n                if (child[i].isClosed()) {\n                    child[i].setClosed(false);\n                }\n                if (!child[i].isOpen()) {\n                    open.add(child[i]);\n                    child[i].setOpen(true);\n                }\n            }\n            current.setClosed(true);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * Search for the shortest path connecting the source node with\n     * the target node. This algorithm is guaranteed to find the\n     * optimal shortest path, if it exist, provided that the heuristic\n     * function is admissible.\n     *\n     * This is a slightly faster implementation of the A* algorithm than\n     * the above using a sorted array to store the open nodes instead of\n     * a PriorityQueue.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path aStarSearch2(Node source, Node target) throws PathNotFoundException {\n        int n = 0;\n        Node[] open = new Node[16];\n        reset();\n        source.setTotal(0.0f);\n        source.setScore(minCost * heuristic(source, target));\n        open[n++] = source;\n        while (n > 0) {\n            Node current = open[--n];\n            current.setOpen(false);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // calculate the accumulated total cost of moving\n                // from source to this child.\n                float total = current.getTotal() + cost(current, child[i]);\n                // skip nodes that are currently being processed and\n                // which have a lower total cost from source.\n                if (child[i].isOpen() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // skip nodes that have already been processed and\n                // which have a lower total cost from source.\n                if (child[i].isClosed() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // a new shorter path to this child was found. update\n                // the node and add it to the list of open nodes if\n                // it isn't already open.\n                float score = total + minCost * heuristic(child[i], target);\n                child[i].setParent(current);\n                child[i].setTotal(total);\n                child[i].setScore(score);\n                if (child[i].isClosed()) {\n                    child[i].setClosed(false);\n                }\n                if (!child[i].isOpen()) {\n                    int l = 0;\n                    int r = n - 1;\n                    int m = 0;\n                    int t = 0;\n                    // search for place to insert new node.\n                    while (l <= r) {\n                        m = (l + r) / 2;\n                        t = -child[i].compareTo(open[m]);\n                        if (t < 0) {\n                            r = m - 1;\n                        } else if (t > 0) {\n                            l = m + 1;\n                        } else {\n                            break;\n                        }\n                    }\n                    m = m < 0 ? 0 : m;\n                    // if the buffer is full allocate space for some\n                    // more nodes. make it twice as large as it was.\n                    if (n > open.length - 2) {\n                        Node[] temp = open;\n                        open = new Node[temp.length << 1];\n                        System.arraycopy(temp, 0, open, 0, temp.length);\n                    }\n                    System.arraycopy(open, m, open, m + 1, n - m);\n                    child[i].setOpen(true);\n                    open[m] = child[i];\n                    n = n + 1;\n                }\n            }\n            current.setClosed(true);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * Search for the shortest path connecting the source node with\n     * the target node. This algorithm is guaranteed to find the\n     * optimal shortest path, if it exist, provided that the heuristic\n     * function is admissible.\n     *\n     * This is a slightly faster implementation of the A* algorithm than\n     * the above using a sorted array to store the open nodes instead of\n     * a PriorityQueue and using DirtyNodes instead of the DefaultNodes.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public Path aStarSearch3(DirtyNode source, DirtyNode target) throws PathNotFoundException {\n        DirtyNode[] open = new DirtyNode[32];\n        int n = 0;\n        reset();\n        //float dx = Math.abs(target.x - source.x);\n        //float dy = Math.abs(target.y - source.y);\n        //float h  = Math.min(dx, dy) + MATH_SQRT_2 * Math.abs(dx - dy);\n        float dx = target.x - source.x;\n        float dy = target.y - source.y;\n        float h = (float) Math.sqrt(dx * dx + dy * dy);\n        source.total = 0.0f;\n        source.score = minCost * h;\n        //source.score = minCost * heuristic(source, target);\n        open[n++] = source;\n        while (n > 0) {\n            DirtyNode current = open[--n];\n            current.state ^= Node.OPEN;\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            DirtyNode[] child = current.children;\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].cost >= maxCost) {\n                    continue;\n                }\n                // calculate the accumulated total cost of moving\n                // from source to this child.\n                float weight = (i % 2 == 0) ? 1 : MATH_SQRT_2;\n                float total = current.total + weight * child[i].cost;\n                //float total = current.total + cost(current, child[i]);\n                // skip nodes that are currently being processed and\n                // which have a lower total cost from source.\n                if ((child[i].state & Node.OPEN) > 0 && child[i].total <= total) {\n                    continue;\n                }\n                // skip nodes that have already been processed and\n                // which have a lower total cost from source.\n                if ((child[i].state & Node.CLOSED) > 0 && child[i].total <= total) {\n                    continue;\n                }\n                // a new shorter path to this child was found. update\n                // the node and add it to the list of open nodes if\n                // it isn't already open.\n                //dx = Math.abs(child[i].x - source.x);\n                //dy = Math.abs(child[i].y - source.y);\n                //h  = Math.min(dx, dy) + MATH_SQRT_2 * Math.abs(dx - dy);\n                dx = child[i].x - target.x;\n                dy = child[i].y - target.y;\n                h = (float) Math.sqrt(dx * dx + dy * dy);\n                float score = total + minCost * h;\n                //float score = total + minCost * heuristic(current, child[i]);\n                child[i].parent = current;\n                child[i].total = total;\n                child[i].score = score;\n                if ((child[i].state & Node.CLOSED) > 0) {\n                    child[i].state ^= Node.CLOSED;\n                }\n                if ((child[i].state & Node.OPEN) == 0) {\n                    int l = 0;\n                    int r = n - 1;\n                    int m = 0;\n                    int t = 0;\n                    // search the open array for a place to insert new\n                    // node. the array is ordered in reverse natural order.\n                    while (l <= r) {\n                        m = (l + r) / 2;\n                        t = child[i].score < open[m].score ? 1 : (child[i].score > open[m].score ? -1 : 0);\n                        if (t < 0) {\n                            r = m - 1;\n                        } else if (t > 0) {\n                            l = m + 1;\n                        } else {\n                            break;\n                        }\n                    }\n                    m = m < 0 ? 0 : m;\n                    // if the buffer is full allocate space for some\n                    // more nodes. make it twice as large as it was.\n                    if (n > open.length - 2) {\n                        DirtyNode[] temp = open;\n                        open = new DirtyNode[temp.length << 1];\n                        System.arraycopy(temp, 0, open, 0, temp.length);\n                    }\n                    System.arraycopy(open, m, open, m + 1, n - m);\n                    child[i].state ^= Node.OPEN;\n                    open[m] = child[i];\n                    n = n + 1;\n                }\n            }\n            current.state ^= Node.CLOSED;\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", t=\" + target);\n    }\n\n    /**\n     * Search for the path connecting the source node with the target node.\n     * This algorithm does not take into account the cost of accessing each\n     * node, only the estimated remaining distance to target is considered.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path bestFirstSearch(Node source, Node target) throws PathNotFoundException {\n        Vector open = new Vector();\n        reset();\n        source.setScore(0.0f);\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(0);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // skip nodes that are currently being processed and\n                // which have a lower total cost from source.\n                if (child[i].isOpen() || child[i].isClosed()) {\n                    continue;\n                }\n                // estimate the remaining distance to target.\n                float score = minCost * heuristic(child[i], target);\n                child[i].setParent(current);\n                child[i].setScore(score);\n                int j = java.util.Collections.binarySearch(open, child[i]);\n                if (j < 0) {\n                    j = -j > open.size() ? open.size() : -j;\n                    open.insertElementAt(child[i], j);\n                    child[i].setOpen(true);\n                    child[i].setClosed(false);\n                }\n            }\n            current.setClosed(true);\n            current.setOpen(false);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * Search for the shortest path connecting the source node with\n     * the target node. This algorithm is guaranteed to find the\n     * optimal shortest path, if it exist.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path dijkstraSearch(Node source, Node target) throws PathNotFoundException {\n        Vector open = new Vector();\n        reset();\n        source.setTotal(0.0f);\n        source.setScore(0.0f);\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(0);\n            current.setOpen(false);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // calculate the accumulated total cost of moving\n                // from source to this child.\n                float total = current.getTotal() + cost(current, child[i]);\n                // skip nodes that are currently being processed and\n                // which have a lower total cost from source.\n                if (child[i].isOpen() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // skip nodes that have already been processed and\n                // which have a lower total cost from source.\n                if (child[i].isClosed() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // a new shorter path to this child was found. update\n                // the node and add it to the list of open nodes if\n                // it isn't already open.\n                child[i].setParent(current);\n                child[i].setTotal(total);\n                child[i].setScore(total);\n                if (child[i].isClosed()) {\n                    child[i].setClosed(false);\n                }\n                if (!child[i].isOpen()) {\n                    open.add(child[i]);\n                    child[i].setOpen(true);\n                }\n            }\n            current.setClosed(true);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * Search for the path connecting the source node with the target node.\n     * This algorithm does not take into account the cost of accessing each\n     * node.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path breadthFirstSearch(Node source, Node target) throws PathNotFoundException {\n        Vector open = new Vector();\n        reset();\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(0);\n            current.setOpen(false);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // skip nodes that are currently being processed and\n                // nodes that have already been processed.\n                if (child[i].isOpen() || child[i].isClosed()) {\n                    continue;\n                }\n                child[i].setParent(current);\n                if (!child[i].isOpen()) {\n                    child[i].setOpen(true);\n                    open.add(child[i]);\n                }\n            }\n            current.setClosed(true);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * Search for the path connecting the source node with the target node.\n     * This algorithm does not take into account the cost of accessing each\n     * node.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path depthFirstSearch(Node source, Node target) throws PathNotFoundException {\n        Vector open = new Vector();\n        reset();\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(open.size() - 1);\n            current.setOpen(false);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // skip nodes that are currently being processed and\n                // nodes that have already been processed.\n                if (child[i].isOpen() || child[i].isClosed()) {\n                    continue;\n                }\n                child[i].setParent(current);\n                if (!child[i].isOpen()) {\n                    open.add(child[i]);\n                    child[i].setOpen(true);\n                }\n            }\n            current.setClosed(true);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * The associated heuristic function for this map. Estimates\n     * the remaining distance from node a to node b.\n     *\n     * @param a The first node.\n     * @param b The second node.\n     */\n    protected abstract float heuristic(Node a, Node b);\n\n    /**\n     * Determines the actual cost of crossing the edge between\n     * the given adjectant nodes. If the nodes are not adjectant\n     * the returned cost is unspecified.\n     *\n     * @param source The source node.\n     * @param target The target node.\n     */\n    protected abstract float cost(Node source, Node target);\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/map/AbstractMapTest3.java",
		"test_prompt": "// AbstractMapTest3.java\npackage map;\n\nimport java.util.Vector;\nimport java.util.PriorityQueue;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractMap}.\n* It contains ten unit test cases for the {@link AbstractMap#bestFirstSearch(Node, Node)} method.\n*/\nclass AbstractMapTest3 {"
	},
	{
		"original_code": "// AbstractMap.java\n/* AbstractMap.java v0.1 (06/17/2002)\n *\n * Copyright (C) 2002, Joel Andersson <bja@kth.se>\n * \n * This software is hereby expressly placed in the public domain.\n * Share and enjoy.\n */\npackage map;\n\nimport java.util.Vector;\nimport java.util.PriorityQueue;\n\n//import bja.util.PriorityQueue;\npublic abstract class AbstractMap implements Map {\n\n    /**\n     * The square root of 2.0f.\n     */\n    protected static final float MATH_SQRT_2 = 1.41421356f;\n\n    /**\n     * The minimum cost associated with accessing a node in this map.\n     */\n    protected static float minCost;\n\n    /**\n     * The maximum cost associated with accessing a node in this map.\n     */\n    protected static float maxCost;\n\n    /**\n     * Creates a new instance of this class.\n     */\n    protected AbstractMap() {\n        minCost = 0.1f;\n        maxCost = 1.0f;\n    }\n\n    /**\n     * Creates a new instance of this class with the specified\n     * attributes.\n     *\n     * @param min the minimum cost of accessing a node.\n     * @param max the maximum cost of accessing a node.\n     */\n    protected AbstractMap(float min, float max) {\n        minCost = min;\n        maxCost = max;\n    }\n\n    /**\n     * Search for the shortest path connecting the source node with\n     * the target node. This algorithm is guaranteed to find the\n     * optimal shortest path, if it exist, provided that the heuristic\n     * function is admissible.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path aStarSearch(Node source, Node target) throws PathNotFoundException {\n        PriorityQueue open = new PriorityQueue();\n        reset();\n        source.setTotal(0.0f);\n        source.setScore(minCost * heuristic(source, target));\n        open.add(source);\n        while (open.size() != 0) {\n            Node current = (Node) open.poll();\n            current.setOpen(false);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // calculate the accumulated total cost of moving\n                // from the source to this child.\n                float total = current.getTotal() + cost(current, child[i]);\n                // skip nodes that are currently being processed and\n                // which have a lower total cost from the source.\n                if (child[i].isOpen() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // skip nodes that have already been processed and\n                // which have a lower total cost from the source.\n                if (child[i].isClosed() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // a new shorter path to this child was found. update\n                // the node and add it to the list of open nodes if\n                // it isn't already open.\n                float score = total + minCost * heuristic(child[i], target);\n                child[i].setParent(current);\n                child[i].setTotal(total);\n                child[i].setScore(score);\n                if (child[i].isClosed()) {\n                    child[i].setClosed(false);\n                }\n                if (!child[i].isOpen()) {\n                    open.add(child[i]);\n                    child[i].setOpen(true);\n                }\n            }\n            current.setClosed(true);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * Search for the shortest path connecting the source node with\n     * the target node. This algorithm is guaranteed to find the\n     * optimal shortest path, if it exist, provided that the heuristic\n     * function is admissible.\n     *\n     * This is a slightly faster implementation of the A* algorithm than\n     * the above using a sorted array to store the open nodes instead of\n     * a PriorityQueue.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path aStarSearch2(Node source, Node target) throws PathNotFoundException {\n        int n = 0;\n        Node[] open = new Node[16];\n        reset();\n        source.setTotal(0.0f);\n        source.setScore(minCost * heuristic(source, target));\n        open[n++] = source;\n        while (n > 0) {\n            Node current = open[--n];\n            current.setOpen(false);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // calculate the accumulated total cost of moving\n                // from source to this child.\n                float total = current.getTotal() + cost(current, child[i]);\n                // skip nodes that are currently being processed and\n                // which have a lower total cost from source.\n                if (child[i].isOpen() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // skip nodes that have already been processed and\n                // which have a lower total cost from source.\n                if (child[i].isClosed() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // a new shorter path to this child was found. update\n                // the node and add it to the list of open nodes if\n                // it isn't already open.\n                float score = total + minCost * heuristic(child[i], target);\n                child[i].setParent(current);\n                child[i].setTotal(total);\n                child[i].setScore(score);\n                if (child[i].isClosed()) {\n                    child[i].setClosed(false);\n                }\n                if (!child[i].isOpen()) {\n                    int l = 0;\n                    int r = n - 1;\n                    int m = 0;\n                    int t = 0;\n                    // search for place to insert new node.\n                    while (l <= r) {\n                        m = (l + r) / 2;\n                        t = -child[i].compareTo(open[m]);\n                        if (t < 0) {\n                            r = m - 1;\n                        } else if (t > 0) {\n                            l = m + 1;\n                        } else {\n                            break;\n                        }\n                    }\n                    m = m < 0 ? 0 : m;\n                    // if the buffer is full allocate space for some\n                    // more nodes. make it twice as large as it was.\n                    if (n > open.length - 2) {\n                        Node[] temp = open;\n                        open = new Node[temp.length << 1];\n                        System.arraycopy(temp, 0, open, 0, temp.length);\n                    }\n                    System.arraycopy(open, m, open, m + 1, n - m);\n                    child[i].setOpen(true);\n                    open[m] = child[i];\n                    n = n + 1;\n                }\n            }\n            current.setClosed(true);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * Search for the shortest path connecting the source node with\n     * the target node. This algorithm is guaranteed to find the\n     * optimal shortest path, if it exist, provided that the heuristic\n     * function is admissible.\n     *\n     * This is a slightly faster implementation of the A* algorithm than\n     * the above using a sorted array to store the open nodes instead of\n     * a PriorityQueue and using DirtyNodes instead of the DefaultNodes.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public Path aStarSearch3(DirtyNode source, DirtyNode target) throws PathNotFoundException {\n        DirtyNode[] open = new DirtyNode[32];\n        int n = 0;\n        reset();\n        //float dx = Math.abs(target.x - source.x);\n        //float dy = Math.abs(target.y - source.y);\n        //float h  = Math.min(dx, dy) + MATH_SQRT_2 * Math.abs(dx - dy);\n        float dx = target.x - source.x;\n        float dy = target.y - source.y;\n        float h = (float) Math.sqrt(dx * dx + dy * dy);\n        source.total = 0.0f;\n        source.score = minCost * h;\n        //source.score = minCost * heuristic(source, target);\n        open[n++] = source;\n        while (n > 0) {\n            DirtyNode current = open[--n];\n            current.state ^= Node.OPEN;\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            DirtyNode[] child = current.children;\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].cost >= maxCost) {\n                    continue;\n                }\n                // calculate the accumulated total cost of moving\n                // from source to this child.\n                float weight = (i % 2 == 0) ? 1 : MATH_SQRT_2;\n                float total = current.total + weight * child[i].cost;\n                //float total = current.total + cost(current, child[i]);\n                // skip nodes that are currently being processed and\n                // which have a lower total cost from source.\n                if ((child[i].state & Node.OPEN) > 0 && child[i].total <= total) {\n                    continue;\n                }\n                // skip nodes that have already been processed and\n                // which have a lower total cost from source.\n                if ((child[i].state & Node.CLOSED) > 0 && child[i].total <= total) {\n                    continue;\n                }\n                // a new shorter path to this child was found. update\n                // the node and add it to the list of open nodes if\n                // it isn't already open.\n                //dx = Math.abs(child[i].x - source.x);\n                //dy = Math.abs(child[i].y - source.y);\n                //h  = Math.min(dx, dy) + MATH_SQRT_2 * Math.abs(dx - dy);\n                dx = child[i].x - target.x;\n                dy = child[i].y - target.y;\n                h = (float) Math.sqrt(dx * dx + dy * dy);\n                float score = total + minCost * h;\n                //float score = total + minCost * heuristic(current, child[i]);\n                child[i].parent = current;\n                child[i].total = total;\n                child[i].score = score;\n                if ((child[i].state & Node.CLOSED) > 0) {\n                    child[i].state ^= Node.CLOSED;\n                }\n                if ((child[i].state & Node.OPEN) == 0) {\n                    int l = 0;\n                    int r = n - 1;\n                    int m = 0;\n                    int t = 0;\n                    // search the open array for a place to insert new\n                    // node. the array is ordered in reverse natural order.\n                    while (l <= r) {\n                        m = (l + r) / 2;\n                        t = child[i].score < open[m].score ? 1 : (child[i].score > open[m].score ? -1 : 0);\n                        if (t < 0) {\n                            r = m - 1;\n                        } else if (t > 0) {\n                            l = m + 1;\n                        } else {\n                            break;\n                        }\n                    }\n                    m = m < 0 ? 0 : m;\n                    // if the buffer is full allocate space for some\n                    // more nodes. make it twice as large as it was.\n                    if (n > open.length - 2) {\n                        DirtyNode[] temp = open;\n                        open = new DirtyNode[temp.length << 1];\n                        System.arraycopy(temp, 0, open, 0, temp.length);\n                    }\n                    System.arraycopy(open, m, open, m + 1, n - m);\n                    child[i].state ^= Node.OPEN;\n                    open[m] = child[i];\n                    n = n + 1;\n                }\n            }\n            current.state ^= Node.CLOSED;\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", t=\" + target);\n    }\n\n    /**\n     * Search for the path connecting the source node with the target node.\n     * This algorithm does not take into account the cost of accessing each\n     * node, only the estimated remaining distance to target is considered.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path bestFirstSearch(Node source, Node target) throws PathNotFoundException {\n        Vector open = new Vector();\n        reset();\n        source.setScore(0.0f);\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(0);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // skip nodes that are currently being processed and\n                // which have a lower total cost from source.\n                if (child[i].isOpen() || child[i].isClosed()) {\n                    continue;\n                }\n                // estimate the remaining distance to target.\n                float score = minCost * heuristic(child[i], target);\n                child[i].setParent(current);\n                child[i].setScore(score);\n                int j = java.util.Collections.binarySearch(open, child[i]);\n                if (j < 0) {\n                    j = -j > open.size() ? open.size() : -j;\n                    open.insertElementAt(child[i], j);\n                    child[i].setOpen(true);\n                    child[i].setClosed(false);\n                }\n            }\n            current.setClosed(true);\n            current.setOpen(false);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * Search for the shortest path connecting the source node with\n     * the target node. This algorithm is guaranteed to find the\n     * optimal shortest path, if it exist.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path dijkstraSearch(Node source, Node target) throws PathNotFoundException {\n        Vector open = new Vector();\n        reset();\n        source.setTotal(0.0f);\n        source.setScore(0.0f);\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(0);\n            current.setOpen(false);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // calculate the accumulated total cost of moving\n                // from source to this child.\n                float total = current.getTotal() + cost(current, child[i]);\n                // skip nodes that are currently being processed and\n                // which have a lower total cost from source.\n                if (child[i].isOpen() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // skip nodes that have already been processed and\n                // which have a lower total cost from source.\n                if (child[i].isClosed() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // a new shorter path to this child was found. update\n                // the node and add it to the list of open nodes if\n                // it isn't already open.\n                child[i].setParent(current);\n                child[i].setTotal(total);\n                child[i].setScore(total);\n                if (child[i].isClosed()) {\n                    child[i].setClosed(false);\n                }\n                if (!child[i].isOpen()) {\n                    open.add(child[i]);\n                    child[i].setOpen(true);\n                }\n            }\n            current.setClosed(true);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * Search for the path connecting the source node with the target node.\n     * This algorithm does not take into account the cost of accessing each\n     * node.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path breadthFirstSearch(Node source, Node target) throws PathNotFoundException {\n        Vector open = new Vector();\n        reset();\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(0);\n            current.setOpen(false);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // skip nodes that are currently being processed and\n                // nodes that have already been processed.\n                if (child[i].isOpen() || child[i].isClosed()) {\n                    continue;\n                }\n                child[i].setParent(current);\n                if (!child[i].isOpen()) {\n                    child[i].setOpen(true);\n                    open.add(child[i]);\n                }\n            }\n            current.setClosed(true);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * Search for the path connecting the source node with the target node.\n     * This algorithm does not take into account the cost of accessing each\n     * node.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path depthFirstSearch(Node source, Node target) throws PathNotFoundException {\n        Vector open = new Vector();\n        reset();\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(open.size() - 1);\n            current.setOpen(false);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // skip nodes that are currently being processed and\n                // nodes that have already been processed.\n                if (child[i].isOpen() || child[i].isClosed()) {\n                    continue;\n                }\n                child[i].setParent(current);\n                if (!child[i].isOpen()) {\n                    open.add(child[i]);\n                    child[i].setOpen(true);\n                }\n            }\n            current.setClosed(true);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * The associated heuristic function for this map. Estimates\n     * the remaining distance from node a to node b.\n     *\n     * @param a The first node.\n     * @param b The second node.\n     */\n    protected abstract float heuristic(Node a, Node b);\n\n    /**\n     * Determines the actual cost of crossing the edge between\n     * the given adjectant nodes. If the nodes are not adjectant\n     * the returned cost is unspecified.\n     *\n     * @param source The source node.\n     * @param target The target node.\n     */\n    protected abstract float cost(Node source, Node target);\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/map/AbstractMapTest4.java",
		"test_prompt": "// AbstractMapTest4.java\npackage map;\n\nimport java.util.Vector;\nimport java.util.PriorityQueue;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractMap}.\n* It contains ten unit test cases for the {@link AbstractMap#dijkstraSearch(Node, Node)} method.\n*/\nclass AbstractMapTest4 {"
	},
	{
		"original_code": "// AbstractMap.java\n/* AbstractMap.java v0.1 (06/17/2002)\n *\n * Copyright (C) 2002, Joel Andersson <bja@kth.se>\n * \n * This software is hereby expressly placed in the public domain.\n * Share and enjoy.\n */\npackage map;\n\nimport java.util.Vector;\nimport java.util.PriorityQueue;\n\n//import bja.util.PriorityQueue;\npublic abstract class AbstractMap implements Map {\n\n    /**\n     * The square root of 2.0f.\n     */\n    protected static final float MATH_SQRT_2 = 1.41421356f;\n\n    /**\n     * The minimum cost associated with accessing a node in this map.\n     */\n    protected static float minCost;\n\n    /**\n     * The maximum cost associated with accessing a node in this map.\n     */\n    protected static float maxCost;\n\n    /**\n     * Creates a new instance of this class.\n     */\n    protected AbstractMap() {\n        minCost = 0.1f;\n        maxCost = 1.0f;\n    }\n\n    /**\n     * Creates a new instance of this class with the specified\n     * attributes.\n     *\n     * @param min the minimum cost of accessing a node.\n     * @param max the maximum cost of accessing a node.\n     */\n    protected AbstractMap(float min, float max) {\n        minCost = min;\n        maxCost = max;\n    }\n\n    /**\n     * Search for the shortest path connecting the source node with\n     * the target node. This algorithm is guaranteed to find the\n     * optimal shortest path, if it exist, provided that the heuristic\n     * function is admissible.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path aStarSearch(Node source, Node target) throws PathNotFoundException {\n        PriorityQueue open = new PriorityQueue();\n        reset();\n        source.setTotal(0.0f);\n        source.setScore(minCost * heuristic(source, target));\n        open.add(source);\n        while (open.size() != 0) {\n            Node current = (Node) open.poll();\n            current.setOpen(false);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // calculate the accumulated total cost of moving\n                // from the source to this child.\n                float total = current.getTotal() + cost(current, child[i]);\n                // skip nodes that are currently being processed and\n                // which have a lower total cost from the source.\n                if (child[i].isOpen() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // skip nodes that have already been processed and\n                // which have a lower total cost from the source.\n                if (child[i].isClosed() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // a new shorter path to this child was found. update\n                // the node and add it to the list of open nodes if\n                // it isn't already open.\n                float score = total + minCost * heuristic(child[i], target);\n                child[i].setParent(current);\n                child[i].setTotal(total);\n                child[i].setScore(score);\n                if (child[i].isClosed()) {\n                    child[i].setClosed(false);\n                }\n                if (!child[i].isOpen()) {\n                    open.add(child[i]);\n                    child[i].setOpen(true);\n                }\n            }\n            current.setClosed(true);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * Search for the shortest path connecting the source node with\n     * the target node. This algorithm is guaranteed to find the\n     * optimal shortest path, if it exist, provided that the heuristic\n     * function is admissible.\n     *\n     * This is a slightly faster implementation of the A* algorithm than\n     * the above using a sorted array to store the open nodes instead of\n     * a PriorityQueue.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path aStarSearch2(Node source, Node target) throws PathNotFoundException {\n        int n = 0;\n        Node[] open = new Node[16];\n        reset();\n        source.setTotal(0.0f);\n        source.setScore(minCost * heuristic(source, target));\n        open[n++] = source;\n        while (n > 0) {\n            Node current = open[--n];\n            current.setOpen(false);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // calculate the accumulated total cost of moving\n                // from source to this child.\n                float total = current.getTotal() + cost(current, child[i]);\n                // skip nodes that are currently being processed and\n                // which have a lower total cost from source.\n                if (child[i].isOpen() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // skip nodes that have already been processed and\n                // which have a lower total cost from source.\n                if (child[i].isClosed() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // a new shorter path to this child was found. update\n                // the node and add it to the list of open nodes if\n                // it isn't already open.\n                float score = total + minCost * heuristic(child[i], target);\n                child[i].setParent(current);\n                child[i].setTotal(total);\n                child[i].setScore(score);\n                if (child[i].isClosed()) {\n                    child[i].setClosed(false);\n                }\n                if (!child[i].isOpen()) {\n                    int l = 0;\n                    int r = n - 1;\n                    int m = 0;\n                    int t = 0;\n                    // search for place to insert new node.\n                    while (l <= r) {\n                        m = (l + r) / 2;\n                        t = -child[i].compareTo(open[m]);\n                        if (t < 0) {\n                            r = m - 1;\n                        } else if (t > 0) {\n                            l = m + 1;\n                        } else {\n                            break;\n                        }\n                    }\n                    m = m < 0 ? 0 : m;\n                    // if the buffer is full allocate space for some\n                    // more nodes. make it twice as large as it was.\n                    if (n > open.length - 2) {\n                        Node[] temp = open;\n                        open = new Node[temp.length << 1];\n                        System.arraycopy(temp, 0, open, 0, temp.length);\n                    }\n                    System.arraycopy(open, m, open, m + 1, n - m);\n                    child[i].setOpen(true);\n                    open[m] = child[i];\n                    n = n + 1;\n                }\n            }\n            current.setClosed(true);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * Search for the shortest path connecting the source node with\n     * the target node. This algorithm is guaranteed to find the\n     * optimal shortest path, if it exist, provided that the heuristic\n     * function is admissible.\n     *\n     * This is a slightly faster implementation of the A* algorithm than\n     * the above using a sorted array to store the open nodes instead of\n     * a PriorityQueue and using DirtyNodes instead of the DefaultNodes.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public Path aStarSearch3(DirtyNode source, DirtyNode target) throws PathNotFoundException {\n        DirtyNode[] open = new DirtyNode[32];\n        int n = 0;\n        reset();\n        //float dx = Math.abs(target.x - source.x);\n        //float dy = Math.abs(target.y - source.y);\n        //float h  = Math.min(dx, dy) + MATH_SQRT_2 * Math.abs(dx - dy);\n        float dx = target.x - source.x;\n        float dy = target.y - source.y;\n        float h = (float) Math.sqrt(dx * dx + dy * dy);\n        source.total = 0.0f;\n        source.score = minCost * h;\n        //source.score = minCost * heuristic(source, target);\n        open[n++] = source;\n        while (n > 0) {\n            DirtyNode current = open[--n];\n            current.state ^= Node.OPEN;\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            DirtyNode[] child = current.children;\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].cost >= maxCost) {\n                    continue;\n                }\n                // calculate the accumulated total cost of moving\n                // from source to this child.\n                float weight = (i % 2 == 0) ? 1 : MATH_SQRT_2;\n                float total = current.total + weight * child[i].cost;\n                //float total = current.total + cost(current, child[i]);\n                // skip nodes that are currently being processed and\n                // which have a lower total cost from source.\n                if ((child[i].state & Node.OPEN) > 0 && child[i].total <= total) {\n                    continue;\n                }\n                // skip nodes that have already been processed and\n                // which have a lower total cost from source.\n                if ((child[i].state & Node.CLOSED) > 0 && child[i].total <= total) {\n                    continue;\n                }\n                // a new shorter path to this child was found. update\n                // the node and add it to the list of open nodes if\n                // it isn't already open.\n                //dx = Math.abs(child[i].x - source.x);\n                //dy = Math.abs(child[i].y - source.y);\n                //h  = Math.min(dx, dy) + MATH_SQRT_2 * Math.abs(dx - dy);\n                dx = child[i].x - target.x;\n                dy = child[i].y - target.y;\n                h = (float) Math.sqrt(dx * dx + dy * dy);\n                float score = total + minCost * h;\n                //float score = total + minCost * heuristic(current, child[i]);\n                child[i].parent = current;\n                child[i].total = total;\n                child[i].score = score;\n                if ((child[i].state & Node.CLOSED) > 0) {\n                    child[i].state ^= Node.CLOSED;\n                }\n                if ((child[i].state & Node.OPEN) == 0) {\n                    int l = 0;\n                    int r = n - 1;\n                    int m = 0;\n                    int t = 0;\n                    // search the open array for a place to insert new\n                    // node. the array is ordered in reverse natural order.\n                    while (l <= r) {\n                        m = (l + r) / 2;\n                        t = child[i].score < open[m].score ? 1 : (child[i].score > open[m].score ? -1 : 0);\n                        if (t < 0) {\n                            r = m - 1;\n                        } else if (t > 0) {\n                            l = m + 1;\n                        } else {\n                            break;\n                        }\n                    }\n                    m = m < 0 ? 0 : m;\n                    // if the buffer is full allocate space for some\n                    // more nodes. make it twice as large as it was.\n                    if (n > open.length - 2) {\n                        DirtyNode[] temp = open;\n                        open = new DirtyNode[temp.length << 1];\n                        System.arraycopy(temp, 0, open, 0, temp.length);\n                    }\n                    System.arraycopy(open, m, open, m + 1, n - m);\n                    child[i].state ^= Node.OPEN;\n                    open[m] = child[i];\n                    n = n + 1;\n                }\n            }\n            current.state ^= Node.CLOSED;\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", t=\" + target);\n    }\n\n    /**\n     * Search for the path connecting the source node with the target node.\n     * This algorithm does not take into account the cost of accessing each\n     * node, only the estimated remaining distance to target is considered.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path bestFirstSearch(Node source, Node target) throws PathNotFoundException {\n        Vector open = new Vector();\n        reset();\n        source.setScore(0.0f);\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(0);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // skip nodes that are currently being processed and\n                // which have a lower total cost from source.\n                if (child[i].isOpen() || child[i].isClosed()) {\n                    continue;\n                }\n                // estimate the remaining distance to target.\n                float score = minCost * heuristic(child[i], target);\n                child[i].setParent(current);\n                child[i].setScore(score);\n                int j = java.util.Collections.binarySearch(open, child[i]);\n                if (j < 0) {\n                    j = -j > open.size() ? open.size() : -j;\n                    open.insertElementAt(child[i], j);\n                    child[i].setOpen(true);\n                    child[i].setClosed(false);\n                }\n            }\n            current.setClosed(true);\n            current.setOpen(false);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * Search for the shortest path connecting the source node with\n     * the target node. This algorithm is guaranteed to find the\n     * optimal shortest path, if it exist.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path dijkstraSearch(Node source, Node target) throws PathNotFoundException {\n        Vector open = new Vector();\n        reset();\n        source.setTotal(0.0f);\n        source.setScore(0.0f);\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(0);\n            current.setOpen(false);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // calculate the accumulated total cost of moving\n                // from source to this child.\n                float total = current.getTotal() + cost(current, child[i]);\n                // skip nodes that are currently being processed and\n                // which have a lower total cost from source.\n                if (child[i].isOpen() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // skip nodes that have already been processed and\n                // which have a lower total cost from source.\n                if (child[i].isClosed() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // a new shorter path to this child was found. update\n                // the node and add it to the list of open nodes if\n                // it isn't already open.\n                child[i].setParent(current);\n                child[i].setTotal(total);\n                child[i].setScore(total);\n                if (child[i].isClosed()) {\n                    child[i].setClosed(false);\n                }\n                if (!child[i].isOpen()) {\n                    open.add(child[i]);\n                    child[i].setOpen(true);\n                }\n            }\n            current.setClosed(true);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * Search for the path connecting the source node with the target node.\n     * This algorithm does not take into account the cost of accessing each\n     * node.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path breadthFirstSearch(Node source, Node target) throws PathNotFoundException {\n        Vector open = new Vector();\n        reset();\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(0);\n            current.setOpen(false);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // skip nodes that are currently being processed and\n                // nodes that have already been processed.\n                if (child[i].isOpen() || child[i].isClosed()) {\n                    continue;\n                }\n                child[i].setParent(current);\n                if (!child[i].isOpen()) {\n                    child[i].setOpen(true);\n                    open.add(child[i]);\n                }\n            }\n            current.setClosed(true);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * Search for the path connecting the source node with the target node.\n     * This algorithm does not take into account the cost of accessing each\n     * node.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path depthFirstSearch(Node source, Node target) throws PathNotFoundException {\n        Vector open = new Vector();\n        reset();\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(open.size() - 1);\n            current.setOpen(false);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // skip nodes that are currently being processed and\n                // nodes that have already been processed.\n                if (child[i].isOpen() || child[i].isClosed()) {\n                    continue;\n                }\n                child[i].setParent(current);\n                if (!child[i].isOpen()) {\n                    open.add(child[i]);\n                    child[i].setOpen(true);\n                }\n            }\n            current.setClosed(true);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * The associated heuristic function for this map. Estimates\n     * the remaining distance from node a to node b.\n     *\n     * @param a The first node.\n     * @param b The second node.\n     */\n    protected abstract float heuristic(Node a, Node b);\n\n    /**\n     * Determines the actual cost of crossing the edge between\n     * the given adjectant nodes. If the nodes are not adjectant\n     * the returned cost is unspecified.\n     *\n     * @param source The source node.\n     * @param target The target node.\n     */\n    protected abstract float cost(Node source, Node target);\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/map/AbstractMapTest5.java",
		"test_prompt": "// AbstractMapTest5.java\npackage map;\n\nimport java.util.Vector;\nimport java.util.PriorityQueue;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractMap}.\n* It contains ten unit test cases for the {@link AbstractMap#breadthFirstSearch(Node, Node)} method.\n*/\nclass AbstractMapTest5 {"
	},
	{
		"original_code": "// AbstractMap.java\n/* AbstractMap.java v0.1 (06/17/2002)\n *\n * Copyright (C) 2002, Joel Andersson <bja@kth.se>\n * \n * This software is hereby expressly placed in the public domain.\n * Share and enjoy.\n */\npackage map;\n\nimport java.util.Vector;\nimport java.util.PriorityQueue;\n\n//import bja.util.PriorityQueue;\npublic abstract class AbstractMap implements Map {\n\n    /**\n     * The square root of 2.0f.\n     */\n    protected static final float MATH_SQRT_2 = 1.41421356f;\n\n    /**\n     * The minimum cost associated with accessing a node in this map.\n     */\n    protected static float minCost;\n\n    /**\n     * The maximum cost associated with accessing a node in this map.\n     */\n    protected static float maxCost;\n\n    /**\n     * Creates a new instance of this class.\n     */\n    protected AbstractMap() {\n        minCost = 0.1f;\n        maxCost = 1.0f;\n    }\n\n    /**\n     * Creates a new instance of this class with the specified\n     * attributes.\n     *\n     * @param min the minimum cost of accessing a node.\n     * @param max the maximum cost of accessing a node.\n     */\n    protected AbstractMap(float min, float max) {\n        minCost = min;\n        maxCost = max;\n    }\n\n    /**\n     * Search for the shortest path connecting the source node with\n     * the target node. This algorithm is guaranteed to find the\n     * optimal shortest path, if it exist, provided that the heuristic\n     * function is admissible.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path aStarSearch(Node source, Node target) throws PathNotFoundException {\n        PriorityQueue open = new PriorityQueue();\n        reset();\n        source.setTotal(0.0f);\n        source.setScore(minCost * heuristic(source, target));\n        open.add(source);\n        while (open.size() != 0) {\n            Node current = (Node) open.poll();\n            current.setOpen(false);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // calculate the accumulated total cost of moving\n                // from the source to this child.\n                float total = current.getTotal() + cost(current, child[i]);\n                // skip nodes that are currently being processed and\n                // which have a lower total cost from the source.\n                if (child[i].isOpen() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // skip nodes that have already been processed and\n                // which have a lower total cost from the source.\n                if (child[i].isClosed() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // a new shorter path to this child was found. update\n                // the node and add it to the list of open nodes if\n                // it isn't already open.\n                float score = total + minCost * heuristic(child[i], target);\n                child[i].setParent(current);\n                child[i].setTotal(total);\n                child[i].setScore(score);\n                if (child[i].isClosed()) {\n                    child[i].setClosed(false);\n                }\n                if (!child[i].isOpen()) {\n                    open.add(child[i]);\n                    child[i].setOpen(true);\n                }\n            }\n            current.setClosed(true);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * Search for the shortest path connecting the source node with\n     * the target node. This algorithm is guaranteed to find the\n     * optimal shortest path, if it exist, provided that the heuristic\n     * function is admissible.\n     *\n     * This is a slightly faster implementation of the A* algorithm than\n     * the above using a sorted array to store the open nodes instead of\n     * a PriorityQueue.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path aStarSearch2(Node source, Node target) throws PathNotFoundException {\n        int n = 0;\n        Node[] open = new Node[16];\n        reset();\n        source.setTotal(0.0f);\n        source.setScore(minCost * heuristic(source, target));\n        open[n++] = source;\n        while (n > 0) {\n            Node current = open[--n];\n            current.setOpen(false);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // calculate the accumulated total cost of moving\n                // from source to this child.\n                float total = current.getTotal() + cost(current, child[i]);\n                // skip nodes that are currently being processed and\n                // which have a lower total cost from source.\n                if (child[i].isOpen() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // skip nodes that have already been processed and\n                // which have a lower total cost from source.\n                if (child[i].isClosed() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // a new shorter path to this child was found. update\n                // the node and add it to the list of open nodes if\n                // it isn't already open.\n                float score = total + minCost * heuristic(child[i], target);\n                child[i].setParent(current);\n                child[i].setTotal(total);\n                child[i].setScore(score);\n                if (child[i].isClosed()) {\n                    child[i].setClosed(false);\n                }\n                if (!child[i].isOpen()) {\n                    int l = 0;\n                    int r = n - 1;\n                    int m = 0;\n                    int t = 0;\n                    // search for place to insert new node.\n                    while (l <= r) {\n                        m = (l + r) / 2;\n                        t = -child[i].compareTo(open[m]);\n                        if (t < 0) {\n                            r = m - 1;\n                        } else if (t > 0) {\n                            l = m + 1;\n                        } else {\n                            break;\n                        }\n                    }\n                    m = m < 0 ? 0 : m;\n                    // if the buffer is full allocate space for some\n                    // more nodes. make it twice as large as it was.\n                    if (n > open.length - 2) {\n                        Node[] temp = open;\n                        open = new Node[temp.length << 1];\n                        System.arraycopy(temp, 0, open, 0, temp.length);\n                    }\n                    System.arraycopy(open, m, open, m + 1, n - m);\n                    child[i].setOpen(true);\n                    open[m] = child[i];\n                    n = n + 1;\n                }\n            }\n            current.setClosed(true);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * Search for the shortest path connecting the source node with\n     * the target node. This algorithm is guaranteed to find the\n     * optimal shortest path, if it exist, provided that the heuristic\n     * function is admissible.\n     *\n     * This is a slightly faster implementation of the A* algorithm than\n     * the above using a sorted array to store the open nodes instead of\n     * a PriorityQueue and using DirtyNodes instead of the DefaultNodes.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public Path aStarSearch3(DirtyNode source, DirtyNode target) throws PathNotFoundException {\n        DirtyNode[] open = new DirtyNode[32];\n        int n = 0;\n        reset();\n        //float dx = Math.abs(target.x - source.x);\n        //float dy = Math.abs(target.y - source.y);\n        //float h  = Math.min(dx, dy) + MATH_SQRT_2 * Math.abs(dx - dy);\n        float dx = target.x - source.x;\n        float dy = target.y - source.y;\n        float h = (float) Math.sqrt(dx * dx + dy * dy);\n        source.total = 0.0f;\n        source.score = minCost * h;\n        //source.score = minCost * heuristic(source, target);\n        open[n++] = source;\n        while (n > 0) {\n            DirtyNode current = open[--n];\n            current.state ^= Node.OPEN;\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            DirtyNode[] child = current.children;\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].cost >= maxCost) {\n                    continue;\n                }\n                // calculate the accumulated total cost of moving\n                // from source to this child.\n                float weight = (i % 2 == 0) ? 1 : MATH_SQRT_2;\n                float total = current.total + weight * child[i].cost;\n                //float total = current.total + cost(current, child[i]);\n                // skip nodes that are currently being processed and\n                // which have a lower total cost from source.\n                if ((child[i].state & Node.OPEN) > 0 && child[i].total <= total) {\n                    continue;\n                }\n                // skip nodes that have already been processed and\n                // which have a lower total cost from source.\n                if ((child[i].state & Node.CLOSED) > 0 && child[i].total <= total) {\n                    continue;\n                }\n                // a new shorter path to this child was found. update\n                // the node and add it to the list of open nodes if\n                // it isn't already open.\n                //dx = Math.abs(child[i].x - source.x);\n                //dy = Math.abs(child[i].y - source.y);\n                //h  = Math.min(dx, dy) + MATH_SQRT_2 * Math.abs(dx - dy);\n                dx = child[i].x - target.x;\n                dy = child[i].y - target.y;\n                h = (float) Math.sqrt(dx * dx + dy * dy);\n                float score = total + minCost * h;\n                //float score = total + minCost * heuristic(current, child[i]);\n                child[i].parent = current;\n                child[i].total = total;\n                child[i].score = score;\n                if ((child[i].state & Node.CLOSED) > 0) {\n                    child[i].state ^= Node.CLOSED;\n                }\n                if ((child[i].state & Node.OPEN) == 0) {\n                    int l = 0;\n                    int r = n - 1;\n                    int m = 0;\n                    int t = 0;\n                    // search the open array for a place to insert new\n                    // node. the array is ordered in reverse natural order.\n                    while (l <= r) {\n                        m = (l + r) / 2;\n                        t = child[i].score < open[m].score ? 1 : (child[i].score > open[m].score ? -1 : 0);\n                        if (t < 0) {\n                            r = m - 1;\n                        } else if (t > 0) {\n                            l = m + 1;\n                        } else {\n                            break;\n                        }\n                    }\n                    m = m < 0 ? 0 : m;\n                    // if the buffer is full allocate space for some\n                    // more nodes. make it twice as large as it was.\n                    if (n > open.length - 2) {\n                        DirtyNode[] temp = open;\n                        open = new DirtyNode[temp.length << 1];\n                        System.arraycopy(temp, 0, open, 0, temp.length);\n                    }\n                    System.arraycopy(open, m, open, m + 1, n - m);\n                    child[i].state ^= Node.OPEN;\n                    open[m] = child[i];\n                    n = n + 1;\n                }\n            }\n            current.state ^= Node.CLOSED;\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", t=\" + target);\n    }\n\n    /**\n     * Search for the path connecting the source node with the target node.\n     * This algorithm does not take into account the cost of accessing each\n     * node, only the estimated remaining distance to target is considered.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path bestFirstSearch(Node source, Node target) throws PathNotFoundException {\n        Vector open = new Vector();\n        reset();\n        source.setScore(0.0f);\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(0);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // skip nodes that are currently being processed and\n                // which have a lower total cost from source.\n                if (child[i].isOpen() || child[i].isClosed()) {\n                    continue;\n                }\n                // estimate the remaining distance to target.\n                float score = minCost * heuristic(child[i], target);\n                child[i].setParent(current);\n                child[i].setScore(score);\n                int j = java.util.Collections.binarySearch(open, child[i]);\n                if (j < 0) {\n                    j = -j > open.size() ? open.size() : -j;\n                    open.insertElementAt(child[i], j);\n                    child[i].setOpen(true);\n                    child[i].setClosed(false);\n                }\n            }\n            current.setClosed(true);\n            current.setOpen(false);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * Search for the shortest path connecting the source node with\n     * the target node. This algorithm is guaranteed to find the\n     * optimal shortest path, if it exist.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path dijkstraSearch(Node source, Node target) throws PathNotFoundException {\n        Vector open = new Vector();\n        reset();\n        source.setTotal(0.0f);\n        source.setScore(0.0f);\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(0);\n            current.setOpen(false);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // calculate the accumulated total cost of moving\n                // from source to this child.\n                float total = current.getTotal() + cost(current, child[i]);\n                // skip nodes that are currently being processed and\n                // which have a lower total cost from source.\n                if (child[i].isOpen() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // skip nodes that have already been processed and\n                // which have a lower total cost from source.\n                if (child[i].isClosed() && child[i].getTotal() <= total) {\n                    continue;\n                }\n                // a new shorter path to this child was found. update\n                // the node and add it to the list of open nodes if\n                // it isn't already open.\n                child[i].setParent(current);\n                child[i].setTotal(total);\n                child[i].setScore(total);\n                if (child[i].isClosed()) {\n                    child[i].setClosed(false);\n                }\n                if (!child[i].isOpen()) {\n                    open.add(child[i]);\n                    child[i].setOpen(true);\n                }\n            }\n            current.setClosed(true);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * Search for the path connecting the source node with the target node.\n     * This algorithm does not take into account the cost of accessing each\n     * node.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path breadthFirstSearch(Node source, Node target) throws PathNotFoundException {\n        Vector open = new Vector();\n        reset();\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(0);\n            current.setOpen(false);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // skip nodes that are currently being processed and\n                // nodes that have already been processed.\n                if (child[i].isOpen() || child[i].isClosed()) {\n                    continue;\n                }\n                child[i].setParent(current);\n                if (!child[i].isOpen()) {\n                    child[i].setOpen(true);\n                    open.add(child[i]);\n                }\n            }\n            current.setClosed(true);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * Search for the path connecting the source node with the target node.\n     * This algorithm does not take into account the cost of accessing each\n     * node.\n     *\n     * @param source The node from which to start.\n     * @param target The node to which a path is to be found.\n     *\n     * @return A <code>Path</code> object representing the path between\n     *         between the source and destination nodes or <code>null/<code>\n     *         if no path was found.\n     *\n     * @throws NullPointerException if either source or target is null.\n     */\n    public final Path depthFirstSearch(Node source, Node target) throws PathNotFoundException {\n        Vector open = new Vector();\n        reset();\n        open.add(source);\n        while (!open.isEmpty()) {\n            Node current = (Node) open.remove(open.size() - 1);\n            current.setOpen(false);\n            if (current.equals(target)) {\n                return new DefaultPath(current);\n            }\n            Node[] child = current.getAllChildren();\n            for (int i = 0; i < child.length; i++) {\n                // ignore the edges on bad maps and nodes that\n                // cannot be entered.\n                if (child[i] == null || child[i].getCost() >= maxCost) {\n                    continue;\n                }\n                // skip nodes that are currently being processed and\n                // nodes that have already been processed.\n                if (child[i].isOpen() || child[i].isClosed()) {\n                    continue;\n                }\n                child[i].setParent(current);\n                if (!child[i].isOpen()) {\n                    open.add(child[i]);\n                    child[i].setOpen(true);\n                }\n            }\n            current.setClosed(true);\n        }\n        throw new PathNotFoundException(\"s=\" + source + \", f=\" + target);\n    }\n\n    /**\n     * The associated heuristic function for this map. Estimates\n     * the remaining distance from node a to node b.\n     *\n     * @param a The first node.\n     * @param b The second node.\n     */\n    protected abstract float heuristic(Node a, Node b);\n\n    /**\n     * Determines the actual cost of crossing the edge between\n     * the given adjectant nodes. If the nodes are not adjectant\n     * the returned cost is unspecified.\n     *\n     * @param source The source node.\n     * @param target The target node.\n     */\n    protected abstract float cost(Node source, Node target);\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/map/AbstractMapTest6.java",
		"test_prompt": "// AbstractMapTest6.java\npackage map;\n\nimport java.util.Vector;\nimport java.util.PriorityQueue;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AbstractMap}.\n* It contains ten unit test cases for the {@link AbstractMap#depthFirstSearch(Node, Node)} method.\n*/\nclass AbstractMapTest6 {"
	},
	{
		"original_code": "// Map.java\n/**\n * $Id: Map.java,v 1.7 2004/04/22 11:26:42 emill Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties.\n *\n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.7 $\n */\npackage gui;\n\nimport static java.lang.Math.max;\nimport static java.lang.Math.round;\nimport static java.lang.Math.sqrt;\nimport static java.lang.Math.pow;\nimport java.util.Comparator;\nimport java.util.Arrays;\nimport java.util.Hashtable;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.StreamTokenizer;\nimport java.io.IOException;\nimport java.awt.*;\nimport state.*;\n\n/**\n * The MapEdit implementation of Map. Some things may be altered to\n * work better with the WorldView in the GUI.\n */\npublic class Map {\n\n    private final static int WORLD_OFFSET_X = 672;\n\n    private final static int WORLD_OFFSET_Y = 32;\n\n    private final static int GRID_OFFSET_X = 14;\n\n    private final static int GRID_OFFSET_Y = -2;\n\n    static final int MAX_NUM_CELLS = 1000;\n\n    public final static int N_LAYERS = 4;\n\n    public final static int PLAYER_LAYER = 2;\n\n    MapCell[][] cell;\n\n    MapTile[] tileList;\n\n    int numOfTiles;\n\n    int[] numOfCells;\n\n    Hashtable<Player, MapCell> playercells = new Hashtable<Player, MapCell>();\n\n    /**\n     * Each tile represents one different kind of tile that can be placed\n     * on the map.\n     */\n    public static class MapTile {\n\n        public String name;\n\n        public Image image;\n\n        private static final Toolkit tk;\n\n        static {\n            tk = Toolkit.getDefaultToolkit();\n        }\n\n        public MapTile(String fileName) throws IOException {\n            name = fileName;\n            image = tk.getImage(fileName);\n        }\n    }\n\n    /**\n     * Each cell is the smallest part of the map.\n     */\n    public static class MapCell {\n\n        float x, y;\n\n        int tile, layer;\n\n        float depthvalue;\n\n        public MapCell(int x, int y, int tile, int layer) {\n            this((float) x, (float) y, tile, layer);\n        }\n\n        public MapCell(int x, int y, int tile) {\n            this(x, y, tile, 0);\n        }\n\n        public MapCell(float x, float y, int tile, int layer) {\n            this.x = x;\n            this.y = y;\n            this.tile = tile;\n            this.layer = layer;\n        }\n\n        public String toString() {\n            return String.format(\"MapCell[x=%f,y=%f,tile=%d,layer=%d]\", x, y, tile, layer);\n        }\n    }\n\n    public static class MapPlayerCell extends MapCell {\n\n        Player p;\n\n        public MapPlayerCell(Player p1) {\n            super(p1.getX(), p1.getY(), 8, PLAYER_LAYER);\n            p = p1;\n        }\n    }\n\n    /**\n     * Compares two MapCells and determine their order.\n     */\n    private class MapCellComparator implements Comparator<MapCell> {\n\n        // MapCellComparator() { /* ... */ }\n        public int compare(MapCell src, MapCell dst) {\n            return ((Float) depthvalue(src)).compareTo(depthvalue(dst));\n        }\n\n        /*if (src.y > src.x) {\n\t\tif (src.y > dst.y)\n\t\t    return 1;\n\t\tif (src.y < dst.y)\n\t\t    return -1;\n\t\treturn 0;\n\t    }\n\n\t    if (src.y < src.x) {\n\t\tif (src.x > dst.x)\n\t\t    return 1;\n\t\tif (src.x < dst.x)\n\t\t    return -1;\n\t\treturn 0;\n\t    }\n\t    \n\t    if (src.x+src.y > dst.x+dst.y)\n\t\treturn 1;\n\t    if (src.x+src.y < dst.x+dst.y)\n\t\treturn -1;\n\t\treturn 0;\n\t}*/\n        private float depthvalue(MapCell c) {\n            return (1000 * (float) c.x + 1001 * (float) c.y) / 1000 * 32;\n        }\n\n        public boolean equals(Object obj) {\n            return obj == this;\n        }\n    }\n\n    /**\n     * Creates a new instance of the Map class.\n     * @param fileName the name of the map to open.\n     */\n    public Map(String fileName) throws IOException {\n        open(fileName);\n    }\n\n    /**\n     * Open the specified map fileName.\n     * @param fileName the name of the file to open.\n     */\n    public Map open(String fileName) throws IOException {\n        //System.err.println(\"Map.open()\");\n        BufferedReader in = new BufferedReader(new FileReader(fileName));\n        StreamTokenizer st = new StreamTokenizer(in);\n        int j = 0, i = 0;\n        int[] tmp = new int[4];\n        //numOfCells = Integer.parseInt(in.readLine());\n        numOfCells = new int[N_LAYERS];\n        int readNumOfTiles = Integer.parseInt(in.readLine());\n        numOfTiles = Integer.parseInt(in.readLine());\n        cell = new MapCell[N_LAYERS][];\n        for (i = 0; i < N_LAYERS; i++) {\n            cell[i] = new MapCell[MAX_NUM_CELLS];\n        }\n        tileList = new MapTile[numOfTiles];\n        for (i = 0; i < numOfTiles; i++) {\n            tileList[i] = new MapTile(in.readLine());\n        }\n        j = 0;\n        int[] c = new int[N_LAYERS];\n        while (st.nextToken() != st.TT_EOF) {\n            if (j > 3) {\n                numOfCells[tmp[3]]++;\n                cell[tmp[3]][c[tmp[3]]++] = new MapCell(tmp[0], tmp[1], tmp[2], tmp[3]);\n                j = 0;\n            }\n            tmp[j++] = (int) st.nval;\n        }\n        if (j == 4) {\n            numOfCells[tmp[3]]++;\n            cell[tmp[3]][c[tmp[3]]++] = new MapCell(tmp[0], tmp[1], tmp[2], tmp[3]);\n            // System.err.println(\"Map.open(): Missing end of line!\");\n        }\n        //if ( != numOfCells) {\n        //    System.err.println(\"Map.open(): Unable to open file!\");\n        //}\n        in.close();\n        try {\n            MediaTracker tracker = new MediaTracker(new Frame());\n            for (MapTile t : tileList) {\n                tracker.addImage(t.image, 0);\n            }\n            //System.err.println(\"Map.open(): waiting for images!\");\n            tracker.waitForAll();\n        } catch (InterruptedException e) {\n            e.printStackTrace(System.err);\n        }\n        return this;\n    }\n\n    /**\n     * Lookup and return the MapCell at the specified x and y coordinates.\n     * Returns null if no MapCell is found. This method does a linear\n     * search through all the cells. This is considered a bug!\n     *\n     * @param x the x-coordinate of the MapCell.\n     * @param y the y-coordinate of the MapCell.\n     * @return The MapCell at the coordinates, or null if not exists.\n     */\n    public MapCell lookup(int x, int y) {\n        for (int i = numOfCells[PLAYER_LAYER] - 1; i >= 0; --i) {\n            if (round(cell[PLAYER_LAYER][i].x) == x && round(cell[PLAYER_LAYER][i].y) == y) {\n                return cell[PLAYER_LAYER][i];\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Converts the input coordinats in screen space to their respective\n     * coordinates in world space.\n     *\n     * @param x\n     * @param y\n     * @param z\n     */\n    public static Point pixelTransform(int x, int y, int z) {\n        return new Point(x + 2 * (y + z), y - (x + z) / 2);\n    }\n\n    /**\n     * Converts the input coordinats in world space to their respective\n     * coordinates in screen space.\n     *\n     * @param x\n     * @param y\n     * @param z\n     */\n    public static Point worldTransform(float x, float y) {\n        //return new Point( (int) ((x - z) / 2 - z - y),\n        //\t\t  (int) ((x + 2 * (y - z) + z) / 4));\n        x += GRID_OFFSET_X;\n        y += GRID_OFFSET_Y;\n        return new Point((int) (16 * (x - y)), (int) (8 * (y + x)));\n    }\n\n    /**\n     * Converts the input coordinats in world space to their respective\n     * coordinates in defined grid.\n     *\n     * @param x\n     * @param y\n     * @param z\n     */\n    public static Point gridTransform(int x, int y) {\n        /*int j = x - WORLD_OFFSET_X + GRID_OFFSET_X;\n\tint i = y + WORLD_OFFSET_Y + GRID_OFFSET_Y;\n\n\tj = (int) (j < 0 ? j / 32 - 0.5 : j / 32 + 1.5);\n\ti = (int) (i < 0 ? i / 16 - 0.5 : i / 16 + 1.5);\n\n\treturn new Point(j, i);*/\n        return new Point(round((float) x / 32 + (float) y / 16) - GRID_OFFSET_X, round((float) y / 16 - (float) x / 32) - GRID_OFFSET_Y);\n    }\n\n    public MapCell addPlayerCell(Player p) {\n        MapCell c = new MapPlayerCell(p);\n        cell[PLAYER_LAYER][numOfCells[PLAYER_LAYER]++] = c;\n        sortCells(PLAYER_LAYER);\n        playercells.put(p, c);\n        return c;\n    }\n\n    public void updatePlayerCell(Player p) {\n        if (p.isDead()) {\n            MapCell m = playercells.get(p);\n            m.tile = 39;\n        } else {\n            MapCell m = playercells.get(p);\n            m.x = p.getX();\n            m.y = p.getY();\n        }\n    }\n\n    public void sortCells(int layer) {\n        //System.err.print(\"Sorting... \");\n        Arrays.sort(cell[layer], 0, numOfCells[layer], new MapCellComparator());\n        //System.err.println(\"done!\");\n    }\n\n    /**\n     * Paints a layer of this map on a Graphics object.\n     */\n    public void draw(Graphics2D g, int layer) {\n        int i, z, w, h;\n        float x, y;\n        MapTile t;\n        Point p;\n        i = 0;\n        try {\n            for (i = 0; i < numOfCells[layer]; i++) {\n                x = cell[layer][i].x;\n                y = cell[layer][i].y;\n                z = cell[layer][i].tile;\n                /* check whether this cell should be drawn */\n                if (z != -1) {\n                    t = tileList[z];\n                    w = t.image.getWidth(null);\n                    h = t.image.getHeight(null);\n                    //p = worldTransform(x*32 + WORLD_OFFSET_X - 8 - w/2,\n                    //\t       y*16 - WORLD_OFFSET_Y - 4 + w/4, 74);\n                    p = worldTransform(x, y);\n                    g.drawImage(t.image, p.x - w / 2, p.y - h, null);\n                }\n            }\n        } catch (Exception e) {\n            System.err.printf(\"MapGrid.paint(): i=%d l=%d\\n\", i, cell.length);\n            e.printStackTrace(System.err);\n        }\n    }\n\n    public String toString() {\n        return \"Map[]\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/gui/MapTest0.java",
		"test_prompt": "// MapTest0.java\npackage gui;\n\nimport static java.lang.Math.max;\nimport static java.lang.Math.round;\nimport static java.lang.Math.sqrt;\nimport static java.lang.Math.pow;\nimport java.util.Comparator;\nimport java.util.Arrays;\nimport java.util.Hashtable;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.StreamTokenizer;\nimport java.io.IOException;\nimport java.awt.*;\nimport state.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Map}.\n* It contains ten unit test cases for the {@link Map#open(String)} method.\n*/\nclass MapTest0 {"
	},
	{
		"original_code": "// Map.java\n/**\n * $Id: Map.java,v 1.7 2004/04/22 11:26:42 emill Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties.\n *\n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.7 $\n */\npackage gui;\n\nimport static java.lang.Math.max;\nimport static java.lang.Math.round;\nimport static java.lang.Math.sqrt;\nimport static java.lang.Math.pow;\nimport java.util.Comparator;\nimport java.util.Arrays;\nimport java.util.Hashtable;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.StreamTokenizer;\nimport java.io.IOException;\nimport java.awt.*;\nimport state.*;\n\n/**\n * The MapEdit implementation of Map. Some things may be altered to\n * work better with the WorldView in the GUI.\n */\npublic class Map {\n\n    private final static int WORLD_OFFSET_X = 672;\n\n    private final static int WORLD_OFFSET_Y = 32;\n\n    private final static int GRID_OFFSET_X = 14;\n\n    private final static int GRID_OFFSET_Y = -2;\n\n    static final int MAX_NUM_CELLS = 1000;\n\n    public final static int N_LAYERS = 4;\n\n    public final static int PLAYER_LAYER = 2;\n\n    MapCell[][] cell;\n\n    MapTile[] tileList;\n\n    int numOfTiles;\n\n    int[] numOfCells;\n\n    Hashtable<Player, MapCell> playercells = new Hashtable<Player, MapCell>();\n\n    /**\n     * Each tile represents one different kind of tile that can be placed\n     * on the map.\n     */\n    public static class MapTile {\n\n        public String name;\n\n        public Image image;\n\n        private static final Toolkit tk;\n\n        static {\n            tk = Toolkit.getDefaultToolkit();\n        }\n\n        public MapTile(String fileName) throws IOException {\n            name = fileName;\n            image = tk.getImage(fileName);\n        }\n    }\n\n    /**\n     * Each cell is the smallest part of the map.\n     */\n    public static class MapCell {\n\n        float x, y;\n\n        int tile, layer;\n\n        float depthvalue;\n\n        public MapCell(int x, int y, int tile, int layer) {\n            this((float) x, (float) y, tile, layer);\n        }\n\n        public MapCell(int x, int y, int tile) {\n            this(x, y, tile, 0);\n        }\n\n        public MapCell(float x, float y, int tile, int layer) {\n            this.x = x;\n            this.y = y;\n            this.tile = tile;\n            this.layer = layer;\n        }\n\n        public String toString() {\n            return String.format(\"MapCell[x=%f,y=%f,tile=%d,layer=%d]\", x, y, tile, layer);\n        }\n    }\n\n    public static class MapPlayerCell extends MapCell {\n\n        Player p;\n\n        public MapPlayerCell(Player p1) {\n            super(p1.getX(), p1.getY(), 8, PLAYER_LAYER);\n            p = p1;\n        }\n    }\n\n    /**\n     * Compares two MapCells and determine their order.\n     */\n    private class MapCellComparator implements Comparator<MapCell> {\n\n        // MapCellComparator() { /* ... */ }\n        public int compare(MapCell src, MapCell dst) {\n            return ((Float) depthvalue(src)).compareTo(depthvalue(dst));\n        }\n\n        /*if (src.y > src.x) {\n\t\tif (src.y > dst.y)\n\t\t    return 1;\n\t\tif (src.y < dst.y)\n\t\t    return -1;\n\t\treturn 0;\n\t    }\n\n\t    if (src.y < src.x) {\n\t\tif (src.x > dst.x)\n\t\t    return 1;\n\t\tif (src.x < dst.x)\n\t\t    return -1;\n\t\treturn 0;\n\t    }\n\t    \n\t    if (src.x+src.y > dst.x+dst.y)\n\t\treturn 1;\n\t    if (src.x+src.y < dst.x+dst.y)\n\t\treturn -1;\n\t\treturn 0;\n\t}*/\n        private float depthvalue(MapCell c) {\n            return (1000 * (float) c.x + 1001 * (float) c.y) / 1000 * 32;\n        }\n\n        public boolean equals(Object obj) {\n            return obj == this;\n        }\n    }\n\n    /**\n     * Creates a new instance of the Map class.\n     * @param fileName the name of the map to open.\n     */\n    public Map(String fileName) throws IOException {\n        open(fileName);\n    }\n\n    /**\n     * Open the specified map fileName.\n     * @param fileName the name of the file to open.\n     */\n    public Map open(String fileName) throws IOException {\n        //System.err.println(\"Map.open()\");\n        BufferedReader in = new BufferedReader(new FileReader(fileName));\n        StreamTokenizer st = new StreamTokenizer(in);\n        int j = 0, i = 0;\n        int[] tmp = new int[4];\n        //numOfCells = Integer.parseInt(in.readLine());\n        numOfCells = new int[N_LAYERS];\n        int readNumOfTiles = Integer.parseInt(in.readLine());\n        numOfTiles = Integer.parseInt(in.readLine());\n        cell = new MapCell[N_LAYERS][];\n        for (i = 0; i < N_LAYERS; i++) {\n            cell[i] = new MapCell[MAX_NUM_CELLS];\n        }\n        tileList = new MapTile[numOfTiles];\n        for (i = 0; i < numOfTiles; i++) {\n            tileList[i] = new MapTile(in.readLine());\n        }\n        j = 0;\n        int[] c = new int[N_LAYERS];\n        while (st.nextToken() != st.TT_EOF) {\n            if (j > 3) {\n                numOfCells[tmp[3]]++;\n                cell[tmp[3]][c[tmp[3]]++] = new MapCell(tmp[0], tmp[1], tmp[2], tmp[3]);\n                j = 0;\n            }\n            tmp[j++] = (int) st.nval;\n        }\n        if (j == 4) {\n            numOfCells[tmp[3]]++;\n            cell[tmp[3]][c[tmp[3]]++] = new MapCell(tmp[0], tmp[1], tmp[2], tmp[3]);\n            // System.err.println(\"Map.open(): Missing end of line!\");\n        }\n        //if ( != numOfCells) {\n        //    System.err.println(\"Map.open(): Unable to open file!\");\n        //}\n        in.close();\n        try {\n            MediaTracker tracker = new MediaTracker(new Frame());\n            for (MapTile t : tileList) {\n                tracker.addImage(t.image, 0);\n            }\n            //System.err.println(\"Map.open(): waiting for images!\");\n            tracker.waitForAll();\n        } catch (InterruptedException e) {\n            e.printStackTrace(System.err);\n        }\n        return this;\n    }\n\n    /**\n     * Lookup and return the MapCell at the specified x and y coordinates.\n     * Returns null if no MapCell is found. This method does a linear\n     * search through all the cells. This is considered a bug!\n     *\n     * @param x the x-coordinate of the MapCell.\n     * @param y the y-coordinate of the MapCell.\n     * @return The MapCell at the coordinates, or null if not exists.\n     */\n    public MapCell lookup(int x, int y) {\n        for (int i = numOfCells[PLAYER_LAYER] - 1; i >= 0; --i) {\n            if (round(cell[PLAYER_LAYER][i].x) == x && round(cell[PLAYER_LAYER][i].y) == y) {\n                return cell[PLAYER_LAYER][i];\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Converts the input coordinats in screen space to their respective\n     * coordinates in world space.\n     *\n     * @param x\n     * @param y\n     * @param z\n     */\n    public static Point pixelTransform(int x, int y, int z) {\n        return new Point(x + 2 * (y + z), y - (x + z) / 2);\n    }\n\n    /**\n     * Converts the input coordinats in world space to their respective\n     * coordinates in screen space.\n     *\n     * @param x\n     * @param y\n     * @param z\n     */\n    public static Point worldTransform(float x, float y) {\n        //return new Point( (int) ((x - z) / 2 - z - y),\n        //\t\t  (int) ((x + 2 * (y - z) + z) / 4));\n        x += GRID_OFFSET_X;\n        y += GRID_OFFSET_Y;\n        return new Point((int) (16 * (x - y)), (int) (8 * (y + x)));\n    }\n\n    /**\n     * Converts the input coordinats in world space to their respective\n     * coordinates in defined grid.\n     *\n     * @param x\n     * @param y\n     * @param z\n     */\n    public static Point gridTransform(int x, int y) {\n        /*int j = x - WORLD_OFFSET_X + GRID_OFFSET_X;\n\tint i = y + WORLD_OFFSET_Y + GRID_OFFSET_Y;\n\n\tj = (int) (j < 0 ? j / 32 - 0.5 : j / 32 + 1.5);\n\ti = (int) (i < 0 ? i / 16 - 0.5 : i / 16 + 1.5);\n\n\treturn new Point(j, i);*/\n        return new Point(round((float) x / 32 + (float) y / 16) - GRID_OFFSET_X, round((float) y / 16 - (float) x / 32) - GRID_OFFSET_Y);\n    }\n\n    public MapCell addPlayerCell(Player p) {\n        MapCell c = new MapPlayerCell(p);\n        cell[PLAYER_LAYER][numOfCells[PLAYER_LAYER]++] = c;\n        sortCells(PLAYER_LAYER);\n        playercells.put(p, c);\n        return c;\n    }\n\n    public void updatePlayerCell(Player p) {\n        if (p.isDead()) {\n            MapCell m = playercells.get(p);\n            m.tile = 39;\n        } else {\n            MapCell m = playercells.get(p);\n            m.x = p.getX();\n            m.y = p.getY();\n        }\n    }\n\n    public void sortCells(int layer) {\n        //System.err.print(\"Sorting... \");\n        Arrays.sort(cell[layer], 0, numOfCells[layer], new MapCellComparator());\n        //System.err.println(\"done!\");\n    }\n\n    /**\n     * Paints a layer of this map on a Graphics object.\n     */\n    public void draw(Graphics2D g, int layer) {\n        int i, z, w, h;\n        float x, y;\n        MapTile t;\n        Point p;\n        i = 0;\n        try {\n            for (i = 0; i < numOfCells[layer]; i++) {\n                x = cell[layer][i].x;\n                y = cell[layer][i].y;\n                z = cell[layer][i].tile;\n                /* check whether this cell should be drawn */\n                if (z != -1) {\n                    t = tileList[z];\n                    w = t.image.getWidth(null);\n                    h = t.image.getHeight(null);\n                    //p = worldTransform(x*32 + WORLD_OFFSET_X - 8 - w/2,\n                    //\t       y*16 - WORLD_OFFSET_Y - 4 + w/4, 74);\n                    p = worldTransform(x, y);\n                    g.drawImage(t.image, p.x - w / 2, p.y - h, null);\n                }\n            }\n        } catch (Exception e) {\n            System.err.printf(\"MapGrid.paint(): i=%d l=%d\\n\", i, cell.length);\n            e.printStackTrace(System.err);\n        }\n    }\n\n    public String toString() {\n        return \"Map[]\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/gui/MapTest1.java",
		"test_prompt": "// MapTest1.java\npackage gui;\n\nimport static java.lang.Math.max;\nimport static java.lang.Math.round;\nimport static java.lang.Math.sqrt;\nimport static java.lang.Math.pow;\nimport java.util.Comparator;\nimport java.util.Arrays;\nimport java.util.Hashtable;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.StreamTokenizer;\nimport java.io.IOException;\nimport java.awt.*;\nimport state.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Map}.\n* It contains ten unit test cases for the {@link Map#lookup(int, int)} method.\n*/\nclass MapTest1 {"
	},
	{
		"original_code": "// Map.java\n/**\n * $Id: Map.java,v 1.7 2004/04/22 11:26:42 emill Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties.\n *\n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.7 $\n */\npackage gui;\n\nimport static java.lang.Math.max;\nimport static java.lang.Math.round;\nimport static java.lang.Math.sqrt;\nimport static java.lang.Math.pow;\nimport java.util.Comparator;\nimport java.util.Arrays;\nimport java.util.Hashtable;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.StreamTokenizer;\nimport java.io.IOException;\nimport java.awt.*;\nimport state.*;\n\n/**\n * The MapEdit implementation of Map. Some things may be altered to\n * work better with the WorldView in the GUI.\n */\npublic class Map {\n\n    private final static int WORLD_OFFSET_X = 672;\n\n    private final static int WORLD_OFFSET_Y = 32;\n\n    private final static int GRID_OFFSET_X = 14;\n\n    private final static int GRID_OFFSET_Y = -2;\n\n    static final int MAX_NUM_CELLS = 1000;\n\n    public final static int N_LAYERS = 4;\n\n    public final static int PLAYER_LAYER = 2;\n\n    MapCell[][] cell;\n\n    MapTile[] tileList;\n\n    int numOfTiles;\n\n    int[] numOfCells;\n\n    Hashtable<Player, MapCell> playercells = new Hashtable<Player, MapCell>();\n\n    /**\n     * Each tile represents one different kind of tile that can be placed\n     * on the map.\n     */\n    public static class MapTile {\n\n        public String name;\n\n        public Image image;\n\n        private static final Toolkit tk;\n\n        static {\n            tk = Toolkit.getDefaultToolkit();\n        }\n\n        public MapTile(String fileName) throws IOException {\n            name = fileName;\n            image = tk.getImage(fileName);\n        }\n    }\n\n    /**\n     * Each cell is the smallest part of the map.\n     */\n    public static class MapCell {\n\n        float x, y;\n\n        int tile, layer;\n\n        float depthvalue;\n\n        public MapCell(int x, int y, int tile, int layer) {\n            this((float) x, (float) y, tile, layer);\n        }\n\n        public MapCell(int x, int y, int tile) {\n            this(x, y, tile, 0);\n        }\n\n        public MapCell(float x, float y, int tile, int layer) {\n            this.x = x;\n            this.y = y;\n            this.tile = tile;\n            this.layer = layer;\n        }\n\n        public String toString() {\n            return String.format(\"MapCell[x=%f,y=%f,tile=%d,layer=%d]\", x, y, tile, layer);\n        }\n    }\n\n    public static class MapPlayerCell extends MapCell {\n\n        Player p;\n\n        public MapPlayerCell(Player p1) {\n            super(p1.getX(), p1.getY(), 8, PLAYER_LAYER);\n            p = p1;\n        }\n    }\n\n    /**\n     * Compares two MapCells and determine their order.\n     */\n    private class MapCellComparator implements Comparator<MapCell> {\n\n        // MapCellComparator() { /* ... */ }\n        public int compare(MapCell src, MapCell dst) {\n            return ((Float) depthvalue(src)).compareTo(depthvalue(dst));\n        }\n\n        /*if (src.y > src.x) {\n\t\tif (src.y > dst.y)\n\t\t    return 1;\n\t\tif (src.y < dst.y)\n\t\t    return -1;\n\t\treturn 0;\n\t    }\n\n\t    if (src.y < src.x) {\n\t\tif (src.x > dst.x)\n\t\t    return 1;\n\t\tif (src.x < dst.x)\n\t\t    return -1;\n\t\treturn 0;\n\t    }\n\t    \n\t    if (src.x+src.y > dst.x+dst.y)\n\t\treturn 1;\n\t    if (src.x+src.y < dst.x+dst.y)\n\t\treturn -1;\n\t\treturn 0;\n\t}*/\n        private float depthvalue(MapCell c) {\n            return (1000 * (float) c.x + 1001 * (float) c.y) / 1000 * 32;\n        }\n\n        public boolean equals(Object obj) {\n            return obj == this;\n        }\n    }\n\n    /**\n     * Creates a new instance of the Map class.\n     * @param fileName the name of the map to open.\n     */\n    public Map(String fileName) throws IOException {\n        open(fileName);\n    }\n\n    /**\n     * Open the specified map fileName.\n     * @param fileName the name of the file to open.\n     */\n    public Map open(String fileName) throws IOException {\n        //System.err.println(\"Map.open()\");\n        BufferedReader in = new BufferedReader(new FileReader(fileName));\n        StreamTokenizer st = new StreamTokenizer(in);\n        int j = 0, i = 0;\n        int[] tmp = new int[4];\n        //numOfCells = Integer.parseInt(in.readLine());\n        numOfCells = new int[N_LAYERS];\n        int readNumOfTiles = Integer.parseInt(in.readLine());\n        numOfTiles = Integer.parseInt(in.readLine());\n        cell = new MapCell[N_LAYERS][];\n        for (i = 0; i < N_LAYERS; i++) {\n            cell[i] = new MapCell[MAX_NUM_CELLS];\n        }\n        tileList = new MapTile[numOfTiles];\n        for (i = 0; i < numOfTiles; i++) {\n            tileList[i] = new MapTile(in.readLine());\n        }\n        j = 0;\n        int[] c = new int[N_LAYERS];\n        while (st.nextToken() != st.TT_EOF) {\n            if (j > 3) {\n                numOfCells[tmp[3]]++;\n                cell[tmp[3]][c[tmp[3]]++] = new MapCell(tmp[0], tmp[1], tmp[2], tmp[3]);\n                j = 0;\n            }\n            tmp[j++] = (int) st.nval;\n        }\n        if (j == 4) {\n            numOfCells[tmp[3]]++;\n            cell[tmp[3]][c[tmp[3]]++] = new MapCell(tmp[0], tmp[1], tmp[2], tmp[3]);\n            // System.err.println(\"Map.open(): Missing end of line!\");\n        }\n        //if ( != numOfCells) {\n        //    System.err.println(\"Map.open(): Unable to open file!\");\n        //}\n        in.close();\n        try {\n            MediaTracker tracker = new MediaTracker(new Frame());\n            for (MapTile t : tileList) {\n                tracker.addImage(t.image, 0);\n            }\n            //System.err.println(\"Map.open(): waiting for images!\");\n            tracker.waitForAll();\n        } catch (InterruptedException e) {\n            e.printStackTrace(System.err);\n        }\n        return this;\n    }\n\n    /**\n     * Lookup and return the MapCell at the specified x and y coordinates.\n     * Returns null if no MapCell is found. This method does a linear\n     * search through all the cells. This is considered a bug!\n     *\n     * @param x the x-coordinate of the MapCell.\n     * @param y the y-coordinate of the MapCell.\n     * @return The MapCell at the coordinates, or null if not exists.\n     */\n    public MapCell lookup(int x, int y) {\n        for (int i = numOfCells[PLAYER_LAYER] - 1; i >= 0; --i) {\n            if (round(cell[PLAYER_LAYER][i].x) == x && round(cell[PLAYER_LAYER][i].y) == y) {\n                return cell[PLAYER_LAYER][i];\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Converts the input coordinats in screen space to their respective\n     * coordinates in world space.\n     *\n     * @param x\n     * @param y\n     * @param z\n     */\n    public static Point pixelTransform(int x, int y, int z) {\n        return new Point(x + 2 * (y + z), y - (x + z) / 2);\n    }\n\n    /**\n     * Converts the input coordinats in world space to their respective\n     * coordinates in screen space.\n     *\n     * @param x\n     * @param y\n     * @param z\n     */\n    public static Point worldTransform(float x, float y) {\n        //return new Point( (int) ((x - z) / 2 - z - y),\n        //\t\t  (int) ((x + 2 * (y - z) + z) / 4));\n        x += GRID_OFFSET_X;\n        y += GRID_OFFSET_Y;\n        return new Point((int) (16 * (x - y)), (int) (8 * (y + x)));\n    }\n\n    /**\n     * Converts the input coordinats in world space to their respective\n     * coordinates in defined grid.\n     *\n     * @param x\n     * @param y\n     * @param z\n     */\n    public static Point gridTransform(int x, int y) {\n        /*int j = x - WORLD_OFFSET_X + GRID_OFFSET_X;\n\tint i = y + WORLD_OFFSET_Y + GRID_OFFSET_Y;\n\n\tj = (int) (j < 0 ? j / 32 - 0.5 : j / 32 + 1.5);\n\ti = (int) (i < 0 ? i / 16 - 0.5 : i / 16 + 1.5);\n\n\treturn new Point(j, i);*/\n        return new Point(round((float) x / 32 + (float) y / 16) - GRID_OFFSET_X, round((float) y / 16 - (float) x / 32) - GRID_OFFSET_Y);\n    }\n\n    public MapCell addPlayerCell(Player p) {\n        MapCell c = new MapPlayerCell(p);\n        cell[PLAYER_LAYER][numOfCells[PLAYER_LAYER]++] = c;\n        sortCells(PLAYER_LAYER);\n        playercells.put(p, c);\n        return c;\n    }\n\n    public void updatePlayerCell(Player p) {\n        if (p.isDead()) {\n            MapCell m = playercells.get(p);\n            m.tile = 39;\n        } else {\n            MapCell m = playercells.get(p);\n            m.x = p.getX();\n            m.y = p.getY();\n        }\n    }\n\n    public void sortCells(int layer) {\n        //System.err.print(\"Sorting... \");\n        Arrays.sort(cell[layer], 0, numOfCells[layer], new MapCellComparator());\n        //System.err.println(\"done!\");\n    }\n\n    /**\n     * Paints a layer of this map on a Graphics object.\n     */\n    public void draw(Graphics2D g, int layer) {\n        int i, z, w, h;\n        float x, y;\n        MapTile t;\n        Point p;\n        i = 0;\n        try {\n            for (i = 0; i < numOfCells[layer]; i++) {\n                x = cell[layer][i].x;\n                y = cell[layer][i].y;\n                z = cell[layer][i].tile;\n                /* check whether this cell should be drawn */\n                if (z != -1) {\n                    t = tileList[z];\n                    w = t.image.getWidth(null);\n                    h = t.image.getHeight(null);\n                    //p = worldTransform(x*32 + WORLD_OFFSET_X - 8 - w/2,\n                    //\t       y*16 - WORLD_OFFSET_Y - 4 + w/4, 74);\n                    p = worldTransform(x, y);\n                    g.drawImage(t.image, p.x - w / 2, p.y - h, null);\n                }\n            }\n        } catch (Exception e) {\n            System.err.printf(\"MapGrid.paint(): i=%d l=%d\\n\", i, cell.length);\n            e.printStackTrace(System.err);\n        }\n    }\n\n    public String toString() {\n        return \"Map[]\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/gui/MapTest2.java",
		"test_prompt": "// MapTest2.java\npackage gui;\n\nimport static java.lang.Math.max;\nimport static java.lang.Math.round;\nimport static java.lang.Math.sqrt;\nimport static java.lang.Math.pow;\nimport java.util.Comparator;\nimport java.util.Arrays;\nimport java.util.Hashtable;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.StreamTokenizer;\nimport java.io.IOException;\nimport java.awt.*;\nimport state.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Map}.\n* It contains ten unit test cases for the {@link Map#pixelTransform(int, int, int)} method.\n*/\nclass MapTest2 {"
	},
	{
		"original_code": "// Map.java\n/**\n * $Id: Map.java,v 1.7 2004/04/22 11:26:42 emill Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties.\n *\n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.7 $\n */\npackage gui;\n\nimport static java.lang.Math.max;\nimport static java.lang.Math.round;\nimport static java.lang.Math.sqrt;\nimport static java.lang.Math.pow;\nimport java.util.Comparator;\nimport java.util.Arrays;\nimport java.util.Hashtable;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.StreamTokenizer;\nimport java.io.IOException;\nimport java.awt.*;\nimport state.*;\n\n/**\n * The MapEdit implementation of Map. Some things may be altered to\n * work better with the WorldView in the GUI.\n */\npublic class Map {\n\n    private final static int WORLD_OFFSET_X = 672;\n\n    private final static int WORLD_OFFSET_Y = 32;\n\n    private final static int GRID_OFFSET_X = 14;\n\n    private final static int GRID_OFFSET_Y = -2;\n\n    static final int MAX_NUM_CELLS = 1000;\n\n    public final static int N_LAYERS = 4;\n\n    public final static int PLAYER_LAYER = 2;\n\n    MapCell[][] cell;\n\n    MapTile[] tileList;\n\n    int numOfTiles;\n\n    int[] numOfCells;\n\n    Hashtable<Player, MapCell> playercells = new Hashtable<Player, MapCell>();\n\n    /**\n     * Each tile represents one different kind of tile that can be placed\n     * on the map.\n     */\n    public static class MapTile {\n\n        public String name;\n\n        public Image image;\n\n        private static final Toolkit tk;\n\n        static {\n            tk = Toolkit.getDefaultToolkit();\n        }\n\n        public MapTile(String fileName) throws IOException {\n            name = fileName;\n            image = tk.getImage(fileName);\n        }\n    }\n\n    /**\n     * Each cell is the smallest part of the map.\n     */\n    public static class MapCell {\n\n        float x, y;\n\n        int tile, layer;\n\n        float depthvalue;\n\n        public MapCell(int x, int y, int tile, int layer) {\n            this((float) x, (float) y, tile, layer);\n        }\n\n        public MapCell(int x, int y, int tile) {\n            this(x, y, tile, 0);\n        }\n\n        public MapCell(float x, float y, int tile, int layer) {\n            this.x = x;\n            this.y = y;\n            this.tile = tile;\n            this.layer = layer;\n        }\n\n        public String toString() {\n            return String.format(\"MapCell[x=%f,y=%f,tile=%d,layer=%d]\", x, y, tile, layer);\n        }\n    }\n\n    public static class MapPlayerCell extends MapCell {\n\n        Player p;\n\n        public MapPlayerCell(Player p1) {\n            super(p1.getX(), p1.getY(), 8, PLAYER_LAYER);\n            p = p1;\n        }\n    }\n\n    /**\n     * Compares two MapCells and determine their order.\n     */\n    private class MapCellComparator implements Comparator<MapCell> {\n\n        // MapCellComparator() { /* ... */ }\n        public int compare(MapCell src, MapCell dst) {\n            return ((Float) depthvalue(src)).compareTo(depthvalue(dst));\n        }\n\n        /*if (src.y > src.x) {\n\t\tif (src.y > dst.y)\n\t\t    return 1;\n\t\tif (src.y < dst.y)\n\t\t    return -1;\n\t\treturn 0;\n\t    }\n\n\t    if (src.y < src.x) {\n\t\tif (src.x > dst.x)\n\t\t    return 1;\n\t\tif (src.x < dst.x)\n\t\t    return -1;\n\t\treturn 0;\n\t    }\n\t    \n\t    if (src.x+src.y > dst.x+dst.y)\n\t\treturn 1;\n\t    if (src.x+src.y < dst.x+dst.y)\n\t\treturn -1;\n\t\treturn 0;\n\t}*/\n        private float depthvalue(MapCell c) {\n            return (1000 * (float) c.x + 1001 * (float) c.y) / 1000 * 32;\n        }\n\n        public boolean equals(Object obj) {\n            return obj == this;\n        }\n    }\n\n    /**\n     * Creates a new instance of the Map class.\n     * @param fileName the name of the map to open.\n     */\n    public Map(String fileName) throws IOException {\n        open(fileName);\n    }\n\n    /**\n     * Open the specified map fileName.\n     * @param fileName the name of the file to open.\n     */\n    public Map open(String fileName) throws IOException {\n        //System.err.println(\"Map.open()\");\n        BufferedReader in = new BufferedReader(new FileReader(fileName));\n        StreamTokenizer st = new StreamTokenizer(in);\n        int j = 0, i = 0;\n        int[] tmp = new int[4];\n        //numOfCells = Integer.parseInt(in.readLine());\n        numOfCells = new int[N_LAYERS];\n        int readNumOfTiles = Integer.parseInt(in.readLine());\n        numOfTiles = Integer.parseInt(in.readLine());\n        cell = new MapCell[N_LAYERS][];\n        for (i = 0; i < N_LAYERS; i++) {\n            cell[i] = new MapCell[MAX_NUM_CELLS];\n        }\n        tileList = new MapTile[numOfTiles];\n        for (i = 0; i < numOfTiles; i++) {\n            tileList[i] = new MapTile(in.readLine());\n        }\n        j = 0;\n        int[] c = new int[N_LAYERS];\n        while (st.nextToken() != st.TT_EOF) {\n            if (j > 3) {\n                numOfCells[tmp[3]]++;\n                cell[tmp[3]][c[tmp[3]]++] = new MapCell(tmp[0], tmp[1], tmp[2], tmp[3]);\n                j = 0;\n            }\n            tmp[j++] = (int) st.nval;\n        }\n        if (j == 4) {\n            numOfCells[tmp[3]]++;\n            cell[tmp[3]][c[tmp[3]]++] = new MapCell(tmp[0], tmp[1], tmp[2], tmp[3]);\n            // System.err.println(\"Map.open(): Missing end of line!\");\n        }\n        //if ( != numOfCells) {\n        //    System.err.println(\"Map.open(): Unable to open file!\");\n        //}\n        in.close();\n        try {\n            MediaTracker tracker = new MediaTracker(new Frame());\n            for (MapTile t : tileList) {\n                tracker.addImage(t.image, 0);\n            }\n            //System.err.println(\"Map.open(): waiting for images!\");\n            tracker.waitForAll();\n        } catch (InterruptedException e) {\n            e.printStackTrace(System.err);\n        }\n        return this;\n    }\n\n    /**\n     * Lookup and return the MapCell at the specified x and y coordinates.\n     * Returns null if no MapCell is found. This method does a linear\n     * search through all the cells. This is considered a bug!\n     *\n     * @param x the x-coordinate of the MapCell.\n     * @param y the y-coordinate of the MapCell.\n     * @return The MapCell at the coordinates, or null if not exists.\n     */\n    public MapCell lookup(int x, int y) {\n        for (int i = numOfCells[PLAYER_LAYER] - 1; i >= 0; --i) {\n            if (round(cell[PLAYER_LAYER][i].x) == x && round(cell[PLAYER_LAYER][i].y) == y) {\n                return cell[PLAYER_LAYER][i];\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Converts the input coordinats in screen space to their respective\n     * coordinates in world space.\n     *\n     * @param x\n     * @param y\n     * @param z\n     */\n    public static Point pixelTransform(int x, int y, int z) {\n        return new Point(x + 2 * (y + z), y - (x + z) / 2);\n    }\n\n    /**\n     * Converts the input coordinats in world space to their respective\n     * coordinates in screen space.\n     *\n     * @param x\n     * @param y\n     * @param z\n     */\n    public static Point worldTransform(float x, float y) {\n        //return new Point( (int) ((x - z) / 2 - z - y),\n        //\t\t  (int) ((x + 2 * (y - z) + z) / 4));\n        x += GRID_OFFSET_X;\n        y += GRID_OFFSET_Y;\n        return new Point((int) (16 * (x - y)), (int) (8 * (y + x)));\n    }\n\n    /**\n     * Converts the input coordinats in world space to their respective\n     * coordinates in defined grid.\n     *\n     * @param x\n     * @param y\n     * @param z\n     */\n    public static Point gridTransform(int x, int y) {\n        /*int j = x - WORLD_OFFSET_X + GRID_OFFSET_X;\n\tint i = y + WORLD_OFFSET_Y + GRID_OFFSET_Y;\n\n\tj = (int) (j < 0 ? j / 32 - 0.5 : j / 32 + 1.5);\n\ti = (int) (i < 0 ? i / 16 - 0.5 : i / 16 + 1.5);\n\n\treturn new Point(j, i);*/\n        return new Point(round((float) x / 32 + (float) y / 16) - GRID_OFFSET_X, round((float) y / 16 - (float) x / 32) - GRID_OFFSET_Y);\n    }\n\n    public MapCell addPlayerCell(Player p) {\n        MapCell c = new MapPlayerCell(p);\n        cell[PLAYER_LAYER][numOfCells[PLAYER_LAYER]++] = c;\n        sortCells(PLAYER_LAYER);\n        playercells.put(p, c);\n        return c;\n    }\n\n    public void updatePlayerCell(Player p) {\n        if (p.isDead()) {\n            MapCell m = playercells.get(p);\n            m.tile = 39;\n        } else {\n            MapCell m = playercells.get(p);\n            m.x = p.getX();\n            m.y = p.getY();\n        }\n    }\n\n    public void sortCells(int layer) {\n        //System.err.print(\"Sorting... \");\n        Arrays.sort(cell[layer], 0, numOfCells[layer], new MapCellComparator());\n        //System.err.println(\"done!\");\n    }\n\n    /**\n     * Paints a layer of this map on a Graphics object.\n     */\n    public void draw(Graphics2D g, int layer) {\n        int i, z, w, h;\n        float x, y;\n        MapTile t;\n        Point p;\n        i = 0;\n        try {\n            for (i = 0; i < numOfCells[layer]; i++) {\n                x = cell[layer][i].x;\n                y = cell[layer][i].y;\n                z = cell[layer][i].tile;\n                /* check whether this cell should be drawn */\n                if (z != -1) {\n                    t = tileList[z];\n                    w = t.image.getWidth(null);\n                    h = t.image.getHeight(null);\n                    //p = worldTransform(x*32 + WORLD_OFFSET_X - 8 - w/2,\n                    //\t       y*16 - WORLD_OFFSET_Y - 4 + w/4, 74);\n                    p = worldTransform(x, y);\n                    g.drawImage(t.image, p.x - w / 2, p.y - h, null);\n                }\n            }\n        } catch (Exception e) {\n            System.err.printf(\"MapGrid.paint(): i=%d l=%d\\n\", i, cell.length);\n            e.printStackTrace(System.err);\n        }\n    }\n\n    public String toString() {\n        return \"Map[]\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/gui/MapTest3.java",
		"test_prompt": "// MapTest3.java\npackage gui;\n\nimport static java.lang.Math.max;\nimport static java.lang.Math.round;\nimport static java.lang.Math.sqrt;\nimport static java.lang.Math.pow;\nimport java.util.Comparator;\nimport java.util.Arrays;\nimport java.util.Hashtable;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.StreamTokenizer;\nimport java.io.IOException;\nimport java.awt.*;\nimport state.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Map}.\n* It contains ten unit test cases for the {@link Map#worldTransform(float, float)} method.\n*/\nclass MapTest3 {"
	},
	{
		"original_code": "// Map.java\n/**\n * $Id: Map.java,v 1.7 2004/04/22 11:26:42 emill Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties.\n *\n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.7 $\n */\npackage gui;\n\nimport static java.lang.Math.max;\nimport static java.lang.Math.round;\nimport static java.lang.Math.sqrt;\nimport static java.lang.Math.pow;\nimport java.util.Comparator;\nimport java.util.Arrays;\nimport java.util.Hashtable;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.StreamTokenizer;\nimport java.io.IOException;\nimport java.awt.*;\nimport state.*;\n\n/**\n * The MapEdit implementation of Map. Some things may be altered to\n * work better with the WorldView in the GUI.\n */\npublic class Map {\n\n    private final static int WORLD_OFFSET_X = 672;\n\n    private final static int WORLD_OFFSET_Y = 32;\n\n    private final static int GRID_OFFSET_X = 14;\n\n    private final static int GRID_OFFSET_Y = -2;\n\n    static final int MAX_NUM_CELLS = 1000;\n\n    public final static int N_LAYERS = 4;\n\n    public final static int PLAYER_LAYER = 2;\n\n    MapCell[][] cell;\n\n    MapTile[] tileList;\n\n    int numOfTiles;\n\n    int[] numOfCells;\n\n    Hashtable<Player, MapCell> playercells = new Hashtable<Player, MapCell>();\n\n    /**\n     * Each tile represents one different kind of tile that can be placed\n     * on the map.\n     */\n    public static class MapTile {\n\n        public String name;\n\n        public Image image;\n\n        private static final Toolkit tk;\n\n        static {\n            tk = Toolkit.getDefaultToolkit();\n        }\n\n        public MapTile(String fileName) throws IOException {\n            name = fileName;\n            image = tk.getImage(fileName);\n        }\n    }\n\n    /**\n     * Each cell is the smallest part of the map.\n     */\n    public static class MapCell {\n\n        float x, y;\n\n        int tile, layer;\n\n        float depthvalue;\n\n        public MapCell(int x, int y, int tile, int layer) {\n            this((float) x, (float) y, tile, layer);\n        }\n\n        public MapCell(int x, int y, int tile) {\n            this(x, y, tile, 0);\n        }\n\n        public MapCell(float x, float y, int tile, int layer) {\n            this.x = x;\n            this.y = y;\n            this.tile = tile;\n            this.layer = layer;\n        }\n\n        public String toString() {\n            return String.format(\"MapCell[x=%f,y=%f,tile=%d,layer=%d]\", x, y, tile, layer);\n        }\n    }\n\n    public static class MapPlayerCell extends MapCell {\n\n        Player p;\n\n        public MapPlayerCell(Player p1) {\n            super(p1.getX(), p1.getY(), 8, PLAYER_LAYER);\n            p = p1;\n        }\n    }\n\n    /**\n     * Compares two MapCells and determine their order.\n     */\n    private class MapCellComparator implements Comparator<MapCell> {\n\n        // MapCellComparator() { /* ... */ }\n        public int compare(MapCell src, MapCell dst) {\n            return ((Float) depthvalue(src)).compareTo(depthvalue(dst));\n        }\n\n        /*if (src.y > src.x) {\n\t\tif (src.y > dst.y)\n\t\t    return 1;\n\t\tif (src.y < dst.y)\n\t\t    return -1;\n\t\treturn 0;\n\t    }\n\n\t    if (src.y < src.x) {\n\t\tif (src.x > dst.x)\n\t\t    return 1;\n\t\tif (src.x < dst.x)\n\t\t    return -1;\n\t\treturn 0;\n\t    }\n\t    \n\t    if (src.x+src.y > dst.x+dst.y)\n\t\treturn 1;\n\t    if (src.x+src.y < dst.x+dst.y)\n\t\treturn -1;\n\t\treturn 0;\n\t}*/\n        private float depthvalue(MapCell c) {\n            return (1000 * (float) c.x + 1001 * (float) c.y) / 1000 * 32;\n        }\n\n        public boolean equals(Object obj) {\n            return obj == this;\n        }\n    }\n\n    /**\n     * Creates a new instance of the Map class.\n     * @param fileName the name of the map to open.\n     */\n    public Map(String fileName) throws IOException {\n        open(fileName);\n    }\n\n    /**\n     * Open the specified map fileName.\n     * @param fileName the name of the file to open.\n     */\n    public Map open(String fileName) throws IOException {\n        //System.err.println(\"Map.open()\");\n        BufferedReader in = new BufferedReader(new FileReader(fileName));\n        StreamTokenizer st = new StreamTokenizer(in);\n        int j = 0, i = 0;\n        int[] tmp = new int[4];\n        //numOfCells = Integer.parseInt(in.readLine());\n        numOfCells = new int[N_LAYERS];\n        int readNumOfTiles = Integer.parseInt(in.readLine());\n        numOfTiles = Integer.parseInt(in.readLine());\n        cell = new MapCell[N_LAYERS][];\n        for (i = 0; i < N_LAYERS; i++) {\n            cell[i] = new MapCell[MAX_NUM_CELLS];\n        }\n        tileList = new MapTile[numOfTiles];\n        for (i = 0; i < numOfTiles; i++) {\n            tileList[i] = new MapTile(in.readLine());\n        }\n        j = 0;\n        int[] c = new int[N_LAYERS];\n        while (st.nextToken() != st.TT_EOF) {\n            if (j > 3) {\n                numOfCells[tmp[3]]++;\n                cell[tmp[3]][c[tmp[3]]++] = new MapCell(tmp[0], tmp[1], tmp[2], tmp[3]);\n                j = 0;\n            }\n            tmp[j++] = (int) st.nval;\n        }\n        if (j == 4) {\n            numOfCells[tmp[3]]++;\n            cell[tmp[3]][c[tmp[3]]++] = new MapCell(tmp[0], tmp[1], tmp[2], tmp[3]);\n            // System.err.println(\"Map.open(): Missing end of line!\");\n        }\n        //if ( != numOfCells) {\n        //    System.err.println(\"Map.open(): Unable to open file!\");\n        //}\n        in.close();\n        try {\n            MediaTracker tracker = new MediaTracker(new Frame());\n            for (MapTile t : tileList) {\n                tracker.addImage(t.image, 0);\n            }\n            //System.err.println(\"Map.open(): waiting for images!\");\n            tracker.waitForAll();\n        } catch (InterruptedException e) {\n            e.printStackTrace(System.err);\n        }\n        return this;\n    }\n\n    /**\n     * Lookup and return the MapCell at the specified x and y coordinates.\n     * Returns null if no MapCell is found. This method does a linear\n     * search through all the cells. This is considered a bug!\n     *\n     * @param x the x-coordinate of the MapCell.\n     * @param y the y-coordinate of the MapCell.\n     * @return The MapCell at the coordinates, or null if not exists.\n     */\n    public MapCell lookup(int x, int y) {\n        for (int i = numOfCells[PLAYER_LAYER] - 1; i >= 0; --i) {\n            if (round(cell[PLAYER_LAYER][i].x) == x && round(cell[PLAYER_LAYER][i].y) == y) {\n                return cell[PLAYER_LAYER][i];\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Converts the input coordinats in screen space to their respective\n     * coordinates in world space.\n     *\n     * @param x\n     * @param y\n     * @param z\n     */\n    public static Point pixelTransform(int x, int y, int z) {\n        return new Point(x + 2 * (y + z), y - (x + z) / 2);\n    }\n\n    /**\n     * Converts the input coordinats in world space to their respective\n     * coordinates in screen space.\n     *\n     * @param x\n     * @param y\n     * @param z\n     */\n    public static Point worldTransform(float x, float y) {\n        //return new Point( (int) ((x - z) / 2 - z - y),\n        //\t\t  (int) ((x + 2 * (y - z) + z) / 4));\n        x += GRID_OFFSET_X;\n        y += GRID_OFFSET_Y;\n        return new Point((int) (16 * (x - y)), (int) (8 * (y + x)));\n    }\n\n    /**\n     * Converts the input coordinats in world space to their respective\n     * coordinates in defined grid.\n     *\n     * @param x\n     * @param y\n     * @param z\n     */\n    public static Point gridTransform(int x, int y) {\n        /*int j = x - WORLD_OFFSET_X + GRID_OFFSET_X;\n\tint i = y + WORLD_OFFSET_Y + GRID_OFFSET_Y;\n\n\tj = (int) (j < 0 ? j / 32 - 0.5 : j / 32 + 1.5);\n\ti = (int) (i < 0 ? i / 16 - 0.5 : i / 16 + 1.5);\n\n\treturn new Point(j, i);*/\n        return new Point(round((float) x / 32 + (float) y / 16) - GRID_OFFSET_X, round((float) y / 16 - (float) x / 32) - GRID_OFFSET_Y);\n    }\n\n    public MapCell addPlayerCell(Player p) {\n        MapCell c = new MapPlayerCell(p);\n        cell[PLAYER_LAYER][numOfCells[PLAYER_LAYER]++] = c;\n        sortCells(PLAYER_LAYER);\n        playercells.put(p, c);\n        return c;\n    }\n\n    public void updatePlayerCell(Player p) {\n        if (p.isDead()) {\n            MapCell m = playercells.get(p);\n            m.tile = 39;\n        } else {\n            MapCell m = playercells.get(p);\n            m.x = p.getX();\n            m.y = p.getY();\n        }\n    }\n\n    public void sortCells(int layer) {\n        //System.err.print(\"Sorting... \");\n        Arrays.sort(cell[layer], 0, numOfCells[layer], new MapCellComparator());\n        //System.err.println(\"done!\");\n    }\n\n    /**\n     * Paints a layer of this map on a Graphics object.\n     */\n    public void draw(Graphics2D g, int layer) {\n        int i, z, w, h;\n        float x, y;\n        MapTile t;\n        Point p;\n        i = 0;\n        try {\n            for (i = 0; i < numOfCells[layer]; i++) {\n                x = cell[layer][i].x;\n                y = cell[layer][i].y;\n                z = cell[layer][i].tile;\n                /* check whether this cell should be drawn */\n                if (z != -1) {\n                    t = tileList[z];\n                    w = t.image.getWidth(null);\n                    h = t.image.getHeight(null);\n                    //p = worldTransform(x*32 + WORLD_OFFSET_X - 8 - w/2,\n                    //\t       y*16 - WORLD_OFFSET_Y - 4 + w/4, 74);\n                    p = worldTransform(x, y);\n                    g.drawImage(t.image, p.x - w / 2, p.y - h, null);\n                }\n            }\n        } catch (Exception e) {\n            System.err.printf(\"MapGrid.paint(): i=%d l=%d\\n\", i, cell.length);\n            e.printStackTrace(System.err);\n        }\n    }\n\n    public String toString() {\n        return \"Map[]\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/gui/MapTest4.java",
		"test_prompt": "// MapTest4.java\npackage gui;\n\nimport static java.lang.Math.max;\nimport static java.lang.Math.round;\nimport static java.lang.Math.sqrt;\nimport static java.lang.Math.pow;\nimport java.util.Comparator;\nimport java.util.Arrays;\nimport java.util.Hashtable;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.StreamTokenizer;\nimport java.io.IOException;\nimport java.awt.*;\nimport state.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Map}.\n* It contains ten unit test cases for the {@link Map#gridTransform(int, int)} method.\n*/\nclass MapTest4 {"
	},
	{
		"original_code": "// Map.java\n/**\n * $Id: Map.java,v 1.7 2004/04/22 11:26:42 emill Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties.\n *\n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.7 $\n */\npackage gui;\n\nimport static java.lang.Math.max;\nimport static java.lang.Math.round;\nimport static java.lang.Math.sqrt;\nimport static java.lang.Math.pow;\nimport java.util.Comparator;\nimport java.util.Arrays;\nimport java.util.Hashtable;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.StreamTokenizer;\nimport java.io.IOException;\nimport java.awt.*;\nimport state.*;\n\n/**\n * The MapEdit implementation of Map. Some things may be altered to\n * work better with the WorldView in the GUI.\n */\npublic class Map {\n\n    private final static int WORLD_OFFSET_X = 672;\n\n    private final static int WORLD_OFFSET_Y = 32;\n\n    private final static int GRID_OFFSET_X = 14;\n\n    private final static int GRID_OFFSET_Y = -2;\n\n    static final int MAX_NUM_CELLS = 1000;\n\n    public final static int N_LAYERS = 4;\n\n    public final static int PLAYER_LAYER = 2;\n\n    MapCell[][] cell;\n\n    MapTile[] tileList;\n\n    int numOfTiles;\n\n    int[] numOfCells;\n\n    Hashtable<Player, MapCell> playercells = new Hashtable<Player, MapCell>();\n\n    /**\n     * Each tile represents one different kind of tile that can be placed\n     * on the map.\n     */\n    public static class MapTile {\n\n        public String name;\n\n        public Image image;\n\n        private static final Toolkit tk;\n\n        static {\n            tk = Toolkit.getDefaultToolkit();\n        }\n\n        public MapTile(String fileName) throws IOException {\n            name = fileName;\n            image = tk.getImage(fileName);\n        }\n    }\n\n    /**\n     * Each cell is the smallest part of the map.\n     */\n    public static class MapCell {\n\n        float x, y;\n\n        int tile, layer;\n\n        float depthvalue;\n\n        public MapCell(int x, int y, int tile, int layer) {\n            this((float) x, (float) y, tile, layer);\n        }\n\n        public MapCell(int x, int y, int tile) {\n            this(x, y, tile, 0);\n        }\n\n        public MapCell(float x, float y, int tile, int layer) {\n            this.x = x;\n            this.y = y;\n            this.tile = tile;\n            this.layer = layer;\n        }\n\n        public String toString() {\n            return String.format(\"MapCell[x=%f,y=%f,tile=%d,layer=%d]\", x, y, tile, layer);\n        }\n    }\n\n    public static class MapPlayerCell extends MapCell {\n\n        Player p;\n\n        public MapPlayerCell(Player p1) {\n            super(p1.getX(), p1.getY(), 8, PLAYER_LAYER);\n            p = p1;\n        }\n    }\n\n    /**\n     * Compares two MapCells and determine their order.\n     */\n    private class MapCellComparator implements Comparator<MapCell> {\n\n        // MapCellComparator() { /* ... */ }\n        public int compare(MapCell src, MapCell dst) {\n            return ((Float) depthvalue(src)).compareTo(depthvalue(dst));\n        }\n\n        /*if (src.y > src.x) {\n\t\tif (src.y > dst.y)\n\t\t    return 1;\n\t\tif (src.y < dst.y)\n\t\t    return -1;\n\t\treturn 0;\n\t    }\n\n\t    if (src.y < src.x) {\n\t\tif (src.x > dst.x)\n\t\t    return 1;\n\t\tif (src.x < dst.x)\n\t\t    return -1;\n\t\treturn 0;\n\t    }\n\t    \n\t    if (src.x+src.y > dst.x+dst.y)\n\t\treturn 1;\n\t    if (src.x+src.y < dst.x+dst.y)\n\t\treturn -1;\n\t\treturn 0;\n\t}*/\n        private float depthvalue(MapCell c) {\n            return (1000 * (float) c.x + 1001 * (float) c.y) / 1000 * 32;\n        }\n\n        public boolean equals(Object obj) {\n            return obj == this;\n        }\n    }\n\n    /**\n     * Creates a new instance of the Map class.\n     * @param fileName the name of the map to open.\n     */\n    public Map(String fileName) throws IOException {\n        open(fileName);\n    }\n\n    /**\n     * Open the specified map fileName.\n     * @param fileName the name of the file to open.\n     */\n    public Map open(String fileName) throws IOException {\n        //System.err.println(\"Map.open()\");\n        BufferedReader in = new BufferedReader(new FileReader(fileName));\n        StreamTokenizer st = new StreamTokenizer(in);\n        int j = 0, i = 0;\n        int[] tmp = new int[4];\n        //numOfCells = Integer.parseInt(in.readLine());\n        numOfCells = new int[N_LAYERS];\n        int readNumOfTiles = Integer.parseInt(in.readLine());\n        numOfTiles = Integer.parseInt(in.readLine());\n        cell = new MapCell[N_LAYERS][];\n        for (i = 0; i < N_LAYERS; i++) {\n            cell[i] = new MapCell[MAX_NUM_CELLS];\n        }\n        tileList = new MapTile[numOfTiles];\n        for (i = 0; i < numOfTiles; i++) {\n            tileList[i] = new MapTile(in.readLine());\n        }\n        j = 0;\n        int[] c = new int[N_LAYERS];\n        while (st.nextToken() != st.TT_EOF) {\n            if (j > 3) {\n                numOfCells[tmp[3]]++;\n                cell[tmp[3]][c[tmp[3]]++] = new MapCell(tmp[0], tmp[1], tmp[2], tmp[3]);\n                j = 0;\n            }\n            tmp[j++] = (int) st.nval;\n        }\n        if (j == 4) {\n            numOfCells[tmp[3]]++;\n            cell[tmp[3]][c[tmp[3]]++] = new MapCell(tmp[0], tmp[1], tmp[2], tmp[3]);\n            // System.err.println(\"Map.open(): Missing end of line!\");\n        }\n        //if ( != numOfCells) {\n        //    System.err.println(\"Map.open(): Unable to open file!\");\n        //}\n        in.close();\n        try {\n            MediaTracker tracker = new MediaTracker(new Frame());\n            for (MapTile t : tileList) {\n                tracker.addImage(t.image, 0);\n            }\n            //System.err.println(\"Map.open(): waiting for images!\");\n            tracker.waitForAll();\n        } catch (InterruptedException e) {\n            e.printStackTrace(System.err);\n        }\n        return this;\n    }\n\n    /**\n     * Lookup and return the MapCell at the specified x and y coordinates.\n     * Returns null if no MapCell is found. This method does a linear\n     * search through all the cells. This is considered a bug!\n     *\n     * @param x the x-coordinate of the MapCell.\n     * @param y the y-coordinate of the MapCell.\n     * @return The MapCell at the coordinates, or null if not exists.\n     */\n    public MapCell lookup(int x, int y) {\n        for (int i = numOfCells[PLAYER_LAYER] - 1; i >= 0; --i) {\n            if (round(cell[PLAYER_LAYER][i].x) == x && round(cell[PLAYER_LAYER][i].y) == y) {\n                return cell[PLAYER_LAYER][i];\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Converts the input coordinats in screen space to their respective\n     * coordinates in world space.\n     *\n     * @param x\n     * @param y\n     * @param z\n     */\n    public static Point pixelTransform(int x, int y, int z) {\n        return new Point(x + 2 * (y + z), y - (x + z) / 2);\n    }\n\n    /**\n     * Converts the input coordinats in world space to their respective\n     * coordinates in screen space.\n     *\n     * @param x\n     * @param y\n     * @param z\n     */\n    public static Point worldTransform(float x, float y) {\n        //return new Point( (int) ((x - z) / 2 - z - y),\n        //\t\t  (int) ((x + 2 * (y - z) + z) / 4));\n        x += GRID_OFFSET_X;\n        y += GRID_OFFSET_Y;\n        return new Point((int) (16 * (x - y)), (int) (8 * (y + x)));\n    }\n\n    /**\n     * Converts the input coordinats in world space to their respective\n     * coordinates in defined grid.\n     *\n     * @param x\n     * @param y\n     * @param z\n     */\n    public static Point gridTransform(int x, int y) {\n        /*int j = x - WORLD_OFFSET_X + GRID_OFFSET_X;\n\tint i = y + WORLD_OFFSET_Y + GRID_OFFSET_Y;\n\n\tj = (int) (j < 0 ? j / 32 - 0.5 : j / 32 + 1.5);\n\ti = (int) (i < 0 ? i / 16 - 0.5 : i / 16 + 1.5);\n\n\treturn new Point(j, i);*/\n        return new Point(round((float) x / 32 + (float) y / 16) - GRID_OFFSET_X, round((float) y / 16 - (float) x / 32) - GRID_OFFSET_Y);\n    }\n\n    public MapCell addPlayerCell(Player p) {\n        MapCell c = new MapPlayerCell(p);\n        cell[PLAYER_LAYER][numOfCells[PLAYER_LAYER]++] = c;\n        sortCells(PLAYER_LAYER);\n        playercells.put(p, c);\n        return c;\n    }\n\n    public void updatePlayerCell(Player p) {\n        if (p.isDead()) {\n            MapCell m = playercells.get(p);\n            m.tile = 39;\n        } else {\n            MapCell m = playercells.get(p);\n            m.x = p.getX();\n            m.y = p.getY();\n        }\n    }\n\n    public void sortCells(int layer) {\n        //System.err.print(\"Sorting... \");\n        Arrays.sort(cell[layer], 0, numOfCells[layer], new MapCellComparator());\n        //System.err.println(\"done!\");\n    }\n\n    /**\n     * Paints a layer of this map on a Graphics object.\n     */\n    public void draw(Graphics2D g, int layer) {\n        int i, z, w, h;\n        float x, y;\n        MapTile t;\n        Point p;\n        i = 0;\n        try {\n            for (i = 0; i < numOfCells[layer]; i++) {\n                x = cell[layer][i].x;\n                y = cell[layer][i].y;\n                z = cell[layer][i].tile;\n                /* check whether this cell should be drawn */\n                if (z != -1) {\n                    t = tileList[z];\n                    w = t.image.getWidth(null);\n                    h = t.image.getHeight(null);\n                    //p = worldTransform(x*32 + WORLD_OFFSET_X - 8 - w/2,\n                    //\t       y*16 - WORLD_OFFSET_Y - 4 + w/4, 74);\n                    p = worldTransform(x, y);\n                    g.drawImage(t.image, p.x - w / 2, p.y - h, null);\n                }\n            }\n        } catch (Exception e) {\n            System.err.printf(\"MapGrid.paint(): i=%d l=%d\\n\", i, cell.length);\n            e.printStackTrace(System.err);\n        }\n    }\n\n    public String toString() {\n        return \"Map[]\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/gui/MapTest5.java",
		"test_prompt": "// MapTest5.java\npackage gui;\n\nimport static java.lang.Math.max;\nimport static java.lang.Math.round;\nimport static java.lang.Math.sqrt;\nimport static java.lang.Math.pow;\nimport java.util.Comparator;\nimport java.util.Arrays;\nimport java.util.Hashtable;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.StreamTokenizer;\nimport java.io.IOException;\nimport java.awt.*;\nimport state.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Map}.\n* It contains ten unit test cases for the {@link Map#addPlayerCell(Player)} method.\n*/\nclass MapTest5 {"
	},
	{
		"original_code": "// WorldGLPanel.java\n/* $Id: WorldGLPanel.java,v 1.1 2004/05/01 22:12:42 emill Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n *\n * @author: Emil Lundstr�m <emill@kth.se>\n * @author: Joel Andersson <bja@kth.se>\n * @version: $Revision: 1.1 $\n *\n */\npackage gui;\n\nimport static java.lang.Math.cos;\nimport static java.lang.Math.sin;\nimport static java.lang.Math.atan2;\nimport static java.lang.Math.PI;\nimport static java.lang.Math.sqrt;\nimport module.GUIModule;\nimport java.awt.*;\nimport java.awt.image.*;\nimport java.awt.event.*;\nimport java.awt.geom.*;\nimport javax.swing.*;\nimport java.util.Observer;\nimport java.util.Observable;\nimport java.io.IOException;\nimport state.*;\nimport gui.gl.*;\n\n/**\n * This class provides a container for the world display.\n */\npublic class WorldGLPanel extends JPanel {\n\n    /**\n     * The module from which to receive events.\n     */\n    protected GUIModule source;\n\n    /**\n     * The gui frame this worldpanel belongs to.\n     */\n    protected GUIFrame frame;\n\n    /**\n     * The GL scene canvas.\n     */\n    protected XithMapRenderer xmr;\n\n    public XithMapRenderer getXMR() {\n        return xmr;\n    }\n\n    /**\n     * Creates a new WorldPanel.\n     * @param mod the event source for this class.\n     */\n    public WorldGLPanel(GUIModule mod, GUIFrame frm) {\n        frame = frm;\n        source = mod;\n        xmr = new XithMapRenderer(this, 512, 384);\n    }\n\n    public XithMapRenderer startXithRenderer() {\n        xmr.init();\n        new Thread(xmr).start();\n        return xmr;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/gui/WorldGLPanelTest.java",
		"test_prompt": "// WorldGLPanelTest.java\npackage gui;\n\nimport static java.lang.Math.cos;\nimport static java.lang.Math.sin;\nimport static java.lang.Math.atan2;\nimport static java.lang.Math.PI;\nimport static java.lang.Math.sqrt;\nimport module.GUIModule;\nimport java.awt.*;\nimport java.awt.image.*;\nimport java.awt.event.*;\nimport java.awt.geom.*;\nimport javax.swing.*;\nimport java.util.Observer;\nimport java.util.Observable;\nimport java.io.IOException;\nimport state.*;\nimport gui.gl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WorldGLPanel}.\n* It contains ten unit test cases for the {@link WorldGLPanel#startXithRenderer()} method.\n*/\nclass WorldGLPanelTest {"
	},
	{
		"original_code": "// PlayerTreeModel.java\n/* $Id: PlayerTreeModel.java,v 1.3 2004/05/02 01:52:45 emill Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n * \n * @author: Emil Lundstr�m <emill@kth.se>\n * @version: $Revision: 1.3 $\n *\n */\npackage gui;\n\nimport javax.swing.tree.*;\nimport javax.swing.event.*;\nimport state.*;\nimport java.util.Vector;\nimport java.util.LinkedList;\nimport java.util.Observer;\nimport java.util.Observable;\n\n/**\n * Provides a TreeModel representingen the GameState, to used in\n * the GroupPanel.\n */\npublic class PlayerTreeModel implements TreeModel, Observer {\n\n    private GameState state;\n\n    // basically a place holder\n    private Party root = new Party();\n\n    private Vector<TreeModelListener> treeModelListeners;\n\n    /**\n     * Creates a new TreeModel for the underlying GameState.\n     *\n     * @param state The underlying state.\n     * @param root The initial root.\n     */\n    public PlayerTreeModel() {\n        treeModelListeners = new Vector<TreeModelListener>();\n    }\n\n    /**\n     * Sets the state for this treemodel.\n     *\n     * @param state the game state.\n     * @see GameState\n     */\n    public void setState(GameState s) {\n        state = s;\n    }\n\n    /**\n     * Update defined in Observer interface.\n     *\n     * @param o The observable object.\n     * @param arg The argument passed to notifyObservers.\n     */\n    public void update(Observable o, Object arg) {\n        System.err.println(\"reloading grouptree\");\n        reload();\n        if (state != o)\n            System.err.println(\"ALERT! state != o in PTM.update()\");\n    }\n\n    /**\n     * Call this whenever the tree structure of GameState has been\n     * changed.\n     *\n     * @param changed The Player from which the change\n     * started. To be sure, use the root :).\n     */\n    protected void fireTreeStructureChanged(Party changed) {\n        TreeModelEvent e = new TreeModelEvent(this, new Object[] { changed });\n        for (TreeModelListener l : treeModelListeners) {\n            l.treeStructureChanged(e);\n        }\n    }\n\n    /**\n     * Call this when the tree structure has been changed.\n     */\n    public void reload() {\n        fireTreeStructureChanged(root);\n    }\n\n    // --- TreeModel interface ---\n    public void addTreeModelListener(TreeModelListener l) {\n        treeModelListeners.addElement(l);\n    }\n\n    public void removeTreeModelListener(TreeModelListener l) {\n        treeModelListeners.removeElement(l);\n    }\n\n    public Object getChild(Object parent, int index) {\n        // give the root special treatment\n        if (state == null)\n            return null;\n        if (parent == root) {\n            int i = 0;\n            for (Player player : state.players()) {\n                if (player != null && player.isBoss() && i++ == index) {\n                    return player;\n                }\n            }\n        } else {\n            LinkedList<Party> l = ((Party) parent).getSubparty();\n            l.remove(parent);\n            return l.get(index);\n        }\n        return null;\n    }\n\n    public int getChildCount(Object parent) {\n        if (state == null)\n            return 0;\n        // give the root special treatment\n        if (parent == root) {\n            int c = 0;\n            for (Player player : state.players()) {\n                if (player != null && player.isBoss()) {\n                    c++;\n                }\n            }\n            return c;\n        } else {\n            LinkedList<Party> l = ((Party) parent).getSubparty();\n            l.remove(parent);\n            return l.size();\n        }\n    }\n\n    /**\n     * Note: Does not follow standard. Should return -1 if either\n     * child or parent is not part of this model, which is never\n     * checked.\n     */\n    public int getIndexOfChild(Object parent, Object child) {\n        if (state == null || parent == null || child == null)\n            return -1;\n        if (parent == root) {\n            int i = 0;\n            for (Player player : state.players()) {\n                if (player != null && player.isBoss()) {\n                    if (player == child)\n                        return i;\n                    i++;\n                }\n            }\n        } else {\n            LinkedList<Party> l = ((Party) parent).getSubparty();\n            l.remove(parent);\n            return l.indexOf(child);\n        }\n        return -1;\n    }\n\n    public Object getRoot() {\n        return root;\n    }\n\n    public boolean isLeaf(Object node) {\n        Party p = (Party) node;\n        return (!p.isBoss() || (p.head == null && p != root));\n    }\n\n    /**\n     * Messaged when the user has altered the value for the item\n     * identified by path to newValue.  Not used by this model.\n     *\n     * FIX: Ripped from JAVA API EXAMPLE.\n     */\n    public void valueForPathChanged(TreePath path, Object newValue) {\n        System.out.println(\"*** valueForPathChanged : \" + path + \" --> \" + newValue);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/gui/PlayerTreeModelTest.java",
		"test_prompt": "// PlayerTreeModelTest.java\npackage gui;\n\nimport javax.swing.tree.*;\nimport javax.swing.event.*;\nimport state.*;\nimport java.util.Vector;\nimport java.util.LinkedList;\nimport java.util.Observer;\nimport java.util.Observable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PlayerTreeModel}.\n* It contains ten unit test cases for the {@link PlayerTreeModel#isLeaf(Object)} method.\n*/\nclass PlayerTreeModelTest {"
	},
	{
		"original_code": "// ChatPanel.java\n/* $Id: ChatPanel.java,v 1.6 2004/05/02 23:01:54 emill Exp $\n *\n * This software is hereby placed in the public domain. You are free to do\n * whatever you want with this software. It is distributed in hope that\n * someone will find it useful but without any warranties. \n *\n * @author: Bartek Tatkowski\n * @author: Emil Lundstr�m <emill@kth.se>\n * @version: $Revision: 1.6 $\n *\n */\npackage gui;\n\nimport java.awt.event.*;\nimport java.awt.BorderLayout;\nimport java.awt.Insets;\nimport javax.swing.JPanel;\nimport javax.swing.JLabel;\nimport javax.swing.JTabbedPane;\nimport javax.swing.JTextField;\nimport javax.swing.JTextArea;\nimport javax.swing.JScrollPane;\nimport javax.swing.JButton;\nimport java.util.ResourceBundle;\nimport java.util.Locale;\nimport java.util.Hashtable;\nimport module.GUIModule;\nimport module.Kernel;\nimport module.AbstractModule;\nimport module.Message;\nimport module.ModuleRegisterException;\nimport module.Module;\nimport module.MessageProcessingException;\nimport module.MessageDeliveryException;\nimport static module.MessageFactory.*;\n\n/**\n * The chat panel.\n */\npublic class ChatPanel extends JPanel {\n\n    /**\n     * Localized strings.\n     */\n    protected ResourceBundle locale;\n\n    /**\n     * The tabs representing different chat windows.\n     */\n    JTabbedPane tabs;\n\n    ChatListener chatlistener;\n\n    //DebugPanel debugPanel;\n    GUIModule module;\n\n    Hashtable<Object, ChatTabPanel> chattabs;\n\n    /**\n     * This class subscribes to every message topic, so it will\n     * receive all messages sent with null recipient.\n     */\n    @module.mod(name = \"SnoopyModule\")\n    private class SnoopyModule extends AbstractModule {\n\n        SnoopyModule(Kernel krn) throws ModuleRegisterException {\n            super(krn);\n        }\n\n        public void sendTextMessage(String topic, String data) {\n            try {\n                createMessage(topic, data).send(this);\n            } catch (MessageDeliveryException e) {\n                e.printStackTrace(System.err);\n            }\n        }\n\n        protected void processKernelMessage(Message m) throws MessageProcessingException {\n            try {\n                //debugPanel.append(m);\n                if (m.getBody().equals(\"REGISTERED\")) {\n                    subscribe(\"*\");\n                }\n            } catch (Exception e) {\n                throw new MessageProcessingException(this, m, e);\n            }\n        }\n\n        protected void processMessage(Message m) {\n            //debugPanel.append(m);\n        }\n    }\n\n    /**\n     * Creates a new ChatPanel.\n     */\n    public ChatPanel(GUIModule mod) {\n        module = mod;\n        locale = ResourceBundle.getBundle(\"gangup\", Locale.getDefault());\n        chatlistener = new ChatListener();\n        chattabs = new Hashtable<Object, ChatTabPanel>();\n        tabs = new JTabbedPane();\n        setLayout(new BorderLayout());\n        add(tabs, BorderLayout.CENTER);\n        addTab(module.GENERAL_MESSAGE);\n        addTab(module.GROUP_MESSAGE);\n        //try {\n        //SnoopyModule snoopy = new SnoopyModule(mod.getKernel());\n        //addDebugTab(snoopy);\n        //snoopy.start();\n        //} catch (ModuleRegisterException e) {\n        // e.printStackTrace(System.err);\n        //}\n        tabs.setSelectedComponent(chattabs.get(module.GENERAL_MESSAGE));\n        tabs.setTabLayoutPolicy(JTabbedPane.SCROLL_TAB_LAYOUT);\n    }\n\n    /**\n     * Adds a tab to the tabbed pane.\n     *\n     * @param name The identifying object of this tab. This must be\n     * the same object passed to a removeTab call, or when specifying\n     * which tab to write to with a writeTo call. Also, when text is\n     * written in this inputfield, this Object is sent as target.\n     * @return The tab just created.\n     */\n    public ChatTabPanel addTab(Object id) {\n        if (!chattabs.containsKey(id)) {\n            ChatTabPanel panel = new ChatTabPanel(id);\n            chattabs.put(id, panel);\n            tabs.add(panel, id.toString());\n            tabs.setSelectedComponent(panel);\n            return panel;\n        }\n        return null;\n    }\n\n    /*\n    private DebugPanel addDebugTab(Module source) {\n\tif (debugPanel == null) {\n\t    debugPanel = new DebugPanel(module.getKernel());\n\t    tabs.add(debugPanel,\"Debug\");\n\t}\n\treturn debugPanel;\n    }\n    */\n    /**\n     * Removes a tab to the tabbed pane.\n     *\n     * @param id The identifying object of this tab. This must be\n     * the same object passed to the addTab call, or when specifying\n     * which tab to write to with a writeTo call. Also, when text is\n     * written in this inputfield, this Object is sent as target.\n     */\n    public void removeTab(Object id) {\n        ChatTabPanel panel = chattabs.get(id);\n        tabs.remove(panel);\n        chattabs.remove(id);\n    }\n\n    /**\n     * Writes the specified text to the text area identified by id.\n     *\n     * @param id The identifying object of this tab. This must be\n     * the same object passed to the addTab call, or when specifying\n     * which tab to write to with a writeTo call. Also, when text is\n     * written in this inputfield, this Object is sent as target.\n     */\n    public void writeTo(Object id, String text) {\n        ChatTabPanel ctp = chattabs.get(id);\n        if (ctp == null) {\n            ctp = addTab(id);\n        }\n        ctp.outputarea.append(text + \"\\n\");\n        ctp.scroll.getVerticalScrollBar().setValue(ctp.scroll.getVerticalScrollBar().getMaximum());\n    }\n\n    /**\n     * Listener that listens if the player sends a message to the chat.\n     */\n    private class ChatListener extends KeyAdapter implements ActionListener {\n\n        /**\n         * Called whenever a key is typed.\n         */\n        public void keyTyped(KeyEvent e) {\n            if (e.getKeyChar() == KeyEvent.VK_ENTER) {\n                sendText();\n            }\n        }\n\n        private void sendText() {\n            ChatTabPanel p = (ChatTabPanel) tabs.getSelectedComponent();\n            JTextField txt = p.inputfield;\n            module.sendTextMessage(txt.getText(), p.identifier);\n            txt.setText(\"\");\n        }\n\n        public void actionPerformed(ActionEvent e) {\n            if (e.getActionCommand().equals(\"send\")) {\n                sendText();\n            } else if (e.getActionCommand().equals(\"close\")) {\n                ChatTabPanel p = (ChatTabPanel) tabs.getSelectedComponent();\n                if (p != chattabs.get(module.GENERAL_MESSAGE) && p != chattabs.get(module.GROUP_MESSAGE)) {\n                    removeTab(p.identifier);\n                }\n            }\n        }\n    }\n\n    private class ChatTabPanel extends JPanel {\n\n        Object identifier;\n\n        JTextField inputfield;\n\n        JButton inputsend;\n\n        JButton inputclose;\n\n        JTextArea outputarea;\n\n        JScrollPane scroll;\n\n        ChatTabPanel(Object id) {\n            identifier = id;\n            setLayout(new BorderLayout());\n            outputarea = new JTextArea();\n            outputarea.setEditable(false);\n            outputarea.setRows(5);\n            scroll = new JScrollPane(outputarea);\n            JPanel inputpanel = new JPanel();\n            inputfield = new JTextField();\n            JLabel inputtext = new JLabel(\" \" + locale.getString(\"_GUI_INPUTTEXT\") + \" \");\n            inputsend = new JButton(locale.getString(\"_GUI_SEND_BUTTON\"));\n            inputclose = new JButton(locale.getString(\"_GUI_CLOSE_BUTTON\"));\n            inputsend.setActionCommand(\"send\");\n            inputclose.setActionCommand(\"close\");\n            inputsend.addActionListener(chatlistener);\n            inputclose.addActionListener(chatlistener);\n            JPanel temp = new JPanel();\n            temp.setLayout(new BorderLayout());\n            temp.add(inputsend, BorderLayout.CENTER);\n            temp.add(inputclose, BorderLayout.EAST);\n            inputpanel.setLayout(new BorderLayout());\n            inputpanel.add(inputtext, BorderLayout.WEST);\n            inputpanel.add(inputfield, BorderLayout.CENTER);\n            inputpanel.add(temp, BorderLayout.EAST);\n            add(scroll, BorderLayout.CENTER);\n            add(inputpanel, BorderLayout.SOUTH);\n            inputfield.addKeyListener(chatlistener);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/gui/ChatPanelTest.java",
		"test_prompt": "// ChatPanelTest.java\npackage gui;\n\nimport java.awt.event.*;\nimport java.awt.BorderLayout;\nimport java.awt.Insets;\nimport javax.swing.JPanel;\nimport javax.swing.JLabel;\nimport javax.swing.JTabbedPane;\nimport javax.swing.JTextField;\nimport javax.swing.JTextArea;\nimport javax.swing.JScrollPane;\nimport javax.swing.JButton;\nimport java.util.ResourceBundle;\nimport java.util.Locale;\nimport java.util.Hashtable;\nimport module.GUIModule;\nimport module.Kernel;\nimport module.AbstractModule;\nimport module.Message;\nimport module.ModuleRegisterException;\nimport module.Module;\nimport module.MessageProcessingException;\nimport module.MessageDeliveryException;\nimport static module.MessageFactory.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ChatPanel}.\n* It contains ten unit test cases for the {@link ChatPanel#addTab(Object)} method.\n*/\nclass ChatPanelTest {"
	},
	{
		"original_code": "// FrameStats.java\n/* $Id: FrameStats.java,v 1.2 2004/04/27 19:26:21 bja Exp $ */\npackage gui.gl;\n\n// use the hidden high-resolution timer\nimport sun.misc.Perf;\nimport com.xith3d.render.CanvasPeer;\nimport com.xith3d.scenegraph.Canvas3D;\nimport com.xith3d.scenegraph.View;\nimport com.xith3d.spatial.bounds.Frustum;\nimport com.xith3d.scenegraph.Transform3D;\nimport com.xith3d.scenegraph.Node;\nimport com.xith3d.scenegraph.BranchGroup;\nimport com.xith3d.scenegraph.TransformGroup;\nimport com.xith3d.scenegraph.Leaf;\nimport com.xith3d.scenegraph.NodeUpdater;\nimport com.xith3d.datatypes.Coord3f;\n\n/**\n * This class provides various statistics for the rendered frame, such as\n * frame rate, frame time, and number of triangles. It uses Sun's builtin\n * timer, so it may not be compatible with other implementations.\n *\n * @author Jens Lehmann\n * @author Joel Andersson <bja@kth.se>\n */\npublic class FrameStats {\n\n    /**\n     */\n    private static FrameStats instance;\n\n    // the associated canvas.\n    private Canvas3D canvas;\n\n    // the hight-resolution timer object we are using to work\n    private Perf perf = sun.misc.Perf.getPerf();\n\n    // the number of ticks per second\n    private long ticksPerSecond = perf.highResFrequency();\n\n    // temporary variables used to calculate the framerate\n    private long lastSecondTicks = 0;\n\n    private long newFrameTicks = 0;\n\n    private int frameCounter = 0;\n\n    private int frameRate = 0;\n\n    // specifies if the counter should update automatically or not\n    private boolean autoUpdate = true;\n\n    // specifies whether this node is attached to the scene or not\n    private boolean attached = false;\n\n    // the number of rendered triangles.\n    private long triangles = 0;\n\n    /*\n     * Creates a new instance of this class. New instances are created with\n     * the newInstance method.\n     */\n    private FrameStats() {\n        this(null);\n    }\n\n    /**\n     * Creates a new instance of this class. New instances are created with\n     * the newInstance method.\n     *\n     * @param c the associated canvas.\n     */\n    private FrameStats(Canvas3D c) {\n        this.canvas = c;\n        if (instance == null) {\n            instance = this;\n        }\n    }\n\n    /**\n     * Update the frame rate and triangle count variables. Method must be\n     * called by everytime a frame has been rendered.\n     */\n    public void nextFrame() {\n        if (newFrameTicks == 0) {\n            // start time measurement\n            lastSecondTicks = perf.highResCounter();\n            newFrameTicks = lastSecondTicks;\n            frameCounter = 0;\n        } else {\n            // update number of frames and ticks\n            frameCounter++;\n            newFrameTicks = perf.highResCounter();\n            // update the counter every second\n            if (newFrameTicks - lastSecondTicks > ticksPerSecond) {\n                // copy the number of frames rendered.\n                frameRate = frameCounter;\n                // set the frame counter back\n                frameCounter = 0;\n                // add a \"second\"\n                lastSecondTicks += ticksPerSecond;\n            }\n        }\n        // Get number of triangles rendered.\n        triangles = canvas.get3DPeer().getTriangles();\n    }\n\n    /**\n     * Returns the number of frames rendered per second.\n     * @return the number of frames rendered per second.\n     */\n    public int getFrameRate() {\n        return frameRate;\n    }\n\n    /**\n     */\n    public long getTicksPerSecond() {\n        return ticksPerSecond;\n    }\n\n    /**\n     * Returns the number of rendered triangles.\n     * @return the number of rendered triangles.\n     */\n    public long getTriangleCount() {\n        return triangles;\n    }\n\n    public void setAutoUpdate(boolean auto) {\n        autoUpdate = auto;\n    }\n\n    public boolean getAutoUpdate() {\n        return autoUpdate;\n    }\n\n    public void attachScene(BranchGroup scene) {\n    }\n\n    public boolean getAttached() {\n        return attached;\n    }\n\n    public static FrameStats newInstance(View view) {\n        instance = new FrameStats(view.getCanvas3D(0));\n        return instance;\n    }\n\n    public static FrameStats getInstance() {\n        return instance;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/FrameStatsTest0.java",
		"test_prompt": "// FrameStatsTest0.java\npackage gui.gl;\n\n// use the hidden high-resolution timer\nimport sun.misc.Perf;\nimport com.xith3d.render.CanvasPeer;\nimport com.xith3d.scenegraph.Canvas3D;\nimport com.xith3d.scenegraph.View;\nimport com.xith3d.spatial.bounds.Frustum;\nimport com.xith3d.scenegraph.Transform3D;\nimport com.xith3d.scenegraph.Node;\nimport com.xith3d.scenegraph.BranchGroup;\nimport com.xith3d.scenegraph.TransformGroup;\nimport com.xith3d.scenegraph.Leaf;\nimport com.xith3d.scenegraph.NodeUpdater;\nimport com.xith3d.datatypes.Coord3f;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FrameStats}.\n* It contains ten unit test cases for the {@link FrameStats#newInstance(View)} method.\n*/\nclass FrameStatsTest0 {"
	},
	{
		"original_code": "// FrameStats.java\n/* $Id: FrameStats.java,v 1.2 2004/04/27 19:26:21 bja Exp $ */\npackage gui.gl;\n\n// use the hidden high-resolution timer\nimport sun.misc.Perf;\nimport com.xith3d.render.CanvasPeer;\nimport com.xith3d.scenegraph.Canvas3D;\nimport com.xith3d.scenegraph.View;\nimport com.xith3d.spatial.bounds.Frustum;\nimport com.xith3d.scenegraph.Transform3D;\nimport com.xith3d.scenegraph.Node;\nimport com.xith3d.scenegraph.BranchGroup;\nimport com.xith3d.scenegraph.TransformGroup;\nimport com.xith3d.scenegraph.Leaf;\nimport com.xith3d.scenegraph.NodeUpdater;\nimport com.xith3d.datatypes.Coord3f;\n\n/**\n * This class provides various statistics for the rendered frame, such as\n * frame rate, frame time, and number of triangles. It uses Sun's builtin\n * timer, so it may not be compatible with other implementations.\n *\n * @author Jens Lehmann\n * @author Joel Andersson <bja@kth.se>\n */\npublic class FrameStats {\n\n    /**\n     */\n    private static FrameStats instance;\n\n    // the associated canvas.\n    private Canvas3D canvas;\n\n    // the hight-resolution timer object we are using to work\n    private Perf perf = sun.misc.Perf.getPerf();\n\n    // the number of ticks per second\n    private long ticksPerSecond = perf.highResFrequency();\n\n    // temporary variables used to calculate the framerate\n    private long lastSecondTicks = 0;\n\n    private long newFrameTicks = 0;\n\n    private int frameCounter = 0;\n\n    private int frameRate = 0;\n\n    // specifies if the counter should update automatically or not\n    private boolean autoUpdate = true;\n\n    // specifies whether this node is attached to the scene or not\n    private boolean attached = false;\n\n    // the number of rendered triangles.\n    private long triangles = 0;\n\n    /*\n     * Creates a new instance of this class. New instances are created with\n     * the newInstance method.\n     */\n    private FrameStats() {\n        this(null);\n    }\n\n    /**\n     * Creates a new instance of this class. New instances are created with\n     * the newInstance method.\n     *\n     * @param c the associated canvas.\n     */\n    private FrameStats(Canvas3D c) {\n        this.canvas = c;\n        if (instance == null) {\n            instance = this;\n        }\n    }\n\n    /**\n     * Update the frame rate and triangle count variables. Method must be\n     * called by everytime a frame has been rendered.\n     */\n    public void nextFrame() {\n        if (newFrameTicks == 0) {\n            // start time measurement\n            lastSecondTicks = perf.highResCounter();\n            newFrameTicks = lastSecondTicks;\n            frameCounter = 0;\n        } else {\n            // update number of frames and ticks\n            frameCounter++;\n            newFrameTicks = perf.highResCounter();\n            // update the counter every second\n            if (newFrameTicks - lastSecondTicks > ticksPerSecond) {\n                // copy the number of frames rendered.\n                frameRate = frameCounter;\n                // set the frame counter back\n                frameCounter = 0;\n                // add a \"second\"\n                lastSecondTicks += ticksPerSecond;\n            }\n        }\n        // Get number of triangles rendered.\n        triangles = canvas.get3DPeer().getTriangles();\n    }\n\n    /**\n     * Returns the number of frames rendered per second.\n     * @return the number of frames rendered per second.\n     */\n    public int getFrameRate() {\n        return frameRate;\n    }\n\n    /**\n     */\n    public long getTicksPerSecond() {\n        return ticksPerSecond;\n    }\n\n    /**\n     * Returns the number of rendered triangles.\n     * @return the number of rendered triangles.\n     */\n    public long getTriangleCount() {\n        return triangles;\n    }\n\n    public void setAutoUpdate(boolean auto) {\n        autoUpdate = auto;\n    }\n\n    public boolean getAutoUpdate() {\n        return autoUpdate;\n    }\n\n    public void attachScene(BranchGroup scene) {\n    }\n\n    public boolean getAttached() {\n        return attached;\n    }\n\n    public static FrameStats newInstance(View view) {\n        instance = new FrameStats(view.getCanvas3D(0));\n        return instance;\n    }\n\n    public static FrameStats getInstance() {\n        return instance;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/FrameStatsTest1.java",
		"test_prompt": "// FrameStatsTest1.java\npackage gui.gl;\n\n// use the hidden high-resolution timer\nimport sun.misc.Perf;\nimport com.xith3d.render.CanvasPeer;\nimport com.xith3d.scenegraph.Canvas3D;\nimport com.xith3d.scenegraph.View;\nimport com.xith3d.spatial.bounds.Frustum;\nimport com.xith3d.scenegraph.Transform3D;\nimport com.xith3d.scenegraph.Node;\nimport com.xith3d.scenegraph.BranchGroup;\nimport com.xith3d.scenegraph.TransformGroup;\nimport com.xith3d.scenegraph.Leaf;\nimport com.xith3d.scenegraph.NodeUpdater;\nimport com.xith3d.datatypes.Coord3f;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FrameStats}.\n* It contains ten unit test cases for the {@link FrameStats#getInstance()} method.\n*/\nclass FrameStatsTest1 {"
	},
	{
		"original_code": "// ParticleManager.java\n/* $Id: ParticleManager.java,v 1.4 2004/05/04 19:42:07 emill Exp $\n *\n *\n * @author Emil Lundstr�m <emill@kth.se>\n */\npackage gui.gl;\n\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.datatypes.*;\nimport java.util.LinkedList;\nimport java.util.Stack;\n\n/**\n * A particle manages all particle systems.\n */\npublic class ParticleManager {\n\n    // milliseconds between updates\n    public static final int UPDATE_FREQUENCY = 10;\n\n    private long nextTime = 0;\n\n    private LinkedList<ParticleSystem> stock;\n\n    //private LinkedList<ParticleSystem> systemList =\n    //\tnew LinkedList<ParticleSystem>();\n    private TransformGroup systemGroup = new TransformGroup();\n\n    public ParticleManager() {\n        stock = new LinkedList<ParticleSystem>();\n    }\n\n    /**\n     * Update all systems this manager manages.\n     *\n     * @param c The transformation used for particle\n     * billboarding. Translation is omitted.\n     */\n    public void updateSystems(Transform3D c) {\n        long currentTime = System.currentTimeMillis();\n        if (currentTime > nextTime) {\n            LinkedList tmp = new LinkedList(systemGroup.getChildren());\n            for (Object p : tmp) {\n                ParticleSystem s = (ParticleSystem) p;\n                if (!s.updateSystem(c)) {\n                    systemGroup.removeChild(s);\n                    systemGroup.updateBounds(false);\n                    stock.add(s);\n                }\n            }\n            nextTime = currentTime + UPDATE_FREQUENCY;\n        }\n    }\n\n    /**\n     * Returns a TransformGroup containing all particles of this\n     * particle system.\n     */\n    public TransformGroup getParticles() {\n        return systemGroup;\n    }\n\n    /**\n     * Adds a new particle system.\n     *\n     * DEPRECATED: Preferred way to create a particle system is by\n     * using built in methods of ParticleManager, which incidentally\n     * haven't been written yet. This function will soon be private.\n     */\n    public void addParticleSystem(ParticleSystem s) {\n        systemGroup.addChild(s);\n        systemGroup.updateBounds(false);\n    }\n\n    /**\n     * Creates a new particle system.\n     *\n     * @param type The type of the new system, as specified in\n     * ParticleSystem constants.\n     * @param l The coordinate of this the new ParticleSystem in this\n     * ParticleManager's coordinate system, which typically should be\n     * equal to the world system.\n     * @param pc The desired particle count. If a unused particle\n     * system with the correct particle count is found, it will be\n     * used. Otherwise, a new one is allocated.\n     * @param lt The lifetime of the particle system.\n     */\n    public ParticleSystem createParticleSystem(int type, Coord3f l, int pc, int lt) {\n        ParticleSystem found = null;\n        for (ParticleSystem s : stock) {\n            if (s.getParticleCount() == pc) {\n                found = s;\n                break;\n            }\n        }\n        if (found == null) {\n            found = new ParticleSystem(this, type, l, pc, lt);\n        } else {\n            stock.remove(found);\n            found.newSystem(type, l, lt);\n        }\n        addParticleSystem(found);\n        return found;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/ParticleManagerTest.java",
		"test_prompt": "// ParticleManagerTest.java\npackage gui.gl;\n\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.datatypes.*;\nimport java.util.LinkedList;\nimport java.util.Stack;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ParticleManager}.\n* It contains ten unit test cases for the {@link ParticleManager#createParticleSystem(int, Coord3f, int, int)} method.\n*/\nclass ParticleManagerTest {"
	},
	{
		"original_code": "// World.java\n/* $Id: World.java,v 1.7 2004/05/02 23:01:54 emill Exp $ */\npackage gui.gl;\n\nimport static java.lang.Math.round;\nimport static gui.gl.Util3D.*;\nimport java.awt.geom.*;\nimport java.awt.Point;\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.loaders.texture.*;\nimport java.util.Iterator;\nimport map.TileMap;\nimport map.Path;\nimport map.PathNotFoundException;\nimport org.newdawn.xith3d.obj.OBJLoader;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.StreamTokenizer;\n\n/**\n * This class represents the world. All objects in the world are children\n * of this class.\n */\npublic class World extends TransformGroup {\n\n    /**\n     * The transform associated with this grid.\n     */\n    // private Transform3D transform;\n    /**\n     * The map associated with this world object.\n     */\n    private TileMap map;\n\n    /**\n     * The cells of the grid.\n     */\n    private TransformGroup[][] cells;\n\n    /**\n     * The geometry that make up the grid.\n     */\n    private Shape3D grid;\n\n    private int rows;\n\n    private int cols;\n\n    private float size;\n\n    private Node[] models;\n\n    /**\n     * The active cell marker.\n     */\n    private TransformGroup selected;\n\n    private TransformGroup actors;\n\n    private TransformGroup objects;\n\n    /**\n     * This is the offset vector used to center the grid.\n     */\n    private Vector3f offset;\n\n    private Transform3D center;\n\n    /**\n     * The physical bounds of this grid.\n     */\n    private Rectangle2D.Float bounds;\n\n    /**\n     */\n    private float roll = 0;\n\n    private float pitch = 0;\n\n    private float yaw = 0;\n\n    /**\n     */\n    //private float posX = 0;\n    //private float posY = 0;\n    //private float posZ = 0;\n    /**\n     * Create a new instance of the Grid class. The grid lies in the xz-plane,\n     * with origo at the bottom left corner.\n     *\n     * @param rows\n     * @param cols\n     * @param size\n     */\n    public World(int rows, int cols, float size) {\n        this.rows = rows;\n        this.cols = cols;\n        this.size = size;\n        cells = new TransformGroup[rows][cols];\n        actors = new TransformGroup();\n        objects = new TransformGroup();\n        /* Create the a visible grid system. */\n        grid = createGrid(rows, cols, size);\n        /* Compute grid bounds and use them to center the grid. */\n        bounds = new Rectangle2D.Float(0, 0, (cols) * size, (rows) * size);\n        offset = new Vector3f(-.5f * bounds.width, 0, -.5f * bounds.height);\n        center = new Transform3D();\n        center.setTranslation(offset);\n        setGridVisible(false);\n        addChild(grid);\n        addChild(actors);\n        addChild(objects);\n        actors.setPickable(true);\n        try {\n            map = new TileMap(0, 2, \"./dat/maps/test.map\", 1);\n            for (int i = 0; i < rows; i++) {\n                for (int j = 0; j < cols; j++) {\n                    map.Node n = map.getNodeAt(j, i);\n                    // System.err.print(n.getCost() + \" \");\n                    if (n.getCost() > 1.0f) {\n                        //System.err.println(\"x=\" + n.getX() + \" y=\"+ n.getY());\n                        //setCellTexture((int)(n.getX()+0.5f),\n                        //\t       (int)(n.getY()+0.5f),\"dirt.png\");\n                    }\n                }\n                // System.err.println();\n            }\n        } catch (java.io.IOException e) {\n            e.printStackTrace(System.err);\n        }\n    }\n\n    /**\n     * Adds an actor to the this world object.\n     * @param a the actor to add.\n     */\n    public void addActor(Actor a) {\n        a.setWorld(this);\n        actors.addChild(a);\n    }\n\n    //public void addChild(Actor actor) {\n    //actor.setWorld(this);\n    //actors.addChild(actor);\n    //}\n    /**\n     * Removes the specified actor from this world.\n     * @param a the actor to remove.\n     */\n    public void removeActor(Actor a) {\n        actors.removeChild(a);\n        a.setWorld(null);\n    }\n\n    public void removeAllActors() {\n        removeChild(actors);\n        actors = new TransformGroup();\n        addChild(actors);\n        actors.setPickable(true);\n    }\n\n    /**\n     * Loads the scene from the specified file.\n     * @param path the file from which to load the scene.\n     */\n    public void load(String path) {\n        //throws java.io.IOException {\n    }\n\n    public void save(String path) {\n        //throws java.io.IOException {\n    }\n\n    public Path findPath(int srcX, int srcY, int dstX, int dstY) throws PathNotFoundException {\n        map.Node src = map.getNodeAt(srcX, srcY);\n        map.Node dst = map.getNodeAt(dstX, dstY);\n        map.reset();\n        return map.coalescePath(map.search(src, dst));\n    }\n\n    /**\n     * Rotates the grid the specified number of degrees around\n     * the given axes.\n     *\n     * @param rotx\n     * @param roty\n     * @param rotz\n     */\n    public void rotXYZ(float rotx, float roty, float rotz) {\n        roll = rotx;\n        yaw = roty;\n        pitch = rotz;\n    }\n\n    public void panX(float dist) {\n        offset.x += dist;\n    }\n\n    public void panY(float dist) {\n        offset.y += dist;\n    }\n\n    public void panZ(float dist) {\n        offset.z += dist;\n    }\n\n    /**\n     * Returns the position of this grid.\n     * @return the position of this grid.\n     */\n    public Point3f getPosition() {\n        return new Point3f(offset);\n    }\n\n    /**\n     * Returns the orientation of this grid.\n     * @return the orientation of this grid.\n     */\n    public Vector3f getOrientation() {\n        return new Vector3f(roll, yaw, pitch);\n    }\n\n    /**\n     * Sets the orienation of this grid to the specified vector.\n     * @param v the new orientation of this grid.\n     */\n    public void setOrientation(Vector3f v) {\n        roll = v.x;\n        yaw = v.y;\n        pitch = v.z;\n    }\n\n    /**\n     * Calculate the intersection point of the specified ray with\n     * this Grid.\n     *\n     * @param r the intersecting ray.\n     * @return the intersection point of the ray and this grid or null\n     *         if the ray is paralell to the grid.\n     */\n    public Point3f intersect(PickRay r) {\n        // ray direction in world space.\n        Vector3f v = r.getDirection();\n        // ray origin in world space.\n        Point3f p = r.getOrigin();\n        // intersection point in grid space.\n        Point3f q = null;\n        // world to grid transform.\n        Transform3D tf = null;\n        // Get a copy of the grid transform.\n        tf = new Transform3D(getTransform());\n        // Transform the ray by the inverse grid transform. This way we\n        // get the ray in grid coordinate space.\n        tf.invert();\n        tf.transform(p);\n        tf.transform(v);\n        // Check that the ray is not parallell to the grid.\n        if (v.y != 0) {\n            // Assume that the grid lies in the xz-plane. It will always\n            // lie in the xz-plane!\n            float t = (offset.y - p.y) / v.y;\n            q = new Point3f(p.x + t * v.x, 0.0f, p.z + t * v.z);\n        }\n        return q;\n    }\n\n    /**\n     * Returns the grid cell corresponding to the given grid coordinate.\n     * @return the grid cell corresponding to the given grid coordinate.\n     */\n    public Point gridCoordToCell(Point3f p) {\n        return new Point(round(p.x / size - 0.5f), round(p.z / size - 0.5f));\n    }\n\n    /**\n     * Sets the background texture of this grid.\n     * @param tex the texture to set as background.\n     */\n    public void setTexture(String tex) {\n        TextureAttributes[] textureAttrs = new TextureAttributes[2];\n        TextureUnitState[] textureUnitStates = new TextureUnitState[2];\n        Texture2D[] textures = new Texture2D[2];\n        try {\n            TextureLoader tl = TextureLoader.getInstance();\n            // these paths should be registered elsewhere.\n            tl.registerPath(\"./\");\n            tl.registerPath(\"./dat/mdl\");\n            tl.registerPath(\"./dat/tex\");\n            tl.registerPath(\"./dat/gfx\");\n            textures[0] = (Texture2D) tl.getMinMapTexture(\"grass2.png\");\n            textures[1] = (Texture2D) tl.getMinMapTexture(\"stone.png\");\n            textureAttrs[0] = new TextureAttributes();\n            textureAttrs[0].setTextureMode(TextureAttributes.DECAL);\n            textureAttrs[1] = new TextureAttributes();\n            textureAttrs[1].setTextureMode(TextureAttributes.MODULATE);\n            textureUnitStates[0] = new TextureUnitState(textures[0], textureAttrs[0], null);\n            textureUnitStates[1] = new TextureUnitState(textures[1], textureAttrs[1], null);\n            // Set polygon offset so that we can see objects lying in the\n            // same plane as the grid.\n            PolygonAttributes polyAttr = new PolygonAttributes();\n            polyAttr.setPolygonOffset(10.0f);\n            polyAttr.setPolygonOffsetFactor(20.0f);\n            Appearance a = new Appearance();\n            a.setTextureUnitState(textureUnitStates);\n            a.setPolygonAttributes(polyAttr);\n            addChild(new Shape3D(createQuad(0f, 0f, cols * size, 1f, 2 * cols), a));\n        } catch (Exception e) {\n            e.printStackTrace(System.err);\n        }\n    }\n\n    /**\n     * Sets the texture of the cell at the specified coordinates\n     * given in grid space. If name is null or empty string, then\n     * the specified cell's texture will be removed.\n     *\n     * @param row the cell row coordinate.\n     * @param col the cell column coordinate.\n     * @param name the texture to set to the cell. If it is null then\n     *             the current texture will be removed from the cell.\n     */\n    public void setCellTexture(int row, int col, String name, boolean blend) {\n        TransformGroup tg = null;\n        Shape3D sh = null;\n        try {\n            tg = getCellNode(row, col);\n        } catch (ArrayIndexOutOfBoundsException e) {\n            // craps!\n            return;\n        }\n        if (name == null || name.length() == 0) {\n            removeChild(tg);\n            setCellNode(row, col, null);\n            return;\n        }\n        if (tg == null) {\n            tg = new TransformGroup();\n            //sh = new Shape3D(createPlane(size, 1));\n            //setTexture2D(sh, \"./dat/tex/\" + name,blend,blend,true);\n            sh = createTexturedPlane(name, size, 1);\n            tg.addChild(sh);\n            setCellNode(row, col, tg);\n            addChild(tg);\n        } else {\n            sh = (Shape3D) tg.getChild(0);\n            TextureLoader tl = TextureLoader.getInstance();\n            Texture2D tex = (Texture2D) tl.getMinMapTexture(name);\n            //setTexture2D(sh,\"./dat/tex/\" + name,blend,blend,true);\n        }\n        Vector3f pos = new Vector3f(row * size, 0.01f, col * size);\n        Transform3D tf = tg.getTransform();\n        tf.setTranslation(pos);\n        tg.setTransform(tf);\n    }\n\n    public void setCellTexture(int row, int col, String name) {\n        setCellTexture(row, col, name, false);\n    }\n\n    public void setCellNode(int row, int col, TransformGroup tg) {\n        cells[row][col] = tg;\n    }\n\n    public TransformGroup getCellNode(int row, int col) {\n        return cells[row][col];\n    }\n\n    /**\n     * Sets the active cell given by the row and col coordinates.\n     *\n     * @param row the active cell row coordinate.\n     * @param col the active cell column coordinate.\n     */\n    public void setActiveCell(int row, int col) {\n        if (selected != null) {\n            Transform3D tf = selected.getTransform();\n            tf.setTranslation(new Vector3f(row * size, 0.01f, col * size));\n        } else {\n            // create the active cell marker\n            selected = new TransformGroup();\n            Vector3f pos = new Vector3f(row * size, 0.01f, col * size);\n            Appearance ap = new Appearance();\n            setTexture2D(\"dat/tex/active.png\", ap);\n            selected.getTransform().setTranslation(pos);\n            selected.addChild(new Shape3D(createPlane(size, 1.0f), ap));\n            addChild(selected);\n            /*\n\n\t    // enable transparency.\n\t    TransparencyAttributes tcattr = new TransparencyAttributes();\n\t    tcattr.setTransparency(0.5f);\n\t    tcattr.setMode(TransparencyAttributes.BLENDED);\n\t    a.setTransparencyAttributes(tcattr);\n\t    sh.setAppearance(a);\n\n\t    // set the line width\n\t    LineAttributes attr = new LineAttributes();\n\t    attr.setLineWidth(1f);\n\t    attr.setLineAntialiasingEnable(true);\n\t    //a.setLineAttributes(attr);\n\n\t    // disable depth buffer test for this shape\n\t    RenderingAttributes attr1 = new RenderingAttributes();\n\t    attr1.setDepthBufferEnable(false);\n\t    a.setRenderingAttributes(attr1);\n\n\t    Color3f lineColor = new Color3f(1,1,0);\n\t    Shape3D rect = new Shape3D(createRectangle(size,size,lineColor)));\n\t    selected.addChild(rect);\n\t\t\t\t          \n            */\n        }\n    }\n\n    /**\n     * Updates and renders the grid. Since scene graph operations must\n     * be carried out from the same thread, we keep all such operations\n     * in this method and call it once from the main rendering loop.\n     */\n    public void render() {\n        Transform3D tf = getTransform();\n        Transform3D centering = new Transform3D();\n        centering.setTranslation(offset);\n        //center.getTranslation(pos);\n        //pos.x = posX;\n        //pos.y = posY;\n        //pos.z = posZ;\n        //center.setTranslation(offset);\n        tf.rotXYZ(roll, yaw, pitch);\n        tf.mul(centering);\n        setTransform(tf);\n    }\n\n    /**\n     * Enables or disables the display of the grid.\n     * @param enable true if the grid should be visible otherwise false.\n     */\n    public void setGridVisible(boolean enable) {\n        Appearance ap = null;\n        RenderingAttributes attr = null;\n        try {\n            ap = grid.getAppearance();\n            attr = ap.getRenderingAttributes();\n            attr.setVisible(enable);\n        } catch (NullPointerException e) {\n            if (ap == null) {\n                ap = new Appearance();\n                grid.setAppearance(ap);\n            }\n            if (attr == null) {\n                attr = new RenderingAttributes();\n                attr.setVisible(enable);\n            }\n        }\n        ap.setRenderingAttributes(attr);\n    }\n\n    /**\n     * Returns true if the grid is visible otherwise false.\n     * @return true if the grid is visible otherwise false.\n     */\n    public boolean getGridVisible() {\n        boolean visible = false;\n        try {\n            Appearance ap = grid.getAppearance();\n            RenderingAttributes attr = ap.getRenderingAttributes();\n            visible = attr.getVisible();\n        } catch (NullPointerException e) {\n            // e.printStackTrace(System.err);\n        }\n        return visible;\n    }\n\n    protected void open(String fileName) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(fileName));\n        StreamTokenizer st = new StreamTokenizer(in);\n        int j = 0, i = 0;\n        int[] tmp = new int[3];\n        // throw away tile info\n        int numOfTiles = Integer.parseInt(in.readLine());\n        models = new Node[numOfTiles];\n        for (i = 0; i < numOfTiles; i++) {\n            String modelname = in.readLine();\n            BranchGroup mdl = new OBJLoader().load(modelname);\n            models[i] = mdl.getChild(0);\n        }\n        int numOfObjs = Integer.parseInt(in.readLine());\n        i = j = 0;\n        while (st.nextToken() != st.TT_EOF && i++ < numOfObjs * tmp.length + 1) {\n            if (j >= tmp.length) {\n                TransformGroup tg = new TransformGroup();\n                Transform3D t = new Transform3D();\n                Node model = new Shape3D();\n                tg.getTransform(t);\n                model = model.sharedCopy(models[tmp[2]]);\n                t.setTranslation(new Vector3f((float) tmp[0] * size + 0.5f, 0.0f, (float) tmp[1] * size + 0.5f));\n                System.err.println(new Vector3f((float) tmp[0] * size, 0.0f, (float) tmp[1] * size));\n                tg.setTransform(t);\n                tg.addChild(model);\n                objects.addChild(tg);\n                j = 0;\n            }\n            tmp[j++] = (int) st.nval;\n        }\n        in.close();\n        objects.updateBounds(true);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/WorldTest0.java",
		"test_prompt": "// WorldTest0.java\npackage gui.gl;\n\nimport static java.lang.Math.round;\nimport static gui.gl.Util3D.*;\nimport java.awt.geom.*;\nimport java.awt.Point;\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.loaders.texture.*;\nimport java.util.Iterator;\nimport map.TileMap;\nimport map.Path;\nimport map.PathNotFoundException;\nimport org.newdawn.xith3d.obj.OBJLoader;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.StreamTokenizer;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link World}.\n* It contains ten unit test cases for the {@link World#findPath(int, int, int, int)} method.\n*/\nclass WorldTest0 {"
	},
	{
		"original_code": "// World.java\n/* $Id: World.java,v 1.7 2004/05/02 23:01:54 emill Exp $ */\npackage gui.gl;\n\nimport static java.lang.Math.round;\nimport static gui.gl.Util3D.*;\nimport java.awt.geom.*;\nimport java.awt.Point;\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.loaders.texture.*;\nimport java.util.Iterator;\nimport map.TileMap;\nimport map.Path;\nimport map.PathNotFoundException;\nimport org.newdawn.xith3d.obj.OBJLoader;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.StreamTokenizer;\n\n/**\n * This class represents the world. All objects in the world are children\n * of this class.\n */\npublic class World extends TransformGroup {\n\n    /**\n     * The transform associated with this grid.\n     */\n    // private Transform3D transform;\n    /**\n     * The map associated with this world object.\n     */\n    private TileMap map;\n\n    /**\n     * The cells of the grid.\n     */\n    private TransformGroup[][] cells;\n\n    /**\n     * The geometry that make up the grid.\n     */\n    private Shape3D grid;\n\n    private int rows;\n\n    private int cols;\n\n    private float size;\n\n    private Node[] models;\n\n    /**\n     * The active cell marker.\n     */\n    private TransformGroup selected;\n\n    private TransformGroup actors;\n\n    private TransformGroup objects;\n\n    /**\n     * This is the offset vector used to center the grid.\n     */\n    private Vector3f offset;\n\n    private Transform3D center;\n\n    /**\n     * The physical bounds of this grid.\n     */\n    private Rectangle2D.Float bounds;\n\n    /**\n     */\n    private float roll = 0;\n\n    private float pitch = 0;\n\n    private float yaw = 0;\n\n    /**\n     */\n    //private float posX = 0;\n    //private float posY = 0;\n    //private float posZ = 0;\n    /**\n     * Create a new instance of the Grid class. The grid lies in the xz-plane,\n     * with origo at the bottom left corner.\n     *\n     * @param rows\n     * @param cols\n     * @param size\n     */\n    public World(int rows, int cols, float size) {\n        this.rows = rows;\n        this.cols = cols;\n        this.size = size;\n        cells = new TransformGroup[rows][cols];\n        actors = new TransformGroup();\n        objects = new TransformGroup();\n        /* Create the a visible grid system. */\n        grid = createGrid(rows, cols, size);\n        /* Compute grid bounds and use them to center the grid. */\n        bounds = new Rectangle2D.Float(0, 0, (cols) * size, (rows) * size);\n        offset = new Vector3f(-.5f * bounds.width, 0, -.5f * bounds.height);\n        center = new Transform3D();\n        center.setTranslation(offset);\n        setGridVisible(false);\n        addChild(grid);\n        addChild(actors);\n        addChild(objects);\n        actors.setPickable(true);\n        try {\n            map = new TileMap(0, 2, \"./dat/maps/test.map\", 1);\n            for (int i = 0; i < rows; i++) {\n                for (int j = 0; j < cols; j++) {\n                    map.Node n = map.getNodeAt(j, i);\n                    // System.err.print(n.getCost() + \" \");\n                    if (n.getCost() > 1.0f) {\n                        //System.err.println(\"x=\" + n.getX() + \" y=\"+ n.getY());\n                        //setCellTexture((int)(n.getX()+0.5f),\n                        //\t       (int)(n.getY()+0.5f),\"dirt.png\");\n                    }\n                }\n                // System.err.println();\n            }\n        } catch (java.io.IOException e) {\n            e.printStackTrace(System.err);\n        }\n    }\n\n    /**\n     * Adds an actor to the this world object.\n     * @param a the actor to add.\n     */\n    public void addActor(Actor a) {\n        a.setWorld(this);\n        actors.addChild(a);\n    }\n\n    //public void addChild(Actor actor) {\n    //actor.setWorld(this);\n    //actors.addChild(actor);\n    //}\n    /**\n     * Removes the specified actor from this world.\n     * @param a the actor to remove.\n     */\n    public void removeActor(Actor a) {\n        actors.removeChild(a);\n        a.setWorld(null);\n    }\n\n    public void removeAllActors() {\n        removeChild(actors);\n        actors = new TransformGroup();\n        addChild(actors);\n        actors.setPickable(true);\n    }\n\n    /**\n     * Loads the scene from the specified file.\n     * @param path the file from which to load the scene.\n     */\n    public void load(String path) {\n        //throws java.io.IOException {\n    }\n\n    public void save(String path) {\n        //throws java.io.IOException {\n    }\n\n    public Path findPath(int srcX, int srcY, int dstX, int dstY) throws PathNotFoundException {\n        map.Node src = map.getNodeAt(srcX, srcY);\n        map.Node dst = map.getNodeAt(dstX, dstY);\n        map.reset();\n        return map.coalescePath(map.search(src, dst));\n    }\n\n    /**\n     * Rotates the grid the specified number of degrees around\n     * the given axes.\n     *\n     * @param rotx\n     * @param roty\n     * @param rotz\n     */\n    public void rotXYZ(float rotx, float roty, float rotz) {\n        roll = rotx;\n        yaw = roty;\n        pitch = rotz;\n    }\n\n    public void panX(float dist) {\n        offset.x += dist;\n    }\n\n    public void panY(float dist) {\n        offset.y += dist;\n    }\n\n    public void panZ(float dist) {\n        offset.z += dist;\n    }\n\n    /**\n     * Returns the position of this grid.\n     * @return the position of this grid.\n     */\n    public Point3f getPosition() {\n        return new Point3f(offset);\n    }\n\n    /**\n     * Returns the orientation of this grid.\n     * @return the orientation of this grid.\n     */\n    public Vector3f getOrientation() {\n        return new Vector3f(roll, yaw, pitch);\n    }\n\n    /**\n     * Sets the orienation of this grid to the specified vector.\n     * @param v the new orientation of this grid.\n     */\n    public void setOrientation(Vector3f v) {\n        roll = v.x;\n        yaw = v.y;\n        pitch = v.z;\n    }\n\n    /**\n     * Calculate the intersection point of the specified ray with\n     * this Grid.\n     *\n     * @param r the intersecting ray.\n     * @return the intersection point of the ray and this grid or null\n     *         if the ray is paralell to the grid.\n     */\n    public Point3f intersect(PickRay r) {\n        // ray direction in world space.\n        Vector3f v = r.getDirection();\n        // ray origin in world space.\n        Point3f p = r.getOrigin();\n        // intersection point in grid space.\n        Point3f q = null;\n        // world to grid transform.\n        Transform3D tf = null;\n        // Get a copy of the grid transform.\n        tf = new Transform3D(getTransform());\n        // Transform the ray by the inverse grid transform. This way we\n        // get the ray in grid coordinate space.\n        tf.invert();\n        tf.transform(p);\n        tf.transform(v);\n        // Check that the ray is not parallell to the grid.\n        if (v.y != 0) {\n            // Assume that the grid lies in the xz-plane. It will always\n            // lie in the xz-plane!\n            float t = (offset.y - p.y) / v.y;\n            q = new Point3f(p.x + t * v.x, 0.0f, p.z + t * v.z);\n        }\n        return q;\n    }\n\n    /**\n     * Returns the grid cell corresponding to the given grid coordinate.\n     * @return the grid cell corresponding to the given grid coordinate.\n     */\n    public Point gridCoordToCell(Point3f p) {\n        return new Point(round(p.x / size - 0.5f), round(p.z / size - 0.5f));\n    }\n\n    /**\n     * Sets the background texture of this grid.\n     * @param tex the texture to set as background.\n     */\n    public void setTexture(String tex) {\n        TextureAttributes[] textureAttrs = new TextureAttributes[2];\n        TextureUnitState[] textureUnitStates = new TextureUnitState[2];\n        Texture2D[] textures = new Texture2D[2];\n        try {\n            TextureLoader tl = TextureLoader.getInstance();\n            // these paths should be registered elsewhere.\n            tl.registerPath(\"./\");\n            tl.registerPath(\"./dat/mdl\");\n            tl.registerPath(\"./dat/tex\");\n            tl.registerPath(\"./dat/gfx\");\n            textures[0] = (Texture2D) tl.getMinMapTexture(\"grass2.png\");\n            textures[1] = (Texture2D) tl.getMinMapTexture(\"stone.png\");\n            textureAttrs[0] = new TextureAttributes();\n            textureAttrs[0].setTextureMode(TextureAttributes.DECAL);\n            textureAttrs[1] = new TextureAttributes();\n            textureAttrs[1].setTextureMode(TextureAttributes.MODULATE);\n            textureUnitStates[0] = new TextureUnitState(textures[0], textureAttrs[0], null);\n            textureUnitStates[1] = new TextureUnitState(textures[1], textureAttrs[1], null);\n            // Set polygon offset so that we can see objects lying in the\n            // same plane as the grid.\n            PolygonAttributes polyAttr = new PolygonAttributes();\n            polyAttr.setPolygonOffset(10.0f);\n            polyAttr.setPolygonOffsetFactor(20.0f);\n            Appearance a = new Appearance();\n            a.setTextureUnitState(textureUnitStates);\n            a.setPolygonAttributes(polyAttr);\n            addChild(new Shape3D(createQuad(0f, 0f, cols * size, 1f, 2 * cols), a));\n        } catch (Exception e) {\n            e.printStackTrace(System.err);\n        }\n    }\n\n    /**\n     * Sets the texture of the cell at the specified coordinates\n     * given in grid space. If name is null or empty string, then\n     * the specified cell's texture will be removed.\n     *\n     * @param row the cell row coordinate.\n     * @param col the cell column coordinate.\n     * @param name the texture to set to the cell. If it is null then\n     *             the current texture will be removed from the cell.\n     */\n    public void setCellTexture(int row, int col, String name, boolean blend) {\n        TransformGroup tg = null;\n        Shape3D sh = null;\n        try {\n            tg = getCellNode(row, col);\n        } catch (ArrayIndexOutOfBoundsException e) {\n            // craps!\n            return;\n        }\n        if (name == null || name.length() == 0) {\n            removeChild(tg);\n            setCellNode(row, col, null);\n            return;\n        }\n        if (tg == null) {\n            tg = new TransformGroup();\n            //sh = new Shape3D(createPlane(size, 1));\n            //setTexture2D(sh, \"./dat/tex/\" + name,blend,blend,true);\n            sh = createTexturedPlane(name, size, 1);\n            tg.addChild(sh);\n            setCellNode(row, col, tg);\n            addChild(tg);\n        } else {\n            sh = (Shape3D) tg.getChild(0);\n            TextureLoader tl = TextureLoader.getInstance();\n            Texture2D tex = (Texture2D) tl.getMinMapTexture(name);\n            //setTexture2D(sh,\"./dat/tex/\" + name,blend,blend,true);\n        }\n        Vector3f pos = new Vector3f(row * size, 0.01f, col * size);\n        Transform3D tf = tg.getTransform();\n        tf.setTranslation(pos);\n        tg.setTransform(tf);\n    }\n\n    public void setCellTexture(int row, int col, String name) {\n        setCellTexture(row, col, name, false);\n    }\n\n    public void setCellNode(int row, int col, TransformGroup tg) {\n        cells[row][col] = tg;\n    }\n\n    public TransformGroup getCellNode(int row, int col) {\n        return cells[row][col];\n    }\n\n    /**\n     * Sets the active cell given by the row and col coordinates.\n     *\n     * @param row the active cell row coordinate.\n     * @param col the active cell column coordinate.\n     */\n    public void setActiveCell(int row, int col) {\n        if (selected != null) {\n            Transform3D tf = selected.getTransform();\n            tf.setTranslation(new Vector3f(row * size, 0.01f, col * size));\n        } else {\n            // create the active cell marker\n            selected = new TransformGroup();\n            Vector3f pos = new Vector3f(row * size, 0.01f, col * size);\n            Appearance ap = new Appearance();\n            setTexture2D(\"dat/tex/active.png\", ap);\n            selected.getTransform().setTranslation(pos);\n            selected.addChild(new Shape3D(createPlane(size, 1.0f), ap));\n            addChild(selected);\n            /*\n\n\t    // enable transparency.\n\t    TransparencyAttributes tcattr = new TransparencyAttributes();\n\t    tcattr.setTransparency(0.5f);\n\t    tcattr.setMode(TransparencyAttributes.BLENDED);\n\t    a.setTransparencyAttributes(tcattr);\n\t    sh.setAppearance(a);\n\n\t    // set the line width\n\t    LineAttributes attr = new LineAttributes();\n\t    attr.setLineWidth(1f);\n\t    attr.setLineAntialiasingEnable(true);\n\t    //a.setLineAttributes(attr);\n\n\t    // disable depth buffer test for this shape\n\t    RenderingAttributes attr1 = new RenderingAttributes();\n\t    attr1.setDepthBufferEnable(false);\n\t    a.setRenderingAttributes(attr1);\n\n\t    Color3f lineColor = new Color3f(1,1,0);\n\t    Shape3D rect = new Shape3D(createRectangle(size,size,lineColor)));\n\t    selected.addChild(rect);\n\t\t\t\t          \n            */\n        }\n    }\n\n    /**\n     * Updates and renders the grid. Since scene graph operations must\n     * be carried out from the same thread, we keep all such operations\n     * in this method and call it once from the main rendering loop.\n     */\n    public void render() {\n        Transform3D tf = getTransform();\n        Transform3D centering = new Transform3D();\n        centering.setTranslation(offset);\n        //center.getTranslation(pos);\n        //pos.x = posX;\n        //pos.y = posY;\n        //pos.z = posZ;\n        //center.setTranslation(offset);\n        tf.rotXYZ(roll, yaw, pitch);\n        tf.mul(centering);\n        setTransform(tf);\n    }\n\n    /**\n     * Enables or disables the display of the grid.\n     * @param enable true if the grid should be visible otherwise false.\n     */\n    public void setGridVisible(boolean enable) {\n        Appearance ap = null;\n        RenderingAttributes attr = null;\n        try {\n            ap = grid.getAppearance();\n            attr = ap.getRenderingAttributes();\n            attr.setVisible(enable);\n        } catch (NullPointerException e) {\n            if (ap == null) {\n                ap = new Appearance();\n                grid.setAppearance(ap);\n            }\n            if (attr == null) {\n                attr = new RenderingAttributes();\n                attr.setVisible(enable);\n            }\n        }\n        ap.setRenderingAttributes(attr);\n    }\n\n    /**\n     * Returns true if the grid is visible otherwise false.\n     * @return true if the grid is visible otherwise false.\n     */\n    public boolean getGridVisible() {\n        boolean visible = false;\n        try {\n            Appearance ap = grid.getAppearance();\n            RenderingAttributes attr = ap.getRenderingAttributes();\n            visible = attr.getVisible();\n        } catch (NullPointerException e) {\n            // e.printStackTrace(System.err);\n        }\n        return visible;\n    }\n\n    protected void open(String fileName) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(fileName));\n        StreamTokenizer st = new StreamTokenizer(in);\n        int j = 0, i = 0;\n        int[] tmp = new int[3];\n        // throw away tile info\n        int numOfTiles = Integer.parseInt(in.readLine());\n        models = new Node[numOfTiles];\n        for (i = 0; i < numOfTiles; i++) {\n            String modelname = in.readLine();\n            BranchGroup mdl = new OBJLoader().load(modelname);\n            models[i] = mdl.getChild(0);\n        }\n        int numOfObjs = Integer.parseInt(in.readLine());\n        i = j = 0;\n        while (st.nextToken() != st.TT_EOF && i++ < numOfObjs * tmp.length + 1) {\n            if (j >= tmp.length) {\n                TransformGroup tg = new TransformGroup();\n                Transform3D t = new Transform3D();\n                Node model = new Shape3D();\n                tg.getTransform(t);\n                model = model.sharedCopy(models[tmp[2]]);\n                t.setTranslation(new Vector3f((float) tmp[0] * size + 0.5f, 0.0f, (float) tmp[1] * size + 0.5f));\n                System.err.println(new Vector3f((float) tmp[0] * size, 0.0f, (float) tmp[1] * size));\n                tg.setTransform(t);\n                tg.addChild(model);\n                objects.addChild(tg);\n                j = 0;\n            }\n            tmp[j++] = (int) st.nval;\n        }\n        in.close();\n        objects.updateBounds(true);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/WorldTest1.java",
		"test_prompt": "// WorldTest1.java\npackage gui.gl;\n\nimport static java.lang.Math.round;\nimport static gui.gl.Util3D.*;\nimport java.awt.geom.*;\nimport java.awt.Point;\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.loaders.texture.*;\nimport java.util.Iterator;\nimport map.TileMap;\nimport map.Path;\nimport map.PathNotFoundException;\nimport org.newdawn.xith3d.obj.OBJLoader;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.StreamTokenizer;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link World}.\n* It contains ten unit test cases for the {@link World#intersect(PickRay)} method.\n*/\nclass WorldTest1 {"
	},
	{
		"original_code": "// World.java\n/* $Id: World.java,v 1.7 2004/05/02 23:01:54 emill Exp $ */\npackage gui.gl;\n\nimport static java.lang.Math.round;\nimport static gui.gl.Util3D.*;\nimport java.awt.geom.*;\nimport java.awt.Point;\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.loaders.texture.*;\nimport java.util.Iterator;\nimport map.TileMap;\nimport map.Path;\nimport map.PathNotFoundException;\nimport org.newdawn.xith3d.obj.OBJLoader;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.StreamTokenizer;\n\n/**\n * This class represents the world. All objects in the world are children\n * of this class.\n */\npublic class World extends TransformGroup {\n\n    /**\n     * The transform associated with this grid.\n     */\n    // private Transform3D transform;\n    /**\n     * The map associated with this world object.\n     */\n    private TileMap map;\n\n    /**\n     * The cells of the grid.\n     */\n    private TransformGroup[][] cells;\n\n    /**\n     * The geometry that make up the grid.\n     */\n    private Shape3D grid;\n\n    private int rows;\n\n    private int cols;\n\n    private float size;\n\n    private Node[] models;\n\n    /**\n     * The active cell marker.\n     */\n    private TransformGroup selected;\n\n    private TransformGroup actors;\n\n    private TransformGroup objects;\n\n    /**\n     * This is the offset vector used to center the grid.\n     */\n    private Vector3f offset;\n\n    private Transform3D center;\n\n    /**\n     * The physical bounds of this grid.\n     */\n    private Rectangle2D.Float bounds;\n\n    /**\n     */\n    private float roll = 0;\n\n    private float pitch = 0;\n\n    private float yaw = 0;\n\n    /**\n     */\n    //private float posX = 0;\n    //private float posY = 0;\n    //private float posZ = 0;\n    /**\n     * Create a new instance of the Grid class. The grid lies in the xz-plane,\n     * with origo at the bottom left corner.\n     *\n     * @param rows\n     * @param cols\n     * @param size\n     */\n    public World(int rows, int cols, float size) {\n        this.rows = rows;\n        this.cols = cols;\n        this.size = size;\n        cells = new TransformGroup[rows][cols];\n        actors = new TransformGroup();\n        objects = new TransformGroup();\n        /* Create the a visible grid system. */\n        grid = createGrid(rows, cols, size);\n        /* Compute grid bounds and use them to center the grid. */\n        bounds = new Rectangle2D.Float(0, 0, (cols) * size, (rows) * size);\n        offset = new Vector3f(-.5f * bounds.width, 0, -.5f * bounds.height);\n        center = new Transform3D();\n        center.setTranslation(offset);\n        setGridVisible(false);\n        addChild(grid);\n        addChild(actors);\n        addChild(objects);\n        actors.setPickable(true);\n        try {\n            map = new TileMap(0, 2, \"./dat/maps/test.map\", 1);\n            for (int i = 0; i < rows; i++) {\n                for (int j = 0; j < cols; j++) {\n                    map.Node n = map.getNodeAt(j, i);\n                    // System.err.print(n.getCost() + \" \");\n                    if (n.getCost() > 1.0f) {\n                        //System.err.println(\"x=\" + n.getX() + \" y=\"+ n.getY());\n                        //setCellTexture((int)(n.getX()+0.5f),\n                        //\t       (int)(n.getY()+0.5f),\"dirt.png\");\n                    }\n                }\n                // System.err.println();\n            }\n        } catch (java.io.IOException e) {\n            e.printStackTrace(System.err);\n        }\n    }\n\n    /**\n     * Adds an actor to the this world object.\n     * @param a the actor to add.\n     */\n    public void addActor(Actor a) {\n        a.setWorld(this);\n        actors.addChild(a);\n    }\n\n    //public void addChild(Actor actor) {\n    //actor.setWorld(this);\n    //actors.addChild(actor);\n    //}\n    /**\n     * Removes the specified actor from this world.\n     * @param a the actor to remove.\n     */\n    public void removeActor(Actor a) {\n        actors.removeChild(a);\n        a.setWorld(null);\n    }\n\n    public void removeAllActors() {\n        removeChild(actors);\n        actors = new TransformGroup();\n        addChild(actors);\n        actors.setPickable(true);\n    }\n\n    /**\n     * Loads the scene from the specified file.\n     * @param path the file from which to load the scene.\n     */\n    public void load(String path) {\n        //throws java.io.IOException {\n    }\n\n    public void save(String path) {\n        //throws java.io.IOException {\n    }\n\n    public Path findPath(int srcX, int srcY, int dstX, int dstY) throws PathNotFoundException {\n        map.Node src = map.getNodeAt(srcX, srcY);\n        map.Node dst = map.getNodeAt(dstX, dstY);\n        map.reset();\n        return map.coalescePath(map.search(src, dst));\n    }\n\n    /**\n     * Rotates the grid the specified number of degrees around\n     * the given axes.\n     *\n     * @param rotx\n     * @param roty\n     * @param rotz\n     */\n    public void rotXYZ(float rotx, float roty, float rotz) {\n        roll = rotx;\n        yaw = roty;\n        pitch = rotz;\n    }\n\n    public void panX(float dist) {\n        offset.x += dist;\n    }\n\n    public void panY(float dist) {\n        offset.y += dist;\n    }\n\n    public void panZ(float dist) {\n        offset.z += dist;\n    }\n\n    /**\n     * Returns the position of this grid.\n     * @return the position of this grid.\n     */\n    public Point3f getPosition() {\n        return new Point3f(offset);\n    }\n\n    /**\n     * Returns the orientation of this grid.\n     * @return the orientation of this grid.\n     */\n    public Vector3f getOrientation() {\n        return new Vector3f(roll, yaw, pitch);\n    }\n\n    /**\n     * Sets the orienation of this grid to the specified vector.\n     * @param v the new orientation of this grid.\n     */\n    public void setOrientation(Vector3f v) {\n        roll = v.x;\n        yaw = v.y;\n        pitch = v.z;\n    }\n\n    /**\n     * Calculate the intersection point of the specified ray with\n     * this Grid.\n     *\n     * @param r the intersecting ray.\n     * @return the intersection point of the ray and this grid or null\n     *         if the ray is paralell to the grid.\n     */\n    public Point3f intersect(PickRay r) {\n        // ray direction in world space.\n        Vector3f v = r.getDirection();\n        // ray origin in world space.\n        Point3f p = r.getOrigin();\n        // intersection point in grid space.\n        Point3f q = null;\n        // world to grid transform.\n        Transform3D tf = null;\n        // Get a copy of the grid transform.\n        tf = new Transform3D(getTransform());\n        // Transform the ray by the inverse grid transform. This way we\n        // get the ray in grid coordinate space.\n        tf.invert();\n        tf.transform(p);\n        tf.transform(v);\n        // Check that the ray is not parallell to the grid.\n        if (v.y != 0) {\n            // Assume that the grid lies in the xz-plane. It will always\n            // lie in the xz-plane!\n            float t = (offset.y - p.y) / v.y;\n            q = new Point3f(p.x + t * v.x, 0.0f, p.z + t * v.z);\n        }\n        return q;\n    }\n\n    /**\n     * Returns the grid cell corresponding to the given grid coordinate.\n     * @return the grid cell corresponding to the given grid coordinate.\n     */\n    public Point gridCoordToCell(Point3f p) {\n        return new Point(round(p.x / size - 0.5f), round(p.z / size - 0.5f));\n    }\n\n    /**\n     * Sets the background texture of this grid.\n     * @param tex the texture to set as background.\n     */\n    public void setTexture(String tex) {\n        TextureAttributes[] textureAttrs = new TextureAttributes[2];\n        TextureUnitState[] textureUnitStates = new TextureUnitState[2];\n        Texture2D[] textures = new Texture2D[2];\n        try {\n            TextureLoader tl = TextureLoader.getInstance();\n            // these paths should be registered elsewhere.\n            tl.registerPath(\"./\");\n            tl.registerPath(\"./dat/mdl\");\n            tl.registerPath(\"./dat/tex\");\n            tl.registerPath(\"./dat/gfx\");\n            textures[0] = (Texture2D) tl.getMinMapTexture(\"grass2.png\");\n            textures[1] = (Texture2D) tl.getMinMapTexture(\"stone.png\");\n            textureAttrs[0] = new TextureAttributes();\n            textureAttrs[0].setTextureMode(TextureAttributes.DECAL);\n            textureAttrs[1] = new TextureAttributes();\n            textureAttrs[1].setTextureMode(TextureAttributes.MODULATE);\n            textureUnitStates[0] = new TextureUnitState(textures[0], textureAttrs[0], null);\n            textureUnitStates[1] = new TextureUnitState(textures[1], textureAttrs[1], null);\n            // Set polygon offset so that we can see objects lying in the\n            // same plane as the grid.\n            PolygonAttributes polyAttr = new PolygonAttributes();\n            polyAttr.setPolygonOffset(10.0f);\n            polyAttr.setPolygonOffsetFactor(20.0f);\n            Appearance a = new Appearance();\n            a.setTextureUnitState(textureUnitStates);\n            a.setPolygonAttributes(polyAttr);\n            addChild(new Shape3D(createQuad(0f, 0f, cols * size, 1f, 2 * cols), a));\n        } catch (Exception e) {\n            e.printStackTrace(System.err);\n        }\n    }\n\n    /**\n     * Sets the texture of the cell at the specified coordinates\n     * given in grid space. If name is null or empty string, then\n     * the specified cell's texture will be removed.\n     *\n     * @param row the cell row coordinate.\n     * @param col the cell column coordinate.\n     * @param name the texture to set to the cell. If it is null then\n     *             the current texture will be removed from the cell.\n     */\n    public void setCellTexture(int row, int col, String name, boolean blend) {\n        TransformGroup tg = null;\n        Shape3D sh = null;\n        try {\n            tg = getCellNode(row, col);\n        } catch (ArrayIndexOutOfBoundsException e) {\n            // craps!\n            return;\n        }\n        if (name == null || name.length() == 0) {\n            removeChild(tg);\n            setCellNode(row, col, null);\n            return;\n        }\n        if (tg == null) {\n            tg = new TransformGroup();\n            //sh = new Shape3D(createPlane(size, 1));\n            //setTexture2D(sh, \"./dat/tex/\" + name,blend,blend,true);\n            sh = createTexturedPlane(name, size, 1);\n            tg.addChild(sh);\n            setCellNode(row, col, tg);\n            addChild(tg);\n        } else {\n            sh = (Shape3D) tg.getChild(0);\n            TextureLoader tl = TextureLoader.getInstance();\n            Texture2D tex = (Texture2D) tl.getMinMapTexture(name);\n            //setTexture2D(sh,\"./dat/tex/\" + name,blend,blend,true);\n        }\n        Vector3f pos = new Vector3f(row * size, 0.01f, col * size);\n        Transform3D tf = tg.getTransform();\n        tf.setTranslation(pos);\n        tg.setTransform(tf);\n    }\n\n    public void setCellTexture(int row, int col, String name) {\n        setCellTexture(row, col, name, false);\n    }\n\n    public void setCellNode(int row, int col, TransformGroup tg) {\n        cells[row][col] = tg;\n    }\n\n    public TransformGroup getCellNode(int row, int col) {\n        return cells[row][col];\n    }\n\n    /**\n     * Sets the active cell given by the row and col coordinates.\n     *\n     * @param row the active cell row coordinate.\n     * @param col the active cell column coordinate.\n     */\n    public void setActiveCell(int row, int col) {\n        if (selected != null) {\n            Transform3D tf = selected.getTransform();\n            tf.setTranslation(new Vector3f(row * size, 0.01f, col * size));\n        } else {\n            // create the active cell marker\n            selected = new TransformGroup();\n            Vector3f pos = new Vector3f(row * size, 0.01f, col * size);\n            Appearance ap = new Appearance();\n            setTexture2D(\"dat/tex/active.png\", ap);\n            selected.getTransform().setTranslation(pos);\n            selected.addChild(new Shape3D(createPlane(size, 1.0f), ap));\n            addChild(selected);\n            /*\n\n\t    // enable transparency.\n\t    TransparencyAttributes tcattr = new TransparencyAttributes();\n\t    tcattr.setTransparency(0.5f);\n\t    tcattr.setMode(TransparencyAttributes.BLENDED);\n\t    a.setTransparencyAttributes(tcattr);\n\t    sh.setAppearance(a);\n\n\t    // set the line width\n\t    LineAttributes attr = new LineAttributes();\n\t    attr.setLineWidth(1f);\n\t    attr.setLineAntialiasingEnable(true);\n\t    //a.setLineAttributes(attr);\n\n\t    // disable depth buffer test for this shape\n\t    RenderingAttributes attr1 = new RenderingAttributes();\n\t    attr1.setDepthBufferEnable(false);\n\t    a.setRenderingAttributes(attr1);\n\n\t    Color3f lineColor = new Color3f(1,1,0);\n\t    Shape3D rect = new Shape3D(createRectangle(size,size,lineColor)));\n\t    selected.addChild(rect);\n\t\t\t\t          \n            */\n        }\n    }\n\n    /**\n     * Updates and renders the grid. Since scene graph operations must\n     * be carried out from the same thread, we keep all such operations\n     * in this method and call it once from the main rendering loop.\n     */\n    public void render() {\n        Transform3D tf = getTransform();\n        Transform3D centering = new Transform3D();\n        centering.setTranslation(offset);\n        //center.getTranslation(pos);\n        //pos.x = posX;\n        //pos.y = posY;\n        //pos.z = posZ;\n        //center.setTranslation(offset);\n        tf.rotXYZ(roll, yaw, pitch);\n        tf.mul(centering);\n        setTransform(tf);\n    }\n\n    /**\n     * Enables or disables the display of the grid.\n     * @param enable true if the grid should be visible otherwise false.\n     */\n    public void setGridVisible(boolean enable) {\n        Appearance ap = null;\n        RenderingAttributes attr = null;\n        try {\n            ap = grid.getAppearance();\n            attr = ap.getRenderingAttributes();\n            attr.setVisible(enable);\n        } catch (NullPointerException e) {\n            if (ap == null) {\n                ap = new Appearance();\n                grid.setAppearance(ap);\n            }\n            if (attr == null) {\n                attr = new RenderingAttributes();\n                attr.setVisible(enable);\n            }\n        }\n        ap.setRenderingAttributes(attr);\n    }\n\n    /**\n     * Returns true if the grid is visible otherwise false.\n     * @return true if the grid is visible otherwise false.\n     */\n    public boolean getGridVisible() {\n        boolean visible = false;\n        try {\n            Appearance ap = grid.getAppearance();\n            RenderingAttributes attr = ap.getRenderingAttributes();\n            visible = attr.getVisible();\n        } catch (NullPointerException e) {\n            // e.printStackTrace(System.err);\n        }\n        return visible;\n    }\n\n    protected void open(String fileName) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(fileName));\n        StreamTokenizer st = new StreamTokenizer(in);\n        int j = 0, i = 0;\n        int[] tmp = new int[3];\n        // throw away tile info\n        int numOfTiles = Integer.parseInt(in.readLine());\n        models = new Node[numOfTiles];\n        for (i = 0; i < numOfTiles; i++) {\n            String modelname = in.readLine();\n            BranchGroup mdl = new OBJLoader().load(modelname);\n            models[i] = mdl.getChild(0);\n        }\n        int numOfObjs = Integer.parseInt(in.readLine());\n        i = j = 0;\n        while (st.nextToken() != st.TT_EOF && i++ < numOfObjs * tmp.length + 1) {\n            if (j >= tmp.length) {\n                TransformGroup tg = new TransformGroup();\n                Transform3D t = new Transform3D();\n                Node model = new Shape3D();\n                tg.getTransform(t);\n                model = model.sharedCopy(models[tmp[2]]);\n                t.setTranslation(new Vector3f((float) tmp[0] * size + 0.5f, 0.0f, (float) tmp[1] * size + 0.5f));\n                System.err.println(new Vector3f((float) tmp[0] * size, 0.0f, (float) tmp[1] * size));\n                tg.setTransform(t);\n                tg.addChild(model);\n                objects.addChild(tg);\n                j = 0;\n            }\n            tmp[j++] = (int) st.nval;\n        }\n        in.close();\n        objects.updateBounds(true);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/WorldTest2.java",
		"test_prompt": "// WorldTest2.java\npackage gui.gl;\n\nimport static java.lang.Math.round;\nimport static gui.gl.Util3D.*;\nimport java.awt.geom.*;\nimport java.awt.Point;\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.loaders.texture.*;\nimport java.util.Iterator;\nimport map.TileMap;\nimport map.Path;\nimport map.PathNotFoundException;\nimport org.newdawn.xith3d.obj.OBJLoader;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.StreamTokenizer;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link World}.\n* It contains ten unit test cases for the {@link World#gridCoordToCell(Point3f)} method.\n*/\nclass WorldTest2 {"
	},
	{
		"original_code": "// Util3D.java\n/* $Id: Util3D.java,v 1.6 2004/04/27 19:26:21 bja Exp $ */\npackage gui.gl;\n\nimport static java.lang.Math.PI;\nimport static java.lang.Math.tan;\nimport static java.lang.Math.cos;\nimport static java.lang.Math.sin;\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.loaders.texture.*;\nimport com.xith3d.render.*;\nimport com.xith3d.render.jogl.*;\nimport javax.imageio.ImageIO;\nimport java.io.*;\nimport com.xith3d.image.DirectBufferedImage;\nimport java.awt.image.BufferedImage;\n\npublic class Util3D {\n\n    public static final float rad(float ang) {\n        return (float) (ang / 180.0 * PI);\n    }\n\n    public static final float deg(float ang) {\n        return (float) (ang / PI * 180.0);\n    }\n\n    /**\n     * Creates a size-by-size wu sized plane with assigned texture\n     * coordinates. Texture coordinates are generated for two layers.\n     *\n     * @param size the size of the plane.\n     *\n     * @return the plane with the given normal and size.\n     */\n    public static Geometry createPlane(float size, float r) {\n        return createQuad(0, 0, size, r, r);\n    }\n\n    public static Geometry createQuad(float x, float y, float size, float s, float t) {\n        Point3f[] coords = new Point3f[] { new Point3f(x, 0f, y), new Point3f(x + size, 0f, y), new Point3f(x + size, 0f, y + size), new Point3f(x, 0f, y + size) };\n        TexCoord2f[] texcoords = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(s, 0f), new TexCoord2f(s, s), new TexCoord2f(0f, s) };\n        TexCoord2f[] texcoords2 = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(t, 0f), new TexCoord2f(t, t), new TexCoord2f(0f, t) };\n        QuadArray plane = new QuadArray(coords.length, GeometryArray.COORDINATES | GeometryArray.TEXTURE_COORDINATE_2, 2, new int[] { 0, 1 });\n        plane.setCoordinates(0, coords);\n        plane.setTextureCoordinates(0, 0, texcoords);\n        plane.setTextureCoordinates(1, 0, texcoords2);\n        return plane;\n    }\n\n    /**\n     * Create a new textured plane shape node.\n     *\n     * @param path the texture to apply to the plane.\n     * @param s the size of the plane.\n     * @param r the number of repetitions.\n     */\n    public static Shape3D createTexturedPlane(String path, float s, float r) {\n        TextureLoader loader = TextureLoader.getInstance();\n        // fixa\n        loader.registerPath(\"./\");\n        // fixa\n        loader.registerPath(\"./dat/tex/\");\n        // fixa\n        loader.registerPath(\"./dat/mdl/\");\n        // fixa\n        loader.registerPath(\"./dat/gfx/\");\n        Appearance appearance = new Appearance();\n        appearance.setTexture((Texture2D) loader.getMinMapTexture(path));\n        // Set polygon offset so that we can see objects lying in the\n        // same plane as the grid.\n        PolygonAttributes polyAttr = new PolygonAttributes();\n        polyAttr.setPolygonOffset(10.0f);\n        polyAttr.setPolygonOffsetFactor(20.0f);\n        appearance.setPolygonAttributes(polyAttr);\n        return new Shape3D(createPlane(s, r), appearance);\n    }\n\n    public static Geometry createRectangle(float w, float h, Color3f color) {\n        Point3f[] coords = new Point3f[] { new Point3f(0f, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, h), new Point3f(w, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, 0f) };\n        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);\n        Color3f[] colors = new Color3f[] { new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z) };\n        lines.setCoordinates(0, coords);\n        lines.setColors(0, colors);\n        return lines;\n    }\n\n    /**\n     * Creates the default coordinate axes with specified length.\n     * @param size the length of the axes.\n     */\n    public static Geometry createCoordAxes(float size) {\n        Point3f[] coords = new Point3f[] { new Point3f(0, 0, 0), new Point3f(size, 0, 0), new Point3f(0, 0, 0), new Point3f(0, size, 0), new Point3f(0, 0, 0), new Point3f(0, 0, size) };\n        Color3f[] colors = new Color3f[] { new Color3f(0, 0, 1), new Color3f(0, 0, 1), new Color3f(1, 0, 0), new Color3f(1, 0, 0), new Color3f(0, 1, 0), new Color3f(0, 1, 0) };\n        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);\n        lines.setCoordinates(0, coords);\n        lines.setColors(0, colors);\n        return lines;\n    }\n\n    /**\n     * Creates a new grid with the specified number of rows and columns,\n     * and with the specified cell size.\n     *\n     * @param cols the number of cols in the grid.\n     * @param rows the number of rows in the grid.\n     * @param size the size of a single cell.\n     */\n    public static Shape3D createGrid(int cols, int rows, float size) {\n        rows++;\n        cols++;\n        Point3f[] coords = new Point3f[2 * (rows + cols)];\n        LineArray grid = new LineArray(coords.length, GeometryArray.COORDINATES);\n        for (int i = 1; i < 2 * rows; i += 2) {\n            coords[i - 1] = new Point3f(0, 0.01f, .5f * size * (i - 1));\n            coords[i] = new Point3f((cols - 1) * size, 0.01f, .5f * size * (i - 1));\n        }\n        for (int j = 1; j < 2 * cols; j += 2) {\n            coords[2 * rows + j - 1] = new Point3f(.5f * size * (j - 1), 0.01f, 0);\n            coords[2 * rows + j] = new Point3f(.5f * size * (j - 1), 0.01f, (rows - 1) * size);\n        }\n        grid.setCoordinates(0, coords);\n        return new Shape3D(grid);\n    }\n\n    /* The following methods are for converting screen coordinates to     \n     * world coordinates. They are taken from the xith3d forum and \n     * modified to fit the application.\n     *                                                                    \n     * Reference: kevglass                                                \n     *                                                                    \n     * http://www.javagaming.org/cgi-bin/JGNetForums/YaBB.cgi?            \n     *        board=xith3d;action=display;num=1068252077;start=15         \n     */\n    /**\n     * Returns the point in world space corresponding to the given\n     * coordinates in screen space.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @return the point in world space at the given depth.\n     */\n    public static Point3f toWorld(Canvas3D c, int x, int y) {\n        return toWorld(c, x, y, c.getView().getFrontClipDistance());\n    }\n\n    /**\n     * Returns the point in world space corresponding to the given\n     * coordinates in screen space.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @param z the z coordinate (depth).\n     * @return the point in world space at the given depth.\n     */\n    public static Point3f toWorld(Canvas3D c, int x, int y, float z) {\n        float fov = c.getView().getFieldOfView();\n        float width = c.getWidth();\n        float height = c.getHeight();\n        float panelY = (float) (tan(fov) * z);\n        float panelX = panelY * (width / height);\n        float xp = x / (width / 2);\n        float yp = y / (height / 2);\n        Point3f pt = new Point3f((xp - 1) * panelX, (1 - yp) * panelY, -z);\n        Transform3D v = new Transform3D();\n        c.getView().getTransform(v);\n        v.transform(pt);\n        return pt;\n    }\n\n    /**\n     * Returns the point in screen space corresponding to the given\n     * coordinates in world space.\n     *\n     * @param c the associated canvas.\n     * @param x the world x coordinate.\n     * @param y the world y coordinate.\n     * @param z the world z coordinate.\n     * @return the corresponding point in screen space.\n     */\n    public static Point3f toScreen(Canvas3D c, Point3f p) {\n        return toScreen(c, p.x, p.y, p.z);\n    }\n\n    public static Point3f toScreen(Canvas3D c, float x, float y, float z) {\n        float fov = c.getView().getFieldOfView();\n        float width = c.getWidth();\n        float height = c.getHeight();\n        Transform3D v = new Transform3D();\n        c.getView().getTransform(v);\n        Point3f p = new Point3f(x, y, z);\n        v.invert();\n        v.transform(p);\n        float panelY = (float) (tan(fov) * p.z);\n        float panelX = panelY * (width / height);\n        Point3f pt = new Point3f(p.x / panelX + 1, -p.y / panelY + 1, p.z);\n        pt.x = width - pt.x * (width / 2);\n        pt.y = height - pt.y * (height / 2);\n        return pt;\n    }\n\n    /**\n     * Returns the ray eminating from the point (x, y) in screen space\n     * directed along the screen z-axis.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @return the ray eminating from x, y in screen space.\n     */\n    public static PickRay castRay(Canvas3D c, int x, int y) {\n        Point3f center = toWorld(c, x, y);\n        Point3f d = toWorld(c, x, y, c.getView().getFrontClipDistance() + 0.1f);\n        Vector3f forward = new Vector3f(center);\n        forward.sub(d);\n        return new PickRay(center, forward);\n    }\n\n    /**\n     * @param path the path to the image to open.\n     */\n    public static BufferedImage getBufferedImage(String path) {\n        BufferedImage bufferedImage = null;\n        try {\n            bufferedImage = ImageIO.read(path.getClass().getResource(path));\n        } catch (Exception e) {\n            try {\n                bufferedImage = ImageIO.read(new File(path));\n            } catch (Exception x) {\n                System.err.println(\"craps!\");\n                x.printStackTrace(System.err);\n            }\n        }\n        return bufferedImage;\n    }\n\n    /**\n     * Sets the specified texture to the specified appearance. The texture\n     * mode is set to modulated.\n     *\n     * reference: Java Cool Dude\n     */\n    public static void setTexture2D(Shape3D shape, String path) {\n        setTexture2D(shape, path, false, true, true);\n    }\n\n    public static void setTexture2D(Shape3D shape, String path, boolean clip, boolean blend, boolean depth) {\n        Appearance appr = shape.getAppearance();\n        if (appr == null) {\n            appr = new Appearance();\n            shape.setAppearance(appr);\n        }\n        setTexture2D(path, appr, clip, blend, depth);\n    }\n\n    public static void setTexture2D(String path, Appearance appr) {\n        setTexture2D(path, appr, false, false, false);\n    }\n\n    public static void setTexture2D(String path, Appearance appr, boolean clip, boolean blend, boolean depth) {\n        BufferedImage bufferedImage = getBufferedImage(path);\n        TextureLoader tl = TextureLoader.getInstance();\n        if (!depth) {\n            RenderingAttributes rendattr = new RenderingAttributes();\n            rendattr.setDepthBufferEnable(false);\n            appr.setRenderingAttributes(rendattr);\n        }\n        if (blend) {\n            TransparencyAttributes aattr = new TransparencyAttributes();\n            aattr.setTransparencyMode(TransparencyAttributes.BLENDED);\n            aattr.setTransparency(0.0f);\n            aattr.setDstBlendFunction(TransparencyAttributes.BLEND_ONE);\n            aattr.setSrcBlendFunction(TransparencyAttributes.BLEND_SRC_ALPHA);\n            appr.setTransparencyAttributes(aattr);\n        }\n        if (clip) {\n            TextureAttributes texattr = new TextureAttributes();\n            texattr.setTextureMode(TextureAttributes.MODULATE);\n            texattr.setPerspectiveCorrectionMode(TextureAttributes.FASTEST);\n            appr.setTextureAttributes(texattr);\n        }\n        bufferedImage = DirectBufferedImage.make(bufferedImage, false);\n        Texture2D texture = (Texture2D) tl.constructTexture(bufferedImage, \"RGB\", false, Texture.BASE_LEVEL_LINEAR, Texture.BASE_LEVEL_LINEAR, Texture.WRAP, false, TextureLoader.SCALE_DRAW_BEST);\n        appr.setTexture(texture);\n    }\n\n    /**\n     * Enable picking of this node by traversing the scenegraph to the\n     * root and setting each node to be pickable.\n     *\n     * @param name the name used to identify this node.\n     */\n    public static void setPickable(Node node, String name) {\n        Node g = node.getParent();\n        while (g != null) {\n            g.setPickable(true);\n            g = g.getParent();\n        }\n        if (node instanceof Group) {\n            setPickableRecursive((Group) node, name);\n        }\n    }\n\n    /**\n     * Set all children of the specified group to be pickable.\n     *\n     * @param group the node at which to start.\n     * @param name the name used to identify the nodes.\n     */\n    public static void setPickableRecursive(Group group, String name) {\n        if (group == null) {\n            return;\n        }\n        group.setPickable(true);\n        java.util.Enumeration e = group.getAllChildren();\n        while (e.hasMoreElements()) {\n            Node node = (Node) e.nextElement();\n            // if it's a group rename all children\n            if (node instanceof Group) {\n                setPickableRecursive((Group) node, name);\n            } else {\n                node.setPickable(true);\n                if (node instanceof Shape3D) {\n                    node.setName(name);\n                }\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/Util3DTest0.java",
		"test_prompt": "// Util3DTest0.java\npackage gui.gl;\n\nimport static java.lang.Math.PI;\nimport static java.lang.Math.tan;\nimport static java.lang.Math.cos;\nimport static java.lang.Math.sin;\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.loaders.texture.*;\nimport com.xith3d.render.*;\nimport com.xith3d.render.jogl.*;\nimport javax.imageio.ImageIO;\nimport java.io.*;\nimport com.xith3d.image.DirectBufferedImage;\nimport java.awt.image.BufferedImage;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Util3D}.\n* It contains ten unit test cases for the {@link Util3D#rad(float)} method.\n*/\nclass Util3DTest0 {"
	},
	{
		"original_code": "// Util3D.java\n/* $Id: Util3D.java,v 1.6 2004/04/27 19:26:21 bja Exp $ */\npackage gui.gl;\n\nimport static java.lang.Math.PI;\nimport static java.lang.Math.tan;\nimport static java.lang.Math.cos;\nimport static java.lang.Math.sin;\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.loaders.texture.*;\nimport com.xith3d.render.*;\nimport com.xith3d.render.jogl.*;\nimport javax.imageio.ImageIO;\nimport java.io.*;\nimport com.xith3d.image.DirectBufferedImage;\nimport java.awt.image.BufferedImage;\n\npublic class Util3D {\n\n    public static final float rad(float ang) {\n        return (float) (ang / 180.0 * PI);\n    }\n\n    public static final float deg(float ang) {\n        return (float) (ang / PI * 180.0);\n    }\n\n    /**\n     * Creates a size-by-size wu sized plane with assigned texture\n     * coordinates. Texture coordinates are generated for two layers.\n     *\n     * @param size the size of the plane.\n     *\n     * @return the plane with the given normal and size.\n     */\n    public static Geometry createPlane(float size, float r) {\n        return createQuad(0, 0, size, r, r);\n    }\n\n    public static Geometry createQuad(float x, float y, float size, float s, float t) {\n        Point3f[] coords = new Point3f[] { new Point3f(x, 0f, y), new Point3f(x + size, 0f, y), new Point3f(x + size, 0f, y + size), new Point3f(x, 0f, y + size) };\n        TexCoord2f[] texcoords = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(s, 0f), new TexCoord2f(s, s), new TexCoord2f(0f, s) };\n        TexCoord2f[] texcoords2 = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(t, 0f), new TexCoord2f(t, t), new TexCoord2f(0f, t) };\n        QuadArray plane = new QuadArray(coords.length, GeometryArray.COORDINATES | GeometryArray.TEXTURE_COORDINATE_2, 2, new int[] { 0, 1 });\n        plane.setCoordinates(0, coords);\n        plane.setTextureCoordinates(0, 0, texcoords);\n        plane.setTextureCoordinates(1, 0, texcoords2);\n        return plane;\n    }\n\n    /**\n     * Create a new textured plane shape node.\n     *\n     * @param path the texture to apply to the plane.\n     * @param s the size of the plane.\n     * @param r the number of repetitions.\n     */\n    public static Shape3D createTexturedPlane(String path, float s, float r) {\n        TextureLoader loader = TextureLoader.getInstance();\n        // fixa\n        loader.registerPath(\"./\");\n        // fixa\n        loader.registerPath(\"./dat/tex/\");\n        // fixa\n        loader.registerPath(\"./dat/mdl/\");\n        // fixa\n        loader.registerPath(\"./dat/gfx/\");\n        Appearance appearance = new Appearance();\n        appearance.setTexture((Texture2D) loader.getMinMapTexture(path));\n        // Set polygon offset so that we can see objects lying in the\n        // same plane as the grid.\n        PolygonAttributes polyAttr = new PolygonAttributes();\n        polyAttr.setPolygonOffset(10.0f);\n        polyAttr.setPolygonOffsetFactor(20.0f);\n        appearance.setPolygonAttributes(polyAttr);\n        return new Shape3D(createPlane(s, r), appearance);\n    }\n\n    public static Geometry createRectangle(float w, float h, Color3f color) {\n        Point3f[] coords = new Point3f[] { new Point3f(0f, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, h), new Point3f(w, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, 0f) };\n        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);\n        Color3f[] colors = new Color3f[] { new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z) };\n        lines.setCoordinates(0, coords);\n        lines.setColors(0, colors);\n        return lines;\n    }\n\n    /**\n     * Creates the default coordinate axes with specified length.\n     * @param size the length of the axes.\n     */\n    public static Geometry createCoordAxes(float size) {\n        Point3f[] coords = new Point3f[] { new Point3f(0, 0, 0), new Point3f(size, 0, 0), new Point3f(0, 0, 0), new Point3f(0, size, 0), new Point3f(0, 0, 0), new Point3f(0, 0, size) };\n        Color3f[] colors = new Color3f[] { new Color3f(0, 0, 1), new Color3f(0, 0, 1), new Color3f(1, 0, 0), new Color3f(1, 0, 0), new Color3f(0, 1, 0), new Color3f(0, 1, 0) };\n        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);\n        lines.setCoordinates(0, coords);\n        lines.setColors(0, colors);\n        return lines;\n    }\n\n    /**\n     * Creates a new grid with the specified number of rows and columns,\n     * and with the specified cell size.\n     *\n     * @param cols the number of cols in the grid.\n     * @param rows the number of rows in the grid.\n     * @param size the size of a single cell.\n     */\n    public static Shape3D createGrid(int cols, int rows, float size) {\n        rows++;\n        cols++;\n        Point3f[] coords = new Point3f[2 * (rows + cols)];\n        LineArray grid = new LineArray(coords.length, GeometryArray.COORDINATES);\n        for (int i = 1; i < 2 * rows; i += 2) {\n            coords[i - 1] = new Point3f(0, 0.01f, .5f * size * (i - 1));\n            coords[i] = new Point3f((cols - 1) * size, 0.01f, .5f * size * (i - 1));\n        }\n        for (int j = 1; j < 2 * cols; j += 2) {\n            coords[2 * rows + j - 1] = new Point3f(.5f * size * (j - 1), 0.01f, 0);\n            coords[2 * rows + j] = new Point3f(.5f * size * (j - 1), 0.01f, (rows - 1) * size);\n        }\n        grid.setCoordinates(0, coords);\n        return new Shape3D(grid);\n    }\n\n    /* The following methods are for converting screen coordinates to     \n     * world coordinates. They are taken from the xith3d forum and \n     * modified to fit the application.\n     *                                                                    \n     * Reference: kevglass                                                \n     *                                                                    \n     * http://www.javagaming.org/cgi-bin/JGNetForums/YaBB.cgi?            \n     *        board=xith3d;action=display;num=1068252077;start=15         \n     */\n    /**\n     * Returns the point in world space corresponding to the given\n     * coordinates in screen space.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @return the point in world space at the given depth.\n     */\n    public static Point3f toWorld(Canvas3D c, int x, int y) {\n        return toWorld(c, x, y, c.getView().getFrontClipDistance());\n    }\n\n    /**\n     * Returns the point in world space corresponding to the given\n     * coordinates in screen space.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @param z the z coordinate (depth).\n     * @return the point in world space at the given depth.\n     */\n    public static Point3f toWorld(Canvas3D c, int x, int y, float z) {\n        float fov = c.getView().getFieldOfView();\n        float width = c.getWidth();\n        float height = c.getHeight();\n        float panelY = (float) (tan(fov) * z);\n        float panelX = panelY * (width / height);\n        float xp = x / (width / 2);\n        float yp = y / (height / 2);\n        Point3f pt = new Point3f((xp - 1) * panelX, (1 - yp) * panelY, -z);\n        Transform3D v = new Transform3D();\n        c.getView().getTransform(v);\n        v.transform(pt);\n        return pt;\n    }\n\n    /**\n     * Returns the point in screen space corresponding to the given\n     * coordinates in world space.\n     *\n     * @param c the associated canvas.\n     * @param x the world x coordinate.\n     * @param y the world y coordinate.\n     * @param z the world z coordinate.\n     * @return the corresponding point in screen space.\n     */\n    public static Point3f toScreen(Canvas3D c, Point3f p) {\n        return toScreen(c, p.x, p.y, p.z);\n    }\n\n    public static Point3f toScreen(Canvas3D c, float x, float y, float z) {\n        float fov = c.getView().getFieldOfView();\n        float width = c.getWidth();\n        float height = c.getHeight();\n        Transform3D v = new Transform3D();\n        c.getView().getTransform(v);\n        Point3f p = new Point3f(x, y, z);\n        v.invert();\n        v.transform(p);\n        float panelY = (float) (tan(fov) * p.z);\n        float panelX = panelY * (width / height);\n        Point3f pt = new Point3f(p.x / panelX + 1, -p.y / panelY + 1, p.z);\n        pt.x = width - pt.x * (width / 2);\n        pt.y = height - pt.y * (height / 2);\n        return pt;\n    }\n\n    /**\n     * Returns the ray eminating from the point (x, y) in screen space\n     * directed along the screen z-axis.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @return the ray eminating from x, y in screen space.\n     */\n    public static PickRay castRay(Canvas3D c, int x, int y) {\n        Point3f center = toWorld(c, x, y);\n        Point3f d = toWorld(c, x, y, c.getView().getFrontClipDistance() + 0.1f);\n        Vector3f forward = new Vector3f(center);\n        forward.sub(d);\n        return new PickRay(center, forward);\n    }\n\n    /**\n     * @param path the path to the image to open.\n     */\n    public static BufferedImage getBufferedImage(String path) {\n        BufferedImage bufferedImage = null;\n        try {\n            bufferedImage = ImageIO.read(path.getClass().getResource(path));\n        } catch (Exception e) {\n            try {\n                bufferedImage = ImageIO.read(new File(path));\n            } catch (Exception x) {\n                System.err.println(\"craps!\");\n                x.printStackTrace(System.err);\n            }\n        }\n        return bufferedImage;\n    }\n\n    /**\n     * Sets the specified texture to the specified appearance. The texture\n     * mode is set to modulated.\n     *\n     * reference: Java Cool Dude\n     */\n    public static void setTexture2D(Shape3D shape, String path) {\n        setTexture2D(shape, path, false, true, true);\n    }\n\n    public static void setTexture2D(Shape3D shape, String path, boolean clip, boolean blend, boolean depth) {\n        Appearance appr = shape.getAppearance();\n        if (appr == null) {\n            appr = new Appearance();\n            shape.setAppearance(appr);\n        }\n        setTexture2D(path, appr, clip, blend, depth);\n    }\n\n    public static void setTexture2D(String path, Appearance appr) {\n        setTexture2D(path, appr, false, false, false);\n    }\n\n    public static void setTexture2D(String path, Appearance appr, boolean clip, boolean blend, boolean depth) {\n        BufferedImage bufferedImage = getBufferedImage(path);\n        TextureLoader tl = TextureLoader.getInstance();\n        if (!depth) {\n            RenderingAttributes rendattr = new RenderingAttributes();\n            rendattr.setDepthBufferEnable(false);\n            appr.setRenderingAttributes(rendattr);\n        }\n        if (blend) {\n            TransparencyAttributes aattr = new TransparencyAttributes();\n            aattr.setTransparencyMode(TransparencyAttributes.BLENDED);\n            aattr.setTransparency(0.0f);\n            aattr.setDstBlendFunction(TransparencyAttributes.BLEND_ONE);\n            aattr.setSrcBlendFunction(TransparencyAttributes.BLEND_SRC_ALPHA);\n            appr.setTransparencyAttributes(aattr);\n        }\n        if (clip) {\n            TextureAttributes texattr = new TextureAttributes();\n            texattr.setTextureMode(TextureAttributes.MODULATE);\n            texattr.setPerspectiveCorrectionMode(TextureAttributes.FASTEST);\n            appr.setTextureAttributes(texattr);\n        }\n        bufferedImage = DirectBufferedImage.make(bufferedImage, false);\n        Texture2D texture = (Texture2D) tl.constructTexture(bufferedImage, \"RGB\", false, Texture.BASE_LEVEL_LINEAR, Texture.BASE_LEVEL_LINEAR, Texture.WRAP, false, TextureLoader.SCALE_DRAW_BEST);\n        appr.setTexture(texture);\n    }\n\n    /**\n     * Enable picking of this node by traversing the scenegraph to the\n     * root and setting each node to be pickable.\n     *\n     * @param name the name used to identify this node.\n     */\n    public static void setPickable(Node node, String name) {\n        Node g = node.getParent();\n        while (g != null) {\n            g.setPickable(true);\n            g = g.getParent();\n        }\n        if (node instanceof Group) {\n            setPickableRecursive((Group) node, name);\n        }\n    }\n\n    /**\n     * Set all children of the specified group to be pickable.\n     *\n     * @param group the node at which to start.\n     * @param name the name used to identify the nodes.\n     */\n    public static void setPickableRecursive(Group group, String name) {\n        if (group == null) {\n            return;\n        }\n        group.setPickable(true);\n        java.util.Enumeration e = group.getAllChildren();\n        while (e.hasMoreElements()) {\n            Node node = (Node) e.nextElement();\n            // if it's a group rename all children\n            if (node instanceof Group) {\n                setPickableRecursive((Group) node, name);\n            } else {\n                node.setPickable(true);\n                if (node instanceof Shape3D) {\n                    node.setName(name);\n                }\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/Util3DTest1.java",
		"test_prompt": "// Util3DTest1.java\npackage gui.gl;\n\nimport static java.lang.Math.PI;\nimport static java.lang.Math.tan;\nimport static java.lang.Math.cos;\nimport static java.lang.Math.sin;\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.loaders.texture.*;\nimport com.xith3d.render.*;\nimport com.xith3d.render.jogl.*;\nimport javax.imageio.ImageIO;\nimport java.io.*;\nimport com.xith3d.image.DirectBufferedImage;\nimport java.awt.image.BufferedImage;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Util3D}.\n* It contains ten unit test cases for the {@link Util3D#deg(float)} method.\n*/\nclass Util3DTest1 {"
	},
	{
		"original_code": "// Util3D.java\n/* $Id: Util3D.java,v 1.6 2004/04/27 19:26:21 bja Exp $ */\npackage gui.gl;\n\nimport static java.lang.Math.PI;\nimport static java.lang.Math.tan;\nimport static java.lang.Math.cos;\nimport static java.lang.Math.sin;\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.loaders.texture.*;\nimport com.xith3d.render.*;\nimport com.xith3d.render.jogl.*;\nimport javax.imageio.ImageIO;\nimport java.io.*;\nimport com.xith3d.image.DirectBufferedImage;\nimport java.awt.image.BufferedImage;\n\npublic class Util3D {\n\n    public static final float rad(float ang) {\n        return (float) (ang / 180.0 * PI);\n    }\n\n    public static final float deg(float ang) {\n        return (float) (ang / PI * 180.0);\n    }\n\n    /**\n     * Creates a size-by-size wu sized plane with assigned texture\n     * coordinates. Texture coordinates are generated for two layers.\n     *\n     * @param size the size of the plane.\n     *\n     * @return the plane with the given normal and size.\n     */\n    public static Geometry createPlane(float size, float r) {\n        return createQuad(0, 0, size, r, r);\n    }\n\n    public static Geometry createQuad(float x, float y, float size, float s, float t) {\n        Point3f[] coords = new Point3f[] { new Point3f(x, 0f, y), new Point3f(x + size, 0f, y), new Point3f(x + size, 0f, y + size), new Point3f(x, 0f, y + size) };\n        TexCoord2f[] texcoords = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(s, 0f), new TexCoord2f(s, s), new TexCoord2f(0f, s) };\n        TexCoord2f[] texcoords2 = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(t, 0f), new TexCoord2f(t, t), new TexCoord2f(0f, t) };\n        QuadArray plane = new QuadArray(coords.length, GeometryArray.COORDINATES | GeometryArray.TEXTURE_COORDINATE_2, 2, new int[] { 0, 1 });\n        plane.setCoordinates(0, coords);\n        plane.setTextureCoordinates(0, 0, texcoords);\n        plane.setTextureCoordinates(1, 0, texcoords2);\n        return plane;\n    }\n\n    /**\n     * Create a new textured plane shape node.\n     *\n     * @param path the texture to apply to the plane.\n     * @param s the size of the plane.\n     * @param r the number of repetitions.\n     */\n    public static Shape3D createTexturedPlane(String path, float s, float r) {\n        TextureLoader loader = TextureLoader.getInstance();\n        // fixa\n        loader.registerPath(\"./\");\n        // fixa\n        loader.registerPath(\"./dat/tex/\");\n        // fixa\n        loader.registerPath(\"./dat/mdl/\");\n        // fixa\n        loader.registerPath(\"./dat/gfx/\");\n        Appearance appearance = new Appearance();\n        appearance.setTexture((Texture2D) loader.getMinMapTexture(path));\n        // Set polygon offset so that we can see objects lying in the\n        // same plane as the grid.\n        PolygonAttributes polyAttr = new PolygonAttributes();\n        polyAttr.setPolygonOffset(10.0f);\n        polyAttr.setPolygonOffsetFactor(20.0f);\n        appearance.setPolygonAttributes(polyAttr);\n        return new Shape3D(createPlane(s, r), appearance);\n    }\n\n    public static Geometry createRectangle(float w, float h, Color3f color) {\n        Point3f[] coords = new Point3f[] { new Point3f(0f, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, h), new Point3f(w, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, 0f) };\n        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);\n        Color3f[] colors = new Color3f[] { new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z) };\n        lines.setCoordinates(0, coords);\n        lines.setColors(0, colors);\n        return lines;\n    }\n\n    /**\n     * Creates the default coordinate axes with specified length.\n     * @param size the length of the axes.\n     */\n    public static Geometry createCoordAxes(float size) {\n        Point3f[] coords = new Point3f[] { new Point3f(0, 0, 0), new Point3f(size, 0, 0), new Point3f(0, 0, 0), new Point3f(0, size, 0), new Point3f(0, 0, 0), new Point3f(0, 0, size) };\n        Color3f[] colors = new Color3f[] { new Color3f(0, 0, 1), new Color3f(0, 0, 1), new Color3f(1, 0, 0), new Color3f(1, 0, 0), new Color3f(0, 1, 0), new Color3f(0, 1, 0) };\n        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);\n        lines.setCoordinates(0, coords);\n        lines.setColors(0, colors);\n        return lines;\n    }\n\n    /**\n     * Creates a new grid with the specified number of rows and columns,\n     * and with the specified cell size.\n     *\n     * @param cols the number of cols in the grid.\n     * @param rows the number of rows in the grid.\n     * @param size the size of a single cell.\n     */\n    public static Shape3D createGrid(int cols, int rows, float size) {\n        rows++;\n        cols++;\n        Point3f[] coords = new Point3f[2 * (rows + cols)];\n        LineArray grid = new LineArray(coords.length, GeometryArray.COORDINATES);\n        for (int i = 1; i < 2 * rows; i += 2) {\n            coords[i - 1] = new Point3f(0, 0.01f, .5f * size * (i - 1));\n            coords[i] = new Point3f((cols - 1) * size, 0.01f, .5f * size * (i - 1));\n        }\n        for (int j = 1; j < 2 * cols; j += 2) {\n            coords[2 * rows + j - 1] = new Point3f(.5f * size * (j - 1), 0.01f, 0);\n            coords[2 * rows + j] = new Point3f(.5f * size * (j - 1), 0.01f, (rows - 1) * size);\n        }\n        grid.setCoordinates(0, coords);\n        return new Shape3D(grid);\n    }\n\n    /* The following methods are for converting screen coordinates to     \n     * world coordinates. They are taken from the xith3d forum and \n     * modified to fit the application.\n     *                                                                    \n     * Reference: kevglass                                                \n     *                                                                    \n     * http://www.javagaming.org/cgi-bin/JGNetForums/YaBB.cgi?            \n     *        board=xith3d;action=display;num=1068252077;start=15         \n     */\n    /**\n     * Returns the point in world space corresponding to the given\n     * coordinates in screen space.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @return the point in world space at the given depth.\n     */\n    public static Point3f toWorld(Canvas3D c, int x, int y) {\n        return toWorld(c, x, y, c.getView().getFrontClipDistance());\n    }\n\n    /**\n     * Returns the point in world space corresponding to the given\n     * coordinates in screen space.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @param z the z coordinate (depth).\n     * @return the point in world space at the given depth.\n     */\n    public static Point3f toWorld(Canvas3D c, int x, int y, float z) {\n        float fov = c.getView().getFieldOfView();\n        float width = c.getWidth();\n        float height = c.getHeight();\n        float panelY = (float) (tan(fov) * z);\n        float panelX = panelY * (width / height);\n        float xp = x / (width / 2);\n        float yp = y / (height / 2);\n        Point3f pt = new Point3f((xp - 1) * panelX, (1 - yp) * panelY, -z);\n        Transform3D v = new Transform3D();\n        c.getView().getTransform(v);\n        v.transform(pt);\n        return pt;\n    }\n\n    /**\n     * Returns the point in screen space corresponding to the given\n     * coordinates in world space.\n     *\n     * @param c the associated canvas.\n     * @param x the world x coordinate.\n     * @param y the world y coordinate.\n     * @param z the world z coordinate.\n     * @return the corresponding point in screen space.\n     */\n    public static Point3f toScreen(Canvas3D c, Point3f p) {\n        return toScreen(c, p.x, p.y, p.z);\n    }\n\n    public static Point3f toScreen(Canvas3D c, float x, float y, float z) {\n        float fov = c.getView().getFieldOfView();\n        float width = c.getWidth();\n        float height = c.getHeight();\n        Transform3D v = new Transform3D();\n        c.getView().getTransform(v);\n        Point3f p = new Point3f(x, y, z);\n        v.invert();\n        v.transform(p);\n        float panelY = (float) (tan(fov) * p.z);\n        float panelX = panelY * (width / height);\n        Point3f pt = new Point3f(p.x / panelX + 1, -p.y / panelY + 1, p.z);\n        pt.x = width - pt.x * (width / 2);\n        pt.y = height - pt.y * (height / 2);\n        return pt;\n    }\n\n    /**\n     * Returns the ray eminating from the point (x, y) in screen space\n     * directed along the screen z-axis.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @return the ray eminating from x, y in screen space.\n     */\n    public static PickRay castRay(Canvas3D c, int x, int y) {\n        Point3f center = toWorld(c, x, y);\n        Point3f d = toWorld(c, x, y, c.getView().getFrontClipDistance() + 0.1f);\n        Vector3f forward = new Vector3f(center);\n        forward.sub(d);\n        return new PickRay(center, forward);\n    }\n\n    /**\n     * @param path the path to the image to open.\n     */\n    public static BufferedImage getBufferedImage(String path) {\n        BufferedImage bufferedImage = null;\n        try {\n            bufferedImage = ImageIO.read(path.getClass().getResource(path));\n        } catch (Exception e) {\n            try {\n                bufferedImage = ImageIO.read(new File(path));\n            } catch (Exception x) {\n                System.err.println(\"craps!\");\n                x.printStackTrace(System.err);\n            }\n        }\n        return bufferedImage;\n    }\n\n    /**\n     * Sets the specified texture to the specified appearance. The texture\n     * mode is set to modulated.\n     *\n     * reference: Java Cool Dude\n     */\n    public static void setTexture2D(Shape3D shape, String path) {\n        setTexture2D(shape, path, false, true, true);\n    }\n\n    public static void setTexture2D(Shape3D shape, String path, boolean clip, boolean blend, boolean depth) {\n        Appearance appr = shape.getAppearance();\n        if (appr == null) {\n            appr = new Appearance();\n            shape.setAppearance(appr);\n        }\n        setTexture2D(path, appr, clip, blend, depth);\n    }\n\n    public static void setTexture2D(String path, Appearance appr) {\n        setTexture2D(path, appr, false, false, false);\n    }\n\n    public static void setTexture2D(String path, Appearance appr, boolean clip, boolean blend, boolean depth) {\n        BufferedImage bufferedImage = getBufferedImage(path);\n        TextureLoader tl = TextureLoader.getInstance();\n        if (!depth) {\n            RenderingAttributes rendattr = new RenderingAttributes();\n            rendattr.setDepthBufferEnable(false);\n            appr.setRenderingAttributes(rendattr);\n        }\n        if (blend) {\n            TransparencyAttributes aattr = new TransparencyAttributes();\n            aattr.setTransparencyMode(TransparencyAttributes.BLENDED);\n            aattr.setTransparency(0.0f);\n            aattr.setDstBlendFunction(TransparencyAttributes.BLEND_ONE);\n            aattr.setSrcBlendFunction(TransparencyAttributes.BLEND_SRC_ALPHA);\n            appr.setTransparencyAttributes(aattr);\n        }\n        if (clip) {\n            TextureAttributes texattr = new TextureAttributes();\n            texattr.setTextureMode(TextureAttributes.MODULATE);\n            texattr.setPerspectiveCorrectionMode(TextureAttributes.FASTEST);\n            appr.setTextureAttributes(texattr);\n        }\n        bufferedImage = DirectBufferedImage.make(bufferedImage, false);\n        Texture2D texture = (Texture2D) tl.constructTexture(bufferedImage, \"RGB\", false, Texture.BASE_LEVEL_LINEAR, Texture.BASE_LEVEL_LINEAR, Texture.WRAP, false, TextureLoader.SCALE_DRAW_BEST);\n        appr.setTexture(texture);\n    }\n\n    /**\n     * Enable picking of this node by traversing the scenegraph to the\n     * root and setting each node to be pickable.\n     *\n     * @param name the name used to identify this node.\n     */\n    public static void setPickable(Node node, String name) {\n        Node g = node.getParent();\n        while (g != null) {\n            g.setPickable(true);\n            g = g.getParent();\n        }\n        if (node instanceof Group) {\n            setPickableRecursive((Group) node, name);\n        }\n    }\n\n    /**\n     * Set all children of the specified group to be pickable.\n     *\n     * @param group the node at which to start.\n     * @param name the name used to identify the nodes.\n     */\n    public static void setPickableRecursive(Group group, String name) {\n        if (group == null) {\n            return;\n        }\n        group.setPickable(true);\n        java.util.Enumeration e = group.getAllChildren();\n        while (e.hasMoreElements()) {\n            Node node = (Node) e.nextElement();\n            // if it's a group rename all children\n            if (node instanceof Group) {\n                setPickableRecursive((Group) node, name);\n            } else {\n                node.setPickable(true);\n                if (node instanceof Shape3D) {\n                    node.setName(name);\n                }\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/Util3DTest2.java",
		"test_prompt": "// Util3DTest2.java\npackage gui.gl;\n\nimport static java.lang.Math.PI;\nimport static java.lang.Math.tan;\nimport static java.lang.Math.cos;\nimport static java.lang.Math.sin;\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.loaders.texture.*;\nimport com.xith3d.render.*;\nimport com.xith3d.render.jogl.*;\nimport javax.imageio.ImageIO;\nimport java.io.*;\nimport com.xith3d.image.DirectBufferedImage;\nimport java.awt.image.BufferedImage;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Util3D}.\n* It contains ten unit test cases for the {@link Util3D#createPlane(float, float)} method.\n*/\nclass Util3DTest2 {"
	},
	{
		"original_code": "// Util3D.java\n/* $Id: Util3D.java,v 1.6 2004/04/27 19:26:21 bja Exp $ */\npackage gui.gl;\n\nimport static java.lang.Math.PI;\nimport static java.lang.Math.tan;\nimport static java.lang.Math.cos;\nimport static java.lang.Math.sin;\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.loaders.texture.*;\nimport com.xith3d.render.*;\nimport com.xith3d.render.jogl.*;\nimport javax.imageio.ImageIO;\nimport java.io.*;\nimport com.xith3d.image.DirectBufferedImage;\nimport java.awt.image.BufferedImage;\n\npublic class Util3D {\n\n    public static final float rad(float ang) {\n        return (float) (ang / 180.0 * PI);\n    }\n\n    public static final float deg(float ang) {\n        return (float) (ang / PI * 180.0);\n    }\n\n    /**\n     * Creates a size-by-size wu sized plane with assigned texture\n     * coordinates. Texture coordinates are generated for two layers.\n     *\n     * @param size the size of the plane.\n     *\n     * @return the plane with the given normal and size.\n     */\n    public static Geometry createPlane(float size, float r) {\n        return createQuad(0, 0, size, r, r);\n    }\n\n    public static Geometry createQuad(float x, float y, float size, float s, float t) {\n        Point3f[] coords = new Point3f[] { new Point3f(x, 0f, y), new Point3f(x + size, 0f, y), new Point3f(x + size, 0f, y + size), new Point3f(x, 0f, y + size) };\n        TexCoord2f[] texcoords = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(s, 0f), new TexCoord2f(s, s), new TexCoord2f(0f, s) };\n        TexCoord2f[] texcoords2 = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(t, 0f), new TexCoord2f(t, t), new TexCoord2f(0f, t) };\n        QuadArray plane = new QuadArray(coords.length, GeometryArray.COORDINATES | GeometryArray.TEXTURE_COORDINATE_2, 2, new int[] { 0, 1 });\n        plane.setCoordinates(0, coords);\n        plane.setTextureCoordinates(0, 0, texcoords);\n        plane.setTextureCoordinates(1, 0, texcoords2);\n        return plane;\n    }\n\n    /**\n     * Create a new textured plane shape node.\n     *\n     * @param path the texture to apply to the plane.\n     * @param s the size of the plane.\n     * @param r the number of repetitions.\n     */\n    public static Shape3D createTexturedPlane(String path, float s, float r) {\n        TextureLoader loader = TextureLoader.getInstance();\n        // fixa\n        loader.registerPath(\"./\");\n        // fixa\n        loader.registerPath(\"./dat/tex/\");\n        // fixa\n        loader.registerPath(\"./dat/mdl/\");\n        // fixa\n        loader.registerPath(\"./dat/gfx/\");\n        Appearance appearance = new Appearance();\n        appearance.setTexture((Texture2D) loader.getMinMapTexture(path));\n        // Set polygon offset so that we can see objects lying in the\n        // same plane as the grid.\n        PolygonAttributes polyAttr = new PolygonAttributes();\n        polyAttr.setPolygonOffset(10.0f);\n        polyAttr.setPolygonOffsetFactor(20.0f);\n        appearance.setPolygonAttributes(polyAttr);\n        return new Shape3D(createPlane(s, r), appearance);\n    }\n\n    public static Geometry createRectangle(float w, float h, Color3f color) {\n        Point3f[] coords = new Point3f[] { new Point3f(0f, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, h), new Point3f(w, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, 0f) };\n        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);\n        Color3f[] colors = new Color3f[] { new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z) };\n        lines.setCoordinates(0, coords);\n        lines.setColors(0, colors);\n        return lines;\n    }\n\n    /**\n     * Creates the default coordinate axes with specified length.\n     * @param size the length of the axes.\n     */\n    public static Geometry createCoordAxes(float size) {\n        Point3f[] coords = new Point3f[] { new Point3f(0, 0, 0), new Point3f(size, 0, 0), new Point3f(0, 0, 0), new Point3f(0, size, 0), new Point3f(0, 0, 0), new Point3f(0, 0, size) };\n        Color3f[] colors = new Color3f[] { new Color3f(0, 0, 1), new Color3f(0, 0, 1), new Color3f(1, 0, 0), new Color3f(1, 0, 0), new Color3f(0, 1, 0), new Color3f(0, 1, 0) };\n        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);\n        lines.setCoordinates(0, coords);\n        lines.setColors(0, colors);\n        return lines;\n    }\n\n    /**\n     * Creates a new grid with the specified number of rows and columns,\n     * and with the specified cell size.\n     *\n     * @param cols the number of cols in the grid.\n     * @param rows the number of rows in the grid.\n     * @param size the size of a single cell.\n     */\n    public static Shape3D createGrid(int cols, int rows, float size) {\n        rows++;\n        cols++;\n        Point3f[] coords = new Point3f[2 * (rows + cols)];\n        LineArray grid = new LineArray(coords.length, GeometryArray.COORDINATES);\n        for (int i = 1; i < 2 * rows; i += 2) {\n            coords[i - 1] = new Point3f(0, 0.01f, .5f * size * (i - 1));\n            coords[i] = new Point3f((cols - 1) * size, 0.01f, .5f * size * (i - 1));\n        }\n        for (int j = 1; j < 2 * cols; j += 2) {\n            coords[2 * rows + j - 1] = new Point3f(.5f * size * (j - 1), 0.01f, 0);\n            coords[2 * rows + j] = new Point3f(.5f * size * (j - 1), 0.01f, (rows - 1) * size);\n        }\n        grid.setCoordinates(0, coords);\n        return new Shape3D(grid);\n    }\n\n    /* The following methods are for converting screen coordinates to     \n     * world coordinates. They are taken from the xith3d forum and \n     * modified to fit the application.\n     *                                                                    \n     * Reference: kevglass                                                \n     *                                                                    \n     * http://www.javagaming.org/cgi-bin/JGNetForums/YaBB.cgi?            \n     *        board=xith3d;action=display;num=1068252077;start=15         \n     */\n    /**\n     * Returns the point in world space corresponding to the given\n     * coordinates in screen space.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @return the point in world space at the given depth.\n     */\n    public static Point3f toWorld(Canvas3D c, int x, int y) {\n        return toWorld(c, x, y, c.getView().getFrontClipDistance());\n    }\n\n    /**\n     * Returns the point in world space corresponding to the given\n     * coordinates in screen space.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @param z the z coordinate (depth).\n     * @return the point in world space at the given depth.\n     */\n    public static Point3f toWorld(Canvas3D c, int x, int y, float z) {\n        float fov = c.getView().getFieldOfView();\n        float width = c.getWidth();\n        float height = c.getHeight();\n        float panelY = (float) (tan(fov) * z);\n        float panelX = panelY * (width / height);\n        float xp = x / (width / 2);\n        float yp = y / (height / 2);\n        Point3f pt = new Point3f((xp - 1) * panelX, (1 - yp) * panelY, -z);\n        Transform3D v = new Transform3D();\n        c.getView().getTransform(v);\n        v.transform(pt);\n        return pt;\n    }\n\n    /**\n     * Returns the point in screen space corresponding to the given\n     * coordinates in world space.\n     *\n     * @param c the associated canvas.\n     * @param x the world x coordinate.\n     * @param y the world y coordinate.\n     * @param z the world z coordinate.\n     * @return the corresponding point in screen space.\n     */\n    public static Point3f toScreen(Canvas3D c, Point3f p) {\n        return toScreen(c, p.x, p.y, p.z);\n    }\n\n    public static Point3f toScreen(Canvas3D c, float x, float y, float z) {\n        float fov = c.getView().getFieldOfView();\n        float width = c.getWidth();\n        float height = c.getHeight();\n        Transform3D v = new Transform3D();\n        c.getView().getTransform(v);\n        Point3f p = new Point3f(x, y, z);\n        v.invert();\n        v.transform(p);\n        float panelY = (float) (tan(fov) * p.z);\n        float panelX = panelY * (width / height);\n        Point3f pt = new Point3f(p.x / panelX + 1, -p.y / panelY + 1, p.z);\n        pt.x = width - pt.x * (width / 2);\n        pt.y = height - pt.y * (height / 2);\n        return pt;\n    }\n\n    /**\n     * Returns the ray eminating from the point (x, y) in screen space\n     * directed along the screen z-axis.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @return the ray eminating from x, y in screen space.\n     */\n    public static PickRay castRay(Canvas3D c, int x, int y) {\n        Point3f center = toWorld(c, x, y);\n        Point3f d = toWorld(c, x, y, c.getView().getFrontClipDistance() + 0.1f);\n        Vector3f forward = new Vector3f(center);\n        forward.sub(d);\n        return new PickRay(center, forward);\n    }\n\n    /**\n     * @param path the path to the image to open.\n     */\n    public static BufferedImage getBufferedImage(String path) {\n        BufferedImage bufferedImage = null;\n        try {\n            bufferedImage = ImageIO.read(path.getClass().getResource(path));\n        } catch (Exception e) {\n            try {\n                bufferedImage = ImageIO.read(new File(path));\n            } catch (Exception x) {\n                System.err.println(\"craps!\");\n                x.printStackTrace(System.err);\n            }\n        }\n        return bufferedImage;\n    }\n\n    /**\n     * Sets the specified texture to the specified appearance. The texture\n     * mode is set to modulated.\n     *\n     * reference: Java Cool Dude\n     */\n    public static void setTexture2D(Shape3D shape, String path) {\n        setTexture2D(shape, path, false, true, true);\n    }\n\n    public static void setTexture2D(Shape3D shape, String path, boolean clip, boolean blend, boolean depth) {\n        Appearance appr = shape.getAppearance();\n        if (appr == null) {\n            appr = new Appearance();\n            shape.setAppearance(appr);\n        }\n        setTexture2D(path, appr, clip, blend, depth);\n    }\n\n    public static void setTexture2D(String path, Appearance appr) {\n        setTexture2D(path, appr, false, false, false);\n    }\n\n    public static void setTexture2D(String path, Appearance appr, boolean clip, boolean blend, boolean depth) {\n        BufferedImage bufferedImage = getBufferedImage(path);\n        TextureLoader tl = TextureLoader.getInstance();\n        if (!depth) {\n            RenderingAttributes rendattr = new RenderingAttributes();\n            rendattr.setDepthBufferEnable(false);\n            appr.setRenderingAttributes(rendattr);\n        }\n        if (blend) {\n            TransparencyAttributes aattr = new TransparencyAttributes();\n            aattr.setTransparencyMode(TransparencyAttributes.BLENDED);\n            aattr.setTransparency(0.0f);\n            aattr.setDstBlendFunction(TransparencyAttributes.BLEND_ONE);\n            aattr.setSrcBlendFunction(TransparencyAttributes.BLEND_SRC_ALPHA);\n            appr.setTransparencyAttributes(aattr);\n        }\n        if (clip) {\n            TextureAttributes texattr = new TextureAttributes();\n            texattr.setTextureMode(TextureAttributes.MODULATE);\n            texattr.setPerspectiveCorrectionMode(TextureAttributes.FASTEST);\n            appr.setTextureAttributes(texattr);\n        }\n        bufferedImage = DirectBufferedImage.make(bufferedImage, false);\n        Texture2D texture = (Texture2D) tl.constructTexture(bufferedImage, \"RGB\", false, Texture.BASE_LEVEL_LINEAR, Texture.BASE_LEVEL_LINEAR, Texture.WRAP, false, TextureLoader.SCALE_DRAW_BEST);\n        appr.setTexture(texture);\n    }\n\n    /**\n     * Enable picking of this node by traversing the scenegraph to the\n     * root and setting each node to be pickable.\n     *\n     * @param name the name used to identify this node.\n     */\n    public static void setPickable(Node node, String name) {\n        Node g = node.getParent();\n        while (g != null) {\n            g.setPickable(true);\n            g = g.getParent();\n        }\n        if (node instanceof Group) {\n            setPickableRecursive((Group) node, name);\n        }\n    }\n\n    /**\n     * Set all children of the specified group to be pickable.\n     *\n     * @param group the node at which to start.\n     * @param name the name used to identify the nodes.\n     */\n    public static void setPickableRecursive(Group group, String name) {\n        if (group == null) {\n            return;\n        }\n        group.setPickable(true);\n        java.util.Enumeration e = group.getAllChildren();\n        while (e.hasMoreElements()) {\n            Node node = (Node) e.nextElement();\n            // if it's a group rename all children\n            if (node instanceof Group) {\n                setPickableRecursive((Group) node, name);\n            } else {\n                node.setPickable(true);\n                if (node instanceof Shape3D) {\n                    node.setName(name);\n                }\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/Util3DTest3.java",
		"test_prompt": "// Util3DTest3.java\npackage gui.gl;\n\nimport static java.lang.Math.PI;\nimport static java.lang.Math.tan;\nimport static java.lang.Math.cos;\nimport static java.lang.Math.sin;\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.loaders.texture.*;\nimport com.xith3d.render.*;\nimport com.xith3d.render.jogl.*;\nimport javax.imageio.ImageIO;\nimport java.io.*;\nimport com.xith3d.image.DirectBufferedImage;\nimport java.awt.image.BufferedImage;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Util3D}.\n* It contains ten unit test cases for the {@link Util3D#createQuad(float, float, float, float, float)} method.\n*/\nclass Util3DTest3 {"
	},
	{
		"original_code": "// Util3D.java\n/* $Id: Util3D.java,v 1.6 2004/04/27 19:26:21 bja Exp $ */\npackage gui.gl;\n\nimport static java.lang.Math.PI;\nimport static java.lang.Math.tan;\nimport static java.lang.Math.cos;\nimport static java.lang.Math.sin;\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.loaders.texture.*;\nimport com.xith3d.render.*;\nimport com.xith3d.render.jogl.*;\nimport javax.imageio.ImageIO;\nimport java.io.*;\nimport com.xith3d.image.DirectBufferedImage;\nimport java.awt.image.BufferedImage;\n\npublic class Util3D {\n\n    public static final float rad(float ang) {\n        return (float) (ang / 180.0 * PI);\n    }\n\n    public static final float deg(float ang) {\n        return (float) (ang / PI * 180.0);\n    }\n\n    /**\n     * Creates a size-by-size wu sized plane with assigned texture\n     * coordinates. Texture coordinates are generated for two layers.\n     *\n     * @param size the size of the plane.\n     *\n     * @return the plane with the given normal and size.\n     */\n    public static Geometry createPlane(float size, float r) {\n        return createQuad(0, 0, size, r, r);\n    }\n\n    public static Geometry createQuad(float x, float y, float size, float s, float t) {\n        Point3f[] coords = new Point3f[] { new Point3f(x, 0f, y), new Point3f(x + size, 0f, y), new Point3f(x + size, 0f, y + size), new Point3f(x, 0f, y + size) };\n        TexCoord2f[] texcoords = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(s, 0f), new TexCoord2f(s, s), new TexCoord2f(0f, s) };\n        TexCoord2f[] texcoords2 = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(t, 0f), new TexCoord2f(t, t), new TexCoord2f(0f, t) };\n        QuadArray plane = new QuadArray(coords.length, GeometryArray.COORDINATES | GeometryArray.TEXTURE_COORDINATE_2, 2, new int[] { 0, 1 });\n        plane.setCoordinates(0, coords);\n        plane.setTextureCoordinates(0, 0, texcoords);\n        plane.setTextureCoordinates(1, 0, texcoords2);\n        return plane;\n    }\n\n    /**\n     * Create a new textured plane shape node.\n     *\n     * @param path the texture to apply to the plane.\n     * @param s the size of the plane.\n     * @param r the number of repetitions.\n     */\n    public static Shape3D createTexturedPlane(String path, float s, float r) {\n        TextureLoader loader = TextureLoader.getInstance();\n        // fixa\n        loader.registerPath(\"./\");\n        // fixa\n        loader.registerPath(\"./dat/tex/\");\n        // fixa\n        loader.registerPath(\"./dat/mdl/\");\n        // fixa\n        loader.registerPath(\"./dat/gfx/\");\n        Appearance appearance = new Appearance();\n        appearance.setTexture((Texture2D) loader.getMinMapTexture(path));\n        // Set polygon offset so that we can see objects lying in the\n        // same plane as the grid.\n        PolygonAttributes polyAttr = new PolygonAttributes();\n        polyAttr.setPolygonOffset(10.0f);\n        polyAttr.setPolygonOffsetFactor(20.0f);\n        appearance.setPolygonAttributes(polyAttr);\n        return new Shape3D(createPlane(s, r), appearance);\n    }\n\n    public static Geometry createRectangle(float w, float h, Color3f color) {\n        Point3f[] coords = new Point3f[] { new Point3f(0f, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, h), new Point3f(w, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, 0f) };\n        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);\n        Color3f[] colors = new Color3f[] { new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z) };\n        lines.setCoordinates(0, coords);\n        lines.setColors(0, colors);\n        return lines;\n    }\n\n    /**\n     * Creates the default coordinate axes with specified length.\n     * @param size the length of the axes.\n     */\n    public static Geometry createCoordAxes(float size) {\n        Point3f[] coords = new Point3f[] { new Point3f(0, 0, 0), new Point3f(size, 0, 0), new Point3f(0, 0, 0), new Point3f(0, size, 0), new Point3f(0, 0, 0), new Point3f(0, 0, size) };\n        Color3f[] colors = new Color3f[] { new Color3f(0, 0, 1), new Color3f(0, 0, 1), new Color3f(1, 0, 0), new Color3f(1, 0, 0), new Color3f(0, 1, 0), new Color3f(0, 1, 0) };\n        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);\n        lines.setCoordinates(0, coords);\n        lines.setColors(0, colors);\n        return lines;\n    }\n\n    /**\n     * Creates a new grid with the specified number of rows and columns,\n     * and with the specified cell size.\n     *\n     * @param cols the number of cols in the grid.\n     * @param rows the number of rows in the grid.\n     * @param size the size of a single cell.\n     */\n    public static Shape3D createGrid(int cols, int rows, float size) {\n        rows++;\n        cols++;\n        Point3f[] coords = new Point3f[2 * (rows + cols)];\n        LineArray grid = new LineArray(coords.length, GeometryArray.COORDINATES);\n        for (int i = 1; i < 2 * rows; i += 2) {\n            coords[i - 1] = new Point3f(0, 0.01f, .5f * size * (i - 1));\n            coords[i] = new Point3f((cols - 1) * size, 0.01f, .5f * size * (i - 1));\n        }\n        for (int j = 1; j < 2 * cols; j += 2) {\n            coords[2 * rows + j - 1] = new Point3f(.5f * size * (j - 1), 0.01f, 0);\n            coords[2 * rows + j] = new Point3f(.5f * size * (j - 1), 0.01f, (rows - 1) * size);\n        }\n        grid.setCoordinates(0, coords);\n        return new Shape3D(grid);\n    }\n\n    /* The following methods are for converting screen coordinates to     \n     * world coordinates. They are taken from the xith3d forum and \n     * modified to fit the application.\n     *                                                                    \n     * Reference: kevglass                                                \n     *                                                                    \n     * http://www.javagaming.org/cgi-bin/JGNetForums/YaBB.cgi?            \n     *        board=xith3d;action=display;num=1068252077;start=15         \n     */\n    /**\n     * Returns the point in world space corresponding to the given\n     * coordinates in screen space.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @return the point in world space at the given depth.\n     */\n    public static Point3f toWorld(Canvas3D c, int x, int y) {\n        return toWorld(c, x, y, c.getView().getFrontClipDistance());\n    }\n\n    /**\n     * Returns the point in world space corresponding to the given\n     * coordinates in screen space.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @param z the z coordinate (depth).\n     * @return the point in world space at the given depth.\n     */\n    public static Point3f toWorld(Canvas3D c, int x, int y, float z) {\n        float fov = c.getView().getFieldOfView();\n        float width = c.getWidth();\n        float height = c.getHeight();\n        float panelY = (float) (tan(fov) * z);\n        float panelX = panelY * (width / height);\n        float xp = x / (width / 2);\n        float yp = y / (height / 2);\n        Point3f pt = new Point3f((xp - 1) * panelX, (1 - yp) * panelY, -z);\n        Transform3D v = new Transform3D();\n        c.getView().getTransform(v);\n        v.transform(pt);\n        return pt;\n    }\n\n    /**\n     * Returns the point in screen space corresponding to the given\n     * coordinates in world space.\n     *\n     * @param c the associated canvas.\n     * @param x the world x coordinate.\n     * @param y the world y coordinate.\n     * @param z the world z coordinate.\n     * @return the corresponding point in screen space.\n     */\n    public static Point3f toScreen(Canvas3D c, Point3f p) {\n        return toScreen(c, p.x, p.y, p.z);\n    }\n\n    public static Point3f toScreen(Canvas3D c, float x, float y, float z) {\n        float fov = c.getView().getFieldOfView();\n        float width = c.getWidth();\n        float height = c.getHeight();\n        Transform3D v = new Transform3D();\n        c.getView().getTransform(v);\n        Point3f p = new Point3f(x, y, z);\n        v.invert();\n        v.transform(p);\n        float panelY = (float) (tan(fov) * p.z);\n        float panelX = panelY * (width / height);\n        Point3f pt = new Point3f(p.x / panelX + 1, -p.y / panelY + 1, p.z);\n        pt.x = width - pt.x * (width / 2);\n        pt.y = height - pt.y * (height / 2);\n        return pt;\n    }\n\n    /**\n     * Returns the ray eminating from the point (x, y) in screen space\n     * directed along the screen z-axis.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @return the ray eminating from x, y in screen space.\n     */\n    public static PickRay castRay(Canvas3D c, int x, int y) {\n        Point3f center = toWorld(c, x, y);\n        Point3f d = toWorld(c, x, y, c.getView().getFrontClipDistance() + 0.1f);\n        Vector3f forward = new Vector3f(center);\n        forward.sub(d);\n        return new PickRay(center, forward);\n    }\n\n    /**\n     * @param path the path to the image to open.\n     */\n    public static BufferedImage getBufferedImage(String path) {\n        BufferedImage bufferedImage = null;\n        try {\n            bufferedImage = ImageIO.read(path.getClass().getResource(path));\n        } catch (Exception e) {\n            try {\n                bufferedImage = ImageIO.read(new File(path));\n            } catch (Exception x) {\n                System.err.println(\"craps!\");\n                x.printStackTrace(System.err);\n            }\n        }\n        return bufferedImage;\n    }\n\n    /**\n     * Sets the specified texture to the specified appearance. The texture\n     * mode is set to modulated.\n     *\n     * reference: Java Cool Dude\n     */\n    public static void setTexture2D(Shape3D shape, String path) {\n        setTexture2D(shape, path, false, true, true);\n    }\n\n    public static void setTexture2D(Shape3D shape, String path, boolean clip, boolean blend, boolean depth) {\n        Appearance appr = shape.getAppearance();\n        if (appr == null) {\n            appr = new Appearance();\n            shape.setAppearance(appr);\n        }\n        setTexture2D(path, appr, clip, blend, depth);\n    }\n\n    public static void setTexture2D(String path, Appearance appr) {\n        setTexture2D(path, appr, false, false, false);\n    }\n\n    public static void setTexture2D(String path, Appearance appr, boolean clip, boolean blend, boolean depth) {\n        BufferedImage bufferedImage = getBufferedImage(path);\n        TextureLoader tl = TextureLoader.getInstance();\n        if (!depth) {\n            RenderingAttributes rendattr = new RenderingAttributes();\n            rendattr.setDepthBufferEnable(false);\n            appr.setRenderingAttributes(rendattr);\n        }\n        if (blend) {\n            TransparencyAttributes aattr = new TransparencyAttributes();\n            aattr.setTransparencyMode(TransparencyAttributes.BLENDED);\n            aattr.setTransparency(0.0f);\n            aattr.setDstBlendFunction(TransparencyAttributes.BLEND_ONE);\n            aattr.setSrcBlendFunction(TransparencyAttributes.BLEND_SRC_ALPHA);\n            appr.setTransparencyAttributes(aattr);\n        }\n        if (clip) {\n            TextureAttributes texattr = new TextureAttributes();\n            texattr.setTextureMode(TextureAttributes.MODULATE);\n            texattr.setPerspectiveCorrectionMode(TextureAttributes.FASTEST);\n            appr.setTextureAttributes(texattr);\n        }\n        bufferedImage = DirectBufferedImage.make(bufferedImage, false);\n        Texture2D texture = (Texture2D) tl.constructTexture(bufferedImage, \"RGB\", false, Texture.BASE_LEVEL_LINEAR, Texture.BASE_LEVEL_LINEAR, Texture.WRAP, false, TextureLoader.SCALE_DRAW_BEST);\n        appr.setTexture(texture);\n    }\n\n    /**\n     * Enable picking of this node by traversing the scenegraph to the\n     * root and setting each node to be pickable.\n     *\n     * @param name the name used to identify this node.\n     */\n    public static void setPickable(Node node, String name) {\n        Node g = node.getParent();\n        while (g != null) {\n            g.setPickable(true);\n            g = g.getParent();\n        }\n        if (node instanceof Group) {\n            setPickableRecursive((Group) node, name);\n        }\n    }\n\n    /**\n     * Set all children of the specified group to be pickable.\n     *\n     * @param group the node at which to start.\n     * @param name the name used to identify the nodes.\n     */\n    public static void setPickableRecursive(Group group, String name) {\n        if (group == null) {\n            return;\n        }\n        group.setPickable(true);\n        java.util.Enumeration e = group.getAllChildren();\n        while (e.hasMoreElements()) {\n            Node node = (Node) e.nextElement();\n            // if it's a group rename all children\n            if (node instanceof Group) {\n                setPickableRecursive((Group) node, name);\n            } else {\n                node.setPickable(true);\n                if (node instanceof Shape3D) {\n                    node.setName(name);\n                }\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/Util3DTest4.java",
		"test_prompt": "// Util3DTest4.java\npackage gui.gl;\n\nimport static java.lang.Math.PI;\nimport static java.lang.Math.tan;\nimport static java.lang.Math.cos;\nimport static java.lang.Math.sin;\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.loaders.texture.*;\nimport com.xith3d.render.*;\nimport com.xith3d.render.jogl.*;\nimport javax.imageio.ImageIO;\nimport java.io.*;\nimport com.xith3d.image.DirectBufferedImage;\nimport java.awt.image.BufferedImage;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Util3D}.\n* It contains ten unit test cases for the {@link Util3D#createTexturedPlane(String, float, float)} method.\n*/\nclass Util3DTest4 {"
	},
	{
		"original_code": "// Util3D.java\n/* $Id: Util3D.java,v 1.6 2004/04/27 19:26:21 bja Exp $ */\npackage gui.gl;\n\nimport static java.lang.Math.PI;\nimport static java.lang.Math.tan;\nimport static java.lang.Math.cos;\nimport static java.lang.Math.sin;\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.loaders.texture.*;\nimport com.xith3d.render.*;\nimport com.xith3d.render.jogl.*;\nimport javax.imageio.ImageIO;\nimport java.io.*;\nimport com.xith3d.image.DirectBufferedImage;\nimport java.awt.image.BufferedImage;\n\npublic class Util3D {\n\n    public static final float rad(float ang) {\n        return (float) (ang / 180.0 * PI);\n    }\n\n    public static final float deg(float ang) {\n        return (float) (ang / PI * 180.0);\n    }\n\n    /**\n     * Creates a size-by-size wu sized plane with assigned texture\n     * coordinates. Texture coordinates are generated for two layers.\n     *\n     * @param size the size of the plane.\n     *\n     * @return the plane with the given normal and size.\n     */\n    public static Geometry createPlane(float size, float r) {\n        return createQuad(0, 0, size, r, r);\n    }\n\n    public static Geometry createQuad(float x, float y, float size, float s, float t) {\n        Point3f[] coords = new Point3f[] { new Point3f(x, 0f, y), new Point3f(x + size, 0f, y), new Point3f(x + size, 0f, y + size), new Point3f(x, 0f, y + size) };\n        TexCoord2f[] texcoords = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(s, 0f), new TexCoord2f(s, s), new TexCoord2f(0f, s) };\n        TexCoord2f[] texcoords2 = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(t, 0f), new TexCoord2f(t, t), new TexCoord2f(0f, t) };\n        QuadArray plane = new QuadArray(coords.length, GeometryArray.COORDINATES | GeometryArray.TEXTURE_COORDINATE_2, 2, new int[] { 0, 1 });\n        plane.setCoordinates(0, coords);\n        plane.setTextureCoordinates(0, 0, texcoords);\n        plane.setTextureCoordinates(1, 0, texcoords2);\n        return plane;\n    }\n\n    /**\n     * Create a new textured plane shape node.\n     *\n     * @param path the texture to apply to the plane.\n     * @param s the size of the plane.\n     * @param r the number of repetitions.\n     */\n    public static Shape3D createTexturedPlane(String path, float s, float r) {\n        TextureLoader loader = TextureLoader.getInstance();\n        // fixa\n        loader.registerPath(\"./\");\n        // fixa\n        loader.registerPath(\"./dat/tex/\");\n        // fixa\n        loader.registerPath(\"./dat/mdl/\");\n        // fixa\n        loader.registerPath(\"./dat/gfx/\");\n        Appearance appearance = new Appearance();\n        appearance.setTexture((Texture2D) loader.getMinMapTexture(path));\n        // Set polygon offset so that we can see objects lying in the\n        // same plane as the grid.\n        PolygonAttributes polyAttr = new PolygonAttributes();\n        polyAttr.setPolygonOffset(10.0f);\n        polyAttr.setPolygonOffsetFactor(20.0f);\n        appearance.setPolygonAttributes(polyAttr);\n        return new Shape3D(createPlane(s, r), appearance);\n    }\n\n    public static Geometry createRectangle(float w, float h, Color3f color) {\n        Point3f[] coords = new Point3f[] { new Point3f(0f, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, h), new Point3f(w, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, 0f) };\n        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);\n        Color3f[] colors = new Color3f[] { new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z) };\n        lines.setCoordinates(0, coords);\n        lines.setColors(0, colors);\n        return lines;\n    }\n\n    /**\n     * Creates the default coordinate axes with specified length.\n     * @param size the length of the axes.\n     */\n    public static Geometry createCoordAxes(float size) {\n        Point3f[] coords = new Point3f[] { new Point3f(0, 0, 0), new Point3f(size, 0, 0), new Point3f(0, 0, 0), new Point3f(0, size, 0), new Point3f(0, 0, 0), new Point3f(0, 0, size) };\n        Color3f[] colors = new Color3f[] { new Color3f(0, 0, 1), new Color3f(0, 0, 1), new Color3f(1, 0, 0), new Color3f(1, 0, 0), new Color3f(0, 1, 0), new Color3f(0, 1, 0) };\n        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);\n        lines.setCoordinates(0, coords);\n        lines.setColors(0, colors);\n        return lines;\n    }\n\n    /**\n     * Creates a new grid with the specified number of rows and columns,\n     * and with the specified cell size.\n     *\n     * @param cols the number of cols in the grid.\n     * @param rows the number of rows in the grid.\n     * @param size the size of a single cell.\n     */\n    public static Shape3D createGrid(int cols, int rows, float size) {\n        rows++;\n        cols++;\n        Point3f[] coords = new Point3f[2 * (rows + cols)];\n        LineArray grid = new LineArray(coords.length, GeometryArray.COORDINATES);\n        for (int i = 1; i < 2 * rows; i += 2) {\n            coords[i - 1] = new Point3f(0, 0.01f, .5f * size * (i - 1));\n            coords[i] = new Point3f((cols - 1) * size, 0.01f, .5f * size * (i - 1));\n        }\n        for (int j = 1; j < 2 * cols; j += 2) {\n            coords[2 * rows + j - 1] = new Point3f(.5f * size * (j - 1), 0.01f, 0);\n            coords[2 * rows + j] = new Point3f(.5f * size * (j - 1), 0.01f, (rows - 1) * size);\n        }\n        grid.setCoordinates(0, coords);\n        return new Shape3D(grid);\n    }\n\n    /* The following methods are for converting screen coordinates to     \n     * world coordinates. They are taken from the xith3d forum and \n     * modified to fit the application.\n     *                                                                    \n     * Reference: kevglass                                                \n     *                                                                    \n     * http://www.javagaming.org/cgi-bin/JGNetForums/YaBB.cgi?            \n     *        board=xith3d;action=display;num=1068252077;start=15         \n     */\n    /**\n     * Returns the point in world space corresponding to the given\n     * coordinates in screen space.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @return the point in world space at the given depth.\n     */\n    public static Point3f toWorld(Canvas3D c, int x, int y) {\n        return toWorld(c, x, y, c.getView().getFrontClipDistance());\n    }\n\n    /**\n     * Returns the point in world space corresponding to the given\n     * coordinates in screen space.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @param z the z coordinate (depth).\n     * @return the point in world space at the given depth.\n     */\n    public static Point3f toWorld(Canvas3D c, int x, int y, float z) {\n        float fov = c.getView().getFieldOfView();\n        float width = c.getWidth();\n        float height = c.getHeight();\n        float panelY = (float) (tan(fov) * z);\n        float panelX = panelY * (width / height);\n        float xp = x / (width / 2);\n        float yp = y / (height / 2);\n        Point3f pt = new Point3f((xp - 1) * panelX, (1 - yp) * panelY, -z);\n        Transform3D v = new Transform3D();\n        c.getView().getTransform(v);\n        v.transform(pt);\n        return pt;\n    }\n\n    /**\n     * Returns the point in screen space corresponding to the given\n     * coordinates in world space.\n     *\n     * @param c the associated canvas.\n     * @param x the world x coordinate.\n     * @param y the world y coordinate.\n     * @param z the world z coordinate.\n     * @return the corresponding point in screen space.\n     */\n    public static Point3f toScreen(Canvas3D c, Point3f p) {\n        return toScreen(c, p.x, p.y, p.z);\n    }\n\n    public static Point3f toScreen(Canvas3D c, float x, float y, float z) {\n        float fov = c.getView().getFieldOfView();\n        float width = c.getWidth();\n        float height = c.getHeight();\n        Transform3D v = new Transform3D();\n        c.getView().getTransform(v);\n        Point3f p = new Point3f(x, y, z);\n        v.invert();\n        v.transform(p);\n        float panelY = (float) (tan(fov) * p.z);\n        float panelX = panelY * (width / height);\n        Point3f pt = new Point3f(p.x / panelX + 1, -p.y / panelY + 1, p.z);\n        pt.x = width - pt.x * (width / 2);\n        pt.y = height - pt.y * (height / 2);\n        return pt;\n    }\n\n    /**\n     * Returns the ray eminating from the point (x, y) in screen space\n     * directed along the screen z-axis.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @return the ray eminating from x, y in screen space.\n     */\n    public static PickRay castRay(Canvas3D c, int x, int y) {\n        Point3f center = toWorld(c, x, y);\n        Point3f d = toWorld(c, x, y, c.getView().getFrontClipDistance() + 0.1f);\n        Vector3f forward = new Vector3f(center);\n        forward.sub(d);\n        return new PickRay(center, forward);\n    }\n\n    /**\n     * @param path the path to the image to open.\n     */\n    public static BufferedImage getBufferedImage(String path) {\n        BufferedImage bufferedImage = null;\n        try {\n            bufferedImage = ImageIO.read(path.getClass().getResource(path));\n        } catch (Exception e) {\n            try {\n                bufferedImage = ImageIO.read(new File(path));\n            } catch (Exception x) {\n                System.err.println(\"craps!\");\n                x.printStackTrace(System.err);\n            }\n        }\n        return bufferedImage;\n    }\n\n    /**\n     * Sets the specified texture to the specified appearance. The texture\n     * mode is set to modulated.\n     *\n     * reference: Java Cool Dude\n     */\n    public static void setTexture2D(Shape3D shape, String path) {\n        setTexture2D(shape, path, false, true, true);\n    }\n\n    public static void setTexture2D(Shape3D shape, String path, boolean clip, boolean blend, boolean depth) {\n        Appearance appr = shape.getAppearance();\n        if (appr == null) {\n            appr = new Appearance();\n            shape.setAppearance(appr);\n        }\n        setTexture2D(path, appr, clip, blend, depth);\n    }\n\n    public static void setTexture2D(String path, Appearance appr) {\n        setTexture2D(path, appr, false, false, false);\n    }\n\n    public static void setTexture2D(String path, Appearance appr, boolean clip, boolean blend, boolean depth) {\n        BufferedImage bufferedImage = getBufferedImage(path);\n        TextureLoader tl = TextureLoader.getInstance();\n        if (!depth) {\n            RenderingAttributes rendattr = new RenderingAttributes();\n            rendattr.setDepthBufferEnable(false);\n            appr.setRenderingAttributes(rendattr);\n        }\n        if (blend) {\n            TransparencyAttributes aattr = new TransparencyAttributes();\n            aattr.setTransparencyMode(TransparencyAttributes.BLENDED);\n            aattr.setTransparency(0.0f);\n            aattr.setDstBlendFunction(TransparencyAttributes.BLEND_ONE);\n            aattr.setSrcBlendFunction(TransparencyAttributes.BLEND_SRC_ALPHA);\n            appr.setTransparencyAttributes(aattr);\n        }\n        if (clip) {\n            TextureAttributes texattr = new TextureAttributes();\n            texattr.setTextureMode(TextureAttributes.MODULATE);\n            texattr.setPerspectiveCorrectionMode(TextureAttributes.FASTEST);\n            appr.setTextureAttributes(texattr);\n        }\n        bufferedImage = DirectBufferedImage.make(bufferedImage, false);\n        Texture2D texture = (Texture2D) tl.constructTexture(bufferedImage, \"RGB\", false, Texture.BASE_LEVEL_LINEAR, Texture.BASE_LEVEL_LINEAR, Texture.WRAP, false, TextureLoader.SCALE_DRAW_BEST);\n        appr.setTexture(texture);\n    }\n\n    /**\n     * Enable picking of this node by traversing the scenegraph to the\n     * root and setting each node to be pickable.\n     *\n     * @param name the name used to identify this node.\n     */\n    public static void setPickable(Node node, String name) {\n        Node g = node.getParent();\n        while (g != null) {\n            g.setPickable(true);\n            g = g.getParent();\n        }\n        if (node instanceof Group) {\n            setPickableRecursive((Group) node, name);\n        }\n    }\n\n    /**\n     * Set all children of the specified group to be pickable.\n     *\n     * @param group the node at which to start.\n     * @param name the name used to identify the nodes.\n     */\n    public static void setPickableRecursive(Group group, String name) {\n        if (group == null) {\n            return;\n        }\n        group.setPickable(true);\n        java.util.Enumeration e = group.getAllChildren();\n        while (e.hasMoreElements()) {\n            Node node = (Node) e.nextElement();\n            // if it's a group rename all children\n            if (node instanceof Group) {\n                setPickableRecursive((Group) node, name);\n            } else {\n                node.setPickable(true);\n                if (node instanceof Shape3D) {\n                    node.setName(name);\n                }\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/Util3DTest5.java",
		"test_prompt": "// Util3DTest5.java\npackage gui.gl;\n\nimport static java.lang.Math.PI;\nimport static java.lang.Math.tan;\nimport static java.lang.Math.cos;\nimport static java.lang.Math.sin;\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.loaders.texture.*;\nimport com.xith3d.render.*;\nimport com.xith3d.render.jogl.*;\nimport javax.imageio.ImageIO;\nimport java.io.*;\nimport com.xith3d.image.DirectBufferedImage;\nimport java.awt.image.BufferedImage;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Util3D}.\n* It contains ten unit test cases for the {@link Util3D#createRectangle(float, float, Color3f)} method.\n*/\nclass Util3DTest5 {"
	},
	{
		"original_code": "// Util3D.java\n/* $Id: Util3D.java,v 1.6 2004/04/27 19:26:21 bja Exp $ */\npackage gui.gl;\n\nimport static java.lang.Math.PI;\nimport static java.lang.Math.tan;\nimport static java.lang.Math.cos;\nimport static java.lang.Math.sin;\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.loaders.texture.*;\nimport com.xith3d.render.*;\nimport com.xith3d.render.jogl.*;\nimport javax.imageio.ImageIO;\nimport java.io.*;\nimport com.xith3d.image.DirectBufferedImage;\nimport java.awt.image.BufferedImage;\n\npublic class Util3D {\n\n    public static final float rad(float ang) {\n        return (float) (ang / 180.0 * PI);\n    }\n\n    public static final float deg(float ang) {\n        return (float) (ang / PI * 180.0);\n    }\n\n    /**\n     * Creates a size-by-size wu sized plane with assigned texture\n     * coordinates. Texture coordinates are generated for two layers.\n     *\n     * @param size the size of the plane.\n     *\n     * @return the plane with the given normal and size.\n     */\n    public static Geometry createPlane(float size, float r) {\n        return createQuad(0, 0, size, r, r);\n    }\n\n    public static Geometry createQuad(float x, float y, float size, float s, float t) {\n        Point3f[] coords = new Point3f[] { new Point3f(x, 0f, y), new Point3f(x + size, 0f, y), new Point3f(x + size, 0f, y + size), new Point3f(x, 0f, y + size) };\n        TexCoord2f[] texcoords = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(s, 0f), new TexCoord2f(s, s), new TexCoord2f(0f, s) };\n        TexCoord2f[] texcoords2 = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(t, 0f), new TexCoord2f(t, t), new TexCoord2f(0f, t) };\n        QuadArray plane = new QuadArray(coords.length, GeometryArray.COORDINATES | GeometryArray.TEXTURE_COORDINATE_2, 2, new int[] { 0, 1 });\n        plane.setCoordinates(0, coords);\n        plane.setTextureCoordinates(0, 0, texcoords);\n        plane.setTextureCoordinates(1, 0, texcoords2);\n        return plane;\n    }\n\n    /**\n     * Create a new textured plane shape node.\n     *\n     * @param path the texture to apply to the plane.\n     * @param s the size of the plane.\n     * @param r the number of repetitions.\n     */\n    public static Shape3D createTexturedPlane(String path, float s, float r) {\n        TextureLoader loader = TextureLoader.getInstance();\n        // fixa\n        loader.registerPath(\"./\");\n        // fixa\n        loader.registerPath(\"./dat/tex/\");\n        // fixa\n        loader.registerPath(\"./dat/mdl/\");\n        // fixa\n        loader.registerPath(\"./dat/gfx/\");\n        Appearance appearance = new Appearance();\n        appearance.setTexture((Texture2D) loader.getMinMapTexture(path));\n        // Set polygon offset so that we can see objects lying in the\n        // same plane as the grid.\n        PolygonAttributes polyAttr = new PolygonAttributes();\n        polyAttr.setPolygonOffset(10.0f);\n        polyAttr.setPolygonOffsetFactor(20.0f);\n        appearance.setPolygonAttributes(polyAttr);\n        return new Shape3D(createPlane(s, r), appearance);\n    }\n\n    public static Geometry createRectangle(float w, float h, Color3f color) {\n        Point3f[] coords = new Point3f[] { new Point3f(0f, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, h), new Point3f(w, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, 0f) };\n        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);\n        Color3f[] colors = new Color3f[] { new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z) };\n        lines.setCoordinates(0, coords);\n        lines.setColors(0, colors);\n        return lines;\n    }\n\n    /**\n     * Creates the default coordinate axes with specified length.\n     * @param size the length of the axes.\n     */\n    public static Geometry createCoordAxes(float size) {\n        Point3f[] coords = new Point3f[] { new Point3f(0, 0, 0), new Point3f(size, 0, 0), new Point3f(0, 0, 0), new Point3f(0, size, 0), new Point3f(0, 0, 0), new Point3f(0, 0, size) };\n        Color3f[] colors = new Color3f[] { new Color3f(0, 0, 1), new Color3f(0, 0, 1), new Color3f(1, 0, 0), new Color3f(1, 0, 0), new Color3f(0, 1, 0), new Color3f(0, 1, 0) };\n        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);\n        lines.setCoordinates(0, coords);\n        lines.setColors(0, colors);\n        return lines;\n    }\n\n    /**\n     * Creates a new grid with the specified number of rows and columns,\n     * and with the specified cell size.\n     *\n     * @param cols the number of cols in the grid.\n     * @param rows the number of rows in the grid.\n     * @param size the size of a single cell.\n     */\n    public static Shape3D createGrid(int cols, int rows, float size) {\n        rows++;\n        cols++;\n        Point3f[] coords = new Point3f[2 * (rows + cols)];\n        LineArray grid = new LineArray(coords.length, GeometryArray.COORDINATES);\n        for (int i = 1; i < 2 * rows; i += 2) {\n            coords[i - 1] = new Point3f(0, 0.01f, .5f * size * (i - 1));\n            coords[i] = new Point3f((cols - 1) * size, 0.01f, .5f * size * (i - 1));\n        }\n        for (int j = 1; j < 2 * cols; j += 2) {\n            coords[2 * rows + j - 1] = new Point3f(.5f * size * (j - 1), 0.01f, 0);\n            coords[2 * rows + j] = new Point3f(.5f * size * (j - 1), 0.01f, (rows - 1) * size);\n        }\n        grid.setCoordinates(0, coords);\n        return new Shape3D(grid);\n    }\n\n    /* The following methods are for converting screen coordinates to     \n     * world coordinates. They are taken from the xith3d forum and \n     * modified to fit the application.\n     *                                                                    \n     * Reference: kevglass                                                \n     *                                                                    \n     * http://www.javagaming.org/cgi-bin/JGNetForums/YaBB.cgi?            \n     *        board=xith3d;action=display;num=1068252077;start=15         \n     */\n    /**\n     * Returns the point in world space corresponding to the given\n     * coordinates in screen space.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @return the point in world space at the given depth.\n     */\n    public static Point3f toWorld(Canvas3D c, int x, int y) {\n        return toWorld(c, x, y, c.getView().getFrontClipDistance());\n    }\n\n    /**\n     * Returns the point in world space corresponding to the given\n     * coordinates in screen space.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @param z the z coordinate (depth).\n     * @return the point in world space at the given depth.\n     */\n    public static Point3f toWorld(Canvas3D c, int x, int y, float z) {\n        float fov = c.getView().getFieldOfView();\n        float width = c.getWidth();\n        float height = c.getHeight();\n        float panelY = (float) (tan(fov) * z);\n        float panelX = panelY * (width / height);\n        float xp = x / (width / 2);\n        float yp = y / (height / 2);\n        Point3f pt = new Point3f((xp - 1) * panelX, (1 - yp) * panelY, -z);\n        Transform3D v = new Transform3D();\n        c.getView().getTransform(v);\n        v.transform(pt);\n        return pt;\n    }\n\n    /**\n     * Returns the point in screen space corresponding to the given\n     * coordinates in world space.\n     *\n     * @param c the associated canvas.\n     * @param x the world x coordinate.\n     * @param y the world y coordinate.\n     * @param z the world z coordinate.\n     * @return the corresponding point in screen space.\n     */\n    public static Point3f toScreen(Canvas3D c, Point3f p) {\n        return toScreen(c, p.x, p.y, p.z);\n    }\n\n    public static Point3f toScreen(Canvas3D c, float x, float y, float z) {\n        float fov = c.getView().getFieldOfView();\n        float width = c.getWidth();\n        float height = c.getHeight();\n        Transform3D v = new Transform3D();\n        c.getView().getTransform(v);\n        Point3f p = new Point3f(x, y, z);\n        v.invert();\n        v.transform(p);\n        float panelY = (float) (tan(fov) * p.z);\n        float panelX = panelY * (width / height);\n        Point3f pt = new Point3f(p.x / panelX + 1, -p.y / panelY + 1, p.z);\n        pt.x = width - pt.x * (width / 2);\n        pt.y = height - pt.y * (height / 2);\n        return pt;\n    }\n\n    /**\n     * Returns the ray eminating from the point (x, y) in screen space\n     * directed along the screen z-axis.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @return the ray eminating from x, y in screen space.\n     */\n    public static PickRay castRay(Canvas3D c, int x, int y) {\n        Point3f center = toWorld(c, x, y);\n        Point3f d = toWorld(c, x, y, c.getView().getFrontClipDistance() + 0.1f);\n        Vector3f forward = new Vector3f(center);\n        forward.sub(d);\n        return new PickRay(center, forward);\n    }\n\n    /**\n     * @param path the path to the image to open.\n     */\n    public static BufferedImage getBufferedImage(String path) {\n        BufferedImage bufferedImage = null;\n        try {\n            bufferedImage = ImageIO.read(path.getClass().getResource(path));\n        } catch (Exception e) {\n            try {\n                bufferedImage = ImageIO.read(new File(path));\n            } catch (Exception x) {\n                System.err.println(\"craps!\");\n                x.printStackTrace(System.err);\n            }\n        }\n        return bufferedImage;\n    }\n\n    /**\n     * Sets the specified texture to the specified appearance. The texture\n     * mode is set to modulated.\n     *\n     * reference: Java Cool Dude\n     */\n    public static void setTexture2D(Shape3D shape, String path) {\n        setTexture2D(shape, path, false, true, true);\n    }\n\n    public static void setTexture2D(Shape3D shape, String path, boolean clip, boolean blend, boolean depth) {\n        Appearance appr = shape.getAppearance();\n        if (appr == null) {\n            appr = new Appearance();\n            shape.setAppearance(appr);\n        }\n        setTexture2D(path, appr, clip, blend, depth);\n    }\n\n    public static void setTexture2D(String path, Appearance appr) {\n        setTexture2D(path, appr, false, false, false);\n    }\n\n    public static void setTexture2D(String path, Appearance appr, boolean clip, boolean blend, boolean depth) {\n        BufferedImage bufferedImage = getBufferedImage(path);\n        TextureLoader tl = TextureLoader.getInstance();\n        if (!depth) {\n            RenderingAttributes rendattr = new RenderingAttributes();\n            rendattr.setDepthBufferEnable(false);\n            appr.setRenderingAttributes(rendattr);\n        }\n        if (blend) {\n            TransparencyAttributes aattr = new TransparencyAttributes();\n            aattr.setTransparencyMode(TransparencyAttributes.BLENDED);\n            aattr.setTransparency(0.0f);\n            aattr.setDstBlendFunction(TransparencyAttributes.BLEND_ONE);\n            aattr.setSrcBlendFunction(TransparencyAttributes.BLEND_SRC_ALPHA);\n            appr.setTransparencyAttributes(aattr);\n        }\n        if (clip) {\n            TextureAttributes texattr = new TextureAttributes();\n            texattr.setTextureMode(TextureAttributes.MODULATE);\n            texattr.setPerspectiveCorrectionMode(TextureAttributes.FASTEST);\n            appr.setTextureAttributes(texattr);\n        }\n        bufferedImage = DirectBufferedImage.make(bufferedImage, false);\n        Texture2D texture = (Texture2D) tl.constructTexture(bufferedImage, \"RGB\", false, Texture.BASE_LEVEL_LINEAR, Texture.BASE_LEVEL_LINEAR, Texture.WRAP, false, TextureLoader.SCALE_DRAW_BEST);\n        appr.setTexture(texture);\n    }\n\n    /**\n     * Enable picking of this node by traversing the scenegraph to the\n     * root and setting each node to be pickable.\n     *\n     * @param name the name used to identify this node.\n     */\n    public static void setPickable(Node node, String name) {\n        Node g = node.getParent();\n        while (g != null) {\n            g.setPickable(true);\n            g = g.getParent();\n        }\n        if (node instanceof Group) {\n            setPickableRecursive((Group) node, name);\n        }\n    }\n\n    /**\n     * Set all children of the specified group to be pickable.\n     *\n     * @param group the node at which to start.\n     * @param name the name used to identify the nodes.\n     */\n    public static void setPickableRecursive(Group group, String name) {\n        if (group == null) {\n            return;\n        }\n        group.setPickable(true);\n        java.util.Enumeration e = group.getAllChildren();\n        while (e.hasMoreElements()) {\n            Node node = (Node) e.nextElement();\n            // if it's a group rename all children\n            if (node instanceof Group) {\n                setPickableRecursive((Group) node, name);\n            } else {\n                node.setPickable(true);\n                if (node instanceof Shape3D) {\n                    node.setName(name);\n                }\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/Util3DTest6.java",
		"test_prompt": "// Util3DTest6.java\npackage gui.gl;\n\nimport static java.lang.Math.PI;\nimport static java.lang.Math.tan;\nimport static java.lang.Math.cos;\nimport static java.lang.Math.sin;\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.loaders.texture.*;\nimport com.xith3d.render.*;\nimport com.xith3d.render.jogl.*;\nimport javax.imageio.ImageIO;\nimport java.io.*;\nimport com.xith3d.image.DirectBufferedImage;\nimport java.awt.image.BufferedImage;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Util3D}.\n* It contains ten unit test cases for the {@link Util3D#createCoordAxes(float)} method.\n*/\nclass Util3DTest6 {"
	},
	{
		"original_code": "// Util3D.java\n/* $Id: Util3D.java,v 1.6 2004/04/27 19:26:21 bja Exp $ */\npackage gui.gl;\n\nimport static java.lang.Math.PI;\nimport static java.lang.Math.tan;\nimport static java.lang.Math.cos;\nimport static java.lang.Math.sin;\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.loaders.texture.*;\nimport com.xith3d.render.*;\nimport com.xith3d.render.jogl.*;\nimport javax.imageio.ImageIO;\nimport java.io.*;\nimport com.xith3d.image.DirectBufferedImage;\nimport java.awt.image.BufferedImage;\n\npublic class Util3D {\n\n    public static final float rad(float ang) {\n        return (float) (ang / 180.0 * PI);\n    }\n\n    public static final float deg(float ang) {\n        return (float) (ang / PI * 180.0);\n    }\n\n    /**\n     * Creates a size-by-size wu sized plane with assigned texture\n     * coordinates. Texture coordinates are generated for two layers.\n     *\n     * @param size the size of the plane.\n     *\n     * @return the plane with the given normal and size.\n     */\n    public static Geometry createPlane(float size, float r) {\n        return createQuad(0, 0, size, r, r);\n    }\n\n    public static Geometry createQuad(float x, float y, float size, float s, float t) {\n        Point3f[] coords = new Point3f[] { new Point3f(x, 0f, y), new Point3f(x + size, 0f, y), new Point3f(x + size, 0f, y + size), new Point3f(x, 0f, y + size) };\n        TexCoord2f[] texcoords = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(s, 0f), new TexCoord2f(s, s), new TexCoord2f(0f, s) };\n        TexCoord2f[] texcoords2 = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(t, 0f), new TexCoord2f(t, t), new TexCoord2f(0f, t) };\n        QuadArray plane = new QuadArray(coords.length, GeometryArray.COORDINATES | GeometryArray.TEXTURE_COORDINATE_2, 2, new int[] { 0, 1 });\n        plane.setCoordinates(0, coords);\n        plane.setTextureCoordinates(0, 0, texcoords);\n        plane.setTextureCoordinates(1, 0, texcoords2);\n        return plane;\n    }\n\n    /**\n     * Create a new textured plane shape node.\n     *\n     * @param path the texture to apply to the plane.\n     * @param s the size of the plane.\n     * @param r the number of repetitions.\n     */\n    public static Shape3D createTexturedPlane(String path, float s, float r) {\n        TextureLoader loader = TextureLoader.getInstance();\n        // fixa\n        loader.registerPath(\"./\");\n        // fixa\n        loader.registerPath(\"./dat/tex/\");\n        // fixa\n        loader.registerPath(\"./dat/mdl/\");\n        // fixa\n        loader.registerPath(\"./dat/gfx/\");\n        Appearance appearance = new Appearance();\n        appearance.setTexture((Texture2D) loader.getMinMapTexture(path));\n        // Set polygon offset so that we can see objects lying in the\n        // same plane as the grid.\n        PolygonAttributes polyAttr = new PolygonAttributes();\n        polyAttr.setPolygonOffset(10.0f);\n        polyAttr.setPolygonOffsetFactor(20.0f);\n        appearance.setPolygonAttributes(polyAttr);\n        return new Shape3D(createPlane(s, r), appearance);\n    }\n\n    public static Geometry createRectangle(float w, float h, Color3f color) {\n        Point3f[] coords = new Point3f[] { new Point3f(0f, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, h), new Point3f(w, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, 0f) };\n        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);\n        Color3f[] colors = new Color3f[] { new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z) };\n        lines.setCoordinates(0, coords);\n        lines.setColors(0, colors);\n        return lines;\n    }\n\n    /**\n     * Creates the default coordinate axes with specified length.\n     * @param size the length of the axes.\n     */\n    public static Geometry createCoordAxes(float size) {\n        Point3f[] coords = new Point3f[] { new Point3f(0, 0, 0), new Point3f(size, 0, 0), new Point3f(0, 0, 0), new Point3f(0, size, 0), new Point3f(0, 0, 0), new Point3f(0, 0, size) };\n        Color3f[] colors = new Color3f[] { new Color3f(0, 0, 1), new Color3f(0, 0, 1), new Color3f(1, 0, 0), new Color3f(1, 0, 0), new Color3f(0, 1, 0), new Color3f(0, 1, 0) };\n        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);\n        lines.setCoordinates(0, coords);\n        lines.setColors(0, colors);\n        return lines;\n    }\n\n    /**\n     * Creates a new grid with the specified number of rows and columns,\n     * and with the specified cell size.\n     *\n     * @param cols the number of cols in the grid.\n     * @param rows the number of rows in the grid.\n     * @param size the size of a single cell.\n     */\n    public static Shape3D createGrid(int cols, int rows, float size) {\n        rows++;\n        cols++;\n        Point3f[] coords = new Point3f[2 * (rows + cols)];\n        LineArray grid = new LineArray(coords.length, GeometryArray.COORDINATES);\n        for (int i = 1; i < 2 * rows; i += 2) {\n            coords[i - 1] = new Point3f(0, 0.01f, .5f * size * (i - 1));\n            coords[i] = new Point3f((cols - 1) * size, 0.01f, .5f * size * (i - 1));\n        }\n        for (int j = 1; j < 2 * cols; j += 2) {\n            coords[2 * rows + j - 1] = new Point3f(.5f * size * (j - 1), 0.01f, 0);\n            coords[2 * rows + j] = new Point3f(.5f * size * (j - 1), 0.01f, (rows - 1) * size);\n        }\n        grid.setCoordinates(0, coords);\n        return new Shape3D(grid);\n    }\n\n    /* The following methods are for converting screen coordinates to     \n     * world coordinates. They are taken from the xith3d forum and \n     * modified to fit the application.\n     *                                                                    \n     * Reference: kevglass                                                \n     *                                                                    \n     * http://www.javagaming.org/cgi-bin/JGNetForums/YaBB.cgi?            \n     *        board=xith3d;action=display;num=1068252077;start=15         \n     */\n    /**\n     * Returns the point in world space corresponding to the given\n     * coordinates in screen space.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @return the point in world space at the given depth.\n     */\n    public static Point3f toWorld(Canvas3D c, int x, int y) {\n        return toWorld(c, x, y, c.getView().getFrontClipDistance());\n    }\n\n    /**\n     * Returns the point in world space corresponding to the given\n     * coordinates in screen space.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @param z the z coordinate (depth).\n     * @return the point in world space at the given depth.\n     */\n    public static Point3f toWorld(Canvas3D c, int x, int y, float z) {\n        float fov = c.getView().getFieldOfView();\n        float width = c.getWidth();\n        float height = c.getHeight();\n        float panelY = (float) (tan(fov) * z);\n        float panelX = panelY * (width / height);\n        float xp = x / (width / 2);\n        float yp = y / (height / 2);\n        Point3f pt = new Point3f((xp - 1) * panelX, (1 - yp) * panelY, -z);\n        Transform3D v = new Transform3D();\n        c.getView().getTransform(v);\n        v.transform(pt);\n        return pt;\n    }\n\n    /**\n     * Returns the point in screen space corresponding to the given\n     * coordinates in world space.\n     *\n     * @param c the associated canvas.\n     * @param x the world x coordinate.\n     * @param y the world y coordinate.\n     * @param z the world z coordinate.\n     * @return the corresponding point in screen space.\n     */\n    public static Point3f toScreen(Canvas3D c, Point3f p) {\n        return toScreen(c, p.x, p.y, p.z);\n    }\n\n    public static Point3f toScreen(Canvas3D c, float x, float y, float z) {\n        float fov = c.getView().getFieldOfView();\n        float width = c.getWidth();\n        float height = c.getHeight();\n        Transform3D v = new Transform3D();\n        c.getView().getTransform(v);\n        Point3f p = new Point3f(x, y, z);\n        v.invert();\n        v.transform(p);\n        float panelY = (float) (tan(fov) * p.z);\n        float panelX = panelY * (width / height);\n        Point3f pt = new Point3f(p.x / panelX + 1, -p.y / panelY + 1, p.z);\n        pt.x = width - pt.x * (width / 2);\n        pt.y = height - pt.y * (height / 2);\n        return pt;\n    }\n\n    /**\n     * Returns the ray eminating from the point (x, y) in screen space\n     * directed along the screen z-axis.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @return the ray eminating from x, y in screen space.\n     */\n    public static PickRay castRay(Canvas3D c, int x, int y) {\n        Point3f center = toWorld(c, x, y);\n        Point3f d = toWorld(c, x, y, c.getView().getFrontClipDistance() + 0.1f);\n        Vector3f forward = new Vector3f(center);\n        forward.sub(d);\n        return new PickRay(center, forward);\n    }\n\n    /**\n     * @param path the path to the image to open.\n     */\n    public static BufferedImage getBufferedImage(String path) {\n        BufferedImage bufferedImage = null;\n        try {\n            bufferedImage = ImageIO.read(path.getClass().getResource(path));\n        } catch (Exception e) {\n            try {\n                bufferedImage = ImageIO.read(new File(path));\n            } catch (Exception x) {\n                System.err.println(\"craps!\");\n                x.printStackTrace(System.err);\n            }\n        }\n        return bufferedImage;\n    }\n\n    /**\n     * Sets the specified texture to the specified appearance. The texture\n     * mode is set to modulated.\n     *\n     * reference: Java Cool Dude\n     */\n    public static void setTexture2D(Shape3D shape, String path) {\n        setTexture2D(shape, path, false, true, true);\n    }\n\n    public static void setTexture2D(Shape3D shape, String path, boolean clip, boolean blend, boolean depth) {\n        Appearance appr = shape.getAppearance();\n        if (appr == null) {\n            appr = new Appearance();\n            shape.setAppearance(appr);\n        }\n        setTexture2D(path, appr, clip, blend, depth);\n    }\n\n    public static void setTexture2D(String path, Appearance appr) {\n        setTexture2D(path, appr, false, false, false);\n    }\n\n    public static void setTexture2D(String path, Appearance appr, boolean clip, boolean blend, boolean depth) {\n        BufferedImage bufferedImage = getBufferedImage(path);\n        TextureLoader tl = TextureLoader.getInstance();\n        if (!depth) {\n            RenderingAttributes rendattr = new RenderingAttributes();\n            rendattr.setDepthBufferEnable(false);\n            appr.setRenderingAttributes(rendattr);\n        }\n        if (blend) {\n            TransparencyAttributes aattr = new TransparencyAttributes();\n            aattr.setTransparencyMode(TransparencyAttributes.BLENDED);\n            aattr.setTransparency(0.0f);\n            aattr.setDstBlendFunction(TransparencyAttributes.BLEND_ONE);\n            aattr.setSrcBlendFunction(TransparencyAttributes.BLEND_SRC_ALPHA);\n            appr.setTransparencyAttributes(aattr);\n        }\n        if (clip) {\n            TextureAttributes texattr = new TextureAttributes();\n            texattr.setTextureMode(TextureAttributes.MODULATE);\n            texattr.setPerspectiveCorrectionMode(TextureAttributes.FASTEST);\n            appr.setTextureAttributes(texattr);\n        }\n        bufferedImage = DirectBufferedImage.make(bufferedImage, false);\n        Texture2D texture = (Texture2D) tl.constructTexture(bufferedImage, \"RGB\", false, Texture.BASE_LEVEL_LINEAR, Texture.BASE_LEVEL_LINEAR, Texture.WRAP, false, TextureLoader.SCALE_DRAW_BEST);\n        appr.setTexture(texture);\n    }\n\n    /**\n     * Enable picking of this node by traversing the scenegraph to the\n     * root and setting each node to be pickable.\n     *\n     * @param name the name used to identify this node.\n     */\n    public static void setPickable(Node node, String name) {\n        Node g = node.getParent();\n        while (g != null) {\n            g.setPickable(true);\n            g = g.getParent();\n        }\n        if (node instanceof Group) {\n            setPickableRecursive((Group) node, name);\n        }\n    }\n\n    /**\n     * Set all children of the specified group to be pickable.\n     *\n     * @param group the node at which to start.\n     * @param name the name used to identify the nodes.\n     */\n    public static void setPickableRecursive(Group group, String name) {\n        if (group == null) {\n            return;\n        }\n        group.setPickable(true);\n        java.util.Enumeration e = group.getAllChildren();\n        while (e.hasMoreElements()) {\n            Node node = (Node) e.nextElement();\n            // if it's a group rename all children\n            if (node instanceof Group) {\n                setPickableRecursive((Group) node, name);\n            } else {\n                node.setPickable(true);\n                if (node instanceof Shape3D) {\n                    node.setName(name);\n                }\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/Util3DTest7.java",
		"test_prompt": "// Util3DTest7.java\npackage gui.gl;\n\nimport static java.lang.Math.PI;\nimport static java.lang.Math.tan;\nimport static java.lang.Math.cos;\nimport static java.lang.Math.sin;\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.loaders.texture.*;\nimport com.xith3d.render.*;\nimport com.xith3d.render.jogl.*;\nimport javax.imageio.ImageIO;\nimport java.io.*;\nimport com.xith3d.image.DirectBufferedImage;\nimport java.awt.image.BufferedImage;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Util3D}.\n* It contains ten unit test cases for the {@link Util3D#createGrid(int, int, float)} method.\n*/\nclass Util3DTest7 {"
	},
	{
		"original_code": "// Util3D.java\n/* $Id: Util3D.java,v 1.6 2004/04/27 19:26:21 bja Exp $ */\npackage gui.gl;\n\nimport static java.lang.Math.PI;\nimport static java.lang.Math.tan;\nimport static java.lang.Math.cos;\nimport static java.lang.Math.sin;\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.loaders.texture.*;\nimport com.xith3d.render.*;\nimport com.xith3d.render.jogl.*;\nimport javax.imageio.ImageIO;\nimport java.io.*;\nimport com.xith3d.image.DirectBufferedImage;\nimport java.awt.image.BufferedImage;\n\npublic class Util3D {\n\n    public static final float rad(float ang) {\n        return (float) (ang / 180.0 * PI);\n    }\n\n    public static final float deg(float ang) {\n        return (float) (ang / PI * 180.0);\n    }\n\n    /**\n     * Creates a size-by-size wu sized plane with assigned texture\n     * coordinates. Texture coordinates are generated for two layers.\n     *\n     * @param size the size of the plane.\n     *\n     * @return the plane with the given normal and size.\n     */\n    public static Geometry createPlane(float size, float r) {\n        return createQuad(0, 0, size, r, r);\n    }\n\n    public static Geometry createQuad(float x, float y, float size, float s, float t) {\n        Point3f[] coords = new Point3f[] { new Point3f(x, 0f, y), new Point3f(x + size, 0f, y), new Point3f(x + size, 0f, y + size), new Point3f(x, 0f, y + size) };\n        TexCoord2f[] texcoords = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(s, 0f), new TexCoord2f(s, s), new TexCoord2f(0f, s) };\n        TexCoord2f[] texcoords2 = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(t, 0f), new TexCoord2f(t, t), new TexCoord2f(0f, t) };\n        QuadArray plane = new QuadArray(coords.length, GeometryArray.COORDINATES | GeometryArray.TEXTURE_COORDINATE_2, 2, new int[] { 0, 1 });\n        plane.setCoordinates(0, coords);\n        plane.setTextureCoordinates(0, 0, texcoords);\n        plane.setTextureCoordinates(1, 0, texcoords2);\n        return plane;\n    }\n\n    /**\n     * Create a new textured plane shape node.\n     *\n     * @param path the texture to apply to the plane.\n     * @param s the size of the plane.\n     * @param r the number of repetitions.\n     */\n    public static Shape3D createTexturedPlane(String path, float s, float r) {\n        TextureLoader loader = TextureLoader.getInstance();\n        // fixa\n        loader.registerPath(\"./\");\n        // fixa\n        loader.registerPath(\"./dat/tex/\");\n        // fixa\n        loader.registerPath(\"./dat/mdl/\");\n        // fixa\n        loader.registerPath(\"./dat/gfx/\");\n        Appearance appearance = new Appearance();\n        appearance.setTexture((Texture2D) loader.getMinMapTexture(path));\n        // Set polygon offset so that we can see objects lying in the\n        // same plane as the grid.\n        PolygonAttributes polyAttr = new PolygonAttributes();\n        polyAttr.setPolygonOffset(10.0f);\n        polyAttr.setPolygonOffsetFactor(20.0f);\n        appearance.setPolygonAttributes(polyAttr);\n        return new Shape3D(createPlane(s, r), appearance);\n    }\n\n    public static Geometry createRectangle(float w, float h, Color3f color) {\n        Point3f[] coords = new Point3f[] { new Point3f(0f, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, h), new Point3f(w, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, 0f) };\n        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);\n        Color3f[] colors = new Color3f[] { new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z) };\n        lines.setCoordinates(0, coords);\n        lines.setColors(0, colors);\n        return lines;\n    }\n\n    /**\n     * Creates the default coordinate axes with specified length.\n     * @param size the length of the axes.\n     */\n    public static Geometry createCoordAxes(float size) {\n        Point3f[] coords = new Point3f[] { new Point3f(0, 0, 0), new Point3f(size, 0, 0), new Point3f(0, 0, 0), new Point3f(0, size, 0), new Point3f(0, 0, 0), new Point3f(0, 0, size) };\n        Color3f[] colors = new Color3f[] { new Color3f(0, 0, 1), new Color3f(0, 0, 1), new Color3f(1, 0, 0), new Color3f(1, 0, 0), new Color3f(0, 1, 0), new Color3f(0, 1, 0) };\n        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);\n        lines.setCoordinates(0, coords);\n        lines.setColors(0, colors);\n        return lines;\n    }\n\n    /**\n     * Creates a new grid with the specified number of rows and columns,\n     * and with the specified cell size.\n     *\n     * @param cols the number of cols in the grid.\n     * @param rows the number of rows in the grid.\n     * @param size the size of a single cell.\n     */\n    public static Shape3D createGrid(int cols, int rows, float size) {\n        rows++;\n        cols++;\n        Point3f[] coords = new Point3f[2 * (rows + cols)];\n        LineArray grid = new LineArray(coords.length, GeometryArray.COORDINATES);\n        for (int i = 1; i < 2 * rows; i += 2) {\n            coords[i - 1] = new Point3f(0, 0.01f, .5f * size * (i - 1));\n            coords[i] = new Point3f((cols - 1) * size, 0.01f, .5f * size * (i - 1));\n        }\n        for (int j = 1; j < 2 * cols; j += 2) {\n            coords[2 * rows + j - 1] = new Point3f(.5f * size * (j - 1), 0.01f, 0);\n            coords[2 * rows + j] = new Point3f(.5f * size * (j - 1), 0.01f, (rows - 1) * size);\n        }\n        grid.setCoordinates(0, coords);\n        return new Shape3D(grid);\n    }\n\n    /* The following methods are for converting screen coordinates to     \n     * world coordinates. They are taken from the xith3d forum and \n     * modified to fit the application.\n     *                                                                    \n     * Reference: kevglass                                                \n     *                                                                    \n     * http://www.javagaming.org/cgi-bin/JGNetForums/YaBB.cgi?            \n     *        board=xith3d;action=display;num=1068252077;start=15         \n     */\n    /**\n     * Returns the point in world space corresponding to the given\n     * coordinates in screen space.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @return the point in world space at the given depth.\n     */\n    public static Point3f toWorld(Canvas3D c, int x, int y) {\n        return toWorld(c, x, y, c.getView().getFrontClipDistance());\n    }\n\n    /**\n     * Returns the point in world space corresponding to the given\n     * coordinates in screen space.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @param z the z coordinate (depth).\n     * @return the point in world space at the given depth.\n     */\n    public static Point3f toWorld(Canvas3D c, int x, int y, float z) {\n        float fov = c.getView().getFieldOfView();\n        float width = c.getWidth();\n        float height = c.getHeight();\n        float panelY = (float) (tan(fov) * z);\n        float panelX = panelY * (width / height);\n        float xp = x / (width / 2);\n        float yp = y / (height / 2);\n        Point3f pt = new Point3f((xp - 1) * panelX, (1 - yp) * panelY, -z);\n        Transform3D v = new Transform3D();\n        c.getView().getTransform(v);\n        v.transform(pt);\n        return pt;\n    }\n\n    /**\n     * Returns the point in screen space corresponding to the given\n     * coordinates in world space.\n     *\n     * @param c the associated canvas.\n     * @param x the world x coordinate.\n     * @param y the world y coordinate.\n     * @param z the world z coordinate.\n     * @return the corresponding point in screen space.\n     */\n    public static Point3f toScreen(Canvas3D c, Point3f p) {\n        return toScreen(c, p.x, p.y, p.z);\n    }\n\n    public static Point3f toScreen(Canvas3D c, float x, float y, float z) {\n        float fov = c.getView().getFieldOfView();\n        float width = c.getWidth();\n        float height = c.getHeight();\n        Transform3D v = new Transform3D();\n        c.getView().getTransform(v);\n        Point3f p = new Point3f(x, y, z);\n        v.invert();\n        v.transform(p);\n        float panelY = (float) (tan(fov) * p.z);\n        float panelX = panelY * (width / height);\n        Point3f pt = new Point3f(p.x / panelX + 1, -p.y / panelY + 1, p.z);\n        pt.x = width - pt.x * (width / 2);\n        pt.y = height - pt.y * (height / 2);\n        return pt;\n    }\n\n    /**\n     * Returns the ray eminating from the point (x, y) in screen space\n     * directed along the screen z-axis.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @return the ray eminating from x, y in screen space.\n     */\n    public static PickRay castRay(Canvas3D c, int x, int y) {\n        Point3f center = toWorld(c, x, y);\n        Point3f d = toWorld(c, x, y, c.getView().getFrontClipDistance() + 0.1f);\n        Vector3f forward = new Vector3f(center);\n        forward.sub(d);\n        return new PickRay(center, forward);\n    }\n\n    /**\n     * @param path the path to the image to open.\n     */\n    public static BufferedImage getBufferedImage(String path) {\n        BufferedImage bufferedImage = null;\n        try {\n            bufferedImage = ImageIO.read(path.getClass().getResource(path));\n        } catch (Exception e) {\n            try {\n                bufferedImage = ImageIO.read(new File(path));\n            } catch (Exception x) {\n                System.err.println(\"craps!\");\n                x.printStackTrace(System.err);\n            }\n        }\n        return bufferedImage;\n    }\n\n    /**\n     * Sets the specified texture to the specified appearance. The texture\n     * mode is set to modulated.\n     *\n     * reference: Java Cool Dude\n     */\n    public static void setTexture2D(Shape3D shape, String path) {\n        setTexture2D(shape, path, false, true, true);\n    }\n\n    public static void setTexture2D(Shape3D shape, String path, boolean clip, boolean blend, boolean depth) {\n        Appearance appr = shape.getAppearance();\n        if (appr == null) {\n            appr = new Appearance();\n            shape.setAppearance(appr);\n        }\n        setTexture2D(path, appr, clip, blend, depth);\n    }\n\n    public static void setTexture2D(String path, Appearance appr) {\n        setTexture2D(path, appr, false, false, false);\n    }\n\n    public static void setTexture2D(String path, Appearance appr, boolean clip, boolean blend, boolean depth) {\n        BufferedImage bufferedImage = getBufferedImage(path);\n        TextureLoader tl = TextureLoader.getInstance();\n        if (!depth) {\n            RenderingAttributes rendattr = new RenderingAttributes();\n            rendattr.setDepthBufferEnable(false);\n            appr.setRenderingAttributes(rendattr);\n        }\n        if (blend) {\n            TransparencyAttributes aattr = new TransparencyAttributes();\n            aattr.setTransparencyMode(TransparencyAttributes.BLENDED);\n            aattr.setTransparency(0.0f);\n            aattr.setDstBlendFunction(TransparencyAttributes.BLEND_ONE);\n            aattr.setSrcBlendFunction(TransparencyAttributes.BLEND_SRC_ALPHA);\n            appr.setTransparencyAttributes(aattr);\n        }\n        if (clip) {\n            TextureAttributes texattr = new TextureAttributes();\n            texattr.setTextureMode(TextureAttributes.MODULATE);\n            texattr.setPerspectiveCorrectionMode(TextureAttributes.FASTEST);\n            appr.setTextureAttributes(texattr);\n        }\n        bufferedImage = DirectBufferedImage.make(bufferedImage, false);\n        Texture2D texture = (Texture2D) tl.constructTexture(bufferedImage, \"RGB\", false, Texture.BASE_LEVEL_LINEAR, Texture.BASE_LEVEL_LINEAR, Texture.WRAP, false, TextureLoader.SCALE_DRAW_BEST);\n        appr.setTexture(texture);\n    }\n\n    /**\n     * Enable picking of this node by traversing the scenegraph to the\n     * root and setting each node to be pickable.\n     *\n     * @param name the name used to identify this node.\n     */\n    public static void setPickable(Node node, String name) {\n        Node g = node.getParent();\n        while (g != null) {\n            g.setPickable(true);\n            g = g.getParent();\n        }\n        if (node instanceof Group) {\n            setPickableRecursive((Group) node, name);\n        }\n    }\n\n    /**\n     * Set all children of the specified group to be pickable.\n     *\n     * @param group the node at which to start.\n     * @param name the name used to identify the nodes.\n     */\n    public static void setPickableRecursive(Group group, String name) {\n        if (group == null) {\n            return;\n        }\n        group.setPickable(true);\n        java.util.Enumeration e = group.getAllChildren();\n        while (e.hasMoreElements()) {\n            Node node = (Node) e.nextElement();\n            // if it's a group rename all children\n            if (node instanceof Group) {\n                setPickableRecursive((Group) node, name);\n            } else {\n                node.setPickable(true);\n                if (node instanceof Shape3D) {\n                    node.setName(name);\n                }\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/Util3DTest8.java",
		"test_prompt": "// Util3DTest8.java\npackage gui.gl;\n\nimport static java.lang.Math.PI;\nimport static java.lang.Math.tan;\nimport static java.lang.Math.cos;\nimport static java.lang.Math.sin;\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.loaders.texture.*;\nimport com.xith3d.render.*;\nimport com.xith3d.render.jogl.*;\nimport javax.imageio.ImageIO;\nimport java.io.*;\nimport com.xith3d.image.DirectBufferedImage;\nimport java.awt.image.BufferedImage;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Util3D}.\n* It contains ten unit test cases for the {@link Util3D#toWorld(Canvas3D, int, int)} method.\n*/\nclass Util3DTest8 {"
	},
	{
		"original_code": "// Util3D.java\n/* $Id: Util3D.java,v 1.6 2004/04/27 19:26:21 bja Exp $ */\npackage gui.gl;\n\nimport static java.lang.Math.PI;\nimport static java.lang.Math.tan;\nimport static java.lang.Math.cos;\nimport static java.lang.Math.sin;\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.loaders.texture.*;\nimport com.xith3d.render.*;\nimport com.xith3d.render.jogl.*;\nimport javax.imageio.ImageIO;\nimport java.io.*;\nimport com.xith3d.image.DirectBufferedImage;\nimport java.awt.image.BufferedImage;\n\npublic class Util3D {\n\n    public static final float rad(float ang) {\n        return (float) (ang / 180.0 * PI);\n    }\n\n    public static final float deg(float ang) {\n        return (float) (ang / PI * 180.0);\n    }\n\n    /**\n     * Creates a size-by-size wu sized plane with assigned texture\n     * coordinates. Texture coordinates are generated for two layers.\n     *\n     * @param size the size of the plane.\n     *\n     * @return the plane with the given normal and size.\n     */\n    public static Geometry createPlane(float size, float r) {\n        return createQuad(0, 0, size, r, r);\n    }\n\n    public static Geometry createQuad(float x, float y, float size, float s, float t) {\n        Point3f[] coords = new Point3f[] { new Point3f(x, 0f, y), new Point3f(x + size, 0f, y), new Point3f(x + size, 0f, y + size), new Point3f(x, 0f, y + size) };\n        TexCoord2f[] texcoords = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(s, 0f), new TexCoord2f(s, s), new TexCoord2f(0f, s) };\n        TexCoord2f[] texcoords2 = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(t, 0f), new TexCoord2f(t, t), new TexCoord2f(0f, t) };\n        QuadArray plane = new QuadArray(coords.length, GeometryArray.COORDINATES | GeometryArray.TEXTURE_COORDINATE_2, 2, new int[] { 0, 1 });\n        plane.setCoordinates(0, coords);\n        plane.setTextureCoordinates(0, 0, texcoords);\n        plane.setTextureCoordinates(1, 0, texcoords2);\n        return plane;\n    }\n\n    /**\n     * Create a new textured plane shape node.\n     *\n     * @param path the texture to apply to the plane.\n     * @param s the size of the plane.\n     * @param r the number of repetitions.\n     */\n    public static Shape3D createTexturedPlane(String path, float s, float r) {\n        TextureLoader loader = TextureLoader.getInstance();\n        // fixa\n        loader.registerPath(\"./\");\n        // fixa\n        loader.registerPath(\"./dat/tex/\");\n        // fixa\n        loader.registerPath(\"./dat/mdl/\");\n        // fixa\n        loader.registerPath(\"./dat/gfx/\");\n        Appearance appearance = new Appearance();\n        appearance.setTexture((Texture2D) loader.getMinMapTexture(path));\n        // Set polygon offset so that we can see objects lying in the\n        // same plane as the grid.\n        PolygonAttributes polyAttr = new PolygonAttributes();\n        polyAttr.setPolygonOffset(10.0f);\n        polyAttr.setPolygonOffsetFactor(20.0f);\n        appearance.setPolygonAttributes(polyAttr);\n        return new Shape3D(createPlane(s, r), appearance);\n    }\n\n    public static Geometry createRectangle(float w, float h, Color3f color) {\n        Point3f[] coords = new Point3f[] { new Point3f(0f, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, h), new Point3f(w, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, 0f) };\n        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);\n        Color3f[] colors = new Color3f[] { new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z) };\n        lines.setCoordinates(0, coords);\n        lines.setColors(0, colors);\n        return lines;\n    }\n\n    /**\n     * Creates the default coordinate axes with specified length.\n     * @param size the length of the axes.\n     */\n    public static Geometry createCoordAxes(float size) {\n        Point3f[] coords = new Point3f[] { new Point3f(0, 0, 0), new Point3f(size, 0, 0), new Point3f(0, 0, 0), new Point3f(0, size, 0), new Point3f(0, 0, 0), new Point3f(0, 0, size) };\n        Color3f[] colors = new Color3f[] { new Color3f(0, 0, 1), new Color3f(0, 0, 1), new Color3f(1, 0, 0), new Color3f(1, 0, 0), new Color3f(0, 1, 0), new Color3f(0, 1, 0) };\n        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);\n        lines.setCoordinates(0, coords);\n        lines.setColors(0, colors);\n        return lines;\n    }\n\n    /**\n     * Creates a new grid with the specified number of rows and columns,\n     * and with the specified cell size.\n     *\n     * @param cols the number of cols in the grid.\n     * @param rows the number of rows in the grid.\n     * @param size the size of a single cell.\n     */\n    public static Shape3D createGrid(int cols, int rows, float size) {\n        rows++;\n        cols++;\n        Point3f[] coords = new Point3f[2 * (rows + cols)];\n        LineArray grid = new LineArray(coords.length, GeometryArray.COORDINATES);\n        for (int i = 1; i < 2 * rows; i += 2) {\n            coords[i - 1] = new Point3f(0, 0.01f, .5f * size * (i - 1));\n            coords[i] = new Point3f((cols - 1) * size, 0.01f, .5f * size * (i - 1));\n        }\n        for (int j = 1; j < 2 * cols; j += 2) {\n            coords[2 * rows + j - 1] = new Point3f(.5f * size * (j - 1), 0.01f, 0);\n            coords[2 * rows + j] = new Point3f(.5f * size * (j - 1), 0.01f, (rows - 1) * size);\n        }\n        grid.setCoordinates(0, coords);\n        return new Shape3D(grid);\n    }\n\n    /* The following methods are for converting screen coordinates to     \n     * world coordinates. They are taken from the xith3d forum and \n     * modified to fit the application.\n     *                                                                    \n     * Reference: kevglass                                                \n     *                                                                    \n     * http://www.javagaming.org/cgi-bin/JGNetForums/YaBB.cgi?            \n     *        board=xith3d;action=display;num=1068252077;start=15         \n     */\n    /**\n     * Returns the point in world space corresponding to the given\n     * coordinates in screen space.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @return the point in world space at the given depth.\n     */\n    public static Point3f toWorld(Canvas3D c, int x, int y) {\n        return toWorld(c, x, y, c.getView().getFrontClipDistance());\n    }\n\n    /**\n     * Returns the point in world space corresponding to the given\n     * coordinates in screen space.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @param z the z coordinate (depth).\n     * @return the point in world space at the given depth.\n     */\n    public static Point3f toWorld(Canvas3D c, int x, int y, float z) {\n        float fov = c.getView().getFieldOfView();\n        float width = c.getWidth();\n        float height = c.getHeight();\n        float panelY = (float) (tan(fov) * z);\n        float panelX = panelY * (width / height);\n        float xp = x / (width / 2);\n        float yp = y / (height / 2);\n        Point3f pt = new Point3f((xp - 1) * panelX, (1 - yp) * panelY, -z);\n        Transform3D v = new Transform3D();\n        c.getView().getTransform(v);\n        v.transform(pt);\n        return pt;\n    }\n\n    /**\n     * Returns the point in screen space corresponding to the given\n     * coordinates in world space.\n     *\n     * @param c the associated canvas.\n     * @param x the world x coordinate.\n     * @param y the world y coordinate.\n     * @param z the world z coordinate.\n     * @return the corresponding point in screen space.\n     */\n    public static Point3f toScreen(Canvas3D c, Point3f p) {\n        return toScreen(c, p.x, p.y, p.z);\n    }\n\n    public static Point3f toScreen(Canvas3D c, float x, float y, float z) {\n        float fov = c.getView().getFieldOfView();\n        float width = c.getWidth();\n        float height = c.getHeight();\n        Transform3D v = new Transform3D();\n        c.getView().getTransform(v);\n        Point3f p = new Point3f(x, y, z);\n        v.invert();\n        v.transform(p);\n        float panelY = (float) (tan(fov) * p.z);\n        float panelX = panelY * (width / height);\n        Point3f pt = new Point3f(p.x / panelX + 1, -p.y / panelY + 1, p.z);\n        pt.x = width - pt.x * (width / 2);\n        pt.y = height - pt.y * (height / 2);\n        return pt;\n    }\n\n    /**\n     * Returns the ray eminating from the point (x, y) in screen space\n     * directed along the screen z-axis.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @return the ray eminating from x, y in screen space.\n     */\n    public static PickRay castRay(Canvas3D c, int x, int y) {\n        Point3f center = toWorld(c, x, y);\n        Point3f d = toWorld(c, x, y, c.getView().getFrontClipDistance() + 0.1f);\n        Vector3f forward = new Vector3f(center);\n        forward.sub(d);\n        return new PickRay(center, forward);\n    }\n\n    /**\n     * @param path the path to the image to open.\n     */\n    public static BufferedImage getBufferedImage(String path) {\n        BufferedImage bufferedImage = null;\n        try {\n            bufferedImage = ImageIO.read(path.getClass().getResource(path));\n        } catch (Exception e) {\n            try {\n                bufferedImage = ImageIO.read(new File(path));\n            } catch (Exception x) {\n                System.err.println(\"craps!\");\n                x.printStackTrace(System.err);\n            }\n        }\n        return bufferedImage;\n    }\n\n    /**\n     * Sets the specified texture to the specified appearance. The texture\n     * mode is set to modulated.\n     *\n     * reference: Java Cool Dude\n     */\n    public static void setTexture2D(Shape3D shape, String path) {\n        setTexture2D(shape, path, false, true, true);\n    }\n\n    public static void setTexture2D(Shape3D shape, String path, boolean clip, boolean blend, boolean depth) {\n        Appearance appr = shape.getAppearance();\n        if (appr == null) {\n            appr = new Appearance();\n            shape.setAppearance(appr);\n        }\n        setTexture2D(path, appr, clip, blend, depth);\n    }\n\n    public static void setTexture2D(String path, Appearance appr) {\n        setTexture2D(path, appr, false, false, false);\n    }\n\n    public static void setTexture2D(String path, Appearance appr, boolean clip, boolean blend, boolean depth) {\n        BufferedImage bufferedImage = getBufferedImage(path);\n        TextureLoader tl = TextureLoader.getInstance();\n        if (!depth) {\n            RenderingAttributes rendattr = new RenderingAttributes();\n            rendattr.setDepthBufferEnable(false);\n            appr.setRenderingAttributes(rendattr);\n        }\n        if (blend) {\n            TransparencyAttributes aattr = new TransparencyAttributes();\n            aattr.setTransparencyMode(TransparencyAttributes.BLENDED);\n            aattr.setTransparency(0.0f);\n            aattr.setDstBlendFunction(TransparencyAttributes.BLEND_ONE);\n            aattr.setSrcBlendFunction(TransparencyAttributes.BLEND_SRC_ALPHA);\n            appr.setTransparencyAttributes(aattr);\n        }\n        if (clip) {\n            TextureAttributes texattr = new TextureAttributes();\n            texattr.setTextureMode(TextureAttributes.MODULATE);\n            texattr.setPerspectiveCorrectionMode(TextureAttributes.FASTEST);\n            appr.setTextureAttributes(texattr);\n        }\n        bufferedImage = DirectBufferedImage.make(bufferedImage, false);\n        Texture2D texture = (Texture2D) tl.constructTexture(bufferedImage, \"RGB\", false, Texture.BASE_LEVEL_LINEAR, Texture.BASE_LEVEL_LINEAR, Texture.WRAP, false, TextureLoader.SCALE_DRAW_BEST);\n        appr.setTexture(texture);\n    }\n\n    /**\n     * Enable picking of this node by traversing the scenegraph to the\n     * root and setting each node to be pickable.\n     *\n     * @param name the name used to identify this node.\n     */\n    public static void setPickable(Node node, String name) {\n        Node g = node.getParent();\n        while (g != null) {\n            g.setPickable(true);\n            g = g.getParent();\n        }\n        if (node instanceof Group) {\n            setPickableRecursive((Group) node, name);\n        }\n    }\n\n    /**\n     * Set all children of the specified group to be pickable.\n     *\n     * @param group the node at which to start.\n     * @param name the name used to identify the nodes.\n     */\n    public static void setPickableRecursive(Group group, String name) {\n        if (group == null) {\n            return;\n        }\n        group.setPickable(true);\n        java.util.Enumeration e = group.getAllChildren();\n        while (e.hasMoreElements()) {\n            Node node = (Node) e.nextElement();\n            // if it's a group rename all children\n            if (node instanceof Group) {\n                setPickableRecursive((Group) node, name);\n            } else {\n                node.setPickable(true);\n                if (node instanceof Shape3D) {\n                    node.setName(name);\n                }\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/Util3DTest9.java",
		"test_prompt": "// Util3DTest9.java\npackage gui.gl;\n\nimport static java.lang.Math.PI;\nimport static java.lang.Math.tan;\nimport static java.lang.Math.cos;\nimport static java.lang.Math.sin;\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.loaders.texture.*;\nimport com.xith3d.render.*;\nimport com.xith3d.render.jogl.*;\nimport javax.imageio.ImageIO;\nimport java.io.*;\nimport com.xith3d.image.DirectBufferedImage;\nimport java.awt.image.BufferedImage;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Util3D}.\n* It contains ten unit test cases for the {@link Util3D#toWorld(Canvas3D, int, int, float)} method.\n*/\nclass Util3DTest9 {"
	},
	{
		"original_code": "// Util3D.java\n/* $Id: Util3D.java,v 1.6 2004/04/27 19:26:21 bja Exp $ */\npackage gui.gl;\n\nimport static java.lang.Math.PI;\nimport static java.lang.Math.tan;\nimport static java.lang.Math.cos;\nimport static java.lang.Math.sin;\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.loaders.texture.*;\nimport com.xith3d.render.*;\nimport com.xith3d.render.jogl.*;\nimport javax.imageio.ImageIO;\nimport java.io.*;\nimport com.xith3d.image.DirectBufferedImage;\nimport java.awt.image.BufferedImage;\n\npublic class Util3D {\n\n    public static final float rad(float ang) {\n        return (float) (ang / 180.0 * PI);\n    }\n\n    public static final float deg(float ang) {\n        return (float) (ang / PI * 180.0);\n    }\n\n    /**\n     * Creates a size-by-size wu sized plane with assigned texture\n     * coordinates. Texture coordinates are generated for two layers.\n     *\n     * @param size the size of the plane.\n     *\n     * @return the plane with the given normal and size.\n     */\n    public static Geometry createPlane(float size, float r) {\n        return createQuad(0, 0, size, r, r);\n    }\n\n    public static Geometry createQuad(float x, float y, float size, float s, float t) {\n        Point3f[] coords = new Point3f[] { new Point3f(x, 0f, y), new Point3f(x + size, 0f, y), new Point3f(x + size, 0f, y + size), new Point3f(x, 0f, y + size) };\n        TexCoord2f[] texcoords = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(s, 0f), new TexCoord2f(s, s), new TexCoord2f(0f, s) };\n        TexCoord2f[] texcoords2 = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(t, 0f), new TexCoord2f(t, t), new TexCoord2f(0f, t) };\n        QuadArray plane = new QuadArray(coords.length, GeometryArray.COORDINATES | GeometryArray.TEXTURE_COORDINATE_2, 2, new int[] { 0, 1 });\n        plane.setCoordinates(0, coords);\n        plane.setTextureCoordinates(0, 0, texcoords);\n        plane.setTextureCoordinates(1, 0, texcoords2);\n        return plane;\n    }\n\n    /**\n     * Create a new textured plane shape node.\n     *\n     * @param path the texture to apply to the plane.\n     * @param s the size of the plane.\n     * @param r the number of repetitions.\n     */\n    public static Shape3D createTexturedPlane(String path, float s, float r) {\n        TextureLoader loader = TextureLoader.getInstance();\n        // fixa\n        loader.registerPath(\"./\");\n        // fixa\n        loader.registerPath(\"./dat/tex/\");\n        // fixa\n        loader.registerPath(\"./dat/mdl/\");\n        // fixa\n        loader.registerPath(\"./dat/gfx/\");\n        Appearance appearance = new Appearance();\n        appearance.setTexture((Texture2D) loader.getMinMapTexture(path));\n        // Set polygon offset so that we can see objects lying in the\n        // same plane as the grid.\n        PolygonAttributes polyAttr = new PolygonAttributes();\n        polyAttr.setPolygonOffset(10.0f);\n        polyAttr.setPolygonOffsetFactor(20.0f);\n        appearance.setPolygonAttributes(polyAttr);\n        return new Shape3D(createPlane(s, r), appearance);\n    }\n\n    public static Geometry createRectangle(float w, float h, Color3f color) {\n        Point3f[] coords = new Point3f[] { new Point3f(0f, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, h), new Point3f(w, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, 0f) };\n        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);\n        Color3f[] colors = new Color3f[] { new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z) };\n        lines.setCoordinates(0, coords);\n        lines.setColors(0, colors);\n        return lines;\n    }\n\n    /**\n     * Creates the default coordinate axes with specified length.\n     * @param size the length of the axes.\n     */\n    public static Geometry createCoordAxes(float size) {\n        Point3f[] coords = new Point3f[] { new Point3f(0, 0, 0), new Point3f(size, 0, 0), new Point3f(0, 0, 0), new Point3f(0, size, 0), new Point3f(0, 0, 0), new Point3f(0, 0, size) };\n        Color3f[] colors = new Color3f[] { new Color3f(0, 0, 1), new Color3f(0, 0, 1), new Color3f(1, 0, 0), new Color3f(1, 0, 0), new Color3f(0, 1, 0), new Color3f(0, 1, 0) };\n        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);\n        lines.setCoordinates(0, coords);\n        lines.setColors(0, colors);\n        return lines;\n    }\n\n    /**\n     * Creates a new grid with the specified number of rows and columns,\n     * and with the specified cell size.\n     *\n     * @param cols the number of cols in the grid.\n     * @param rows the number of rows in the grid.\n     * @param size the size of a single cell.\n     */\n    public static Shape3D createGrid(int cols, int rows, float size) {\n        rows++;\n        cols++;\n        Point3f[] coords = new Point3f[2 * (rows + cols)];\n        LineArray grid = new LineArray(coords.length, GeometryArray.COORDINATES);\n        for (int i = 1; i < 2 * rows; i += 2) {\n            coords[i - 1] = new Point3f(0, 0.01f, .5f * size * (i - 1));\n            coords[i] = new Point3f((cols - 1) * size, 0.01f, .5f * size * (i - 1));\n        }\n        for (int j = 1; j < 2 * cols; j += 2) {\n            coords[2 * rows + j - 1] = new Point3f(.5f * size * (j - 1), 0.01f, 0);\n            coords[2 * rows + j] = new Point3f(.5f * size * (j - 1), 0.01f, (rows - 1) * size);\n        }\n        grid.setCoordinates(0, coords);\n        return new Shape3D(grid);\n    }\n\n    /* The following methods are for converting screen coordinates to     \n     * world coordinates. They are taken from the xith3d forum and \n     * modified to fit the application.\n     *                                                                    \n     * Reference: kevglass                                                \n     *                                                                    \n     * http://www.javagaming.org/cgi-bin/JGNetForums/YaBB.cgi?            \n     *        board=xith3d;action=display;num=1068252077;start=15         \n     */\n    /**\n     * Returns the point in world space corresponding to the given\n     * coordinates in screen space.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @return the point in world space at the given depth.\n     */\n    public static Point3f toWorld(Canvas3D c, int x, int y) {\n        return toWorld(c, x, y, c.getView().getFrontClipDistance());\n    }\n\n    /**\n     * Returns the point in world space corresponding to the given\n     * coordinates in screen space.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @param z the z coordinate (depth).\n     * @return the point in world space at the given depth.\n     */\n    public static Point3f toWorld(Canvas3D c, int x, int y, float z) {\n        float fov = c.getView().getFieldOfView();\n        float width = c.getWidth();\n        float height = c.getHeight();\n        float panelY = (float) (tan(fov) * z);\n        float panelX = panelY * (width / height);\n        float xp = x / (width / 2);\n        float yp = y / (height / 2);\n        Point3f pt = new Point3f((xp - 1) * panelX, (1 - yp) * panelY, -z);\n        Transform3D v = new Transform3D();\n        c.getView().getTransform(v);\n        v.transform(pt);\n        return pt;\n    }\n\n    /**\n     * Returns the point in screen space corresponding to the given\n     * coordinates in world space.\n     *\n     * @param c the associated canvas.\n     * @param x the world x coordinate.\n     * @param y the world y coordinate.\n     * @param z the world z coordinate.\n     * @return the corresponding point in screen space.\n     */\n    public static Point3f toScreen(Canvas3D c, Point3f p) {\n        return toScreen(c, p.x, p.y, p.z);\n    }\n\n    public static Point3f toScreen(Canvas3D c, float x, float y, float z) {\n        float fov = c.getView().getFieldOfView();\n        float width = c.getWidth();\n        float height = c.getHeight();\n        Transform3D v = new Transform3D();\n        c.getView().getTransform(v);\n        Point3f p = new Point3f(x, y, z);\n        v.invert();\n        v.transform(p);\n        float panelY = (float) (tan(fov) * p.z);\n        float panelX = panelY * (width / height);\n        Point3f pt = new Point3f(p.x / panelX + 1, -p.y / panelY + 1, p.z);\n        pt.x = width - pt.x * (width / 2);\n        pt.y = height - pt.y * (height / 2);\n        return pt;\n    }\n\n    /**\n     * Returns the ray eminating from the point (x, y) in screen space\n     * directed along the screen z-axis.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @return the ray eminating from x, y in screen space.\n     */\n    public static PickRay castRay(Canvas3D c, int x, int y) {\n        Point3f center = toWorld(c, x, y);\n        Point3f d = toWorld(c, x, y, c.getView().getFrontClipDistance() + 0.1f);\n        Vector3f forward = new Vector3f(center);\n        forward.sub(d);\n        return new PickRay(center, forward);\n    }\n\n    /**\n     * @param path the path to the image to open.\n     */\n    public static BufferedImage getBufferedImage(String path) {\n        BufferedImage bufferedImage = null;\n        try {\n            bufferedImage = ImageIO.read(path.getClass().getResource(path));\n        } catch (Exception e) {\n            try {\n                bufferedImage = ImageIO.read(new File(path));\n            } catch (Exception x) {\n                System.err.println(\"craps!\");\n                x.printStackTrace(System.err);\n            }\n        }\n        return bufferedImage;\n    }\n\n    /**\n     * Sets the specified texture to the specified appearance. The texture\n     * mode is set to modulated.\n     *\n     * reference: Java Cool Dude\n     */\n    public static void setTexture2D(Shape3D shape, String path) {\n        setTexture2D(shape, path, false, true, true);\n    }\n\n    public static void setTexture2D(Shape3D shape, String path, boolean clip, boolean blend, boolean depth) {\n        Appearance appr = shape.getAppearance();\n        if (appr == null) {\n            appr = new Appearance();\n            shape.setAppearance(appr);\n        }\n        setTexture2D(path, appr, clip, blend, depth);\n    }\n\n    public static void setTexture2D(String path, Appearance appr) {\n        setTexture2D(path, appr, false, false, false);\n    }\n\n    public static void setTexture2D(String path, Appearance appr, boolean clip, boolean blend, boolean depth) {\n        BufferedImage bufferedImage = getBufferedImage(path);\n        TextureLoader tl = TextureLoader.getInstance();\n        if (!depth) {\n            RenderingAttributes rendattr = new RenderingAttributes();\n            rendattr.setDepthBufferEnable(false);\n            appr.setRenderingAttributes(rendattr);\n        }\n        if (blend) {\n            TransparencyAttributes aattr = new TransparencyAttributes();\n            aattr.setTransparencyMode(TransparencyAttributes.BLENDED);\n            aattr.setTransparency(0.0f);\n            aattr.setDstBlendFunction(TransparencyAttributes.BLEND_ONE);\n            aattr.setSrcBlendFunction(TransparencyAttributes.BLEND_SRC_ALPHA);\n            appr.setTransparencyAttributes(aattr);\n        }\n        if (clip) {\n            TextureAttributes texattr = new TextureAttributes();\n            texattr.setTextureMode(TextureAttributes.MODULATE);\n            texattr.setPerspectiveCorrectionMode(TextureAttributes.FASTEST);\n            appr.setTextureAttributes(texattr);\n        }\n        bufferedImage = DirectBufferedImage.make(bufferedImage, false);\n        Texture2D texture = (Texture2D) tl.constructTexture(bufferedImage, \"RGB\", false, Texture.BASE_LEVEL_LINEAR, Texture.BASE_LEVEL_LINEAR, Texture.WRAP, false, TextureLoader.SCALE_DRAW_BEST);\n        appr.setTexture(texture);\n    }\n\n    /**\n     * Enable picking of this node by traversing the scenegraph to the\n     * root and setting each node to be pickable.\n     *\n     * @param name the name used to identify this node.\n     */\n    public static void setPickable(Node node, String name) {\n        Node g = node.getParent();\n        while (g != null) {\n            g.setPickable(true);\n            g = g.getParent();\n        }\n        if (node instanceof Group) {\n            setPickableRecursive((Group) node, name);\n        }\n    }\n\n    /**\n     * Set all children of the specified group to be pickable.\n     *\n     * @param group the node at which to start.\n     * @param name the name used to identify the nodes.\n     */\n    public static void setPickableRecursive(Group group, String name) {\n        if (group == null) {\n            return;\n        }\n        group.setPickable(true);\n        java.util.Enumeration e = group.getAllChildren();\n        while (e.hasMoreElements()) {\n            Node node = (Node) e.nextElement();\n            // if it's a group rename all children\n            if (node instanceof Group) {\n                setPickableRecursive((Group) node, name);\n            } else {\n                node.setPickable(true);\n                if (node instanceof Shape3D) {\n                    node.setName(name);\n                }\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/Util3DTest10.java",
		"test_prompt": "// Util3DTest10.java\npackage gui.gl;\n\nimport static java.lang.Math.PI;\nimport static java.lang.Math.tan;\nimport static java.lang.Math.cos;\nimport static java.lang.Math.sin;\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.loaders.texture.*;\nimport com.xith3d.render.*;\nimport com.xith3d.render.jogl.*;\nimport javax.imageio.ImageIO;\nimport java.io.*;\nimport com.xith3d.image.DirectBufferedImage;\nimport java.awt.image.BufferedImage;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Util3D}.\n* It contains ten unit test cases for the {@link Util3D#toScreen(Canvas3D, Point3f)} method.\n*/\nclass Util3DTest10 {"
	},
	{
		"original_code": "// Util3D.java\n/* $Id: Util3D.java,v 1.6 2004/04/27 19:26:21 bja Exp $ */\npackage gui.gl;\n\nimport static java.lang.Math.PI;\nimport static java.lang.Math.tan;\nimport static java.lang.Math.cos;\nimport static java.lang.Math.sin;\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.loaders.texture.*;\nimport com.xith3d.render.*;\nimport com.xith3d.render.jogl.*;\nimport javax.imageio.ImageIO;\nimport java.io.*;\nimport com.xith3d.image.DirectBufferedImage;\nimport java.awt.image.BufferedImage;\n\npublic class Util3D {\n\n    public static final float rad(float ang) {\n        return (float) (ang / 180.0 * PI);\n    }\n\n    public static final float deg(float ang) {\n        return (float) (ang / PI * 180.0);\n    }\n\n    /**\n     * Creates a size-by-size wu sized plane with assigned texture\n     * coordinates. Texture coordinates are generated for two layers.\n     *\n     * @param size the size of the plane.\n     *\n     * @return the plane with the given normal and size.\n     */\n    public static Geometry createPlane(float size, float r) {\n        return createQuad(0, 0, size, r, r);\n    }\n\n    public static Geometry createQuad(float x, float y, float size, float s, float t) {\n        Point3f[] coords = new Point3f[] { new Point3f(x, 0f, y), new Point3f(x + size, 0f, y), new Point3f(x + size, 0f, y + size), new Point3f(x, 0f, y + size) };\n        TexCoord2f[] texcoords = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(s, 0f), new TexCoord2f(s, s), new TexCoord2f(0f, s) };\n        TexCoord2f[] texcoords2 = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(t, 0f), new TexCoord2f(t, t), new TexCoord2f(0f, t) };\n        QuadArray plane = new QuadArray(coords.length, GeometryArray.COORDINATES | GeometryArray.TEXTURE_COORDINATE_2, 2, new int[] { 0, 1 });\n        plane.setCoordinates(0, coords);\n        plane.setTextureCoordinates(0, 0, texcoords);\n        plane.setTextureCoordinates(1, 0, texcoords2);\n        return plane;\n    }\n\n    /**\n     * Create a new textured plane shape node.\n     *\n     * @param path the texture to apply to the plane.\n     * @param s the size of the plane.\n     * @param r the number of repetitions.\n     */\n    public static Shape3D createTexturedPlane(String path, float s, float r) {\n        TextureLoader loader = TextureLoader.getInstance();\n        // fixa\n        loader.registerPath(\"./\");\n        // fixa\n        loader.registerPath(\"./dat/tex/\");\n        // fixa\n        loader.registerPath(\"./dat/mdl/\");\n        // fixa\n        loader.registerPath(\"./dat/gfx/\");\n        Appearance appearance = new Appearance();\n        appearance.setTexture((Texture2D) loader.getMinMapTexture(path));\n        // Set polygon offset so that we can see objects lying in the\n        // same plane as the grid.\n        PolygonAttributes polyAttr = new PolygonAttributes();\n        polyAttr.setPolygonOffset(10.0f);\n        polyAttr.setPolygonOffsetFactor(20.0f);\n        appearance.setPolygonAttributes(polyAttr);\n        return new Shape3D(createPlane(s, r), appearance);\n    }\n\n    public static Geometry createRectangle(float w, float h, Color3f color) {\n        Point3f[] coords = new Point3f[] { new Point3f(0f, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, h), new Point3f(w, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, 0f) };\n        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);\n        Color3f[] colors = new Color3f[] { new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z) };\n        lines.setCoordinates(0, coords);\n        lines.setColors(0, colors);\n        return lines;\n    }\n\n    /**\n     * Creates the default coordinate axes with specified length.\n     * @param size the length of the axes.\n     */\n    public static Geometry createCoordAxes(float size) {\n        Point3f[] coords = new Point3f[] { new Point3f(0, 0, 0), new Point3f(size, 0, 0), new Point3f(0, 0, 0), new Point3f(0, size, 0), new Point3f(0, 0, 0), new Point3f(0, 0, size) };\n        Color3f[] colors = new Color3f[] { new Color3f(0, 0, 1), new Color3f(0, 0, 1), new Color3f(1, 0, 0), new Color3f(1, 0, 0), new Color3f(0, 1, 0), new Color3f(0, 1, 0) };\n        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);\n        lines.setCoordinates(0, coords);\n        lines.setColors(0, colors);\n        return lines;\n    }\n\n    /**\n     * Creates a new grid with the specified number of rows and columns,\n     * and with the specified cell size.\n     *\n     * @param cols the number of cols in the grid.\n     * @param rows the number of rows in the grid.\n     * @param size the size of a single cell.\n     */\n    public static Shape3D createGrid(int cols, int rows, float size) {\n        rows++;\n        cols++;\n        Point3f[] coords = new Point3f[2 * (rows + cols)];\n        LineArray grid = new LineArray(coords.length, GeometryArray.COORDINATES);\n        for (int i = 1; i < 2 * rows; i += 2) {\n            coords[i - 1] = new Point3f(0, 0.01f, .5f * size * (i - 1));\n            coords[i] = new Point3f((cols - 1) * size, 0.01f, .5f * size * (i - 1));\n        }\n        for (int j = 1; j < 2 * cols; j += 2) {\n            coords[2 * rows + j - 1] = new Point3f(.5f * size * (j - 1), 0.01f, 0);\n            coords[2 * rows + j] = new Point3f(.5f * size * (j - 1), 0.01f, (rows - 1) * size);\n        }\n        grid.setCoordinates(0, coords);\n        return new Shape3D(grid);\n    }\n\n    /* The following methods are for converting screen coordinates to     \n     * world coordinates. They are taken from the xith3d forum and \n     * modified to fit the application.\n     *                                                                    \n     * Reference: kevglass                                                \n     *                                                                    \n     * http://www.javagaming.org/cgi-bin/JGNetForums/YaBB.cgi?            \n     *        board=xith3d;action=display;num=1068252077;start=15         \n     */\n    /**\n     * Returns the point in world space corresponding to the given\n     * coordinates in screen space.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @return the point in world space at the given depth.\n     */\n    public static Point3f toWorld(Canvas3D c, int x, int y) {\n        return toWorld(c, x, y, c.getView().getFrontClipDistance());\n    }\n\n    /**\n     * Returns the point in world space corresponding to the given\n     * coordinates in screen space.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @param z the z coordinate (depth).\n     * @return the point in world space at the given depth.\n     */\n    public static Point3f toWorld(Canvas3D c, int x, int y, float z) {\n        float fov = c.getView().getFieldOfView();\n        float width = c.getWidth();\n        float height = c.getHeight();\n        float panelY = (float) (tan(fov) * z);\n        float panelX = panelY * (width / height);\n        float xp = x / (width / 2);\n        float yp = y / (height / 2);\n        Point3f pt = new Point3f((xp - 1) * panelX, (1 - yp) * panelY, -z);\n        Transform3D v = new Transform3D();\n        c.getView().getTransform(v);\n        v.transform(pt);\n        return pt;\n    }\n\n    /**\n     * Returns the point in screen space corresponding to the given\n     * coordinates in world space.\n     *\n     * @param c the associated canvas.\n     * @param x the world x coordinate.\n     * @param y the world y coordinate.\n     * @param z the world z coordinate.\n     * @return the corresponding point in screen space.\n     */\n    public static Point3f toScreen(Canvas3D c, Point3f p) {\n        return toScreen(c, p.x, p.y, p.z);\n    }\n\n    public static Point3f toScreen(Canvas3D c, float x, float y, float z) {\n        float fov = c.getView().getFieldOfView();\n        float width = c.getWidth();\n        float height = c.getHeight();\n        Transform3D v = new Transform3D();\n        c.getView().getTransform(v);\n        Point3f p = new Point3f(x, y, z);\n        v.invert();\n        v.transform(p);\n        float panelY = (float) (tan(fov) * p.z);\n        float panelX = panelY * (width / height);\n        Point3f pt = new Point3f(p.x / panelX + 1, -p.y / panelY + 1, p.z);\n        pt.x = width - pt.x * (width / 2);\n        pt.y = height - pt.y * (height / 2);\n        return pt;\n    }\n\n    /**\n     * Returns the ray eminating from the point (x, y) in screen space\n     * directed along the screen z-axis.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @return the ray eminating from x, y in screen space.\n     */\n    public static PickRay castRay(Canvas3D c, int x, int y) {\n        Point3f center = toWorld(c, x, y);\n        Point3f d = toWorld(c, x, y, c.getView().getFrontClipDistance() + 0.1f);\n        Vector3f forward = new Vector3f(center);\n        forward.sub(d);\n        return new PickRay(center, forward);\n    }\n\n    /**\n     * @param path the path to the image to open.\n     */\n    public static BufferedImage getBufferedImage(String path) {\n        BufferedImage bufferedImage = null;\n        try {\n            bufferedImage = ImageIO.read(path.getClass().getResource(path));\n        } catch (Exception e) {\n            try {\n                bufferedImage = ImageIO.read(new File(path));\n            } catch (Exception x) {\n                System.err.println(\"craps!\");\n                x.printStackTrace(System.err);\n            }\n        }\n        return bufferedImage;\n    }\n\n    /**\n     * Sets the specified texture to the specified appearance. The texture\n     * mode is set to modulated.\n     *\n     * reference: Java Cool Dude\n     */\n    public static void setTexture2D(Shape3D shape, String path) {\n        setTexture2D(shape, path, false, true, true);\n    }\n\n    public static void setTexture2D(Shape3D shape, String path, boolean clip, boolean blend, boolean depth) {\n        Appearance appr = shape.getAppearance();\n        if (appr == null) {\n            appr = new Appearance();\n            shape.setAppearance(appr);\n        }\n        setTexture2D(path, appr, clip, blend, depth);\n    }\n\n    public static void setTexture2D(String path, Appearance appr) {\n        setTexture2D(path, appr, false, false, false);\n    }\n\n    public static void setTexture2D(String path, Appearance appr, boolean clip, boolean blend, boolean depth) {\n        BufferedImage bufferedImage = getBufferedImage(path);\n        TextureLoader tl = TextureLoader.getInstance();\n        if (!depth) {\n            RenderingAttributes rendattr = new RenderingAttributes();\n            rendattr.setDepthBufferEnable(false);\n            appr.setRenderingAttributes(rendattr);\n        }\n        if (blend) {\n            TransparencyAttributes aattr = new TransparencyAttributes();\n            aattr.setTransparencyMode(TransparencyAttributes.BLENDED);\n            aattr.setTransparency(0.0f);\n            aattr.setDstBlendFunction(TransparencyAttributes.BLEND_ONE);\n            aattr.setSrcBlendFunction(TransparencyAttributes.BLEND_SRC_ALPHA);\n            appr.setTransparencyAttributes(aattr);\n        }\n        if (clip) {\n            TextureAttributes texattr = new TextureAttributes();\n            texattr.setTextureMode(TextureAttributes.MODULATE);\n            texattr.setPerspectiveCorrectionMode(TextureAttributes.FASTEST);\n            appr.setTextureAttributes(texattr);\n        }\n        bufferedImage = DirectBufferedImage.make(bufferedImage, false);\n        Texture2D texture = (Texture2D) tl.constructTexture(bufferedImage, \"RGB\", false, Texture.BASE_LEVEL_LINEAR, Texture.BASE_LEVEL_LINEAR, Texture.WRAP, false, TextureLoader.SCALE_DRAW_BEST);\n        appr.setTexture(texture);\n    }\n\n    /**\n     * Enable picking of this node by traversing the scenegraph to the\n     * root and setting each node to be pickable.\n     *\n     * @param name the name used to identify this node.\n     */\n    public static void setPickable(Node node, String name) {\n        Node g = node.getParent();\n        while (g != null) {\n            g.setPickable(true);\n            g = g.getParent();\n        }\n        if (node instanceof Group) {\n            setPickableRecursive((Group) node, name);\n        }\n    }\n\n    /**\n     * Set all children of the specified group to be pickable.\n     *\n     * @param group the node at which to start.\n     * @param name the name used to identify the nodes.\n     */\n    public static void setPickableRecursive(Group group, String name) {\n        if (group == null) {\n            return;\n        }\n        group.setPickable(true);\n        java.util.Enumeration e = group.getAllChildren();\n        while (e.hasMoreElements()) {\n            Node node = (Node) e.nextElement();\n            // if it's a group rename all children\n            if (node instanceof Group) {\n                setPickableRecursive((Group) node, name);\n            } else {\n                node.setPickable(true);\n                if (node instanceof Shape3D) {\n                    node.setName(name);\n                }\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/Util3DTest11.java",
		"test_prompt": "// Util3DTest11.java\npackage gui.gl;\n\nimport static java.lang.Math.PI;\nimport static java.lang.Math.tan;\nimport static java.lang.Math.cos;\nimport static java.lang.Math.sin;\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.loaders.texture.*;\nimport com.xith3d.render.*;\nimport com.xith3d.render.jogl.*;\nimport javax.imageio.ImageIO;\nimport java.io.*;\nimport com.xith3d.image.DirectBufferedImage;\nimport java.awt.image.BufferedImage;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Util3D}.\n* It contains ten unit test cases for the {@link Util3D#toScreen(Canvas3D, float, float, float)} method.\n*/\nclass Util3DTest11 {"
	},
	{
		"original_code": "// Util3D.java\n/* $Id: Util3D.java,v 1.6 2004/04/27 19:26:21 bja Exp $ */\npackage gui.gl;\n\nimport static java.lang.Math.PI;\nimport static java.lang.Math.tan;\nimport static java.lang.Math.cos;\nimport static java.lang.Math.sin;\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.loaders.texture.*;\nimport com.xith3d.render.*;\nimport com.xith3d.render.jogl.*;\nimport javax.imageio.ImageIO;\nimport java.io.*;\nimport com.xith3d.image.DirectBufferedImage;\nimport java.awt.image.BufferedImage;\n\npublic class Util3D {\n\n    public static final float rad(float ang) {\n        return (float) (ang / 180.0 * PI);\n    }\n\n    public static final float deg(float ang) {\n        return (float) (ang / PI * 180.0);\n    }\n\n    /**\n     * Creates a size-by-size wu sized plane with assigned texture\n     * coordinates. Texture coordinates are generated for two layers.\n     *\n     * @param size the size of the plane.\n     *\n     * @return the plane with the given normal and size.\n     */\n    public static Geometry createPlane(float size, float r) {\n        return createQuad(0, 0, size, r, r);\n    }\n\n    public static Geometry createQuad(float x, float y, float size, float s, float t) {\n        Point3f[] coords = new Point3f[] { new Point3f(x, 0f, y), new Point3f(x + size, 0f, y), new Point3f(x + size, 0f, y + size), new Point3f(x, 0f, y + size) };\n        TexCoord2f[] texcoords = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(s, 0f), new TexCoord2f(s, s), new TexCoord2f(0f, s) };\n        TexCoord2f[] texcoords2 = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(t, 0f), new TexCoord2f(t, t), new TexCoord2f(0f, t) };\n        QuadArray plane = new QuadArray(coords.length, GeometryArray.COORDINATES | GeometryArray.TEXTURE_COORDINATE_2, 2, new int[] { 0, 1 });\n        plane.setCoordinates(0, coords);\n        plane.setTextureCoordinates(0, 0, texcoords);\n        plane.setTextureCoordinates(1, 0, texcoords2);\n        return plane;\n    }\n\n    /**\n     * Create a new textured plane shape node.\n     *\n     * @param path the texture to apply to the plane.\n     * @param s the size of the plane.\n     * @param r the number of repetitions.\n     */\n    public static Shape3D createTexturedPlane(String path, float s, float r) {\n        TextureLoader loader = TextureLoader.getInstance();\n        // fixa\n        loader.registerPath(\"./\");\n        // fixa\n        loader.registerPath(\"./dat/tex/\");\n        // fixa\n        loader.registerPath(\"./dat/mdl/\");\n        // fixa\n        loader.registerPath(\"./dat/gfx/\");\n        Appearance appearance = new Appearance();\n        appearance.setTexture((Texture2D) loader.getMinMapTexture(path));\n        // Set polygon offset so that we can see objects lying in the\n        // same plane as the grid.\n        PolygonAttributes polyAttr = new PolygonAttributes();\n        polyAttr.setPolygonOffset(10.0f);\n        polyAttr.setPolygonOffsetFactor(20.0f);\n        appearance.setPolygonAttributes(polyAttr);\n        return new Shape3D(createPlane(s, r), appearance);\n    }\n\n    public static Geometry createRectangle(float w, float h, Color3f color) {\n        Point3f[] coords = new Point3f[] { new Point3f(0f, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, h), new Point3f(w, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, 0f) };\n        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);\n        Color3f[] colors = new Color3f[] { new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z) };\n        lines.setCoordinates(0, coords);\n        lines.setColors(0, colors);\n        return lines;\n    }\n\n    /**\n     * Creates the default coordinate axes with specified length.\n     * @param size the length of the axes.\n     */\n    public static Geometry createCoordAxes(float size) {\n        Point3f[] coords = new Point3f[] { new Point3f(0, 0, 0), new Point3f(size, 0, 0), new Point3f(0, 0, 0), new Point3f(0, size, 0), new Point3f(0, 0, 0), new Point3f(0, 0, size) };\n        Color3f[] colors = new Color3f[] { new Color3f(0, 0, 1), new Color3f(0, 0, 1), new Color3f(1, 0, 0), new Color3f(1, 0, 0), new Color3f(0, 1, 0), new Color3f(0, 1, 0) };\n        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);\n        lines.setCoordinates(0, coords);\n        lines.setColors(0, colors);\n        return lines;\n    }\n\n    /**\n     * Creates a new grid with the specified number of rows and columns,\n     * and with the specified cell size.\n     *\n     * @param cols the number of cols in the grid.\n     * @param rows the number of rows in the grid.\n     * @param size the size of a single cell.\n     */\n    public static Shape3D createGrid(int cols, int rows, float size) {\n        rows++;\n        cols++;\n        Point3f[] coords = new Point3f[2 * (rows + cols)];\n        LineArray grid = new LineArray(coords.length, GeometryArray.COORDINATES);\n        for (int i = 1; i < 2 * rows; i += 2) {\n            coords[i - 1] = new Point3f(0, 0.01f, .5f * size * (i - 1));\n            coords[i] = new Point3f((cols - 1) * size, 0.01f, .5f * size * (i - 1));\n        }\n        for (int j = 1; j < 2 * cols; j += 2) {\n            coords[2 * rows + j - 1] = new Point3f(.5f * size * (j - 1), 0.01f, 0);\n            coords[2 * rows + j] = new Point3f(.5f * size * (j - 1), 0.01f, (rows - 1) * size);\n        }\n        grid.setCoordinates(0, coords);\n        return new Shape3D(grid);\n    }\n\n    /* The following methods are for converting screen coordinates to     \n     * world coordinates. They are taken from the xith3d forum and \n     * modified to fit the application.\n     *                                                                    \n     * Reference: kevglass                                                \n     *                                                                    \n     * http://www.javagaming.org/cgi-bin/JGNetForums/YaBB.cgi?            \n     *        board=xith3d;action=display;num=1068252077;start=15         \n     */\n    /**\n     * Returns the point in world space corresponding to the given\n     * coordinates in screen space.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @return the point in world space at the given depth.\n     */\n    public static Point3f toWorld(Canvas3D c, int x, int y) {\n        return toWorld(c, x, y, c.getView().getFrontClipDistance());\n    }\n\n    /**\n     * Returns the point in world space corresponding to the given\n     * coordinates in screen space.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @param z the z coordinate (depth).\n     * @return the point in world space at the given depth.\n     */\n    public static Point3f toWorld(Canvas3D c, int x, int y, float z) {\n        float fov = c.getView().getFieldOfView();\n        float width = c.getWidth();\n        float height = c.getHeight();\n        float panelY = (float) (tan(fov) * z);\n        float panelX = panelY * (width / height);\n        float xp = x / (width / 2);\n        float yp = y / (height / 2);\n        Point3f pt = new Point3f((xp - 1) * panelX, (1 - yp) * panelY, -z);\n        Transform3D v = new Transform3D();\n        c.getView().getTransform(v);\n        v.transform(pt);\n        return pt;\n    }\n\n    /**\n     * Returns the point in screen space corresponding to the given\n     * coordinates in world space.\n     *\n     * @param c the associated canvas.\n     * @param x the world x coordinate.\n     * @param y the world y coordinate.\n     * @param z the world z coordinate.\n     * @return the corresponding point in screen space.\n     */\n    public static Point3f toScreen(Canvas3D c, Point3f p) {\n        return toScreen(c, p.x, p.y, p.z);\n    }\n\n    public static Point3f toScreen(Canvas3D c, float x, float y, float z) {\n        float fov = c.getView().getFieldOfView();\n        float width = c.getWidth();\n        float height = c.getHeight();\n        Transform3D v = new Transform3D();\n        c.getView().getTransform(v);\n        Point3f p = new Point3f(x, y, z);\n        v.invert();\n        v.transform(p);\n        float panelY = (float) (tan(fov) * p.z);\n        float panelX = panelY * (width / height);\n        Point3f pt = new Point3f(p.x / panelX + 1, -p.y / panelY + 1, p.z);\n        pt.x = width - pt.x * (width / 2);\n        pt.y = height - pt.y * (height / 2);\n        return pt;\n    }\n\n    /**\n     * Returns the ray eminating from the point (x, y) in screen space\n     * directed along the screen z-axis.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @return the ray eminating from x, y in screen space.\n     */\n    public static PickRay castRay(Canvas3D c, int x, int y) {\n        Point3f center = toWorld(c, x, y);\n        Point3f d = toWorld(c, x, y, c.getView().getFrontClipDistance() + 0.1f);\n        Vector3f forward = new Vector3f(center);\n        forward.sub(d);\n        return new PickRay(center, forward);\n    }\n\n    /**\n     * @param path the path to the image to open.\n     */\n    public static BufferedImage getBufferedImage(String path) {\n        BufferedImage bufferedImage = null;\n        try {\n            bufferedImage = ImageIO.read(path.getClass().getResource(path));\n        } catch (Exception e) {\n            try {\n                bufferedImage = ImageIO.read(new File(path));\n            } catch (Exception x) {\n                System.err.println(\"craps!\");\n                x.printStackTrace(System.err);\n            }\n        }\n        return bufferedImage;\n    }\n\n    /**\n     * Sets the specified texture to the specified appearance. The texture\n     * mode is set to modulated.\n     *\n     * reference: Java Cool Dude\n     */\n    public static void setTexture2D(Shape3D shape, String path) {\n        setTexture2D(shape, path, false, true, true);\n    }\n\n    public static void setTexture2D(Shape3D shape, String path, boolean clip, boolean blend, boolean depth) {\n        Appearance appr = shape.getAppearance();\n        if (appr == null) {\n            appr = new Appearance();\n            shape.setAppearance(appr);\n        }\n        setTexture2D(path, appr, clip, blend, depth);\n    }\n\n    public static void setTexture2D(String path, Appearance appr) {\n        setTexture2D(path, appr, false, false, false);\n    }\n\n    public static void setTexture2D(String path, Appearance appr, boolean clip, boolean blend, boolean depth) {\n        BufferedImage bufferedImage = getBufferedImage(path);\n        TextureLoader tl = TextureLoader.getInstance();\n        if (!depth) {\n            RenderingAttributes rendattr = new RenderingAttributes();\n            rendattr.setDepthBufferEnable(false);\n            appr.setRenderingAttributes(rendattr);\n        }\n        if (blend) {\n            TransparencyAttributes aattr = new TransparencyAttributes();\n            aattr.setTransparencyMode(TransparencyAttributes.BLENDED);\n            aattr.setTransparency(0.0f);\n            aattr.setDstBlendFunction(TransparencyAttributes.BLEND_ONE);\n            aattr.setSrcBlendFunction(TransparencyAttributes.BLEND_SRC_ALPHA);\n            appr.setTransparencyAttributes(aattr);\n        }\n        if (clip) {\n            TextureAttributes texattr = new TextureAttributes();\n            texattr.setTextureMode(TextureAttributes.MODULATE);\n            texattr.setPerspectiveCorrectionMode(TextureAttributes.FASTEST);\n            appr.setTextureAttributes(texattr);\n        }\n        bufferedImage = DirectBufferedImage.make(bufferedImage, false);\n        Texture2D texture = (Texture2D) tl.constructTexture(bufferedImage, \"RGB\", false, Texture.BASE_LEVEL_LINEAR, Texture.BASE_LEVEL_LINEAR, Texture.WRAP, false, TextureLoader.SCALE_DRAW_BEST);\n        appr.setTexture(texture);\n    }\n\n    /**\n     * Enable picking of this node by traversing the scenegraph to the\n     * root and setting each node to be pickable.\n     *\n     * @param name the name used to identify this node.\n     */\n    public static void setPickable(Node node, String name) {\n        Node g = node.getParent();\n        while (g != null) {\n            g.setPickable(true);\n            g = g.getParent();\n        }\n        if (node instanceof Group) {\n            setPickableRecursive((Group) node, name);\n        }\n    }\n\n    /**\n     * Set all children of the specified group to be pickable.\n     *\n     * @param group the node at which to start.\n     * @param name the name used to identify the nodes.\n     */\n    public static void setPickableRecursive(Group group, String name) {\n        if (group == null) {\n            return;\n        }\n        group.setPickable(true);\n        java.util.Enumeration e = group.getAllChildren();\n        while (e.hasMoreElements()) {\n            Node node = (Node) e.nextElement();\n            // if it's a group rename all children\n            if (node instanceof Group) {\n                setPickableRecursive((Group) node, name);\n            } else {\n                node.setPickable(true);\n                if (node instanceof Shape3D) {\n                    node.setName(name);\n                }\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/Util3DTest12.java",
		"test_prompt": "// Util3DTest12.java\npackage gui.gl;\n\nimport static java.lang.Math.PI;\nimport static java.lang.Math.tan;\nimport static java.lang.Math.cos;\nimport static java.lang.Math.sin;\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.loaders.texture.*;\nimport com.xith3d.render.*;\nimport com.xith3d.render.jogl.*;\nimport javax.imageio.ImageIO;\nimport java.io.*;\nimport com.xith3d.image.DirectBufferedImage;\nimport java.awt.image.BufferedImage;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Util3D}.\n* It contains ten unit test cases for the {@link Util3D#castRay(Canvas3D, int, int)} method.\n*/\nclass Util3DTest12 {"
	},
	{
		"original_code": "// Util3D.java\n/* $Id: Util3D.java,v 1.6 2004/04/27 19:26:21 bja Exp $ */\npackage gui.gl;\n\nimport static java.lang.Math.PI;\nimport static java.lang.Math.tan;\nimport static java.lang.Math.cos;\nimport static java.lang.Math.sin;\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.loaders.texture.*;\nimport com.xith3d.render.*;\nimport com.xith3d.render.jogl.*;\nimport javax.imageio.ImageIO;\nimport java.io.*;\nimport com.xith3d.image.DirectBufferedImage;\nimport java.awt.image.BufferedImage;\n\npublic class Util3D {\n\n    public static final float rad(float ang) {\n        return (float) (ang / 180.0 * PI);\n    }\n\n    public static final float deg(float ang) {\n        return (float) (ang / PI * 180.0);\n    }\n\n    /**\n     * Creates a size-by-size wu sized plane with assigned texture\n     * coordinates. Texture coordinates are generated for two layers.\n     *\n     * @param size the size of the plane.\n     *\n     * @return the plane with the given normal and size.\n     */\n    public static Geometry createPlane(float size, float r) {\n        return createQuad(0, 0, size, r, r);\n    }\n\n    public static Geometry createQuad(float x, float y, float size, float s, float t) {\n        Point3f[] coords = new Point3f[] { new Point3f(x, 0f, y), new Point3f(x + size, 0f, y), new Point3f(x + size, 0f, y + size), new Point3f(x, 0f, y + size) };\n        TexCoord2f[] texcoords = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(s, 0f), new TexCoord2f(s, s), new TexCoord2f(0f, s) };\n        TexCoord2f[] texcoords2 = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(t, 0f), new TexCoord2f(t, t), new TexCoord2f(0f, t) };\n        QuadArray plane = new QuadArray(coords.length, GeometryArray.COORDINATES | GeometryArray.TEXTURE_COORDINATE_2, 2, new int[] { 0, 1 });\n        plane.setCoordinates(0, coords);\n        plane.setTextureCoordinates(0, 0, texcoords);\n        plane.setTextureCoordinates(1, 0, texcoords2);\n        return plane;\n    }\n\n    /**\n     * Create a new textured plane shape node.\n     *\n     * @param path the texture to apply to the plane.\n     * @param s the size of the plane.\n     * @param r the number of repetitions.\n     */\n    public static Shape3D createTexturedPlane(String path, float s, float r) {\n        TextureLoader loader = TextureLoader.getInstance();\n        // fixa\n        loader.registerPath(\"./\");\n        // fixa\n        loader.registerPath(\"./dat/tex/\");\n        // fixa\n        loader.registerPath(\"./dat/mdl/\");\n        // fixa\n        loader.registerPath(\"./dat/gfx/\");\n        Appearance appearance = new Appearance();\n        appearance.setTexture((Texture2D) loader.getMinMapTexture(path));\n        // Set polygon offset so that we can see objects lying in the\n        // same plane as the grid.\n        PolygonAttributes polyAttr = new PolygonAttributes();\n        polyAttr.setPolygonOffset(10.0f);\n        polyAttr.setPolygonOffsetFactor(20.0f);\n        appearance.setPolygonAttributes(polyAttr);\n        return new Shape3D(createPlane(s, r), appearance);\n    }\n\n    public static Geometry createRectangle(float w, float h, Color3f color) {\n        Point3f[] coords = new Point3f[] { new Point3f(0f, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, h), new Point3f(w, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, 0f) };\n        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);\n        Color3f[] colors = new Color3f[] { new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z) };\n        lines.setCoordinates(0, coords);\n        lines.setColors(0, colors);\n        return lines;\n    }\n\n    /**\n     * Creates the default coordinate axes with specified length.\n     * @param size the length of the axes.\n     */\n    public static Geometry createCoordAxes(float size) {\n        Point3f[] coords = new Point3f[] { new Point3f(0, 0, 0), new Point3f(size, 0, 0), new Point3f(0, 0, 0), new Point3f(0, size, 0), new Point3f(0, 0, 0), new Point3f(0, 0, size) };\n        Color3f[] colors = new Color3f[] { new Color3f(0, 0, 1), new Color3f(0, 0, 1), new Color3f(1, 0, 0), new Color3f(1, 0, 0), new Color3f(0, 1, 0), new Color3f(0, 1, 0) };\n        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);\n        lines.setCoordinates(0, coords);\n        lines.setColors(0, colors);\n        return lines;\n    }\n\n    /**\n     * Creates a new grid with the specified number of rows and columns,\n     * and with the specified cell size.\n     *\n     * @param cols the number of cols in the grid.\n     * @param rows the number of rows in the grid.\n     * @param size the size of a single cell.\n     */\n    public static Shape3D createGrid(int cols, int rows, float size) {\n        rows++;\n        cols++;\n        Point3f[] coords = new Point3f[2 * (rows + cols)];\n        LineArray grid = new LineArray(coords.length, GeometryArray.COORDINATES);\n        for (int i = 1; i < 2 * rows; i += 2) {\n            coords[i - 1] = new Point3f(0, 0.01f, .5f * size * (i - 1));\n            coords[i] = new Point3f((cols - 1) * size, 0.01f, .5f * size * (i - 1));\n        }\n        for (int j = 1; j < 2 * cols; j += 2) {\n            coords[2 * rows + j - 1] = new Point3f(.5f * size * (j - 1), 0.01f, 0);\n            coords[2 * rows + j] = new Point3f(.5f * size * (j - 1), 0.01f, (rows - 1) * size);\n        }\n        grid.setCoordinates(0, coords);\n        return new Shape3D(grid);\n    }\n\n    /* The following methods are for converting screen coordinates to     \n     * world coordinates. They are taken from the xith3d forum and \n     * modified to fit the application.\n     *                                                                    \n     * Reference: kevglass                                                \n     *                                                                    \n     * http://www.javagaming.org/cgi-bin/JGNetForums/YaBB.cgi?            \n     *        board=xith3d;action=display;num=1068252077;start=15         \n     */\n    /**\n     * Returns the point in world space corresponding to the given\n     * coordinates in screen space.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @return the point in world space at the given depth.\n     */\n    public static Point3f toWorld(Canvas3D c, int x, int y) {\n        return toWorld(c, x, y, c.getView().getFrontClipDistance());\n    }\n\n    /**\n     * Returns the point in world space corresponding to the given\n     * coordinates in screen space.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @param z the z coordinate (depth).\n     * @return the point in world space at the given depth.\n     */\n    public static Point3f toWorld(Canvas3D c, int x, int y, float z) {\n        float fov = c.getView().getFieldOfView();\n        float width = c.getWidth();\n        float height = c.getHeight();\n        float panelY = (float) (tan(fov) * z);\n        float panelX = panelY * (width / height);\n        float xp = x / (width / 2);\n        float yp = y / (height / 2);\n        Point3f pt = new Point3f((xp - 1) * panelX, (1 - yp) * panelY, -z);\n        Transform3D v = new Transform3D();\n        c.getView().getTransform(v);\n        v.transform(pt);\n        return pt;\n    }\n\n    /**\n     * Returns the point in screen space corresponding to the given\n     * coordinates in world space.\n     *\n     * @param c the associated canvas.\n     * @param x the world x coordinate.\n     * @param y the world y coordinate.\n     * @param z the world z coordinate.\n     * @return the corresponding point in screen space.\n     */\n    public static Point3f toScreen(Canvas3D c, Point3f p) {\n        return toScreen(c, p.x, p.y, p.z);\n    }\n\n    public static Point3f toScreen(Canvas3D c, float x, float y, float z) {\n        float fov = c.getView().getFieldOfView();\n        float width = c.getWidth();\n        float height = c.getHeight();\n        Transform3D v = new Transform3D();\n        c.getView().getTransform(v);\n        Point3f p = new Point3f(x, y, z);\n        v.invert();\n        v.transform(p);\n        float panelY = (float) (tan(fov) * p.z);\n        float panelX = panelY * (width / height);\n        Point3f pt = new Point3f(p.x / panelX + 1, -p.y / panelY + 1, p.z);\n        pt.x = width - pt.x * (width / 2);\n        pt.y = height - pt.y * (height / 2);\n        return pt;\n    }\n\n    /**\n     * Returns the ray eminating from the point (x, y) in screen space\n     * directed along the screen z-axis.\n     *\n     * @param c the associated canvas.\n     * @param x the x coordinate.\n     * @param y the y coordinate.\n     * @return the ray eminating from x, y in screen space.\n     */\n    public static PickRay castRay(Canvas3D c, int x, int y) {\n        Point3f center = toWorld(c, x, y);\n        Point3f d = toWorld(c, x, y, c.getView().getFrontClipDistance() + 0.1f);\n        Vector3f forward = new Vector3f(center);\n        forward.sub(d);\n        return new PickRay(center, forward);\n    }\n\n    /**\n     * @param path the path to the image to open.\n     */\n    public static BufferedImage getBufferedImage(String path) {\n        BufferedImage bufferedImage = null;\n        try {\n            bufferedImage = ImageIO.read(path.getClass().getResource(path));\n        } catch (Exception e) {\n            try {\n                bufferedImage = ImageIO.read(new File(path));\n            } catch (Exception x) {\n                System.err.println(\"craps!\");\n                x.printStackTrace(System.err);\n            }\n        }\n        return bufferedImage;\n    }\n\n    /**\n     * Sets the specified texture to the specified appearance. The texture\n     * mode is set to modulated.\n     *\n     * reference: Java Cool Dude\n     */\n    public static void setTexture2D(Shape3D shape, String path) {\n        setTexture2D(shape, path, false, true, true);\n    }\n\n    public static void setTexture2D(Shape3D shape, String path, boolean clip, boolean blend, boolean depth) {\n        Appearance appr = shape.getAppearance();\n        if (appr == null) {\n            appr = new Appearance();\n            shape.setAppearance(appr);\n        }\n        setTexture2D(path, appr, clip, blend, depth);\n    }\n\n    public static void setTexture2D(String path, Appearance appr) {\n        setTexture2D(path, appr, false, false, false);\n    }\n\n    public static void setTexture2D(String path, Appearance appr, boolean clip, boolean blend, boolean depth) {\n        BufferedImage bufferedImage = getBufferedImage(path);\n        TextureLoader tl = TextureLoader.getInstance();\n        if (!depth) {\n            RenderingAttributes rendattr = new RenderingAttributes();\n            rendattr.setDepthBufferEnable(false);\n            appr.setRenderingAttributes(rendattr);\n        }\n        if (blend) {\n            TransparencyAttributes aattr = new TransparencyAttributes();\n            aattr.setTransparencyMode(TransparencyAttributes.BLENDED);\n            aattr.setTransparency(0.0f);\n            aattr.setDstBlendFunction(TransparencyAttributes.BLEND_ONE);\n            aattr.setSrcBlendFunction(TransparencyAttributes.BLEND_SRC_ALPHA);\n            appr.setTransparencyAttributes(aattr);\n        }\n        if (clip) {\n            TextureAttributes texattr = new TextureAttributes();\n            texattr.setTextureMode(TextureAttributes.MODULATE);\n            texattr.setPerspectiveCorrectionMode(TextureAttributes.FASTEST);\n            appr.setTextureAttributes(texattr);\n        }\n        bufferedImage = DirectBufferedImage.make(bufferedImage, false);\n        Texture2D texture = (Texture2D) tl.constructTexture(bufferedImage, \"RGB\", false, Texture.BASE_LEVEL_LINEAR, Texture.BASE_LEVEL_LINEAR, Texture.WRAP, false, TextureLoader.SCALE_DRAW_BEST);\n        appr.setTexture(texture);\n    }\n\n    /**\n     * Enable picking of this node by traversing the scenegraph to the\n     * root and setting each node to be pickable.\n     *\n     * @param name the name used to identify this node.\n     */\n    public static void setPickable(Node node, String name) {\n        Node g = node.getParent();\n        while (g != null) {\n            g.setPickable(true);\n            g = g.getParent();\n        }\n        if (node instanceof Group) {\n            setPickableRecursive((Group) node, name);\n        }\n    }\n\n    /**\n     * Set all children of the specified group to be pickable.\n     *\n     * @param group the node at which to start.\n     * @param name the name used to identify the nodes.\n     */\n    public static void setPickableRecursive(Group group, String name) {\n        if (group == null) {\n            return;\n        }\n        group.setPickable(true);\n        java.util.Enumeration e = group.getAllChildren();\n        while (e.hasMoreElements()) {\n            Node node = (Node) e.nextElement();\n            // if it's a group rename all children\n            if (node instanceof Group) {\n                setPickableRecursive((Group) node, name);\n            } else {\n                node.setPickable(true);\n                if (node instanceof Shape3D) {\n                    node.setName(name);\n                }\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/Util3DTest13.java",
		"test_prompt": "// Util3DTest13.java\npackage gui.gl;\n\nimport static java.lang.Math.PI;\nimport static java.lang.Math.tan;\nimport static java.lang.Math.cos;\nimport static java.lang.Math.sin;\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.loaders.texture.*;\nimport com.xith3d.render.*;\nimport com.xith3d.render.jogl.*;\nimport javax.imageio.ImageIO;\nimport java.io.*;\nimport com.xith3d.image.DirectBufferedImage;\nimport java.awt.image.BufferedImage;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Util3D}.\n* It contains ten unit test cases for the {@link Util3D#getBufferedImage(String)} method.\n*/\nclass Util3DTest13 {"
	},
	{
		"original_code": "// HeadUpDisplay.java\n/* $Id: HeadUpDisplay.java,v 1.4 2004/05/04 21:33:58 emill Exp $\n *\n * Based on Jens Lehmann's excellent tutorial found at \n * http://xith.org/tutes/GettingStarted/html/simple_header.html\n *\n * @author Joel Andersson <bja@kth.se>\n * @version $Revision: 1.4 $\n */\npackage gui.gl;\n\nimport com.xith3d.scenegraph.Node;\nimport com.xith3d.scenegraph.BoundingSphere;\nimport com.xith3d.scenegraph.Canvas3D;\nimport com.xith3d.scenegraph.Shape3D;\nimport com.xith3d.userinterface.UIOverlay;\nimport com.xith3d.userinterface.UIOverlayInterface;\nimport com.xith3d.userinterface.UIWindow;\nimport com.xith3d.userinterface.UIWindowManager;\nimport com.xith3d.userinterface.UIPositionedWindow;\nimport javax.vecmath.Point3f;\nimport java.awt.Font;\nimport java.awt.FontMetrics;\nimport java.awt.Graphics2D;\nimport java.awt.GraphicsConfiguration;\nimport java.awt.GraphicsDevice;\nimport java.awt.GraphicsEnvironment;\nimport java.awt.image.BufferedImage;\nimport java.awt.Dimension;\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.BorderLayout;\nimport javax.swing.JTextArea;\nimport javax.swing.JPanel;\n\n/**\n */\npublic class HeadUpDisplay extends UIWindowManager {\n\n    /**\n     */\n    private Canvas3D canvas;\n\n    /**\n     */\n    public HeadUpDisplay(Canvas3D c) {\n        super(c);\n        this.canvas = c;\n    }\n\n    /**\n     */\n    public UIPositionedWindow addOverlay(UIOverlayInterface o) {\n        if (o instanceof Overlay) {\n            ((Overlay) o).setWindowManager(this);\n        }\n        if (o instanceof NodeOverlay) {\n            ((NodeOverlay) o).setCanvas(canvas);\n        }\n        setPosition(o, 0, 0);\n        setVisible(o, true);\n        return super.addOverlay(o);\n    }\n}\n\n/**\n */\nclass SwingTextOverlay extends UIWindow {\n\n    /**\n     */\n    private JTextArea textArea;\n\n    /**\n     */\n    private JPanel root;\n\n    /**\n     */\n    private Color background;\n\n    /**\n     */\n    private Color foreground;\n\n    /**\n     * @param width\n     * @param height\n     */\n    public SwingTextOverlay(int width, int height) {\n        super(width, height, true, true);\n        background = new Color(0.0f, 0.0f, 0.0f, 0.0f);\n        foreground = new Color(1.0f, 1.0f, 1.0f, 1.0f);\n        textArea = new JTextArea();\n        textArea.setForeground(foreground);\n        textArea.setBackground(background);\n        root = new JPanel();\n        root.setLayout(new BorderLayout());\n        root.setBackground(background);\n        root.setSize(new Dimension(width, height));\n        root.add(BorderLayout.CENTER, textArea);\n        setRoot(root);\n    }\n\n    /**\n     * @param text\n     */\n    public void setText(String text) {\n        textArea.setText(text);\n    }\n\n    public void append(String text) {\n        textArea.append(text);\n    }\n\n    public void clear() {\n        setText(\"\");\n    }\n}\n\nclass TextOverlay implements Overlay {\n\n    public static final Font FONT_PLAIN;\n\n    static {\n        FONT_PLAIN = new Font(\"SansSerif\", Font.PLAIN, 12);\n    }\n\n    private static final Color transparent = new Color(0, 0, 0, 0);\n\n    private UIOverlay overlay;\n\n    private FontMetrics fontMetrics;\n\n    private String text;\n\n    private Font font;\n\n    private Graphics2D gfx = null;\n\n    private int width = 0;\n\n    private int height = 0;\n\n    private UIWindowManager uiWinMgr;\n\n    private Color foreground;\n\n    private Color background;\n\n    private Color shadow;\n\n    private Color outline;\n\n    /**\n     * Creates a new TextOverlay with the specified text.\n     * @param text the text associated with this overlay.\n     */\n    TextOverlay(String text) {\n        setFont(\"SansSerif\", Font.PLAIN, 12);\n        setBackground(transparent);\n        setForeground(Color.WHITE);\n        setShadow(transparent);\n        setOutline(Color.black);\n        setText(text);\n        setVisible(true);\n        setPosition(0, 0);\n    }\n\n    public void setFont(String name, int style, int size) {\n        try {\n            font = new Font(name, style, size);\n            fontMetrics = getFontMetrics(font);\n            overlay.repaint();\n        } catch (NullPointerException e) {\n            // text not set, ignore this exception.\n        }\n    }\n\n    public String getText() {\n        return text;\n    }\n\n    public void setText(String text) {\n        this.text = text;\n        int w = fontMetrics.stringWidth(text);\n        int h = fontMetrics.getMaxDescent() + fontMetrics.getMaxAscent();\n        if (w > width || h > height) {\n            // add space for round edge\n            width = w + h;\n            height = h;\n            overlay = new UIOverlay(width, height + 2, true, false) {\n\n                public void paint(Graphics2D g) {\n                    int ascent = fontMetrics.getMaxAscent();\n                    // background\n                    g.setColor(background);\n                    g.fillArc(0, 0, height, height, 90, 180);\n                    g.fillArc(width - height, 0, height, height, 270, 180);\n                    g.fillRect(height / 2, 0, width - height, height);\n                    // border\n                    /*\n\t\t\tg.setColor(outline);\n\t\t\tg.drawArc(0,0,height-1,height,90,180);\n\t\t\tg.drawArc(width-height,0,height-1,height,270,180);\n\t\t\tg.drawLine(height/2,0,width-height/2,0);\n\t\t\tg.drawLine(height/2,height-1,width-height/2,height-1);\n\t\t\tg.drawArc(2,2,height-3,height-3,90,180);\n\t\t\tg.drawArc(width-height-2,2,height-3,height-3,270,180);\n\t\t\tg.drawLine(height/2,2,width-height/2,2);\n\t\t\tg.drawLine(height/2,height-3,width-height/2,height-3);\n\t\t\tg.setColor(foreground);\n\t\t\tg.drawArc(1,1,height-2,height-2,90,180);\n\t\t\tg.drawArc(width-height-1,1,height-2,height-2,270,180);\n\t\t\tg.drawLine(height/2,1,width-height/2,1);\n\t\t\tg.drawLine(height/2,height-2,width-height/2,height-2);\n\t\t\t*/\n                    // outlined\n                    g.setColor(outline);\n                    g.drawString(getText(), height / 2, ascent - 1);\n                    g.drawString(getText(), height / 2, ascent + 1);\n                    g.drawString(getText(), height / 2 - 1, ascent);\n                    g.drawString(getText(), height / 2 + 1, ascent);\n                    // shadowed\n                    g.setColor(shadow);\n                    g.drawString(getText(), height / 2 + 1, ascent + 1);\n                    g.drawString(getText(), height / 2 + 2, ascent + 2);\n                    // foreground\n                    g.setColor(foreground);\n                    g.drawString(getText(), height / 2, ascent);\n                }\n            };\n            BufferedImage img = overlay.getBackgroundImage();\n            overlay.setBackgroundMode(UIOverlay.BACKGROUND_COPY);\n            overlay.setBackgroundImage(img);\n            gfx = img.createGraphics();\n            if (uiWinMgr != null) {\n                uiWinMgr.removeOverlay(this);\n                uiWinMgr.addOverlay(this);\n            }\n        }\n        overlay.repaint();\n    }\n\n    public void setForeground(Color color) {\n        try {\n            this.foreground = color;\n            overlay.repaint();\n        } catch (NullPointerException e) {\n            // text not set, ignore this.\n        }\n    }\n\n    public void setBackground(Color color) {\n        try {\n            this.background = color;\n            overlay.repaint();\n        } catch (NullPointerException e) {\n            // text not set, ignore this.\n        }\n    }\n\n    public void setShadow(Color color) {\n        try {\n            this.shadow = color;\n            overlay.repaint();\n        } catch (NullPointerException e) {\n            // text not set, ignore this.\n        }\n    }\n\n    public void setOutline(Color color) {\n        try {\n            this.outline = color;\n            overlay.repaint();\n        } catch (NullPointerException e) {\n            // text not set, ignore this.\n        }\n    }\n\n    public void setPosition(int x, int y) {\n        if (uiWinMgr != null) {\n            uiWinMgr.setPosition(this, x - width / 2, y - height / 2);\n        } else {\n            overlay.setPosition(x, y);\n        }\n    }\n\n    public void setVisible(boolean visible) {\n        if (uiWinMgr != null) {\n            uiWinMgr.setVisible(this, visible);\n        } else {\n            overlay.setVisible(visible);\n        }\n    }\n\n    public void setWindowManager(UIWindowManager mgr) {\n        this.uiWinMgr = mgr;\n    }\n\n    public Node getRoot() {\n        return overlay.getRoot();\n    }\n\n    public void getSize(Dimension dim) {\n        overlay.getSize(dim);\n    }\n\n    public boolean isOpaque() {\n        return overlay.isOpaque();\n    }\n\n    public void update() {\n        overlay.update();\n    }\n\n    private static FontMetrics getFontMetrics(Font font) {\n        GraphicsEnvironment env = GraphicsEnvironment.getLocalGraphicsEnvironment();\n        GraphicsDevice dev = env.getDefaultScreenDevice();\n        GraphicsConfiguration cfg = dev.getDefaultConfiguration();\n        Graphics2D g = cfg.createCompatibleImage(1, 1).createGraphics();\n        return g.getFontMetrics(font);\n    }\n}\n\nclass NodeTextOverlay extends TextOverlay implements NodeOverlay {\n\n    private Canvas3D canvas;\n\n    private Node node;\n\n    NodeTextOverlay(Node node) {\n        this(node, node.getName());\n    }\n\n    NodeTextOverlay(Node node, String text) {\n        super(text);\n        this.node = node;\n    }\n\n    public void update() {\n        BoundingSphere sphere = (BoundingSphere) node.getBounds();\n        javax.vecmath.Point3f q = sphere.getCenter();\n        q.y = 0.6f;\n        node.getLocalToVworld().transform(q);\n        q = Util3D.toScreen(canvas, q);\n        setPosition((int) q.x, (int) q.y);\n        if (node instanceof Actor) {\n            if (((Actor) node).dead)\n                setPosition(1000, 1000);\n        }\n        super.update();\n    }\n\n    public void setCanvas(Canvas3D canvas) {\n        this.canvas = canvas;\n    }\n}\n\nclass ImageOverlay implements Overlay {\n\n    private Graphics2D gfx;\n\n    private BufferedImage image;\n\n    private UIOverlay overlay;\n\n    private UIWindowManager uiWinMgr;\n\n    public ImageOverlay() {\n    }\n\n    public ImageOverlay(BufferedImage img) {\n        setImage(img);\n    }\n\n    public void setImage(BufferedImage img) {\n        overlay = new UIOverlay(img.getWidth(), img.getHeight(), true, false);\n        overlay.setBackgroundMode(UIOverlay.BACKGROUND_COPY);\n        image = overlay.getBackgroundImage();\n        overlay.setBackgroundImage(img);\n        gfx = image.createGraphics();\n        gfx.drawImage(img, null, 0, 0);\n        if (uiWinMgr != null) {\n            uiWinMgr.removeOverlay(this);\n            uiWinMgr.addOverlay(this);\n        }\n        //\toverlay.repaint();\n    }\n\n    public BufferedImage getImage() {\n        return image;\n    }\n\n    public Graphics2D getGraphics() {\n        return gfx;\n    }\n\n    public void setPosition(int x, int y) {\n        if (uiWinMgr != null) {\n            uiWinMgr.setPosition(this, x - image.getWidth() / 2, y - image.getHeight() / 2);\n        } else {\n            overlay.setPosition(x, y);\n        }\n    }\n\n    public void setWindowManager(UIWindowManager mgr) {\n        this.uiWinMgr = mgr;\n    }\n\n    public Node getRoot() {\n        return overlay.getRoot();\n    }\n\n    public void getSize(Dimension dim) {\n        overlay.getSize(dim);\n    }\n\n    public boolean isOpaque() {\n        return overlay.isOpaque();\n    }\n\n    public void update() {\n        overlay.update();\n    }\n}\n\nclass NodeImageOverlay extends ImageOverlay implements NodeOverlay {\n\n    private Node node;\n\n    private Canvas3D canvas;\n\n    public NodeImageOverlay(Node node, BufferedImage img) {\n        super(img);\n        this.node = node;\n    }\n\n    public void update() {\n        BoundingSphere sphere = (BoundingSphere) node.getBounds();\n        Point3f q = sphere.getCenter();\n        q.y = sphere.getRadius();\n        node.getLocalToVworld().transform(q);\n        q = Util3D.toScreen(canvas, q);\n        setPosition((int) q.x, (int) q.y);\n        super.update();\n    }\n\n    public void setCanvas(Canvas3D canvas) {\n        this.canvas = canvas;\n    }\n}\n\ninterface Overlay extends UIOverlayInterface {\n\n    public void setWindowManager(UIWindowManager mgr);\n}\n\ninterface NodeOverlay extends Overlay {\n\n    public void setCanvas(Canvas3D canvas);\n}\n\nclass HudOverlay extends UIOverlay implements UIOverlayInterface {\n\n    HudOverlay(int w, int h, boolean clip, boolean blend) {\n        super(w, h, clip, blend);\n    }\n\n    public void paint(Graphics2D g) {\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/HeadUpDisplayTest.java",
		"test_prompt": "// HeadUpDisplayTest.java\npackage gui.gl;\n\nimport com.xith3d.scenegraph.Node;\nimport com.xith3d.scenegraph.BoundingSphere;\nimport com.xith3d.scenegraph.Canvas3D;\nimport com.xith3d.scenegraph.Shape3D;\nimport com.xith3d.userinterface.UIOverlay;\nimport com.xith3d.userinterface.UIOverlayInterface;\nimport com.xith3d.userinterface.UIWindow;\nimport com.xith3d.userinterface.UIWindowManager;\nimport com.xith3d.userinterface.UIPositionedWindow;\nimport javax.vecmath.Point3f;\nimport java.awt.Font;\nimport java.awt.FontMetrics;\nimport java.awt.Graphics2D;\nimport java.awt.GraphicsConfiguration;\nimport java.awt.GraphicsDevice;\nimport java.awt.GraphicsEnvironment;\nimport java.awt.image.BufferedImage;\nimport java.awt.Dimension;\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.BorderLayout;\nimport javax.swing.JTextArea;\nimport javax.swing.JPanel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HeadUpDisplay}.\n* It contains ten unit test cases for the {@link HeadUpDisplay#addOverlay(UIOverlayInterface)} method.\n*/\nclass HeadUpDisplayTest {"
	},
	{
		"original_code": "// ParticleSystem.java\n/* $Id: ParticleSystem.java,v 1.6 2004/05/05 11:55:12 emill Exp $\n *\n *\n * @author Emil Lundstr�m <emill@kth.se>\n */\npackage gui.gl;\n\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.datatypes.*;\nimport com.xith3d.loaders.texture.TextureLoader;\nimport com.xith3d.image.*;\nimport java.util.Random;\nimport javax.imageio.ImageIO;\nimport java.io.File;\nimport java.io.IOException;\nimport java.awt.image.BufferedImage;\n\n/**\n * A particle system in the partice engine. One particle system is the\n * same as one source of particles, e.g. one puff of smoke, one\n * explosion, etc.\n */\npublic class ParticleSystem extends TransformGroup {\n\n    private ParticleManager manager;\n\n    private int particle_count;\n\n    private Particle[] particles;\n\n    private Shape3D shape;\n\n    // this is used to build a shape3d\n    private TriangleStripArray particleGeometry;\n\n    // facing stuff for each particle\n    Coord3f[] sharedGeometryData = { new Coord3f(-1.0f, -1.0f, 0.0f), new Coord3f(1.0f, -1.0f, 0.0f), new Coord3f(-1.0f, 1.0f, 0.0f), new Coord3f(1.0f, 1.0f, 0.0f) };\n\n    // default geometry data, used only to recalculate\n    // sharedGeometryData when billboarding\n    private static final Coord3f[] defaultGeometryData = { new Coord3f(-1.0f, -1.0f, 0.0f), new Coord3f(1.0f, -1.0f, 0.0f), new Coord3f(-1.0f, 1.0f, 0.0f), new Coord3f(1.0f, 1.0f, 0.0f) };\n\n    private TexCoord2f[] sharedTextureData = { new TexCoord2f(0, 0), new TexCoord2f(1, 0), new TexCoord2f(0, 1), new TexCoord2f(1, 1) };\n\n    // holds geometry coords for all particles (4 for each)\n    private Point3f[] geometryCoordinates;\n\n    private Color4f[] appearanceColors;\n\n    // particle system specific data\n    private int lifetime = 100000;\n\n    private int age = 0;\n\n    private int type = 0;\n\n    public static final int TYPE_FLAME = 0;\n\n    public static final int TYPE_SMOKE = 1;\n\n    public static final int TYPE_EXPLOSION = 2;\n\n    public static final int TYPE_MUZZLE = 3;\n\n    public static final int TYPE_BLOOD = 4;\n\n    public static final int TYPE_SUPERNOVA = 5;\n\n    // IMPORTANT: Update this if another system type is added.\n    static final int PARTICLE_SYSTEM_COUNT = 6;\n\n    // default values for newly spawned particles for this particle\n    // system.\n    private Coord3f particleSpawnLocation = new Coord3f();\n\n    private Vector3f particleSpeed = new Vector3f();\n\n    private Vector3f particleAcceleration = new Vector3f();\n\n    private Color4f particleColor = new Color4f();\n\n    private int particleLifetime = 0;\n\n    private float particleFadeSpeed = 1f;\n\n    // values used by the particles of this system\n    public float particleSpeedRandomness = 0f;\n\n    public float particleAccelerationRandomness = 0f;\n\n    public float particleLocationRandomness = 0.1f;\n\n    public float particleLifetimeRandomness = 0.1f;\n\n    public float particleSize = 1f;\n\n    public Random random = new Random();\n\n    /**\n     * Creates a new particle system using the given preset.\n     *\n     * @param m The particle manager.\n     * @param type The preset type for this particle system.\n     * @param loc The world coordinate where new particles spawn.\n     * @param pc Number of particles.\n     * @param lt The lifetime of this system.\n     */\n    public ParticleSystem(ParticleManager m, int t, Coord3f loc, int pc, int lt) {\n        particle_count = pc;\n        manager = m;\n        setUpSystem();\n        newSystem(t, loc, lt);\n    }\n\n    /**\n     * Sets up variables for a new system. If an old particle system\n     * needs to be reused, calling this function should be\n     * enough. I.e., there's no need to call setUpSystem().\n     *\n     * @param type The preset type for this particle system.\n     * @param loc The world coordinate where new particles spawn.\n     * @param lt The lifetime of this system.\n     */\n    public void newSystem(int t, Coord3f loc, int lt) {\n        setTranslation(loc);\n        lifetime = lt;\n        age = 0;\n        type = t;\n        switch(type) {\n            case TYPE_FLAME:\n                particleSpawnLocation.set(0f, 0f, 0f);\n                particleSpeed.set(0f, 0.03f, 0f);\n                particleAcceleration.set(0f, 0f, 0f);\n                particleColor.set(1f, 0.4f, 0.1f, 1f);\n                particleLifetime = 30;\n                particleFadeSpeed = 1f;\n                particleSize = 0.2f;\n                particleSpeedRandomness = 0.001f;\n                particleAccelerationRandomness = 0f;\n                particleLocationRandomness = 0.05f;\n                particleLifetimeRandomness = 30f;\n                break;\n            case TYPE_BLOOD:\n                particleSpawnLocation.set(0f, 0f, 0f);\n                particleSpeed.set(0f, 0.01f, 0f);\n                particleAcceleration.set(0f, -0.002f, 0f);\n                particleColor.set(0.5f, 0.01f, 0.01f, 1f);\n                particleLifetime = 40;\n                particleFadeSpeed = 2f;\n                particleSize = 0.03f;\n                particleSpeedRandomness = 0f;\n                particleAccelerationRandomness = 0f;\n                particleLocationRandomness = 0.01f;\n                particleLifetimeRandomness = 30f;\n                break;\n            case TYPE_MUZZLE:\n                particleSpawnLocation.set(0f, 0f, 0f);\n                particleSpeed.set(0f, 0.01f, 0f);\n                particleAcceleration.set(0f, -0.001f, 0f);\n                particleColor.set(0.7f, 0.4f, 0.03f, 1f);\n                particleLifetime = 5;\n                particleFadeSpeed = 1f;\n                particleSize = 0.03f;\n                particleSpeedRandomness = 0.01f;\n                particleAccelerationRandomness = 0f;\n                particleLocationRandomness = 0.01f;\n                particleLifetimeRandomness = 0f;\n                break;\n            case TYPE_SMOKE:\n                particleSpawnLocation.set(0f, 0f, 0f);\n                particleSpeed.set(0f, 0.02f, 0f);\n                particleAcceleration.set(0f, 0f, 0f);\n                particleColor.set(0.1f, 0.1f, 0.1f, 1f);\n                particleLifetime = 150;\n                particleFadeSpeed = 1f;\n                particleSize = 0.4f;\n                particleSpeedRandomness = 0.001f;\n                particleAccelerationRandomness = 0f;\n                particleLocationRandomness = 0.001f;\n                particleLifetimeRandomness = 150f;\n                break;\n            case TYPE_EXPLOSION:\n                particleSpawnLocation.set(0f, 0f, 0f);\n                particleSpeed.set(0f, 0f, 0f);\n                particleAcceleration.set(0f, 0f, 0f);\n                particleColor.set(0.5f, 0.3f, 0.1f, 1f);\n                particleLifetime = 100;\n                particleFadeSpeed = 0.5f;\n                particleSize = 0.1f;\n                particleSpeedRandomness = 0f;\n                particleAccelerationRandomness = 0.1f;\n                particleLocationRandomness = 0.02f;\n                particleLifetimeRandomness = 0f;\n                break;\n            case TYPE_SUPERNOVA:\n                particleSpeed.set(0f, 0f, 0f);\n                particleAcceleration.set(0f, 0f, 0f);\n                particleColor.set(0.8f, 0.8f, 0.6f, 1f);\n                particleLifetime = 200;\n                particleFadeSpeed = 1f;\n                particleSize = 5f;\n                particleSpeedRandomness = 0f;\n                particleAccelerationRandomness = 0.1f;\n                particleLocationRandomness = 0.5f;\n                particleLifetimeRandomness = 0f;\n                break;\n        }\n        updateAllParticles();\n    }\n\n    /**\n     * Sets this particle system's translation.\n     */\n    public void setTranslation(Vector3f loc) {\n        Transform3D t = new Transform3D();\n        t.setTranslation(loc);\n        setTransform(t);\n    }\n\n    /**\n     * Returns this particle system's type.\n     */\n    public int getType() {\n        return type;\n    }\n\n    /**\n     * Returns the number of particles in this particle system.\n     */\n    public int getParticleCount() {\n        return particle_count;\n    }\n\n    private void setUpSystem() {\n        // set up so each triangle strip consists of 4 vertice, i.e.\n        // two triangles.\n        int[] strips = new int[particle_count];\n        for (int i = 0; i < particle_count; i++) {\n            strips[i] = 4;\n        }\n        particles = new Particle[particle_count];\n        geometryCoordinates = new Point3f[particle_count * 4];\n        appearanceColors = new Color4f[particle_count * 4];\n        // borrowed from javacooldude's particle engine example.\n        // creates a trianglestriparray with 4 vertice per particle\n        particleGeometry = new TriangleStripArray(particle_count * 4, GeometryArray.TEXTURE_COORDINATE_2 | GeometryArray.COORDINATES | GeometryArray.COLOR_4, strips);\n        particleGeometry.setCapability(GeometryArray.ALLOW_COORDINATE_WRITE);\n        particleGeometry.setCapability(GeometryArray.ALLOW_COLOR_WRITE);\n        createShape3D();\n    }\n\n    /**\n     * Returns a Shape3D object for the particles in this particle\n     * system.\n     */\n    private void createShape3D() {\n        ParticleAppearanceManager am = new ParticleAppearanceManager(\"./dat/gfx/star2.png\");\n        shape = new Shape3D(particleGeometry, am.texturedAppearance);\n        addChild(shape);\n    }\n\n    private void updateAllParticles() {\n        for (int i = 0; i < particle_count; i++) {\n            particles[i] = new Particle();\n            particles[i].newParticle(this, particleSpawnLocation, particleSpeed, particleAcceleration, particleColor, particleLifetime, particleFadeSpeed);\n            for (int j = 0; j < 4; j++) {\n                particleGeometry.setTextureCoordinate(0, i * 4 + j, sharedTextureData[j]);\n                geometryCoordinates[i * 4 + j] = particles[i].particleCoordinates[j];\n                appearanceColors[i * 4 + j] = particles[i].color;\n            }\n            particles[i].updateParticle();\n        }\n    }\n\n    /**\n     * Makes the particles in this particle system face the correct\n     * way. The correct way in this system is a plane perpendicular to\n     * the camera direction vector, i.e. the particles use the same\n     * transform as the camera.\n     *\n     * @param camera The camera transform.\n     */\n    public void billboardParticles(Transform3D camera) {\n        Transform3D t = new Transform3D(camera);\n        t.setTranslation(new Vector3f(0f, 0f, 0f));\n        for (int i = 0; i < 4; i++) {\n            sharedGeometryData[i].set(defaultGeometryData[i]);\n            t.transform(sharedGeometryData[i]);\n        }\n    }\n\n    /**\n     * Updates this system and all particles in it.\n     */\n    public boolean updateSystem(Transform3D c) {\n        for (int i = 0; i < particle_count; i++) {\n            if (!particles[i].updateParticle()) {\n                particles[i].newParticle(this, particleSpawnLocation, particleSpeed, particleAcceleration, particleColor, particleLifetime, particleFadeSpeed);\n            }\n        }\n        particleGeometry.setCoordinates(0, geometryCoordinates);\n        particleGeometry.setColors(0, appearanceColors);\n        billboardParticles(c);\n        if (lifetime == 0 || age++ < lifetime)\n            return true;\n        return false;\n    }\n\n    private static class ParticleAppearanceManager {\n\n        public TransparencyAttributes transparencyAttributes = new TransparencyAttributes();\n\n        public RenderingAttributes renderingAttributes = new RenderingAttributes();\n\n        public TextureAttributes textureAttributes = new TextureAttributes();\n\n        public Appearance texturedAppearance = new Appearance();\n\n        public Texture2D texture;\n\n        /**\n         * Creates a new appearance manager for particle systems.\n         *\n         * @param textureFilename The initial texture file name.\n         */\n        public ParticleAppearanceManager(String textureFilename) {\n            renderingAttributes.setDepthBufferEnable(false);\n            transparencyAttributes.setTransparencyMode(transparencyAttributes.BLENDED);\n            transparencyAttributes.setTransparency(0);\n            transparencyAttributes.setDstBlendFunction(transparencyAttributes.BLEND_ONE);\n            transparencyAttributes.setSrcBlendFunction(transparencyAttributes.BLEND_SRC_ALPHA);\n            textureAttributes.setTextureMode(TextureAttributes.MODULATE);\n            textureAttributes.setPerspectiveCorrectionMode(TextureAttributes.FASTEST);\n            texturedAppearance.setTransparencyAttributes(transparencyAttributes);\n            texturedAppearance.setRenderingAttributes(renderingAttributes);\n            texturedAppearance.setTextureAttributes(textureAttributes);\n            loadTexture(textureFilename);\n        }\n\n        /**\n         * Loads a texture to this manager's texturedAppearance.\n         *\n         * @param textureFilename Path to the texture file image.\n         */\n        public void loadTexture(String textureFilename) {\n            File textureFile = new File(textureFilename);\n            BufferedImage textureImage = null;\n            try {\n                textureImage = ImageIO.read(textureFile);\n                texture = (Texture2D) TextureLoader.getInstance().constructTexture(DirectBufferedImage.make(textureImage, false), \"RGB\", false, Texture.BASE_LEVEL_LINEAR, Texture.BASE_LEVEL_LINEAR, Texture.WRAP, false, TextureLoader.SCALE_DRAW_BEST);\n                texturedAppearance.setTexture(texture);\n            } catch (IOException e) {\n                System.err.println(\"error loading texture\");\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/ParticleSystemTest.java",
		"test_prompt": "// ParticleSystemTest.java\npackage gui.gl;\n\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.datatypes.*;\nimport com.xith3d.loaders.texture.TextureLoader;\nimport com.xith3d.image.*;\nimport java.util.Random;\nimport javax.imageio.ImageIO;\nimport java.io.File;\nimport java.io.IOException;\nimport java.awt.image.BufferedImage;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ParticleSystem}.\n* It contains ten unit test cases for the {@link ParticleSystem#updateSystem(Transform3D)} method.\n*/\nclass ParticleSystemTest {"
	},
	{
		"original_code": "// Particle.java\n/* $Id: Particle.java,v 1.1 2004/04/25 15:05:31 emill Exp $\n *\n *\n * @author Emil Lundstr�m <emill@kth.se>\n */\npackage gui.gl;\n\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.datatypes.*;\n\n/**\n * A single particle in the particle engine.\n */\npublic class Particle {\n\n    /**\n     * The particle location in the world.\n     */\n    Coord3f location = new Coord3f();\n\n    /**\n     * The particle speed.\n     */\n    Vector3f speed = new Vector3f();\n\n    /**\n     * The particle acceleration.\n     */\n    Vector3f acceleration = new Vector3f();\n\n    /**\n     * The particle color.\n     */\n    Color4f color = new Color4f();\n\n    Point3f[] particleCoordinates = { new Point3f(), new Point3f(), new Point3f(), new Point3f() };\n\n    /**\n     * The total lifetime of this particle.\n     */\n    private int lifetime = 1;\n\n    /**\n     * The speed that this particle fades away with. A high value\n     *        makes it fade away slow at first, then quickly in the end. A\n     *        value of one makes it fade away linearly.\n     */\n    private float fadeSpeed = 1f;\n\n    /**\n     * The age of this particle.\n     */\n    private int age = 0;\n\n    private ParticleSystem system;\n\n    private static Coord3f randomPoint = new Coord3f();\n\n    /**\n     * Creates a new particle. Its parameters are all set to zero.\n     */\n    public Particle() {\n    }\n\n    /**\n     * Creates a new particle and sets its parameters to the passed\n     * arguments.\n     *\n     * @see newParticle()\n     */\n    public Particle(ParticleSystem m, Coord3f l, Vector3f s, Vector3f a, Color4f c, int lt, float fs) {\n        newParticle(m, l, s, a, c, lt, fs);\n    }\n\n    /**\n     * Sets this particle to a new particle, for re-usability.\n     *\n     * @param m The parent particle system for this particle.\n     * @param l The location of the particle.\n     * @param s The speed vector of the particle.\n     * @param a The acceleration vector of the particle.\n     * @param c The color of the particle.\n     * @param lt The lifetime, in update ticks, of the particle.\n     */\n    public void newParticle(ParticleSystem m, Coord3f l, Vector3f s, Vector3f a, Color4f c, int lt, float fs) {\n        system = m;\n        location.set(l);\n        speed.set(s);\n        acceleration.set(a);\n        color.set(c);\n        lifetime = lt + (int) (system.particleLifetimeRandomness * (system.random.nextFloat() - 0.5f));\n        fadeSpeed = fs;\n        age = 0;\n        updateParticleLocation();\n        addRandomness(speed, system.particleSpeedRandomness);\n        addRandomness(acceleration, system.particleAccelerationRandomness);\n    }\n\n    private void addRandomness(Tuple3f point, float scale) {\n        randomPoint.set(system.random.nextFloat() - 0.5f, system.random.nextFloat() - 0.5f, system.random.nextFloat() - 0.5f);\n        randomPoint.scale(scale);\n        point.add(randomPoint);\n    }\n\n    /**\n     * Executes one update on this particle by updating its speed,\n     * location and color. To be called once every update tick from\n     * the state loop.\n     *\n     * @return true if particle is still alive. false otherwise.\n     */\n    public boolean updateParticle() {\n        speed.add(acceleration);\n        location.add(speed);\n        addRandomness(location, system.particleLocationRandomness);\n        updateParticleLocation();\n        age++;\n        color.w = 1f - (float) Math.pow(age / (float) lifetime, fadeSpeed);\n        if (age < lifetime)\n            return true;\n        return false;\n    }\n\n    public void updateParticleLocation() {\n        for (int i = 0; i < 4; i++) particleCoordinates[i].scaleAdd(system.particleSize, system.sharedGeometryData[i], location);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/ParticleTest.java",
		"test_prompt": "// ParticleTest.java\npackage gui.gl;\n\nimport javax.vecmath.*;\nimport com.xith3d.scenegraph.*;\nimport com.xith3d.datatypes.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Particle}.\n* It contains ten unit test cases for the {@link Particle#updateParticle()} method.\n*/\nclass ParticleTest {"
	},
	{
		"original_code": "// AudioManager.java\npackage gui;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.nio.ByteBuffer;\nimport net.java.games.joal.AL;\nimport net.java.games.joal.ALFactory;\nimport net.java.games.joal.util.ALut;\nimport net.java.games.joal.OpenALException;\nimport java.util.Hashtable;\n\npublic class AudioManager {\n\n    private boolean ready = false;\n\n    private boolean initialized;\n\n    private static AL al;\n\n    private Hashtable handles;\n\n    private int nSamples;\n\n    // Buffers hold sound data.\n    private static int[] buffers = new int[128];\n\n    // Sources are points emitting sound.\n    private static int[] source = new int[128];\n\n    // Position of the source sound.\n    // Velocity of the source sound.\n    private static float[] sourceVel = { 0.0f, 0.0f, 0.0f };\n\n    private float[] listenerPos = { .0f, 0.0f, 0.0f };\n\n    // Velocity of the listener.\n    private static float[] listenerVel = { 0.0f, 0.0f, 0.0f };\n\n    // Orientation of the listener. (first 3 elems are \"at\", second 3 are \"up\")\n    private static float[] listenerOri = { 0.0f, 0.0f, -1.0f, 0.0f, 1.0f, 0.0f };\n\n    public boolean loadSample(String filename, String handle, boolean loops) {\n        if (ready) {\n            if (handles.containsKey(handle)) {\n                System.out.println(\"AudioManager: handle exists\");\n                return false;\n            }\n            // variables to load into\n            int[] format = new int[1];\n            int[] size = new int[1];\n            ByteBuffer[] data = new ByteBuffer[1];\n            int[] freq = new int[1];\n            int[] loop = new int[1];\n            // Load wav data into a buffer.\n            ALut.alutLoadWAVFile(filename, format, data, size, freq, loop);\n            al.alBufferData(buffers[nSamples], format[0], data[0], size[0], freq[0]);\n            ALut.alutUnloadWAV(format[0], data[0], size[0], freq[0]);\n            // Bind buffer with a source.\n            if (al.alGetError() != AL.AL_NO_ERROR) {\n                System.out.println(\"AudioManager: Couldn't create sources\");\n                return false;\n            }\n            float[] sourcePos = { ((float) Math.random() % 4.0f - 2.0f), ((float) Math.random() % 4.0f - 2.0f), ((float) Math.random() % 4.0f - 2.0f) };\n            al.alSourcei(source[nSamples], AL.AL_BUFFER, buffers[nSamples]);\n            al.alSourcef(source[nSamples], AL.AL_PITCH, 1.0f);\n            al.alSourcef(source[nSamples], AL.AL_GAIN, 1.0f);\n            al.alSourcefv(source[nSamples], AL.AL_POSITION, sourcePos);\n            al.alSourcefv(source[nSamples], AL.AL_VELOCITY, sourceVel);\n            if (loops) {\n                al.alSourcei(source[nSamples], AL.AL_LOOPING, AL.AL_TRUE);\n            } else {\n                al.alSourcei(source[nSamples], AL.AL_LOOPING, AL.AL_FALSE);\n            }\n            // Do another error check and return.\n            int i = al.alGetError();\n            if (i == AL.AL_NO_ERROR) {\n                System.out.println(\"AudioManager: All ok\");\n                handles.put(handle, new Integer(nSamples));\n                nSamples++;\n                ready = true;\n                return true;\n            }\n            System.out.println(\"LoadSample, error: \" + i);\n            System.out.println(AL.AL_INVALID_OPERATION);\n            System.out.println(AL.AL_OUT_OF_MEMORY);\n            System.out.println(AL.AL_INVALID_VALUE);\n            System.out.println(al.AL_INVALID_NAME);\n        }\n        return false;\n    }\n\n    public void setEnabled(boolean b) {\n        ready = b;\n    }\n\n    private void setListenerValues() {\n        if (ready) {\n            al.alListenerfv(AL.AL_POSITION, listenerPos);\n            al.alListenerfv(AL.AL_VELOCITY, listenerVel);\n            al.alListenerfv(AL.AL_ORIENTATION, listenerOri);\n        }\n    }\n\n    public void killAllData() {\n        if (initialized) {\n            al.alDeleteBuffers(128, buffers);\n            al.alDeleteSources(128, source);\n            ALut.alutExit();\n        }\n    }\n\n    public AudioManager() {\n        this(true);\n    }\n\n    public AudioManager(boolean b) {\n        if (b) {\n            initialized = false;\n            try {\n                al = ALFactory.getAL();\n                ALut.alutInit();\n                al.alGetError();\n                initialized = true;\n            } catch (OpenALException e) {\n                e.printStackTrace();\n                //System.exit(1);\n            }\n            al.alGenBuffers(128, buffers);\n            al.alGenSources(32, source);\n            handles = new Hashtable();\n            nSamples = 0;\n            setListenerValues();\n            ready = true;\n        }\n    }\n\n    public void play(String handle) {\n        if (ready && handles.containsKey(handle)) {\n            Integer i = (Integer) handles.get(handle);\n            System.out.println(\"playing: \" + i);\n            al.alSourcePlay(source[i.intValue()]);\n        }\n    }\n\n    public void stop(String handle) {\n        if (ready && handles.containsKey(handle)) {\n            Integer i = (Integer) handles.get(handle);\n            al.alSourceStop(source[i.intValue()]);\n        }\n    }\n\n    public void moveListener(float x, float y, float z) {\n        if (ready) {\n            al.alListener3f(al.AL_POSITION, x, y, z);\n            al.alListener3f(AL.AL_VELOCITY, 0, 0, 0);\n            al.alListenerfv(AL.AL_ORIENTATION, listenerOri);\n        }\n    }\n\n    public boolean moveSource(String handle, float x, float y, float z) {\n        if (ready && handles.containsKey(handle)) {\n            Integer i = (Integer) handles.get(handle);\n            al.alSource3f(source[i.intValue()], AL.AL_POSITION, x, y, z);\n            return true;\n        }\n        return false;\n    }\n    /*    public static void main(String argv[]) {\n\tBufferedReader input = \n\t    new BufferedReader(new InputStreamReader(System.in));\n\n\tAudioManager a = new AudioManager();\n\tif(!a.loadSample(\"test.wav\", \"test\", false)) {\n\n\t    System.out.println(\"error\");\n\t    a.killAllData();\n\t    System.exit(0);\n\t    \n\t}\n\tif(!a.loadSample(\"hit.wav\", \"test2\", false)) {\n\n\t    System.out.println(\"error2\");\n\t    a.killAllData();\n\t    System.exit(0);\n\t    \n\t}\n\tif(!a.loadSample(\"test2.wav\", \"ambient\", true)) {\n\n\t    System.out.println(\"error3\");\n\t    a.killAllData();\n\t    System.exit(0);\n\t    \n\t}\n\tif(!a.loadSample(\"test3.wav\", \"test3\", false)) {\n\n\t    System.out.println(\"error4\");\n\t    a.killAllData();\n\t    System.exit(0);\n\t    \n\t}\n\tif(!a.loadSample(\"test4.wav\", \"test4\", false)) {\n\n\t    System.out.println(\"error5\");\n\t    a.killAllData();\n\t    System.exit(0);\n\t    \n\t}\n\ta.play(\"ambient\");\n\ta.play(\"test\");\n\tString s = \"\";\n\tfloat t = 0;\n\tfloat u = 0;\n\tt += .01;\n\tu += .01;\n\ttry {\n\t    while(!s.equals(\"q\")) {\n\t\t\n\t\tCharacter c = new Character((char)input.read());\n\t\ts = c.toString();\n\t\tif (s.equals(\"w\")) {\n\t\t    t += .5;\n\t\t    a.moveListener(u,t,0);\n\t\t}\n\t\tif (s.equals(\"s\")) {\n\t\t    t -= .5;\n\t\t    a.moveListener(u,t,0);\n\t\t}\n\t\tif (s.equals(\"a\")) {\n\t\t    u -= .5;\n\t\t    a.moveListener(u,t,0);\n\t\t}\n\t\tif (s.equals(\"d\")) {\n\t\t    u += .5;\n\t\t    a.moveListener(u,t,0);\n\t\t}\n\t\tif (s.equals(\"u\")) {\n\t\t    a.play(\"test\");\n\t\t}\n\t\tif (s.equals(\"i\")) {\n\t\t    a.play(\"test2\");\n\t\t}\n\t\tif (s.equals(\"o\")) {\n\t\t    a.play(\"test3\");\n\t\t}\n\t\tif (s.equals(\"p\")) {\n\t\t    a.play(\"test4\");\n\t\t}\n\t\t//System.out.println(\"S: \" + s + \";\");\n\t    }\n\t} catch (Exception e) { \n\t    a.killAllData(); \n\t    System.exit(0);\n\t    \n\t}\n\t\n\ta.killAllData();\n\tSystem.exit(0);\n    }*/\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/gui/AudioManagerTest0.java",
		"test_prompt": "// AudioManagerTest0.java\npackage gui;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.nio.ByteBuffer;\nimport net.java.games.joal.AL;\nimport net.java.games.joal.ALFactory;\nimport net.java.games.joal.util.ALut;\nimport net.java.games.joal.OpenALException;\nimport java.util.Hashtable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AudioManager}.\n* It contains ten unit test cases for the {@link AudioManager#loadSample(String, String, boolean)} method.\n*/\nclass AudioManagerTest0 {"
	},
	{
		"original_code": "// AudioManager.java\npackage gui;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.nio.ByteBuffer;\nimport net.java.games.joal.AL;\nimport net.java.games.joal.ALFactory;\nimport net.java.games.joal.util.ALut;\nimport net.java.games.joal.OpenALException;\nimport java.util.Hashtable;\n\npublic class AudioManager {\n\n    private boolean ready = false;\n\n    private boolean initialized;\n\n    private static AL al;\n\n    private Hashtable handles;\n\n    private int nSamples;\n\n    // Buffers hold sound data.\n    private static int[] buffers = new int[128];\n\n    // Sources are points emitting sound.\n    private static int[] source = new int[128];\n\n    // Position of the source sound.\n    // Velocity of the source sound.\n    private static float[] sourceVel = { 0.0f, 0.0f, 0.0f };\n\n    private float[] listenerPos = { .0f, 0.0f, 0.0f };\n\n    // Velocity of the listener.\n    private static float[] listenerVel = { 0.0f, 0.0f, 0.0f };\n\n    // Orientation of the listener. (first 3 elems are \"at\", second 3 are \"up\")\n    private static float[] listenerOri = { 0.0f, 0.0f, -1.0f, 0.0f, 1.0f, 0.0f };\n\n    public boolean loadSample(String filename, String handle, boolean loops) {\n        if (ready) {\n            if (handles.containsKey(handle)) {\n                System.out.println(\"AudioManager: handle exists\");\n                return false;\n            }\n            // variables to load into\n            int[] format = new int[1];\n            int[] size = new int[1];\n            ByteBuffer[] data = new ByteBuffer[1];\n            int[] freq = new int[1];\n            int[] loop = new int[1];\n            // Load wav data into a buffer.\n            ALut.alutLoadWAVFile(filename, format, data, size, freq, loop);\n            al.alBufferData(buffers[nSamples], format[0], data[0], size[0], freq[0]);\n            ALut.alutUnloadWAV(format[0], data[0], size[0], freq[0]);\n            // Bind buffer with a source.\n            if (al.alGetError() != AL.AL_NO_ERROR) {\n                System.out.println(\"AudioManager: Couldn't create sources\");\n                return false;\n            }\n            float[] sourcePos = { ((float) Math.random() % 4.0f - 2.0f), ((float) Math.random() % 4.0f - 2.0f), ((float) Math.random() % 4.0f - 2.0f) };\n            al.alSourcei(source[nSamples], AL.AL_BUFFER, buffers[nSamples]);\n            al.alSourcef(source[nSamples], AL.AL_PITCH, 1.0f);\n            al.alSourcef(source[nSamples], AL.AL_GAIN, 1.0f);\n            al.alSourcefv(source[nSamples], AL.AL_POSITION, sourcePos);\n            al.alSourcefv(source[nSamples], AL.AL_VELOCITY, sourceVel);\n            if (loops) {\n                al.alSourcei(source[nSamples], AL.AL_LOOPING, AL.AL_TRUE);\n            } else {\n                al.alSourcei(source[nSamples], AL.AL_LOOPING, AL.AL_FALSE);\n            }\n            // Do another error check and return.\n            int i = al.alGetError();\n            if (i == AL.AL_NO_ERROR) {\n                System.out.println(\"AudioManager: All ok\");\n                handles.put(handle, new Integer(nSamples));\n                nSamples++;\n                ready = true;\n                return true;\n            }\n            System.out.println(\"LoadSample, error: \" + i);\n            System.out.println(AL.AL_INVALID_OPERATION);\n            System.out.println(AL.AL_OUT_OF_MEMORY);\n            System.out.println(AL.AL_INVALID_VALUE);\n            System.out.println(al.AL_INVALID_NAME);\n        }\n        return false;\n    }\n\n    public void setEnabled(boolean b) {\n        ready = b;\n    }\n\n    private void setListenerValues() {\n        if (ready) {\n            al.alListenerfv(AL.AL_POSITION, listenerPos);\n            al.alListenerfv(AL.AL_VELOCITY, listenerVel);\n            al.alListenerfv(AL.AL_ORIENTATION, listenerOri);\n        }\n    }\n\n    public void killAllData() {\n        if (initialized) {\n            al.alDeleteBuffers(128, buffers);\n            al.alDeleteSources(128, source);\n            ALut.alutExit();\n        }\n    }\n\n    public AudioManager() {\n        this(true);\n    }\n\n    public AudioManager(boolean b) {\n        if (b) {\n            initialized = false;\n            try {\n                al = ALFactory.getAL();\n                ALut.alutInit();\n                al.alGetError();\n                initialized = true;\n            } catch (OpenALException e) {\n                e.printStackTrace();\n                //System.exit(1);\n            }\n            al.alGenBuffers(128, buffers);\n            al.alGenSources(32, source);\n            handles = new Hashtable();\n            nSamples = 0;\n            setListenerValues();\n            ready = true;\n        }\n    }\n\n    public void play(String handle) {\n        if (ready && handles.containsKey(handle)) {\n            Integer i = (Integer) handles.get(handle);\n            System.out.println(\"playing: \" + i);\n            al.alSourcePlay(source[i.intValue()]);\n        }\n    }\n\n    public void stop(String handle) {\n        if (ready && handles.containsKey(handle)) {\n            Integer i = (Integer) handles.get(handle);\n            al.alSourceStop(source[i.intValue()]);\n        }\n    }\n\n    public void moveListener(float x, float y, float z) {\n        if (ready) {\n            al.alListener3f(al.AL_POSITION, x, y, z);\n            al.alListener3f(AL.AL_VELOCITY, 0, 0, 0);\n            al.alListenerfv(AL.AL_ORIENTATION, listenerOri);\n        }\n    }\n\n    public boolean moveSource(String handle, float x, float y, float z) {\n        if (ready && handles.containsKey(handle)) {\n            Integer i = (Integer) handles.get(handle);\n            al.alSource3f(source[i.intValue()], AL.AL_POSITION, x, y, z);\n            return true;\n        }\n        return false;\n    }\n    /*    public static void main(String argv[]) {\n\tBufferedReader input = \n\t    new BufferedReader(new InputStreamReader(System.in));\n\n\tAudioManager a = new AudioManager();\n\tif(!a.loadSample(\"test.wav\", \"test\", false)) {\n\n\t    System.out.println(\"error\");\n\t    a.killAllData();\n\t    System.exit(0);\n\t    \n\t}\n\tif(!a.loadSample(\"hit.wav\", \"test2\", false)) {\n\n\t    System.out.println(\"error2\");\n\t    a.killAllData();\n\t    System.exit(0);\n\t    \n\t}\n\tif(!a.loadSample(\"test2.wav\", \"ambient\", true)) {\n\n\t    System.out.println(\"error3\");\n\t    a.killAllData();\n\t    System.exit(0);\n\t    \n\t}\n\tif(!a.loadSample(\"test3.wav\", \"test3\", false)) {\n\n\t    System.out.println(\"error4\");\n\t    a.killAllData();\n\t    System.exit(0);\n\t    \n\t}\n\tif(!a.loadSample(\"test4.wav\", \"test4\", false)) {\n\n\t    System.out.println(\"error5\");\n\t    a.killAllData();\n\t    System.exit(0);\n\t    \n\t}\n\ta.play(\"ambient\");\n\ta.play(\"test\");\n\tString s = \"\";\n\tfloat t = 0;\n\tfloat u = 0;\n\tt += .01;\n\tu += .01;\n\ttry {\n\t    while(!s.equals(\"q\")) {\n\t\t\n\t\tCharacter c = new Character((char)input.read());\n\t\ts = c.toString();\n\t\tif (s.equals(\"w\")) {\n\t\t    t += .5;\n\t\t    a.moveListener(u,t,0);\n\t\t}\n\t\tif (s.equals(\"s\")) {\n\t\t    t -= .5;\n\t\t    a.moveListener(u,t,0);\n\t\t}\n\t\tif (s.equals(\"a\")) {\n\t\t    u -= .5;\n\t\t    a.moveListener(u,t,0);\n\t\t}\n\t\tif (s.equals(\"d\")) {\n\t\t    u += .5;\n\t\t    a.moveListener(u,t,0);\n\t\t}\n\t\tif (s.equals(\"u\")) {\n\t\t    a.play(\"test\");\n\t\t}\n\t\tif (s.equals(\"i\")) {\n\t\t    a.play(\"test2\");\n\t\t}\n\t\tif (s.equals(\"o\")) {\n\t\t    a.play(\"test3\");\n\t\t}\n\t\tif (s.equals(\"p\")) {\n\t\t    a.play(\"test4\");\n\t\t}\n\t\t//System.out.println(\"S: \" + s + \";\");\n\t    }\n\t} catch (Exception e) { \n\t    a.killAllData(); \n\t    System.exit(0);\n\t    \n\t}\n\t\n\ta.killAllData();\n\tSystem.exit(0);\n    }*/\n}\n",
		"id": "EvoSuiteBenchmark/27_gangup/src/main/java/gui/AudioManagerTest1.java",
		"test_prompt": "// AudioManagerTest1.java\npackage gui;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.nio.ByteBuffer;\nimport net.java.games.joal.AL;\nimport net.java.games.joal.ALFactory;\nimport net.java.games.joal.util.ALut;\nimport net.java.games.joal.OpenALException;\nimport java.util.Hashtable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AudioManager}.\n* It contains ten unit test cases for the {@link AudioManager#moveSource(String, float, float, float)} method.\n*/\nclass AudioManagerTest1 {"
	}
]