[
	{
		"original_code": "// JMCAController.java\n/*\n JMCAController.java\n\n Contains class JMCAController\n JMCAController accepts a filename as input, then calls other classes to\n 1) parse the file and get the Abstract Syntax Tree (AST)\n 2) pass the AST to the cohesion analyzer class\n 3) get the report output from the analyzer\n\n\n CEN4010\n FALL 2005\n GROUP2\n\n Curt Hayashida, Scott Springer, Ian Cole\n\n\n Revision History:\n 10/15/2005 - IC - Quick & Dirty Class Creation for prototype\n 10/24/2005 - IC - First Integration pass with GUI code\n           1) Added to package\n           2) Added comments to the analyze() method\n             based on Scott's early design\n 10/30/2005 - IC - Convert to true MVC (Model-View-Controller) per the grading notes\n      1) Changing from JMCAFrame has a JMCAController to\n       JMCAController (Controller) has a JMCAFrame (View)\n      2) Removed constructor that took filename - unneeded with MVC\n      3) Removed get / set filename - unneeded\n      4) Removed getOutput - unneeded\n      5) Main function now target for application execution\n      6) Main function updated to MVC pattern\n      7) Converted to use JMCAView\n\n 11/13/2005 - SS - Change parser to JMCAParser, analyzer to JMCAAnalyzer\n\n Compilation (from project directory)\n javac -d . *.java\n\n Execution (from top-level project directory)\n java com.soops.CEN4010.JMCA.JMCAController\n\n\n */\npackage com.soops.CEN4010.JMCA;\n\nimport java.io.Reader;\nimport java.io.IOException;\nimport java.io.FileReader;\nimport java.io.File;\nimport java.awt.event.*;\nimport java.awt.Toolkit;\nimport com.soops.CEN4010.JMCA.JParser.parseTest.JMCAParserTestFrame;\nimport javax.swing.tree.DefaultMutableTreeNode;\nimport java.awt.Dimension;\n\n/**\n * <p>Title: Group 2 Project </p>\n *\n * <p>Class: CEN4010 Fall 2005</p>\n *\n * <p>Description: Controller manages subsystems of JMCA </p>\n *\n * <p>Instructor Dr. Stoeklin</p>\n *\n * @author Group 2\n */\npublic class JMCAController {\n\n    private static final boolean DEVELOPMENT = true;\n\n    private static JMCAView view;\n\n    /**\n     * default constructor\n     */\n    JMCAController() {\n    }\n\n    /**\n     *   controls Parser and Analyzer\n     *     analyze will return String with analysis or error text\n     * @return String\n     */\n    public static String analyze(String filename) {\n        /**\n         * implement placeholder implementations of Parser and Analyzer\n         *       Reader rdr = new FileReader (new File (filename));\n         *       ASTNode rootNode = new JMCAParser().parse(rdr);\n         *       output = new JMCAAnalyzer().analyze(rootNode);\n         */\n        if (filename != null && !filename.equals(\"\")) {\n            Reader rdr = null;\n            try {\n                rdr = new FileReader(new File(filename));\n            } catch (IOException ie) {\n                System.err.println(ie.getMessage());\n            }\n            /**\n             * call parser\n             */\n            // ASTNode rootNode = new DummyParser().parse(rdr);\n            ASTNode rootNode = new JMCAParser().parse(rdr);\n            if (DEVELOPMENT && rootNode != null)\n                showTree(rootNode, filename);\n            /**\n             * call analyzer\n             */\n            //  Analyzer analyzer = new UILayoutDisplayAnalyzer();\n            Analyzer analyzer = new JMCAAnalyzer();\n            analyzer.setFileName(filename);\n            return analyzer.analyze(rootNode);\n        }\n        return new String(\"ERROR: Filename not entered.\");\n    }\n\n    //end analyze()\n    private static void showTree(ASTNode tmp, String filename) {\n        DefaultMutableTreeNode rootNode = tmp.createTree();\n        JMCAParserTestFrame frame = new JMCAParserTestFrame(rootNode, filename);\n        frame.validate();\n        // Center the window\n        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n        Dimension frameSize = frame.getSize();\n        if (frameSize.height > screenSize.height) {\n            frameSize.height = screenSize.height;\n        }\n        if (frameSize.width > screenSize.width) {\n            frameSize.width = screenSize.width;\n        }\n        frame.setLocation((screenSize.width - frameSize.width) / 2, (screenSize.height - frameSize.height) / 2);\n        frame.setVisible(true);\n    }\n\n    //main function for JMCA Application\n    public static void main(String[] args) {\n        view = new JMCAView();\n        // in this case our model is the Parser / Analyzer\n        //set action listeners here....\n        view.setAnalyzeListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                view.updateDisplay(analyze(view.getFilename()));\n            }\n        });\n        //end setAnalyzeListener\n        view.setSelectFileListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                view.chooseFile();\n            }\n        });\n        //end setSelectFileListener\n    }\n    //end main\n}\n//end class\n",
		"id": "EvoSuiteBenchmark/19_jmca/src/main/java/com/soops/CEN4010/JMCA/JMCAControllerTest.java",
		"test_prompt": "// JMCAControllerTest.java\npackage com.soops.CEN4010.JMCA;\n\nimport java.io.Reader;\nimport java.io.IOException;\nimport java.io.FileReader;\nimport java.io.File;\nimport java.awt.event.*;\nimport java.awt.Toolkit;\nimport com.soops.CEN4010.JMCA.JParser.parseTest.JMCAParserTestFrame;\nimport javax.swing.tree.DefaultMutableTreeNode;\nimport java.awt.Dimension;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JMCAController}.\n* It contains ten unit test cases for the {@link JMCAController#analyze(String)} method.\n*/\nclass JMCAControllerTest {"
	},
	{
		"original_code": "// ASTNode.java\npackage com.soops.CEN4010.JMCA;\n\nimport java.util.ArrayList;\nimport java.io.*;\nimport javax.swing.tree.DefaultMutableTreeNode;\n\n/**\n * <p>Title: Group 2 Project </p>\n *\n * <p>Class: CEN4010 Fall 2005</p>\n *\n * <p>Description: Data Structure for ASTree Node</p>\n *\n * <p>Instructor Dr. Stoeklin</p>\n *\n * @author Group 2\n */\npublic class ASTNode implements Comparable, java.io.Serializable {\n\n    /**\n     * data of the node\n     */\n    String type = null;\n\n    String identity = null;\n\n    /**\n     * implements Comparable\n     * @param node Object\n     * @return int values 0 for same and 1 for different\n     */\n    public int compareTo(Object node) {\n        if (!type.equals(((ASTNode) node).getType()) || !identity.equals(((ASTNode) node).getIdentity())) {\n            return 1;\n        }\n        for (int i = 0; i < list.size(); ++i) {\n            try {\n                if (list.get(i).compareTo(((ASTNode) node).list.get(i)) == 1) {\n                    return 1;\n                }\n            } catch (IndexOutOfBoundsException ne) {\n                return 1;\n            } catch (NullPointerException np) {\n                return 1;\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * children of the node\n     */\n    //IC - Added the <Object> tags to get rid of warnings...\n    //http://java.sun.com/developer/JDCTechTips/2005/tt0315.html\n    // SS - changed <Object> to <ASTNode> and removed the casts\n    java.util.ArrayList<ASTNode> list = new java.util.ArrayList<ASTNode>();\n\n    /**\n     * parent of the node\n     */\n    ASTNode parent = null;\n\n    /**\n     * add child to node\n     * @param node ASTNode\n     */\n    public void addChild(ASTNode node) {\n        list.add(node);\n    }\n\n    /**\n     * default constructor\n     */\n    public ASTNode() {\n    }\n\n    /**\n     * construct a  node and set its parent\n     * @param p ASTNode\n     */\n    public ASTNode(ASTNode p) {\n        parent = p;\n    }\n\n    /**\n     * construct a node and set data types and parent\n     * @param type String\n     * @param identity String\n     * @param p ASTNode\n     */\n    public ASTNode(String type, String identity, ASTNode p) {\n        parent = p;\n        setType(type);\n        setIdentity(identity);\n    }\n\n    /**\n     * get the parent node\n     * @return ASTNode\n     */\n    public ASTNode getParent() {\n        return parent;\n    }\n\n    /**\n     * set the data element type\n     * @param t String\n     */\n    public void setType(String t) {\n        type = t;\n    }\n\n    /**\n     * set the data type identity\n     * @param id String\n     */\n    public void setIdentity(String id) {\n        identity = id;\n    }\n\n    /**\n     * get the data element type\n     * @return String\n     */\n    public String getType() {\n        return type;\n    }\n\n    /**\n     * get the data element identity\n     * @return String\n     */\n    public String getIdentity() {\n        return identity;\n    }\n\n    /**\n     * concat type and identity\n     * @return String\n     */\n    public String toString() {\n        String returnString = type + \" :: \" + identity;\n        return returnString;\n    }\n\n    /**\n     * display this node and all its children recursively\n     * @param wtr Writer\n     */\n    public void display(Writer wtr) {\n        try {\n            wtr.write(toString());\n        } catch (IOException ie) {\n            System.err.println(ie.getMessage());\n        }\n        int arraySize = list.size();\n        for (int i = 0; i < arraySize; ++i) {\n            try {\n                wtr.write(\"\\n\");\n            } catch (IOException ie) {\n                System.err.println(ie.getMessage());\n            }\n            list.get(i).display(wtr);\n        }\n    }\n\n    /**\n     *  reads the node in from a file\n     * @param filename String\n     * @return ASTNode\n     */\n    public static ASTNode getTree(String filename) {\n        ObjectInputStream rdr = null;\n        ASTNode rootNode = null;\n        try {\n            FileInputStream flstrm = new FileInputStream(new File(filename));\n            rdr = new ObjectInputStream(flstrm);\n            rootNode = (ASTNode) rdr.readObject();\n            rdr.close();\n        } catch (java.io.IOException ie) {\n        } finally {\n            return rootNode;\n        }\n    }\n\n    /**\n     * save the node and its children to disk\n     * @param filename String\n     */\n    public void dump(String filename) {\n        ObjectOutputStream wtr = null;\n        try {\n            FileOutputStream flstrm = new FileOutputStream(new File(filename));\n            wtr = new ObjectOutputStream(flstrm);\n            wtr.writeObject(this);\n            wtr.close();\n        } catch (java.io.IOException ie) {\n        }\n    }\n\n    /**\n     * add this node and recursively all its children to a swing tree structure <br>\n     * used to construct a JTree with the ASTree\n     * @return DefaultMutableTreeNode\n     */\n    public DefaultMutableTreeNode createTree() {\n        javax.swing.tree.DefaultMutableTreeNode node = new DefaultMutableTreeNode(toString());\n        int arraySize = list.size();\n        for (int i = 0; i < arraySize; ++i) {\n            node.add(list.get(i).createTree());\n        }\n        return node;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/19_jmca/src/main/java/com/soops/CEN4010/JMCA/ASTNodeTest0.java",
		"test_prompt": "// ASTNodeTest0.java\npackage com.soops.CEN4010.JMCA;\n\nimport java.util.ArrayList;\nimport java.io.*;\nimport javax.swing.tree.DefaultMutableTreeNode;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ASTNode}.\n* It contains ten unit test cases for the {@link ASTNode#compareTo(Object)} method.\n*/\nclass ASTNodeTest0 {"
	},
	{
		"original_code": "// ASTNode.java\npackage com.soops.CEN4010.JMCA;\n\nimport java.util.ArrayList;\nimport java.io.*;\nimport javax.swing.tree.DefaultMutableTreeNode;\n\n/**\n * <p>Title: Group 2 Project </p>\n *\n * <p>Class: CEN4010 Fall 2005</p>\n *\n * <p>Description: Data Structure for ASTree Node</p>\n *\n * <p>Instructor Dr. Stoeklin</p>\n *\n * @author Group 2\n */\npublic class ASTNode implements Comparable, java.io.Serializable {\n\n    /**\n     * data of the node\n     */\n    String type = null;\n\n    String identity = null;\n\n    /**\n     * implements Comparable\n     * @param node Object\n     * @return int values 0 for same and 1 for different\n     */\n    public int compareTo(Object node) {\n        if (!type.equals(((ASTNode) node).getType()) || !identity.equals(((ASTNode) node).getIdentity())) {\n            return 1;\n        }\n        for (int i = 0; i < list.size(); ++i) {\n            try {\n                if (list.get(i).compareTo(((ASTNode) node).list.get(i)) == 1) {\n                    return 1;\n                }\n            } catch (IndexOutOfBoundsException ne) {\n                return 1;\n            } catch (NullPointerException np) {\n                return 1;\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * children of the node\n     */\n    //IC - Added the <Object> tags to get rid of warnings...\n    //http://java.sun.com/developer/JDCTechTips/2005/tt0315.html\n    // SS - changed <Object> to <ASTNode> and removed the casts\n    java.util.ArrayList<ASTNode> list = new java.util.ArrayList<ASTNode>();\n\n    /**\n     * parent of the node\n     */\n    ASTNode parent = null;\n\n    /**\n     * add child to node\n     * @param node ASTNode\n     */\n    public void addChild(ASTNode node) {\n        list.add(node);\n    }\n\n    /**\n     * default constructor\n     */\n    public ASTNode() {\n    }\n\n    /**\n     * construct a  node and set its parent\n     * @param p ASTNode\n     */\n    public ASTNode(ASTNode p) {\n        parent = p;\n    }\n\n    /**\n     * construct a node and set data types and parent\n     * @param type String\n     * @param identity String\n     * @param p ASTNode\n     */\n    public ASTNode(String type, String identity, ASTNode p) {\n        parent = p;\n        setType(type);\n        setIdentity(identity);\n    }\n\n    /**\n     * get the parent node\n     * @return ASTNode\n     */\n    public ASTNode getParent() {\n        return parent;\n    }\n\n    /**\n     * set the data element type\n     * @param t String\n     */\n    public void setType(String t) {\n        type = t;\n    }\n\n    /**\n     * set the data type identity\n     * @param id String\n     */\n    public void setIdentity(String id) {\n        identity = id;\n    }\n\n    /**\n     * get the data element type\n     * @return String\n     */\n    public String getType() {\n        return type;\n    }\n\n    /**\n     * get the data element identity\n     * @return String\n     */\n    public String getIdentity() {\n        return identity;\n    }\n\n    /**\n     * concat type and identity\n     * @return String\n     */\n    public String toString() {\n        String returnString = type + \" :: \" + identity;\n        return returnString;\n    }\n\n    /**\n     * display this node and all its children recursively\n     * @param wtr Writer\n     */\n    public void display(Writer wtr) {\n        try {\n            wtr.write(toString());\n        } catch (IOException ie) {\n            System.err.println(ie.getMessage());\n        }\n        int arraySize = list.size();\n        for (int i = 0; i < arraySize; ++i) {\n            try {\n                wtr.write(\"\\n\");\n            } catch (IOException ie) {\n                System.err.println(ie.getMessage());\n            }\n            list.get(i).display(wtr);\n        }\n    }\n\n    /**\n     *  reads the node in from a file\n     * @param filename String\n     * @return ASTNode\n     */\n    public static ASTNode getTree(String filename) {\n        ObjectInputStream rdr = null;\n        ASTNode rootNode = null;\n        try {\n            FileInputStream flstrm = new FileInputStream(new File(filename));\n            rdr = new ObjectInputStream(flstrm);\n            rootNode = (ASTNode) rdr.readObject();\n            rdr.close();\n        } catch (java.io.IOException ie) {\n        } finally {\n            return rootNode;\n        }\n    }\n\n    /**\n     * save the node and its children to disk\n     * @param filename String\n     */\n    public void dump(String filename) {\n        ObjectOutputStream wtr = null;\n        try {\n            FileOutputStream flstrm = new FileOutputStream(new File(filename));\n            wtr = new ObjectOutputStream(flstrm);\n            wtr.writeObject(this);\n            wtr.close();\n        } catch (java.io.IOException ie) {\n        }\n    }\n\n    /**\n     * add this node and recursively all its children to a swing tree structure <br>\n     * used to construct a JTree with the ASTree\n     * @return DefaultMutableTreeNode\n     */\n    public DefaultMutableTreeNode createTree() {\n        javax.swing.tree.DefaultMutableTreeNode node = new DefaultMutableTreeNode(toString());\n        int arraySize = list.size();\n        for (int i = 0; i < arraySize; ++i) {\n            node.add(list.get(i).createTree());\n        }\n        return node;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/19_jmca/src/main/java/com/soops/CEN4010/JMCA/ASTNodeTest1.java",
		"test_prompt": "// ASTNodeTest1.java\npackage com.soops.CEN4010.JMCA;\n\nimport java.util.ArrayList;\nimport java.io.*;\nimport javax.swing.tree.DefaultMutableTreeNode;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ASTNode}.\n* It contains ten unit test cases for the {@link ASTNode#getTree(String)} method.\n*/\nclass ASTNodeTest1 {"
	},
	{
		"original_code": "// ASTNode.java\npackage com.soops.CEN4010.JMCA;\n\nimport java.util.ArrayList;\nimport java.io.*;\nimport javax.swing.tree.DefaultMutableTreeNode;\n\n/**\n * <p>Title: Group 2 Project </p>\n *\n * <p>Class: CEN4010 Fall 2005</p>\n *\n * <p>Description: Data Structure for ASTree Node</p>\n *\n * <p>Instructor Dr. Stoeklin</p>\n *\n * @author Group 2\n */\npublic class ASTNode implements Comparable, java.io.Serializable {\n\n    /**\n     * data of the node\n     */\n    String type = null;\n\n    String identity = null;\n\n    /**\n     * implements Comparable\n     * @param node Object\n     * @return int values 0 for same and 1 for different\n     */\n    public int compareTo(Object node) {\n        if (!type.equals(((ASTNode) node).getType()) || !identity.equals(((ASTNode) node).getIdentity())) {\n            return 1;\n        }\n        for (int i = 0; i < list.size(); ++i) {\n            try {\n                if (list.get(i).compareTo(((ASTNode) node).list.get(i)) == 1) {\n                    return 1;\n                }\n            } catch (IndexOutOfBoundsException ne) {\n                return 1;\n            } catch (NullPointerException np) {\n                return 1;\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * children of the node\n     */\n    //IC - Added the <Object> tags to get rid of warnings...\n    //http://java.sun.com/developer/JDCTechTips/2005/tt0315.html\n    // SS - changed <Object> to <ASTNode> and removed the casts\n    java.util.ArrayList<ASTNode> list = new java.util.ArrayList<ASTNode>();\n\n    /**\n     * parent of the node\n     */\n    ASTNode parent = null;\n\n    /**\n     * add child to node\n     * @param node ASTNode\n     */\n    public void addChild(ASTNode node) {\n        list.add(node);\n    }\n\n    /**\n     * default constructor\n     */\n    public ASTNode() {\n    }\n\n    /**\n     * construct a  node and set its parent\n     * @param p ASTNode\n     */\n    public ASTNode(ASTNode p) {\n        parent = p;\n    }\n\n    /**\n     * construct a node and set data types and parent\n     * @param type String\n     * @param identity String\n     * @param p ASTNode\n     */\n    public ASTNode(String type, String identity, ASTNode p) {\n        parent = p;\n        setType(type);\n        setIdentity(identity);\n    }\n\n    /**\n     * get the parent node\n     * @return ASTNode\n     */\n    public ASTNode getParent() {\n        return parent;\n    }\n\n    /**\n     * set the data element type\n     * @param t String\n     */\n    public void setType(String t) {\n        type = t;\n    }\n\n    /**\n     * set the data type identity\n     * @param id String\n     */\n    public void setIdentity(String id) {\n        identity = id;\n    }\n\n    /**\n     * get the data element type\n     * @return String\n     */\n    public String getType() {\n        return type;\n    }\n\n    /**\n     * get the data element identity\n     * @return String\n     */\n    public String getIdentity() {\n        return identity;\n    }\n\n    /**\n     * concat type and identity\n     * @return String\n     */\n    public String toString() {\n        String returnString = type + \" :: \" + identity;\n        return returnString;\n    }\n\n    /**\n     * display this node and all its children recursively\n     * @param wtr Writer\n     */\n    public void display(Writer wtr) {\n        try {\n            wtr.write(toString());\n        } catch (IOException ie) {\n            System.err.println(ie.getMessage());\n        }\n        int arraySize = list.size();\n        for (int i = 0; i < arraySize; ++i) {\n            try {\n                wtr.write(\"\\n\");\n            } catch (IOException ie) {\n                System.err.println(ie.getMessage());\n            }\n            list.get(i).display(wtr);\n        }\n    }\n\n    /**\n     *  reads the node in from a file\n     * @param filename String\n     * @return ASTNode\n     */\n    public static ASTNode getTree(String filename) {\n        ObjectInputStream rdr = null;\n        ASTNode rootNode = null;\n        try {\n            FileInputStream flstrm = new FileInputStream(new File(filename));\n            rdr = new ObjectInputStream(flstrm);\n            rootNode = (ASTNode) rdr.readObject();\n            rdr.close();\n        } catch (java.io.IOException ie) {\n        } finally {\n            return rootNode;\n        }\n    }\n\n    /**\n     * save the node and its children to disk\n     * @param filename String\n     */\n    public void dump(String filename) {\n        ObjectOutputStream wtr = null;\n        try {\n            FileOutputStream flstrm = new FileOutputStream(new File(filename));\n            wtr = new ObjectOutputStream(flstrm);\n            wtr.writeObject(this);\n            wtr.close();\n        } catch (java.io.IOException ie) {\n        }\n    }\n\n    /**\n     * add this node and recursively all its children to a swing tree structure <br>\n     * used to construct a JTree with the ASTree\n     * @return DefaultMutableTreeNode\n     */\n    public DefaultMutableTreeNode createTree() {\n        javax.swing.tree.DefaultMutableTreeNode node = new DefaultMutableTreeNode(toString());\n        int arraySize = list.size();\n        for (int i = 0; i < arraySize; ++i) {\n            node.add(list.get(i).createTree());\n        }\n        return node;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/19_jmca/src/main/java/com/soops/CEN4010/JMCA/ASTNodeTest2.java",
		"test_prompt": "// ASTNodeTest2.java\npackage com.soops.CEN4010.JMCA;\n\nimport java.util.ArrayList;\nimport java.io.*;\nimport javax.swing.tree.DefaultMutableTreeNode;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ASTNode}.\n* It contains ten unit test cases for the {@link ASTNode#createTree()} method.\n*/\nclass ASTNodeTest2 {"
	},
	{
		"original_code": "// JavaCharStream.java\npackage com.soops.CEN4010.JMCA.JParser;\n\n/* Generated By:JavaCC: Do not edit this line. JavaCharStream.java Version 3.0 */\n/**\n * An implementation of interface CharStream, where the stream is assumed to\n * contain only ASCII characters (with java-like unicode escape processing).\n */\npublic class JavaCharStream {\n\n    public static final boolean staticFlag = false;\n\n    static final int hexval(char c) throws java.io.IOException {\n        switch(c) {\n            case '0':\n                return 0;\n            case '1':\n                return 1;\n            case '2':\n                return 2;\n            case '3':\n                return 3;\n            case '4':\n                return 4;\n            case '5':\n                return 5;\n            case '6':\n                return 6;\n            case '7':\n                return 7;\n            case '8':\n                return 8;\n            case '9':\n                return 9;\n            case 'a':\n            case 'A':\n                return 10;\n            case 'b':\n            case 'B':\n                return 11;\n            case 'c':\n            case 'C':\n                return 12;\n            case 'd':\n            case 'D':\n                return 13;\n            case 'e':\n            case 'E':\n                return 14;\n            case 'f':\n            case 'F':\n                return 15;\n        }\n        // Should never come here\n        throw new java.io.IOException();\n    }\n\n    public int bufpos = -1;\n\n    int bufsize;\n\n    int available;\n\n    int tokenBegin;\n\n    protected int[] bufline;\n\n    protected int[] bufcolumn;\n\n    protected int column = 0;\n\n    protected int line = 1;\n\n    protected boolean prevCharIsCR = false;\n\n    protected boolean prevCharIsLF = false;\n\n    protected java.io.Reader inputStream;\n\n    protected char[] nextCharBuf;\n\n    protected char[] buffer;\n\n    protected int maxNextCharInd = 0;\n\n    protected int nextCharInd = -1;\n\n    protected int inBuf = 0;\n\n    protected void ExpandBuff(boolean wrapAround) {\n        char[] newbuffer = new char[bufsize + 2048];\n        int[] newbufline = new int[bufsize + 2048];\n        int[] newbufcolumn = new int[bufsize + 2048];\n        try {\n            if (wrapAround) {\n                System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n                System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos);\n                buffer = newbuffer;\n                System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n                System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);\n                bufline = newbufline;\n                System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n                System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);\n                bufcolumn = newbufcolumn;\n                bufpos += (bufsize - tokenBegin);\n            } else {\n                System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n                buffer = newbuffer;\n                System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n                bufline = newbufline;\n                System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n                bufcolumn = newbufcolumn;\n                bufpos -= tokenBegin;\n            }\n        } catch (Throwable t) {\n            throw new Error(t.getMessage());\n        }\n        available = (bufsize += 2048);\n        tokenBegin = 0;\n    }\n\n    protected void FillBuff() throws java.io.IOException {\n        int i;\n        if (maxNextCharInd == 4096)\n            maxNextCharInd = nextCharInd = 0;\n        try {\n            if ((i = inputStream.read(nextCharBuf, maxNextCharInd, 4096 - maxNextCharInd)) == -1) {\n                inputStream.close();\n                throw new java.io.IOException();\n            } else\n                maxNextCharInd += i;\n            return;\n        } catch (java.io.IOException e) {\n            if (bufpos != 0) {\n                --bufpos;\n                backup(0);\n            } else {\n                bufline[bufpos] = line;\n                bufcolumn[bufpos] = column;\n            }\n            throw e;\n        }\n    }\n\n    protected char ReadByte() throws java.io.IOException {\n        if (++nextCharInd >= maxNextCharInd)\n            FillBuff();\n        return nextCharBuf[nextCharInd];\n    }\n\n    public char BeginToken() throws java.io.IOException {\n        if (inBuf > 0) {\n            --inBuf;\n            if (++bufpos == bufsize)\n                bufpos = 0;\n            tokenBegin = bufpos;\n            return buffer[bufpos];\n        }\n        tokenBegin = 0;\n        bufpos = -1;\n        return readChar();\n    }\n\n    protected void AdjustBuffSize() {\n        if (available == bufsize) {\n            if (tokenBegin > 2048) {\n                bufpos = 0;\n                available = tokenBegin;\n            } else\n                ExpandBuff(false);\n        } else if (available > tokenBegin)\n            available = bufsize;\n        else if ((tokenBegin - available) < 2048)\n            ExpandBuff(true);\n        else\n            available = tokenBegin;\n    }\n\n    protected void UpdateLineColumn(char c) {\n        column++;\n        if (prevCharIsLF) {\n            prevCharIsLF = false;\n            line += (column = 1);\n        } else if (prevCharIsCR) {\n            prevCharIsCR = false;\n            if (c == '\\n') {\n                prevCharIsLF = true;\n            } else\n                line += (column = 1);\n        }\n        switch(c) {\n            case '\\r':\n                prevCharIsCR = true;\n                break;\n            case '\\n':\n                prevCharIsLF = true;\n                break;\n            case '\\t':\n                column--;\n                column += (8 - (column & 07));\n                break;\n            default:\n                break;\n        }\n        bufline[bufpos] = line;\n        bufcolumn[bufpos] = column;\n    }\n\n    public char readChar() throws java.io.IOException {\n        if (inBuf > 0) {\n            --inBuf;\n            if (++bufpos == bufsize)\n                bufpos = 0;\n            return buffer[bufpos];\n        }\n        char c;\n        if (++bufpos == available)\n            AdjustBuffSize();\n        if ((buffer[bufpos] = c = ReadByte()) == '\\\\') {\n            UpdateLineColumn(c);\n            int backSlashCnt = 1;\n            for (; ; ) // Read all the backslashes\n            {\n                if (++bufpos == available)\n                    AdjustBuffSize();\n                try {\n                    if ((buffer[bufpos] = c = ReadByte()) != '\\\\') {\n                        UpdateLineColumn(c);\n                        // found a non-backslash char.\n                        if ((c == 'u') && ((backSlashCnt & 1) == 1)) {\n                            if (--bufpos < 0)\n                                bufpos = bufsize - 1;\n                            break;\n                        }\n                        backup(backSlashCnt);\n                        return '\\\\';\n                    }\n                } catch (java.io.IOException e) {\n                    if (backSlashCnt > 1)\n                        backup(backSlashCnt);\n                    return '\\\\';\n                }\n                UpdateLineColumn(c);\n                backSlashCnt++;\n            }\n            // Here, we have seen an odd number of backslash's followed by a 'u'\n            try {\n                while ((c = ReadByte()) == 'u') ++column;\n                buffer[bufpos] = c = (char) (hexval(c) << 12 | hexval(ReadByte()) << 8 | hexval(ReadByte()) << 4 | hexval(ReadByte()));\n                column += 4;\n            } catch (java.io.IOException e) {\n                throw new Error(\"Invalid escape character at line \" + line + \" column \" + column + \".\");\n            }\n            if (backSlashCnt == 1)\n                return c;\n            else {\n                backup(backSlashCnt - 1);\n                return '\\\\';\n            }\n        } else {\n            UpdateLineColumn(c);\n            return (c);\n        }\n    }\n\n    /**\n     * @deprecated\n     * @see #getEndColumn\n     */\n    public int getColumn() {\n        return bufcolumn[bufpos];\n    }\n\n    /**\n     * @deprecated\n     * @see #getEndLine\n     */\n    public int getLine() {\n        return bufline[bufpos];\n    }\n\n    public int getEndColumn() {\n        return bufcolumn[bufpos];\n    }\n\n    public int getEndLine() {\n        return bufline[bufpos];\n    }\n\n    public int getBeginColumn() {\n        return bufcolumn[tokenBegin];\n    }\n\n    public int getBeginLine() {\n        return bufline[tokenBegin];\n    }\n\n    public void backup(int amount) {\n        inBuf += amount;\n        if ((bufpos -= amount) < 0)\n            bufpos += bufsize;\n    }\n\n    public JavaCharStream(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {\n        inputStream = dstream;\n        line = startline;\n        column = startcolumn - 1;\n        available = bufsize = buffersize;\n        buffer = new char[buffersize];\n        bufline = new int[buffersize];\n        bufcolumn = new int[buffersize];\n        nextCharBuf = new char[4096];\n    }\n\n    public JavaCharStream(java.io.Reader dstream, int startline, int startcolumn) {\n        this(dstream, startline, startcolumn, 4096);\n    }\n\n    public JavaCharStream(java.io.Reader dstream) {\n        this(dstream, 1, 1, 4096);\n    }\n\n    public void ReInit(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {\n        inputStream = dstream;\n        line = startline;\n        column = startcolumn - 1;\n        if (buffer == null || buffersize != buffer.length) {\n            available = bufsize = buffersize;\n            buffer = new char[buffersize];\n            bufline = new int[buffersize];\n            bufcolumn = new int[buffersize];\n            nextCharBuf = new char[4096];\n        }\n        prevCharIsLF = prevCharIsCR = false;\n        tokenBegin = inBuf = maxNextCharInd = 0;\n        nextCharInd = bufpos = -1;\n    }\n\n    public void ReInit(java.io.Reader dstream, int startline, int startcolumn) {\n        ReInit(dstream, startline, startcolumn, 4096);\n    }\n\n    public void ReInit(java.io.Reader dstream) {\n        ReInit(dstream, 1, 1, 4096);\n    }\n\n    public JavaCharStream(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {\n        this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);\n    }\n\n    public JavaCharStream(java.io.InputStream dstream, int startline, int startcolumn) {\n        this(dstream, startline, startcolumn, 4096);\n    }\n\n    public JavaCharStream(java.io.InputStream dstream) {\n        this(dstream, 1, 1, 4096);\n    }\n\n    public void ReInit(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {\n        ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);\n    }\n\n    public void ReInit(java.io.InputStream dstream, int startline, int startcolumn) {\n        ReInit(dstream, startline, startcolumn, 4096);\n    }\n\n    public void ReInit(java.io.InputStream dstream) {\n        ReInit(dstream, 1, 1, 4096);\n    }\n\n    public String GetImage() {\n        if (bufpos >= tokenBegin)\n            return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);\n        else\n            return new String(buffer, tokenBegin, bufsize - tokenBegin) + new String(buffer, 0, bufpos + 1);\n    }\n\n    public char[] GetSuffix(int len) {\n        char[] ret = new char[len];\n        if ((bufpos + 1) >= len)\n            System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);\n        else {\n            System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0, len - bufpos - 1);\n            System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);\n        }\n        return ret;\n    }\n\n    public void Done() {\n        nextCharBuf = null;\n        buffer = null;\n        bufline = null;\n        bufcolumn = null;\n    }\n\n    /**\n     * Method to adjust line and column numbers for the start of a token.\n     */\n    public void adjustBeginLineColumn(int newLine, int newCol) {\n        int start = tokenBegin;\n        int len;\n        if (bufpos >= tokenBegin) {\n            len = bufpos - tokenBegin + inBuf + 1;\n        } else {\n            len = bufsize - tokenBegin + bufpos + 1 + inBuf;\n        }\n        int i = 0, j = 0, k = 0;\n        int nextColDiff = 0, columnDiff = 0;\n        while (i < len && bufline[j = start % bufsize] == bufline[k = ++start % bufsize]) {\n            bufline[j] = newLine;\n            nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];\n            bufcolumn[j] = newCol + columnDiff;\n            columnDiff = nextColDiff;\n            i++;\n        }\n        if (i < len) {\n            bufline[j] = newLine++;\n            bufcolumn[j] = newCol + columnDiff;\n            while (i++ < len) {\n                if (bufline[j = start % bufsize] != bufline[++start % bufsize])\n                    bufline[j] = newLine++;\n                else\n                    bufline[j] = newLine;\n            }\n        }\n        line = bufline[j];\n        column = bufcolumn[j];\n    }\n}\n",
		"id": "EvoSuiteBenchmark/19_jmca/src/main/java/com/soops/CEN4010/JMCA/JParser/JavaCharStreamTest0.java",
		"test_prompt": "// JavaCharStreamTest0.java\npackage com.soops.CEN4010.JMCA.JParser;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JavaCharStream}.\n* It contains ten unit test cases for the {@link JavaCharStream#BeginToken()} method.\n*/\nclass JavaCharStreamTest0 {"
	},
	{
		"original_code": "// JavaCharStream.java\npackage com.soops.CEN4010.JMCA.JParser;\n\n/* Generated By:JavaCC: Do not edit this line. JavaCharStream.java Version 3.0 */\n/**\n * An implementation of interface CharStream, where the stream is assumed to\n * contain only ASCII characters (with java-like unicode escape processing).\n */\npublic class JavaCharStream {\n\n    public static final boolean staticFlag = false;\n\n    static final int hexval(char c) throws java.io.IOException {\n        switch(c) {\n            case '0':\n                return 0;\n            case '1':\n                return 1;\n            case '2':\n                return 2;\n            case '3':\n                return 3;\n            case '4':\n                return 4;\n            case '5':\n                return 5;\n            case '6':\n                return 6;\n            case '7':\n                return 7;\n            case '8':\n                return 8;\n            case '9':\n                return 9;\n            case 'a':\n            case 'A':\n                return 10;\n            case 'b':\n            case 'B':\n                return 11;\n            case 'c':\n            case 'C':\n                return 12;\n            case 'd':\n            case 'D':\n                return 13;\n            case 'e':\n            case 'E':\n                return 14;\n            case 'f':\n            case 'F':\n                return 15;\n        }\n        // Should never come here\n        throw new java.io.IOException();\n    }\n\n    public int bufpos = -1;\n\n    int bufsize;\n\n    int available;\n\n    int tokenBegin;\n\n    protected int[] bufline;\n\n    protected int[] bufcolumn;\n\n    protected int column = 0;\n\n    protected int line = 1;\n\n    protected boolean prevCharIsCR = false;\n\n    protected boolean prevCharIsLF = false;\n\n    protected java.io.Reader inputStream;\n\n    protected char[] nextCharBuf;\n\n    protected char[] buffer;\n\n    protected int maxNextCharInd = 0;\n\n    protected int nextCharInd = -1;\n\n    protected int inBuf = 0;\n\n    protected void ExpandBuff(boolean wrapAround) {\n        char[] newbuffer = new char[bufsize + 2048];\n        int[] newbufline = new int[bufsize + 2048];\n        int[] newbufcolumn = new int[bufsize + 2048];\n        try {\n            if (wrapAround) {\n                System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n                System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos);\n                buffer = newbuffer;\n                System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n                System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);\n                bufline = newbufline;\n                System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n                System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);\n                bufcolumn = newbufcolumn;\n                bufpos += (bufsize - tokenBegin);\n            } else {\n                System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n                buffer = newbuffer;\n                System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n                bufline = newbufline;\n                System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n                bufcolumn = newbufcolumn;\n                bufpos -= tokenBegin;\n            }\n        } catch (Throwable t) {\n            throw new Error(t.getMessage());\n        }\n        available = (bufsize += 2048);\n        tokenBegin = 0;\n    }\n\n    protected void FillBuff() throws java.io.IOException {\n        int i;\n        if (maxNextCharInd == 4096)\n            maxNextCharInd = nextCharInd = 0;\n        try {\n            if ((i = inputStream.read(nextCharBuf, maxNextCharInd, 4096 - maxNextCharInd)) == -1) {\n                inputStream.close();\n                throw new java.io.IOException();\n            } else\n                maxNextCharInd += i;\n            return;\n        } catch (java.io.IOException e) {\n            if (bufpos != 0) {\n                --bufpos;\n                backup(0);\n            } else {\n                bufline[bufpos] = line;\n                bufcolumn[bufpos] = column;\n            }\n            throw e;\n        }\n    }\n\n    protected char ReadByte() throws java.io.IOException {\n        if (++nextCharInd >= maxNextCharInd)\n            FillBuff();\n        return nextCharBuf[nextCharInd];\n    }\n\n    public char BeginToken() throws java.io.IOException {\n        if (inBuf > 0) {\n            --inBuf;\n            if (++bufpos == bufsize)\n                bufpos = 0;\n            tokenBegin = bufpos;\n            return buffer[bufpos];\n        }\n        tokenBegin = 0;\n        bufpos = -1;\n        return readChar();\n    }\n\n    protected void AdjustBuffSize() {\n        if (available == bufsize) {\n            if (tokenBegin > 2048) {\n                bufpos = 0;\n                available = tokenBegin;\n            } else\n                ExpandBuff(false);\n        } else if (available > tokenBegin)\n            available = bufsize;\n        else if ((tokenBegin - available) < 2048)\n            ExpandBuff(true);\n        else\n            available = tokenBegin;\n    }\n\n    protected void UpdateLineColumn(char c) {\n        column++;\n        if (prevCharIsLF) {\n            prevCharIsLF = false;\n            line += (column = 1);\n        } else if (prevCharIsCR) {\n            prevCharIsCR = false;\n            if (c == '\\n') {\n                prevCharIsLF = true;\n            } else\n                line += (column = 1);\n        }\n        switch(c) {\n            case '\\r':\n                prevCharIsCR = true;\n                break;\n            case '\\n':\n                prevCharIsLF = true;\n                break;\n            case '\\t':\n                column--;\n                column += (8 - (column & 07));\n                break;\n            default:\n                break;\n        }\n        bufline[bufpos] = line;\n        bufcolumn[bufpos] = column;\n    }\n\n    public char readChar() throws java.io.IOException {\n        if (inBuf > 0) {\n            --inBuf;\n            if (++bufpos == bufsize)\n                bufpos = 0;\n            return buffer[bufpos];\n        }\n        char c;\n        if (++bufpos == available)\n            AdjustBuffSize();\n        if ((buffer[bufpos] = c = ReadByte()) == '\\\\') {\n            UpdateLineColumn(c);\n            int backSlashCnt = 1;\n            for (; ; ) // Read all the backslashes\n            {\n                if (++bufpos == available)\n                    AdjustBuffSize();\n                try {\n                    if ((buffer[bufpos] = c = ReadByte()) != '\\\\') {\n                        UpdateLineColumn(c);\n                        // found a non-backslash char.\n                        if ((c == 'u') && ((backSlashCnt & 1) == 1)) {\n                            if (--bufpos < 0)\n                                bufpos = bufsize - 1;\n                            break;\n                        }\n                        backup(backSlashCnt);\n                        return '\\\\';\n                    }\n                } catch (java.io.IOException e) {\n                    if (backSlashCnt > 1)\n                        backup(backSlashCnt);\n                    return '\\\\';\n                }\n                UpdateLineColumn(c);\n                backSlashCnt++;\n            }\n            // Here, we have seen an odd number of backslash's followed by a 'u'\n            try {\n                while ((c = ReadByte()) == 'u') ++column;\n                buffer[bufpos] = c = (char) (hexval(c) << 12 | hexval(ReadByte()) << 8 | hexval(ReadByte()) << 4 | hexval(ReadByte()));\n                column += 4;\n            } catch (java.io.IOException e) {\n                throw new Error(\"Invalid escape character at line \" + line + \" column \" + column + \".\");\n            }\n            if (backSlashCnt == 1)\n                return c;\n            else {\n                backup(backSlashCnt - 1);\n                return '\\\\';\n            }\n        } else {\n            UpdateLineColumn(c);\n            return (c);\n        }\n    }\n\n    /**\n     * @deprecated\n     * @see #getEndColumn\n     */\n    public int getColumn() {\n        return bufcolumn[bufpos];\n    }\n\n    /**\n     * @deprecated\n     * @see #getEndLine\n     */\n    public int getLine() {\n        return bufline[bufpos];\n    }\n\n    public int getEndColumn() {\n        return bufcolumn[bufpos];\n    }\n\n    public int getEndLine() {\n        return bufline[bufpos];\n    }\n\n    public int getBeginColumn() {\n        return bufcolumn[tokenBegin];\n    }\n\n    public int getBeginLine() {\n        return bufline[tokenBegin];\n    }\n\n    public void backup(int amount) {\n        inBuf += amount;\n        if ((bufpos -= amount) < 0)\n            bufpos += bufsize;\n    }\n\n    public JavaCharStream(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {\n        inputStream = dstream;\n        line = startline;\n        column = startcolumn - 1;\n        available = bufsize = buffersize;\n        buffer = new char[buffersize];\n        bufline = new int[buffersize];\n        bufcolumn = new int[buffersize];\n        nextCharBuf = new char[4096];\n    }\n\n    public JavaCharStream(java.io.Reader dstream, int startline, int startcolumn) {\n        this(dstream, startline, startcolumn, 4096);\n    }\n\n    public JavaCharStream(java.io.Reader dstream) {\n        this(dstream, 1, 1, 4096);\n    }\n\n    public void ReInit(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {\n        inputStream = dstream;\n        line = startline;\n        column = startcolumn - 1;\n        if (buffer == null || buffersize != buffer.length) {\n            available = bufsize = buffersize;\n            buffer = new char[buffersize];\n            bufline = new int[buffersize];\n            bufcolumn = new int[buffersize];\n            nextCharBuf = new char[4096];\n        }\n        prevCharIsLF = prevCharIsCR = false;\n        tokenBegin = inBuf = maxNextCharInd = 0;\n        nextCharInd = bufpos = -1;\n    }\n\n    public void ReInit(java.io.Reader dstream, int startline, int startcolumn) {\n        ReInit(dstream, startline, startcolumn, 4096);\n    }\n\n    public void ReInit(java.io.Reader dstream) {\n        ReInit(dstream, 1, 1, 4096);\n    }\n\n    public JavaCharStream(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {\n        this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);\n    }\n\n    public JavaCharStream(java.io.InputStream dstream, int startline, int startcolumn) {\n        this(dstream, startline, startcolumn, 4096);\n    }\n\n    public JavaCharStream(java.io.InputStream dstream) {\n        this(dstream, 1, 1, 4096);\n    }\n\n    public void ReInit(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {\n        ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);\n    }\n\n    public void ReInit(java.io.InputStream dstream, int startline, int startcolumn) {\n        ReInit(dstream, startline, startcolumn, 4096);\n    }\n\n    public void ReInit(java.io.InputStream dstream) {\n        ReInit(dstream, 1, 1, 4096);\n    }\n\n    public String GetImage() {\n        if (bufpos >= tokenBegin)\n            return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);\n        else\n            return new String(buffer, tokenBegin, bufsize - tokenBegin) + new String(buffer, 0, bufpos + 1);\n    }\n\n    public char[] GetSuffix(int len) {\n        char[] ret = new char[len];\n        if ((bufpos + 1) >= len)\n            System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);\n        else {\n            System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0, len - bufpos - 1);\n            System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);\n        }\n        return ret;\n    }\n\n    public void Done() {\n        nextCharBuf = null;\n        buffer = null;\n        bufline = null;\n        bufcolumn = null;\n    }\n\n    /**\n     * Method to adjust line and column numbers for the start of a token.\n     */\n    public void adjustBeginLineColumn(int newLine, int newCol) {\n        int start = tokenBegin;\n        int len;\n        if (bufpos >= tokenBegin) {\n            len = bufpos - tokenBegin + inBuf + 1;\n        } else {\n            len = bufsize - tokenBegin + bufpos + 1 + inBuf;\n        }\n        int i = 0, j = 0, k = 0;\n        int nextColDiff = 0, columnDiff = 0;\n        while (i < len && bufline[j = start % bufsize] == bufline[k = ++start % bufsize]) {\n            bufline[j] = newLine;\n            nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];\n            bufcolumn[j] = newCol + columnDiff;\n            columnDiff = nextColDiff;\n            i++;\n        }\n        if (i < len) {\n            bufline[j] = newLine++;\n            bufcolumn[j] = newCol + columnDiff;\n            while (i++ < len) {\n                if (bufline[j = start % bufsize] != bufline[++start % bufsize])\n                    bufline[j] = newLine++;\n                else\n                    bufline[j] = newLine;\n            }\n        }\n        line = bufline[j];\n        column = bufcolumn[j];\n    }\n}\n",
		"id": "EvoSuiteBenchmark/19_jmca/src/main/java/com/soops/CEN4010/JMCA/JParser/JavaCharStreamTest1.java",
		"test_prompt": "// JavaCharStreamTest1.java\npackage com.soops.CEN4010.JMCA.JParser;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JavaCharStream}.\n* It contains ten unit test cases for the {@link JavaCharStream#readChar()} method.\n*/\nclass JavaCharStreamTest1 {"
	},
	{
		"original_code": "// JavaCharStream.java\npackage com.soops.CEN4010.JMCA.JParser;\n\n/* Generated By:JavaCC: Do not edit this line. JavaCharStream.java Version 3.0 */\n/**\n * An implementation of interface CharStream, where the stream is assumed to\n * contain only ASCII characters (with java-like unicode escape processing).\n */\npublic class JavaCharStream {\n\n    public static final boolean staticFlag = false;\n\n    static final int hexval(char c) throws java.io.IOException {\n        switch(c) {\n            case '0':\n                return 0;\n            case '1':\n                return 1;\n            case '2':\n                return 2;\n            case '3':\n                return 3;\n            case '4':\n                return 4;\n            case '5':\n                return 5;\n            case '6':\n                return 6;\n            case '7':\n                return 7;\n            case '8':\n                return 8;\n            case '9':\n                return 9;\n            case 'a':\n            case 'A':\n                return 10;\n            case 'b':\n            case 'B':\n                return 11;\n            case 'c':\n            case 'C':\n                return 12;\n            case 'd':\n            case 'D':\n                return 13;\n            case 'e':\n            case 'E':\n                return 14;\n            case 'f':\n            case 'F':\n                return 15;\n        }\n        // Should never come here\n        throw new java.io.IOException();\n    }\n\n    public int bufpos = -1;\n\n    int bufsize;\n\n    int available;\n\n    int tokenBegin;\n\n    protected int[] bufline;\n\n    protected int[] bufcolumn;\n\n    protected int column = 0;\n\n    protected int line = 1;\n\n    protected boolean prevCharIsCR = false;\n\n    protected boolean prevCharIsLF = false;\n\n    protected java.io.Reader inputStream;\n\n    protected char[] nextCharBuf;\n\n    protected char[] buffer;\n\n    protected int maxNextCharInd = 0;\n\n    protected int nextCharInd = -1;\n\n    protected int inBuf = 0;\n\n    protected void ExpandBuff(boolean wrapAround) {\n        char[] newbuffer = new char[bufsize + 2048];\n        int[] newbufline = new int[bufsize + 2048];\n        int[] newbufcolumn = new int[bufsize + 2048];\n        try {\n            if (wrapAround) {\n                System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n                System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos);\n                buffer = newbuffer;\n                System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n                System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);\n                bufline = newbufline;\n                System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n                System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);\n                bufcolumn = newbufcolumn;\n                bufpos += (bufsize - tokenBegin);\n            } else {\n                System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n                buffer = newbuffer;\n                System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n                bufline = newbufline;\n                System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n                bufcolumn = newbufcolumn;\n                bufpos -= tokenBegin;\n            }\n        } catch (Throwable t) {\n            throw new Error(t.getMessage());\n        }\n        available = (bufsize += 2048);\n        tokenBegin = 0;\n    }\n\n    protected void FillBuff() throws java.io.IOException {\n        int i;\n        if (maxNextCharInd == 4096)\n            maxNextCharInd = nextCharInd = 0;\n        try {\n            if ((i = inputStream.read(nextCharBuf, maxNextCharInd, 4096 - maxNextCharInd)) == -1) {\n                inputStream.close();\n                throw new java.io.IOException();\n            } else\n                maxNextCharInd += i;\n            return;\n        } catch (java.io.IOException e) {\n            if (bufpos != 0) {\n                --bufpos;\n                backup(0);\n            } else {\n                bufline[bufpos] = line;\n                bufcolumn[bufpos] = column;\n            }\n            throw e;\n        }\n    }\n\n    protected char ReadByte() throws java.io.IOException {\n        if (++nextCharInd >= maxNextCharInd)\n            FillBuff();\n        return nextCharBuf[nextCharInd];\n    }\n\n    public char BeginToken() throws java.io.IOException {\n        if (inBuf > 0) {\n            --inBuf;\n            if (++bufpos == bufsize)\n                bufpos = 0;\n            tokenBegin = bufpos;\n            return buffer[bufpos];\n        }\n        tokenBegin = 0;\n        bufpos = -1;\n        return readChar();\n    }\n\n    protected void AdjustBuffSize() {\n        if (available == bufsize) {\n            if (tokenBegin > 2048) {\n                bufpos = 0;\n                available = tokenBegin;\n            } else\n                ExpandBuff(false);\n        } else if (available > tokenBegin)\n            available = bufsize;\n        else if ((tokenBegin - available) < 2048)\n            ExpandBuff(true);\n        else\n            available = tokenBegin;\n    }\n\n    protected void UpdateLineColumn(char c) {\n        column++;\n        if (prevCharIsLF) {\n            prevCharIsLF = false;\n            line += (column = 1);\n        } else if (prevCharIsCR) {\n            prevCharIsCR = false;\n            if (c == '\\n') {\n                prevCharIsLF = true;\n            } else\n                line += (column = 1);\n        }\n        switch(c) {\n            case '\\r':\n                prevCharIsCR = true;\n                break;\n            case '\\n':\n                prevCharIsLF = true;\n                break;\n            case '\\t':\n                column--;\n                column += (8 - (column & 07));\n                break;\n            default:\n                break;\n        }\n        bufline[bufpos] = line;\n        bufcolumn[bufpos] = column;\n    }\n\n    public char readChar() throws java.io.IOException {\n        if (inBuf > 0) {\n            --inBuf;\n            if (++bufpos == bufsize)\n                bufpos = 0;\n            return buffer[bufpos];\n        }\n        char c;\n        if (++bufpos == available)\n            AdjustBuffSize();\n        if ((buffer[bufpos] = c = ReadByte()) == '\\\\') {\n            UpdateLineColumn(c);\n            int backSlashCnt = 1;\n            for (; ; ) // Read all the backslashes\n            {\n                if (++bufpos == available)\n                    AdjustBuffSize();\n                try {\n                    if ((buffer[bufpos] = c = ReadByte()) != '\\\\') {\n                        UpdateLineColumn(c);\n                        // found a non-backslash char.\n                        if ((c == 'u') && ((backSlashCnt & 1) == 1)) {\n                            if (--bufpos < 0)\n                                bufpos = bufsize - 1;\n                            break;\n                        }\n                        backup(backSlashCnt);\n                        return '\\\\';\n                    }\n                } catch (java.io.IOException e) {\n                    if (backSlashCnt > 1)\n                        backup(backSlashCnt);\n                    return '\\\\';\n                }\n                UpdateLineColumn(c);\n                backSlashCnt++;\n            }\n            // Here, we have seen an odd number of backslash's followed by a 'u'\n            try {\n                while ((c = ReadByte()) == 'u') ++column;\n                buffer[bufpos] = c = (char) (hexval(c) << 12 | hexval(ReadByte()) << 8 | hexval(ReadByte()) << 4 | hexval(ReadByte()));\n                column += 4;\n            } catch (java.io.IOException e) {\n                throw new Error(\"Invalid escape character at line \" + line + \" column \" + column + \".\");\n            }\n            if (backSlashCnt == 1)\n                return c;\n            else {\n                backup(backSlashCnt - 1);\n                return '\\\\';\n            }\n        } else {\n            UpdateLineColumn(c);\n            return (c);\n        }\n    }\n\n    /**\n     * @deprecated\n     * @see #getEndColumn\n     */\n    public int getColumn() {\n        return bufcolumn[bufpos];\n    }\n\n    /**\n     * @deprecated\n     * @see #getEndLine\n     */\n    public int getLine() {\n        return bufline[bufpos];\n    }\n\n    public int getEndColumn() {\n        return bufcolumn[bufpos];\n    }\n\n    public int getEndLine() {\n        return bufline[bufpos];\n    }\n\n    public int getBeginColumn() {\n        return bufcolumn[tokenBegin];\n    }\n\n    public int getBeginLine() {\n        return bufline[tokenBegin];\n    }\n\n    public void backup(int amount) {\n        inBuf += amount;\n        if ((bufpos -= amount) < 0)\n            bufpos += bufsize;\n    }\n\n    public JavaCharStream(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {\n        inputStream = dstream;\n        line = startline;\n        column = startcolumn - 1;\n        available = bufsize = buffersize;\n        buffer = new char[buffersize];\n        bufline = new int[buffersize];\n        bufcolumn = new int[buffersize];\n        nextCharBuf = new char[4096];\n    }\n\n    public JavaCharStream(java.io.Reader dstream, int startline, int startcolumn) {\n        this(dstream, startline, startcolumn, 4096);\n    }\n\n    public JavaCharStream(java.io.Reader dstream) {\n        this(dstream, 1, 1, 4096);\n    }\n\n    public void ReInit(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {\n        inputStream = dstream;\n        line = startline;\n        column = startcolumn - 1;\n        if (buffer == null || buffersize != buffer.length) {\n            available = bufsize = buffersize;\n            buffer = new char[buffersize];\n            bufline = new int[buffersize];\n            bufcolumn = new int[buffersize];\n            nextCharBuf = new char[4096];\n        }\n        prevCharIsLF = prevCharIsCR = false;\n        tokenBegin = inBuf = maxNextCharInd = 0;\n        nextCharInd = bufpos = -1;\n    }\n\n    public void ReInit(java.io.Reader dstream, int startline, int startcolumn) {\n        ReInit(dstream, startline, startcolumn, 4096);\n    }\n\n    public void ReInit(java.io.Reader dstream) {\n        ReInit(dstream, 1, 1, 4096);\n    }\n\n    public JavaCharStream(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {\n        this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);\n    }\n\n    public JavaCharStream(java.io.InputStream dstream, int startline, int startcolumn) {\n        this(dstream, startline, startcolumn, 4096);\n    }\n\n    public JavaCharStream(java.io.InputStream dstream) {\n        this(dstream, 1, 1, 4096);\n    }\n\n    public void ReInit(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {\n        ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);\n    }\n\n    public void ReInit(java.io.InputStream dstream, int startline, int startcolumn) {\n        ReInit(dstream, startline, startcolumn, 4096);\n    }\n\n    public void ReInit(java.io.InputStream dstream) {\n        ReInit(dstream, 1, 1, 4096);\n    }\n\n    public String GetImage() {\n        if (bufpos >= tokenBegin)\n            return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);\n        else\n            return new String(buffer, tokenBegin, bufsize - tokenBegin) + new String(buffer, 0, bufpos + 1);\n    }\n\n    public char[] GetSuffix(int len) {\n        char[] ret = new char[len];\n        if ((bufpos + 1) >= len)\n            System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);\n        else {\n            System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0, len - bufpos - 1);\n            System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);\n        }\n        return ret;\n    }\n\n    public void Done() {\n        nextCharBuf = null;\n        buffer = null;\n        bufline = null;\n        bufcolumn = null;\n    }\n\n    /**\n     * Method to adjust line and column numbers for the start of a token.\n     */\n    public void adjustBeginLineColumn(int newLine, int newCol) {\n        int start = tokenBegin;\n        int len;\n        if (bufpos >= tokenBegin) {\n            len = bufpos - tokenBegin + inBuf + 1;\n        } else {\n            len = bufsize - tokenBegin + bufpos + 1 + inBuf;\n        }\n        int i = 0, j = 0, k = 0;\n        int nextColDiff = 0, columnDiff = 0;\n        while (i < len && bufline[j = start % bufsize] == bufline[k = ++start % bufsize]) {\n            bufline[j] = newLine;\n            nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];\n            bufcolumn[j] = newCol + columnDiff;\n            columnDiff = nextColDiff;\n            i++;\n        }\n        if (i < len) {\n            bufline[j] = newLine++;\n            bufcolumn[j] = newCol + columnDiff;\n            while (i++ < len) {\n                if (bufline[j = start % bufsize] != bufline[++start % bufsize])\n                    bufline[j] = newLine++;\n                else\n                    bufline[j] = newLine;\n            }\n        }\n        line = bufline[j];\n        column = bufcolumn[j];\n    }\n}\n",
		"id": "EvoSuiteBenchmark/19_jmca/src/main/java/com/soops/CEN4010/JMCA/JParser/JavaCharStreamTest2.java",
		"test_prompt": "// JavaCharStreamTest2.java\npackage com.soops.CEN4010.JMCA.JParser;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JavaCharStream}.\n* It contains ten unit test cases for the {@link JavaCharStream#GetImage()} method.\n*/\nclass JavaCharStreamTest2 {"
	},
	{
		"original_code": "// JavaCharStream.java\npackage com.soops.CEN4010.JMCA.JParser;\n\n/* Generated By:JavaCC: Do not edit this line. JavaCharStream.java Version 3.0 */\n/**\n * An implementation of interface CharStream, where the stream is assumed to\n * contain only ASCII characters (with java-like unicode escape processing).\n */\npublic class JavaCharStream {\n\n    public static final boolean staticFlag = false;\n\n    static final int hexval(char c) throws java.io.IOException {\n        switch(c) {\n            case '0':\n                return 0;\n            case '1':\n                return 1;\n            case '2':\n                return 2;\n            case '3':\n                return 3;\n            case '4':\n                return 4;\n            case '5':\n                return 5;\n            case '6':\n                return 6;\n            case '7':\n                return 7;\n            case '8':\n                return 8;\n            case '9':\n                return 9;\n            case 'a':\n            case 'A':\n                return 10;\n            case 'b':\n            case 'B':\n                return 11;\n            case 'c':\n            case 'C':\n                return 12;\n            case 'd':\n            case 'D':\n                return 13;\n            case 'e':\n            case 'E':\n                return 14;\n            case 'f':\n            case 'F':\n                return 15;\n        }\n        // Should never come here\n        throw new java.io.IOException();\n    }\n\n    public int bufpos = -1;\n\n    int bufsize;\n\n    int available;\n\n    int tokenBegin;\n\n    protected int[] bufline;\n\n    protected int[] bufcolumn;\n\n    protected int column = 0;\n\n    protected int line = 1;\n\n    protected boolean prevCharIsCR = false;\n\n    protected boolean prevCharIsLF = false;\n\n    protected java.io.Reader inputStream;\n\n    protected char[] nextCharBuf;\n\n    protected char[] buffer;\n\n    protected int maxNextCharInd = 0;\n\n    protected int nextCharInd = -1;\n\n    protected int inBuf = 0;\n\n    protected void ExpandBuff(boolean wrapAround) {\n        char[] newbuffer = new char[bufsize + 2048];\n        int[] newbufline = new int[bufsize + 2048];\n        int[] newbufcolumn = new int[bufsize + 2048];\n        try {\n            if (wrapAround) {\n                System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n                System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos);\n                buffer = newbuffer;\n                System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n                System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);\n                bufline = newbufline;\n                System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n                System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);\n                bufcolumn = newbufcolumn;\n                bufpos += (bufsize - tokenBegin);\n            } else {\n                System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n                buffer = newbuffer;\n                System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n                bufline = newbufline;\n                System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n                bufcolumn = newbufcolumn;\n                bufpos -= tokenBegin;\n            }\n        } catch (Throwable t) {\n            throw new Error(t.getMessage());\n        }\n        available = (bufsize += 2048);\n        tokenBegin = 0;\n    }\n\n    protected void FillBuff() throws java.io.IOException {\n        int i;\n        if (maxNextCharInd == 4096)\n            maxNextCharInd = nextCharInd = 0;\n        try {\n            if ((i = inputStream.read(nextCharBuf, maxNextCharInd, 4096 - maxNextCharInd)) == -1) {\n                inputStream.close();\n                throw new java.io.IOException();\n            } else\n                maxNextCharInd += i;\n            return;\n        } catch (java.io.IOException e) {\n            if (bufpos != 0) {\n                --bufpos;\n                backup(0);\n            } else {\n                bufline[bufpos] = line;\n                bufcolumn[bufpos] = column;\n            }\n            throw e;\n        }\n    }\n\n    protected char ReadByte() throws java.io.IOException {\n        if (++nextCharInd >= maxNextCharInd)\n            FillBuff();\n        return nextCharBuf[nextCharInd];\n    }\n\n    public char BeginToken() throws java.io.IOException {\n        if (inBuf > 0) {\n            --inBuf;\n            if (++bufpos == bufsize)\n                bufpos = 0;\n            tokenBegin = bufpos;\n            return buffer[bufpos];\n        }\n        tokenBegin = 0;\n        bufpos = -1;\n        return readChar();\n    }\n\n    protected void AdjustBuffSize() {\n        if (available == bufsize) {\n            if (tokenBegin > 2048) {\n                bufpos = 0;\n                available = tokenBegin;\n            } else\n                ExpandBuff(false);\n        } else if (available > tokenBegin)\n            available = bufsize;\n        else if ((tokenBegin - available) < 2048)\n            ExpandBuff(true);\n        else\n            available = tokenBegin;\n    }\n\n    protected void UpdateLineColumn(char c) {\n        column++;\n        if (prevCharIsLF) {\n            prevCharIsLF = false;\n            line += (column = 1);\n        } else if (prevCharIsCR) {\n            prevCharIsCR = false;\n            if (c == '\\n') {\n                prevCharIsLF = true;\n            } else\n                line += (column = 1);\n        }\n        switch(c) {\n            case '\\r':\n                prevCharIsCR = true;\n                break;\n            case '\\n':\n                prevCharIsLF = true;\n                break;\n            case '\\t':\n                column--;\n                column += (8 - (column & 07));\n                break;\n            default:\n                break;\n        }\n        bufline[bufpos] = line;\n        bufcolumn[bufpos] = column;\n    }\n\n    public char readChar() throws java.io.IOException {\n        if (inBuf > 0) {\n            --inBuf;\n            if (++bufpos == bufsize)\n                bufpos = 0;\n            return buffer[bufpos];\n        }\n        char c;\n        if (++bufpos == available)\n            AdjustBuffSize();\n        if ((buffer[bufpos] = c = ReadByte()) == '\\\\') {\n            UpdateLineColumn(c);\n            int backSlashCnt = 1;\n            for (; ; ) // Read all the backslashes\n            {\n                if (++bufpos == available)\n                    AdjustBuffSize();\n                try {\n                    if ((buffer[bufpos] = c = ReadByte()) != '\\\\') {\n                        UpdateLineColumn(c);\n                        // found a non-backslash char.\n                        if ((c == 'u') && ((backSlashCnt & 1) == 1)) {\n                            if (--bufpos < 0)\n                                bufpos = bufsize - 1;\n                            break;\n                        }\n                        backup(backSlashCnt);\n                        return '\\\\';\n                    }\n                } catch (java.io.IOException e) {\n                    if (backSlashCnt > 1)\n                        backup(backSlashCnt);\n                    return '\\\\';\n                }\n                UpdateLineColumn(c);\n                backSlashCnt++;\n            }\n            // Here, we have seen an odd number of backslash's followed by a 'u'\n            try {\n                while ((c = ReadByte()) == 'u') ++column;\n                buffer[bufpos] = c = (char) (hexval(c) << 12 | hexval(ReadByte()) << 8 | hexval(ReadByte()) << 4 | hexval(ReadByte()));\n                column += 4;\n            } catch (java.io.IOException e) {\n                throw new Error(\"Invalid escape character at line \" + line + \" column \" + column + \".\");\n            }\n            if (backSlashCnt == 1)\n                return c;\n            else {\n                backup(backSlashCnt - 1);\n                return '\\\\';\n            }\n        } else {\n            UpdateLineColumn(c);\n            return (c);\n        }\n    }\n\n    /**\n     * @deprecated\n     * @see #getEndColumn\n     */\n    public int getColumn() {\n        return bufcolumn[bufpos];\n    }\n\n    /**\n     * @deprecated\n     * @see #getEndLine\n     */\n    public int getLine() {\n        return bufline[bufpos];\n    }\n\n    public int getEndColumn() {\n        return bufcolumn[bufpos];\n    }\n\n    public int getEndLine() {\n        return bufline[bufpos];\n    }\n\n    public int getBeginColumn() {\n        return bufcolumn[tokenBegin];\n    }\n\n    public int getBeginLine() {\n        return bufline[tokenBegin];\n    }\n\n    public void backup(int amount) {\n        inBuf += amount;\n        if ((bufpos -= amount) < 0)\n            bufpos += bufsize;\n    }\n\n    public JavaCharStream(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {\n        inputStream = dstream;\n        line = startline;\n        column = startcolumn - 1;\n        available = bufsize = buffersize;\n        buffer = new char[buffersize];\n        bufline = new int[buffersize];\n        bufcolumn = new int[buffersize];\n        nextCharBuf = new char[4096];\n    }\n\n    public JavaCharStream(java.io.Reader dstream, int startline, int startcolumn) {\n        this(dstream, startline, startcolumn, 4096);\n    }\n\n    public JavaCharStream(java.io.Reader dstream) {\n        this(dstream, 1, 1, 4096);\n    }\n\n    public void ReInit(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {\n        inputStream = dstream;\n        line = startline;\n        column = startcolumn - 1;\n        if (buffer == null || buffersize != buffer.length) {\n            available = bufsize = buffersize;\n            buffer = new char[buffersize];\n            bufline = new int[buffersize];\n            bufcolumn = new int[buffersize];\n            nextCharBuf = new char[4096];\n        }\n        prevCharIsLF = prevCharIsCR = false;\n        tokenBegin = inBuf = maxNextCharInd = 0;\n        nextCharInd = bufpos = -1;\n    }\n\n    public void ReInit(java.io.Reader dstream, int startline, int startcolumn) {\n        ReInit(dstream, startline, startcolumn, 4096);\n    }\n\n    public void ReInit(java.io.Reader dstream) {\n        ReInit(dstream, 1, 1, 4096);\n    }\n\n    public JavaCharStream(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {\n        this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);\n    }\n\n    public JavaCharStream(java.io.InputStream dstream, int startline, int startcolumn) {\n        this(dstream, startline, startcolumn, 4096);\n    }\n\n    public JavaCharStream(java.io.InputStream dstream) {\n        this(dstream, 1, 1, 4096);\n    }\n\n    public void ReInit(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {\n        ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);\n    }\n\n    public void ReInit(java.io.InputStream dstream, int startline, int startcolumn) {\n        ReInit(dstream, startline, startcolumn, 4096);\n    }\n\n    public void ReInit(java.io.InputStream dstream) {\n        ReInit(dstream, 1, 1, 4096);\n    }\n\n    public String GetImage() {\n        if (bufpos >= tokenBegin)\n            return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);\n        else\n            return new String(buffer, tokenBegin, bufsize - tokenBegin) + new String(buffer, 0, bufpos + 1);\n    }\n\n    public char[] GetSuffix(int len) {\n        char[] ret = new char[len];\n        if ((bufpos + 1) >= len)\n            System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);\n        else {\n            System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0, len - bufpos - 1);\n            System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);\n        }\n        return ret;\n    }\n\n    public void Done() {\n        nextCharBuf = null;\n        buffer = null;\n        bufline = null;\n        bufcolumn = null;\n    }\n\n    /**\n     * Method to adjust line and column numbers for the start of a token.\n     */\n    public void adjustBeginLineColumn(int newLine, int newCol) {\n        int start = tokenBegin;\n        int len;\n        if (bufpos >= tokenBegin) {\n            len = bufpos - tokenBegin + inBuf + 1;\n        } else {\n            len = bufsize - tokenBegin + bufpos + 1 + inBuf;\n        }\n        int i = 0, j = 0, k = 0;\n        int nextColDiff = 0, columnDiff = 0;\n        while (i < len && bufline[j = start % bufsize] == bufline[k = ++start % bufsize]) {\n            bufline[j] = newLine;\n            nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];\n            bufcolumn[j] = newCol + columnDiff;\n            columnDiff = nextColDiff;\n            i++;\n        }\n        if (i < len) {\n            bufline[j] = newLine++;\n            bufcolumn[j] = newCol + columnDiff;\n            while (i++ < len) {\n                if (bufline[j = start % bufsize] != bufline[++start % bufsize])\n                    bufline[j] = newLine++;\n                else\n                    bufline[j] = newLine;\n            }\n        }\n        line = bufline[j];\n        column = bufcolumn[j];\n    }\n}\n",
		"id": "EvoSuiteBenchmark/19_jmca/src/main/java/com/soops/CEN4010/JMCA/JParser/JavaCharStreamTest3.java",
		"test_prompt": "// JavaCharStreamTest3.java\npackage com.soops.CEN4010.JMCA.JParser;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JavaCharStream}.\n* It contains ten unit test cases for the {@link JavaCharStream#GetSuffix(int)} method.\n*/\nclass JavaCharStreamTest3 {"
	},
	{
		"original_code": "// JavaParser.java\npackage com.soops.CEN4010.JMCA.JParser;\n\n/* Generated By:JJTree&JavaCC: Do not edit this line. JavaParser.java */\nimport java.io.*;\n\n/**\n * Grammar to parse Java version 1.5\n * @author Sreenivasa Viswanadha - Simplified and enhanced for 1.5\n */\npublic class JavaParser implements /*@bgen(jjtree)*/\nJavaParserTreeConstants, JavaParserConstants {\n\n    /*@bgen(jjtree)*/\n    JJTJavaParserState jjtree = new JJTJavaParserState();\n\n    /**\n     * Class to hold modifiers.\n     */\n    /**\n     *  currNode is the current node of the tree - it is set in simplenode\n     *   has package access fro ease of use\n     */\n    Node currNode = null;\n\n    // << to do >> cleasn up the remarked out code\n    /**\n     *   nodeIsSet is a flag used to determine which token string value to use\n     */\n    //    boolean nodeIsSet = false;\n    //    public void setNode(boolean condition) {\n    //       nodeIsSet = condition;\n    //   }\n    static public final class ModifierSet {\n\n        /* Definitions of the bits in the modifiers field.  */\n        public static final int PUBLIC = 0x0001;\n\n        public static final int PROTECTED = 0x0002;\n\n        public static final int PRIVATE = 0x0004;\n\n        public static final int ABSTRACT = 0x0008;\n\n        public static final int STATIC = 0x0010;\n\n        public static final int FINAL = 0x0020;\n\n        public static final int SYNCHRONIZED = 0x0040;\n\n        public static final int NATIVE = 0x0080;\n\n        public static final int TRANSIENT = 0x0100;\n\n        public static final int VOLATILE = 0x0200;\n\n        public static final int STRICTFP = 0x1000;\n\n        /**\n         * A set of accessors that indicate whether the specified modifier\n         *            is in the set.\n         */\n        public boolean isPublic(int modifiers) {\n            return (modifiers & PUBLIC) != 0;\n        }\n\n        public boolean isProtected(int modifiers) {\n            return (modifiers & PROTECTED) != 0;\n        }\n\n        public boolean isPrivate(int modifiers) {\n            return (modifiers & PRIVATE) != 0;\n        }\n\n        public boolean isStatic(int modifiers) {\n            return (modifiers & STATIC) != 0;\n        }\n\n        public boolean isAbstract(int modifiers) {\n            return (modifiers & ABSTRACT) != 0;\n        }\n\n        public boolean isFinal(int modifiers) {\n            return (modifiers & FINAL) != 0;\n        }\n\n        public boolean isNative(int modifiers) {\n            return (modifiers & NATIVE) != 0;\n        }\n\n        public boolean isStrictfp(int modifiers) {\n            return (modifiers & STRICTFP) != 0;\n        }\n\n        public boolean isSynchronized(int modifiers) {\n            return (modifiers & SYNCHRONIZED) != 0;\n        }\n\n        public boolean isTransient(int modifiers) {\n            return (modifiers & TRANSIENT) != 0;\n        }\n\n        public boolean isVolatile(int modifiers) {\n            return (modifiers & VOLATILE) != 0;\n        }\n\n        /**\n         * Removes the given modifier.\n         */\n        static int removeModifier(int modifiers, int mod) {\n            return modifiers & ~mod;\n        }\n    }\n\n    public JavaParser(String fileName) {\n        this(System.in);\n        try {\n            ReInit(new FileInputStream(new File(fileName)));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void dump(Writer wtr) {\n        try {\n            ((SimpleNode) this.jjtree.rootNode()).dump(\"root\", wtr);\n        } catch (IOException ie) {\n            System.err.println(ie.getMessage());\n        }\n    }\n\n    public static void main(String[] args) {\n        JavaParser parser = null;\n        //    Writer wtr = new java.io.PrintWriter(System.out);\n        if (args.length == 0) {\n            System.out.println(\"Java Parser Version 1.1:  Reading from standard input . . .\");\n            parser = new JavaParser(System.in);\n        } else if (args.length == 1) {\n            //    System.out.println(\"Java Parser Version 1.1:  Reading from file \" +\n            //                      args[0] + \" . . .\");\n            try {\n                parser = new JavaParser(new java.io.FileInputStream(args[0]));\n            } catch (java.io.FileNotFoundException e) {\n                System.out.println(\"Java Parser Version 1.1:  File \" + args[0] + \" not found.\");\n                return;\n            }\n        } else {\n            System.out.println(\"Java Parser Version 1.1:  Usage is one of:\");\n            System.out.println(\"         java JavaParser < inputfile\");\n            System.out.println(\"OR\");\n            System.out.println(\"         java JavaParser inputfile\");\n            return;\n        }\n        try {\n            parser.CompilationUnit();\n            Writer wtr = new PrintWriter(System.out);\n            wtr.write(\"<?xml version='1.0' encoding='ISO-8859-1' ?>\");\n            ((SimpleNode) parser.jjtree.rootNode()).dump(\"root\", wtr);\n            //    System.out.println(\n            //           \"Java Parser Version 1.1:  Java program parsed successfully.\");\n        } catch (ParseException e) {\n            System.out.println(e.getMessage());\n            System.out.println(\"Java Parser Version 1.1:  Encountered errors during parse.\");\n        } catch (IOException ie) {\n        }\n    }\n\n    /**\n     * **************************************\n     *  THE JAVA LANGUAGE GRAMMAR STARTS HERE *\n     * ***************************************\n     */\n    /*\n     * Program structuring syntax follows.\n     */\n    final public void CompilationUnit() throws ParseException {\n        /*@bgen(jjtree) CompilationUnit */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTCOMPILATIONUNIT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case PACKAGE:\n                    PackageDeclaration();\n                    break;\n                default:\n                    ;\n            }\n            label_1: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case IMPORT:\n                        ;\n                        break;\n                    default:\n                        break label_1;\n                }\n                ImportDeclaration();\n            }\n            label_2: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case ABSTRACT:\n                    case CLASS:\n                    case ENUM:\n                    case FINAL:\n                    case INTERFACE:\n                    case NATIVE:\n                    case PRIVATE:\n                    case PROTECTED:\n                    case PUBLIC:\n                    case STATIC:\n                    case STRICTFP:\n                    case SYNCHRONIZED:\n                    case TRANSIENT:\n                    case VOLATILE:\n                    case SEMICOLON:\n                    case AT:\n                        ;\n                        break;\n                    default:\n                        break label_2;\n                }\n                TypeDeclaration();\n            }\n            jj_consume_token(0);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void PackageDeclaration() throws ParseException {\n        /*@bgen(jjtree) PackageDeclaration */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTPACKAGEDECLARATION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(PACKAGE);\n            Name();\n            jj_consume_token(SEMICOLON);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ImportDeclaration() throws ParseException {\n        /*@bgen(jjtree) ImportDeclaration */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTIMPORTDECLARATION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(IMPORT);\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case STATIC:\n                    jj_consume_token(STATIC);\n                    break;\n                default:\n                    ;\n            }\n            Name();\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case DOT:\n                    jj_consume_token(DOT);\n                    jj_consume_token(STAR);\n                    break;\n                default:\n                    ;\n            }\n            jj_consume_token(SEMICOLON);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    /*\n     * Modifiers. We match all modifiers in a single rule to reduce the chances of\n     * syntax errors for simple modifier mistakes. It will also enable us to give\n     * better error messages.\n     */\n    final public int Modifiers() throws ParseException {\n        /*@bgen(jjtree) Modifiers */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTMODIFIERS);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        int modifiers = 0;\n        try {\n            label_3: while (true) {\n                if (jj_2_1(2)) {\n                    ;\n                } else {\n                    break label_3;\n                }\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case PUBLIC:\n                        jj_consume_token(PUBLIC);\n                        modifiers |= ModifierSet.PUBLIC;\n                        break;\n                    case STATIC:\n                        jj_consume_token(STATIC);\n                        modifiers |= ModifierSet.STATIC;\n                        break;\n                    case PROTECTED:\n                        jj_consume_token(PROTECTED);\n                        modifiers |= ModifierSet.PROTECTED;\n                        break;\n                    case PRIVATE:\n                        jj_consume_token(PRIVATE);\n                        modifiers |= ModifierSet.PRIVATE;\n                        break;\n                    case FINAL:\n                        jj_consume_token(FINAL);\n                        modifiers |= ModifierSet.FINAL;\n                        break;\n                    case ABSTRACT:\n                        jj_consume_token(ABSTRACT);\n                        modifiers |= ModifierSet.ABSTRACT;\n                        break;\n                    case SYNCHRONIZED:\n                        jj_consume_token(SYNCHRONIZED);\n                        modifiers |= ModifierSet.SYNCHRONIZED;\n                        break;\n                    case NATIVE:\n                        jj_consume_token(NATIVE);\n                        modifiers |= ModifierSet.NATIVE;\n                        break;\n                    case TRANSIENT:\n                        jj_consume_token(TRANSIENT);\n                        modifiers |= ModifierSet.TRANSIENT;\n                        break;\n                    case VOLATILE:\n                        jj_consume_token(VOLATILE);\n                        modifiers |= ModifierSet.VOLATILE;\n                        break;\n                    case STRICTFP:\n                        jj_consume_token(STRICTFP);\n                        modifiers |= ModifierSet.STRICTFP;\n                        break;\n                    case AT:\n                        Annotation();\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n            jjtree.closeNodeScope(jjtn000, true);\n            jjtc000 = false;\n            {\n                if (true) {\n                    return modifiers;\n                }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n        throw new Error(\"Missing return statement in function\");\n    }\n\n    /*\n     * Declaration syntax follows.\n     */\n    final public void TypeDeclaration() throws ParseException {\n        /*@bgen(jjtree) TypeDeclaration */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTTYPEDECLARATION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        int modifiers;\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case SEMICOLON:\n                    jj_consume_token(SEMICOLON);\n                    break;\n                case ABSTRACT:\n                case CLASS:\n                case ENUM:\n                case FINAL:\n                case INTERFACE:\n                case NATIVE:\n                case PRIVATE:\n                case PROTECTED:\n                case PUBLIC:\n                case STATIC:\n                case STRICTFP:\n                case SYNCHRONIZED:\n                case TRANSIENT:\n                case VOLATILE:\n                case AT:\n                    modifiers = Modifiers();\n                    switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                        case CLASS:\n                        case INTERFACE:\n                            ClassOrInterfaceDeclaration(modifiers);\n                            break;\n                        case ENUM:\n                            EnumDeclaration(modifiers);\n                            break;\n                        case AT:\n                            AnnotationTypeDeclaration(modifiers);\n                            break;\n                        default:\n                            jj_consume_token(-1);\n                            throw new ParseException();\n                    }\n                    break;\n                default:\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ClassOrInterfaceDeclaration(int modifiers) throws ParseException {\n        /*@bgen(jjtree) ClassOrInterfaceDeclaration */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTCLASSORINTERFACEDECLARATION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        boolean isInterface = false;\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case CLASS:\n                    jj_consume_token(CLASS);\n                    break;\n                case INTERFACE:\n                    jj_consume_token(INTERFACE);\n                    isInterface = true;\n                    break;\n                default:\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n            jj_consume_token(IDENTIFIER);\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case LT:\n                    TypeParameters();\n                    break;\n                default:\n                    ;\n            }\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case EXTENDS:\n                    ExtendsList(isInterface);\n                    break;\n                default:\n                    ;\n            }\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case IMPLEMENTS:\n                    ImplementsList(isInterface);\n                    break;\n                default:\n                    ;\n            }\n            ClassOrInterfaceBody(isInterface);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ExtendsList(boolean isInterface) throws ParseException {\n        /*@bgen(jjtree) ExtendsList */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTEXTENDSLIST);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        boolean extendsMoreThanOne = false;\n        try {\n            jj_consume_token(EXTENDS);\n            ClassOrInterfaceType();\n            label_4: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case COMMA:\n                        ;\n                        break;\n                    default:\n                        break label_4;\n                }\n                jj_consume_token(COMMA);\n                ClassOrInterfaceType();\n                extendsMoreThanOne = true;\n            }\n            jjtree.closeNodeScope(jjtn000, true);\n            jjtc000 = false;\n            if (extendsMoreThanOne && !isInterface) {\n                if (true) {\n                    throw new ParseException(\"A class cannot extend more than one other class\");\n                }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ImplementsList(boolean isInterface) throws ParseException {\n        /*@bgen(jjtree) ImplementsList */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTIMPLEMENTSLIST);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(IMPLEMENTS);\n            ClassOrInterfaceType();\n            label_5: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case COMMA:\n                        ;\n                        break;\n                    default:\n                        break label_5;\n                }\n                jj_consume_token(COMMA);\n                ClassOrInterfaceType();\n            }\n            jjtree.closeNodeScope(jjtn000, true);\n            jjtc000 = false;\n            if (isInterface) {\n                if (true) {\n                    throw new ParseException(\"An interface cannot implement other interfaces\");\n                }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void EnumDeclaration(int modifiers) throws ParseException {\n        /*@bgen(jjtree) EnumDeclaration */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTENUMDECLARATION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(ENUM);\n            jj_consume_token(IDENTIFIER);\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case IMPLEMENTS:\n                    ImplementsList(false);\n                    break;\n                default:\n                    ;\n            }\n            EnumBody();\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void EnumBody() throws ParseException {\n        /*@bgen(jjtree) EnumBody */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTENUMBODY);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(LBRACE);\n            EnumConstant();\n            label_6: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case COMMA:\n                        ;\n                        break;\n                    default:\n                        break label_6;\n                }\n                jj_consume_token(COMMA);\n                EnumConstant();\n            }\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case SEMICOLON:\n                    jj_consume_token(SEMICOLON);\n                    label_7: while (true) {\n                        switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                            case ABSTRACT:\n                            case BOOLEAN:\n                            case BYTE:\n                            case CHAR:\n                            case CLASS:\n                            case DOUBLE:\n                            case ENUM:\n                            case FINAL:\n                            case FLOAT:\n                            case INT:\n                            case INTERFACE:\n                            case LONG:\n                            case NATIVE:\n                            case PRIVATE:\n                            case PROTECTED:\n                            case PUBLIC:\n                            case SHORT:\n                            case STATIC:\n                            case STRICTFP:\n                            case SYNCHRONIZED:\n                            case TRANSIENT:\n                            case VOID:\n                            case VOLATILE:\n                            case IDENTIFIER:\n                            case LBRACE:\n                            case SEMICOLON:\n                            case AT:\n                            case LT:\n                                ;\n                                break;\n                            default:\n                                break label_7;\n                        }\n                        ClassOrInterfaceBodyDeclaration(false);\n                    }\n                    break;\n                default:\n                    ;\n            }\n            jj_consume_token(RBRACE);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void EnumConstant() throws ParseException {\n        /*@bgen(jjtree) EnumConstant */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTENUMCONSTANT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(IDENTIFIER);\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case LPAREN:\n                    Arguments();\n                    break;\n                default:\n                    ;\n            }\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case LBRACE:\n                    ClassOrInterfaceBody(false);\n                    break;\n                default:\n                    ;\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void TypeParameters() throws ParseException {\n        /*@bgen(jjtree) TypeParameters */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTTYPEPARAMETERS);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(LT);\n            TypeParameter();\n            label_8: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case COMMA:\n                        ;\n                        break;\n                    default:\n                        break label_8;\n                }\n                jj_consume_token(COMMA);\n                TypeParameter();\n            }\n            jj_consume_token(GT);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void TypeParameter() throws ParseException {\n        /*@bgen(jjtree) TypeParameter */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTTYPEPARAMETER);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(IDENTIFIER);\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case EXTENDS:\n                    TypeBound();\n                    break;\n                default:\n                    ;\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void TypeBound() throws ParseException {\n        /*@bgen(jjtree) TypeBound */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTTYPEBOUND);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(EXTENDS);\n            ClassOrInterfaceType();\n            label_9: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case BIT_AND:\n                        ;\n                        break;\n                    default:\n                        break label_9;\n                }\n                jj_consume_token(BIT_AND);\n                ClassOrInterfaceType();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ClassOrInterfaceBody(boolean isInterface) throws ParseException {\n        /*@bgen(jjtree) ClassOrInterfaceBody */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTCLASSORINTERFACEBODY);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(LBRACE);\n            label_10: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case ABSTRACT:\n                    case BOOLEAN:\n                    case BYTE:\n                    case CHAR:\n                    case CLASS:\n                    case DOUBLE:\n                    case ENUM:\n                    case FINAL:\n                    case FLOAT:\n                    case INT:\n                    case INTERFACE:\n                    case LONG:\n                    case NATIVE:\n                    case PRIVATE:\n                    case PROTECTED:\n                    case PUBLIC:\n                    case SHORT:\n                    case STATIC:\n                    case STRICTFP:\n                    case SYNCHRONIZED:\n                    case TRANSIENT:\n                    case VOID:\n                    case VOLATILE:\n                    case IDENTIFIER:\n                    case LBRACE:\n                    case SEMICOLON:\n                    case AT:\n                    case LT:\n                        ;\n                        break;\n                    default:\n                        break label_10;\n                }\n                ClassOrInterfaceBodyDeclaration(isInterface);\n            }\n            jj_consume_token(RBRACE);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ClassOrInterfaceBodyDeclaration(boolean isInterface) throws ParseException {\n        /*@bgen(jjtree) ClassOrInterfaceBodyDeclaration */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTCLASSORINTERFACEBODYDECLARATION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        boolean isNestedInterface = false;\n        int modifiers;\n        try {\n            if (jj_2_4(2)) {\n                Initializer();\n                jjtree.closeNodeScope(jjtn000, true);\n                jjtc000 = false;\n                if (isInterface) {\n                    if (true) {\n                        throw new ParseException(\"An interface cannot have initializers\");\n                    }\n                }\n            } else {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case ABSTRACT:\n                    case BOOLEAN:\n                    case BYTE:\n                    case CHAR:\n                    case CLASS:\n                    case DOUBLE:\n                    case ENUM:\n                    case FINAL:\n                    case FLOAT:\n                    case INT:\n                    case INTERFACE:\n                    case LONG:\n                    case NATIVE:\n                    case PRIVATE:\n                    case PROTECTED:\n                    case PUBLIC:\n                    case SHORT:\n                    case STATIC:\n                    case STRICTFP:\n                    case SYNCHRONIZED:\n                    case TRANSIENT:\n                    case VOID:\n                    case VOLATILE:\n                    case IDENTIFIER:\n                    case AT:\n                    case LT:\n                        modifiers = Modifiers();\n                        switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                            case CLASS:\n                            case INTERFACE:\n                                ClassOrInterfaceDeclaration(modifiers);\n                                break;\n                            case ENUM:\n                                EnumDeclaration(modifiers);\n                                break;\n                            default:\n                                if (jj_2_2(2147483647)) {\n                                    ConstructorDeclaration();\n                                } else if (jj_2_3(2147483647)) {\n                                    FieldDeclaration(modifiers);\n                                } else {\n                                    switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                                        case BOOLEAN:\n                                        case BYTE:\n                                        case CHAR:\n                                        case DOUBLE:\n                                        case FLOAT:\n                                        case INT:\n                                        case LONG:\n                                        case SHORT:\n                                        case VOID:\n                                        case IDENTIFIER:\n                                        case LT:\n                                            MethodDeclaration(modifiers);\n                                            break;\n                                        default:\n                                            jj_consume_token(-1);\n                                            throw new ParseException();\n                                    }\n                                }\n                        }\n                        break;\n                    case SEMICOLON:\n                        jj_consume_token(SEMICOLON);\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void FieldDeclaration(int modifiers) throws ParseException {\n        /*@bgen(jjtree) FieldDeclaration */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTFIELDDECLARATION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            Type();\n            VariableDeclarator();\n            label_11: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case COMMA:\n                        ;\n                        break;\n                    default:\n                        break label_11;\n                }\n                jj_consume_token(COMMA);\n                VariableDeclarator();\n            }\n            jj_consume_token(SEMICOLON);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void VariableDeclarator() throws ParseException {\n        /*@bgen(jjtree) VariableDeclarator */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTVARIABLEDECLARATOR);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            VariableDeclaratorId();\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case ASSIGN:\n                    jj_consume_token(ASSIGN);\n                    VariableInitializer();\n                    break;\n                default:\n                    ;\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void VariableDeclaratorId() throws ParseException {\n        /*@bgen(jjtree) VariableDeclaratorId */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTVARIABLEDECLARATORID);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(IDENTIFIER);\n            label_12: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case LBRACKET:\n                        ;\n                        break;\n                    default:\n                        break label_12;\n                }\n                jj_consume_token(LBRACKET);\n                jj_consume_token(RBRACKET);\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void VariableInitializer() throws ParseException {\n        /*@bgen(jjtree) VariableInitializer */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTVARIABLEINITIALIZER);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case LBRACE:\n                    ArrayInitializer();\n                    break;\n                case BOOLEAN:\n                case BYTE:\n                case CHAR:\n                case DOUBLE:\n                case FALSE:\n                case FLOAT:\n                case INT:\n                case LONG:\n                case NEW:\n                case NULL:\n                case SHORT:\n                case SUPER:\n                case THIS:\n                case TRUE:\n                case VOID:\n                case INTEGER_LITERAL:\n                case FLOATING_POINT_LITERAL:\n                case CHARACTER_LITERAL:\n                case STRING_LITERAL:\n                case IDENTIFIER:\n                case LPAREN:\n                case BANG:\n                case TILDE:\n                case INCR:\n                case DECR:\n                case PLUS:\n                case MINUS:\n                    Expression();\n                    break;\n                default:\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ArrayInitializer() throws ParseException {\n        /*@bgen(jjtree) ArrayInitializer */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTARRAYINITIALIZER);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(LBRACE);\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case BOOLEAN:\n                case BYTE:\n                case CHAR:\n                case DOUBLE:\n                case FALSE:\n                case FLOAT:\n                case INT:\n                case LONG:\n                case NEW:\n                case NULL:\n                case SHORT:\n                case SUPER:\n                case THIS:\n                case TRUE:\n                case VOID:\n                case INTEGER_LITERAL:\n                case FLOATING_POINT_LITERAL:\n                case CHARACTER_LITERAL:\n                case STRING_LITERAL:\n                case IDENTIFIER:\n                case LPAREN:\n                case LBRACE:\n                case BANG:\n                case TILDE:\n                case INCR:\n                case DECR:\n                case PLUS:\n                case MINUS:\n                    VariableInitializer();\n                    label_13: while (true) {\n                        if (jj_2_5(2)) {\n                            ;\n                        } else {\n                            break label_13;\n                        }\n                        jj_consume_token(COMMA);\n                        VariableInitializer();\n                    }\n                    break;\n                default:\n                    ;\n            }\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case COMMA:\n                    jj_consume_token(COMMA);\n                    break;\n                default:\n                    ;\n            }\n            jj_consume_token(RBRACE);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void MethodDeclaration(int modifiers) throws ParseException {\n        /*@bgen(jjtree) MethodDeclaration */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTMETHODDECLARATION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case LT:\n                    TypeParameters();\n                    break;\n                default:\n                    ;\n            }\n            ResultType();\n            MethodDeclarator();\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case THROWS:\n                    jj_consume_token(THROWS);\n                    NameList();\n                    break;\n                default:\n                    ;\n            }\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case LBRACE:\n                    Block();\n                    break;\n                case SEMICOLON:\n                    jj_consume_token(SEMICOLON);\n                    break;\n                default:\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void MethodDeclarator() throws ParseException {\n        /*@bgen(jjtree) MethodDeclarator */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTMETHODDECLARATOR);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(IDENTIFIER);\n            FormalParameters();\n            label_14: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case LBRACKET:\n                        ;\n                        break;\n                    default:\n                        break label_14;\n                }\n                jj_consume_token(LBRACKET);\n                jj_consume_token(RBRACKET);\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void FormalParameters() throws ParseException {\n        /*@bgen(jjtree) FormalParameters */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTFORMALPARAMETERS);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(LPAREN);\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case BOOLEAN:\n                case BYTE:\n                case CHAR:\n                case DOUBLE:\n                case FINAL:\n                case FLOAT:\n                case INT:\n                case LONG:\n                case SHORT:\n                case IDENTIFIER:\n                    FormalParameter();\n                    label_15: while (true) {\n                        switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                            case COMMA:\n                                ;\n                                break;\n                            default:\n                                break label_15;\n                        }\n                        jj_consume_token(COMMA);\n                        FormalParameter();\n                    }\n                    break;\n                default:\n                    ;\n            }\n            jj_consume_token(RPAREN);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void FormalParameter() throws ParseException {\n        /*@bgen(jjtree) FormalParameter */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTFORMALPARAMETER);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case FINAL:\n                    jj_consume_token(FINAL);\n                    break;\n                default:\n                    ;\n            }\n            Type();\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case ELLIPSIS:\n                    jj_consume_token(ELLIPSIS);\n                    break;\n                default:\n                    ;\n            }\n            VariableDeclaratorId();\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ConstructorDeclaration() throws ParseException {\n        /*@bgen(jjtree) ConstructorDeclaration */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTCONSTRUCTORDECLARATION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case LT:\n                    TypeParameters();\n                    break;\n                default:\n                    ;\n            }\n            jj_consume_token(IDENTIFIER);\n            FormalParameters();\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case THROWS:\n                    jj_consume_token(THROWS);\n                    NameList();\n                    break;\n                default:\n                    ;\n            }\n            jj_consume_token(LBRACE);\n            if (jj_2_6(2147483647)) {\n                ExplicitConstructorInvocation();\n            } else {\n                ;\n            }\n            label_16: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case ASSERT:\n                    case BOOLEAN:\n                    case BREAK:\n                    case BYTE:\n                    case CHAR:\n                    case CLASS:\n                    case CONTINUE:\n                    case DO:\n                    case DOUBLE:\n                    case FALSE:\n                    case FINAL:\n                    case FLOAT:\n                    case FOR:\n                    case IF:\n                    case INT:\n                    case INTERFACE:\n                    case LONG:\n                    case NEW:\n                    case NULL:\n                    case RETURN:\n                    case SHORT:\n                    case SUPER:\n                    case SWITCH:\n                    case SYNCHRONIZED:\n                    case THIS:\n                    case THROW:\n                    case TRUE:\n                    case TRY:\n                    case VOID:\n                    case WHILE:\n                    case INTEGER_LITERAL:\n                    case FLOATING_POINT_LITERAL:\n                    case CHARACTER_LITERAL:\n                    case STRING_LITERAL:\n                    case IDENTIFIER:\n                    case LPAREN:\n                    case LBRACE:\n                    case SEMICOLON:\n                    case INCR:\n                    case DECR:\n                        ;\n                        break;\n                    default:\n                        break label_16;\n                }\n                BlockStatement();\n            }\n            jj_consume_token(RBRACE);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ExplicitConstructorInvocation() throws ParseException {\n        /*@bgen(jjtree) ExplicitConstructorInvocation */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTEXPLICITCONSTRUCTORINVOCATION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            if (jj_2_8(2147483647)) {\n                jj_consume_token(THIS);\n                Arguments();\n                jj_consume_token(SEMICOLON);\n            } else {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case BOOLEAN:\n                    case BYTE:\n                    case CHAR:\n                    case DOUBLE:\n                    case FALSE:\n                    case FLOAT:\n                    case INT:\n                    case LONG:\n                    case NEW:\n                    case NULL:\n                    case SHORT:\n                    case SUPER:\n                    case THIS:\n                    case TRUE:\n                    case VOID:\n                    case INTEGER_LITERAL:\n                    case FLOATING_POINT_LITERAL:\n                    case CHARACTER_LITERAL:\n                    case STRING_LITERAL:\n                    case IDENTIFIER:\n                    case LPAREN:\n                        if (jj_2_7(2)) {\n                            PrimaryExpression();\n                            jj_consume_token(DOT);\n                        } else {\n                            ;\n                        }\n                        jj_consume_token(SUPER);\n                        Arguments();\n                        jj_consume_token(SEMICOLON);\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void Initializer() throws ParseException {\n        /*@bgen(jjtree) Initializer */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTINITIALIZER);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case STATIC:\n                    jj_consume_token(STATIC);\n                    break;\n                default:\n                    ;\n            }\n            Block();\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    /*\n     * Type, name and expression syntax follows.\n     */\n    final public void Type() throws ParseException {\n        /*@bgen(jjtree) Type */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTTYPE);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            if (jj_2_9(2)) {\n                ReferenceType();\n            } else {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case BOOLEAN:\n                    case BYTE:\n                    case CHAR:\n                    case DOUBLE:\n                    case FLOAT:\n                    case INT:\n                    case LONG:\n                    case SHORT:\n                        PrimitiveType();\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ReferenceType() throws ParseException {\n        /*@bgen(jjtree) ReferenceType */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTREFERENCETYPE);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case BOOLEAN:\n                case BYTE:\n                case CHAR:\n                case DOUBLE:\n                case FLOAT:\n                case INT:\n                case LONG:\n                case SHORT:\n                    PrimitiveType();\n                    label_17: while (true) {\n                        jj_consume_token(LBRACKET);\n                        jj_consume_token(RBRACKET);\n                        if (jj_2_10(2)) {\n                            ;\n                        } else {\n                            break label_17;\n                        }\n                    }\n                    break;\n                case IDENTIFIER:\n                    ClassOrInterfaceType();\n                    label_18: while (true) {\n                        if (jj_2_11(2)) {\n                            ;\n                        } else {\n                            break label_18;\n                        }\n                        jj_consume_token(LBRACKET);\n                        jj_consume_token(RBRACKET);\n                    }\n                    break;\n                default:\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ClassOrInterfaceType() throws ParseException {\n        /*@bgen(jjtree) ClassOrInterfaceType */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTCLASSORINTERFACETYPE);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(IDENTIFIER);\n            if (jj_2_12(2)) {\n                TypeArguments();\n            } else {\n                ;\n            }\n            label_19: while (true) {\n                if (jj_2_13(2)) {\n                    ;\n                } else {\n                    break label_19;\n                }\n                jj_consume_token(DOT);\n                jj_consume_token(IDENTIFIER);\n                if (jj_2_14(2)) {\n                    TypeArguments();\n                } else {\n                    ;\n                }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void TypeArguments() throws ParseException {\n        /*@bgen(jjtree) TypeArguments */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTTYPEARGUMENTS);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(LT);\n            TypeArgument();\n            label_20: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case COMMA:\n                        ;\n                        break;\n                    default:\n                        break label_20;\n                }\n                jj_consume_token(COMMA);\n                TypeArgument();\n            }\n            jj_consume_token(GT);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void TypeArgument() throws ParseException {\n        /*@bgen(jjtree) TypeArgument */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTTYPEARGUMENT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case BOOLEAN:\n                case BYTE:\n                case CHAR:\n                case DOUBLE:\n                case FLOAT:\n                case INT:\n                case LONG:\n                case SHORT:\n                case IDENTIFIER:\n                    ReferenceType();\n                    break;\n                case HOOK:\n                    jj_consume_token(HOOK);\n                    switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                        case EXTENDS:\n                        case SUPER:\n                            WildcardBounds();\n                            break;\n                        default:\n                            ;\n                    }\n                    break;\n                default:\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void WildcardBounds() throws ParseException {\n        /*@bgen(jjtree) WildcardBounds */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTWILDCARDBOUNDS);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case EXTENDS:\n                    jj_consume_token(EXTENDS);\n                    ReferenceType();\n                    break;\n                case SUPER:\n                    jj_consume_token(SUPER);\n                    ReferenceType();\n                    break;\n                default:\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void PrimitiveType() throws ParseException {\n        /*@bgen(jjtree) PrimitiveType */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTPRIMITIVETYPE);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case BOOLEAN:\n                    jj_consume_token(BOOLEAN);\n                    break;\n                case CHAR:\n                    jj_consume_token(CHAR);\n                    break;\n                case BYTE:\n                    jj_consume_token(BYTE);\n                    break;\n                case SHORT:\n                    jj_consume_token(SHORT);\n                    break;\n                case INT:\n                    jj_consume_token(INT);\n                    break;\n                case LONG:\n                    jj_consume_token(LONG);\n                    break;\n                case FLOAT:\n                    jj_consume_token(FLOAT);\n                    break;\n                case DOUBLE:\n                    jj_consume_token(DOUBLE);\n                    break;\n                default:\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ResultType() throws ParseException {\n        /*@bgen(jjtree) ResultType */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTRESULTTYPE);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case VOID:\n                    jj_consume_token(VOID);\n                    break;\n                case BOOLEAN:\n                case BYTE:\n                case CHAR:\n                case DOUBLE:\n                case FLOAT:\n                case INT:\n                case LONG:\n                case SHORT:\n                case IDENTIFIER:\n                    Type();\n                    break;\n                default:\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void Name() throws ParseException {\n        /*@bgen(jjtree) Name */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTNAME);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(IDENTIFIER);\n            label_21: while (true) {\n                if (jj_2_15(2)) {\n                    ;\n                } else {\n                    break label_21;\n                }\n                jj_consume_token(DOT);\n                jj_consume_token(IDENTIFIER);\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void NameList() throws ParseException {\n        /*@bgen(jjtree) NameList */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTNAMELIST);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            Name();\n            label_22: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case COMMA:\n                        ;\n                        break;\n                    default:\n                        break label_22;\n                }\n                jj_consume_token(COMMA);\n                Name();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    /*\n     * Expression syntax follows.\n     */\n    final public void Expression() throws ParseException {\n        /*@bgen(jjtree) Expression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            ConditionalExpression();\n            if (jj_2_16(2)) {\n                AssignmentOperator();\n                Expression();\n            } else {\n                ;\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void AssignmentOperator() throws ParseException {\n        /*@bgen(jjtree) AssignmentOperator */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTASSIGNMENTOPERATOR);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case ASSIGN:\n                    jj_consume_token(ASSIGN);\n                    break;\n                case STARASSIGN:\n                    jj_consume_token(STARASSIGN);\n                    break;\n                case SLASHASSIGN:\n                    jj_consume_token(SLASHASSIGN);\n                    break;\n                case REMASSIGN:\n                    jj_consume_token(REMASSIGN);\n                    break;\n                case PLUSASSIGN:\n                    jj_consume_token(PLUSASSIGN);\n                    break;\n                case MINUSASSIGN:\n                    jj_consume_token(MINUSASSIGN);\n                    break;\n                case LSHIFTASSIGN:\n                    jj_consume_token(LSHIFTASSIGN);\n                    break;\n                case RSIGNEDSHIFTASSIGN:\n                    jj_consume_token(RSIGNEDSHIFTASSIGN);\n                    break;\n                case RUNSIGNEDSHIFTASSIGN:\n                    jj_consume_token(RUNSIGNEDSHIFTASSIGN);\n                    break;\n                case ANDASSIGN:\n                    jj_consume_token(ANDASSIGN);\n                    break;\n                case XORASSIGN:\n                    jj_consume_token(XORASSIGN);\n                    break;\n                case ORASSIGN:\n                    jj_consume_token(ORASSIGN);\n                    break;\n                default:\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ConditionalExpression() throws ParseException {\n        /*@bgen(jjtree) ConditionalExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTCONDITIONALEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            ConditionalOrExpression();\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case HOOK:\n                    jj_consume_token(HOOK);\n                    Expression();\n                    jj_consume_token(COLON);\n                    Expression();\n                    break;\n                default:\n                    ;\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ConditionalOrExpression() throws ParseException {\n        /*@bgen(jjtree) ConditionalOrExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTCONDITIONALOREXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            ConditionalAndExpression();\n            label_23: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case SC_OR:\n                        ;\n                        break;\n                    default:\n                        break label_23;\n                }\n                jj_consume_token(SC_OR);\n                ConditionalAndExpression();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ConditionalAndExpression() throws ParseException {\n        /*@bgen(jjtree) ConditionalAndExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTCONDITIONALANDEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            InclusiveOrExpression();\n            label_24: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case SC_AND:\n                        ;\n                        break;\n                    default:\n                        break label_24;\n                }\n                jj_consume_token(SC_AND);\n                InclusiveOrExpression();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void InclusiveOrExpression() throws ParseException {\n        /*@bgen(jjtree) InclusiveOrExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTINCLUSIVEOREXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            ExclusiveOrExpression();\n            label_25: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case BIT_OR:\n                        ;\n                        break;\n                    default:\n                        break label_25;\n                }\n                jj_consume_token(BIT_OR);\n                ExclusiveOrExpression();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ExclusiveOrExpression() throws ParseException {\n        /*@bgen(jjtree) ExclusiveOrExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTEXCLUSIVEOREXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            AndExpression();\n            label_26: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case XOR:\n                        ;\n                        break;\n                    default:\n                        break label_26;\n                }\n                jj_consume_token(XOR);\n                AndExpression();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void AndExpression() throws ParseException {\n        /*@bgen(jjtree) AndExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTANDEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            EqualityExpression();\n            label_27: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case BIT_AND:\n                        ;\n                        break;\n                    default:\n                        break label_27;\n                }\n                jj_consume_token(BIT_AND);\n                EqualityExpression();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void EqualityExpression() throws ParseException {\n        /*@bgen(jjtree) EqualityExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTEQUALITYEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            InstanceOfExpression();\n            label_28: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case EQ:\n                    case NE:\n                        ;\n                        break;\n                    default:\n                        break label_28;\n                }\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case EQ:\n                        jj_consume_token(EQ);\n                        break;\n                    case NE:\n                        jj_consume_token(NE);\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n                InstanceOfExpression();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void InstanceOfExpression() throws ParseException {\n        /*@bgen(jjtree) InstanceOfExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTINSTANCEOFEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            RelationalExpression();\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case INSTANCEOF:\n                    jj_consume_token(INSTANCEOF);\n                    Type();\n                    break;\n                default:\n                    ;\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void RelationalExpression() throws ParseException {\n        /*@bgen(jjtree) RelationalExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTRELATIONALEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            ShiftExpression();\n            label_29: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case LT:\n                    case LE:\n                    case GE:\n                    case GT:\n                        ;\n                        break;\n                    default:\n                        break label_29;\n                }\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case LT:\n                        jj_consume_token(LT);\n                        break;\n                    case GT:\n                        jj_consume_token(GT);\n                        break;\n                    case LE:\n                        jj_consume_token(LE);\n                        break;\n                    case GE:\n                        jj_consume_token(GE);\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n                ShiftExpression();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ShiftExpression() throws ParseException {\n        /*@bgen(jjtree) ShiftExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTSHIFTEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            AdditiveExpression();\n            label_30: while (true) {\n                if (jj_2_17(1)) {\n                    ;\n                } else {\n                    break label_30;\n                }\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case LSHIFT:\n                        jj_consume_token(LSHIFT);\n                        break;\n                    default:\n                        if (jj_2_18(1)) {\n                            RSIGNEDSHIFT();\n                        } else if (jj_2_19(1)) {\n                            RUNSIGNEDSHIFT();\n                        } else {\n                            jj_consume_token(-1);\n                            throw new ParseException();\n                        }\n                }\n                AdditiveExpression();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void AdditiveExpression() throws ParseException {\n        /*@bgen(jjtree) AdditiveExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTADDITIVEEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            MultiplicativeExpression();\n            label_31: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case PLUS:\n                    case MINUS:\n                        ;\n                        break;\n                    default:\n                        break label_31;\n                }\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case PLUS:\n                        jj_consume_token(PLUS);\n                        break;\n                    case MINUS:\n                        jj_consume_token(MINUS);\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n                MultiplicativeExpression();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void MultiplicativeExpression() throws ParseException {\n        /*@bgen(jjtree) MultiplicativeExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTMULTIPLICATIVEEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            UnaryExpression();\n            label_32: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case STAR:\n                    case SLASH:\n                    case REM:\n                        ;\n                        break;\n                    default:\n                        break label_32;\n                }\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case STAR:\n                        jj_consume_token(STAR);\n                        break;\n                    case SLASH:\n                        jj_consume_token(SLASH);\n                        break;\n                    case REM:\n                        jj_consume_token(REM);\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n                UnaryExpression();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void UnaryExpression() throws ParseException {\n        /*@bgen(jjtree) UnaryExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTUNARYEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case PLUS:\n                case MINUS:\n                    switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                        case PLUS:\n                            jj_consume_token(PLUS);\n                            break;\n                        case MINUS:\n                            jj_consume_token(MINUS);\n                            break;\n                        default:\n                            jj_consume_token(-1);\n                            throw new ParseException();\n                    }\n                    UnaryExpression();\n                    break;\n                case INCR:\n                    PreIncrementExpression();\n                    break;\n                case DECR:\n                    PreDecrementExpression();\n                    break;\n                case BOOLEAN:\n                case BYTE:\n                case CHAR:\n                case DOUBLE:\n                case FALSE:\n                case FLOAT:\n                case INT:\n                case LONG:\n                case NEW:\n                case NULL:\n                case SHORT:\n                case SUPER:\n                case THIS:\n                case TRUE:\n                case VOID:\n                case INTEGER_LITERAL:\n                case FLOATING_POINT_LITERAL:\n                case CHARACTER_LITERAL:\n                case STRING_LITERAL:\n                case IDENTIFIER:\n                case LPAREN:\n                case BANG:\n                case TILDE:\n                    UnaryExpressionNotPlusMinus();\n                    break;\n                default:\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void PreIncrementExpression() throws ParseException {\n        /*@bgen(jjtree) PreIncrementExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTPREINCREMENTEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(INCR);\n            PrimaryExpression();\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void PreDecrementExpression() throws ParseException {\n        /*@bgen(jjtree) PreDecrementExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTPREDECREMENTEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(DECR);\n            PrimaryExpression();\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void UnaryExpressionNotPlusMinus() throws ParseException {\n        /*@bgen(jjtree) UnaryExpressionNotPlusMinus */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTUNARYEXPRESSIONNOTPLUSMINUS);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case BANG:\n                case TILDE:\n                    switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                        case TILDE:\n                            jj_consume_token(TILDE);\n                            break;\n                        case BANG:\n                            jj_consume_token(BANG);\n                            break;\n                        default:\n                            jj_consume_token(-1);\n                            throw new ParseException();\n                    }\n                    UnaryExpression();\n                    break;\n                default:\n                    if (jj_2_20(2147483647)) {\n                        CastExpression();\n                    } else {\n                        switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                            case BOOLEAN:\n                            case BYTE:\n                            case CHAR:\n                            case DOUBLE:\n                            case FALSE:\n                            case FLOAT:\n                            case INT:\n                            case LONG:\n                            case NEW:\n                            case NULL:\n                            case SHORT:\n                            case SUPER:\n                            case THIS:\n                            case TRUE:\n                            case VOID:\n                            case INTEGER_LITERAL:\n                            case FLOATING_POINT_LITERAL:\n                            case CHARACTER_LITERAL:\n                            case STRING_LITERAL:\n                            case IDENTIFIER:\n                            case LPAREN:\n                                PostfixExpression();\n                                break;\n                            default:\n                                jj_consume_token(-1);\n                                throw new ParseException();\n                        }\n                    }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    // This production is to determine lookahead only.  The LOOKAHEAD specifications\n    // below are not used, but they are there just to indicate that we know about\n    // this.\n    final public void CastLookahead() throws ParseException {\n        /*@bgen(jjtree) CastLookahead */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTCASTLOOKAHEAD);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            if (jj_2_21(2)) {\n                jj_consume_token(LPAREN);\n                PrimitiveType();\n            } else if (jj_2_22(2147483647)) {\n                jj_consume_token(LPAREN);\n                Type();\n                jj_consume_token(LBRACKET);\n                jj_consume_token(RBRACKET);\n            } else {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case LPAREN:\n                        jj_consume_token(LPAREN);\n                        Type();\n                        jj_consume_token(RPAREN);\n                        switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                            case TILDE:\n                                jj_consume_token(TILDE);\n                                break;\n                            case BANG:\n                                jj_consume_token(BANG);\n                                break;\n                            case LPAREN:\n                                jj_consume_token(LPAREN);\n                                break;\n                            case IDENTIFIER:\n                                jj_consume_token(IDENTIFIER);\n                                break;\n                            case THIS:\n                                jj_consume_token(THIS);\n                                break;\n                            case SUPER:\n                                jj_consume_token(SUPER);\n                                break;\n                            case NEW:\n                                jj_consume_token(NEW);\n                                break;\n                            case FALSE:\n                            case NULL:\n                            case TRUE:\n                            case INTEGER_LITERAL:\n                            case FLOATING_POINT_LITERAL:\n                            case CHARACTER_LITERAL:\n                            case STRING_LITERAL:\n                                Literal();\n                                break;\n                            default:\n                                jj_consume_token(-1);\n                                throw new ParseException();\n                        }\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void PostfixExpression() throws ParseException {\n        /*@bgen(jjtree) PostfixExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTPOSTFIXEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            PrimaryExpression();\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case INCR:\n                case DECR:\n                    switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                        case INCR:\n                            jj_consume_token(INCR);\n                            break;\n                        case DECR:\n                            jj_consume_token(DECR);\n                            break;\n                        default:\n                            jj_consume_token(-1);\n                            throw new ParseException();\n                    }\n                    break;\n                default:\n                    ;\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void CastExpression() throws ParseException {\n        /*@bgen(jjtree) CastExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTCASTEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            if (jj_2_23(2147483647)) {\n                jj_consume_token(LPAREN);\n                Type();\n                jj_consume_token(RPAREN);\n                UnaryExpression();\n            } else {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case LPAREN:\n                        jj_consume_token(LPAREN);\n                        Type();\n                        jj_consume_token(RPAREN);\n                        UnaryExpressionNotPlusMinus();\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void PrimaryExpression() throws ParseException {\n        /*@bgen(jjtree) PrimaryExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTPRIMARYEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            PrimaryPrefix();\n            label_33: while (true) {\n                if (jj_2_24(2)) {\n                    ;\n                } else {\n                    break label_33;\n                }\n                PrimarySuffix();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void MemberSelector() throws ParseException {\n        /*@bgen(jjtree) MemberSelector */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTMEMBERSELECTOR);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(DOT);\n            TypeArguments();\n            jj_consume_token(IDENTIFIER);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void PrimaryPrefix() throws ParseException {\n        /*@bgen(jjtree) PrimaryPrefix */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTPRIMARYPREFIX);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case FALSE:\n                case NULL:\n                case TRUE:\n                case INTEGER_LITERAL:\n                case FLOATING_POINT_LITERAL:\n                case CHARACTER_LITERAL:\n                case STRING_LITERAL:\n                    Literal();\n                    break;\n                case THIS:\n                    jj_consume_token(THIS);\n                    break;\n                case SUPER:\n                    jj_consume_token(SUPER);\n                    jj_consume_token(DOT);\n                    jj_consume_token(IDENTIFIER);\n                    break;\n                case LPAREN:\n                    jj_consume_token(LPAREN);\n                    Expression();\n                    jj_consume_token(RPAREN);\n                    break;\n                case NEW:\n                    AllocationExpression();\n                    break;\n                default:\n                    if (jj_2_25(2147483647)) {\n                        ResultType();\n                        jj_consume_token(DOT);\n                        jj_consume_token(CLASS);\n                    } else {\n                        switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                            case IDENTIFIER:\n                                Name();\n                                break;\n                            default:\n                                jj_consume_token(-1);\n                                throw new ParseException();\n                        }\n                    }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void PrimarySuffix() throws ParseException {\n        /*@bgen(jjtree) PrimarySuffix */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTPRIMARYSUFFIX);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            if (jj_2_26(2)) {\n                jj_consume_token(DOT);\n                jj_consume_token(THIS);\n            } else if (jj_2_27(2)) {\n                jj_consume_token(DOT);\n                AllocationExpression();\n            } else if (jj_2_28(3)) {\n                MemberSelector();\n            } else {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case LBRACKET:\n                        jj_consume_token(LBRACKET);\n                        Expression();\n                        jj_consume_token(RBRACKET);\n                        break;\n                    case DOT:\n                        jj_consume_token(DOT);\n                        jj_consume_token(IDENTIFIER);\n                        break;\n                    case LPAREN:\n                        Arguments();\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void Literal() throws ParseException {\n        /*@bgen(jjtree) Literal */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTLITERAL);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case INTEGER_LITERAL:\n                    jj_consume_token(INTEGER_LITERAL);\n                    break;\n                case FLOATING_POINT_LITERAL:\n                    jj_consume_token(FLOATING_POINT_LITERAL);\n                    break;\n                case CHARACTER_LITERAL:\n                    jj_consume_token(CHARACTER_LITERAL);\n                    break;\n                case STRING_LITERAL:\n                    jj_consume_token(STRING_LITERAL);\n                    break;\n                case FALSE:\n                case TRUE:\n                    BooleanLiteral();\n                    break;\n                case NULL:\n                    NullLiteral();\n                    break;\n                default:\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void BooleanLiteral() throws ParseException {\n        /*@bgen(jjtree) BooleanLiteral */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTBOOLEANLITERAL);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case TRUE:\n                    jj_consume_token(TRUE);\n                    break;\n                case FALSE:\n                    jj_consume_token(FALSE);\n                    break;\n                default:\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void NullLiteral() throws ParseException {\n        /*@bgen(jjtree) NullLiteral */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTNULLLITERAL);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(NULL);\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void Arguments() throws ParseException {\n        /*@bgen(jjtree) Arguments */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTARGUMENTS);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(LPAREN);\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case BOOLEAN:\n                case BYTE:\n                case CHAR:\n                case DOUBLE:\n                case FALSE:\n                case FLOAT:\n                case INT:\n                case LONG:\n                case NEW:\n                case NULL:\n                case SHORT:\n                case SUPER:\n                case THIS:\n                case TRUE:\n                case VOID:\n                case INTEGER_LITERAL:\n                case FLOATING_POINT_LITERAL:\n                case CHARACTER_LITERAL:\n                case STRING_LITERAL:\n                case IDENTIFIER:\n                case LPAREN:\n                case BANG:\n                case TILDE:\n                case INCR:\n                case DECR:\n                case PLUS:\n                case MINUS:\n                    ArgumentList();\n                    break;\n                default:\n                    ;\n            }\n            jj_consume_token(RPAREN);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ArgumentList() throws ParseException {\n        /*@bgen(jjtree) ArgumentList */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTARGUMENTLIST);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            Expression();\n            label_34: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case COMMA:\n                        ;\n                        break;\n                    default:\n                        break label_34;\n                }\n                jj_consume_token(COMMA);\n                Expression();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void AllocationExpression() throws ParseException {\n        /*@bgen(jjtree) AllocationExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTALLOCATIONEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            if (jj_2_29(2)) {\n                jj_consume_token(NEW);\n                PrimitiveType();\n                ArrayDimsAndInits();\n            } else {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case NEW:\n                        jj_consume_token(NEW);\n                        ClassOrInterfaceType();\n                        switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                            case LT:\n                                TypeArguments();\n                                break;\n                            default:\n                                ;\n                        }\n                        switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                            case LBRACKET:\n                                ArrayDimsAndInits();\n                                break;\n                            case LPAREN:\n                                Arguments();\n                                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                                    case LBRACE:\n                                        ClassOrInterfaceBody(false);\n                                        break;\n                                    default:\n                                        ;\n                                }\n                                break;\n                            default:\n                                jj_consume_token(-1);\n                                throw new ParseException();\n                        }\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    /*\n     * The third LOOKAHEAD specification below is to parse to PrimarySuffix\n     * if there is an expression between the \"[...]\".\n     */\n    final public void ArrayDimsAndInits() throws ParseException {\n        /*@bgen(jjtree) ArrayDimsAndInits */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTARRAYDIMSANDINITS);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            if (jj_2_32(2)) {\n                label_35: while (true) {\n                    jj_consume_token(LBRACKET);\n                    Expression();\n                    jj_consume_token(RBRACKET);\n                    if (jj_2_30(2)) {\n                        ;\n                    } else {\n                        break label_35;\n                    }\n                }\n                label_36: while (true) {\n                    if (jj_2_31(2)) {\n                        ;\n                    } else {\n                        break label_36;\n                    }\n                    jj_consume_token(LBRACKET);\n                    jj_consume_token(RBRACKET);\n                }\n            } else {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case LBRACKET:\n                        label_37: while (true) {\n                            jj_consume_token(LBRACKET);\n                            jj_consume_token(RBRACKET);\n                            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                                case LBRACKET:\n                                    ;\n                                    break;\n                                default:\n                                    break label_37;\n                            }\n                        }\n                        ArrayInitializer();\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    /*\n     * Statement syntax follows.\n     */\n    final public void Statement() throws ParseException {\n        /*@bgen(jjtree) Statement */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTSTATEMENT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            if (jj_2_33(2)) {\n                LabeledStatement();\n            } else {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case ASSERT:\n                        AssertStatement();\n                        break;\n                    case LBRACE:\n                        Block();\n                        break;\n                    case SEMICOLON:\n                        EmptyStatement();\n                        break;\n                    case BOOLEAN:\n                    case BYTE:\n                    case CHAR:\n                    case DOUBLE:\n                    case FALSE:\n                    case FLOAT:\n                    case INT:\n                    case LONG:\n                    case NEW:\n                    case NULL:\n                    case SHORT:\n                    case SUPER:\n                    case THIS:\n                    case TRUE:\n                    case VOID:\n                    case INTEGER_LITERAL:\n                    case FLOATING_POINT_LITERAL:\n                    case CHARACTER_LITERAL:\n                    case STRING_LITERAL:\n                    case IDENTIFIER:\n                    case LPAREN:\n                    case INCR:\n                    case DECR:\n                        StatementExpression();\n                        jj_consume_token(SEMICOLON);\n                        break;\n                    case SWITCH:\n                        SwitchStatement();\n                        break;\n                    case IF:\n                        IfStatement();\n                        break;\n                    case WHILE:\n                        WhileStatement();\n                        break;\n                    case DO:\n                        DoStatement();\n                        break;\n                    case FOR:\n                        ForStatement();\n                        break;\n                    case BREAK:\n                        BreakStatement();\n                        break;\n                    case CONTINUE:\n                        ContinueStatement();\n                        break;\n                    case RETURN:\n                        ReturnStatement();\n                        break;\n                    case THROW:\n                        ThrowStatement();\n                        break;\n                    case SYNCHRONIZED:\n                        SynchronizedStatement();\n                        break;\n                    case TRY:\n                        TryStatement();\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void AssertStatement() throws ParseException {\n        /*@bgen(jjtree) AssertStatement */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTASSERTSTATEMENT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(ASSERT);\n            Expression();\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case COLON:\n                    jj_consume_token(COLON);\n                    Expression();\n                    break;\n                default:\n                    ;\n            }\n            jj_consume_token(SEMICOLON);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void LabeledStatement() throws ParseException {\n        /*@bgen(jjtree) LabeledStatement */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTLABELEDSTATEMENT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(IDENTIFIER);\n            jj_consume_token(COLON);\n            Statement();\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void Block() throws ParseException {\n        /*@bgen(jjtree) Block */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTBLOCK);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(LBRACE);\n            label_38: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case ASSERT:\n                    case BOOLEAN:\n                    case BREAK:\n                    case BYTE:\n                    case CHAR:\n                    case CLASS:\n                    case CONTINUE:\n                    case DO:\n                    case DOUBLE:\n                    case FALSE:\n                    case FINAL:\n                    case FLOAT:\n                    case FOR:\n                    case IF:\n                    case INT:\n                    case INTERFACE:\n                    case LONG:\n                    case NEW:\n                    case NULL:\n                    case RETURN:\n                    case SHORT:\n                    case SUPER:\n                    case SWITCH:\n                    case SYNCHRONIZED:\n                    case THIS:\n                    case THROW:\n                    case TRUE:\n                    case TRY:\n                    case VOID:\n                    case WHILE:\n                    case INTEGER_LITERAL:\n                    case FLOATING_POINT_LITERAL:\n                    case CHARACTER_LITERAL:\n                    case STRING_LITERAL:\n                    case IDENTIFIER:\n                    case LPAREN:\n                    case LBRACE:\n                    case SEMICOLON:\n                    case INCR:\n                    case DECR:\n                        ;\n                        break;\n                    default:\n                        break label_38;\n                }\n                BlockStatement();\n            }\n            jj_consume_token(RBRACE);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void BlockStatement() throws ParseException {\n        /*@bgen(jjtree) BlockStatement */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTBLOCKSTATEMENT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            if (jj_2_34(2147483647)) {\n                LocalVariableDeclaration();\n                jj_consume_token(SEMICOLON);\n            } else {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case ASSERT:\n                    case BOOLEAN:\n                    case BREAK:\n                    case BYTE:\n                    case CHAR:\n                    case CONTINUE:\n                    case DO:\n                    case DOUBLE:\n                    case FALSE:\n                    case FLOAT:\n                    case FOR:\n                    case IF:\n                    case INT:\n                    case LONG:\n                    case NEW:\n                    case NULL:\n                    case RETURN:\n                    case SHORT:\n                    case SUPER:\n                    case SWITCH:\n                    case SYNCHRONIZED:\n                    case THIS:\n                    case THROW:\n                    case TRUE:\n                    case TRY:\n                    case VOID:\n                    case WHILE:\n                    case INTEGER_LITERAL:\n                    case FLOATING_POINT_LITERAL:\n                    case CHARACTER_LITERAL:\n                    case STRING_LITERAL:\n                    case IDENTIFIER:\n                    case LPAREN:\n                    case LBRACE:\n                    case SEMICOLON:\n                    case INCR:\n                    case DECR:\n                        Statement();\n                        break;\n                    case CLASS:\n                    case INTERFACE:\n                        ClassOrInterfaceDeclaration(0);\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void LocalVariableDeclaration() throws ParseException {\n        /*@bgen(jjtree) LocalVariableDeclaration */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTLOCALVARIABLEDECLARATION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case FINAL:\n                    jj_consume_token(FINAL);\n                    break;\n                default:\n                    ;\n            }\n            Type();\n            VariableDeclarator();\n            label_39: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case COMMA:\n                        ;\n                        break;\n                    default:\n                        break label_39;\n                }\n                jj_consume_token(COMMA);\n                VariableDeclarator();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void EmptyStatement() throws ParseException {\n        /*@bgen(jjtree) EmptyStatement */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTEMPTYSTATEMENT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(SEMICOLON);\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void StatementExpression() throws ParseException {\n        /*@bgen(jjtree) StatementExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTSTATEMENTEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case INCR:\n                    PreIncrementExpression();\n                    break;\n                case DECR:\n                    PreDecrementExpression();\n                    break;\n                case BOOLEAN:\n                case BYTE:\n                case CHAR:\n                case DOUBLE:\n                case FALSE:\n                case FLOAT:\n                case INT:\n                case LONG:\n                case NEW:\n                case NULL:\n                case SHORT:\n                case SUPER:\n                case THIS:\n                case TRUE:\n                case VOID:\n                case INTEGER_LITERAL:\n                case FLOATING_POINT_LITERAL:\n                case CHARACTER_LITERAL:\n                case STRING_LITERAL:\n                case IDENTIFIER:\n                case LPAREN:\n                    PrimaryExpression();\n                    switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                        case ASSIGN:\n                        case INCR:\n                        case DECR:\n                        case PLUSASSIGN:\n                        case MINUSASSIGN:\n                        case STARASSIGN:\n                        case SLASHASSIGN:\n                        case ANDASSIGN:\n                        case ORASSIGN:\n                        case XORASSIGN:\n                        case REMASSIGN:\n                        case LSHIFTASSIGN:\n                        case RSIGNEDSHIFTASSIGN:\n                        case RUNSIGNEDSHIFTASSIGN:\n                            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                                case INCR:\n                                    jj_consume_token(INCR);\n                                    break;\n                                case DECR:\n                                    jj_consume_token(DECR);\n                                    break;\n                                case ASSIGN:\n                                case PLUSASSIGN:\n                                case MINUSASSIGN:\n                                case STARASSIGN:\n                                case SLASHASSIGN:\n                                case ANDASSIGN:\n                                case ORASSIGN:\n                                case XORASSIGN:\n                                case REMASSIGN:\n                                case LSHIFTASSIGN:\n                                case RSIGNEDSHIFTASSIGN:\n                                case RUNSIGNEDSHIFTASSIGN:\n                                    AssignmentOperator();\n                                    Expression();\n                                    break;\n                                default:\n                                    jj_consume_token(-1);\n                                    throw new ParseException();\n                            }\n                            break;\n                        default:\n                            ;\n                    }\n                    break;\n                default:\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void SwitchStatement() throws ParseException {\n        /*@bgen(jjtree) SwitchStatement */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTSWITCHSTATEMENT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(SWITCH);\n            jj_consume_token(LPAREN);\n            Expression();\n            jj_consume_token(RPAREN);\n            jj_consume_token(LBRACE);\n            label_40: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case CASE:\n                    case _DEFAULT:\n                        ;\n                        break;\n                    default:\n                        break label_40;\n                }\n                SwitchLabel();\n                label_41: while (true) {\n                    switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                        case ASSERT:\n                        case BOOLEAN:\n                        case BREAK:\n                        case BYTE:\n                        case CHAR:\n                        case CLASS:\n                        case CONTINUE:\n                        case DO:\n                        case DOUBLE:\n                        case FALSE:\n                        case FINAL:\n                        case FLOAT:\n                        case FOR:\n                        case IF:\n                        case INT:\n                        case INTERFACE:\n                        case LONG:\n                        case NEW:\n                        case NULL:\n                        case RETURN:\n                        case SHORT:\n                        case SUPER:\n                        case SWITCH:\n                        case SYNCHRONIZED:\n                        case THIS:\n                        case THROW:\n                        case TRUE:\n                        case TRY:\n                        case VOID:\n                        case WHILE:\n                        case INTEGER_LITERAL:\n                        case FLOATING_POINT_LITERAL:\n                        case CHARACTER_LITERAL:\n                        case STRING_LITERAL:\n                        case IDENTIFIER:\n                        case LPAREN:\n                        case LBRACE:\n                        case SEMICOLON:\n                        case INCR:\n                        case DECR:\n                            ;\n                            break;\n                        default:\n                            break label_41;\n                    }\n                    BlockStatement();\n                }\n            }\n            jj_consume_token(RBRACE);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void SwitchLabel() throws ParseException {\n        /*@bgen(jjtree) SwitchLabel */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTSWITCHLABEL);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case CASE:\n                    jj_consume_token(CASE);\n                    Expression();\n                    jj_consume_token(COLON);\n                    break;\n                case _DEFAULT:\n                    jj_consume_token(_DEFAULT);\n                    jj_consume_token(COLON);\n                    break;\n                default:\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void IfStatement() throws ParseException {\n        /*@bgen(jjtree) IfStatement */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTIFSTATEMENT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(IF);\n            jj_consume_token(LPAREN);\n            Expression();\n            jj_consume_token(RPAREN);\n            Statement();\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case ELSE:\n                    jj_consume_token(ELSE);\n                    Statement();\n                    break;\n                default:\n                    ;\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void WhileStatement() throws ParseException {\n        /*@bgen(jjtree) WhileStatement */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTWHILESTATEMENT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(WHILE);\n            jj_consume_token(LPAREN);\n            Expression();\n            jj_consume_token(RPAREN);\n            Statement();\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void DoStatement() throws ParseException {\n        /*@bgen(jjtree) DoStatement */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTDOSTATEMENT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(DO);\n            Statement();\n            jj_consume_token(WHILE);\n            jj_consume_token(LPAREN);\n            Expression();\n            jj_consume_token(RPAREN);\n            jj_consume_token(SEMICOLON);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ForStatement() throws ParseException {\n        /*@bgen(jjtree) ForStatement */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTFORSTATEMENT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(FOR);\n            jj_consume_token(LPAREN);\n            if (jj_2_35(2147483647)) {\n                Type();\n                jj_consume_token(IDENTIFIER);\n                jj_consume_token(COLON);\n                Expression();\n            } else {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case BOOLEAN:\n                    case BYTE:\n                    case CHAR:\n                    case DOUBLE:\n                    case FALSE:\n                    case FINAL:\n                    case FLOAT:\n                    case INT:\n                    case LONG:\n                    case NEW:\n                    case NULL:\n                    case SHORT:\n                    case SUPER:\n                    case THIS:\n                    case TRUE:\n                    case VOID:\n                    case INTEGER_LITERAL:\n                    case FLOATING_POINT_LITERAL:\n                    case CHARACTER_LITERAL:\n                    case STRING_LITERAL:\n                    case IDENTIFIER:\n                    case LPAREN:\n                    case SEMICOLON:\n                    case INCR:\n                    case DECR:\n                        switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                            case BOOLEAN:\n                            case BYTE:\n                            case CHAR:\n                            case DOUBLE:\n                            case FALSE:\n                            case FINAL:\n                            case FLOAT:\n                            case INT:\n                            case LONG:\n                            case NEW:\n                            case NULL:\n                            case SHORT:\n                            case SUPER:\n                            case THIS:\n                            case TRUE:\n                            case VOID:\n                            case INTEGER_LITERAL:\n                            case FLOATING_POINT_LITERAL:\n                            case CHARACTER_LITERAL:\n                            case STRING_LITERAL:\n                            case IDENTIFIER:\n                            case LPAREN:\n                            case INCR:\n                            case DECR:\n                                ForInit();\n                                break;\n                            default:\n                                ;\n                        }\n                        jj_consume_token(SEMICOLON);\n                        switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                            case BOOLEAN:\n                            case BYTE:\n                            case CHAR:\n                            case DOUBLE:\n                            case FALSE:\n                            case FLOAT:\n                            case INT:\n                            case LONG:\n                            case NEW:\n                            case NULL:\n                            case SHORT:\n                            case SUPER:\n                            case THIS:\n                            case TRUE:\n                            case VOID:\n                            case INTEGER_LITERAL:\n                            case FLOATING_POINT_LITERAL:\n                            case CHARACTER_LITERAL:\n                            case STRING_LITERAL:\n                            case IDENTIFIER:\n                            case LPAREN:\n                            case BANG:\n                            case TILDE:\n                            case INCR:\n                            case DECR:\n                            case PLUS:\n                            case MINUS:\n                                Expression();\n                                break;\n                            default:\n                                ;\n                        }\n                        jj_consume_token(SEMICOLON);\n                        switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                            case BOOLEAN:\n                            case BYTE:\n                            case CHAR:\n                            case DOUBLE:\n                            case FALSE:\n                            case FLOAT:\n                            case INT:\n                            case LONG:\n                            case NEW:\n                            case NULL:\n                            case SHORT:\n                            case SUPER:\n                            case THIS:\n                            case TRUE:\n                            case VOID:\n                            case INTEGER_LITERAL:\n                            case FLOATING_POINT_LITERAL:\n                            case CHARACTER_LITERAL:\n                            case STRING_LITERAL:\n                            case IDENTIFIER:\n                            case LPAREN:\n                            case INCR:\n                            case DECR:\n                                ForUpdate();\n                                break;\n                            default:\n                                ;\n                        }\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n            jj_consume_token(RPAREN);\n            Statement();\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ForInit() throws ParseException {\n        /*@bgen(jjtree) ForInit */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTFORINIT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            if (jj_2_36(2147483647)) {\n                LocalVariableDeclaration();\n            } else {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case BOOLEAN:\n                    case BYTE:\n                    case CHAR:\n                    case DOUBLE:\n                    case FALSE:\n                    case FLOAT:\n                    case INT:\n                    case LONG:\n                    case NEW:\n                    case NULL:\n                    case SHORT:\n                    case SUPER:\n                    case THIS:\n                    case TRUE:\n                    case VOID:\n                    case INTEGER_LITERAL:\n                    case FLOATING_POINT_LITERAL:\n                    case CHARACTER_LITERAL:\n                    case STRING_LITERAL:\n                    case IDENTIFIER:\n                    case LPAREN:\n                    case INCR:\n                    case DECR:\n                        StatementExpressionList();\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void StatementExpressionList() throws ParseException {\n        /*@bgen(jjtree) StatementExpressionList */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTSTATEMENTEXPRESSIONLIST);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            StatementExpression();\n            label_42: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case COMMA:\n                        ;\n                        break;\n                    default:\n                        break label_42;\n                }\n                jj_consume_token(COMMA);\n                StatementExpression();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ForUpdate() throws ParseException {\n        /*@bgen(jjtree) ForUpdate */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTFORUPDATE);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            StatementExpressionList();\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void BreakStatement() throws ParseException {\n        /*@bgen(jjtree) BreakStatement */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTBREAKSTATEMENT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(BREAK);\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case IDENTIFIER:\n                    jj_consume_token(IDENTIFIER);\n                    break;\n                default:\n                    ;\n            }\n            jj_consume_token(SEMICOLON);\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ContinueStatement() throws ParseException {\n        /*@bgen(jjtree) ContinueStatement */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTCONTINUESTATEMENT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(CONTINUE);\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case IDENTIFIER:\n                    jj_consume_token(IDENTIFIER);\n                    break;\n                default:\n                    ;\n            }\n            jj_consume_token(SEMICOLON);\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ReturnStatement() throws ParseException {\n        /*@bgen(jjtree) ReturnStatement */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTRETURNSTATEMENT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(RETURN);\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case BOOLEAN:\n                case BYTE:\n                case CHAR:\n                case DOUBLE:\n                case FALSE:\n                case FLOAT:\n                case INT:\n                case LONG:\n                case NEW:\n                case NULL:\n                case SHORT:\n                case SUPER:\n                case THIS:\n                case TRUE:\n                case VOID:\n                case INTEGER_LITERAL:\n                case FLOATING_POINT_LITERAL:\n                case CHARACTER_LITERAL:\n                case STRING_LITERAL:\n                case IDENTIFIER:\n                case LPAREN:\n                case BANG:\n                case TILDE:\n                case INCR:\n                case DECR:\n                case PLUS:\n                case MINUS:\n                    Expression();\n                    break;\n                default:\n                    ;\n            }\n            jj_consume_token(SEMICOLON);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ThrowStatement() throws ParseException {\n        /*@bgen(jjtree) ThrowStatement */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTTHROWSTATEMENT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(THROW);\n            Expression();\n            jj_consume_token(SEMICOLON);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void SynchronizedStatement() throws ParseException {\n        /*@bgen(jjtree) SynchronizedStatement */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTSYNCHRONIZEDSTATEMENT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(SYNCHRONIZED);\n            jj_consume_token(LPAREN);\n            Expression();\n            jj_consume_token(RPAREN);\n            Block();\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void TryStatement() throws ParseException {\n        /*@bgen(jjtree) TryStatement */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTTRYSTATEMENT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(TRY);\n            Block();\n            label_43: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case CATCH:\n                        ;\n                        break;\n                    default:\n                        break label_43;\n                }\n                jj_consume_token(CATCH);\n                jj_consume_token(LPAREN);\n                FormalParameter();\n                jj_consume_token(RPAREN);\n                Block();\n            }\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case FINALLY:\n                    jj_consume_token(FINALLY);\n                    Block();\n                    break;\n                default:\n                    ;\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    /* We use productions to match >>>, >> and > so that we can keep the\n     * type declaration syntax with generics clean\n     */\n    final public void RUNSIGNEDSHIFT() throws ParseException {\n        /*@bgen(jjtree) RUNSIGNEDSHIFT */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTRUNSIGNEDSHIFT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            if (getToken(1).kind == GT && ((Token.GTToken) getToken(1)).realKind == RUNSIGNEDSHIFT) {\n            } else {\n                jj_consume_token(-1);\n                throw new ParseException();\n            }\n            jj_consume_token(GT);\n            jj_consume_token(GT);\n            jj_consume_token(GT);\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void RSIGNEDSHIFT() throws ParseException {\n        /*@bgen(jjtree) RSIGNEDSHIFT */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTRSIGNEDSHIFT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            if (getToken(1).kind == GT && ((Token.GTToken) getToken(1)).realKind == RSIGNEDSHIFT) {\n            } else {\n                jj_consume_token(-1);\n                throw new ParseException();\n            }\n            jj_consume_token(GT);\n            jj_consume_token(GT);\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    /* Annotation syntax follows. */\n    final public void Annotation() throws ParseException {\n        /*@bgen(jjtree) Annotation */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTANNOTATION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            if (jj_2_37(2147483647)) {\n                NormalAnnotation();\n            } else if (jj_2_38(2147483647)) {\n                SingleMemberAnnotation();\n            } else {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case AT:\n                        MarkerAnnotation();\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void NormalAnnotation() throws ParseException {\n        /*@bgen(jjtree) NormalAnnotation */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTNORMALANNOTATION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(AT);\n            Name();\n            jj_consume_token(LPAREN);\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case IDENTIFIER:\n                    MemberValuePairs();\n                    break;\n                default:\n                    ;\n            }\n            jj_consume_token(RPAREN);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void MarkerAnnotation() throws ParseException {\n        /*@bgen(jjtree) MarkerAnnotation */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTMARKERANNOTATION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(AT);\n            Name();\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void SingleMemberAnnotation() throws ParseException {\n        /*@bgen(jjtree) SingleMemberAnnotation */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTSINGLEMEMBERANNOTATION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(AT);\n            Name();\n            jj_consume_token(LPAREN);\n            MemberValue();\n            jj_consume_token(RPAREN);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void MemberValuePairs() throws ParseException {\n        /*@bgen(jjtree) MemberValuePairs */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTMEMBERVALUEPAIRS);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            MemberValuePair();\n            label_44: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case COMMA:\n                        ;\n                        break;\n                    default:\n                        break label_44;\n                }\n                jj_consume_token(COMMA);\n                MemberValuePair();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void MemberValuePair() throws ParseException {\n        /*@bgen(jjtree) MemberValuePair */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTMEMBERVALUEPAIR);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(IDENTIFIER);\n            jj_consume_token(ASSIGN);\n            MemberValue();\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void MemberValue() throws ParseException {\n        /*@bgen(jjtree) MemberValue */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTMEMBERVALUE);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case AT:\n                    Annotation();\n                    break;\n                case LBRACE:\n                    MemberValueArrayInitializer();\n                    break;\n                case BOOLEAN:\n                case BYTE:\n                case CHAR:\n                case DOUBLE:\n                case FALSE:\n                case FLOAT:\n                case INT:\n                case LONG:\n                case NEW:\n                case NULL:\n                case SHORT:\n                case SUPER:\n                case THIS:\n                case TRUE:\n                case VOID:\n                case INTEGER_LITERAL:\n                case FLOATING_POINT_LITERAL:\n                case CHARACTER_LITERAL:\n                case STRING_LITERAL:\n                case IDENTIFIER:\n                case LPAREN:\n                case BANG:\n                case TILDE:\n                case INCR:\n                case DECR:\n                case PLUS:\n                case MINUS:\n                    ConditionalExpression();\n                    break;\n                default:\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void MemberValueArrayInitializer() throws ParseException {\n        /*@bgen(jjtree) MemberValueArrayInitializer */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTMEMBERVALUEARRAYINITIALIZER);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(LBRACE);\n            MemberValue();\n            label_45: while (true) {\n                if (jj_2_39(2)) {\n                    ;\n                } else {\n                    break label_45;\n                }\n                jj_consume_token(COMMA);\n                MemberValue();\n            }\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case COMMA:\n                    jj_consume_token(COMMA);\n                    break;\n                default:\n                    ;\n            }\n            jj_consume_token(RBRACE);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    /* Annotation Types. */\n    final public void AnnotationTypeDeclaration(int modifiers) throws ParseException {\n        /*@bgen(jjtree) AnnotationTypeDeclaration */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTANNOTATIONTYPEDECLARATION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(AT);\n            jj_consume_token(INTERFACE);\n            jj_consume_token(IDENTIFIER);\n            AnnotationTypeBody();\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void AnnotationTypeBody() throws ParseException {\n        /*@bgen(jjtree) AnnotationTypeBody */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTANNOTATIONTYPEBODY);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(LBRACE);\n            label_46: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case ABSTRACT:\n                    case BOOLEAN:\n                    case BYTE:\n                    case CHAR:\n                    case CLASS:\n                    case DOUBLE:\n                    case ENUM:\n                    case FINAL:\n                    case FLOAT:\n                    case INT:\n                    case INTERFACE:\n                    case LONG:\n                    case NATIVE:\n                    case PRIVATE:\n                    case PROTECTED:\n                    case PUBLIC:\n                    case SHORT:\n                    case STATIC:\n                    case STRICTFP:\n                    case SYNCHRONIZED:\n                    case TRANSIENT:\n                    case VOLATILE:\n                    case IDENTIFIER:\n                    case SEMICOLON:\n                    case AT:\n                        ;\n                        break;\n                    default:\n                        break label_46;\n                }\n                AnnotationTypeMemberDeclaration();\n            }\n            jj_consume_token(RBRACE);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void AnnotationTypeMemberDeclaration() throws ParseException {\n        /*@bgen(jjtree) AnnotationTypeMemberDeclaration */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTANNOTATIONTYPEMEMBERDECLARATION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        int modifiers;\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case ABSTRACT:\n                case BOOLEAN:\n                case BYTE:\n                case CHAR:\n                case CLASS:\n                case DOUBLE:\n                case ENUM:\n                case FINAL:\n                case FLOAT:\n                case INT:\n                case INTERFACE:\n                case LONG:\n                case NATIVE:\n                case PRIVATE:\n                case PROTECTED:\n                case PUBLIC:\n                case SHORT:\n                case STATIC:\n                case STRICTFP:\n                case SYNCHRONIZED:\n                case TRANSIENT:\n                case VOLATILE:\n                case IDENTIFIER:\n                case AT:\n                    modifiers = Modifiers();\n                    if (jj_2_40(2147483647)) {\n                        Type();\n                        jj_consume_token(IDENTIFIER);\n                        jj_consume_token(LPAREN);\n                        jj_consume_token(RPAREN);\n                        switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                            case _DEFAULT:\n                                DefaultValue();\n                                break;\n                            default:\n                                ;\n                        }\n                        jj_consume_token(SEMICOLON);\n                    } else {\n                        switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                            case CLASS:\n                            case INTERFACE:\n                                ClassOrInterfaceDeclaration(modifiers);\n                                break;\n                            case ENUM:\n                                EnumDeclaration(modifiers);\n                                break;\n                            case AT:\n                                AnnotationTypeDeclaration(modifiers);\n                                break;\n                            case BOOLEAN:\n                            case BYTE:\n                            case CHAR:\n                            case DOUBLE:\n                            case FLOAT:\n                            case INT:\n                            case LONG:\n                            case SHORT:\n                            case IDENTIFIER:\n                                FieldDeclaration(modifiers);\n                                break;\n                            default:\n                                jj_consume_token(-1);\n                                throw new ParseException();\n                        }\n                    }\n                    break;\n                case SEMICOLON:\n                    jj_consume_token(SEMICOLON);\n                    break;\n                default:\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void DefaultValue() throws ParseException {\n        /*@bgen(jjtree) DefaultValue */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTDEFAULTVALUE);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(_DEFAULT);\n            MemberValue();\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final private boolean jj_2_1(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_1();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_2(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_2();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_3(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_3();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_4(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_4();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_5(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_5();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_6(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_6();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_7(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_7();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_8(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_8();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_9(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_9();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_10(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_10();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_11(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_11();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_12(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_12();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_13(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_13();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_14(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_14();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_15(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_15();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_16(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_16();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_17(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_17();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_18(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_18();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_19(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_19();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_20(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_20();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_21(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_21();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_22(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_22();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_23(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_23();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_24(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_24();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_25(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_25();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_26(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_26();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_27(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_27();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_28(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_28();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_29(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_29();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_30(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_30();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_31(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_31();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_32(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_32();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_33(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_33();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_34(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_34();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_35(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_35();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_36(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_36();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_37(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_37();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_38(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_38();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_39(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_39();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_40(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_40();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_3R_94() {\n        if (jj_3R_123()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3_11()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_93() {\n        if (jj_3R_74()) {\n            return true;\n        }\n        Token xsp;\n        if (jj_3_10()) {\n            return true;\n        }\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3_10()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_67() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_93()) {\n            jj_scanpos = xsp;\n            if (jj_3R_94()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_243() {\n        if (jj_scan_token(THROWS)) {\n            return true;\n        }\n        if (jj_3R_262()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_85() {\n        if (jj_3R_74()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_9() {\n        if (jj_3R_67()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_60() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3_9()) {\n            jj_scanpos = xsp;\n            if (jj_3R_85()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3_8() {\n        if (jj_scan_token(THIS)) {\n            return true;\n        }\n        if (jj_3R_66()) {\n            return true;\n        }\n        if (jj_scan_token(SEMICOLON)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_62() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(52)) {\n            jj_scanpos = xsp;\n        }\n        if (jj_3R_86()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_6() {\n        if (jj_3R_64()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_7() {\n        if (jj_3R_65()) {\n            return true;\n        }\n        if (jj_scan_token(DOT)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_265() {\n        if (jj_scan_token(LBRACKET)) {\n            return true;\n        }\n        if (jj_scan_token(RBRACKET)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_90() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3_7()) {\n            jj_scanpos = xsp;\n        }\n        if (jj_scan_token(SUPER)) {\n            return true;\n        }\n        if (jj_3R_66()) {\n            return true;\n        }\n        if (jj_scan_token(SEMICOLON)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_274() {\n        if (jj_scan_token(COMMA)) {\n            return true;\n        }\n        if (jj_3R_273()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_89() {\n        if (jj_scan_token(THIS)) {\n            return true;\n        }\n        if (jj_3R_66()) {\n            return true;\n        }\n        if (jj_scan_token(SEMICOLON)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_64() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_89()) {\n            jj_scanpos = xsp;\n            if (jj_3R_90()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_245() {\n        if (jj_3R_133()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_244() {\n        if (jj_3R_64()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_241() {\n        if (jj_3R_84()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_231() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_241()) {\n            jj_scanpos = xsp;\n        }\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        if (jj_3R_242()) {\n            return true;\n        }\n        xsp = jj_scanpos;\n        if (jj_3R_243()) {\n            jj_scanpos = xsp;\n        }\n        if (jj_scan_token(LBRACE)) {\n            return true;\n        }\n        xsp = jj_scanpos;\n        if (jj_3R_244()) {\n            jj_scanpos = xsp;\n        }\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_245()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        if (jj_scan_token(RBRACE)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_5() {\n        if (jj_scan_token(COMMA)) {\n            return true;\n        }\n        if (jj_3R_63()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_250() {\n        if (jj_scan_token(THROWS)) {\n            return true;\n        }\n        if (jj_3R_262()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_273() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(31)) {\n            jj_scanpos = xsp;\n        }\n        if (jj_3R_60()) {\n            return true;\n        }\n        xsp = jj_scanpos;\n        if (jj_scan_token(121)) {\n            jj_scanpos = xsp;\n        }\n        if (jj_3R_263()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_261() {\n        if (jj_3R_273()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_274()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_242() {\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_261()) {\n            jj_scanpos = xsp;\n        }\n        if (jj_scan_token(RPAREN)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_249() {\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        if (jj_3R_242()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_265()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_251() {\n        if (jj_3R_86()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_40() {\n        if (jj_3R_60()) {\n            return true;\n        }\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_248() {\n        if (jj_3R_84()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_210() {\n        if (jj_3R_63()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3_5()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_233() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_248()) {\n            jj_scanpos = xsp;\n        }\n        if (jj_3R_76()) {\n            return true;\n        }\n        if (jj_3R_249()) {\n            return true;\n        }\n        xsp = jj_scanpos;\n        if (jj_3R_250()) {\n            jj_scanpos = xsp;\n        }\n        xsp = jj_scanpos;\n        if (jj_3R_251()) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(83)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_264() {\n        if (jj_scan_token(ASSIGN)) {\n            return true;\n        }\n        if (jj_3R_63()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_247() {\n        if (jj_scan_token(COMMA)) {\n            return true;\n        }\n        if (jj_3R_246()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_276() {\n        if (jj_scan_token(LBRACKET)) {\n            return true;\n        }\n        if (jj_scan_token(RBRACKET)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_115() {\n        if (jj_scan_token(LBRACE)) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_210()) {\n            jj_scanpos = xsp;\n        }\n        xsp = jj_scanpos;\n        if (jj_scan_token(84)) {\n            jj_scanpos = xsp;\n        }\n        if (jj_scan_token(RBRACE)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_61() {\n        if (jj_scan_token(LBRACKET)) {\n            return true;\n        }\n        if (jj_scan_token(RBRACKET)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_39() {\n        if (jj_scan_token(COMMA)) {\n            return true;\n        }\n        if (jj_3R_82()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_88() {\n        if (jj_3R_70()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_87() {\n        if (jj_3R_115()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_63() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_87()) {\n            jj_scanpos = xsp;\n            if (jj_3R_88()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_263() {\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_276()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_246() {\n        if (jj_3R_263()) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_264()) {\n            jj_scanpos = xsp;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_3() {\n        if (jj_3R_60()) {\n            return true;\n        }\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_61()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        xsp = jj_scanpos;\n        if (jj_scan_token(84)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(87)) {\n                jj_scanpos = xsp;\n                if (jj_scan_token(83)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_59() {\n        if (jj_3R_84()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_128() {\n        if (jj_scan_token(LBRACE)) {\n            return true;\n        }\n        if (jj_3R_82()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3_39()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        xsp = jj_scanpos;\n        if (jj_scan_token(84)) {\n            jj_scanpos = xsp;\n        }\n        if (jj_scan_token(RBRACE)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_292() {\n        if (jj_scan_token(COMMA)) {\n            return true;\n        }\n        if (jj_3R_291()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_2() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_59()) {\n            jj_scanpos = xsp;\n        }\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_232() {\n        if (jj_3R_60()) {\n            return true;\n        }\n        if (jj_3R_246()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_247()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        if (jj_scan_token(SEMICOLON)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_108() {\n        if (jj_3R_96()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_225() {\n        if (jj_3R_233()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_107() {\n        if (jj_3R_128()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_106() {\n        if (jj_3R_83()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_82() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_106()) {\n            jj_scanpos = xsp;\n            if (jj_3R_107()) {\n                jj_scanpos = xsp;\n                if (jj_3R_108()) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_144() {\n        if (jj_scan_token(BIT_AND)) {\n            return true;\n        }\n        if (jj_3R_123()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_224() {\n        if (jj_3R_232()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_223() {\n        if (jj_3R_231()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_291() {\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        if (jj_scan_token(ASSIGN)) {\n            return true;\n        }\n        if (jj_3R_82()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_222() {\n        if (jj_3R_230()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_221() {\n        if (jj_3R_147()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_281() {\n        if (jj_3R_291()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_292()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_280() {\n        if (jj_3R_281()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_81() {\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        if (jj_scan_token(ASSIGN)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_217() {\n        if (jj_3R_220()) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_221()) {\n            jj_scanpos = xsp;\n            if (jj_3R_222()) {\n                jj_scanpos = xsp;\n                if (jj_3R_223()) {\n                    jj_scanpos = xsp;\n                    if (jj_3R_224()) {\n                        jj_scanpos = xsp;\n                        if (jj_3R_225()) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_130() {\n        if (jj_scan_token(AT)) {\n            return true;\n        }\n        if (jj_3R_80()) {\n            return true;\n        }\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        if (jj_3R_82()) {\n            return true;\n        }\n        if (jj_scan_token(RPAREN)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_4() {\n        if (jj_3R_62()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_214() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3_4()) {\n            jj_scanpos = xsp;\n            if (jj_3R_217()) {\n                jj_scanpos = xsp;\n                if (jj_scan_token(83)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_271() {\n        if (jj_3R_205()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_211() {\n        if (jj_3R_214()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_131() {\n        if (jj_scan_token(AT)) {\n            return true;\n        }\n        if (jj_3R_80()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_113() {\n        if (jj_scan_token(COMMA)) {\n            return true;\n        }\n        if (jj_3R_112()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_132() {\n        if (jj_3R_137()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_38() {\n        if (jj_scan_token(AT)) {\n            return true;\n        }\n        if (jj_3R_80()) {\n            return true;\n        }\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_129() {\n        if (jj_scan_token(AT)) {\n            return true;\n        }\n        if (jj_3R_80()) {\n            return true;\n        }\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_280()) {\n            jj_scanpos = xsp;\n        }\n        if (jj_scan_token(RPAREN)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_205() {\n        if (jj_scan_token(LBRACE)) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_211()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        if (jj_scan_token(RBRACE)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_37() {\n        if (jj_scan_token(AT)) {\n            return true;\n        }\n        if (jj_3R_80()) {\n            return true;\n        }\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_81()) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(78)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_137() {\n        if (jj_scan_token(EXTENDS)) {\n            return true;\n        }\n        if (jj_3R_123()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_144()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_111() {\n        if (jj_3R_131()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_110() {\n        if (jj_3R_130()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_270() {\n        if (jj_3R_66()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_112() {\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_132()) {\n            jj_scanpos = xsp;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_109() {\n        if (jj_3R_129()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_97() {\n        return false;\n    }\n\n    final private boolean jj_3R_83() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_109()) {\n            jj_scanpos = xsp;\n            if (jj_3R_110()) {\n                jj_scanpos = xsp;\n                if (jj_3R_111()) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_259() {\n        if (jj_scan_token(COMMA)) {\n            return true;\n        }\n        if (jj_3R_258()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_84() {\n        if (jj_scan_token(LT)) {\n            return true;\n        }\n        if (jj_3R_112()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_113()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        if (jj_scan_token(GT)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_98() {\n        return false;\n    }\n\n    final private boolean jj_3R_272() {\n        if (jj_3R_214()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_71() {\n        Token xsp;\n        xsp = jj_scanpos;\n        lookingAhead = true;\n        jj_semLA = getToken(1).kind == GT && ((Token.GTToken) getToken(1)).realKind == RSIGNEDSHIFT;\n        lookingAhead = false;\n        if (!jj_semLA || jj_3R_97()) {\n            return true;\n        }\n        if (jj_scan_token(GT)) {\n            return true;\n        }\n        if (jj_scan_token(GT)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_258() {\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_270()) {\n            jj_scanpos = xsp;\n        }\n        xsp = jj_scanpos;\n        if (jj_3R_271()) {\n            jj_scanpos = xsp;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_260() {\n        if (jj_scan_token(SEMICOLON)) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_272()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_240() {\n        if (jj_scan_token(LBRACE)) {\n            return true;\n        }\n        if (jj_3R_258()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_259()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        xsp = jj_scanpos;\n        if (jj_3R_260()) {\n            jj_scanpos = xsp;\n        }\n        if (jj_scan_token(RBRACE)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_72() {\n        Token xsp;\n        xsp = jj_scanpos;\n        lookingAhead = true;\n        jj_semLA = getToken(1).kind == GT && ((Token.GTToken) getToken(1)).realKind == RUNSIGNEDSHIFT;\n        lookingAhead = false;\n        if (!jj_semLA || jj_3R_98()) {\n            return true;\n        }\n        if (jj_scan_token(GT)) {\n            return true;\n        }\n        if (jj_scan_token(GT)) {\n            return true;\n        }\n        if (jj_scan_token(GT)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_239() {\n        if (jj_3R_257()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_290() {\n        if (jj_scan_token(FINALLY)) {\n            return true;\n        }\n        if (jj_3R_86()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_289() {\n        if (jj_scan_token(CATCH)) {\n            return true;\n        }\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        if (jj_3R_273()) {\n            return true;\n        }\n        if (jj_scan_token(RPAREN)) {\n            return true;\n        }\n        if (jj_3R_86()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_230() {\n        if (jj_scan_token(ENUM)) {\n            return true;\n        }\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_239()) {\n            jj_scanpos = xsp;\n        }\n        if (jj_3R_240()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_184() {\n        if (jj_scan_token(TRY)) {\n            return true;\n        }\n        if (jj_3R_86()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_289()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        xsp = jj_scanpos;\n        if (jj_3R_290()) {\n            jj_scanpos = xsp;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_269() {\n        if (jj_scan_token(COMMA)) {\n            return true;\n        }\n        if (jj_3R_123()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_257() {\n        if (jj_scan_token(IMPLEMENTS)) {\n            return true;\n        }\n        if (jj_3R_123()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_269()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_183() {\n        if (jj_scan_token(SYNCHRONIZED)) {\n            return true;\n        }\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        if (jj_scan_token(RPAREN)) {\n            return true;\n        }\n        if (jj_3R_86()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_288() {\n        if (jj_3R_70()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_268() {\n        if (jj_scan_token(COMMA)) {\n            return true;\n        }\n        if (jj_3R_123()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_182() {\n        if (jj_scan_token(THROW)) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        if (jj_scan_token(SEMICOLON)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_256() {\n        if (jj_scan_token(EXTENDS)) {\n            return true;\n        }\n        if (jj_3R_123()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_268()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_298() {\n        if (jj_3R_303()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_167() {\n        if (jj_scan_token(INTERFACE)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_307() {\n        if (jj_scan_token(COMMA)) {\n            return true;\n        }\n        if (jj_3R_173()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_181() {\n        if (jj_scan_token(RETURN)) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_288()) {\n            jj_scanpos = xsp;\n        }\n        if (jj_scan_token(SEMICOLON)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_238() {\n        if (jj_3R_257()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_237() {\n        if (jj_3R_256()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_236() {\n        if (jj_3R_84()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_180() {\n        if (jj_scan_token(CONTINUE)) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(74)) {\n            jj_scanpos = xsp;\n        }\n        if (jj_scan_token(SEMICOLON)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_147() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(21)) {\n            jj_scanpos = xsp;\n            if (jj_3R_167()) {\n                return true;\n            }\n        }\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        xsp = jj_scanpos;\n        if (jj_3R_236()) {\n            jj_scanpos = xsp;\n        }\n        xsp = jj_scanpos;\n        if (jj_3R_237()) {\n            jj_scanpos = xsp;\n        }\n        xsp = jj_scanpos;\n        if (jj_3R_238()) {\n            jj_scanpos = xsp;\n        }\n        if (jj_3R_205()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_179() {\n        if (jj_scan_token(BREAK)) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(74)) {\n            jj_scanpos = xsp;\n        }\n        if (jj_scan_token(SEMICOLON)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_303() {\n        if (jj_3R_306()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_297() {\n        if (jj_3R_70()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_36() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(31)) {\n            jj_scanpos = xsp;\n        }\n        if (jj_3R_60()) {\n            return true;\n        }\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_306() {\n        if (jj_3R_173()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_307()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_285() {\n        if (jj_scan_token(ELSE)) {\n            return true;\n        }\n        if (jj_3R_146()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_305() {\n        if (jj_3R_306()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_35() {\n        if (jj_3R_60()) {\n            return true;\n        }\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        if (jj_scan_token(COLON)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_304() {\n        if (jj_3R_145()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_302() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_304()) {\n            jj_scanpos = xsp;\n            if (jj_3R_305()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_296() {\n        if (jj_3R_302()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_287() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_296()) {\n            jj_scanpos = xsp;\n        }\n        if (jj_scan_token(SEMICOLON)) {\n            return true;\n        }\n        xsp = jj_scanpos;\n        if (jj_3R_297()) {\n            jj_scanpos = xsp;\n        }\n        if (jj_scan_token(SEMICOLON)) {\n            return true;\n        }\n        xsp = jj_scanpos;\n        if (jj_3R_298()) {\n            jj_scanpos = xsp;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_286() {\n        if (jj_3R_60()) {\n            return true;\n        }\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        if (jj_scan_token(COLON)) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_58() {\n        if (jj_3R_83()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_57() {\n        if (jj_scan_token(STRICTFP)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_56() {\n        if (jj_scan_token(VOLATILE)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_178() {\n        if (jj_scan_token(FOR)) {\n            return true;\n        }\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_286()) {\n            jj_scanpos = xsp;\n            if (jj_3R_287()) {\n                return true;\n            }\n        }\n        if (jj_scan_token(RPAREN)) {\n            return true;\n        }\n        if (jj_3R_146()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_55() {\n        if (jj_scan_token(TRANSIENT)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_54() {\n        if (jj_scan_token(NATIVE)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_53() {\n        if (jj_scan_token(SYNCHRONIZED)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_177() {\n        if (jj_scan_token(DO)) {\n            return true;\n        }\n        if (jj_3R_146()) {\n            return true;\n        }\n        if (jj_scan_token(WHILE)) {\n            return true;\n        }\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        if (jj_scan_token(RPAREN)) {\n            return true;\n        }\n        if (jj_scan_token(SEMICOLON)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_52() {\n        if (jj_scan_token(ABSTRACT)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_51() {\n        if (jj_scan_token(FINAL)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_50() {\n        if (jj_scan_token(PRIVATE)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_176() {\n        if (jj_scan_token(WHILE)) {\n            return true;\n        }\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        if (jj_scan_token(RPAREN)) {\n            return true;\n        }\n        if (jj_3R_146()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_49() {\n        if (jj_scan_token(PROTECTED)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_48() {\n        if (jj_scan_token(STATIC)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_295() {\n        if (jj_3R_133()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_47() {\n        if (jj_scan_token(PUBLIC)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_175() {\n        if (jj_scan_token(IF)) {\n            return true;\n        }\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        if (jj_scan_token(RPAREN)) {\n            return true;\n        }\n        if (jj_3R_146()) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_285()) {\n            jj_scanpos = xsp;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_1() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_47()) {\n            jj_scanpos = xsp;\n            if (jj_3R_48()) {\n                jj_scanpos = xsp;\n                if (jj_3R_49()) {\n                    jj_scanpos = xsp;\n                    if (jj_3R_50()) {\n                        jj_scanpos = xsp;\n                        if (jj_3R_51()) {\n                            jj_scanpos = xsp;\n                            if (jj_3R_52()) {\n                                jj_scanpos = xsp;\n                                if (jj_3R_53()) {\n                                    jj_scanpos = xsp;\n                                    if (jj_3R_54()) {\n                                        jj_scanpos = xsp;\n                                        if (jj_3R_55()) {\n                                            jj_scanpos = xsp;\n                                            if (jj_3R_56()) {\n                                                jj_scanpos = xsp;\n                                                if (jj_3R_57()) {\n                                                    jj_scanpos = xsp;\n                                                    if (jj_3R_58()) {\n                                                        return true;\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_220() {\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3_1()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_301() {\n        if (jj_scan_token(_DEFAULT)) {\n            return true;\n        }\n        if (jj_scan_token(COLON)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_300() {\n        if (jj_scan_token(CASE)) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        if (jj_scan_token(COLON)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_294() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_300()) {\n            jj_scanpos = xsp;\n            if (jj_3R_301()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_279() {\n        if (jj_scan_token(COMMA)) {\n            return true;\n        }\n        if (jj_3R_246()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_284() {\n        if (jj_3R_294()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_295()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_174() {\n        if (jj_scan_token(SWITCH)) {\n            return true;\n        }\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        if (jj_scan_token(RPAREN)) {\n            return true;\n        }\n        if (jj_scan_token(LBRACE)) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_284()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        if (jj_scan_token(RBRACE)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_299() {\n        if (jj_3R_69()) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_293() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(99)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(100)) {\n                jj_scanpos = xsp;\n                if (jj_3R_299()) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_189() {\n        if (jj_3R_65()) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_293()) {\n            jj_scanpos = xsp;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_188() {\n        if (jj_3R_198()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_173() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_187()) {\n            jj_scanpos = xsp;\n            if (jj_3R_188()) {\n                jj_scanpos = xsp;\n                if (jj_3R_189()) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_187() {\n        if (jj_3R_197()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_172() {\n        if (jj_scan_token(SEMICOLON)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_145() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(31)) {\n            jj_scanpos = xsp;\n        }\n        if (jj_3R_60()) {\n            return true;\n        }\n        if (jj_3R_246()) {\n            return true;\n        }\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_279()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3_34() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(31)) {\n            jj_scanpos = xsp;\n        }\n        if (jj_3R_60()) {\n            return true;\n        }\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_283() {\n        if (jj_scan_token(COLON)) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_140() {\n        if (jj_3R_147()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_139() {\n        if (jj_3R_146()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_138() {\n        if (jj_3R_145()) {\n            return true;\n        }\n        if (jj_scan_token(SEMICOLON)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_133() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_138()) {\n            jj_scanpos = xsp;\n            if (jj_3R_139()) {\n                jj_scanpos = xsp;\n                if (jj_3R_140()) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_114() {\n        if (jj_3R_133()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_86() {\n        if (jj_scan_token(LBRACE)) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_114()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        if (jj_scan_token(RBRACE)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_79() {\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        if (jj_scan_token(COLON)) {\n            return true;\n        }\n        if (jj_3R_146()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_171() {\n        if (jj_scan_token(ASSERT)) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_283()) {\n            jj_scanpos = xsp;\n        }\n        if (jj_scan_token(SEMICOLON)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_166() {\n        if (jj_3R_184()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_165() {\n        if (jj_3R_183()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_31() {\n        if (jj_scan_token(LBRACKET)) {\n            return true;\n        }\n        if (jj_scan_token(RBRACKET)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_164() {\n        if (jj_3R_182()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_163() {\n        if (jj_3R_181()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_162() {\n        if (jj_3R_180()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_161() {\n        if (jj_3R_179()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_160() {\n        if (jj_3R_178()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_159() {\n        if (jj_3R_177()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_158() {\n        if (jj_3R_176()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_157() {\n        if (jj_3R_175()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_156() {\n        if (jj_3R_174()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_155() {\n        if (jj_3R_173()) {\n            return true;\n        }\n        if (jj_scan_token(SEMICOLON)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_154() {\n        if (jj_3R_172()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_153() {\n        if (jj_3R_86()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_152() {\n        if (jj_3R_171()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_191() {\n        if (jj_3R_68()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_33() {\n        if (jj_3R_79()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_146() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3_33()) {\n            jj_scanpos = xsp;\n            if (jj_3R_152()) {\n                jj_scanpos = xsp;\n                if (jj_3R_153()) {\n                    jj_scanpos = xsp;\n                    if (jj_3R_154()) {\n                        jj_scanpos = xsp;\n                        if (jj_3R_155()) {\n                            jj_scanpos = xsp;\n                            if (jj_3R_156()) {\n                                jj_scanpos = xsp;\n                                if (jj_3R_157()) {\n                                    jj_scanpos = xsp;\n                                    if (jj_3R_158()) {\n                                        jj_scanpos = xsp;\n                                        if (jj_3R_159()) {\n                                            jj_scanpos = xsp;\n                                            if (jj_3R_160()) {\n                                                jj_scanpos = xsp;\n                                                if (jj_3R_161()) {\n                                                    jj_scanpos = xsp;\n                                                    if (jj_3R_162()) {\n                                                        jj_scanpos = xsp;\n                                                        if (jj_3R_163()) {\n                                                            jj_scanpos = xsp;\n                                                            if (jj_3R_164()) {\n                                                                jj_scanpos = xsp;\n                                                                if (jj_3R_165()) {\n                                                                    jj_scanpos = xsp;\n                                                                    if (jj_3R_166()) {\n                                                                        return true;\n                                                                    }\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_200() {\n        if (jj_3R_205()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_204() {\n        if (jj_scan_token(LBRACKET)) {\n            return true;\n        }\n        if (jj_scan_token(RBRACKET)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_30() {\n        if (jj_scan_token(LBRACKET)) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        if (jj_scan_token(RBRACKET)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_199() {\n        Token xsp;\n        if (jj_3R_204()) {\n            return true;\n        }\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_204()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        if (jj_3R_115()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_32() {\n        Token xsp;\n        if (jj_3_30()) {\n            return true;\n        }\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3_30()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3_31()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_190() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3_32()) {\n            jj_scanpos = xsp;\n            if (jj_3R_199()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_193() {\n        if (jj_3R_66()) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_200()) {\n            jj_scanpos = xsp;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_135() {\n        if (jj_scan_token(COMMA)) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_192() {\n        if (jj_3R_190()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_105() {\n        if (jj_scan_token(NEW)) {\n            return true;\n        }\n        if (jj_3R_123()) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_191()) {\n            jj_scanpos = xsp;\n        }\n        xsp = jj_scanpos;\n        if (jj_3R_192()) {\n            jj_scanpos = xsp;\n            if (jj_3R_193()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3_29() {\n        if (jj_scan_token(NEW)) {\n            return true;\n        }\n        if (jj_3R_74()) {\n            return true;\n        }\n        if (jj_3R_190()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_77() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3_29()) {\n            jj_scanpos = xsp;\n            if (jj_3R_105()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_122() {\n        if (jj_3R_70()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_135()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_92() {\n        if (jj_3R_122()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_66() {\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_92()) {\n            jj_scanpos = xsp;\n        }\n        if (jj_scan_token(RPAREN)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_149() {\n        if (jj_scan_token(NULL)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_148() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(61)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(30)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_142() {\n        if (jj_3R_149()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_141() {\n        if (jj_3R_148()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_127() {\n        if (jj_3R_134()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_134() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(66)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(70)) {\n                jj_scanpos = xsp;\n                if (jj_scan_token(72)) {\n                    jj_scanpos = xsp;\n                    if (jj_scan_token(73)) {\n                        jj_scanpos = xsp;\n                        if (jj_3R_141()) {\n                            jj_scanpos = xsp;\n                            if (jj_3R_142()) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_103() {\n        if (jj_3R_66()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_102() {\n        if (jj_scan_token(DOT)) {\n            return true;\n        }\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_101() {\n        if (jj_scan_token(LBRACKET)) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        if (jj_scan_token(RBRACKET)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_28() {\n        if (jj_3R_78()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_27() {\n        if (jj_scan_token(DOT)) {\n            return true;\n        }\n        if (jj_3R_77()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_25() {\n        if (jj_3R_76()) {\n            return true;\n        }\n        if (jj_scan_token(DOT)) {\n            return true;\n        }\n        if (jj_scan_token(CLASS)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_26() {\n        if (jj_scan_token(DOT)) {\n            return true;\n        }\n        if (jj_scan_token(THIS)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_75() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3_26()) {\n            jj_scanpos = xsp;\n            if (jj_3_27()) {\n                jj_scanpos = xsp;\n                if (jj_3_28()) {\n                    jj_scanpos = xsp;\n                    if (jj_3R_101()) {\n                        jj_scanpos = xsp;\n                        if (jj_3R_102()) {\n                            jj_scanpos = xsp;\n                            if (jj_3R_103()) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_121() {\n        if (jj_3R_80()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_120() {\n        if (jj_3R_76()) {\n            return true;\n        }\n        if (jj_scan_token(DOT)) {\n            return true;\n        }\n        if (jj_scan_token(CLASS)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_119() {\n        if (jj_3R_77()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_118() {\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        if (jj_scan_token(RPAREN)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_24() {\n        if (jj_3R_75()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_117() {\n        if (jj_scan_token(SUPER)) {\n            return true;\n        }\n        if (jj_scan_token(DOT)) {\n            return true;\n        }\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_116() {\n        if (jj_3R_134()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_91() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_116()) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(57)) {\n                jj_scanpos = xsp;\n                if (jj_3R_117()) {\n                    jj_scanpos = xsp;\n                    if (jj_3R_118()) {\n                        jj_scanpos = xsp;\n                        if (jj_3R_119()) {\n                            jj_scanpos = xsp;\n                            if (jj_3R_120()) {\n                                jj_scanpos = xsp;\n                                if (jj_3R_121()) {\n                                    return true;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_282() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(99)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(100)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_78() {\n        if (jj_scan_token(DOT)) {\n            return true;\n        }\n        if (jj_3R_68()) {\n            return true;\n        }\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_23() {\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        if (jj_3R_74()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_65() {\n        if (jj_3R_91()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3_24()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_278() {\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        if (jj_3R_60()) {\n            return true;\n        }\n        if (jj_scan_token(RPAREN)) {\n            return true;\n        }\n        if (jj_3R_235()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_277() {\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        if (jj_3R_60()) {\n            return true;\n        }\n        if (jj_scan_token(RPAREN)) {\n            return true;\n        }\n        if (jj_3R_219()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_266() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_277()) {\n            jj_scanpos = xsp;\n            if (jj_3R_278()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3_22() {\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        if (jj_3R_60()) {\n            return true;\n        }\n        if (jj_scan_token(LBRACKET)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_267() {\n        if (jj_3R_65()) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_282()) {\n            jj_scanpos = xsp;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_100() {\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        if (jj_3R_60()) {\n            return true;\n        }\n        if (jj_scan_token(RPAREN)) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(90)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(89)) {\n                jj_scanpos = xsp;\n                if (jj_scan_token(77)) {\n                    jj_scanpos = xsp;\n                    if (jj_scan_token(74)) {\n                        jj_scanpos = xsp;\n                        if (jj_scan_token(57)) {\n                            jj_scanpos = xsp;\n                            if (jj_scan_token(54)) {\n                                jj_scanpos = xsp;\n                                if (jj_scan_token(44)) {\n                                    jj_scanpos = xsp;\n                                    if (jj_3R_127()) {\n                                        return true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_99() {\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        if (jj_3R_60()) {\n            return true;\n        }\n        if (jj_scan_token(LBRACKET)) {\n            return true;\n        }\n        if (jj_scan_token(RBRACKET)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_21() {\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        if (jj_3R_74()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_73() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3_21()) {\n            jj_scanpos = xsp;\n            if (jj_3R_99()) {\n                jj_scanpos = xsp;\n                if (jj_3R_100()) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3_20() {\n        if (jj_3R_73()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_19() {\n        if (jj_3R_72()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_255() {\n        if (jj_3R_267()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_254() {\n        if (jj_3R_266()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_235() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_253()) {\n            jj_scanpos = xsp;\n            if (jj_3R_254()) {\n                jj_scanpos = xsp;\n                if (jj_3R_255()) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_253() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(90)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(89)) {\n                return true;\n            }\n        }\n        if (jj_3R_219()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_198() {\n        if (jj_scan_token(DECR)) {\n            return true;\n        }\n        if (jj_3R_65()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_234() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(101)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(102)) {\n                return true;\n            }\n        }\n        if (jj_3R_216()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_18() {\n        if (jj_3R_71()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_252() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(103)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(104)) {\n                jj_scanpos = xsp;\n                if (jj_scan_token(108)) {\n                    return true;\n                }\n            }\n        }\n        if (jj_3R_219()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_197() {\n        if (jj_scan_token(INCR)) {\n            return true;\n        }\n        if (jj_3R_65()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_229() {\n        if (jj_3R_235()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_17() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(109)) {\n            jj_scanpos = xsp;\n            if (jj_3_18()) {\n                jj_scanpos = xsp;\n                if (jj_3_19()) {\n                    return true;\n                }\n            }\n        }\n        if (jj_3R_213()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_228() {\n        if (jj_3R_198()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_227() {\n        if (jj_3R_197()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_219() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_226()) {\n            jj_scanpos = xsp;\n            if (jj_3R_227()) {\n                jj_scanpos = xsp;\n                if (jj_3R_228()) {\n                    jj_scanpos = xsp;\n                    if (jj_3R_229()) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_226() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(101)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(102)) {\n                return true;\n            }\n        }\n        if (jj_3R_219()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_218() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(88)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(124)) {\n                jj_scanpos = xsp;\n                if (jj_scan_token(94)) {\n                    jj_scanpos = xsp;\n                    if (jj_scan_token(95)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        if (jj_3R_207()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_215() {\n        if (jj_scan_token(INSTANCEOF)) {\n            return true;\n        }\n        if (jj_3R_60()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_216() {\n        if (jj_3R_219()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_252()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_212() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(93)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(96)) {\n                return true;\n            }\n        }\n        if (jj_3R_195()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_213() {\n        if (jj_3R_216()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_234()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_207() {\n        if (jj_3R_213()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3_17()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_206() {\n        if (jj_scan_token(BIT_AND)) {\n            return true;\n        }\n        if (jj_3R_186()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_202() {\n        if (jj_3R_207()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_218()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_194() {\n        if (jj_scan_token(BIT_OR)) {\n            return true;\n        }\n        if (jj_3R_151()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_195() {\n        if (jj_3R_202()) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_215()) {\n            jj_scanpos = xsp;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_201() {\n        if (jj_scan_token(XOR)) {\n            return true;\n        }\n        if (jj_3R_169()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_185() {\n        if (jj_scan_token(SC_AND)) {\n            return true;\n        }\n        if (jj_3R_143()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_186() {\n        if (jj_3R_195()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_212()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_168() {\n        if (jj_scan_token(SC_OR)) {\n            return true;\n        }\n        if (jj_3R_136()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_169() {\n        if (jj_3R_186()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_206()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_150() {\n        if (jj_scan_token(HOOK)) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        if (jj_scan_token(COLON)) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_151() {\n        if (jj_3R_169()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_201()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_143() {\n        if (jj_3R_151()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_194()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_136() {\n        if (jj_3R_143()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_185()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_126() {\n        if (jj_3R_136()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_168()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_96() {\n        if (jj_3R_126()) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_150()) {\n            jj_scanpos = xsp;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_69() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(87)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(112)) {\n                jj_scanpos = xsp;\n                if (jj_scan_token(113)) {\n                    jj_scanpos = xsp;\n                    if (jj_scan_token(117)) {\n                        jj_scanpos = xsp;\n                        if (jj_scan_token(110)) {\n                            jj_scanpos = xsp;\n                            if (jj_scan_token(111)) {\n                                jj_scanpos = xsp;\n                                if (jj_scan_token(118)) {\n                                    jj_scanpos = xsp;\n                                    if (jj_scan_token(119)) {\n                                        jj_scanpos = xsp;\n                                        if (jj_scan_token(120)) {\n                                            jj_scanpos = xsp;\n                                            if (jj_scan_token(114)) {\n                                                jj_scanpos = xsp;\n                                                if (jj_scan_token(116)) {\n                                                    jj_scanpos = xsp;\n                                                    if (jj_scan_token(115)) {\n                                                        return true;\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3_16() {\n        if (jj_3R_69()) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_70() {\n        if (jj_3R_96()) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3_16()) {\n            jj_scanpos = xsp;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_275() {\n        if (jj_scan_token(COMMA)) {\n            return true;\n        }\n        if (jj_3R_80()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_262() {\n        if (jj_3R_80()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_275()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3_15() {\n        if (jj_scan_token(DOT)) {\n            return true;\n        }\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_80() {\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3_15()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_104() {\n        if (jj_3R_60()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_76() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(63)) {\n            jj_scanpos = xsp;\n            if (jj_3R_104()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3_14() {\n        if (jj_3R_68()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_74() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(15)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(20)) {\n                jj_scanpos = xsp;\n                if (jj_scan_token(17)) {\n                    jj_scanpos = xsp;\n                    if (jj_scan_token(51)) {\n                        jj_scanpos = xsp;\n                        if (jj_scan_token(40)) {\n                            jj_scanpos = xsp;\n                            if (jj_scan_token(42)) {\n                                jj_scanpos = xsp;\n                                if (jj_scan_token(33)) {\n                                    jj_scanpos = xsp;\n                                    if (jj_scan_token(26)) {\n                                        return true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_170() {\n        if (jj_scan_token(COMMA)) {\n            return true;\n        }\n        if (jj_3R_95()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_11() {\n        if (jj_scan_token(LBRACKET)) {\n            return true;\n        }\n        if (jj_scan_token(RBRACKET)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_209() {\n        if (jj_scan_token(SUPER)) {\n            return true;\n        }\n        if (jj_3R_67()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_196() {\n        if (jj_3R_203()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_203() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_208()) {\n            jj_scanpos = xsp;\n            if (jj_3R_209()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_208() {\n        if (jj_scan_token(EXTENDS)) {\n            return true;\n        }\n        if (jj_3R_67()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_125() {\n        if (jj_scan_token(HOOK)) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_196()) {\n            jj_scanpos = xsp;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_12() {\n        if (jj_3R_68()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_124() {\n        if (jj_3R_67()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_95() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_124()) {\n            jj_scanpos = xsp;\n            if (jj_3R_125()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3_10() {\n        if (jj_scan_token(LBRACKET)) {\n            return true;\n        }\n        if (jj_scan_token(RBRACKET)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_68() {\n        if (jj_scan_token(LT)) {\n            return true;\n        }\n        if (jj_3R_95()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_170()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        if (jj_scan_token(GT)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_13() {\n        if (jj_scan_token(DOT)) {\n            return true;\n        }\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3_14()) {\n            jj_scanpos = xsp;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_123() {\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3_12()) {\n            jj_scanpos = xsp;\n        }\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3_13()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    public JavaParserTokenManager token_source;\n\n    JavaCharStream jj_input_stream;\n\n    public Token token, jj_nt;\n\n    private int jj_ntk;\n\n    private Token jj_scanpos, jj_lastpos;\n\n    private int jj_la;\n\n    public boolean lookingAhead = false;\n\n    private boolean jj_semLA;\n\n    public JavaParser(java.io.InputStream stream) {\n        jj_input_stream = new JavaCharStream(stream, 1, 1);\n        token_source = new JavaParserTokenManager(jj_input_stream);\n        token = new Token();\n        jj_ntk = -1;\n    }\n\n    public void ReInit(java.io.InputStream stream) {\n        jj_input_stream.ReInit(stream, 1, 1);\n        token_source.ReInit(jj_input_stream);\n        token = new Token();\n        jj_ntk = -1;\n        jjtree.reset();\n    }\n\n    public JavaParser(java.io.Reader stream) {\n        jj_input_stream = new JavaCharStream(stream, 1, 1);\n        token_source = new JavaParserTokenManager(jj_input_stream);\n        token = new Token();\n        jj_ntk = -1;\n    }\n\n    public void ReInit(java.io.Reader stream) {\n        jj_input_stream.ReInit(stream, 1, 1);\n        token_source.ReInit(jj_input_stream);\n        token = new Token();\n        jj_ntk = -1;\n        jjtree.reset();\n    }\n\n    public JavaParser(JavaParserTokenManager tm) {\n        token_source = tm;\n        token = new Token();\n        jj_ntk = -1;\n    }\n\n    public void ReInit(JavaParserTokenManager tm) {\n        token_source = tm;\n        token = new Token();\n        jj_ntk = -1;\n        jjtree.reset();\n    }\n\n    final private Token jj_consume_token(int kind) throws ParseException {\n        Token oldToken;\n        if ((oldToken = token).next != null) {\n            token = token.next;\n        } else {\n            token = token.next = token_source.getNextToken();\n        }\n        jj_ntk = -1;\n        // << to do >> cleasn up the remarked out code\n        // these are the literals\n        if (token.kind >= 66 && token.kind <= 74) {\n            if (currNode != null) {\n                //      currNode.setIdentifier( token.toString());\n                //       setNode(true);\n            }\n        }\n        if (token.kind == kind) {\n            //         if (!nodeIsSet) {\n            currNode.setIdentifier(token.toString());\n            //   setNode(true);\n            //         }\n            return token;\n        }\n        token = oldToken;\n        throw generateParseException();\n    }\n\n    static private final class LookaheadSuccess extends java.lang.Error {\n    }\n\n    final private LookaheadSuccess jj_ls = new LookaheadSuccess();\n\n    final private boolean jj_scan_token(int kind) {\n        if (jj_scanpos == jj_lastpos) {\n            jj_la--;\n            if (jj_scanpos.next == null) {\n                jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();\n            } else {\n                jj_lastpos = jj_scanpos = jj_scanpos.next;\n            }\n        } else {\n            jj_scanpos = jj_scanpos.next;\n        }\n        if (jj_scanpos.kind != kind) {\n            return true;\n        }\n        if (jj_la == 0 && jj_scanpos == jj_lastpos) {\n            throw jj_ls;\n        }\n        return false;\n    }\n\n    final public Token getNextToken() {\n        if (token.next != null) {\n            token = token.next;\n        } else {\n            token = token.next = token_source.getNextToken();\n        }\n        jj_ntk = -1;\n        return token;\n    }\n\n    final public Token getToken(int index) {\n        Token t = lookingAhead ? jj_scanpos : token;\n        for (int i = 0; i < index; i++) {\n            if (t.next != null) {\n                t = t.next;\n            } else {\n                t = t.next = token_source.getNextToken();\n            }\n        }\n        return t;\n    }\n\n    final private int jj_ntk() {\n        if ((jj_nt = token.next) == null) {\n            return (jj_ntk = (token.next = token_source.getNextToken()).kind);\n        } else {\n            return (jj_ntk = jj_nt.kind);\n        }\n    }\n\n    public ParseException generateParseException() {\n        Token errortok = token.next;\n        int line = errortok.beginLine, column = errortok.beginColumn;\n        String mess = (errortok.kind == 0) ? tokenImage[0] : errortok.image;\n        return new ParseException(\"Parse error at line \" + line + \", column \" + column + \".  Encountered: \" + mess);\n    }\n\n    final public void enable_tracing() {\n    }\n\n    final public void disable_tracing() {\n    }\n}\n",
		"id": "EvoSuiteBenchmark/19_jmca/src/main/java/com/soops/CEN4010/JMCA/JParser/JavaParserTest0.java",
		"test_prompt": "// JavaParserTest0.java\npackage com.soops.CEN4010.JMCA.JParser;\n\n/* Generated By:JJTree&JavaCC: Do not edit this line. JavaParser.java */\nimport java.io.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JavaParser}.\n* It contains ten unit test cases for the {@link JavaParser#Modifiers()} method.\n*/\nclass JavaParserTest0 {"
	},
	{
		"original_code": "// JavaParser.java\npackage com.soops.CEN4010.JMCA.JParser;\n\n/* Generated By:JJTree&JavaCC: Do not edit this line. JavaParser.java */\nimport java.io.*;\n\n/**\n * Grammar to parse Java version 1.5\n * @author Sreenivasa Viswanadha - Simplified and enhanced for 1.5\n */\npublic class JavaParser implements /*@bgen(jjtree)*/\nJavaParserTreeConstants, JavaParserConstants {\n\n    /*@bgen(jjtree)*/\n    JJTJavaParserState jjtree = new JJTJavaParserState();\n\n    /**\n     * Class to hold modifiers.\n     */\n    /**\n     *  currNode is the current node of the tree - it is set in simplenode\n     *   has package access fro ease of use\n     */\n    Node currNode = null;\n\n    // << to do >> cleasn up the remarked out code\n    /**\n     *   nodeIsSet is a flag used to determine which token string value to use\n     */\n    //    boolean nodeIsSet = false;\n    //    public void setNode(boolean condition) {\n    //       nodeIsSet = condition;\n    //   }\n    static public final class ModifierSet {\n\n        /* Definitions of the bits in the modifiers field.  */\n        public static final int PUBLIC = 0x0001;\n\n        public static final int PROTECTED = 0x0002;\n\n        public static final int PRIVATE = 0x0004;\n\n        public static final int ABSTRACT = 0x0008;\n\n        public static final int STATIC = 0x0010;\n\n        public static final int FINAL = 0x0020;\n\n        public static final int SYNCHRONIZED = 0x0040;\n\n        public static final int NATIVE = 0x0080;\n\n        public static final int TRANSIENT = 0x0100;\n\n        public static final int VOLATILE = 0x0200;\n\n        public static final int STRICTFP = 0x1000;\n\n        /**\n         * A set of accessors that indicate whether the specified modifier\n         *            is in the set.\n         */\n        public boolean isPublic(int modifiers) {\n            return (modifiers & PUBLIC) != 0;\n        }\n\n        public boolean isProtected(int modifiers) {\n            return (modifiers & PROTECTED) != 0;\n        }\n\n        public boolean isPrivate(int modifiers) {\n            return (modifiers & PRIVATE) != 0;\n        }\n\n        public boolean isStatic(int modifiers) {\n            return (modifiers & STATIC) != 0;\n        }\n\n        public boolean isAbstract(int modifiers) {\n            return (modifiers & ABSTRACT) != 0;\n        }\n\n        public boolean isFinal(int modifiers) {\n            return (modifiers & FINAL) != 0;\n        }\n\n        public boolean isNative(int modifiers) {\n            return (modifiers & NATIVE) != 0;\n        }\n\n        public boolean isStrictfp(int modifiers) {\n            return (modifiers & STRICTFP) != 0;\n        }\n\n        public boolean isSynchronized(int modifiers) {\n            return (modifiers & SYNCHRONIZED) != 0;\n        }\n\n        public boolean isTransient(int modifiers) {\n            return (modifiers & TRANSIENT) != 0;\n        }\n\n        public boolean isVolatile(int modifiers) {\n            return (modifiers & VOLATILE) != 0;\n        }\n\n        /**\n         * Removes the given modifier.\n         */\n        static int removeModifier(int modifiers, int mod) {\n            return modifiers & ~mod;\n        }\n    }\n\n    public JavaParser(String fileName) {\n        this(System.in);\n        try {\n            ReInit(new FileInputStream(new File(fileName)));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void dump(Writer wtr) {\n        try {\n            ((SimpleNode) this.jjtree.rootNode()).dump(\"root\", wtr);\n        } catch (IOException ie) {\n            System.err.println(ie.getMessage());\n        }\n    }\n\n    public static void main(String[] args) {\n        JavaParser parser = null;\n        //    Writer wtr = new java.io.PrintWriter(System.out);\n        if (args.length == 0) {\n            System.out.println(\"Java Parser Version 1.1:  Reading from standard input . . .\");\n            parser = new JavaParser(System.in);\n        } else if (args.length == 1) {\n            //    System.out.println(\"Java Parser Version 1.1:  Reading from file \" +\n            //                      args[0] + \" . . .\");\n            try {\n                parser = new JavaParser(new java.io.FileInputStream(args[0]));\n            } catch (java.io.FileNotFoundException e) {\n                System.out.println(\"Java Parser Version 1.1:  File \" + args[0] + \" not found.\");\n                return;\n            }\n        } else {\n            System.out.println(\"Java Parser Version 1.1:  Usage is one of:\");\n            System.out.println(\"         java JavaParser < inputfile\");\n            System.out.println(\"OR\");\n            System.out.println(\"         java JavaParser inputfile\");\n            return;\n        }\n        try {\n            parser.CompilationUnit();\n            Writer wtr = new PrintWriter(System.out);\n            wtr.write(\"<?xml version='1.0' encoding='ISO-8859-1' ?>\");\n            ((SimpleNode) parser.jjtree.rootNode()).dump(\"root\", wtr);\n            //    System.out.println(\n            //           \"Java Parser Version 1.1:  Java program parsed successfully.\");\n        } catch (ParseException e) {\n            System.out.println(e.getMessage());\n            System.out.println(\"Java Parser Version 1.1:  Encountered errors during parse.\");\n        } catch (IOException ie) {\n        }\n    }\n\n    /**\n     * **************************************\n     *  THE JAVA LANGUAGE GRAMMAR STARTS HERE *\n     * ***************************************\n     */\n    /*\n     * Program structuring syntax follows.\n     */\n    final public void CompilationUnit() throws ParseException {\n        /*@bgen(jjtree) CompilationUnit */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTCOMPILATIONUNIT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case PACKAGE:\n                    PackageDeclaration();\n                    break;\n                default:\n                    ;\n            }\n            label_1: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case IMPORT:\n                        ;\n                        break;\n                    default:\n                        break label_1;\n                }\n                ImportDeclaration();\n            }\n            label_2: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case ABSTRACT:\n                    case CLASS:\n                    case ENUM:\n                    case FINAL:\n                    case INTERFACE:\n                    case NATIVE:\n                    case PRIVATE:\n                    case PROTECTED:\n                    case PUBLIC:\n                    case STATIC:\n                    case STRICTFP:\n                    case SYNCHRONIZED:\n                    case TRANSIENT:\n                    case VOLATILE:\n                    case SEMICOLON:\n                    case AT:\n                        ;\n                        break;\n                    default:\n                        break label_2;\n                }\n                TypeDeclaration();\n            }\n            jj_consume_token(0);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void PackageDeclaration() throws ParseException {\n        /*@bgen(jjtree) PackageDeclaration */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTPACKAGEDECLARATION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(PACKAGE);\n            Name();\n            jj_consume_token(SEMICOLON);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ImportDeclaration() throws ParseException {\n        /*@bgen(jjtree) ImportDeclaration */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTIMPORTDECLARATION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(IMPORT);\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case STATIC:\n                    jj_consume_token(STATIC);\n                    break;\n                default:\n                    ;\n            }\n            Name();\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case DOT:\n                    jj_consume_token(DOT);\n                    jj_consume_token(STAR);\n                    break;\n                default:\n                    ;\n            }\n            jj_consume_token(SEMICOLON);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    /*\n     * Modifiers. We match all modifiers in a single rule to reduce the chances of\n     * syntax errors for simple modifier mistakes. It will also enable us to give\n     * better error messages.\n     */\n    final public int Modifiers() throws ParseException {\n        /*@bgen(jjtree) Modifiers */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTMODIFIERS);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        int modifiers = 0;\n        try {\n            label_3: while (true) {\n                if (jj_2_1(2)) {\n                    ;\n                } else {\n                    break label_3;\n                }\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case PUBLIC:\n                        jj_consume_token(PUBLIC);\n                        modifiers |= ModifierSet.PUBLIC;\n                        break;\n                    case STATIC:\n                        jj_consume_token(STATIC);\n                        modifiers |= ModifierSet.STATIC;\n                        break;\n                    case PROTECTED:\n                        jj_consume_token(PROTECTED);\n                        modifiers |= ModifierSet.PROTECTED;\n                        break;\n                    case PRIVATE:\n                        jj_consume_token(PRIVATE);\n                        modifiers |= ModifierSet.PRIVATE;\n                        break;\n                    case FINAL:\n                        jj_consume_token(FINAL);\n                        modifiers |= ModifierSet.FINAL;\n                        break;\n                    case ABSTRACT:\n                        jj_consume_token(ABSTRACT);\n                        modifiers |= ModifierSet.ABSTRACT;\n                        break;\n                    case SYNCHRONIZED:\n                        jj_consume_token(SYNCHRONIZED);\n                        modifiers |= ModifierSet.SYNCHRONIZED;\n                        break;\n                    case NATIVE:\n                        jj_consume_token(NATIVE);\n                        modifiers |= ModifierSet.NATIVE;\n                        break;\n                    case TRANSIENT:\n                        jj_consume_token(TRANSIENT);\n                        modifiers |= ModifierSet.TRANSIENT;\n                        break;\n                    case VOLATILE:\n                        jj_consume_token(VOLATILE);\n                        modifiers |= ModifierSet.VOLATILE;\n                        break;\n                    case STRICTFP:\n                        jj_consume_token(STRICTFP);\n                        modifiers |= ModifierSet.STRICTFP;\n                        break;\n                    case AT:\n                        Annotation();\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n            jjtree.closeNodeScope(jjtn000, true);\n            jjtc000 = false;\n            {\n                if (true) {\n                    return modifiers;\n                }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n        throw new Error(\"Missing return statement in function\");\n    }\n\n    /*\n     * Declaration syntax follows.\n     */\n    final public void TypeDeclaration() throws ParseException {\n        /*@bgen(jjtree) TypeDeclaration */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTTYPEDECLARATION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        int modifiers;\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case SEMICOLON:\n                    jj_consume_token(SEMICOLON);\n                    break;\n                case ABSTRACT:\n                case CLASS:\n                case ENUM:\n                case FINAL:\n                case INTERFACE:\n                case NATIVE:\n                case PRIVATE:\n                case PROTECTED:\n                case PUBLIC:\n                case STATIC:\n                case STRICTFP:\n                case SYNCHRONIZED:\n                case TRANSIENT:\n                case VOLATILE:\n                case AT:\n                    modifiers = Modifiers();\n                    switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                        case CLASS:\n                        case INTERFACE:\n                            ClassOrInterfaceDeclaration(modifiers);\n                            break;\n                        case ENUM:\n                            EnumDeclaration(modifiers);\n                            break;\n                        case AT:\n                            AnnotationTypeDeclaration(modifiers);\n                            break;\n                        default:\n                            jj_consume_token(-1);\n                            throw new ParseException();\n                    }\n                    break;\n                default:\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ClassOrInterfaceDeclaration(int modifiers) throws ParseException {\n        /*@bgen(jjtree) ClassOrInterfaceDeclaration */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTCLASSORINTERFACEDECLARATION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        boolean isInterface = false;\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case CLASS:\n                    jj_consume_token(CLASS);\n                    break;\n                case INTERFACE:\n                    jj_consume_token(INTERFACE);\n                    isInterface = true;\n                    break;\n                default:\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n            jj_consume_token(IDENTIFIER);\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case LT:\n                    TypeParameters();\n                    break;\n                default:\n                    ;\n            }\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case EXTENDS:\n                    ExtendsList(isInterface);\n                    break;\n                default:\n                    ;\n            }\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case IMPLEMENTS:\n                    ImplementsList(isInterface);\n                    break;\n                default:\n                    ;\n            }\n            ClassOrInterfaceBody(isInterface);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ExtendsList(boolean isInterface) throws ParseException {\n        /*@bgen(jjtree) ExtendsList */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTEXTENDSLIST);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        boolean extendsMoreThanOne = false;\n        try {\n            jj_consume_token(EXTENDS);\n            ClassOrInterfaceType();\n            label_4: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case COMMA:\n                        ;\n                        break;\n                    default:\n                        break label_4;\n                }\n                jj_consume_token(COMMA);\n                ClassOrInterfaceType();\n                extendsMoreThanOne = true;\n            }\n            jjtree.closeNodeScope(jjtn000, true);\n            jjtc000 = false;\n            if (extendsMoreThanOne && !isInterface) {\n                if (true) {\n                    throw new ParseException(\"A class cannot extend more than one other class\");\n                }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ImplementsList(boolean isInterface) throws ParseException {\n        /*@bgen(jjtree) ImplementsList */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTIMPLEMENTSLIST);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(IMPLEMENTS);\n            ClassOrInterfaceType();\n            label_5: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case COMMA:\n                        ;\n                        break;\n                    default:\n                        break label_5;\n                }\n                jj_consume_token(COMMA);\n                ClassOrInterfaceType();\n            }\n            jjtree.closeNodeScope(jjtn000, true);\n            jjtc000 = false;\n            if (isInterface) {\n                if (true) {\n                    throw new ParseException(\"An interface cannot implement other interfaces\");\n                }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void EnumDeclaration(int modifiers) throws ParseException {\n        /*@bgen(jjtree) EnumDeclaration */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTENUMDECLARATION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(ENUM);\n            jj_consume_token(IDENTIFIER);\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case IMPLEMENTS:\n                    ImplementsList(false);\n                    break;\n                default:\n                    ;\n            }\n            EnumBody();\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void EnumBody() throws ParseException {\n        /*@bgen(jjtree) EnumBody */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTENUMBODY);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(LBRACE);\n            EnumConstant();\n            label_6: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case COMMA:\n                        ;\n                        break;\n                    default:\n                        break label_6;\n                }\n                jj_consume_token(COMMA);\n                EnumConstant();\n            }\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case SEMICOLON:\n                    jj_consume_token(SEMICOLON);\n                    label_7: while (true) {\n                        switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                            case ABSTRACT:\n                            case BOOLEAN:\n                            case BYTE:\n                            case CHAR:\n                            case CLASS:\n                            case DOUBLE:\n                            case ENUM:\n                            case FINAL:\n                            case FLOAT:\n                            case INT:\n                            case INTERFACE:\n                            case LONG:\n                            case NATIVE:\n                            case PRIVATE:\n                            case PROTECTED:\n                            case PUBLIC:\n                            case SHORT:\n                            case STATIC:\n                            case STRICTFP:\n                            case SYNCHRONIZED:\n                            case TRANSIENT:\n                            case VOID:\n                            case VOLATILE:\n                            case IDENTIFIER:\n                            case LBRACE:\n                            case SEMICOLON:\n                            case AT:\n                            case LT:\n                                ;\n                                break;\n                            default:\n                                break label_7;\n                        }\n                        ClassOrInterfaceBodyDeclaration(false);\n                    }\n                    break;\n                default:\n                    ;\n            }\n            jj_consume_token(RBRACE);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void EnumConstant() throws ParseException {\n        /*@bgen(jjtree) EnumConstant */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTENUMCONSTANT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(IDENTIFIER);\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case LPAREN:\n                    Arguments();\n                    break;\n                default:\n                    ;\n            }\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case LBRACE:\n                    ClassOrInterfaceBody(false);\n                    break;\n                default:\n                    ;\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void TypeParameters() throws ParseException {\n        /*@bgen(jjtree) TypeParameters */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTTYPEPARAMETERS);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(LT);\n            TypeParameter();\n            label_8: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case COMMA:\n                        ;\n                        break;\n                    default:\n                        break label_8;\n                }\n                jj_consume_token(COMMA);\n                TypeParameter();\n            }\n            jj_consume_token(GT);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void TypeParameter() throws ParseException {\n        /*@bgen(jjtree) TypeParameter */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTTYPEPARAMETER);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(IDENTIFIER);\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case EXTENDS:\n                    TypeBound();\n                    break;\n                default:\n                    ;\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void TypeBound() throws ParseException {\n        /*@bgen(jjtree) TypeBound */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTTYPEBOUND);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(EXTENDS);\n            ClassOrInterfaceType();\n            label_9: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case BIT_AND:\n                        ;\n                        break;\n                    default:\n                        break label_9;\n                }\n                jj_consume_token(BIT_AND);\n                ClassOrInterfaceType();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ClassOrInterfaceBody(boolean isInterface) throws ParseException {\n        /*@bgen(jjtree) ClassOrInterfaceBody */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTCLASSORINTERFACEBODY);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(LBRACE);\n            label_10: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case ABSTRACT:\n                    case BOOLEAN:\n                    case BYTE:\n                    case CHAR:\n                    case CLASS:\n                    case DOUBLE:\n                    case ENUM:\n                    case FINAL:\n                    case FLOAT:\n                    case INT:\n                    case INTERFACE:\n                    case LONG:\n                    case NATIVE:\n                    case PRIVATE:\n                    case PROTECTED:\n                    case PUBLIC:\n                    case SHORT:\n                    case STATIC:\n                    case STRICTFP:\n                    case SYNCHRONIZED:\n                    case TRANSIENT:\n                    case VOID:\n                    case VOLATILE:\n                    case IDENTIFIER:\n                    case LBRACE:\n                    case SEMICOLON:\n                    case AT:\n                    case LT:\n                        ;\n                        break;\n                    default:\n                        break label_10;\n                }\n                ClassOrInterfaceBodyDeclaration(isInterface);\n            }\n            jj_consume_token(RBRACE);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ClassOrInterfaceBodyDeclaration(boolean isInterface) throws ParseException {\n        /*@bgen(jjtree) ClassOrInterfaceBodyDeclaration */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTCLASSORINTERFACEBODYDECLARATION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        boolean isNestedInterface = false;\n        int modifiers;\n        try {\n            if (jj_2_4(2)) {\n                Initializer();\n                jjtree.closeNodeScope(jjtn000, true);\n                jjtc000 = false;\n                if (isInterface) {\n                    if (true) {\n                        throw new ParseException(\"An interface cannot have initializers\");\n                    }\n                }\n            } else {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case ABSTRACT:\n                    case BOOLEAN:\n                    case BYTE:\n                    case CHAR:\n                    case CLASS:\n                    case DOUBLE:\n                    case ENUM:\n                    case FINAL:\n                    case FLOAT:\n                    case INT:\n                    case INTERFACE:\n                    case LONG:\n                    case NATIVE:\n                    case PRIVATE:\n                    case PROTECTED:\n                    case PUBLIC:\n                    case SHORT:\n                    case STATIC:\n                    case STRICTFP:\n                    case SYNCHRONIZED:\n                    case TRANSIENT:\n                    case VOID:\n                    case VOLATILE:\n                    case IDENTIFIER:\n                    case AT:\n                    case LT:\n                        modifiers = Modifiers();\n                        switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                            case CLASS:\n                            case INTERFACE:\n                                ClassOrInterfaceDeclaration(modifiers);\n                                break;\n                            case ENUM:\n                                EnumDeclaration(modifiers);\n                                break;\n                            default:\n                                if (jj_2_2(2147483647)) {\n                                    ConstructorDeclaration();\n                                } else if (jj_2_3(2147483647)) {\n                                    FieldDeclaration(modifiers);\n                                } else {\n                                    switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                                        case BOOLEAN:\n                                        case BYTE:\n                                        case CHAR:\n                                        case DOUBLE:\n                                        case FLOAT:\n                                        case INT:\n                                        case LONG:\n                                        case SHORT:\n                                        case VOID:\n                                        case IDENTIFIER:\n                                        case LT:\n                                            MethodDeclaration(modifiers);\n                                            break;\n                                        default:\n                                            jj_consume_token(-1);\n                                            throw new ParseException();\n                                    }\n                                }\n                        }\n                        break;\n                    case SEMICOLON:\n                        jj_consume_token(SEMICOLON);\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void FieldDeclaration(int modifiers) throws ParseException {\n        /*@bgen(jjtree) FieldDeclaration */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTFIELDDECLARATION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            Type();\n            VariableDeclarator();\n            label_11: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case COMMA:\n                        ;\n                        break;\n                    default:\n                        break label_11;\n                }\n                jj_consume_token(COMMA);\n                VariableDeclarator();\n            }\n            jj_consume_token(SEMICOLON);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void VariableDeclarator() throws ParseException {\n        /*@bgen(jjtree) VariableDeclarator */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTVARIABLEDECLARATOR);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            VariableDeclaratorId();\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case ASSIGN:\n                    jj_consume_token(ASSIGN);\n                    VariableInitializer();\n                    break;\n                default:\n                    ;\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void VariableDeclaratorId() throws ParseException {\n        /*@bgen(jjtree) VariableDeclaratorId */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTVARIABLEDECLARATORID);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(IDENTIFIER);\n            label_12: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case LBRACKET:\n                        ;\n                        break;\n                    default:\n                        break label_12;\n                }\n                jj_consume_token(LBRACKET);\n                jj_consume_token(RBRACKET);\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void VariableInitializer() throws ParseException {\n        /*@bgen(jjtree) VariableInitializer */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTVARIABLEINITIALIZER);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case LBRACE:\n                    ArrayInitializer();\n                    break;\n                case BOOLEAN:\n                case BYTE:\n                case CHAR:\n                case DOUBLE:\n                case FALSE:\n                case FLOAT:\n                case INT:\n                case LONG:\n                case NEW:\n                case NULL:\n                case SHORT:\n                case SUPER:\n                case THIS:\n                case TRUE:\n                case VOID:\n                case INTEGER_LITERAL:\n                case FLOATING_POINT_LITERAL:\n                case CHARACTER_LITERAL:\n                case STRING_LITERAL:\n                case IDENTIFIER:\n                case LPAREN:\n                case BANG:\n                case TILDE:\n                case INCR:\n                case DECR:\n                case PLUS:\n                case MINUS:\n                    Expression();\n                    break;\n                default:\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ArrayInitializer() throws ParseException {\n        /*@bgen(jjtree) ArrayInitializer */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTARRAYINITIALIZER);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(LBRACE);\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case BOOLEAN:\n                case BYTE:\n                case CHAR:\n                case DOUBLE:\n                case FALSE:\n                case FLOAT:\n                case INT:\n                case LONG:\n                case NEW:\n                case NULL:\n                case SHORT:\n                case SUPER:\n                case THIS:\n                case TRUE:\n                case VOID:\n                case INTEGER_LITERAL:\n                case FLOATING_POINT_LITERAL:\n                case CHARACTER_LITERAL:\n                case STRING_LITERAL:\n                case IDENTIFIER:\n                case LPAREN:\n                case LBRACE:\n                case BANG:\n                case TILDE:\n                case INCR:\n                case DECR:\n                case PLUS:\n                case MINUS:\n                    VariableInitializer();\n                    label_13: while (true) {\n                        if (jj_2_5(2)) {\n                            ;\n                        } else {\n                            break label_13;\n                        }\n                        jj_consume_token(COMMA);\n                        VariableInitializer();\n                    }\n                    break;\n                default:\n                    ;\n            }\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case COMMA:\n                    jj_consume_token(COMMA);\n                    break;\n                default:\n                    ;\n            }\n            jj_consume_token(RBRACE);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void MethodDeclaration(int modifiers) throws ParseException {\n        /*@bgen(jjtree) MethodDeclaration */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTMETHODDECLARATION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case LT:\n                    TypeParameters();\n                    break;\n                default:\n                    ;\n            }\n            ResultType();\n            MethodDeclarator();\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case THROWS:\n                    jj_consume_token(THROWS);\n                    NameList();\n                    break;\n                default:\n                    ;\n            }\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case LBRACE:\n                    Block();\n                    break;\n                case SEMICOLON:\n                    jj_consume_token(SEMICOLON);\n                    break;\n                default:\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void MethodDeclarator() throws ParseException {\n        /*@bgen(jjtree) MethodDeclarator */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTMETHODDECLARATOR);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(IDENTIFIER);\n            FormalParameters();\n            label_14: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case LBRACKET:\n                        ;\n                        break;\n                    default:\n                        break label_14;\n                }\n                jj_consume_token(LBRACKET);\n                jj_consume_token(RBRACKET);\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void FormalParameters() throws ParseException {\n        /*@bgen(jjtree) FormalParameters */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTFORMALPARAMETERS);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(LPAREN);\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case BOOLEAN:\n                case BYTE:\n                case CHAR:\n                case DOUBLE:\n                case FINAL:\n                case FLOAT:\n                case INT:\n                case LONG:\n                case SHORT:\n                case IDENTIFIER:\n                    FormalParameter();\n                    label_15: while (true) {\n                        switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                            case COMMA:\n                                ;\n                                break;\n                            default:\n                                break label_15;\n                        }\n                        jj_consume_token(COMMA);\n                        FormalParameter();\n                    }\n                    break;\n                default:\n                    ;\n            }\n            jj_consume_token(RPAREN);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void FormalParameter() throws ParseException {\n        /*@bgen(jjtree) FormalParameter */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTFORMALPARAMETER);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case FINAL:\n                    jj_consume_token(FINAL);\n                    break;\n                default:\n                    ;\n            }\n            Type();\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case ELLIPSIS:\n                    jj_consume_token(ELLIPSIS);\n                    break;\n                default:\n                    ;\n            }\n            VariableDeclaratorId();\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ConstructorDeclaration() throws ParseException {\n        /*@bgen(jjtree) ConstructorDeclaration */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTCONSTRUCTORDECLARATION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case LT:\n                    TypeParameters();\n                    break;\n                default:\n                    ;\n            }\n            jj_consume_token(IDENTIFIER);\n            FormalParameters();\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case THROWS:\n                    jj_consume_token(THROWS);\n                    NameList();\n                    break;\n                default:\n                    ;\n            }\n            jj_consume_token(LBRACE);\n            if (jj_2_6(2147483647)) {\n                ExplicitConstructorInvocation();\n            } else {\n                ;\n            }\n            label_16: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case ASSERT:\n                    case BOOLEAN:\n                    case BREAK:\n                    case BYTE:\n                    case CHAR:\n                    case CLASS:\n                    case CONTINUE:\n                    case DO:\n                    case DOUBLE:\n                    case FALSE:\n                    case FINAL:\n                    case FLOAT:\n                    case FOR:\n                    case IF:\n                    case INT:\n                    case INTERFACE:\n                    case LONG:\n                    case NEW:\n                    case NULL:\n                    case RETURN:\n                    case SHORT:\n                    case SUPER:\n                    case SWITCH:\n                    case SYNCHRONIZED:\n                    case THIS:\n                    case THROW:\n                    case TRUE:\n                    case TRY:\n                    case VOID:\n                    case WHILE:\n                    case INTEGER_LITERAL:\n                    case FLOATING_POINT_LITERAL:\n                    case CHARACTER_LITERAL:\n                    case STRING_LITERAL:\n                    case IDENTIFIER:\n                    case LPAREN:\n                    case LBRACE:\n                    case SEMICOLON:\n                    case INCR:\n                    case DECR:\n                        ;\n                        break;\n                    default:\n                        break label_16;\n                }\n                BlockStatement();\n            }\n            jj_consume_token(RBRACE);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ExplicitConstructorInvocation() throws ParseException {\n        /*@bgen(jjtree) ExplicitConstructorInvocation */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTEXPLICITCONSTRUCTORINVOCATION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            if (jj_2_8(2147483647)) {\n                jj_consume_token(THIS);\n                Arguments();\n                jj_consume_token(SEMICOLON);\n            } else {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case BOOLEAN:\n                    case BYTE:\n                    case CHAR:\n                    case DOUBLE:\n                    case FALSE:\n                    case FLOAT:\n                    case INT:\n                    case LONG:\n                    case NEW:\n                    case NULL:\n                    case SHORT:\n                    case SUPER:\n                    case THIS:\n                    case TRUE:\n                    case VOID:\n                    case INTEGER_LITERAL:\n                    case FLOATING_POINT_LITERAL:\n                    case CHARACTER_LITERAL:\n                    case STRING_LITERAL:\n                    case IDENTIFIER:\n                    case LPAREN:\n                        if (jj_2_7(2)) {\n                            PrimaryExpression();\n                            jj_consume_token(DOT);\n                        } else {\n                            ;\n                        }\n                        jj_consume_token(SUPER);\n                        Arguments();\n                        jj_consume_token(SEMICOLON);\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void Initializer() throws ParseException {\n        /*@bgen(jjtree) Initializer */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTINITIALIZER);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case STATIC:\n                    jj_consume_token(STATIC);\n                    break;\n                default:\n                    ;\n            }\n            Block();\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    /*\n     * Type, name and expression syntax follows.\n     */\n    final public void Type() throws ParseException {\n        /*@bgen(jjtree) Type */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTTYPE);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            if (jj_2_9(2)) {\n                ReferenceType();\n            } else {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case BOOLEAN:\n                    case BYTE:\n                    case CHAR:\n                    case DOUBLE:\n                    case FLOAT:\n                    case INT:\n                    case LONG:\n                    case SHORT:\n                        PrimitiveType();\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ReferenceType() throws ParseException {\n        /*@bgen(jjtree) ReferenceType */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTREFERENCETYPE);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case BOOLEAN:\n                case BYTE:\n                case CHAR:\n                case DOUBLE:\n                case FLOAT:\n                case INT:\n                case LONG:\n                case SHORT:\n                    PrimitiveType();\n                    label_17: while (true) {\n                        jj_consume_token(LBRACKET);\n                        jj_consume_token(RBRACKET);\n                        if (jj_2_10(2)) {\n                            ;\n                        } else {\n                            break label_17;\n                        }\n                    }\n                    break;\n                case IDENTIFIER:\n                    ClassOrInterfaceType();\n                    label_18: while (true) {\n                        if (jj_2_11(2)) {\n                            ;\n                        } else {\n                            break label_18;\n                        }\n                        jj_consume_token(LBRACKET);\n                        jj_consume_token(RBRACKET);\n                    }\n                    break;\n                default:\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ClassOrInterfaceType() throws ParseException {\n        /*@bgen(jjtree) ClassOrInterfaceType */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTCLASSORINTERFACETYPE);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(IDENTIFIER);\n            if (jj_2_12(2)) {\n                TypeArguments();\n            } else {\n                ;\n            }\n            label_19: while (true) {\n                if (jj_2_13(2)) {\n                    ;\n                } else {\n                    break label_19;\n                }\n                jj_consume_token(DOT);\n                jj_consume_token(IDENTIFIER);\n                if (jj_2_14(2)) {\n                    TypeArguments();\n                } else {\n                    ;\n                }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void TypeArguments() throws ParseException {\n        /*@bgen(jjtree) TypeArguments */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTTYPEARGUMENTS);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(LT);\n            TypeArgument();\n            label_20: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case COMMA:\n                        ;\n                        break;\n                    default:\n                        break label_20;\n                }\n                jj_consume_token(COMMA);\n                TypeArgument();\n            }\n            jj_consume_token(GT);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void TypeArgument() throws ParseException {\n        /*@bgen(jjtree) TypeArgument */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTTYPEARGUMENT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case BOOLEAN:\n                case BYTE:\n                case CHAR:\n                case DOUBLE:\n                case FLOAT:\n                case INT:\n                case LONG:\n                case SHORT:\n                case IDENTIFIER:\n                    ReferenceType();\n                    break;\n                case HOOK:\n                    jj_consume_token(HOOK);\n                    switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                        case EXTENDS:\n                        case SUPER:\n                            WildcardBounds();\n                            break;\n                        default:\n                            ;\n                    }\n                    break;\n                default:\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void WildcardBounds() throws ParseException {\n        /*@bgen(jjtree) WildcardBounds */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTWILDCARDBOUNDS);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case EXTENDS:\n                    jj_consume_token(EXTENDS);\n                    ReferenceType();\n                    break;\n                case SUPER:\n                    jj_consume_token(SUPER);\n                    ReferenceType();\n                    break;\n                default:\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void PrimitiveType() throws ParseException {\n        /*@bgen(jjtree) PrimitiveType */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTPRIMITIVETYPE);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case BOOLEAN:\n                    jj_consume_token(BOOLEAN);\n                    break;\n                case CHAR:\n                    jj_consume_token(CHAR);\n                    break;\n                case BYTE:\n                    jj_consume_token(BYTE);\n                    break;\n                case SHORT:\n                    jj_consume_token(SHORT);\n                    break;\n                case INT:\n                    jj_consume_token(INT);\n                    break;\n                case LONG:\n                    jj_consume_token(LONG);\n                    break;\n                case FLOAT:\n                    jj_consume_token(FLOAT);\n                    break;\n                case DOUBLE:\n                    jj_consume_token(DOUBLE);\n                    break;\n                default:\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ResultType() throws ParseException {\n        /*@bgen(jjtree) ResultType */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTRESULTTYPE);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case VOID:\n                    jj_consume_token(VOID);\n                    break;\n                case BOOLEAN:\n                case BYTE:\n                case CHAR:\n                case DOUBLE:\n                case FLOAT:\n                case INT:\n                case LONG:\n                case SHORT:\n                case IDENTIFIER:\n                    Type();\n                    break;\n                default:\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void Name() throws ParseException {\n        /*@bgen(jjtree) Name */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTNAME);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(IDENTIFIER);\n            label_21: while (true) {\n                if (jj_2_15(2)) {\n                    ;\n                } else {\n                    break label_21;\n                }\n                jj_consume_token(DOT);\n                jj_consume_token(IDENTIFIER);\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void NameList() throws ParseException {\n        /*@bgen(jjtree) NameList */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTNAMELIST);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            Name();\n            label_22: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case COMMA:\n                        ;\n                        break;\n                    default:\n                        break label_22;\n                }\n                jj_consume_token(COMMA);\n                Name();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    /*\n     * Expression syntax follows.\n     */\n    final public void Expression() throws ParseException {\n        /*@bgen(jjtree) Expression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            ConditionalExpression();\n            if (jj_2_16(2)) {\n                AssignmentOperator();\n                Expression();\n            } else {\n                ;\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void AssignmentOperator() throws ParseException {\n        /*@bgen(jjtree) AssignmentOperator */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTASSIGNMENTOPERATOR);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case ASSIGN:\n                    jj_consume_token(ASSIGN);\n                    break;\n                case STARASSIGN:\n                    jj_consume_token(STARASSIGN);\n                    break;\n                case SLASHASSIGN:\n                    jj_consume_token(SLASHASSIGN);\n                    break;\n                case REMASSIGN:\n                    jj_consume_token(REMASSIGN);\n                    break;\n                case PLUSASSIGN:\n                    jj_consume_token(PLUSASSIGN);\n                    break;\n                case MINUSASSIGN:\n                    jj_consume_token(MINUSASSIGN);\n                    break;\n                case LSHIFTASSIGN:\n                    jj_consume_token(LSHIFTASSIGN);\n                    break;\n                case RSIGNEDSHIFTASSIGN:\n                    jj_consume_token(RSIGNEDSHIFTASSIGN);\n                    break;\n                case RUNSIGNEDSHIFTASSIGN:\n                    jj_consume_token(RUNSIGNEDSHIFTASSIGN);\n                    break;\n                case ANDASSIGN:\n                    jj_consume_token(ANDASSIGN);\n                    break;\n                case XORASSIGN:\n                    jj_consume_token(XORASSIGN);\n                    break;\n                case ORASSIGN:\n                    jj_consume_token(ORASSIGN);\n                    break;\n                default:\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ConditionalExpression() throws ParseException {\n        /*@bgen(jjtree) ConditionalExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTCONDITIONALEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            ConditionalOrExpression();\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case HOOK:\n                    jj_consume_token(HOOK);\n                    Expression();\n                    jj_consume_token(COLON);\n                    Expression();\n                    break;\n                default:\n                    ;\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ConditionalOrExpression() throws ParseException {\n        /*@bgen(jjtree) ConditionalOrExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTCONDITIONALOREXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            ConditionalAndExpression();\n            label_23: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case SC_OR:\n                        ;\n                        break;\n                    default:\n                        break label_23;\n                }\n                jj_consume_token(SC_OR);\n                ConditionalAndExpression();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ConditionalAndExpression() throws ParseException {\n        /*@bgen(jjtree) ConditionalAndExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTCONDITIONALANDEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            InclusiveOrExpression();\n            label_24: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case SC_AND:\n                        ;\n                        break;\n                    default:\n                        break label_24;\n                }\n                jj_consume_token(SC_AND);\n                InclusiveOrExpression();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void InclusiveOrExpression() throws ParseException {\n        /*@bgen(jjtree) InclusiveOrExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTINCLUSIVEOREXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            ExclusiveOrExpression();\n            label_25: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case BIT_OR:\n                        ;\n                        break;\n                    default:\n                        break label_25;\n                }\n                jj_consume_token(BIT_OR);\n                ExclusiveOrExpression();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ExclusiveOrExpression() throws ParseException {\n        /*@bgen(jjtree) ExclusiveOrExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTEXCLUSIVEOREXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            AndExpression();\n            label_26: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case XOR:\n                        ;\n                        break;\n                    default:\n                        break label_26;\n                }\n                jj_consume_token(XOR);\n                AndExpression();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void AndExpression() throws ParseException {\n        /*@bgen(jjtree) AndExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTANDEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            EqualityExpression();\n            label_27: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case BIT_AND:\n                        ;\n                        break;\n                    default:\n                        break label_27;\n                }\n                jj_consume_token(BIT_AND);\n                EqualityExpression();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void EqualityExpression() throws ParseException {\n        /*@bgen(jjtree) EqualityExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTEQUALITYEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            InstanceOfExpression();\n            label_28: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case EQ:\n                    case NE:\n                        ;\n                        break;\n                    default:\n                        break label_28;\n                }\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case EQ:\n                        jj_consume_token(EQ);\n                        break;\n                    case NE:\n                        jj_consume_token(NE);\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n                InstanceOfExpression();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void InstanceOfExpression() throws ParseException {\n        /*@bgen(jjtree) InstanceOfExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTINSTANCEOFEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            RelationalExpression();\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case INSTANCEOF:\n                    jj_consume_token(INSTANCEOF);\n                    Type();\n                    break;\n                default:\n                    ;\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void RelationalExpression() throws ParseException {\n        /*@bgen(jjtree) RelationalExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTRELATIONALEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            ShiftExpression();\n            label_29: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case LT:\n                    case LE:\n                    case GE:\n                    case GT:\n                        ;\n                        break;\n                    default:\n                        break label_29;\n                }\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case LT:\n                        jj_consume_token(LT);\n                        break;\n                    case GT:\n                        jj_consume_token(GT);\n                        break;\n                    case LE:\n                        jj_consume_token(LE);\n                        break;\n                    case GE:\n                        jj_consume_token(GE);\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n                ShiftExpression();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ShiftExpression() throws ParseException {\n        /*@bgen(jjtree) ShiftExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTSHIFTEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            AdditiveExpression();\n            label_30: while (true) {\n                if (jj_2_17(1)) {\n                    ;\n                } else {\n                    break label_30;\n                }\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case LSHIFT:\n                        jj_consume_token(LSHIFT);\n                        break;\n                    default:\n                        if (jj_2_18(1)) {\n                            RSIGNEDSHIFT();\n                        } else if (jj_2_19(1)) {\n                            RUNSIGNEDSHIFT();\n                        } else {\n                            jj_consume_token(-1);\n                            throw new ParseException();\n                        }\n                }\n                AdditiveExpression();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void AdditiveExpression() throws ParseException {\n        /*@bgen(jjtree) AdditiveExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTADDITIVEEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            MultiplicativeExpression();\n            label_31: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case PLUS:\n                    case MINUS:\n                        ;\n                        break;\n                    default:\n                        break label_31;\n                }\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case PLUS:\n                        jj_consume_token(PLUS);\n                        break;\n                    case MINUS:\n                        jj_consume_token(MINUS);\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n                MultiplicativeExpression();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void MultiplicativeExpression() throws ParseException {\n        /*@bgen(jjtree) MultiplicativeExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTMULTIPLICATIVEEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            UnaryExpression();\n            label_32: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case STAR:\n                    case SLASH:\n                    case REM:\n                        ;\n                        break;\n                    default:\n                        break label_32;\n                }\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case STAR:\n                        jj_consume_token(STAR);\n                        break;\n                    case SLASH:\n                        jj_consume_token(SLASH);\n                        break;\n                    case REM:\n                        jj_consume_token(REM);\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n                UnaryExpression();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void UnaryExpression() throws ParseException {\n        /*@bgen(jjtree) UnaryExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTUNARYEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case PLUS:\n                case MINUS:\n                    switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                        case PLUS:\n                            jj_consume_token(PLUS);\n                            break;\n                        case MINUS:\n                            jj_consume_token(MINUS);\n                            break;\n                        default:\n                            jj_consume_token(-1);\n                            throw new ParseException();\n                    }\n                    UnaryExpression();\n                    break;\n                case INCR:\n                    PreIncrementExpression();\n                    break;\n                case DECR:\n                    PreDecrementExpression();\n                    break;\n                case BOOLEAN:\n                case BYTE:\n                case CHAR:\n                case DOUBLE:\n                case FALSE:\n                case FLOAT:\n                case INT:\n                case LONG:\n                case NEW:\n                case NULL:\n                case SHORT:\n                case SUPER:\n                case THIS:\n                case TRUE:\n                case VOID:\n                case INTEGER_LITERAL:\n                case FLOATING_POINT_LITERAL:\n                case CHARACTER_LITERAL:\n                case STRING_LITERAL:\n                case IDENTIFIER:\n                case LPAREN:\n                case BANG:\n                case TILDE:\n                    UnaryExpressionNotPlusMinus();\n                    break;\n                default:\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void PreIncrementExpression() throws ParseException {\n        /*@bgen(jjtree) PreIncrementExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTPREINCREMENTEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(INCR);\n            PrimaryExpression();\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void PreDecrementExpression() throws ParseException {\n        /*@bgen(jjtree) PreDecrementExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTPREDECREMENTEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(DECR);\n            PrimaryExpression();\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void UnaryExpressionNotPlusMinus() throws ParseException {\n        /*@bgen(jjtree) UnaryExpressionNotPlusMinus */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTUNARYEXPRESSIONNOTPLUSMINUS);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case BANG:\n                case TILDE:\n                    switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                        case TILDE:\n                            jj_consume_token(TILDE);\n                            break;\n                        case BANG:\n                            jj_consume_token(BANG);\n                            break;\n                        default:\n                            jj_consume_token(-1);\n                            throw new ParseException();\n                    }\n                    UnaryExpression();\n                    break;\n                default:\n                    if (jj_2_20(2147483647)) {\n                        CastExpression();\n                    } else {\n                        switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                            case BOOLEAN:\n                            case BYTE:\n                            case CHAR:\n                            case DOUBLE:\n                            case FALSE:\n                            case FLOAT:\n                            case INT:\n                            case LONG:\n                            case NEW:\n                            case NULL:\n                            case SHORT:\n                            case SUPER:\n                            case THIS:\n                            case TRUE:\n                            case VOID:\n                            case INTEGER_LITERAL:\n                            case FLOATING_POINT_LITERAL:\n                            case CHARACTER_LITERAL:\n                            case STRING_LITERAL:\n                            case IDENTIFIER:\n                            case LPAREN:\n                                PostfixExpression();\n                                break;\n                            default:\n                                jj_consume_token(-1);\n                                throw new ParseException();\n                        }\n                    }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    // This production is to determine lookahead only.  The LOOKAHEAD specifications\n    // below are not used, but they are there just to indicate that we know about\n    // this.\n    final public void CastLookahead() throws ParseException {\n        /*@bgen(jjtree) CastLookahead */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTCASTLOOKAHEAD);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            if (jj_2_21(2)) {\n                jj_consume_token(LPAREN);\n                PrimitiveType();\n            } else if (jj_2_22(2147483647)) {\n                jj_consume_token(LPAREN);\n                Type();\n                jj_consume_token(LBRACKET);\n                jj_consume_token(RBRACKET);\n            } else {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case LPAREN:\n                        jj_consume_token(LPAREN);\n                        Type();\n                        jj_consume_token(RPAREN);\n                        switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                            case TILDE:\n                                jj_consume_token(TILDE);\n                                break;\n                            case BANG:\n                                jj_consume_token(BANG);\n                                break;\n                            case LPAREN:\n                                jj_consume_token(LPAREN);\n                                break;\n                            case IDENTIFIER:\n                                jj_consume_token(IDENTIFIER);\n                                break;\n                            case THIS:\n                                jj_consume_token(THIS);\n                                break;\n                            case SUPER:\n                                jj_consume_token(SUPER);\n                                break;\n                            case NEW:\n                                jj_consume_token(NEW);\n                                break;\n                            case FALSE:\n                            case NULL:\n                            case TRUE:\n                            case INTEGER_LITERAL:\n                            case FLOATING_POINT_LITERAL:\n                            case CHARACTER_LITERAL:\n                            case STRING_LITERAL:\n                                Literal();\n                                break;\n                            default:\n                                jj_consume_token(-1);\n                                throw new ParseException();\n                        }\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void PostfixExpression() throws ParseException {\n        /*@bgen(jjtree) PostfixExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTPOSTFIXEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            PrimaryExpression();\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case INCR:\n                case DECR:\n                    switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                        case INCR:\n                            jj_consume_token(INCR);\n                            break;\n                        case DECR:\n                            jj_consume_token(DECR);\n                            break;\n                        default:\n                            jj_consume_token(-1);\n                            throw new ParseException();\n                    }\n                    break;\n                default:\n                    ;\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void CastExpression() throws ParseException {\n        /*@bgen(jjtree) CastExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTCASTEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            if (jj_2_23(2147483647)) {\n                jj_consume_token(LPAREN);\n                Type();\n                jj_consume_token(RPAREN);\n                UnaryExpression();\n            } else {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case LPAREN:\n                        jj_consume_token(LPAREN);\n                        Type();\n                        jj_consume_token(RPAREN);\n                        UnaryExpressionNotPlusMinus();\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void PrimaryExpression() throws ParseException {\n        /*@bgen(jjtree) PrimaryExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTPRIMARYEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            PrimaryPrefix();\n            label_33: while (true) {\n                if (jj_2_24(2)) {\n                    ;\n                } else {\n                    break label_33;\n                }\n                PrimarySuffix();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void MemberSelector() throws ParseException {\n        /*@bgen(jjtree) MemberSelector */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTMEMBERSELECTOR);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(DOT);\n            TypeArguments();\n            jj_consume_token(IDENTIFIER);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void PrimaryPrefix() throws ParseException {\n        /*@bgen(jjtree) PrimaryPrefix */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTPRIMARYPREFIX);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case FALSE:\n                case NULL:\n                case TRUE:\n                case INTEGER_LITERAL:\n                case FLOATING_POINT_LITERAL:\n                case CHARACTER_LITERAL:\n                case STRING_LITERAL:\n                    Literal();\n                    break;\n                case THIS:\n                    jj_consume_token(THIS);\n                    break;\n                case SUPER:\n                    jj_consume_token(SUPER);\n                    jj_consume_token(DOT);\n                    jj_consume_token(IDENTIFIER);\n                    break;\n                case LPAREN:\n                    jj_consume_token(LPAREN);\n                    Expression();\n                    jj_consume_token(RPAREN);\n                    break;\n                case NEW:\n                    AllocationExpression();\n                    break;\n                default:\n                    if (jj_2_25(2147483647)) {\n                        ResultType();\n                        jj_consume_token(DOT);\n                        jj_consume_token(CLASS);\n                    } else {\n                        switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                            case IDENTIFIER:\n                                Name();\n                                break;\n                            default:\n                                jj_consume_token(-1);\n                                throw new ParseException();\n                        }\n                    }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void PrimarySuffix() throws ParseException {\n        /*@bgen(jjtree) PrimarySuffix */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTPRIMARYSUFFIX);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            if (jj_2_26(2)) {\n                jj_consume_token(DOT);\n                jj_consume_token(THIS);\n            } else if (jj_2_27(2)) {\n                jj_consume_token(DOT);\n                AllocationExpression();\n            } else if (jj_2_28(3)) {\n                MemberSelector();\n            } else {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case LBRACKET:\n                        jj_consume_token(LBRACKET);\n                        Expression();\n                        jj_consume_token(RBRACKET);\n                        break;\n                    case DOT:\n                        jj_consume_token(DOT);\n                        jj_consume_token(IDENTIFIER);\n                        break;\n                    case LPAREN:\n                        Arguments();\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void Literal() throws ParseException {\n        /*@bgen(jjtree) Literal */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTLITERAL);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case INTEGER_LITERAL:\n                    jj_consume_token(INTEGER_LITERAL);\n                    break;\n                case FLOATING_POINT_LITERAL:\n                    jj_consume_token(FLOATING_POINT_LITERAL);\n                    break;\n                case CHARACTER_LITERAL:\n                    jj_consume_token(CHARACTER_LITERAL);\n                    break;\n                case STRING_LITERAL:\n                    jj_consume_token(STRING_LITERAL);\n                    break;\n                case FALSE:\n                case TRUE:\n                    BooleanLiteral();\n                    break;\n                case NULL:\n                    NullLiteral();\n                    break;\n                default:\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void BooleanLiteral() throws ParseException {\n        /*@bgen(jjtree) BooleanLiteral */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTBOOLEANLITERAL);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case TRUE:\n                    jj_consume_token(TRUE);\n                    break;\n                case FALSE:\n                    jj_consume_token(FALSE);\n                    break;\n                default:\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void NullLiteral() throws ParseException {\n        /*@bgen(jjtree) NullLiteral */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTNULLLITERAL);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(NULL);\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void Arguments() throws ParseException {\n        /*@bgen(jjtree) Arguments */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTARGUMENTS);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(LPAREN);\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case BOOLEAN:\n                case BYTE:\n                case CHAR:\n                case DOUBLE:\n                case FALSE:\n                case FLOAT:\n                case INT:\n                case LONG:\n                case NEW:\n                case NULL:\n                case SHORT:\n                case SUPER:\n                case THIS:\n                case TRUE:\n                case VOID:\n                case INTEGER_LITERAL:\n                case FLOATING_POINT_LITERAL:\n                case CHARACTER_LITERAL:\n                case STRING_LITERAL:\n                case IDENTIFIER:\n                case LPAREN:\n                case BANG:\n                case TILDE:\n                case INCR:\n                case DECR:\n                case PLUS:\n                case MINUS:\n                    ArgumentList();\n                    break;\n                default:\n                    ;\n            }\n            jj_consume_token(RPAREN);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ArgumentList() throws ParseException {\n        /*@bgen(jjtree) ArgumentList */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTARGUMENTLIST);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            Expression();\n            label_34: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case COMMA:\n                        ;\n                        break;\n                    default:\n                        break label_34;\n                }\n                jj_consume_token(COMMA);\n                Expression();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void AllocationExpression() throws ParseException {\n        /*@bgen(jjtree) AllocationExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTALLOCATIONEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            if (jj_2_29(2)) {\n                jj_consume_token(NEW);\n                PrimitiveType();\n                ArrayDimsAndInits();\n            } else {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case NEW:\n                        jj_consume_token(NEW);\n                        ClassOrInterfaceType();\n                        switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                            case LT:\n                                TypeArguments();\n                                break;\n                            default:\n                                ;\n                        }\n                        switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                            case LBRACKET:\n                                ArrayDimsAndInits();\n                                break;\n                            case LPAREN:\n                                Arguments();\n                                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                                    case LBRACE:\n                                        ClassOrInterfaceBody(false);\n                                        break;\n                                    default:\n                                        ;\n                                }\n                                break;\n                            default:\n                                jj_consume_token(-1);\n                                throw new ParseException();\n                        }\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    /*\n     * The third LOOKAHEAD specification below is to parse to PrimarySuffix\n     * if there is an expression between the \"[...]\".\n     */\n    final public void ArrayDimsAndInits() throws ParseException {\n        /*@bgen(jjtree) ArrayDimsAndInits */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTARRAYDIMSANDINITS);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            if (jj_2_32(2)) {\n                label_35: while (true) {\n                    jj_consume_token(LBRACKET);\n                    Expression();\n                    jj_consume_token(RBRACKET);\n                    if (jj_2_30(2)) {\n                        ;\n                    } else {\n                        break label_35;\n                    }\n                }\n                label_36: while (true) {\n                    if (jj_2_31(2)) {\n                        ;\n                    } else {\n                        break label_36;\n                    }\n                    jj_consume_token(LBRACKET);\n                    jj_consume_token(RBRACKET);\n                }\n            } else {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case LBRACKET:\n                        label_37: while (true) {\n                            jj_consume_token(LBRACKET);\n                            jj_consume_token(RBRACKET);\n                            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                                case LBRACKET:\n                                    ;\n                                    break;\n                                default:\n                                    break label_37;\n                            }\n                        }\n                        ArrayInitializer();\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    /*\n     * Statement syntax follows.\n     */\n    final public void Statement() throws ParseException {\n        /*@bgen(jjtree) Statement */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTSTATEMENT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            if (jj_2_33(2)) {\n                LabeledStatement();\n            } else {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case ASSERT:\n                        AssertStatement();\n                        break;\n                    case LBRACE:\n                        Block();\n                        break;\n                    case SEMICOLON:\n                        EmptyStatement();\n                        break;\n                    case BOOLEAN:\n                    case BYTE:\n                    case CHAR:\n                    case DOUBLE:\n                    case FALSE:\n                    case FLOAT:\n                    case INT:\n                    case LONG:\n                    case NEW:\n                    case NULL:\n                    case SHORT:\n                    case SUPER:\n                    case THIS:\n                    case TRUE:\n                    case VOID:\n                    case INTEGER_LITERAL:\n                    case FLOATING_POINT_LITERAL:\n                    case CHARACTER_LITERAL:\n                    case STRING_LITERAL:\n                    case IDENTIFIER:\n                    case LPAREN:\n                    case INCR:\n                    case DECR:\n                        StatementExpression();\n                        jj_consume_token(SEMICOLON);\n                        break;\n                    case SWITCH:\n                        SwitchStatement();\n                        break;\n                    case IF:\n                        IfStatement();\n                        break;\n                    case WHILE:\n                        WhileStatement();\n                        break;\n                    case DO:\n                        DoStatement();\n                        break;\n                    case FOR:\n                        ForStatement();\n                        break;\n                    case BREAK:\n                        BreakStatement();\n                        break;\n                    case CONTINUE:\n                        ContinueStatement();\n                        break;\n                    case RETURN:\n                        ReturnStatement();\n                        break;\n                    case THROW:\n                        ThrowStatement();\n                        break;\n                    case SYNCHRONIZED:\n                        SynchronizedStatement();\n                        break;\n                    case TRY:\n                        TryStatement();\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void AssertStatement() throws ParseException {\n        /*@bgen(jjtree) AssertStatement */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTASSERTSTATEMENT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(ASSERT);\n            Expression();\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case COLON:\n                    jj_consume_token(COLON);\n                    Expression();\n                    break;\n                default:\n                    ;\n            }\n            jj_consume_token(SEMICOLON);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void LabeledStatement() throws ParseException {\n        /*@bgen(jjtree) LabeledStatement */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTLABELEDSTATEMENT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(IDENTIFIER);\n            jj_consume_token(COLON);\n            Statement();\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void Block() throws ParseException {\n        /*@bgen(jjtree) Block */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTBLOCK);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(LBRACE);\n            label_38: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case ASSERT:\n                    case BOOLEAN:\n                    case BREAK:\n                    case BYTE:\n                    case CHAR:\n                    case CLASS:\n                    case CONTINUE:\n                    case DO:\n                    case DOUBLE:\n                    case FALSE:\n                    case FINAL:\n                    case FLOAT:\n                    case FOR:\n                    case IF:\n                    case INT:\n                    case INTERFACE:\n                    case LONG:\n                    case NEW:\n                    case NULL:\n                    case RETURN:\n                    case SHORT:\n                    case SUPER:\n                    case SWITCH:\n                    case SYNCHRONIZED:\n                    case THIS:\n                    case THROW:\n                    case TRUE:\n                    case TRY:\n                    case VOID:\n                    case WHILE:\n                    case INTEGER_LITERAL:\n                    case FLOATING_POINT_LITERAL:\n                    case CHARACTER_LITERAL:\n                    case STRING_LITERAL:\n                    case IDENTIFIER:\n                    case LPAREN:\n                    case LBRACE:\n                    case SEMICOLON:\n                    case INCR:\n                    case DECR:\n                        ;\n                        break;\n                    default:\n                        break label_38;\n                }\n                BlockStatement();\n            }\n            jj_consume_token(RBRACE);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void BlockStatement() throws ParseException {\n        /*@bgen(jjtree) BlockStatement */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTBLOCKSTATEMENT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            if (jj_2_34(2147483647)) {\n                LocalVariableDeclaration();\n                jj_consume_token(SEMICOLON);\n            } else {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case ASSERT:\n                    case BOOLEAN:\n                    case BREAK:\n                    case BYTE:\n                    case CHAR:\n                    case CONTINUE:\n                    case DO:\n                    case DOUBLE:\n                    case FALSE:\n                    case FLOAT:\n                    case FOR:\n                    case IF:\n                    case INT:\n                    case LONG:\n                    case NEW:\n                    case NULL:\n                    case RETURN:\n                    case SHORT:\n                    case SUPER:\n                    case SWITCH:\n                    case SYNCHRONIZED:\n                    case THIS:\n                    case THROW:\n                    case TRUE:\n                    case TRY:\n                    case VOID:\n                    case WHILE:\n                    case INTEGER_LITERAL:\n                    case FLOATING_POINT_LITERAL:\n                    case CHARACTER_LITERAL:\n                    case STRING_LITERAL:\n                    case IDENTIFIER:\n                    case LPAREN:\n                    case LBRACE:\n                    case SEMICOLON:\n                    case INCR:\n                    case DECR:\n                        Statement();\n                        break;\n                    case CLASS:\n                    case INTERFACE:\n                        ClassOrInterfaceDeclaration(0);\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void LocalVariableDeclaration() throws ParseException {\n        /*@bgen(jjtree) LocalVariableDeclaration */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTLOCALVARIABLEDECLARATION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case FINAL:\n                    jj_consume_token(FINAL);\n                    break;\n                default:\n                    ;\n            }\n            Type();\n            VariableDeclarator();\n            label_39: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case COMMA:\n                        ;\n                        break;\n                    default:\n                        break label_39;\n                }\n                jj_consume_token(COMMA);\n                VariableDeclarator();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void EmptyStatement() throws ParseException {\n        /*@bgen(jjtree) EmptyStatement */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTEMPTYSTATEMENT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(SEMICOLON);\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void StatementExpression() throws ParseException {\n        /*@bgen(jjtree) StatementExpression */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTSTATEMENTEXPRESSION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case INCR:\n                    PreIncrementExpression();\n                    break;\n                case DECR:\n                    PreDecrementExpression();\n                    break;\n                case BOOLEAN:\n                case BYTE:\n                case CHAR:\n                case DOUBLE:\n                case FALSE:\n                case FLOAT:\n                case INT:\n                case LONG:\n                case NEW:\n                case NULL:\n                case SHORT:\n                case SUPER:\n                case THIS:\n                case TRUE:\n                case VOID:\n                case INTEGER_LITERAL:\n                case FLOATING_POINT_LITERAL:\n                case CHARACTER_LITERAL:\n                case STRING_LITERAL:\n                case IDENTIFIER:\n                case LPAREN:\n                    PrimaryExpression();\n                    switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                        case ASSIGN:\n                        case INCR:\n                        case DECR:\n                        case PLUSASSIGN:\n                        case MINUSASSIGN:\n                        case STARASSIGN:\n                        case SLASHASSIGN:\n                        case ANDASSIGN:\n                        case ORASSIGN:\n                        case XORASSIGN:\n                        case REMASSIGN:\n                        case LSHIFTASSIGN:\n                        case RSIGNEDSHIFTASSIGN:\n                        case RUNSIGNEDSHIFTASSIGN:\n                            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                                case INCR:\n                                    jj_consume_token(INCR);\n                                    break;\n                                case DECR:\n                                    jj_consume_token(DECR);\n                                    break;\n                                case ASSIGN:\n                                case PLUSASSIGN:\n                                case MINUSASSIGN:\n                                case STARASSIGN:\n                                case SLASHASSIGN:\n                                case ANDASSIGN:\n                                case ORASSIGN:\n                                case XORASSIGN:\n                                case REMASSIGN:\n                                case LSHIFTASSIGN:\n                                case RSIGNEDSHIFTASSIGN:\n                                case RUNSIGNEDSHIFTASSIGN:\n                                    AssignmentOperator();\n                                    Expression();\n                                    break;\n                                default:\n                                    jj_consume_token(-1);\n                                    throw new ParseException();\n                            }\n                            break;\n                        default:\n                            ;\n                    }\n                    break;\n                default:\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void SwitchStatement() throws ParseException {\n        /*@bgen(jjtree) SwitchStatement */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTSWITCHSTATEMENT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(SWITCH);\n            jj_consume_token(LPAREN);\n            Expression();\n            jj_consume_token(RPAREN);\n            jj_consume_token(LBRACE);\n            label_40: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case CASE:\n                    case _DEFAULT:\n                        ;\n                        break;\n                    default:\n                        break label_40;\n                }\n                SwitchLabel();\n                label_41: while (true) {\n                    switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                        case ASSERT:\n                        case BOOLEAN:\n                        case BREAK:\n                        case BYTE:\n                        case CHAR:\n                        case CLASS:\n                        case CONTINUE:\n                        case DO:\n                        case DOUBLE:\n                        case FALSE:\n                        case FINAL:\n                        case FLOAT:\n                        case FOR:\n                        case IF:\n                        case INT:\n                        case INTERFACE:\n                        case LONG:\n                        case NEW:\n                        case NULL:\n                        case RETURN:\n                        case SHORT:\n                        case SUPER:\n                        case SWITCH:\n                        case SYNCHRONIZED:\n                        case THIS:\n                        case THROW:\n                        case TRUE:\n                        case TRY:\n                        case VOID:\n                        case WHILE:\n                        case INTEGER_LITERAL:\n                        case FLOATING_POINT_LITERAL:\n                        case CHARACTER_LITERAL:\n                        case STRING_LITERAL:\n                        case IDENTIFIER:\n                        case LPAREN:\n                        case LBRACE:\n                        case SEMICOLON:\n                        case INCR:\n                        case DECR:\n                            ;\n                            break;\n                        default:\n                            break label_41;\n                    }\n                    BlockStatement();\n                }\n            }\n            jj_consume_token(RBRACE);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void SwitchLabel() throws ParseException {\n        /*@bgen(jjtree) SwitchLabel */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTSWITCHLABEL);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case CASE:\n                    jj_consume_token(CASE);\n                    Expression();\n                    jj_consume_token(COLON);\n                    break;\n                case _DEFAULT:\n                    jj_consume_token(_DEFAULT);\n                    jj_consume_token(COLON);\n                    break;\n                default:\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void IfStatement() throws ParseException {\n        /*@bgen(jjtree) IfStatement */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTIFSTATEMENT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(IF);\n            jj_consume_token(LPAREN);\n            Expression();\n            jj_consume_token(RPAREN);\n            Statement();\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case ELSE:\n                    jj_consume_token(ELSE);\n                    Statement();\n                    break;\n                default:\n                    ;\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void WhileStatement() throws ParseException {\n        /*@bgen(jjtree) WhileStatement */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTWHILESTATEMENT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(WHILE);\n            jj_consume_token(LPAREN);\n            Expression();\n            jj_consume_token(RPAREN);\n            Statement();\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void DoStatement() throws ParseException {\n        /*@bgen(jjtree) DoStatement */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTDOSTATEMENT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(DO);\n            Statement();\n            jj_consume_token(WHILE);\n            jj_consume_token(LPAREN);\n            Expression();\n            jj_consume_token(RPAREN);\n            jj_consume_token(SEMICOLON);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ForStatement() throws ParseException {\n        /*@bgen(jjtree) ForStatement */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTFORSTATEMENT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(FOR);\n            jj_consume_token(LPAREN);\n            if (jj_2_35(2147483647)) {\n                Type();\n                jj_consume_token(IDENTIFIER);\n                jj_consume_token(COLON);\n                Expression();\n            } else {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case BOOLEAN:\n                    case BYTE:\n                    case CHAR:\n                    case DOUBLE:\n                    case FALSE:\n                    case FINAL:\n                    case FLOAT:\n                    case INT:\n                    case LONG:\n                    case NEW:\n                    case NULL:\n                    case SHORT:\n                    case SUPER:\n                    case THIS:\n                    case TRUE:\n                    case VOID:\n                    case INTEGER_LITERAL:\n                    case FLOATING_POINT_LITERAL:\n                    case CHARACTER_LITERAL:\n                    case STRING_LITERAL:\n                    case IDENTIFIER:\n                    case LPAREN:\n                    case SEMICOLON:\n                    case INCR:\n                    case DECR:\n                        switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                            case BOOLEAN:\n                            case BYTE:\n                            case CHAR:\n                            case DOUBLE:\n                            case FALSE:\n                            case FINAL:\n                            case FLOAT:\n                            case INT:\n                            case LONG:\n                            case NEW:\n                            case NULL:\n                            case SHORT:\n                            case SUPER:\n                            case THIS:\n                            case TRUE:\n                            case VOID:\n                            case INTEGER_LITERAL:\n                            case FLOATING_POINT_LITERAL:\n                            case CHARACTER_LITERAL:\n                            case STRING_LITERAL:\n                            case IDENTIFIER:\n                            case LPAREN:\n                            case INCR:\n                            case DECR:\n                                ForInit();\n                                break;\n                            default:\n                                ;\n                        }\n                        jj_consume_token(SEMICOLON);\n                        switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                            case BOOLEAN:\n                            case BYTE:\n                            case CHAR:\n                            case DOUBLE:\n                            case FALSE:\n                            case FLOAT:\n                            case INT:\n                            case LONG:\n                            case NEW:\n                            case NULL:\n                            case SHORT:\n                            case SUPER:\n                            case THIS:\n                            case TRUE:\n                            case VOID:\n                            case INTEGER_LITERAL:\n                            case FLOATING_POINT_LITERAL:\n                            case CHARACTER_LITERAL:\n                            case STRING_LITERAL:\n                            case IDENTIFIER:\n                            case LPAREN:\n                            case BANG:\n                            case TILDE:\n                            case INCR:\n                            case DECR:\n                            case PLUS:\n                            case MINUS:\n                                Expression();\n                                break;\n                            default:\n                                ;\n                        }\n                        jj_consume_token(SEMICOLON);\n                        switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                            case BOOLEAN:\n                            case BYTE:\n                            case CHAR:\n                            case DOUBLE:\n                            case FALSE:\n                            case FLOAT:\n                            case INT:\n                            case LONG:\n                            case NEW:\n                            case NULL:\n                            case SHORT:\n                            case SUPER:\n                            case THIS:\n                            case TRUE:\n                            case VOID:\n                            case INTEGER_LITERAL:\n                            case FLOATING_POINT_LITERAL:\n                            case CHARACTER_LITERAL:\n                            case STRING_LITERAL:\n                            case IDENTIFIER:\n                            case LPAREN:\n                            case INCR:\n                            case DECR:\n                                ForUpdate();\n                                break;\n                            default:\n                                ;\n                        }\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n            jj_consume_token(RPAREN);\n            Statement();\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ForInit() throws ParseException {\n        /*@bgen(jjtree) ForInit */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTFORINIT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            if (jj_2_36(2147483647)) {\n                LocalVariableDeclaration();\n            } else {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case BOOLEAN:\n                    case BYTE:\n                    case CHAR:\n                    case DOUBLE:\n                    case FALSE:\n                    case FLOAT:\n                    case INT:\n                    case LONG:\n                    case NEW:\n                    case NULL:\n                    case SHORT:\n                    case SUPER:\n                    case THIS:\n                    case TRUE:\n                    case VOID:\n                    case INTEGER_LITERAL:\n                    case FLOATING_POINT_LITERAL:\n                    case CHARACTER_LITERAL:\n                    case STRING_LITERAL:\n                    case IDENTIFIER:\n                    case LPAREN:\n                    case INCR:\n                    case DECR:\n                        StatementExpressionList();\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void StatementExpressionList() throws ParseException {\n        /*@bgen(jjtree) StatementExpressionList */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTSTATEMENTEXPRESSIONLIST);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            StatementExpression();\n            label_42: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case COMMA:\n                        ;\n                        break;\n                    default:\n                        break label_42;\n                }\n                jj_consume_token(COMMA);\n                StatementExpression();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ForUpdate() throws ParseException {\n        /*@bgen(jjtree) ForUpdate */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTFORUPDATE);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            StatementExpressionList();\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void BreakStatement() throws ParseException {\n        /*@bgen(jjtree) BreakStatement */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTBREAKSTATEMENT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(BREAK);\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case IDENTIFIER:\n                    jj_consume_token(IDENTIFIER);\n                    break;\n                default:\n                    ;\n            }\n            jj_consume_token(SEMICOLON);\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ContinueStatement() throws ParseException {\n        /*@bgen(jjtree) ContinueStatement */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTCONTINUESTATEMENT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(CONTINUE);\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case IDENTIFIER:\n                    jj_consume_token(IDENTIFIER);\n                    break;\n                default:\n                    ;\n            }\n            jj_consume_token(SEMICOLON);\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ReturnStatement() throws ParseException {\n        /*@bgen(jjtree) ReturnStatement */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTRETURNSTATEMENT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(RETURN);\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case BOOLEAN:\n                case BYTE:\n                case CHAR:\n                case DOUBLE:\n                case FALSE:\n                case FLOAT:\n                case INT:\n                case LONG:\n                case NEW:\n                case NULL:\n                case SHORT:\n                case SUPER:\n                case THIS:\n                case TRUE:\n                case VOID:\n                case INTEGER_LITERAL:\n                case FLOATING_POINT_LITERAL:\n                case CHARACTER_LITERAL:\n                case STRING_LITERAL:\n                case IDENTIFIER:\n                case LPAREN:\n                case BANG:\n                case TILDE:\n                case INCR:\n                case DECR:\n                case PLUS:\n                case MINUS:\n                    Expression();\n                    break;\n                default:\n                    ;\n            }\n            jj_consume_token(SEMICOLON);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void ThrowStatement() throws ParseException {\n        /*@bgen(jjtree) ThrowStatement */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTTHROWSTATEMENT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(THROW);\n            Expression();\n            jj_consume_token(SEMICOLON);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void SynchronizedStatement() throws ParseException {\n        /*@bgen(jjtree) SynchronizedStatement */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTSYNCHRONIZEDSTATEMENT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(SYNCHRONIZED);\n            jj_consume_token(LPAREN);\n            Expression();\n            jj_consume_token(RPAREN);\n            Block();\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void TryStatement() throws ParseException {\n        /*@bgen(jjtree) TryStatement */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTTRYSTATEMENT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(TRY);\n            Block();\n            label_43: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case CATCH:\n                        ;\n                        break;\n                    default:\n                        break label_43;\n                }\n                jj_consume_token(CATCH);\n                jj_consume_token(LPAREN);\n                FormalParameter();\n                jj_consume_token(RPAREN);\n                Block();\n            }\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case FINALLY:\n                    jj_consume_token(FINALLY);\n                    Block();\n                    break;\n                default:\n                    ;\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    /* We use productions to match >>>, >> and > so that we can keep the\n     * type declaration syntax with generics clean\n     */\n    final public void RUNSIGNEDSHIFT() throws ParseException {\n        /*@bgen(jjtree) RUNSIGNEDSHIFT */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTRUNSIGNEDSHIFT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            if (getToken(1).kind == GT && ((Token.GTToken) getToken(1)).realKind == RUNSIGNEDSHIFT) {\n            } else {\n                jj_consume_token(-1);\n                throw new ParseException();\n            }\n            jj_consume_token(GT);\n            jj_consume_token(GT);\n            jj_consume_token(GT);\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void RSIGNEDSHIFT() throws ParseException {\n        /*@bgen(jjtree) RSIGNEDSHIFT */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTRSIGNEDSHIFT);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            if (getToken(1).kind == GT && ((Token.GTToken) getToken(1)).realKind == RSIGNEDSHIFT) {\n            } else {\n                jj_consume_token(-1);\n                throw new ParseException();\n            }\n            jj_consume_token(GT);\n            jj_consume_token(GT);\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    /* Annotation syntax follows. */\n    final public void Annotation() throws ParseException {\n        /*@bgen(jjtree) Annotation */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTANNOTATION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            if (jj_2_37(2147483647)) {\n                NormalAnnotation();\n            } else if (jj_2_38(2147483647)) {\n                SingleMemberAnnotation();\n            } else {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case AT:\n                        MarkerAnnotation();\n                        break;\n                    default:\n                        jj_consume_token(-1);\n                        throw new ParseException();\n                }\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void NormalAnnotation() throws ParseException {\n        /*@bgen(jjtree) NormalAnnotation */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTNORMALANNOTATION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(AT);\n            Name();\n            jj_consume_token(LPAREN);\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case IDENTIFIER:\n                    MemberValuePairs();\n                    break;\n                default:\n                    ;\n            }\n            jj_consume_token(RPAREN);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void MarkerAnnotation() throws ParseException {\n        /*@bgen(jjtree) MarkerAnnotation */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTMARKERANNOTATION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(AT);\n            Name();\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void SingleMemberAnnotation() throws ParseException {\n        /*@bgen(jjtree) SingleMemberAnnotation */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTSINGLEMEMBERANNOTATION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(AT);\n            Name();\n            jj_consume_token(LPAREN);\n            MemberValue();\n            jj_consume_token(RPAREN);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void MemberValuePairs() throws ParseException {\n        /*@bgen(jjtree) MemberValuePairs */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTMEMBERVALUEPAIRS);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            MemberValuePair();\n            label_44: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case COMMA:\n                        ;\n                        break;\n                    default:\n                        break label_44;\n                }\n                jj_consume_token(COMMA);\n                MemberValuePair();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void MemberValuePair() throws ParseException {\n        /*@bgen(jjtree) MemberValuePair */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTMEMBERVALUEPAIR);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(IDENTIFIER);\n            jj_consume_token(ASSIGN);\n            MemberValue();\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void MemberValue() throws ParseException {\n        /*@bgen(jjtree) MemberValue */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTMEMBERVALUE);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case AT:\n                    Annotation();\n                    break;\n                case LBRACE:\n                    MemberValueArrayInitializer();\n                    break;\n                case BOOLEAN:\n                case BYTE:\n                case CHAR:\n                case DOUBLE:\n                case FALSE:\n                case FLOAT:\n                case INT:\n                case LONG:\n                case NEW:\n                case NULL:\n                case SHORT:\n                case SUPER:\n                case THIS:\n                case TRUE:\n                case VOID:\n                case INTEGER_LITERAL:\n                case FLOATING_POINT_LITERAL:\n                case CHARACTER_LITERAL:\n                case STRING_LITERAL:\n                case IDENTIFIER:\n                case LPAREN:\n                case BANG:\n                case TILDE:\n                case INCR:\n                case DECR:\n                case PLUS:\n                case MINUS:\n                    ConditionalExpression();\n                    break;\n                default:\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void MemberValueArrayInitializer() throws ParseException {\n        /*@bgen(jjtree) MemberValueArrayInitializer */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTMEMBERVALUEARRAYINITIALIZER);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(LBRACE);\n            MemberValue();\n            label_45: while (true) {\n                if (jj_2_39(2)) {\n                    ;\n                } else {\n                    break label_45;\n                }\n                jj_consume_token(COMMA);\n                MemberValue();\n            }\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case COMMA:\n                    jj_consume_token(COMMA);\n                    break;\n                default:\n                    ;\n            }\n            jj_consume_token(RBRACE);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    /* Annotation Types. */\n    final public void AnnotationTypeDeclaration(int modifiers) throws ParseException {\n        /*@bgen(jjtree) AnnotationTypeDeclaration */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTANNOTATIONTYPEDECLARATION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(AT);\n            jj_consume_token(INTERFACE);\n            jj_consume_token(IDENTIFIER);\n            AnnotationTypeBody();\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void AnnotationTypeBody() throws ParseException {\n        /*@bgen(jjtree) AnnotationTypeBody */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTANNOTATIONTYPEBODY);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(LBRACE);\n            label_46: while (true) {\n                switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                    case ABSTRACT:\n                    case BOOLEAN:\n                    case BYTE:\n                    case CHAR:\n                    case CLASS:\n                    case DOUBLE:\n                    case ENUM:\n                    case FINAL:\n                    case FLOAT:\n                    case INT:\n                    case INTERFACE:\n                    case LONG:\n                    case NATIVE:\n                    case PRIVATE:\n                    case PROTECTED:\n                    case PUBLIC:\n                    case SHORT:\n                    case STATIC:\n                    case STRICTFP:\n                    case SYNCHRONIZED:\n                    case TRANSIENT:\n                    case VOLATILE:\n                    case IDENTIFIER:\n                    case SEMICOLON:\n                    case AT:\n                        ;\n                        break;\n                    default:\n                        break label_46;\n                }\n                AnnotationTypeMemberDeclaration();\n            }\n            jj_consume_token(RBRACE);\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void AnnotationTypeMemberDeclaration() throws ParseException {\n        /*@bgen(jjtree) AnnotationTypeMemberDeclaration */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTANNOTATIONTYPEMEMBERDECLARATION);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        int modifiers;\n        try {\n            switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                case ABSTRACT:\n                case BOOLEAN:\n                case BYTE:\n                case CHAR:\n                case CLASS:\n                case DOUBLE:\n                case ENUM:\n                case FINAL:\n                case FLOAT:\n                case INT:\n                case INTERFACE:\n                case LONG:\n                case NATIVE:\n                case PRIVATE:\n                case PROTECTED:\n                case PUBLIC:\n                case SHORT:\n                case STATIC:\n                case STRICTFP:\n                case SYNCHRONIZED:\n                case TRANSIENT:\n                case VOLATILE:\n                case IDENTIFIER:\n                case AT:\n                    modifiers = Modifiers();\n                    if (jj_2_40(2147483647)) {\n                        Type();\n                        jj_consume_token(IDENTIFIER);\n                        jj_consume_token(LPAREN);\n                        jj_consume_token(RPAREN);\n                        switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                            case _DEFAULT:\n                                DefaultValue();\n                                break;\n                            default:\n                                ;\n                        }\n                        jj_consume_token(SEMICOLON);\n                    } else {\n                        switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n                            case CLASS:\n                            case INTERFACE:\n                                ClassOrInterfaceDeclaration(modifiers);\n                                break;\n                            case ENUM:\n                                EnumDeclaration(modifiers);\n                                break;\n                            case AT:\n                                AnnotationTypeDeclaration(modifiers);\n                                break;\n                            case BOOLEAN:\n                            case BYTE:\n                            case CHAR:\n                            case DOUBLE:\n                            case FLOAT:\n                            case INT:\n                            case LONG:\n                            case SHORT:\n                            case IDENTIFIER:\n                                FieldDeclaration(modifiers);\n                                break;\n                            default:\n                                jj_consume_token(-1);\n                                throw new ParseException();\n                        }\n                    }\n                    break;\n                case SEMICOLON:\n                    jj_consume_token(SEMICOLON);\n                    break;\n                default:\n                    jj_consume_token(-1);\n                    throw new ParseException();\n            }\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final public void DefaultValue() throws ParseException {\n        /*@bgen(jjtree) DefaultValue */\n        SimpleNode jjtn000 = new SimpleNode(this, JJTDEFAULTVALUE);\n        boolean jjtc000 = true;\n        jjtree.openNodeScope(jjtn000);\n        try {\n            jj_consume_token(_DEFAULT);\n            MemberValue();\n        } catch (Throwable jjte000) {\n            if (jjtc000) {\n                jjtree.clearNodeScope(jjtn000);\n                jjtc000 = false;\n            } else {\n                jjtree.popNode();\n            }\n            if (jjte000 instanceof RuntimeException) {\n                {\n                    if (true) {\n                        throw (RuntimeException) jjte000;\n                    }\n                }\n            }\n            if (jjte000 instanceof ParseException) {\n                {\n                    if (true) {\n                        throw (ParseException) jjte000;\n                    }\n                }\n            }\n            {\n                if (true) {\n                    throw (Error) jjte000;\n                }\n            }\n        } finally {\n            if (jjtc000) {\n                jjtree.closeNodeScope(jjtn000, true);\n            }\n        }\n    }\n\n    final private boolean jj_2_1(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_1();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_2(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_2();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_3(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_3();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_4(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_4();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_5(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_5();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_6(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_6();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_7(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_7();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_8(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_8();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_9(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_9();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_10(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_10();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_11(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_11();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_12(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_12();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_13(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_13();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_14(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_14();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_15(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_15();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_16(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_16();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_17(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_17();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_18(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_18();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_19(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_19();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_20(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_20();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_21(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_21();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_22(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_22();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_23(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_23();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_24(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_24();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_25(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_25();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_26(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_26();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_27(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_27();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_28(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_28();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_29(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_29();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_30(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_30();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_31(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_31();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_32(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_32();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_33(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_33();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_34(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_34();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_35(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_35();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_36(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_36();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_37(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_37();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_38(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_38();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_39(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_39();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_2_40(int xla) {\n        jj_la = xla;\n        jj_lastpos = jj_scanpos = token;\n        try {\n            return !jj_3_40();\n        } catch (LookaheadSuccess ls) {\n            return true;\n        }\n    }\n\n    final private boolean jj_3R_94() {\n        if (jj_3R_123()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3_11()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_93() {\n        if (jj_3R_74()) {\n            return true;\n        }\n        Token xsp;\n        if (jj_3_10()) {\n            return true;\n        }\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3_10()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_67() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_93()) {\n            jj_scanpos = xsp;\n            if (jj_3R_94()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_243() {\n        if (jj_scan_token(THROWS)) {\n            return true;\n        }\n        if (jj_3R_262()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_85() {\n        if (jj_3R_74()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_9() {\n        if (jj_3R_67()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_60() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3_9()) {\n            jj_scanpos = xsp;\n            if (jj_3R_85()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3_8() {\n        if (jj_scan_token(THIS)) {\n            return true;\n        }\n        if (jj_3R_66()) {\n            return true;\n        }\n        if (jj_scan_token(SEMICOLON)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_62() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(52)) {\n            jj_scanpos = xsp;\n        }\n        if (jj_3R_86()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_6() {\n        if (jj_3R_64()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_7() {\n        if (jj_3R_65()) {\n            return true;\n        }\n        if (jj_scan_token(DOT)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_265() {\n        if (jj_scan_token(LBRACKET)) {\n            return true;\n        }\n        if (jj_scan_token(RBRACKET)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_90() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3_7()) {\n            jj_scanpos = xsp;\n        }\n        if (jj_scan_token(SUPER)) {\n            return true;\n        }\n        if (jj_3R_66()) {\n            return true;\n        }\n        if (jj_scan_token(SEMICOLON)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_274() {\n        if (jj_scan_token(COMMA)) {\n            return true;\n        }\n        if (jj_3R_273()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_89() {\n        if (jj_scan_token(THIS)) {\n            return true;\n        }\n        if (jj_3R_66()) {\n            return true;\n        }\n        if (jj_scan_token(SEMICOLON)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_64() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_89()) {\n            jj_scanpos = xsp;\n            if (jj_3R_90()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_245() {\n        if (jj_3R_133()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_244() {\n        if (jj_3R_64()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_241() {\n        if (jj_3R_84()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_231() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_241()) {\n            jj_scanpos = xsp;\n        }\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        if (jj_3R_242()) {\n            return true;\n        }\n        xsp = jj_scanpos;\n        if (jj_3R_243()) {\n            jj_scanpos = xsp;\n        }\n        if (jj_scan_token(LBRACE)) {\n            return true;\n        }\n        xsp = jj_scanpos;\n        if (jj_3R_244()) {\n            jj_scanpos = xsp;\n        }\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_245()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        if (jj_scan_token(RBRACE)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_5() {\n        if (jj_scan_token(COMMA)) {\n            return true;\n        }\n        if (jj_3R_63()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_250() {\n        if (jj_scan_token(THROWS)) {\n            return true;\n        }\n        if (jj_3R_262()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_273() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(31)) {\n            jj_scanpos = xsp;\n        }\n        if (jj_3R_60()) {\n            return true;\n        }\n        xsp = jj_scanpos;\n        if (jj_scan_token(121)) {\n            jj_scanpos = xsp;\n        }\n        if (jj_3R_263()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_261() {\n        if (jj_3R_273()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_274()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_242() {\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_261()) {\n            jj_scanpos = xsp;\n        }\n        if (jj_scan_token(RPAREN)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_249() {\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        if (jj_3R_242()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_265()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_251() {\n        if (jj_3R_86()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_40() {\n        if (jj_3R_60()) {\n            return true;\n        }\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_248() {\n        if (jj_3R_84()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_210() {\n        if (jj_3R_63()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3_5()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_233() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_248()) {\n            jj_scanpos = xsp;\n        }\n        if (jj_3R_76()) {\n            return true;\n        }\n        if (jj_3R_249()) {\n            return true;\n        }\n        xsp = jj_scanpos;\n        if (jj_3R_250()) {\n            jj_scanpos = xsp;\n        }\n        xsp = jj_scanpos;\n        if (jj_3R_251()) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(83)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_264() {\n        if (jj_scan_token(ASSIGN)) {\n            return true;\n        }\n        if (jj_3R_63()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_247() {\n        if (jj_scan_token(COMMA)) {\n            return true;\n        }\n        if (jj_3R_246()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_276() {\n        if (jj_scan_token(LBRACKET)) {\n            return true;\n        }\n        if (jj_scan_token(RBRACKET)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_115() {\n        if (jj_scan_token(LBRACE)) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_210()) {\n            jj_scanpos = xsp;\n        }\n        xsp = jj_scanpos;\n        if (jj_scan_token(84)) {\n            jj_scanpos = xsp;\n        }\n        if (jj_scan_token(RBRACE)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_61() {\n        if (jj_scan_token(LBRACKET)) {\n            return true;\n        }\n        if (jj_scan_token(RBRACKET)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_39() {\n        if (jj_scan_token(COMMA)) {\n            return true;\n        }\n        if (jj_3R_82()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_88() {\n        if (jj_3R_70()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_87() {\n        if (jj_3R_115()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_63() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_87()) {\n            jj_scanpos = xsp;\n            if (jj_3R_88()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_263() {\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_276()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_246() {\n        if (jj_3R_263()) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_264()) {\n            jj_scanpos = xsp;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_3() {\n        if (jj_3R_60()) {\n            return true;\n        }\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_61()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        xsp = jj_scanpos;\n        if (jj_scan_token(84)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(87)) {\n                jj_scanpos = xsp;\n                if (jj_scan_token(83)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_59() {\n        if (jj_3R_84()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_128() {\n        if (jj_scan_token(LBRACE)) {\n            return true;\n        }\n        if (jj_3R_82()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3_39()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        xsp = jj_scanpos;\n        if (jj_scan_token(84)) {\n            jj_scanpos = xsp;\n        }\n        if (jj_scan_token(RBRACE)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_292() {\n        if (jj_scan_token(COMMA)) {\n            return true;\n        }\n        if (jj_3R_291()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_2() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_59()) {\n            jj_scanpos = xsp;\n        }\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_232() {\n        if (jj_3R_60()) {\n            return true;\n        }\n        if (jj_3R_246()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_247()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        if (jj_scan_token(SEMICOLON)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_108() {\n        if (jj_3R_96()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_225() {\n        if (jj_3R_233()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_107() {\n        if (jj_3R_128()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_106() {\n        if (jj_3R_83()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_82() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_106()) {\n            jj_scanpos = xsp;\n            if (jj_3R_107()) {\n                jj_scanpos = xsp;\n                if (jj_3R_108()) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_144() {\n        if (jj_scan_token(BIT_AND)) {\n            return true;\n        }\n        if (jj_3R_123()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_224() {\n        if (jj_3R_232()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_223() {\n        if (jj_3R_231()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_291() {\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        if (jj_scan_token(ASSIGN)) {\n            return true;\n        }\n        if (jj_3R_82()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_222() {\n        if (jj_3R_230()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_221() {\n        if (jj_3R_147()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_281() {\n        if (jj_3R_291()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_292()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_280() {\n        if (jj_3R_281()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_81() {\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        if (jj_scan_token(ASSIGN)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_217() {\n        if (jj_3R_220()) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_221()) {\n            jj_scanpos = xsp;\n            if (jj_3R_222()) {\n                jj_scanpos = xsp;\n                if (jj_3R_223()) {\n                    jj_scanpos = xsp;\n                    if (jj_3R_224()) {\n                        jj_scanpos = xsp;\n                        if (jj_3R_225()) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_130() {\n        if (jj_scan_token(AT)) {\n            return true;\n        }\n        if (jj_3R_80()) {\n            return true;\n        }\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        if (jj_3R_82()) {\n            return true;\n        }\n        if (jj_scan_token(RPAREN)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_4() {\n        if (jj_3R_62()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_214() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3_4()) {\n            jj_scanpos = xsp;\n            if (jj_3R_217()) {\n                jj_scanpos = xsp;\n                if (jj_scan_token(83)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_271() {\n        if (jj_3R_205()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_211() {\n        if (jj_3R_214()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_131() {\n        if (jj_scan_token(AT)) {\n            return true;\n        }\n        if (jj_3R_80()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_113() {\n        if (jj_scan_token(COMMA)) {\n            return true;\n        }\n        if (jj_3R_112()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_132() {\n        if (jj_3R_137()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_38() {\n        if (jj_scan_token(AT)) {\n            return true;\n        }\n        if (jj_3R_80()) {\n            return true;\n        }\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_129() {\n        if (jj_scan_token(AT)) {\n            return true;\n        }\n        if (jj_3R_80()) {\n            return true;\n        }\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_280()) {\n            jj_scanpos = xsp;\n        }\n        if (jj_scan_token(RPAREN)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_205() {\n        if (jj_scan_token(LBRACE)) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_211()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        if (jj_scan_token(RBRACE)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_37() {\n        if (jj_scan_token(AT)) {\n            return true;\n        }\n        if (jj_3R_80()) {\n            return true;\n        }\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_81()) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(78)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_137() {\n        if (jj_scan_token(EXTENDS)) {\n            return true;\n        }\n        if (jj_3R_123()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_144()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_111() {\n        if (jj_3R_131()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_110() {\n        if (jj_3R_130()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_270() {\n        if (jj_3R_66()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_112() {\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_132()) {\n            jj_scanpos = xsp;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_109() {\n        if (jj_3R_129()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_97() {\n        return false;\n    }\n\n    final private boolean jj_3R_83() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_109()) {\n            jj_scanpos = xsp;\n            if (jj_3R_110()) {\n                jj_scanpos = xsp;\n                if (jj_3R_111()) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_259() {\n        if (jj_scan_token(COMMA)) {\n            return true;\n        }\n        if (jj_3R_258()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_84() {\n        if (jj_scan_token(LT)) {\n            return true;\n        }\n        if (jj_3R_112()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_113()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        if (jj_scan_token(GT)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_98() {\n        return false;\n    }\n\n    final private boolean jj_3R_272() {\n        if (jj_3R_214()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_71() {\n        Token xsp;\n        xsp = jj_scanpos;\n        lookingAhead = true;\n        jj_semLA = getToken(1).kind == GT && ((Token.GTToken) getToken(1)).realKind == RSIGNEDSHIFT;\n        lookingAhead = false;\n        if (!jj_semLA || jj_3R_97()) {\n            return true;\n        }\n        if (jj_scan_token(GT)) {\n            return true;\n        }\n        if (jj_scan_token(GT)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_258() {\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_270()) {\n            jj_scanpos = xsp;\n        }\n        xsp = jj_scanpos;\n        if (jj_3R_271()) {\n            jj_scanpos = xsp;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_260() {\n        if (jj_scan_token(SEMICOLON)) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_272()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_240() {\n        if (jj_scan_token(LBRACE)) {\n            return true;\n        }\n        if (jj_3R_258()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_259()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        xsp = jj_scanpos;\n        if (jj_3R_260()) {\n            jj_scanpos = xsp;\n        }\n        if (jj_scan_token(RBRACE)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_72() {\n        Token xsp;\n        xsp = jj_scanpos;\n        lookingAhead = true;\n        jj_semLA = getToken(1).kind == GT && ((Token.GTToken) getToken(1)).realKind == RUNSIGNEDSHIFT;\n        lookingAhead = false;\n        if (!jj_semLA || jj_3R_98()) {\n            return true;\n        }\n        if (jj_scan_token(GT)) {\n            return true;\n        }\n        if (jj_scan_token(GT)) {\n            return true;\n        }\n        if (jj_scan_token(GT)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_239() {\n        if (jj_3R_257()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_290() {\n        if (jj_scan_token(FINALLY)) {\n            return true;\n        }\n        if (jj_3R_86()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_289() {\n        if (jj_scan_token(CATCH)) {\n            return true;\n        }\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        if (jj_3R_273()) {\n            return true;\n        }\n        if (jj_scan_token(RPAREN)) {\n            return true;\n        }\n        if (jj_3R_86()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_230() {\n        if (jj_scan_token(ENUM)) {\n            return true;\n        }\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_239()) {\n            jj_scanpos = xsp;\n        }\n        if (jj_3R_240()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_184() {\n        if (jj_scan_token(TRY)) {\n            return true;\n        }\n        if (jj_3R_86()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_289()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        xsp = jj_scanpos;\n        if (jj_3R_290()) {\n            jj_scanpos = xsp;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_269() {\n        if (jj_scan_token(COMMA)) {\n            return true;\n        }\n        if (jj_3R_123()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_257() {\n        if (jj_scan_token(IMPLEMENTS)) {\n            return true;\n        }\n        if (jj_3R_123()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_269()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_183() {\n        if (jj_scan_token(SYNCHRONIZED)) {\n            return true;\n        }\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        if (jj_scan_token(RPAREN)) {\n            return true;\n        }\n        if (jj_3R_86()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_288() {\n        if (jj_3R_70()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_268() {\n        if (jj_scan_token(COMMA)) {\n            return true;\n        }\n        if (jj_3R_123()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_182() {\n        if (jj_scan_token(THROW)) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        if (jj_scan_token(SEMICOLON)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_256() {\n        if (jj_scan_token(EXTENDS)) {\n            return true;\n        }\n        if (jj_3R_123()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_268()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_298() {\n        if (jj_3R_303()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_167() {\n        if (jj_scan_token(INTERFACE)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_307() {\n        if (jj_scan_token(COMMA)) {\n            return true;\n        }\n        if (jj_3R_173()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_181() {\n        if (jj_scan_token(RETURN)) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_288()) {\n            jj_scanpos = xsp;\n        }\n        if (jj_scan_token(SEMICOLON)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_238() {\n        if (jj_3R_257()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_237() {\n        if (jj_3R_256()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_236() {\n        if (jj_3R_84()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_180() {\n        if (jj_scan_token(CONTINUE)) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(74)) {\n            jj_scanpos = xsp;\n        }\n        if (jj_scan_token(SEMICOLON)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_147() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(21)) {\n            jj_scanpos = xsp;\n            if (jj_3R_167()) {\n                return true;\n            }\n        }\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        xsp = jj_scanpos;\n        if (jj_3R_236()) {\n            jj_scanpos = xsp;\n        }\n        xsp = jj_scanpos;\n        if (jj_3R_237()) {\n            jj_scanpos = xsp;\n        }\n        xsp = jj_scanpos;\n        if (jj_3R_238()) {\n            jj_scanpos = xsp;\n        }\n        if (jj_3R_205()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_179() {\n        if (jj_scan_token(BREAK)) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(74)) {\n            jj_scanpos = xsp;\n        }\n        if (jj_scan_token(SEMICOLON)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_303() {\n        if (jj_3R_306()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_297() {\n        if (jj_3R_70()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_36() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(31)) {\n            jj_scanpos = xsp;\n        }\n        if (jj_3R_60()) {\n            return true;\n        }\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_306() {\n        if (jj_3R_173()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_307()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_285() {\n        if (jj_scan_token(ELSE)) {\n            return true;\n        }\n        if (jj_3R_146()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_305() {\n        if (jj_3R_306()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_35() {\n        if (jj_3R_60()) {\n            return true;\n        }\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        if (jj_scan_token(COLON)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_304() {\n        if (jj_3R_145()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_302() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_304()) {\n            jj_scanpos = xsp;\n            if (jj_3R_305()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_296() {\n        if (jj_3R_302()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_287() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_296()) {\n            jj_scanpos = xsp;\n        }\n        if (jj_scan_token(SEMICOLON)) {\n            return true;\n        }\n        xsp = jj_scanpos;\n        if (jj_3R_297()) {\n            jj_scanpos = xsp;\n        }\n        if (jj_scan_token(SEMICOLON)) {\n            return true;\n        }\n        xsp = jj_scanpos;\n        if (jj_3R_298()) {\n            jj_scanpos = xsp;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_286() {\n        if (jj_3R_60()) {\n            return true;\n        }\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        if (jj_scan_token(COLON)) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_58() {\n        if (jj_3R_83()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_57() {\n        if (jj_scan_token(STRICTFP)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_56() {\n        if (jj_scan_token(VOLATILE)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_178() {\n        if (jj_scan_token(FOR)) {\n            return true;\n        }\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_286()) {\n            jj_scanpos = xsp;\n            if (jj_3R_287()) {\n                return true;\n            }\n        }\n        if (jj_scan_token(RPAREN)) {\n            return true;\n        }\n        if (jj_3R_146()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_55() {\n        if (jj_scan_token(TRANSIENT)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_54() {\n        if (jj_scan_token(NATIVE)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_53() {\n        if (jj_scan_token(SYNCHRONIZED)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_177() {\n        if (jj_scan_token(DO)) {\n            return true;\n        }\n        if (jj_3R_146()) {\n            return true;\n        }\n        if (jj_scan_token(WHILE)) {\n            return true;\n        }\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        if (jj_scan_token(RPAREN)) {\n            return true;\n        }\n        if (jj_scan_token(SEMICOLON)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_52() {\n        if (jj_scan_token(ABSTRACT)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_51() {\n        if (jj_scan_token(FINAL)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_50() {\n        if (jj_scan_token(PRIVATE)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_176() {\n        if (jj_scan_token(WHILE)) {\n            return true;\n        }\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        if (jj_scan_token(RPAREN)) {\n            return true;\n        }\n        if (jj_3R_146()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_49() {\n        if (jj_scan_token(PROTECTED)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_48() {\n        if (jj_scan_token(STATIC)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_295() {\n        if (jj_3R_133()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_47() {\n        if (jj_scan_token(PUBLIC)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_175() {\n        if (jj_scan_token(IF)) {\n            return true;\n        }\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        if (jj_scan_token(RPAREN)) {\n            return true;\n        }\n        if (jj_3R_146()) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_285()) {\n            jj_scanpos = xsp;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_1() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_47()) {\n            jj_scanpos = xsp;\n            if (jj_3R_48()) {\n                jj_scanpos = xsp;\n                if (jj_3R_49()) {\n                    jj_scanpos = xsp;\n                    if (jj_3R_50()) {\n                        jj_scanpos = xsp;\n                        if (jj_3R_51()) {\n                            jj_scanpos = xsp;\n                            if (jj_3R_52()) {\n                                jj_scanpos = xsp;\n                                if (jj_3R_53()) {\n                                    jj_scanpos = xsp;\n                                    if (jj_3R_54()) {\n                                        jj_scanpos = xsp;\n                                        if (jj_3R_55()) {\n                                            jj_scanpos = xsp;\n                                            if (jj_3R_56()) {\n                                                jj_scanpos = xsp;\n                                                if (jj_3R_57()) {\n                                                    jj_scanpos = xsp;\n                                                    if (jj_3R_58()) {\n                                                        return true;\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_220() {\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3_1()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_301() {\n        if (jj_scan_token(_DEFAULT)) {\n            return true;\n        }\n        if (jj_scan_token(COLON)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_300() {\n        if (jj_scan_token(CASE)) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        if (jj_scan_token(COLON)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_294() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_300()) {\n            jj_scanpos = xsp;\n            if (jj_3R_301()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_279() {\n        if (jj_scan_token(COMMA)) {\n            return true;\n        }\n        if (jj_3R_246()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_284() {\n        if (jj_3R_294()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_295()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_174() {\n        if (jj_scan_token(SWITCH)) {\n            return true;\n        }\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        if (jj_scan_token(RPAREN)) {\n            return true;\n        }\n        if (jj_scan_token(LBRACE)) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_284()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        if (jj_scan_token(RBRACE)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_299() {\n        if (jj_3R_69()) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_293() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(99)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(100)) {\n                jj_scanpos = xsp;\n                if (jj_3R_299()) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_189() {\n        if (jj_3R_65()) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_293()) {\n            jj_scanpos = xsp;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_188() {\n        if (jj_3R_198()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_173() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_187()) {\n            jj_scanpos = xsp;\n            if (jj_3R_188()) {\n                jj_scanpos = xsp;\n                if (jj_3R_189()) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_187() {\n        if (jj_3R_197()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_172() {\n        if (jj_scan_token(SEMICOLON)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_145() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(31)) {\n            jj_scanpos = xsp;\n        }\n        if (jj_3R_60()) {\n            return true;\n        }\n        if (jj_3R_246()) {\n            return true;\n        }\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_279()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3_34() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(31)) {\n            jj_scanpos = xsp;\n        }\n        if (jj_3R_60()) {\n            return true;\n        }\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_283() {\n        if (jj_scan_token(COLON)) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_140() {\n        if (jj_3R_147()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_139() {\n        if (jj_3R_146()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_138() {\n        if (jj_3R_145()) {\n            return true;\n        }\n        if (jj_scan_token(SEMICOLON)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_133() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_138()) {\n            jj_scanpos = xsp;\n            if (jj_3R_139()) {\n                jj_scanpos = xsp;\n                if (jj_3R_140()) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_114() {\n        if (jj_3R_133()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_86() {\n        if (jj_scan_token(LBRACE)) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_114()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        if (jj_scan_token(RBRACE)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_79() {\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        if (jj_scan_token(COLON)) {\n            return true;\n        }\n        if (jj_3R_146()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_171() {\n        if (jj_scan_token(ASSERT)) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_283()) {\n            jj_scanpos = xsp;\n        }\n        if (jj_scan_token(SEMICOLON)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_166() {\n        if (jj_3R_184()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_165() {\n        if (jj_3R_183()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_31() {\n        if (jj_scan_token(LBRACKET)) {\n            return true;\n        }\n        if (jj_scan_token(RBRACKET)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_164() {\n        if (jj_3R_182()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_163() {\n        if (jj_3R_181()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_162() {\n        if (jj_3R_180()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_161() {\n        if (jj_3R_179()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_160() {\n        if (jj_3R_178()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_159() {\n        if (jj_3R_177()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_158() {\n        if (jj_3R_176()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_157() {\n        if (jj_3R_175()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_156() {\n        if (jj_3R_174()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_155() {\n        if (jj_3R_173()) {\n            return true;\n        }\n        if (jj_scan_token(SEMICOLON)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_154() {\n        if (jj_3R_172()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_153() {\n        if (jj_3R_86()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_152() {\n        if (jj_3R_171()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_191() {\n        if (jj_3R_68()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_33() {\n        if (jj_3R_79()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_146() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3_33()) {\n            jj_scanpos = xsp;\n            if (jj_3R_152()) {\n                jj_scanpos = xsp;\n                if (jj_3R_153()) {\n                    jj_scanpos = xsp;\n                    if (jj_3R_154()) {\n                        jj_scanpos = xsp;\n                        if (jj_3R_155()) {\n                            jj_scanpos = xsp;\n                            if (jj_3R_156()) {\n                                jj_scanpos = xsp;\n                                if (jj_3R_157()) {\n                                    jj_scanpos = xsp;\n                                    if (jj_3R_158()) {\n                                        jj_scanpos = xsp;\n                                        if (jj_3R_159()) {\n                                            jj_scanpos = xsp;\n                                            if (jj_3R_160()) {\n                                                jj_scanpos = xsp;\n                                                if (jj_3R_161()) {\n                                                    jj_scanpos = xsp;\n                                                    if (jj_3R_162()) {\n                                                        jj_scanpos = xsp;\n                                                        if (jj_3R_163()) {\n                                                            jj_scanpos = xsp;\n                                                            if (jj_3R_164()) {\n                                                                jj_scanpos = xsp;\n                                                                if (jj_3R_165()) {\n                                                                    jj_scanpos = xsp;\n                                                                    if (jj_3R_166()) {\n                                                                        return true;\n                                                                    }\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_200() {\n        if (jj_3R_205()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_204() {\n        if (jj_scan_token(LBRACKET)) {\n            return true;\n        }\n        if (jj_scan_token(RBRACKET)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_30() {\n        if (jj_scan_token(LBRACKET)) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        if (jj_scan_token(RBRACKET)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_199() {\n        Token xsp;\n        if (jj_3R_204()) {\n            return true;\n        }\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_204()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        if (jj_3R_115()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_32() {\n        Token xsp;\n        if (jj_3_30()) {\n            return true;\n        }\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3_30()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3_31()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_190() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3_32()) {\n            jj_scanpos = xsp;\n            if (jj_3R_199()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_193() {\n        if (jj_3R_66()) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_200()) {\n            jj_scanpos = xsp;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_135() {\n        if (jj_scan_token(COMMA)) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_192() {\n        if (jj_3R_190()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_105() {\n        if (jj_scan_token(NEW)) {\n            return true;\n        }\n        if (jj_3R_123()) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_191()) {\n            jj_scanpos = xsp;\n        }\n        xsp = jj_scanpos;\n        if (jj_3R_192()) {\n            jj_scanpos = xsp;\n            if (jj_3R_193()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3_29() {\n        if (jj_scan_token(NEW)) {\n            return true;\n        }\n        if (jj_3R_74()) {\n            return true;\n        }\n        if (jj_3R_190()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_77() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3_29()) {\n            jj_scanpos = xsp;\n            if (jj_3R_105()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_122() {\n        if (jj_3R_70()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_135()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_92() {\n        if (jj_3R_122()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_66() {\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_92()) {\n            jj_scanpos = xsp;\n        }\n        if (jj_scan_token(RPAREN)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_149() {\n        if (jj_scan_token(NULL)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_148() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(61)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(30)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_142() {\n        if (jj_3R_149()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_141() {\n        if (jj_3R_148()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_127() {\n        if (jj_3R_134()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_134() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(66)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(70)) {\n                jj_scanpos = xsp;\n                if (jj_scan_token(72)) {\n                    jj_scanpos = xsp;\n                    if (jj_scan_token(73)) {\n                        jj_scanpos = xsp;\n                        if (jj_3R_141()) {\n                            jj_scanpos = xsp;\n                            if (jj_3R_142()) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_103() {\n        if (jj_3R_66()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_102() {\n        if (jj_scan_token(DOT)) {\n            return true;\n        }\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_101() {\n        if (jj_scan_token(LBRACKET)) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        if (jj_scan_token(RBRACKET)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_28() {\n        if (jj_3R_78()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_27() {\n        if (jj_scan_token(DOT)) {\n            return true;\n        }\n        if (jj_3R_77()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_25() {\n        if (jj_3R_76()) {\n            return true;\n        }\n        if (jj_scan_token(DOT)) {\n            return true;\n        }\n        if (jj_scan_token(CLASS)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_26() {\n        if (jj_scan_token(DOT)) {\n            return true;\n        }\n        if (jj_scan_token(THIS)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_75() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3_26()) {\n            jj_scanpos = xsp;\n            if (jj_3_27()) {\n                jj_scanpos = xsp;\n                if (jj_3_28()) {\n                    jj_scanpos = xsp;\n                    if (jj_3R_101()) {\n                        jj_scanpos = xsp;\n                        if (jj_3R_102()) {\n                            jj_scanpos = xsp;\n                            if (jj_3R_103()) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_121() {\n        if (jj_3R_80()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_120() {\n        if (jj_3R_76()) {\n            return true;\n        }\n        if (jj_scan_token(DOT)) {\n            return true;\n        }\n        if (jj_scan_token(CLASS)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_119() {\n        if (jj_3R_77()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_118() {\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        if (jj_scan_token(RPAREN)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_24() {\n        if (jj_3R_75()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_117() {\n        if (jj_scan_token(SUPER)) {\n            return true;\n        }\n        if (jj_scan_token(DOT)) {\n            return true;\n        }\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_116() {\n        if (jj_3R_134()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_91() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_116()) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(57)) {\n                jj_scanpos = xsp;\n                if (jj_3R_117()) {\n                    jj_scanpos = xsp;\n                    if (jj_3R_118()) {\n                        jj_scanpos = xsp;\n                        if (jj_3R_119()) {\n                            jj_scanpos = xsp;\n                            if (jj_3R_120()) {\n                                jj_scanpos = xsp;\n                                if (jj_3R_121()) {\n                                    return true;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_282() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(99)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(100)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_78() {\n        if (jj_scan_token(DOT)) {\n            return true;\n        }\n        if (jj_3R_68()) {\n            return true;\n        }\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_23() {\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        if (jj_3R_74()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_65() {\n        if (jj_3R_91()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3_24()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_278() {\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        if (jj_3R_60()) {\n            return true;\n        }\n        if (jj_scan_token(RPAREN)) {\n            return true;\n        }\n        if (jj_3R_235()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_277() {\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        if (jj_3R_60()) {\n            return true;\n        }\n        if (jj_scan_token(RPAREN)) {\n            return true;\n        }\n        if (jj_3R_219()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_266() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_277()) {\n            jj_scanpos = xsp;\n            if (jj_3R_278()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3_22() {\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        if (jj_3R_60()) {\n            return true;\n        }\n        if (jj_scan_token(LBRACKET)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_267() {\n        if (jj_3R_65()) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_282()) {\n            jj_scanpos = xsp;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_100() {\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        if (jj_3R_60()) {\n            return true;\n        }\n        if (jj_scan_token(RPAREN)) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(90)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(89)) {\n                jj_scanpos = xsp;\n                if (jj_scan_token(77)) {\n                    jj_scanpos = xsp;\n                    if (jj_scan_token(74)) {\n                        jj_scanpos = xsp;\n                        if (jj_scan_token(57)) {\n                            jj_scanpos = xsp;\n                            if (jj_scan_token(54)) {\n                                jj_scanpos = xsp;\n                                if (jj_scan_token(44)) {\n                                    jj_scanpos = xsp;\n                                    if (jj_3R_127()) {\n                                        return true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_99() {\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        if (jj_3R_60()) {\n            return true;\n        }\n        if (jj_scan_token(LBRACKET)) {\n            return true;\n        }\n        if (jj_scan_token(RBRACKET)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_21() {\n        if (jj_scan_token(LPAREN)) {\n            return true;\n        }\n        if (jj_3R_74()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_73() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3_21()) {\n            jj_scanpos = xsp;\n            if (jj_3R_99()) {\n                jj_scanpos = xsp;\n                if (jj_3R_100()) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3_20() {\n        if (jj_3R_73()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_19() {\n        if (jj_3R_72()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_255() {\n        if (jj_3R_267()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_254() {\n        if (jj_3R_266()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_235() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_253()) {\n            jj_scanpos = xsp;\n            if (jj_3R_254()) {\n                jj_scanpos = xsp;\n                if (jj_3R_255()) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_253() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(90)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(89)) {\n                return true;\n            }\n        }\n        if (jj_3R_219()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_198() {\n        if (jj_scan_token(DECR)) {\n            return true;\n        }\n        if (jj_3R_65()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_234() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(101)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(102)) {\n                return true;\n            }\n        }\n        if (jj_3R_216()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_18() {\n        if (jj_3R_71()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_252() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(103)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(104)) {\n                jj_scanpos = xsp;\n                if (jj_scan_token(108)) {\n                    return true;\n                }\n            }\n        }\n        if (jj_3R_219()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_197() {\n        if (jj_scan_token(INCR)) {\n            return true;\n        }\n        if (jj_3R_65()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_229() {\n        if (jj_3R_235()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_17() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(109)) {\n            jj_scanpos = xsp;\n            if (jj_3_18()) {\n                jj_scanpos = xsp;\n                if (jj_3_19()) {\n                    return true;\n                }\n            }\n        }\n        if (jj_3R_213()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_228() {\n        if (jj_3R_198()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_227() {\n        if (jj_3R_197()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_219() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_226()) {\n            jj_scanpos = xsp;\n            if (jj_3R_227()) {\n                jj_scanpos = xsp;\n                if (jj_3R_228()) {\n                    jj_scanpos = xsp;\n                    if (jj_3R_229()) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_226() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(101)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(102)) {\n                return true;\n            }\n        }\n        if (jj_3R_219()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_218() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(88)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(124)) {\n                jj_scanpos = xsp;\n                if (jj_scan_token(94)) {\n                    jj_scanpos = xsp;\n                    if (jj_scan_token(95)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        if (jj_3R_207()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_215() {\n        if (jj_scan_token(INSTANCEOF)) {\n            return true;\n        }\n        if (jj_3R_60()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_216() {\n        if (jj_3R_219()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_252()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_212() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(93)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(96)) {\n                return true;\n            }\n        }\n        if (jj_3R_195()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_213() {\n        if (jj_3R_216()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_234()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_207() {\n        if (jj_3R_213()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3_17()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_206() {\n        if (jj_scan_token(BIT_AND)) {\n            return true;\n        }\n        if (jj_3R_186()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_202() {\n        if (jj_3R_207()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_218()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_194() {\n        if (jj_scan_token(BIT_OR)) {\n            return true;\n        }\n        if (jj_3R_151()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_195() {\n        if (jj_3R_202()) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_215()) {\n            jj_scanpos = xsp;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_201() {\n        if (jj_scan_token(XOR)) {\n            return true;\n        }\n        if (jj_3R_169()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_185() {\n        if (jj_scan_token(SC_AND)) {\n            return true;\n        }\n        if (jj_3R_143()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_186() {\n        if (jj_3R_195()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_212()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_168() {\n        if (jj_scan_token(SC_OR)) {\n            return true;\n        }\n        if (jj_3R_136()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_169() {\n        if (jj_3R_186()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_206()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_150() {\n        if (jj_scan_token(HOOK)) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        if (jj_scan_token(COLON)) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_151() {\n        if (jj_3R_169()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_201()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_143() {\n        if (jj_3R_151()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_194()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_136() {\n        if (jj_3R_143()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_185()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_126() {\n        if (jj_3R_136()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_168()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_96() {\n        if (jj_3R_126()) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_150()) {\n            jj_scanpos = xsp;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_69() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(87)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(112)) {\n                jj_scanpos = xsp;\n                if (jj_scan_token(113)) {\n                    jj_scanpos = xsp;\n                    if (jj_scan_token(117)) {\n                        jj_scanpos = xsp;\n                        if (jj_scan_token(110)) {\n                            jj_scanpos = xsp;\n                            if (jj_scan_token(111)) {\n                                jj_scanpos = xsp;\n                                if (jj_scan_token(118)) {\n                                    jj_scanpos = xsp;\n                                    if (jj_scan_token(119)) {\n                                        jj_scanpos = xsp;\n                                        if (jj_scan_token(120)) {\n                                            jj_scanpos = xsp;\n                                            if (jj_scan_token(114)) {\n                                                jj_scanpos = xsp;\n                                                if (jj_scan_token(116)) {\n                                                    jj_scanpos = xsp;\n                                                    if (jj_scan_token(115)) {\n                                                        return true;\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3_16() {\n        if (jj_3R_69()) {\n            return true;\n        }\n        if (jj_3R_70()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_70() {\n        if (jj_3R_96()) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3_16()) {\n            jj_scanpos = xsp;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_275() {\n        if (jj_scan_token(COMMA)) {\n            return true;\n        }\n        if (jj_3R_80()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_262() {\n        if (jj_3R_80()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_275()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3_15() {\n        if (jj_scan_token(DOT)) {\n            return true;\n        }\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_80() {\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3_15()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_104() {\n        if (jj_3R_60()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_76() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(63)) {\n            jj_scanpos = xsp;\n            if (jj_3R_104()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3_14() {\n        if (jj_3R_68()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_74() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_scan_token(15)) {\n            jj_scanpos = xsp;\n            if (jj_scan_token(20)) {\n                jj_scanpos = xsp;\n                if (jj_scan_token(17)) {\n                    jj_scanpos = xsp;\n                    if (jj_scan_token(51)) {\n                        jj_scanpos = xsp;\n                        if (jj_scan_token(40)) {\n                            jj_scanpos = xsp;\n                            if (jj_scan_token(42)) {\n                                jj_scanpos = xsp;\n                                if (jj_scan_token(33)) {\n                                    jj_scanpos = xsp;\n                                    if (jj_scan_token(26)) {\n                                        return true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_170() {\n        if (jj_scan_token(COMMA)) {\n            return true;\n        }\n        if (jj_3R_95()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_11() {\n        if (jj_scan_token(LBRACKET)) {\n            return true;\n        }\n        if (jj_scan_token(RBRACKET)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_209() {\n        if (jj_scan_token(SUPER)) {\n            return true;\n        }\n        if (jj_3R_67()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_196() {\n        if (jj_3R_203()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_203() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_208()) {\n            jj_scanpos = xsp;\n            if (jj_3R_209()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_208() {\n        if (jj_scan_token(EXTENDS)) {\n            return true;\n        }\n        if (jj_3R_67()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_125() {\n        if (jj_scan_token(HOOK)) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_196()) {\n            jj_scanpos = xsp;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_12() {\n        if (jj_3R_68()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_124() {\n        if (jj_3R_67()) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_95() {\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3R_124()) {\n            jj_scanpos = xsp;\n            if (jj_3R_125()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    final private boolean jj_3_10() {\n        if (jj_scan_token(LBRACKET)) {\n            return true;\n        }\n        if (jj_scan_token(RBRACKET)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_68() {\n        if (jj_scan_token(LT)) {\n            return true;\n        }\n        if (jj_3R_95()) {\n            return true;\n        }\n        Token xsp;\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3R_170()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        if (jj_scan_token(GT)) {\n            return true;\n        }\n        return false;\n    }\n\n    final private boolean jj_3_13() {\n        if (jj_scan_token(DOT)) {\n            return true;\n        }\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3_14()) {\n            jj_scanpos = xsp;\n        }\n        return false;\n    }\n\n    final private boolean jj_3R_123() {\n        if (jj_scan_token(IDENTIFIER)) {\n            return true;\n        }\n        Token xsp;\n        xsp = jj_scanpos;\n        if (jj_3_12()) {\n            jj_scanpos = xsp;\n        }\n        while (true) {\n            xsp = jj_scanpos;\n            if (jj_3_13()) {\n                jj_scanpos = xsp;\n                break;\n            }\n        }\n        return false;\n    }\n\n    public JavaParserTokenManager token_source;\n\n    JavaCharStream jj_input_stream;\n\n    public Token token, jj_nt;\n\n    private int jj_ntk;\n\n    private Token jj_scanpos, jj_lastpos;\n\n    private int jj_la;\n\n    public boolean lookingAhead = false;\n\n    private boolean jj_semLA;\n\n    public JavaParser(java.io.InputStream stream) {\n        jj_input_stream = new JavaCharStream(stream, 1, 1);\n        token_source = new JavaParserTokenManager(jj_input_stream);\n        token = new Token();\n        jj_ntk = -1;\n    }\n\n    public void ReInit(java.io.InputStream stream) {\n        jj_input_stream.ReInit(stream, 1, 1);\n        token_source.ReInit(jj_input_stream);\n        token = new Token();\n        jj_ntk = -1;\n        jjtree.reset();\n    }\n\n    public JavaParser(java.io.Reader stream) {\n        jj_input_stream = new JavaCharStream(stream, 1, 1);\n        token_source = new JavaParserTokenManager(jj_input_stream);\n        token = new Token();\n        jj_ntk = -1;\n    }\n\n    public void ReInit(java.io.Reader stream) {\n        jj_input_stream.ReInit(stream, 1, 1);\n        token_source.ReInit(jj_input_stream);\n        token = new Token();\n        jj_ntk = -1;\n        jjtree.reset();\n    }\n\n    public JavaParser(JavaParserTokenManager tm) {\n        token_source = tm;\n        token = new Token();\n        jj_ntk = -1;\n    }\n\n    public void ReInit(JavaParserTokenManager tm) {\n        token_source = tm;\n        token = new Token();\n        jj_ntk = -1;\n        jjtree.reset();\n    }\n\n    final private Token jj_consume_token(int kind) throws ParseException {\n        Token oldToken;\n        if ((oldToken = token).next != null) {\n            token = token.next;\n        } else {\n            token = token.next = token_source.getNextToken();\n        }\n        jj_ntk = -1;\n        // << to do >> cleasn up the remarked out code\n        // these are the literals\n        if (token.kind >= 66 && token.kind <= 74) {\n            if (currNode != null) {\n                //      currNode.setIdentifier( token.toString());\n                //       setNode(true);\n            }\n        }\n        if (token.kind == kind) {\n            //         if (!nodeIsSet) {\n            currNode.setIdentifier(token.toString());\n            //   setNode(true);\n            //         }\n            return token;\n        }\n        token = oldToken;\n        throw generateParseException();\n    }\n\n    static private final class LookaheadSuccess extends java.lang.Error {\n    }\n\n    final private LookaheadSuccess jj_ls = new LookaheadSuccess();\n\n    final private boolean jj_scan_token(int kind) {\n        if (jj_scanpos == jj_lastpos) {\n            jj_la--;\n            if (jj_scanpos.next == null) {\n                jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();\n            } else {\n                jj_lastpos = jj_scanpos = jj_scanpos.next;\n            }\n        } else {\n            jj_scanpos = jj_scanpos.next;\n        }\n        if (jj_scanpos.kind != kind) {\n            return true;\n        }\n        if (jj_la == 0 && jj_scanpos == jj_lastpos) {\n            throw jj_ls;\n        }\n        return false;\n    }\n\n    final public Token getNextToken() {\n        if (token.next != null) {\n            token = token.next;\n        } else {\n            token = token.next = token_source.getNextToken();\n        }\n        jj_ntk = -1;\n        return token;\n    }\n\n    final public Token getToken(int index) {\n        Token t = lookingAhead ? jj_scanpos : token;\n        for (int i = 0; i < index; i++) {\n            if (t.next != null) {\n                t = t.next;\n            } else {\n                t = t.next = token_source.getNextToken();\n            }\n        }\n        return t;\n    }\n\n    final private int jj_ntk() {\n        if ((jj_nt = token.next) == null) {\n            return (jj_ntk = (token.next = token_source.getNextToken()).kind);\n        } else {\n            return (jj_ntk = jj_nt.kind);\n        }\n    }\n\n    public ParseException generateParseException() {\n        Token errortok = token.next;\n        int line = errortok.beginLine, column = errortok.beginColumn;\n        String mess = (errortok.kind == 0) ? tokenImage[0] : errortok.image;\n        return new ParseException(\"Parse error at line \" + line + \", column \" + column + \".  Encountered: \" + mess);\n    }\n\n    final public void enable_tracing() {\n    }\n\n    final public void disable_tracing() {\n    }\n}\n",
		"id": "EvoSuiteBenchmark/19_jmca/src/main/java/com/soops/CEN4010/JMCA/JParser/JavaParserTest1.java",
		"test_prompt": "// JavaParserTest1.java\npackage com.soops.CEN4010.JMCA.JParser;\n\n/* Generated By:JJTree&JavaCC: Do not edit this line. JavaParser.java */\nimport java.io.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JavaParser}.\n* It contains ten unit test cases for the {@link JavaParser#generateParseException()} method.\n*/\nclass JavaParserTest1 {"
	},
	{
		"original_code": "// Token.java\npackage com.soops.CEN4010.JMCA.JParser;\n\n/* Generated By:JavaCC: Do not edit this line. Token.java Version 3.0 */\n/**\n * Describes the input token stream.\n */\npublic class Token {\n\n    /**\n     * An integer that describes the kind of this token.  This numbering\n     * system is determined by JavaCCParser, and a table of these numbers is\n     * stored in the file ...Constants.java.\n     */\n    public int kind;\n\n    /**\n     * beginLine and beginColumn describe the position of the first character\n     * of this token; endLine and endColumn describe the position of the\n     * last character of this token.\n     */\n    public int beginLine, beginColumn, endLine, endColumn;\n\n    /**\n     * The string image of the token.\n     */\n    public String image;\n\n    /**\n     * A reference to the next regular (non-special) token from the input\n     * stream.  If this is the last token from the input stream, or if the\n     * token manager has not read tokens beyond this one, this field is\n     * set to null.  This is true only if this token is also a regular\n     * token.  Otherwise, see below for a description of the contents of\n     * this field.\n     */\n    public Token next;\n\n    /**\n     * This field is used to access special tokens that occur prior to this\n     * token, but after the immediately preceding regular (non-special) token.\n     * If there are no such special tokens, this field is set to null.\n     * When there are more than one such special token, this field refers\n     * to the last of these special tokens, which in turn refers to the next\n     * previous special token through its specialToken field, and so on\n     * until the first special token (whose specialToken field is null).\n     * The next fields of special tokens refer to other special tokens that\n     * immediately follow it (without an intervening regular token).  If there\n     * is no such token, this field is null.\n     */\n    public Token specialToken;\n\n    /**\n     * Returns the image.\n     */\n    public String toString() {\n        return image;\n    }\n\n    /**\n     * Returns a new Token object, by default. However, if you want, you\n     * can create and return subclass objects based on the value of ofKind.\n     * Simply add the cases to the switch for all those special cases.\n     * For example, if you have a subclass of Token called IDToken that\n     * you want to create if ofKind is ID, simlpy add something like :\n     *\n     *    case MyParserConstants.ID : return new IDToken();\n     *\n     * to the following switch statement. Then you can cast matchedToken\n     * variable to the appropriate type and use it in your lexical actions.\n     */\n    public static final Token newToken(int ofKind) {\n        switch(ofKind) {\n            default:\n                return new Token();\n            case JavaParserConstants.RUNSIGNEDSHIFT:\n            case JavaParserConstants.RSIGNEDSHIFT:\n            case JavaParserConstants.GT:\n                return new GTToken();\n        }\n    }\n\n    public static class GTToken extends Token {\n\n        int realKind = JavaParserConstants.GT;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/19_jmca/src/main/java/com/soops/CEN4010/JMCA/JParser/TokenTest.java",
		"test_prompt": "// TokenTest.java\npackage com.soops.CEN4010.JMCA.JParser;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Token}.\n* It contains ten unit test cases for the {@link Token#newToken(int)} method.\n*/\nclass TokenTest {"
	},
	{
		"original_code": "// SimpleNode.java\npackage com.soops.CEN4010.JMCA.JParser;\n\nimport java.io.*;\nimport java.util.*;\n\n/* Generated By:JJTree: Do not edit this line. SimpleNode.java */\npublic class SimpleNode implements Node {\n\n    protected Node parent;\n\n    protected Node[] children;\n\n    protected int id;\n\n    protected JavaParser parser;\n\n    ArrayList<String> identifiers = new ArrayList<String>();\n\n    public SimpleNode(int i) {\n        id = i;\n    }\n\n    public SimpleNode(JavaParser p, int i) {\n        this(i);\n        parser = p;\n        parser.currNode = this;\n        //      parser.setNode(false);\n        /*   if (parser == null)\n             identifier = \"Parser is null\";\n           else if (parser.token == null)\n             identifier = \"Token is Null\";\n           else if (parser.token.next == null) identifier = \"Next is null\";\n           else\n         */\n        // if (parser.token != null)\n        //      identifier = parser.token.toString();\n        // identifier = parser.token.toString();\n    }\n\n    public void setIdentifier(String s) {\n        identifiers.add(s);\n    }\n\n    public void jjtOpen() {\n    }\n\n    public void jjtClose() {\n    }\n\n    public void jjtSetParent(Node n) {\n        parent = n;\n    }\n\n    public Node jjtGetParent() {\n        return parent;\n    }\n\n    public void jjtAddChild(Node n, int i) {\n        if (children == null) {\n            children = new Node[i + 1];\n        } else if (i >= children.length) {\n            Node[] c = new Node[i + 1];\n            System.arraycopy(children, 0, c, 0, children.length);\n            children = c;\n        }\n        children[i] = n;\n    }\n\n    public Node jjtGetChild(int i) {\n        return children[i];\n    }\n\n    public int jjtGetNumChildren() {\n        return (children == null) ? 0 : children.length;\n    }\n\n    /* You can override these two methods in subclasses of SimpleNode to\n       customize the way the node appears when the tree is dumped.  If\n       your output uses more than one line you should override\n       toString(String), otherwise overriding toString() is probably all\n       you need to do. */\n    public String toString() {\n        String tmpString = JavaParserTreeConstants.jjtNodeName[id];\n        for (String identifier : identifiers) {\n            tmpString += \" : \" + identifier;\n        }\n        return tmpString;\n    }\n\n    public String toString(String prefix) {\n        return prefix + toString();\n    }\n\n    /* Override this method if you want to customize how the node dumps\n       out its children. */\n    public void dump(String prefix, Writer wtr) throws IOException {\n        // System.out.println(toString(prefix));\n        if (identifiers.size() > 0) {\n            wtr.write(\"<\" + JavaParserTreeConstants.jjtNodeName[id] + \">\" + '\\n');\n            if (JavaParserTreeConstants.jjtNodeName[id].equals(\"Literal\")) {\n                wtr.write(\"<identifier>Literal Value</identifier>\" + '\\n');\n            } else {\n                // write the identifier except for \";\" \"{\" \"}\" \"\"\n                for (String identifier : identifiers) {\n                    if (!(identifier.equals(\";\") || identifier.equals(\"}\") || identifier.equals(\"{\") || identifier.equals(\"\"))) {\n                        // don't write the last ) for method params\n                        if (!(JavaParserTreeConstants.jjtNodeName[id].equals(\"VariableDeclaratorId\") && identifier.equals(\")\"))) {\n                            // change identifiers that will mess up the xml markup\n                            if (identifier.equals(\"<\")) {\n                                identifier = \"*lt\";\n                            }\n                            if (identifier.equals(\">\")) {\n                                identifier = \"*gt\";\n                            }\n                            if (identifier.equals(\">>\")) {\n                                identifier = \"*rshft\";\n                            }\n                            if (identifier.equals(\"<<\")) {\n                                identifier = \"*lshft\";\n                            }\n                            if (identifier.equals(\"<=\")) {\n                                identifier = \"*le\";\n                            }\n                            if (identifier.equals(\">=\")) {\n                                identifier = \"*ge\";\n                            }\n                            if (identifier.equals(\"&\") || identifier.equals(\"&&\")) {\n                                identifier = \"*amp\";\n                            }\n                            wtr.write(\"  <identifier>\" + identifier + \"</identifier>\" + '\\n');\n                        }\n                    }\n                }\n            }\n        } else {\n            if (children != null && children.length > 0) {\n                wtr.write(\"<\" + JavaParserTreeConstants.jjtNodeName[id] + \">\");\n            }\n        }\n        if (children != null) {\n            for (int i = 0; i < children.length; ++i) {\n                SimpleNode n = (SimpleNode) children[i];\n                if (n != null) {\n                    n.dump(prefix + \" \", wtr);\n                }\n            }\n        }\n        if (identifiers.size() > 0 || (children != null && children.length > 0)) {\n            wtr.write(\"</\" + JavaParserTreeConstants.jjtNodeName[id] + \">\" + '\\n');\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/19_jmca/src/main/java/com/soops/CEN4010/JMCA/JParser/SimpleNodeTest0.java",
		"test_prompt": "// SimpleNodeTest0.java\npackage com.soops.CEN4010.JMCA.JParser;\n\nimport java.io.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleNode}.\n* It contains ten unit test cases for the {@link SimpleNode#jjtGetParent()} method.\n*/\nclass SimpleNodeTest0 {"
	},
	{
		"original_code": "// SimpleNode.java\npackage com.soops.CEN4010.JMCA.JParser;\n\nimport java.io.*;\nimport java.util.*;\n\n/* Generated By:JJTree: Do not edit this line. SimpleNode.java */\npublic class SimpleNode implements Node {\n\n    protected Node parent;\n\n    protected Node[] children;\n\n    protected int id;\n\n    protected JavaParser parser;\n\n    ArrayList<String> identifiers = new ArrayList<String>();\n\n    public SimpleNode(int i) {\n        id = i;\n    }\n\n    public SimpleNode(JavaParser p, int i) {\n        this(i);\n        parser = p;\n        parser.currNode = this;\n        //      parser.setNode(false);\n        /*   if (parser == null)\n             identifier = \"Parser is null\";\n           else if (parser.token == null)\n             identifier = \"Token is Null\";\n           else if (parser.token.next == null) identifier = \"Next is null\";\n           else\n         */\n        // if (parser.token != null)\n        //      identifier = parser.token.toString();\n        // identifier = parser.token.toString();\n    }\n\n    public void setIdentifier(String s) {\n        identifiers.add(s);\n    }\n\n    public void jjtOpen() {\n    }\n\n    public void jjtClose() {\n    }\n\n    public void jjtSetParent(Node n) {\n        parent = n;\n    }\n\n    public Node jjtGetParent() {\n        return parent;\n    }\n\n    public void jjtAddChild(Node n, int i) {\n        if (children == null) {\n            children = new Node[i + 1];\n        } else if (i >= children.length) {\n            Node[] c = new Node[i + 1];\n            System.arraycopy(children, 0, c, 0, children.length);\n            children = c;\n        }\n        children[i] = n;\n    }\n\n    public Node jjtGetChild(int i) {\n        return children[i];\n    }\n\n    public int jjtGetNumChildren() {\n        return (children == null) ? 0 : children.length;\n    }\n\n    /* You can override these two methods in subclasses of SimpleNode to\n       customize the way the node appears when the tree is dumped.  If\n       your output uses more than one line you should override\n       toString(String), otherwise overriding toString() is probably all\n       you need to do. */\n    public String toString() {\n        String tmpString = JavaParserTreeConstants.jjtNodeName[id];\n        for (String identifier : identifiers) {\n            tmpString += \" : \" + identifier;\n        }\n        return tmpString;\n    }\n\n    public String toString(String prefix) {\n        return prefix + toString();\n    }\n\n    /* Override this method if you want to customize how the node dumps\n       out its children. */\n    public void dump(String prefix, Writer wtr) throws IOException {\n        // System.out.println(toString(prefix));\n        if (identifiers.size() > 0) {\n            wtr.write(\"<\" + JavaParserTreeConstants.jjtNodeName[id] + \">\" + '\\n');\n            if (JavaParserTreeConstants.jjtNodeName[id].equals(\"Literal\")) {\n                wtr.write(\"<identifier>Literal Value</identifier>\" + '\\n');\n            } else {\n                // write the identifier except for \";\" \"{\" \"}\" \"\"\n                for (String identifier : identifiers) {\n                    if (!(identifier.equals(\";\") || identifier.equals(\"}\") || identifier.equals(\"{\") || identifier.equals(\"\"))) {\n                        // don't write the last ) for method params\n                        if (!(JavaParserTreeConstants.jjtNodeName[id].equals(\"VariableDeclaratorId\") && identifier.equals(\")\"))) {\n                            // change identifiers that will mess up the xml markup\n                            if (identifier.equals(\"<\")) {\n                                identifier = \"*lt\";\n                            }\n                            if (identifier.equals(\">\")) {\n                                identifier = \"*gt\";\n                            }\n                            if (identifier.equals(\">>\")) {\n                                identifier = \"*rshft\";\n                            }\n                            if (identifier.equals(\"<<\")) {\n                                identifier = \"*lshft\";\n                            }\n                            if (identifier.equals(\"<=\")) {\n                                identifier = \"*le\";\n                            }\n                            if (identifier.equals(\">=\")) {\n                                identifier = \"*ge\";\n                            }\n                            if (identifier.equals(\"&\") || identifier.equals(\"&&\")) {\n                                identifier = \"*amp\";\n                            }\n                            wtr.write(\"  <identifier>\" + identifier + \"</identifier>\" + '\\n');\n                        }\n                    }\n                }\n            }\n        } else {\n            if (children != null && children.length > 0) {\n                wtr.write(\"<\" + JavaParserTreeConstants.jjtNodeName[id] + \">\");\n            }\n        }\n        if (children != null) {\n            for (int i = 0; i < children.length; ++i) {\n                SimpleNode n = (SimpleNode) children[i];\n                if (n != null) {\n                    n.dump(prefix + \" \", wtr);\n                }\n            }\n        }\n        if (identifiers.size() > 0 || (children != null && children.length > 0)) {\n            wtr.write(\"</\" + JavaParserTreeConstants.jjtNodeName[id] + \">\" + '\\n');\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/19_jmca/src/main/java/com/soops/CEN4010/JMCA/JParser/SimpleNodeTest1.java",
		"test_prompt": "// SimpleNodeTest1.java\npackage com.soops.CEN4010.JMCA.JParser;\n\nimport java.io.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleNode}.\n* It contains ten unit test cases for the {@link SimpleNode#jjtGetChild(int)} method.\n*/\nclass SimpleNodeTest1 {"
	},
	{
		"original_code": "// SimpleNode.java\npackage com.soops.CEN4010.JMCA.JParser;\n\nimport java.io.*;\nimport java.util.*;\n\n/* Generated By:JJTree: Do not edit this line. SimpleNode.java */\npublic class SimpleNode implements Node {\n\n    protected Node parent;\n\n    protected Node[] children;\n\n    protected int id;\n\n    protected JavaParser parser;\n\n    ArrayList<String> identifiers = new ArrayList<String>();\n\n    public SimpleNode(int i) {\n        id = i;\n    }\n\n    public SimpleNode(JavaParser p, int i) {\n        this(i);\n        parser = p;\n        parser.currNode = this;\n        //      parser.setNode(false);\n        /*   if (parser == null)\n             identifier = \"Parser is null\";\n           else if (parser.token == null)\n             identifier = \"Token is Null\";\n           else if (parser.token.next == null) identifier = \"Next is null\";\n           else\n         */\n        // if (parser.token != null)\n        //      identifier = parser.token.toString();\n        // identifier = parser.token.toString();\n    }\n\n    public void setIdentifier(String s) {\n        identifiers.add(s);\n    }\n\n    public void jjtOpen() {\n    }\n\n    public void jjtClose() {\n    }\n\n    public void jjtSetParent(Node n) {\n        parent = n;\n    }\n\n    public Node jjtGetParent() {\n        return parent;\n    }\n\n    public void jjtAddChild(Node n, int i) {\n        if (children == null) {\n            children = new Node[i + 1];\n        } else if (i >= children.length) {\n            Node[] c = new Node[i + 1];\n            System.arraycopy(children, 0, c, 0, children.length);\n            children = c;\n        }\n        children[i] = n;\n    }\n\n    public Node jjtGetChild(int i) {\n        return children[i];\n    }\n\n    public int jjtGetNumChildren() {\n        return (children == null) ? 0 : children.length;\n    }\n\n    /* You can override these two methods in subclasses of SimpleNode to\n       customize the way the node appears when the tree is dumped.  If\n       your output uses more than one line you should override\n       toString(String), otherwise overriding toString() is probably all\n       you need to do. */\n    public String toString() {\n        String tmpString = JavaParserTreeConstants.jjtNodeName[id];\n        for (String identifier : identifiers) {\n            tmpString += \" : \" + identifier;\n        }\n        return tmpString;\n    }\n\n    public String toString(String prefix) {\n        return prefix + toString();\n    }\n\n    /* Override this method if you want to customize how the node dumps\n       out its children. */\n    public void dump(String prefix, Writer wtr) throws IOException {\n        // System.out.println(toString(prefix));\n        if (identifiers.size() > 0) {\n            wtr.write(\"<\" + JavaParserTreeConstants.jjtNodeName[id] + \">\" + '\\n');\n            if (JavaParserTreeConstants.jjtNodeName[id].equals(\"Literal\")) {\n                wtr.write(\"<identifier>Literal Value</identifier>\" + '\\n');\n            } else {\n                // write the identifier except for \";\" \"{\" \"}\" \"\"\n                for (String identifier : identifiers) {\n                    if (!(identifier.equals(\";\") || identifier.equals(\"}\") || identifier.equals(\"{\") || identifier.equals(\"\"))) {\n                        // don't write the last ) for method params\n                        if (!(JavaParserTreeConstants.jjtNodeName[id].equals(\"VariableDeclaratorId\") && identifier.equals(\")\"))) {\n                            // change identifiers that will mess up the xml markup\n                            if (identifier.equals(\"<\")) {\n                                identifier = \"*lt\";\n                            }\n                            if (identifier.equals(\">\")) {\n                                identifier = \"*gt\";\n                            }\n                            if (identifier.equals(\">>\")) {\n                                identifier = \"*rshft\";\n                            }\n                            if (identifier.equals(\"<<\")) {\n                                identifier = \"*lshft\";\n                            }\n                            if (identifier.equals(\"<=\")) {\n                                identifier = \"*le\";\n                            }\n                            if (identifier.equals(\">=\")) {\n                                identifier = \"*ge\";\n                            }\n                            if (identifier.equals(\"&\") || identifier.equals(\"&&\")) {\n                                identifier = \"*amp\";\n                            }\n                            wtr.write(\"  <identifier>\" + identifier + \"</identifier>\" + '\\n');\n                        }\n                    }\n                }\n            }\n        } else {\n            if (children != null && children.length > 0) {\n                wtr.write(\"<\" + JavaParserTreeConstants.jjtNodeName[id] + \">\");\n            }\n        }\n        if (children != null) {\n            for (int i = 0; i < children.length; ++i) {\n                SimpleNode n = (SimpleNode) children[i];\n                if (n != null) {\n                    n.dump(prefix + \" \", wtr);\n                }\n            }\n        }\n        if (identifiers.size() > 0 || (children != null && children.length > 0)) {\n            wtr.write(\"</\" + JavaParserTreeConstants.jjtNodeName[id] + \">\" + '\\n');\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/19_jmca/src/main/java/com/soops/CEN4010/JMCA/JParser/SimpleNodeTest2.java",
		"test_prompt": "// SimpleNodeTest2.java\npackage com.soops.CEN4010.JMCA.JParser;\n\nimport java.io.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleNode}.\n* It contains ten unit test cases for the {@link SimpleNode#jjtGetNumChildren()} method.\n*/\nclass SimpleNodeTest2 {"
	},
	{
		"original_code": "// JMCAParser.java\npackage com.soops.CEN4010.JMCA;\n\nimport java.io.Reader;\nimport com.soops.CEN4010.JMCA.JParser.JavaParser;\nimport java.io.IOException;\nimport java.io.FileWriter;\nimport java.io.Writer;\nimport java.io.FileInputStream;\nimport java.io.File;\nimport com.soops.CEN4010.JMCA.JParser.xmlParser.SaxProcessor;\nimport com.soops.CEN4010.JMCA.JParser.ParseException;\n\npublic class JMCAParser implements Parser {\n\n    String intermediateFile = \"default.xml\";\n\n    /**\n     * parse implements parse for Parser\n     * precondition is the intermediatFile is set\n     * @param rdr Reader\n     * @return ASTNode\n     */\n    public ASTNode parse(Reader rdr) {\n        JavaParser parser = new JavaParser(rdr);\n        Writer wtr = null;\n        try {\n            parser.CompilationUnit();\n            wtr = new FileWriter(new File(intermediateFile));\n            parser.dump(wtr);\n            System.out.println(\"Java Parser Version 1.1:  Java program parsed successfully.\");\n            wtr.close();\n            SaxProcessor saxP = new SaxProcessor(new FileInputStream(new File(intermediateFile)));\n            saxP.showFile();\n            return saxP.getRootNode();\n        } catch (ParseException e) {\n            System.out.println(e.getMessage());\n            System.out.println(\"Java Parser Version 1.1:  Encountered errors during parse.\");\n            return null;\n        } catch (IOException ie) {\n            System.out.println(\"IO Error from parse : \" + ie.getMessage());\n            return null;\n        } catch (Error ex) {\n            return null;\n        } finally {\n            try {\n                if (wtr != null)\n                    wtr.close();\n            } catch (IOException ie) {\n                System.err.println(\"Error while closing intermediate file \" + intermediateFile);\n                System.err.println(ie.getMessage());\n            }\n        }\n        //           return null;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/19_jmca/src/main/java/com/soops/CEN4010/JMCA/JMCAParserTest.java",
		"test_prompt": "// JMCAParserTest.java\npackage com.soops.CEN4010.JMCA;\n\nimport java.io.Reader;\nimport com.soops.CEN4010.JMCA.JParser.JavaParser;\nimport java.io.IOException;\nimport java.io.FileWriter;\nimport java.io.Writer;\nimport java.io.FileInputStream;\nimport java.io.File;\nimport com.soops.CEN4010.JMCA.JParser.xmlParser.SaxProcessor;\nimport com.soops.CEN4010.JMCA.JParser.ParseException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JMCAParser}.\n* It contains ten unit test cases for the {@link JMCAParser#parse(Reader)} method.\n*/\nclass JMCAParserTest {"
	},
	{
		"original_code": "// DummyParser.java\npackage com.soops.CEN4010.JMCA;\n\npublic class DummyParser implements Parser {\n\n    public ASTNode parse(java.io.Reader rdr) {\n        return null;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/19_jmca/src/main/java/com/soops/CEN4010/JMCA/DummyParserTest.java",
		"test_prompt": "// DummyParserTest.java\npackage com.soops.CEN4010.JMCA;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DummyParser}.\n* It contains ten unit test cases for the {@link DummyParser#parse(java.io.Reader)} method.\n*/\nclass DummyParserTest {"
	},
	{
		"original_code": "// UILayoutDisplayAnalyzer.java\npackage com.soops.CEN4010.JMCA;\n\n/**\n * <p>Title: Group 2 Project </p>\n *\n * <p>Class: CEN4010 Fall 2005</p>\n *\n * <p>Description: Description: UILayoutDisplayAnalyzer implements a dummy Analyzer\n *    use for UI layout  </p>\n *\n * <p>Instructor Dr. Stoeklin</p>\n *\n * @author Group 2\n */\npublic class UILayoutDisplayAnalyzer implements Analyzer {\n\n    String filename = null;\n\n    /**\n     * store the file name for formatted display purposes\n     * @param file String\n     */\n    public void setFileName(String file) {\n        filename = file;\n    }\n\n    /**\n     * no operational implementation of Analyzer\n     * @param dummy ASTNode not used for dummy output\n     * @return display string\n     */\n    public String analyze(ASTNode dummy) {\n        StringBuffer output = new StringBuffer();\n        //FAKE OUTPUT FOR PROTOTYPE\n        output = new StringBuffer(\"\\nFile:  \");\n        output.append(filename);\n        output.append(\"\\n\");\n        output.append(\"Class: CohesionTest\\n\\n\");\n        output.append(\"Method Name                             Cohesion Level\\n\");\n        output.append(\"--------------------------------------------------------------\\n\");\n        output.append(\"deposit                                 Functional\\n\");\n        output.append(\"withdraw                                Sequential\\n\");\n        output.append(\"addCD                                   Communicational\\n\");\n        output.append(\"formDet                                 Iterative\\n\");\n        output.append(\"checkBookIn                             Conditional\\n\");\n        output.append(\"readInput                               Coincidental\\n\");\n        return output.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/19_jmca/src/main/java/com/soops/CEN4010/JMCA/UILayoutDisplayAnalyzerTest.java",
		"test_prompt": "// UILayoutDisplayAnalyzerTest.java\npackage com.soops.CEN4010.JMCA;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UILayoutDisplayAnalyzer}.\n* It contains ten unit test cases for the {@link UILayoutDisplayAnalyzer#analyze(ASTNode)} method.\n*/\nclass UILayoutDisplayAnalyzerTest {"
	},
	{
		"original_code": "// JMCAAnalyzer.java\npackage com.soops.CEN4010.JMCA;\n\nimport java.util.*;\n\n/**\n * <p>Title: JMCAAnalyzer </p>\n *\n * <p>Description: implements Analyzer</p>\n *\n * Group2 for CEN4010 at FSU - Fall 2005\n */\npublic class JMCAAnalyzer implements Analyzer {\n\n    private String fileName = \"\";\n\n    private StringBuilder output = new StringBuilder();\n\n    private java.util.HashSet<String> classList = null;\n\n    private static final boolean DEVELOPMENT = false;\n\n    /**\n     * Analyze the ASTree and return a formatted string\n     * @param root ASTNode\n     * @return String\n     */\n    public String analyze(ASTNode root) {\n        if (root == null) {\n            output.append(\"File did not parse correctly\");\n            return output.toString();\n        }\n        setHeader();\n        //  for each class\n        for (ASTNode node : root.list) {\n            analyzeClass(node);\n        }\n        return output.toString();\n    }\n\n    /**\n     * top level analyzer for each class <br>\n     * calls analyzeMethod for each method\n     * @param node ASTNode\n     */\n    private void analyzeClass(ASTNode node) {\n        // list of class variables\n        classList = new HashSet<String>();\n        java.util.ArrayList<ASTNode> methodList = new ArrayList<ASTNode>();\n        // print class header\n        output.append(\"\\nClass: \" + node.getIdentity() + \"\\n\\n\");\n        output.append(\"Method Name                             Cohesion Level\\n\");\n        output.append(\"--------------------------------------------------------------\\n\");\n        // save each class variable in classList\n        for (ASTNode childNode : node.list) {\n            if (childNode.getType().equals(\"ClassVariableDeclaration\")) {\n                classList.add(childNode.getIdentity());\n            }\n        }\n        //  do for each method\n        for (ASTNode childNode : node.list) {\n            if (childNode.getType().equals(\"MethodDeclaration\")) {\n                analyzeMethod(childNode);\n            }\n        }\n    }\n\n    // end method analyzeClass\n    /**\n     * called for each method\n     * @param node ASTNode\n     */\n    private void analyzeMethod(ASTNode node) {\n        output.append(node.getIdentity());\n        /**\n         * list of all statements\n         */\n        ArrayList<StatementDS> statementList = new ArrayList<StatementDS>();\n        /**\n         * analyze all statements and add them to the statementList\n         */\n        statements(node, statementList, false, false);\n        /**\n         * HashMap of all modified variables\n         */\n        HashMap<String, StatementElement> modifiedVariables = new HashMap<String, StatementElement>();\n        // build semantics for each statement\n        for (StatementDS tmpDS : statementList) {\n            if (classList.contains(tmpDS.getLVal().getElementName())) {\n                tmpDS.getLVal().setType(StatementElement.variableType.ClassVariable);\n            }\n            if (tmpDS.getType() != null) {\n                if (tmpDS.getType().equals(StatementDS.statementType.Assignment) || tmpDS.getType().equals(StatementDS.statementType.PostInc) || tmpDS.getType().equals(StatementDS.statementType.PreInc)) {\n                    tmpDS.getLVal().setModified(true);\n                    modifiedVariables.put(tmpDS.getLVal().getElementName(), tmpDS.getLVal());\n                }\n            }\n            // set for selection\n            tmpDS.getLVal().setInSelection(tmpDS.isInSelection());\n            // set for iteration\n            tmpDS.getLVal().setInIteration(tmpDS.isInIteration());\n            // add modified variables to the chain of variables affecting this element\n            ArrayList<StatementElement> rVals = tmpDS.getRVals();\n            for (StatementElement rval : rVals) {\n                StatementElement tmpEl = modifiedVariables.get(rval.getElementName());\n                if (tmpEl != null && !tmpEl.getElementName().equals(tmpDS.getLVal().getElementName())) {\n                    tmpDS.getLVal().addModifier(tmpEl);\n                } else if (!rval.getElementName().equals(tmpDS.getLVal().getElementName())) {\n                    tmpDS.getLVal().addModifier(rval);\n                }\n                if (rval.hasBeenModified()) {\n                    tmpDS.getLVal().addModifier(rval);\n                    modifiedVariables.put(rval.getElementName(), rval);\n                }\n            }\n        }\n        int modifiedClassVariables = 0;\n        int classVariableWithModifiers = 0;\n        int modifiedLocVariables = 0;\n        boolean iterative = false;\n        boolean selective = false;\n        String cohesionLevel = \"\";\n        boolean firstModifiedClassVariableWithModifers = true;\n        ArrayList<String> classVarModifiers = new ArrayList<String>();\n        // do for every Statement\n        for (StatementElement el : modifiedVariables.values()) {\n            if (el.hasBeenModified()) {\n                // class variables\n                if (el.getType() != null && el.getType().equals(StatementElement.variableType.ClassVariable)) {\n                    // selection\n                    if (el.isInSelection()) {\n                        selective = true;\n                    }\n                    // iteration\n                    if (el.isInIteration()) {\n                        iterative = true;\n                    }\n                    if (el.getModifiers().size() > 0) {\n                        ++classVariableWithModifiers;\n                        if (firstModifiedClassVariableWithModifers) {\n                            createArrayListOfModifiers(el, classVarModifiers);\n                            firstModifiedClassVariableWithModifers = false;\n                        } else {\n                            ArrayList<String> tmpList = new ArrayList<String>();\n                            createArrayListOfModifiers(el, tmpList);\n                            ArrayList<String> unionSet = new ArrayList<String>();\n                            // get the union of modifed variables\n                            for (String var : classVarModifiers) {\n                                for (String tmpEl : tmpList) {\n                                    if (var.equals(tmpEl)) {\n                                        unionSet.add(var);\n                                    }\n                                }\n                            }\n                            classVarModifiers = unionSet;\n                        }\n                    }\n                    ++modifiedClassVariables;\n                } else {\n                    // end modified class variables\n                    ++modifiedLocVariables;\n                }\n            }\n        }\n        String cohesionType = \"Coincidental\";\n        if (modifiedClassVariables == 1 && modifiedLocVariables == 0) {\n            cohesionType = \"Functional\";\n        } else if (modifiedClassVariables == 1 && classVarModifiers.size() > 0) {\n            cohesionType = \"Sequential\";\n        } else if (modifiedClassVariables > 1 && classVarModifiers.size() > 0) {\n            cohesionType = \"Communicational\";\n        } else if (modifiedClassVariables == 0) {\n            cohesionType = \"No Class Level Assignments\";\n            //  cohesionType = \"Coincidental\";\n        }\n        if (iterative) {\n            cohesionType = \"Iterative\";\n        }\n        if (selective) {\n            cohesionType = \"Conditional\";\n        }\n        for (int i = 0; i < 60 - node.getIdentity().length() - cohesionType.length(); ++i) {\n            output.append(\" \");\n        }\n        output.append(cohesionType + \"\\n\");\n        // print out a toString dump for development analysis\n        if (DEVELOPMENT) {\n            for (StatementDS tmpDS : statementList) {\n                output.append(\"     \" + tmpDS.toString() + \"\\n\");\n            }\n        }\n    }\n\n    // end method analyzeMethod\n    /**\n     * recursive method to create a chain of modifiers to a variable <b>\n     * using this method then :   a = b + c;  d = a;  e = d; <br>\n     *   e would contain both d and a as modifiers it is dependent on\n     * @param stE StatementElement\n     * @param list ArrayList\n     */\n    private void createArrayListOfModifiers(StatementElement stE, ArrayList<String> list) {\n        for (StatementElement tmpEl : stE.getModifiers()) {\n            list.add(tmpEl.getElementName());\n            if (tmpEl.getModifiers().size() > 0) {\n                createArrayListOfModifiers(tmpEl, list);\n            }\n        }\n    }\n\n    /**\n     * recusive method to analyze statements\n     * @param parentNode ASTNode\n     * @param statementList ArrayList\n     * @param isInSelection boolean\n     * @param isInIteration boolean\n     */\n    private void statements(ASTNode parentNode, ArrayList<StatementDS> statementList, boolean isInSelection, boolean isInIteration) {\n        for (ASTNode childNode : parentNode.list) {\n            if (childNode.getType().equals(\"Selection\")) {\n                statements(childNode, statementList, true, isInIteration);\n            } else if (childNode.getType().equals(\"Iteration\")) {\n                statements(childNode, statementList, isInSelection, true);\n            } else if (childNode.getIdentity().equals(\"StatementExpression\")) {\n                StatementDS tmpDS = analyzeStatement(childNode);\n                tmpDS.setInIteration(isInIteration);\n                tmpDS.setInSelection(isInSelection);\n                statementList.add(tmpDS);\n            }\n        }\n    }\n\n    /**\n     * called for each statement\n     * @param node ASTNode\n     * @return StatementDS\n     */\n    private StatementDS analyzeStatement(ASTNode node) {\n        StatementDS localDS = new StatementDS();\n        int nodeCount = node.list.size();\n        int currCtr = 0;\n        int nxtCtr = nodeCount > 0 ? 1 : 0;\n        // check for preDec ++ or --\n        String firstVal = node.list.get(0).getIdentity();\n        if (firstVal.equals(\"++\") || firstVal.equals(\"--\")) {\n            localDS.setType(StatementDS.statementType.PreInc);\n            currCtr++;\n        }\n        currCtr = getLVal(currCtr, node.list);\n        localDS.setLVal(node.list.get(currCtr).getIdentity());\n        if (currCtr + 1 == nodeCount) {\n            return localDS;\n        }\n        // have the LVAL and there is a next\n        currCtr++;\n        if (node.list.get(currCtr).getIdentity().equals(\"[\")) {\n            while (!node.list.get(currCtr).getIdentity().equals(\"]\")) {\n                currCtr++;\n            }\n            currCtr++;\n        }\n        if (currCtr + 1 == nodeCount) {\n            return localDS;\n        }\n        // have the LVAL and there is a next\n        String tmpVl = node.list.get(currCtr).getIdentity();\n        if (tmpVl.equals(\"(\")) {\n            localDS.setType(StatementDS.statementType.MethodCall);\n            return localDS;\n        }\n        if (tmpVl.equals(\"++\") || tmpVl.equals(\"--\")) {\n            localDS.setType(StatementDS.statementType.PostInc);\n            return localDS;\n        }\n        if (tmpVl.equals(\"+=\") || tmpVl.equals(\"=\") || tmpVl.equals(\"-=\") || tmpVl.equals(\"\\\\=\") || tmpVl.equals(\"*=\")) {\n            localDS.setType(StatementDS.statementType.Assignment);\n            currCtr++;\n        }\n        getRVals(localDS, currCtr, node.list);\n        return localDS;\n    }\n\n    /**\n     * called from analyzeStatement - gets a list of RVals in assignment statements\n     * @param locDS StatementDS\n     * @param ctr int\n     * @param list ArrayList\n     */\n    private void getRVals(StatementDS locDS, int ctr, ArrayList<ASTNode> list) {\n        // reset to true for each new rval element\n        boolean isFirstToken = true;\n        String currVariable = null;\n        int nodeCount = list.size();\n        String currID = null, nextID = null;\n        StatementElement currEl = null;\n        while (ctr < nodeCount) {\n            currID = list.get(ctr).getIdentity();\n            if (ctr + 1 < nodeCount) {\n                nextID = list.get(ctr + 1).getIdentity();\n            } else {\n                nextID = null;\n            }\n            if (isFirstToken) {\n                currEl = new StatementElement();\n                isFirstToken = false;\n                if (currID.equals(\"++\") || currID.equals(\"--\")) {\n                    currEl.setModified(true);\n                }\n                if (currID.equals(\"(\")) {\n                    ctr++;\n                    continue;\n                }\n            }\n            if (nextID != null && (nextID.equals(\"++\") || nextID.equals(\"--\"))) {\n                currEl.setModified(true);\n                if (currEl.getElementName() == null) {\n                    currEl.setElementName(currID);\n                }\n            }\n            if (nextID != null && (nextID.equals(\")\"))) {\n                if (currEl.getElementName() == null) {\n                    currEl.setElementName(currID);\n                }\n                ctr++;\n                continue;\n            }\n            if (nextID != null && nextID.equals(\".\")) {\n                ctr += 2;\n                continue;\n            }\n            if (nextID == null || isOperator(nextID)) {\n                if (currEl.getElementName() == null) {\n                    currEl.setElementName(currID);\n                }\n                locDS.addRVal(currEl);\n                // set for the next element\n                isFirstToken = true;\n                ctr++;\n                continue;\n            }\n            if (currID.equals(\"new\")) {\n                currEl.setType(StatementElement.variableType.ClassInitiator);\n            }\n            if (nextID != null && nextID.equals(\"(\")) {\n                if (currEl.getType() == null) {\n                    currEl.setType(StatementElement.variableType.MethodCall);\n                }\n                if (currEl.getElementName() == null) {\n                    currEl.setElementName(currID);\n                }\n            }\n            // ignore the array subscripts\n            if (nextID != null && nextID.equals(\"[\")) {\n                if (currEl.getElementName() == null) {\n                    currEl.setElementName(currID);\n                }\n                String tmpVal = list.get(ctr).getIdentity();\n                while (!tmpVal.equals(\"]\")) {\n                    ctr++;\n                    tmpVal = list.get(ctr).getIdentity();\n                }\n                if (ctr == nodeCount - 1) {\n                    locDS.addRVal(currEl);\n                }\n            }\n            ctr++;\n        }\n        // end while loop\n    }\n\n    /**\n     * helper function - checks for delimiters in a equation where delimiters <br>\n     * are defined as arithmetic operands such as '+' and '-'\n     * @param id String\n     * @return boolean\n     */\n    private boolean isOperator(String id) {\n        if (id == null) {\n            return false;\n        }\n        if (id.equals(\"+\") || id.equals(\"-\") || id.equals(\"\\\\\") || id.equals(\"*\") || id.equals(\"<<\") || id.equals(\">>\") || id.equals(\"%\")) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * gets the variable name for the lVal of an expression\n     * @param ctr int\n     * @param list ArrayList\n     * @return int\n     */\n    private int getLVal(int ctr, ArrayList<ASTNode> list) {\n        // do until the LVal is found\n        // lval is an identity that does not have a '.' as the next identity\n        // ie.   java.util.Type   in this instance Type is the LVal\n        int nodeCount = list.size();\n        String currID = null, nextID = null;\n        while (ctr < nodeCount) {\n            currID = list.get(ctr).getIdentity();\n            if (ctr + 1 < nodeCount) {\n                nextID = list.get(ctr + 1).getIdentity();\n            } else {\n                return ctr;\n            }\n            if (!nextID.equals(\".\")) {\n                return ctr;\n            }\n            ctr += 2;\n        }\n        return ctr;\n    }\n\n    /**\n     * write the report header to output\n     */\n    private void setHeader() {\n        output.append(\"\\nFile:  \");\n        output.append(fileName);\n        output.append(\"\\n\");\n    }\n\n    /**\n     * Store the file name parsed for formatted display purposes\n     * @param fileName String\n     */\n    public void setFileName(String fileName) {\n        this.fileName = fileName;\n    }\n}\n\n/**\n *  represents a variable in an expression\n */\nclass StatementElement {\n\n    /**\n     * marked true if this variable is modifed in the method\n     */\n    private boolean hasBeenModified = false;\n\n    /**\n     * represents the variable name\n     */\n    private String elementName = null;\n\n    /**\n     * set true if variable is within a if statement\n     */\n    private boolean isInSelection = false;\n\n    /**\n     * set true if variable is within an interation block\n     */\n    private boolean isInIteration = false;\n\n    /**\n     * list of elements that have modified this element <br>\n     * a recursive descent of elements will get a chain of modifiers\n     */\n    private ArrayList<StatementElement> modifiers = new ArrayList<StatementElement>();\n\n    /**\n     * add a variable to the modifier list\n     * @param rval StatementElement\n     */\n    public void addModifier(StatementElement rval) {\n        modifiers.add(rval);\n    }\n\n    /**\n     * return a reference to the modifier list\n     * @return ArrayList\n     */\n    public ArrayList<StatementElement> getModifiers() {\n        return modifiers;\n    }\n\n    /**\n     *  enumeration of types\n     */\n    public static enum variableType {\n\n        ClassVariable, LocalVariable, MethodCall, ClassInitiator\n    }\n\n    /**\n     * local variableType represent the type of variable this is\n     */\n    variableType type = null;\n\n    /**\n     * default constructor\n     */\n    StatementElement() {\n    }\n\n    /**\n     *  setter for the variable name\n     * @param name String\n     */\n    StatementElement(String name) {\n        setElementName(name);\n    }\n\n    /**\n     * getter for the type : see enum variableType\n     * @return variableType\n     */\n    variableType getType() {\n        return type;\n    }\n\n    /**\n     * setter for the variable type\n     * @param t variableType\n     */\n    void setType(variableType t) {\n        type = t;\n    }\n\n    /**\n     * setter for the name\n     * @param name String\n     */\n    void setElementName(String name) {\n        elementName = name;\n    }\n\n    /**\n     * getter for the boolean flag hasBeenModified\n     * @return boolean\n     */\n    boolean hasBeenModified() {\n        return hasBeenModified;\n    }\n\n    /**\n     * getter for the variable name\n     * @return String\n     */\n    String getElementName() {\n        return elementName;\n    }\n\n    /**\n     * setter for the boolean flag has been modified\n     * @param val boolean\n     */\n    void setModified(boolean val) {\n        hasBeenModified = val;\n    }\n\n    /**\n     * override of toString provides information for debugging/development\n     * @return String\n     */\n    public String toString() {\n        String tmp = elementName;\n        if (hasBeenModified) {\n            tmp += \" (modified) \";\n        }\n        if (type != null) {\n            tmp += \" (\" + type.toString() + \") \";\n        }\n        for (StatementElement element : modifiers) {\n            tmp += element.toString();\n        }\n        return tmp;\n    }\n\n    /**\n     * getter for the boolean flag isInSelection\n     * @return boolean\n     */\n    boolean isInSelection() {\n        return isInSelection;\n    }\n\n    /**\n     * getter for the boolean flag isInIteration\n     * @return boolean\n     */\n    boolean isInIteration() {\n        return isInIteration;\n    }\n\n    /**\n     * setter for isInSelection\n     * @param val boolean\n     */\n    void setInSelection(boolean val) {\n        isInSelection = val;\n    }\n\n    /**\n     * setter for isInIteration\n     * @param val boolean\n     */\n    void setInIteration(boolean val) {\n        isInIteration = val;\n    }\n}\n\n// end class\n/**\n *   represents an expression statement <br>\n *   has Statment Elements  : one lVal and 0 . . . n rVals\n */\nclass StatementDS {\n\n    private StatementElement lVal = null;\n\n    private ArrayList<StatementElement> rValList = new ArrayList<StatementElement>();\n\n    public static enum statementType {\n\n        PreInc, PostInc, Assignment, MethodCall\n    }\n\n    private statementType type = null;\n\n    private boolean isInSelection = false;\n\n    private boolean isInIteration = false;\n\n    statementType getType() {\n        return type;\n    }\n\n    /**\n     * add a rVal to the list\n     * @param rv StatementElement\n     */\n    void addRVal(StatementElement rv) {\n        rValList.add(rv);\n    }\n\n    /**\n     * set statement type: see  enum statementType\n     * @param t statementType\n     */\n    void setType(statementType t) {\n        type = t;\n    }\n\n    /**\n     * get a reference to the list of rVals\n     * @return ArrayList\n     */\n    ArrayList<StatementElement> getRVals() {\n        return rValList;\n    }\n\n    /**\n     * override of toString contains information for debugging\n     * @return String\n     */\n    public String toString() {\n        String tmp = lVal.toString();\n        tmp += \" : \" + type.toString();\n        if (this.isInIteration()) {\n            tmp += \" (Iteration) \";\n        }\n        if (this.isInSelection()) {\n            tmp += \" (Selection) \";\n        }\n        for (StatementElement rVal : rValList) {\n            tmp += \" := \" + rVal.toString();\n        }\n        return tmp;\n    }\n\n    /**\n     * setter for the LVal\n     * @param rv StatementElement\n     */\n    void setLVal(StatementElement rv) {\n        lVal = rv;\n    }\n\n    /**\n     * setter for the LVal\n     * @param id String\n     */\n    void setLVal(String id) {\n        lVal = new StatementElement(id);\n    }\n\n    /**\n     * getter for the LVal\n     * @return StatementElement\n     */\n    StatementElement getLVal() {\n        return lVal;\n    }\n\n    /**\n     * getter for the boolean flag isInSelection\n     * @return boolean\n     */\n    boolean isInSelection() {\n        return isInSelection;\n    }\n\n    /**\n     * getter for the boolean flag isInIteration\n     * @return boolean\n     */\n    boolean isInIteration() {\n        return isInIteration;\n    }\n\n    /**\n     * setter for isInSelection\n     * @param val boolean\n     */\n    void setInSelection(boolean val) {\n        isInSelection = val;\n    }\n\n    /**\n     * setter for isInIteration\n     * @param val boolean\n     */\n    void setInIteration(boolean val) {\n        isInIteration = val;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/19_jmca/src/main/java/com/soops/CEN4010/JMCA/JMCAAnalyzerTest.java",
		"test_prompt": "// JMCAAnalyzerTest.java\npackage com.soops.CEN4010.JMCA;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JMCAAnalyzer}.\n* It contains ten unit test cases for the {@link JMCAAnalyzer#analyze(ASTNode)} method.\n*/\nclass JMCAAnalyzerTest {"
	}
]