[
	{
		"original_code": "// DbConfigTableModel.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy.ui;\r\n\r\nimport java.beans.BeanInfo;\r\nimport java.beans.IntrospectionException;\r\nimport java.beans.Introspector;\r\nimport java.beans.PropertyDescriptor;\r\nimport java.lang.reflect.InvocationTargetException;\r\nimport java.util.ArrayList;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport javax.swing.table.AbstractTableModel;\r\nimport net.sourceforge.schemaspy.Config;\r\nimport net.sourceforge.schemaspy.Config.MissingRequiredParameterException;\r\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\r\nimport net.sourceforge.schemaspy.util.DbSpecificOption;\r\n\r\n/**\r\n * @author John Currier\r\n */\r\npublic class DbConfigTableModel extends AbstractTableModel {\r\n\r\n    private static final long serialVersionUID = 1L;\r\n\r\n    private final List<PropertyDescriptor> options = new ArrayList<PropertyDescriptor>();\r\n\r\n    // the config associated with DbSpecificConfig\r\n    private Config config = Config.getInstance();\r\n\r\n    public DbConfigTableModel() {\r\n        PropertyDescriptor[] props = getConfigProps();\r\n        options.add(getDescriptor(\"outputDir\", \"Directory to generate HTML output to\", props));\r\n        options.add(getDescriptor(\"schema\", \"Schema to evaluate\", props));\r\n        options.add(getDescriptor(\"user\", \"User ID to connect with\", props));\r\n        options.add(getDescriptor(\"password\", \"Password associated with user id\", props));\r\n        options.add(getDescriptor(\"impliedConstraintsEnabled\", \"XXXX\", props));\r\n    }\r\n\r\n    public void setDbSpecificConfig(DbSpecificConfig dbConfig) {\r\n        config = dbConfig.getConfig();\r\n        Config.setInstance(config);\r\n        PropertyDescriptor[] props = getConfigProps();\r\n        removeDbSpecificOptions();\r\n        for (DbSpecificOption option : dbConfig.getOptions()) {\r\n            PropertyDescriptor descriptor = getDescriptor(option.getName(), option.getDescription(), props);\r\n            descriptor.setValue(\"dbSpecific\", Boolean.TRUE);\r\n            options.add(descriptor);\r\n        }\r\n        fireTableDataChanged();\r\n    }\r\n\r\n    @Override\r\n    public String getColumnName(int column) {\r\n        switch(column) {\r\n            case 0:\r\n                return \"Option\";\r\n            default:\r\n                return \"Value\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param string\r\n     * @param string2\r\n     * @param props\r\n     * @return\r\n     */\r\n    private PropertyDescriptor getDescriptor(String propName, String description, PropertyDescriptor[] props) {\r\n        if (props == null)\r\n            props = getConfigProps();\r\n        for (int i = 0; i < props.length; ++i) {\r\n            PropertyDescriptor prop = props[i];\r\n            if (prop.getName().equalsIgnoreCase(propName)) {\r\n                prop.setShortDescription(description);\r\n                return prop;\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(propName + \" is not a valid configuration item\");\r\n    }\r\n\r\n    private PropertyDescriptor[] getConfigProps() throws RuntimeException {\r\n        BeanInfo beanInfo;\r\n        try {\r\n            beanInfo = Introspector.getBeanInfo(Config.class);\r\n        } catch (IntrospectionException exc) {\r\n            throw new RuntimeException(exc);\r\n        }\r\n        return beanInfo.getPropertyDescriptors();\r\n    }\r\n\r\n    private void removeDbSpecificOptions() {\r\n        Iterator<PropertyDescriptor> iter = options.iterator();\r\n        while (iter.hasNext()) {\r\n            PropertyDescriptor descriptor = iter.next();\r\n            if (descriptor.getValue(\"dbSpecific\") != null)\r\n                iter.remove();\r\n        }\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see javax.swing.table.TableModel#getColumnCount()\r\n     */\r\n    public int getColumnCount() {\r\n        return 2;\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see javax.swing.table.TableModel#getRowCount()\r\n     */\r\n    public int getRowCount() {\r\n        return options.size();\r\n    }\r\n\r\n    @Override\r\n    public boolean isCellEditable(int row, int col) {\r\n        if (col != 1)\r\n            return false;\r\n        return options.get(row).getWriteMethod() != null;\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see javax.swing.table.TableModel#getValueAt(int, int)\r\n     */\r\n    public Object getValueAt(int row, int column) {\r\n        PropertyDescriptor descriptor = options.get(row);\r\n        switch(column) {\r\n            case 0:\r\n                return descriptor.getName();\r\n            case 1:\r\n                try {\r\n                    Object value = descriptor.getReadMethod().invoke(config, (Object[]) null);\r\n                    //System.out.println(descriptor.getReadMethod().getName() + \":'\" + value + \"' \" + (value != null ? value.getClass().toString() : \"\"));\r\n                    return value;\r\n                } catch (InvocationTargetException exc) {\r\n                    if (exc.getCause() instanceof MissingRequiredParameterException)\r\n                        return null;\r\n                    throw new RuntimeException(exc);\r\n                } catch (Exception exc) {\r\n                    throw new RuntimeException(exc);\r\n                }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public void setValueAt(Object value, int row, int col) {\r\n        Object oldValue = getValueAt(row, col);\r\n        if (oldValue != value && (value == null || oldValue == null || !value.equals(oldValue))) {\r\n            PropertyDescriptor descriptor = options.get(row);\r\n            try {\r\n                //System.out.println(descriptor.getWriteMethod().getName() + \":'\" + value + \"' \" + (value != null ? value.getClass().toString() : \"\"));\r\n                if (value instanceof String && descriptor.getPropertyType().isAssignableFrom(Integer.class)) {\r\n                    try {\r\n                        value = Integer.valueOf((String) value);\r\n                    } catch (NumberFormatException nfe) {\r\n                        value = oldValue;\r\n                    }\r\n                }\r\n                descriptor.getWriteMethod().invoke(config, new Object[] { value });\r\n            } catch (Exception exc) {\r\n                throw new RuntimeException(exc);\r\n            }\r\n            fireTableCellUpdated(row, col);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param row\r\n     * @return\r\n     */\r\n    public Class<?> getClass(int row) {\r\n        PropertyDescriptor descriptor = options.get(row);\r\n        return descriptor.getPropertyType();\r\n    }\r\n\r\n    /**\r\n     * @param row\r\n     * @return\r\n     */\r\n    public String getDescription(int row) {\r\n        PropertyDescriptor descriptor = options.get(row);\r\n        return descriptor.getShortDescription();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/ui/DbConfigTableModelTest.java",
		"test_prompt": "// DbConfigTableModelTest.java\npackage net.sourceforge.schemaspy.ui;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport javax.swing.table.AbstractTableModel;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.Config.MissingRequiredParameterException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.DbSpecificOption;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DbConfigTableModel}.\n* It contains ten unit test cases for the {@link DbConfigTableModel#isCellEditable(int, int)} method.\n*/\nclass DbConfigTableModelTest {"
	},
	{
		"original_code": "// UiUtils.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy.ui;\r\n\r\nimport java.awt.Component;\r\nimport javax.swing.JTable;\r\nimport javax.swing.table.TableCellRenderer;\r\nimport javax.swing.table.TableColumn;\r\n\r\n/**\r\n * @author John Currier\r\n */\r\npublic class UiUtils {\r\n\r\n    public static int getPreferredColumnWidth(JTable table, TableColumn col) {\r\n        return Math.max(getPreferredColumnHeaderWidth(table, col), getWidestCellInColumn(table, col));\r\n    }\r\n\r\n    public static int getPreferredColumnHeaderWidth(JTable table, TableColumn col) {\r\n        TableCellRenderer renderer = col.getHeaderRenderer();\r\n        if (renderer == null)\r\n            return 0;\r\n        Component comp = renderer.getTableCellRendererComponent(table, col.getHeaderValue(), false, false, 0, 0);\r\n        return comp.getPreferredSize().width;\r\n    }\r\n\r\n    public static int getWidestCellInColumn(JTable table, TableColumn col) {\r\n        int column = col.getModelIndex();\r\n        int max = 0;\r\n        for (int row = 0; row < table.getRowCount(); ++row) {\r\n            TableCellRenderer renderer = table.getCellRenderer(row, column);\r\n            Component comp = renderer.getTableCellRendererComponent(table, table.getValueAt(row, column), false, false, row, column);\r\n            max = Math.max(comp.getPreferredSize().width, max);\r\n        }\r\n        return max;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/ui/UiUtilsTest0.java",
		"test_prompt": "// UiUtilsTest0.java\npackage net.sourceforge.schemaspy.ui;\n\nimport java.awt.Component;\nimport javax.swing.JTable;\nimport javax.swing.table.TableCellRenderer;\nimport javax.swing.table.TableColumn;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UiUtils}.\n* It contains ten unit test cases for the {@link UiUtils#getPreferredColumnWidth(JTable, TableColumn)} method.\n*/\nclass UiUtilsTest0 {"
	},
	{
		"original_code": "// UiUtils.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy.ui;\r\n\r\nimport java.awt.Component;\r\nimport javax.swing.JTable;\r\nimport javax.swing.table.TableCellRenderer;\r\nimport javax.swing.table.TableColumn;\r\n\r\n/**\r\n * @author John Currier\r\n */\r\npublic class UiUtils {\r\n\r\n    public static int getPreferredColumnWidth(JTable table, TableColumn col) {\r\n        return Math.max(getPreferredColumnHeaderWidth(table, col), getWidestCellInColumn(table, col));\r\n    }\r\n\r\n    public static int getPreferredColumnHeaderWidth(JTable table, TableColumn col) {\r\n        TableCellRenderer renderer = col.getHeaderRenderer();\r\n        if (renderer == null)\r\n            return 0;\r\n        Component comp = renderer.getTableCellRendererComponent(table, col.getHeaderValue(), false, false, 0, 0);\r\n        return comp.getPreferredSize().width;\r\n    }\r\n\r\n    public static int getWidestCellInColumn(JTable table, TableColumn col) {\r\n        int column = col.getModelIndex();\r\n        int max = 0;\r\n        for (int row = 0; row < table.getRowCount(); ++row) {\r\n            TableCellRenderer renderer = table.getCellRenderer(row, column);\r\n            Component comp = renderer.getTableCellRendererComponent(table, table.getValueAt(row, column), false, false, row, column);\r\n            max = Math.max(comp.getPreferredSize().width, max);\r\n        }\r\n        return max;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/ui/UiUtilsTest1.java",
		"test_prompt": "// UiUtilsTest1.java\npackage net.sourceforge.schemaspy.ui;\n\nimport java.awt.Component;\nimport javax.swing.JTable;\nimport javax.swing.table.TableCellRenderer;\nimport javax.swing.table.TableColumn;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UiUtils}.\n* It contains ten unit test cases for the {@link UiUtils#getPreferredColumnHeaderWidth(JTable, TableColumn)} method.\n*/\nclass UiUtilsTest1 {"
	},
	{
		"original_code": "// UiUtils.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy.ui;\r\n\r\nimport java.awt.Component;\r\nimport javax.swing.JTable;\r\nimport javax.swing.table.TableCellRenderer;\r\nimport javax.swing.table.TableColumn;\r\n\r\n/**\r\n * @author John Currier\r\n */\r\npublic class UiUtils {\r\n\r\n    public static int getPreferredColumnWidth(JTable table, TableColumn col) {\r\n        return Math.max(getPreferredColumnHeaderWidth(table, col), getWidestCellInColumn(table, col));\r\n    }\r\n\r\n    public static int getPreferredColumnHeaderWidth(JTable table, TableColumn col) {\r\n        TableCellRenderer renderer = col.getHeaderRenderer();\r\n        if (renderer == null)\r\n            return 0;\r\n        Component comp = renderer.getTableCellRendererComponent(table, col.getHeaderValue(), false, false, 0, 0);\r\n        return comp.getPreferredSize().width;\r\n    }\r\n\r\n    public static int getWidestCellInColumn(JTable table, TableColumn col) {\r\n        int column = col.getModelIndex();\r\n        int max = 0;\r\n        for (int row = 0; row < table.getRowCount(); ++row) {\r\n            TableCellRenderer renderer = table.getCellRenderer(row, column);\r\n            Component comp = renderer.getTableCellRendererComponent(table, table.getValueAt(row, column), false, false, row, column);\r\n            max = Math.max(comp.getPreferredSize().width, max);\r\n        }\r\n        return max;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/ui/UiUtilsTest2.java",
		"test_prompt": "// UiUtilsTest2.java\npackage net.sourceforge.schemaspy.ui;\n\nimport java.awt.Component;\nimport javax.swing.JTable;\nimport javax.swing.table.TableCellRenderer;\nimport javax.swing.table.TableColumn;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UiUtils}.\n* It contains ten unit test cases for the {@link UiUtils#getWidestCellInColumn(JTable, TableColumn)} method.\n*/\nclass UiUtilsTest2 {"
	},
	{
		"original_code": "// Inflection.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy.util;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.regex.Pattern;\r\n\r\n/**\r\n * Implementation of Rails'\r\n * <a href='http://api.rubyonrails.org/classes/ActiveSupport/CoreExtensions/String/Inflections.html'>Inflections</a>\r\n * to handle singularization and pluralization of 'Rails strings'.\r\n *\r\n * Copied from <a href='http://code.google.com/p/rogueweb/'>rogueweb</a>'s port of Rails to Java.\r\n *\r\n * @author Anthony Eden\r\n */\r\npublic class Inflection {\r\n\r\n    private static final List<Inflection> plural = new ArrayList<Inflection>();\r\n\r\n    private static final List<Inflection> singular = new ArrayList<Inflection>();\r\n\r\n    private static final List<String> uncountable = new ArrayList<String>();\r\n\r\n    static {\r\n        // plural is \"singular to plural form\"\r\n        // singular is \"plural to singular form\"\r\n        plural(\"$\", \"s\");\r\n        plural(\"s$\", \"s\");\r\n        plural(\"(ax|test)is$\", \"$1es\");\r\n        plural(\"(octop|vir)us$\", \"$1i\");\r\n        plural(\"(alias|status)$\", \"$1es\");\r\n        plural(\"(bu)s$\", \"$1ses\");\r\n        plural(\"(buffal|tomat)o$\", \"$1oes\");\r\n        plural(\"([ti])um$\", \"$1a\");\r\n        plural(\"sis$\", \"ses\");\r\n        plural(\"(?:([^f])fe|([lr])f)$\", \"$1$2ves\");\r\n        plural(\"(hive)$\", \"$1s\");\r\n        plural(\"([^aeiouy]|qu)y$\", \"$1ies\");\r\n        //plural(\"([^aeiouy]|qu)ies$\", \"$1y\");\r\n        plural(\"(x|ch|ss|sh)$\", \"$1es\");\r\n        plural(\"(matr|vert|ind)ix|ex$\", \"$1ices\");\r\n        plural(\"([m|l])ouse$\", \"$1ice\");\r\n        plural(\"^(ox)$\", \"$1en\");\r\n        plural(\"(quiz)$\", \"$1zes\");\r\n        singular(\"s$\", \"\");\r\n        singular(\"(n)ews$\", \"$1ews\");\r\n        singular(\"([ti])a$\", \"$1um\");\r\n        singular(\"((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$\", \"$1$2sis\");\r\n        singular(\"(^analy)ses$\", \"$1sis\");\r\n        singular(\"([^f])ves$\", \"$1fe\");\r\n        singular(\"(hive)s$\", \"$1\");\r\n        singular(\"(tive)s$\", \"$1\");\r\n        singular(\"([lr])ves$\", \"$1f\");\r\n        singular(\"([^aeiouy]|qu)ies$\", \"$1y\");\r\n        singular(\"(s)eries$\", \"$1eries\");\r\n        singular(\"(m)ovies$\", \"$1ovie\");\r\n        singular(\"(x|ch|ss|sh)es$\", \"$1\");\r\n        singular(\"([m|l])ice$\", \"$1ouse\");\r\n        singular(\"(bus)es$\", \"$1\");\r\n        singular(\"(o)es$\", \"$1\");\r\n        singular(\"(shoe)s$\", \"$1\");\r\n        singular(\"(cris|ax|test)es$\", \"$1is\");\r\n        singular(\"(octop|vir)i$\", \"$1us\");\r\n        singular(\"(alias|status)es$\", \"$1\");\r\n        singular(\"^(ox)en\", \"$1\");\r\n        singular(\"(vert|ind)ices$\", \"$1ex\");\r\n        singular(\"(matr)ices$\", \"$1ix\");\r\n        singular(\"(quiz)zes$\", \"$1\");\r\n        // irregular\r\n        irregular(\"person\", \"people\");\r\n        irregular(\"man\", \"men\");\r\n        irregular(\"child\", \"children\");\r\n        irregular(\"sex\", \"sexes\");\r\n        irregular(\"move\", \"moves\");\r\n        uncountable(\"equipment\");\r\n        uncountable(\"information\");\r\n        uncountable(\"rice\");\r\n        uncountable(\"money\");\r\n        uncountable(\"species\");\r\n        uncountable(\"series\");\r\n        uncountable(\"fish\");\r\n        uncountable(\"sheep\");\r\n        //Collections.reverse(singular);\r\n        //Collections.reverse(plural);\r\n    }\r\n\r\n    private final String pattern;\r\n\r\n    private final String replacement;\r\n\r\n    private final boolean ignoreCase;\r\n\r\n    public Inflection(String pattern) {\r\n        this(pattern, null, true);\r\n    }\r\n\r\n    public Inflection(String pattern, String replacement) {\r\n        this(pattern, replacement, true);\r\n    }\r\n\r\n    public Inflection(String pattern, String replacement, boolean ignoreCase) {\r\n        this.pattern = pattern;\r\n        this.replacement = replacement;\r\n        this.ignoreCase = ignoreCase;\r\n    }\r\n\r\n    private static void plural(String pattern, String replacement) {\r\n        plural.add(0, new Inflection(pattern, replacement));\r\n    }\r\n\r\n    private static void singular(String pattern, String replacement) {\r\n        singular.add(0, new Inflection(pattern, replacement));\r\n    }\r\n\r\n    private static void irregular(String s, String p) {\r\n        plural(\"(\" + s.substring(0, 1) + \")\" + s.substring(1) + \"$\", \"$1\" + p.substring(1));\r\n        singular(\"(\" + p.substring(0, 1) + \")\" + p.substring(1) + \"$\", \"$1\" + s.substring(1));\r\n    }\r\n\r\n    private static void uncountable(String word) {\r\n        uncountable.add(word);\r\n    }\r\n\r\n    /**\r\n     * Does the given word match?\r\n     * @param word The word\r\n     * @return True if it matches the inflection pattern\r\n     */\r\n    public boolean match(String word) {\r\n        int flags = 0;\r\n        if (ignoreCase) {\r\n            flags = flags | Pattern.CASE_INSENSITIVE;\r\n        }\r\n        return Pattern.compile(pattern, flags).matcher(word).find();\r\n    }\r\n\r\n    /**\r\n     * Replace the word with its pattern.\r\n     * @param word The word\r\n     * @return The result\r\n     */\r\n    public String replace(String word) {\r\n        int flags = 0;\r\n        if (ignoreCase) {\r\n            flags = flags | Pattern.CASE_INSENSITIVE;\r\n        }\r\n        return Pattern.compile(pattern, flags).matcher(word).replaceAll(replacement);\r\n    }\r\n\r\n    /**\r\n     * Return the pluralized version of a word.\r\n     * @param word The word\r\n     * @return The pluralized word\r\n     */\r\n    public static String pluralize(String word) {\r\n        if (Inflection.isUncountable(word)) {\r\n            return word;\r\n        }\r\n        for (Inflection inflection : plural) {\r\n            if (inflection.match(word)) {\r\n                return inflection.replace(word);\r\n            }\r\n        }\r\n        return word;\r\n    }\r\n\r\n    /**\r\n     * Return the singularized version of a word.\r\n     * @param word The word\r\n     * @return The singularized word\r\n     */\r\n    public static String singularize(String word) {\r\n        if (Inflection.isUncountable(word)) {\r\n            return word;\r\n        }\r\n        for (Inflection inflection : singular) {\r\n            //System.out.println(word + \" matches \" + inflection.pattern + \"? (ignore case: \" + inflection.ignoreCase + \")\");\r\n            if (inflection.match(word)) {\r\n                //System.out.println(\"match!\");\r\n                return inflection.replace(word);\r\n            }\r\n        }\r\n        return word;\r\n    }\r\n\r\n    /**\r\n     * Return true if the word is uncountable.\r\n     * @param word The word\r\n     * @return True if it is uncountable\r\n     */\r\n    public static boolean isUncountable(String word) {\r\n        for (String w : uncountable) {\r\n            if (w.equalsIgnoreCase(word))\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/InflectionTest0.java",
		"test_prompt": "// InflectionTest0.java\npackage net.sourceforge.schemaspy.util;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Pattern;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Inflection}.\n* It contains ten unit test cases for the {@link Inflection#match(String)} method.\n*/\nclass InflectionTest0 {"
	},
	{
		"original_code": "// Inflection.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy.util;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.regex.Pattern;\r\n\r\n/**\r\n * Implementation of Rails'\r\n * <a href='http://api.rubyonrails.org/classes/ActiveSupport/CoreExtensions/String/Inflections.html'>Inflections</a>\r\n * to handle singularization and pluralization of 'Rails strings'.\r\n *\r\n * Copied from <a href='http://code.google.com/p/rogueweb/'>rogueweb</a>'s port of Rails to Java.\r\n *\r\n * @author Anthony Eden\r\n */\r\npublic class Inflection {\r\n\r\n    private static final List<Inflection> plural = new ArrayList<Inflection>();\r\n\r\n    private static final List<Inflection> singular = new ArrayList<Inflection>();\r\n\r\n    private static final List<String> uncountable = new ArrayList<String>();\r\n\r\n    static {\r\n        // plural is \"singular to plural form\"\r\n        // singular is \"plural to singular form\"\r\n        plural(\"$\", \"s\");\r\n        plural(\"s$\", \"s\");\r\n        plural(\"(ax|test)is$\", \"$1es\");\r\n        plural(\"(octop|vir)us$\", \"$1i\");\r\n        plural(\"(alias|status)$\", \"$1es\");\r\n        plural(\"(bu)s$\", \"$1ses\");\r\n        plural(\"(buffal|tomat)o$\", \"$1oes\");\r\n        plural(\"([ti])um$\", \"$1a\");\r\n        plural(\"sis$\", \"ses\");\r\n        plural(\"(?:([^f])fe|([lr])f)$\", \"$1$2ves\");\r\n        plural(\"(hive)$\", \"$1s\");\r\n        plural(\"([^aeiouy]|qu)y$\", \"$1ies\");\r\n        //plural(\"([^aeiouy]|qu)ies$\", \"$1y\");\r\n        plural(\"(x|ch|ss|sh)$\", \"$1es\");\r\n        plural(\"(matr|vert|ind)ix|ex$\", \"$1ices\");\r\n        plural(\"([m|l])ouse$\", \"$1ice\");\r\n        plural(\"^(ox)$\", \"$1en\");\r\n        plural(\"(quiz)$\", \"$1zes\");\r\n        singular(\"s$\", \"\");\r\n        singular(\"(n)ews$\", \"$1ews\");\r\n        singular(\"([ti])a$\", \"$1um\");\r\n        singular(\"((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$\", \"$1$2sis\");\r\n        singular(\"(^analy)ses$\", \"$1sis\");\r\n        singular(\"([^f])ves$\", \"$1fe\");\r\n        singular(\"(hive)s$\", \"$1\");\r\n        singular(\"(tive)s$\", \"$1\");\r\n        singular(\"([lr])ves$\", \"$1f\");\r\n        singular(\"([^aeiouy]|qu)ies$\", \"$1y\");\r\n        singular(\"(s)eries$\", \"$1eries\");\r\n        singular(\"(m)ovies$\", \"$1ovie\");\r\n        singular(\"(x|ch|ss|sh)es$\", \"$1\");\r\n        singular(\"([m|l])ice$\", \"$1ouse\");\r\n        singular(\"(bus)es$\", \"$1\");\r\n        singular(\"(o)es$\", \"$1\");\r\n        singular(\"(shoe)s$\", \"$1\");\r\n        singular(\"(cris|ax|test)es$\", \"$1is\");\r\n        singular(\"(octop|vir)i$\", \"$1us\");\r\n        singular(\"(alias|status)es$\", \"$1\");\r\n        singular(\"^(ox)en\", \"$1\");\r\n        singular(\"(vert|ind)ices$\", \"$1ex\");\r\n        singular(\"(matr)ices$\", \"$1ix\");\r\n        singular(\"(quiz)zes$\", \"$1\");\r\n        // irregular\r\n        irregular(\"person\", \"people\");\r\n        irregular(\"man\", \"men\");\r\n        irregular(\"child\", \"children\");\r\n        irregular(\"sex\", \"sexes\");\r\n        irregular(\"move\", \"moves\");\r\n        uncountable(\"equipment\");\r\n        uncountable(\"information\");\r\n        uncountable(\"rice\");\r\n        uncountable(\"money\");\r\n        uncountable(\"species\");\r\n        uncountable(\"series\");\r\n        uncountable(\"fish\");\r\n        uncountable(\"sheep\");\r\n        //Collections.reverse(singular);\r\n        //Collections.reverse(plural);\r\n    }\r\n\r\n    private final String pattern;\r\n\r\n    private final String replacement;\r\n\r\n    private final boolean ignoreCase;\r\n\r\n    public Inflection(String pattern) {\r\n        this(pattern, null, true);\r\n    }\r\n\r\n    public Inflection(String pattern, String replacement) {\r\n        this(pattern, replacement, true);\r\n    }\r\n\r\n    public Inflection(String pattern, String replacement, boolean ignoreCase) {\r\n        this.pattern = pattern;\r\n        this.replacement = replacement;\r\n        this.ignoreCase = ignoreCase;\r\n    }\r\n\r\n    private static void plural(String pattern, String replacement) {\r\n        plural.add(0, new Inflection(pattern, replacement));\r\n    }\r\n\r\n    private static void singular(String pattern, String replacement) {\r\n        singular.add(0, new Inflection(pattern, replacement));\r\n    }\r\n\r\n    private static void irregular(String s, String p) {\r\n        plural(\"(\" + s.substring(0, 1) + \")\" + s.substring(1) + \"$\", \"$1\" + p.substring(1));\r\n        singular(\"(\" + p.substring(0, 1) + \")\" + p.substring(1) + \"$\", \"$1\" + s.substring(1));\r\n    }\r\n\r\n    private static void uncountable(String word) {\r\n        uncountable.add(word);\r\n    }\r\n\r\n    /**\r\n     * Does the given word match?\r\n     * @param word The word\r\n     * @return True if it matches the inflection pattern\r\n     */\r\n    public boolean match(String word) {\r\n        int flags = 0;\r\n        if (ignoreCase) {\r\n            flags = flags | Pattern.CASE_INSENSITIVE;\r\n        }\r\n        return Pattern.compile(pattern, flags).matcher(word).find();\r\n    }\r\n\r\n    /**\r\n     * Replace the word with its pattern.\r\n     * @param word The word\r\n     * @return The result\r\n     */\r\n    public String replace(String word) {\r\n        int flags = 0;\r\n        if (ignoreCase) {\r\n            flags = flags | Pattern.CASE_INSENSITIVE;\r\n        }\r\n        return Pattern.compile(pattern, flags).matcher(word).replaceAll(replacement);\r\n    }\r\n\r\n    /**\r\n     * Return the pluralized version of a word.\r\n     * @param word The word\r\n     * @return The pluralized word\r\n     */\r\n    public static String pluralize(String word) {\r\n        if (Inflection.isUncountable(word)) {\r\n            return word;\r\n        }\r\n        for (Inflection inflection : plural) {\r\n            if (inflection.match(word)) {\r\n                return inflection.replace(word);\r\n            }\r\n        }\r\n        return word;\r\n    }\r\n\r\n    /**\r\n     * Return the singularized version of a word.\r\n     * @param word The word\r\n     * @return The singularized word\r\n     */\r\n    public static String singularize(String word) {\r\n        if (Inflection.isUncountable(word)) {\r\n            return word;\r\n        }\r\n        for (Inflection inflection : singular) {\r\n            //System.out.println(word + \" matches \" + inflection.pattern + \"? (ignore case: \" + inflection.ignoreCase + \")\");\r\n            if (inflection.match(word)) {\r\n                //System.out.println(\"match!\");\r\n                return inflection.replace(word);\r\n            }\r\n        }\r\n        return word;\r\n    }\r\n\r\n    /**\r\n     * Return true if the word is uncountable.\r\n     * @param word The word\r\n     * @return True if it is uncountable\r\n     */\r\n    public static boolean isUncountable(String word) {\r\n        for (String w : uncountable) {\r\n            if (w.equalsIgnoreCase(word))\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/InflectionTest1.java",
		"test_prompt": "// InflectionTest1.java\npackage net.sourceforge.schemaspy.util;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Pattern;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Inflection}.\n* It contains ten unit test cases for the {@link Inflection#replace(String)} method.\n*/\nclass InflectionTest1 {"
	},
	{
		"original_code": "// Inflection.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy.util;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.regex.Pattern;\r\n\r\n/**\r\n * Implementation of Rails'\r\n * <a href='http://api.rubyonrails.org/classes/ActiveSupport/CoreExtensions/String/Inflections.html'>Inflections</a>\r\n * to handle singularization and pluralization of 'Rails strings'.\r\n *\r\n * Copied from <a href='http://code.google.com/p/rogueweb/'>rogueweb</a>'s port of Rails to Java.\r\n *\r\n * @author Anthony Eden\r\n */\r\npublic class Inflection {\r\n\r\n    private static final List<Inflection> plural = new ArrayList<Inflection>();\r\n\r\n    private static final List<Inflection> singular = new ArrayList<Inflection>();\r\n\r\n    private static final List<String> uncountable = new ArrayList<String>();\r\n\r\n    static {\r\n        // plural is \"singular to plural form\"\r\n        // singular is \"plural to singular form\"\r\n        plural(\"$\", \"s\");\r\n        plural(\"s$\", \"s\");\r\n        plural(\"(ax|test)is$\", \"$1es\");\r\n        plural(\"(octop|vir)us$\", \"$1i\");\r\n        plural(\"(alias|status)$\", \"$1es\");\r\n        plural(\"(bu)s$\", \"$1ses\");\r\n        plural(\"(buffal|tomat)o$\", \"$1oes\");\r\n        plural(\"([ti])um$\", \"$1a\");\r\n        plural(\"sis$\", \"ses\");\r\n        plural(\"(?:([^f])fe|([lr])f)$\", \"$1$2ves\");\r\n        plural(\"(hive)$\", \"$1s\");\r\n        plural(\"([^aeiouy]|qu)y$\", \"$1ies\");\r\n        //plural(\"([^aeiouy]|qu)ies$\", \"$1y\");\r\n        plural(\"(x|ch|ss|sh)$\", \"$1es\");\r\n        plural(\"(matr|vert|ind)ix|ex$\", \"$1ices\");\r\n        plural(\"([m|l])ouse$\", \"$1ice\");\r\n        plural(\"^(ox)$\", \"$1en\");\r\n        plural(\"(quiz)$\", \"$1zes\");\r\n        singular(\"s$\", \"\");\r\n        singular(\"(n)ews$\", \"$1ews\");\r\n        singular(\"([ti])a$\", \"$1um\");\r\n        singular(\"((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$\", \"$1$2sis\");\r\n        singular(\"(^analy)ses$\", \"$1sis\");\r\n        singular(\"([^f])ves$\", \"$1fe\");\r\n        singular(\"(hive)s$\", \"$1\");\r\n        singular(\"(tive)s$\", \"$1\");\r\n        singular(\"([lr])ves$\", \"$1f\");\r\n        singular(\"([^aeiouy]|qu)ies$\", \"$1y\");\r\n        singular(\"(s)eries$\", \"$1eries\");\r\n        singular(\"(m)ovies$\", \"$1ovie\");\r\n        singular(\"(x|ch|ss|sh)es$\", \"$1\");\r\n        singular(\"([m|l])ice$\", \"$1ouse\");\r\n        singular(\"(bus)es$\", \"$1\");\r\n        singular(\"(o)es$\", \"$1\");\r\n        singular(\"(shoe)s$\", \"$1\");\r\n        singular(\"(cris|ax|test)es$\", \"$1is\");\r\n        singular(\"(octop|vir)i$\", \"$1us\");\r\n        singular(\"(alias|status)es$\", \"$1\");\r\n        singular(\"^(ox)en\", \"$1\");\r\n        singular(\"(vert|ind)ices$\", \"$1ex\");\r\n        singular(\"(matr)ices$\", \"$1ix\");\r\n        singular(\"(quiz)zes$\", \"$1\");\r\n        // irregular\r\n        irregular(\"person\", \"people\");\r\n        irregular(\"man\", \"men\");\r\n        irregular(\"child\", \"children\");\r\n        irregular(\"sex\", \"sexes\");\r\n        irregular(\"move\", \"moves\");\r\n        uncountable(\"equipment\");\r\n        uncountable(\"information\");\r\n        uncountable(\"rice\");\r\n        uncountable(\"money\");\r\n        uncountable(\"species\");\r\n        uncountable(\"series\");\r\n        uncountable(\"fish\");\r\n        uncountable(\"sheep\");\r\n        //Collections.reverse(singular);\r\n        //Collections.reverse(plural);\r\n    }\r\n\r\n    private final String pattern;\r\n\r\n    private final String replacement;\r\n\r\n    private final boolean ignoreCase;\r\n\r\n    public Inflection(String pattern) {\r\n        this(pattern, null, true);\r\n    }\r\n\r\n    public Inflection(String pattern, String replacement) {\r\n        this(pattern, replacement, true);\r\n    }\r\n\r\n    public Inflection(String pattern, String replacement, boolean ignoreCase) {\r\n        this.pattern = pattern;\r\n        this.replacement = replacement;\r\n        this.ignoreCase = ignoreCase;\r\n    }\r\n\r\n    private static void plural(String pattern, String replacement) {\r\n        plural.add(0, new Inflection(pattern, replacement));\r\n    }\r\n\r\n    private static void singular(String pattern, String replacement) {\r\n        singular.add(0, new Inflection(pattern, replacement));\r\n    }\r\n\r\n    private static void irregular(String s, String p) {\r\n        plural(\"(\" + s.substring(0, 1) + \")\" + s.substring(1) + \"$\", \"$1\" + p.substring(1));\r\n        singular(\"(\" + p.substring(0, 1) + \")\" + p.substring(1) + \"$\", \"$1\" + s.substring(1));\r\n    }\r\n\r\n    private static void uncountable(String word) {\r\n        uncountable.add(word);\r\n    }\r\n\r\n    /**\r\n     * Does the given word match?\r\n     * @param word The word\r\n     * @return True if it matches the inflection pattern\r\n     */\r\n    public boolean match(String word) {\r\n        int flags = 0;\r\n        if (ignoreCase) {\r\n            flags = flags | Pattern.CASE_INSENSITIVE;\r\n        }\r\n        return Pattern.compile(pattern, flags).matcher(word).find();\r\n    }\r\n\r\n    /**\r\n     * Replace the word with its pattern.\r\n     * @param word The word\r\n     * @return The result\r\n     */\r\n    public String replace(String word) {\r\n        int flags = 0;\r\n        if (ignoreCase) {\r\n            flags = flags | Pattern.CASE_INSENSITIVE;\r\n        }\r\n        return Pattern.compile(pattern, flags).matcher(word).replaceAll(replacement);\r\n    }\r\n\r\n    /**\r\n     * Return the pluralized version of a word.\r\n     * @param word The word\r\n     * @return The pluralized word\r\n     */\r\n    public static String pluralize(String word) {\r\n        if (Inflection.isUncountable(word)) {\r\n            return word;\r\n        }\r\n        for (Inflection inflection : plural) {\r\n            if (inflection.match(word)) {\r\n                return inflection.replace(word);\r\n            }\r\n        }\r\n        return word;\r\n    }\r\n\r\n    /**\r\n     * Return the singularized version of a word.\r\n     * @param word The word\r\n     * @return The singularized word\r\n     */\r\n    public static String singularize(String word) {\r\n        if (Inflection.isUncountable(word)) {\r\n            return word;\r\n        }\r\n        for (Inflection inflection : singular) {\r\n            //System.out.println(word + \" matches \" + inflection.pattern + \"? (ignore case: \" + inflection.ignoreCase + \")\");\r\n            if (inflection.match(word)) {\r\n                //System.out.println(\"match!\");\r\n                return inflection.replace(word);\r\n            }\r\n        }\r\n        return word;\r\n    }\r\n\r\n    /**\r\n     * Return true if the word is uncountable.\r\n     * @param word The word\r\n     * @return True if it is uncountable\r\n     */\r\n    public static boolean isUncountable(String word) {\r\n        for (String w : uncountable) {\r\n            if (w.equalsIgnoreCase(word))\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/InflectionTest2.java",
		"test_prompt": "// InflectionTest2.java\npackage net.sourceforge.schemaspy.util;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Pattern;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Inflection}.\n* It contains ten unit test cases for the {@link Inflection#pluralize(String)} method.\n*/\nclass InflectionTest2 {"
	},
	{
		"original_code": "// Inflection.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy.util;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.regex.Pattern;\r\n\r\n/**\r\n * Implementation of Rails'\r\n * <a href='http://api.rubyonrails.org/classes/ActiveSupport/CoreExtensions/String/Inflections.html'>Inflections</a>\r\n * to handle singularization and pluralization of 'Rails strings'.\r\n *\r\n * Copied from <a href='http://code.google.com/p/rogueweb/'>rogueweb</a>'s port of Rails to Java.\r\n *\r\n * @author Anthony Eden\r\n */\r\npublic class Inflection {\r\n\r\n    private static final List<Inflection> plural = new ArrayList<Inflection>();\r\n\r\n    private static final List<Inflection> singular = new ArrayList<Inflection>();\r\n\r\n    private static final List<String> uncountable = new ArrayList<String>();\r\n\r\n    static {\r\n        // plural is \"singular to plural form\"\r\n        // singular is \"plural to singular form\"\r\n        plural(\"$\", \"s\");\r\n        plural(\"s$\", \"s\");\r\n        plural(\"(ax|test)is$\", \"$1es\");\r\n        plural(\"(octop|vir)us$\", \"$1i\");\r\n        plural(\"(alias|status)$\", \"$1es\");\r\n        plural(\"(bu)s$\", \"$1ses\");\r\n        plural(\"(buffal|tomat)o$\", \"$1oes\");\r\n        plural(\"([ti])um$\", \"$1a\");\r\n        plural(\"sis$\", \"ses\");\r\n        plural(\"(?:([^f])fe|([lr])f)$\", \"$1$2ves\");\r\n        plural(\"(hive)$\", \"$1s\");\r\n        plural(\"([^aeiouy]|qu)y$\", \"$1ies\");\r\n        //plural(\"([^aeiouy]|qu)ies$\", \"$1y\");\r\n        plural(\"(x|ch|ss|sh)$\", \"$1es\");\r\n        plural(\"(matr|vert|ind)ix|ex$\", \"$1ices\");\r\n        plural(\"([m|l])ouse$\", \"$1ice\");\r\n        plural(\"^(ox)$\", \"$1en\");\r\n        plural(\"(quiz)$\", \"$1zes\");\r\n        singular(\"s$\", \"\");\r\n        singular(\"(n)ews$\", \"$1ews\");\r\n        singular(\"([ti])a$\", \"$1um\");\r\n        singular(\"((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$\", \"$1$2sis\");\r\n        singular(\"(^analy)ses$\", \"$1sis\");\r\n        singular(\"([^f])ves$\", \"$1fe\");\r\n        singular(\"(hive)s$\", \"$1\");\r\n        singular(\"(tive)s$\", \"$1\");\r\n        singular(\"([lr])ves$\", \"$1f\");\r\n        singular(\"([^aeiouy]|qu)ies$\", \"$1y\");\r\n        singular(\"(s)eries$\", \"$1eries\");\r\n        singular(\"(m)ovies$\", \"$1ovie\");\r\n        singular(\"(x|ch|ss|sh)es$\", \"$1\");\r\n        singular(\"([m|l])ice$\", \"$1ouse\");\r\n        singular(\"(bus)es$\", \"$1\");\r\n        singular(\"(o)es$\", \"$1\");\r\n        singular(\"(shoe)s$\", \"$1\");\r\n        singular(\"(cris|ax|test)es$\", \"$1is\");\r\n        singular(\"(octop|vir)i$\", \"$1us\");\r\n        singular(\"(alias|status)es$\", \"$1\");\r\n        singular(\"^(ox)en\", \"$1\");\r\n        singular(\"(vert|ind)ices$\", \"$1ex\");\r\n        singular(\"(matr)ices$\", \"$1ix\");\r\n        singular(\"(quiz)zes$\", \"$1\");\r\n        // irregular\r\n        irregular(\"person\", \"people\");\r\n        irregular(\"man\", \"men\");\r\n        irregular(\"child\", \"children\");\r\n        irregular(\"sex\", \"sexes\");\r\n        irregular(\"move\", \"moves\");\r\n        uncountable(\"equipment\");\r\n        uncountable(\"information\");\r\n        uncountable(\"rice\");\r\n        uncountable(\"money\");\r\n        uncountable(\"species\");\r\n        uncountable(\"series\");\r\n        uncountable(\"fish\");\r\n        uncountable(\"sheep\");\r\n        //Collections.reverse(singular);\r\n        //Collections.reverse(plural);\r\n    }\r\n\r\n    private final String pattern;\r\n\r\n    private final String replacement;\r\n\r\n    private final boolean ignoreCase;\r\n\r\n    public Inflection(String pattern) {\r\n        this(pattern, null, true);\r\n    }\r\n\r\n    public Inflection(String pattern, String replacement) {\r\n        this(pattern, replacement, true);\r\n    }\r\n\r\n    public Inflection(String pattern, String replacement, boolean ignoreCase) {\r\n        this.pattern = pattern;\r\n        this.replacement = replacement;\r\n        this.ignoreCase = ignoreCase;\r\n    }\r\n\r\n    private static void plural(String pattern, String replacement) {\r\n        plural.add(0, new Inflection(pattern, replacement));\r\n    }\r\n\r\n    private static void singular(String pattern, String replacement) {\r\n        singular.add(0, new Inflection(pattern, replacement));\r\n    }\r\n\r\n    private static void irregular(String s, String p) {\r\n        plural(\"(\" + s.substring(0, 1) + \")\" + s.substring(1) + \"$\", \"$1\" + p.substring(1));\r\n        singular(\"(\" + p.substring(0, 1) + \")\" + p.substring(1) + \"$\", \"$1\" + s.substring(1));\r\n    }\r\n\r\n    private static void uncountable(String word) {\r\n        uncountable.add(word);\r\n    }\r\n\r\n    /**\r\n     * Does the given word match?\r\n     * @param word The word\r\n     * @return True if it matches the inflection pattern\r\n     */\r\n    public boolean match(String word) {\r\n        int flags = 0;\r\n        if (ignoreCase) {\r\n            flags = flags | Pattern.CASE_INSENSITIVE;\r\n        }\r\n        return Pattern.compile(pattern, flags).matcher(word).find();\r\n    }\r\n\r\n    /**\r\n     * Replace the word with its pattern.\r\n     * @param word The word\r\n     * @return The result\r\n     */\r\n    public String replace(String word) {\r\n        int flags = 0;\r\n        if (ignoreCase) {\r\n            flags = flags | Pattern.CASE_INSENSITIVE;\r\n        }\r\n        return Pattern.compile(pattern, flags).matcher(word).replaceAll(replacement);\r\n    }\r\n\r\n    /**\r\n     * Return the pluralized version of a word.\r\n     * @param word The word\r\n     * @return The pluralized word\r\n     */\r\n    public static String pluralize(String word) {\r\n        if (Inflection.isUncountable(word)) {\r\n            return word;\r\n        }\r\n        for (Inflection inflection : plural) {\r\n            if (inflection.match(word)) {\r\n                return inflection.replace(word);\r\n            }\r\n        }\r\n        return word;\r\n    }\r\n\r\n    /**\r\n     * Return the singularized version of a word.\r\n     * @param word The word\r\n     * @return The singularized word\r\n     */\r\n    public static String singularize(String word) {\r\n        if (Inflection.isUncountable(word)) {\r\n            return word;\r\n        }\r\n        for (Inflection inflection : singular) {\r\n            //System.out.println(word + \" matches \" + inflection.pattern + \"? (ignore case: \" + inflection.ignoreCase + \")\");\r\n            if (inflection.match(word)) {\r\n                //System.out.println(\"match!\");\r\n                return inflection.replace(word);\r\n            }\r\n        }\r\n        return word;\r\n    }\r\n\r\n    /**\r\n     * Return true if the word is uncountable.\r\n     * @param word The word\r\n     * @return True if it is uncountable\r\n     */\r\n    public static boolean isUncountable(String word) {\r\n        for (String w : uncountable) {\r\n            if (w.equalsIgnoreCase(word))\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/InflectionTest3.java",
		"test_prompt": "// InflectionTest3.java\npackage net.sourceforge.schemaspy.util;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Pattern;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Inflection}.\n* It contains ten unit test cases for the {@link Inflection#singularize(String)} method.\n*/\nclass InflectionTest3 {"
	},
	{
		"original_code": "// Inflection.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy.util;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.regex.Pattern;\r\n\r\n/**\r\n * Implementation of Rails'\r\n * <a href='http://api.rubyonrails.org/classes/ActiveSupport/CoreExtensions/String/Inflections.html'>Inflections</a>\r\n * to handle singularization and pluralization of 'Rails strings'.\r\n *\r\n * Copied from <a href='http://code.google.com/p/rogueweb/'>rogueweb</a>'s port of Rails to Java.\r\n *\r\n * @author Anthony Eden\r\n */\r\npublic class Inflection {\r\n\r\n    private static final List<Inflection> plural = new ArrayList<Inflection>();\r\n\r\n    private static final List<Inflection> singular = new ArrayList<Inflection>();\r\n\r\n    private static final List<String> uncountable = new ArrayList<String>();\r\n\r\n    static {\r\n        // plural is \"singular to plural form\"\r\n        // singular is \"plural to singular form\"\r\n        plural(\"$\", \"s\");\r\n        plural(\"s$\", \"s\");\r\n        plural(\"(ax|test)is$\", \"$1es\");\r\n        plural(\"(octop|vir)us$\", \"$1i\");\r\n        plural(\"(alias|status)$\", \"$1es\");\r\n        plural(\"(bu)s$\", \"$1ses\");\r\n        plural(\"(buffal|tomat)o$\", \"$1oes\");\r\n        plural(\"([ti])um$\", \"$1a\");\r\n        plural(\"sis$\", \"ses\");\r\n        plural(\"(?:([^f])fe|([lr])f)$\", \"$1$2ves\");\r\n        plural(\"(hive)$\", \"$1s\");\r\n        plural(\"([^aeiouy]|qu)y$\", \"$1ies\");\r\n        //plural(\"([^aeiouy]|qu)ies$\", \"$1y\");\r\n        plural(\"(x|ch|ss|sh)$\", \"$1es\");\r\n        plural(\"(matr|vert|ind)ix|ex$\", \"$1ices\");\r\n        plural(\"([m|l])ouse$\", \"$1ice\");\r\n        plural(\"^(ox)$\", \"$1en\");\r\n        plural(\"(quiz)$\", \"$1zes\");\r\n        singular(\"s$\", \"\");\r\n        singular(\"(n)ews$\", \"$1ews\");\r\n        singular(\"([ti])a$\", \"$1um\");\r\n        singular(\"((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$\", \"$1$2sis\");\r\n        singular(\"(^analy)ses$\", \"$1sis\");\r\n        singular(\"([^f])ves$\", \"$1fe\");\r\n        singular(\"(hive)s$\", \"$1\");\r\n        singular(\"(tive)s$\", \"$1\");\r\n        singular(\"([lr])ves$\", \"$1f\");\r\n        singular(\"([^aeiouy]|qu)ies$\", \"$1y\");\r\n        singular(\"(s)eries$\", \"$1eries\");\r\n        singular(\"(m)ovies$\", \"$1ovie\");\r\n        singular(\"(x|ch|ss|sh)es$\", \"$1\");\r\n        singular(\"([m|l])ice$\", \"$1ouse\");\r\n        singular(\"(bus)es$\", \"$1\");\r\n        singular(\"(o)es$\", \"$1\");\r\n        singular(\"(shoe)s$\", \"$1\");\r\n        singular(\"(cris|ax|test)es$\", \"$1is\");\r\n        singular(\"(octop|vir)i$\", \"$1us\");\r\n        singular(\"(alias|status)es$\", \"$1\");\r\n        singular(\"^(ox)en\", \"$1\");\r\n        singular(\"(vert|ind)ices$\", \"$1ex\");\r\n        singular(\"(matr)ices$\", \"$1ix\");\r\n        singular(\"(quiz)zes$\", \"$1\");\r\n        // irregular\r\n        irregular(\"person\", \"people\");\r\n        irregular(\"man\", \"men\");\r\n        irregular(\"child\", \"children\");\r\n        irregular(\"sex\", \"sexes\");\r\n        irregular(\"move\", \"moves\");\r\n        uncountable(\"equipment\");\r\n        uncountable(\"information\");\r\n        uncountable(\"rice\");\r\n        uncountable(\"money\");\r\n        uncountable(\"species\");\r\n        uncountable(\"series\");\r\n        uncountable(\"fish\");\r\n        uncountable(\"sheep\");\r\n        //Collections.reverse(singular);\r\n        //Collections.reverse(plural);\r\n    }\r\n\r\n    private final String pattern;\r\n\r\n    private final String replacement;\r\n\r\n    private final boolean ignoreCase;\r\n\r\n    public Inflection(String pattern) {\r\n        this(pattern, null, true);\r\n    }\r\n\r\n    public Inflection(String pattern, String replacement) {\r\n        this(pattern, replacement, true);\r\n    }\r\n\r\n    public Inflection(String pattern, String replacement, boolean ignoreCase) {\r\n        this.pattern = pattern;\r\n        this.replacement = replacement;\r\n        this.ignoreCase = ignoreCase;\r\n    }\r\n\r\n    private static void plural(String pattern, String replacement) {\r\n        plural.add(0, new Inflection(pattern, replacement));\r\n    }\r\n\r\n    private static void singular(String pattern, String replacement) {\r\n        singular.add(0, new Inflection(pattern, replacement));\r\n    }\r\n\r\n    private static void irregular(String s, String p) {\r\n        plural(\"(\" + s.substring(0, 1) + \")\" + s.substring(1) + \"$\", \"$1\" + p.substring(1));\r\n        singular(\"(\" + p.substring(0, 1) + \")\" + p.substring(1) + \"$\", \"$1\" + s.substring(1));\r\n    }\r\n\r\n    private static void uncountable(String word) {\r\n        uncountable.add(word);\r\n    }\r\n\r\n    /**\r\n     * Does the given word match?\r\n     * @param word The word\r\n     * @return True if it matches the inflection pattern\r\n     */\r\n    public boolean match(String word) {\r\n        int flags = 0;\r\n        if (ignoreCase) {\r\n            flags = flags | Pattern.CASE_INSENSITIVE;\r\n        }\r\n        return Pattern.compile(pattern, flags).matcher(word).find();\r\n    }\r\n\r\n    /**\r\n     * Replace the word with its pattern.\r\n     * @param word The word\r\n     * @return The result\r\n     */\r\n    public String replace(String word) {\r\n        int flags = 0;\r\n        if (ignoreCase) {\r\n            flags = flags | Pattern.CASE_INSENSITIVE;\r\n        }\r\n        return Pattern.compile(pattern, flags).matcher(word).replaceAll(replacement);\r\n    }\r\n\r\n    /**\r\n     * Return the pluralized version of a word.\r\n     * @param word The word\r\n     * @return The pluralized word\r\n     */\r\n    public static String pluralize(String word) {\r\n        if (Inflection.isUncountable(word)) {\r\n            return word;\r\n        }\r\n        for (Inflection inflection : plural) {\r\n            if (inflection.match(word)) {\r\n                return inflection.replace(word);\r\n            }\r\n        }\r\n        return word;\r\n    }\r\n\r\n    /**\r\n     * Return the singularized version of a word.\r\n     * @param word The word\r\n     * @return The singularized word\r\n     */\r\n    public static String singularize(String word) {\r\n        if (Inflection.isUncountable(word)) {\r\n            return word;\r\n        }\r\n        for (Inflection inflection : singular) {\r\n            //System.out.println(word + \" matches \" + inflection.pattern + \"? (ignore case: \" + inflection.ignoreCase + \")\");\r\n            if (inflection.match(word)) {\r\n                //System.out.println(\"match!\");\r\n                return inflection.replace(word);\r\n            }\r\n        }\r\n        return word;\r\n    }\r\n\r\n    /**\r\n     * Return true if the word is uncountable.\r\n     * @param word The word\r\n     * @return True if it is uncountable\r\n     */\r\n    public static boolean isUncountable(String word) {\r\n        for (String w : uncountable) {\r\n            if (w.equalsIgnoreCase(word))\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/InflectionTest4.java",
		"test_prompt": "// InflectionTest4.java\npackage net.sourceforge.schemaspy.util;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Pattern;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Inflection}.\n* It contains ten unit test cases for the {@link Inflection#isUncountable(String)} method.\n*/\nclass InflectionTest4 {"
	},
	{
		"original_code": "// PasswordReader.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy.util;\r\n\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.PushbackInputStream;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * This class prompts the user for a password and attempts to mask input with\r\n * \"*\"\r\n */\r\npublic class PasswordReader {\r\n\r\n    private static PasswordReader instance;\r\n\r\n    public static synchronized PasswordReader getInstance() {\r\n        if (instance == null) {\r\n            try {\r\n                instance = new ConsolePasswordReader();\r\n            } catch (Throwable exc) {\r\n                // Java6+ version can't be loaded, so revert to this implementation\r\n                instance = new PasswordReader();\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n\r\n    /**\r\n     * Use {@link #getInstance()} instead.\r\n     */\r\n    protected PasswordReader() {\r\n    }\r\n\r\n    /**\r\n     * Matches the contract of Java 1.6+'s {@link java.io.Console#readPassword}\r\n     * except that our own IOError is thrown in place of the 1.6-specific IOError.\r\n     * By matching the contract we can use this implementation when\r\n     * running in a 1.5 JVM or the much better implementation that\r\n     * was introduced in 1.6 when running in a JVM that supplies it.\r\n     *\r\n     * @param fmt\r\n     * @param args\r\n     * @return\r\n     */\r\n    public char[] readPassword(String fmt, Object... args) {\r\n        InputStream in = System.in;\r\n        char[] lineBuffer;\r\n        char[] buf = lineBuffer = new char[128];\r\n        int room = buf.length;\r\n        int offset = 0;\r\n        int ch;\r\n        boolean reading = true;\r\n        Masker masker = new Masker(String.format(fmt, args));\r\n        masker.start();\r\n        try {\r\n            while (reading) {\r\n                switch(ch = in.read()) {\r\n                    case -1:\r\n                    case '\\n':\r\n                        reading = false;\r\n                        break;\r\n                    case '\\r':\r\n                        int c2 = in.read();\r\n                        if (c2 != '\\n' && c2 != -1) {\r\n                            if (!(in instanceof PushbackInputStream)) {\r\n                                in = new PushbackInputStream(in);\r\n                            }\r\n                            ((PushbackInputStream) in).unread(c2);\r\n                        } else {\r\n                            reading = false;\r\n                        }\r\n                        break;\r\n                    default:\r\n                        if (--room < 0) {\r\n                            buf = new char[offset + 128];\r\n                            room = buf.length - offset - 1;\r\n                            System.arraycopy(lineBuffer, 0, buf, 0, offset);\r\n                            Arrays.fill(lineBuffer, ' ');\r\n                            lineBuffer = buf;\r\n                        }\r\n                        buf[offset++] = (char) ch;\r\n                        break;\r\n                }\r\n            }\r\n        } catch (IOException exc) {\r\n            throw new IOError(exc);\r\n        } finally {\r\n            masker.stopMasking();\r\n        }\r\n        if (offset == 0) {\r\n            return null;\r\n        }\r\n        char[] password = new char[offset];\r\n        System.arraycopy(buf, 0, password, 0, offset);\r\n        Arrays.fill(buf, ' ');\r\n        return password;\r\n    }\r\n\r\n    /**\r\n     * Simple thread that constantly overwrites (masking) whatever\r\n     * the user is typing as their password.\r\n     */\r\n    private static class Masker extends Thread {\r\n\r\n        private volatile boolean masking = true;\r\n\r\n        private final String mask;\r\n\r\n        /**\r\n         * @param prompt The prompt displayed to the user\r\n         */\r\n        public Masker(String prompt) {\r\n            // mask that will be printed every iteration\r\n            // it includes spaces to replace what's typed\r\n            // and backspaces to move back over them\r\n            mask = \"\\r\" + prompt + \"     \\010\\010\\010\\010\\010\";\r\n            // set our priority to something higher than the caller's\r\n            setPriority(Thread.currentThread().getPriority() + 1);\r\n        }\r\n\r\n        /**\r\n         * Keep masking until asked to stop\r\n         */\r\n        @Override\r\n        public void run() {\r\n            while (masking) {\r\n                System.out.print(mask);\r\n                try {\r\n                    sleep(100);\r\n                } catch (InterruptedException iex) {\r\n                    interrupt();\r\n                    masking = false;\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Stop masking the password\r\n         */\r\n        public void stopMasking() {\r\n            masking = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Our own implementation of the Java 1.6 IOError class.\r\n     */\r\n    public class IOError extends Error {\r\n\r\n        private static final long serialVersionUID = 20100629L;\r\n\r\n        public IOError(Throwable cause) {\r\n            super(cause);\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/PasswordReaderTest0.java",
		"test_prompt": "// PasswordReaderTest0.java\npackage net.sourceforge.schemaspy.util;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PushbackInputStream;\nimport java.util.Arrays;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PasswordReader}.\n* It contains ten unit test cases for the {@link PasswordReader#getInstance()} method.\n*/\nclass PasswordReaderTest0 {"
	},
	{
		"original_code": "// PasswordReader.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy.util;\r\n\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.PushbackInputStream;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * This class prompts the user for a password and attempts to mask input with\r\n * \"*\"\r\n */\r\npublic class PasswordReader {\r\n\r\n    private static PasswordReader instance;\r\n\r\n    public static synchronized PasswordReader getInstance() {\r\n        if (instance == null) {\r\n            try {\r\n                instance = new ConsolePasswordReader();\r\n            } catch (Throwable exc) {\r\n                // Java6+ version can't be loaded, so revert to this implementation\r\n                instance = new PasswordReader();\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n\r\n    /**\r\n     * Use {@link #getInstance()} instead.\r\n     */\r\n    protected PasswordReader() {\r\n    }\r\n\r\n    /**\r\n     * Matches the contract of Java 1.6+'s {@link java.io.Console#readPassword}\r\n     * except that our own IOError is thrown in place of the 1.6-specific IOError.\r\n     * By matching the contract we can use this implementation when\r\n     * running in a 1.5 JVM or the much better implementation that\r\n     * was introduced in 1.6 when running in a JVM that supplies it.\r\n     *\r\n     * @param fmt\r\n     * @param args\r\n     * @return\r\n     */\r\n    public char[] readPassword(String fmt, Object... args) {\r\n        InputStream in = System.in;\r\n        char[] lineBuffer;\r\n        char[] buf = lineBuffer = new char[128];\r\n        int room = buf.length;\r\n        int offset = 0;\r\n        int ch;\r\n        boolean reading = true;\r\n        Masker masker = new Masker(String.format(fmt, args));\r\n        masker.start();\r\n        try {\r\n            while (reading) {\r\n                switch(ch = in.read()) {\r\n                    case -1:\r\n                    case '\\n':\r\n                        reading = false;\r\n                        break;\r\n                    case '\\r':\r\n                        int c2 = in.read();\r\n                        if (c2 != '\\n' && c2 != -1) {\r\n                            if (!(in instanceof PushbackInputStream)) {\r\n                                in = new PushbackInputStream(in);\r\n                            }\r\n                            ((PushbackInputStream) in).unread(c2);\r\n                        } else {\r\n                            reading = false;\r\n                        }\r\n                        break;\r\n                    default:\r\n                        if (--room < 0) {\r\n                            buf = new char[offset + 128];\r\n                            room = buf.length - offset - 1;\r\n                            System.arraycopy(lineBuffer, 0, buf, 0, offset);\r\n                            Arrays.fill(lineBuffer, ' ');\r\n                            lineBuffer = buf;\r\n                        }\r\n                        buf[offset++] = (char) ch;\r\n                        break;\r\n                }\r\n            }\r\n        } catch (IOException exc) {\r\n            throw new IOError(exc);\r\n        } finally {\r\n            masker.stopMasking();\r\n        }\r\n        if (offset == 0) {\r\n            return null;\r\n        }\r\n        char[] password = new char[offset];\r\n        System.arraycopy(buf, 0, password, 0, offset);\r\n        Arrays.fill(buf, ' ');\r\n        return password;\r\n    }\r\n\r\n    /**\r\n     * Simple thread that constantly overwrites (masking) whatever\r\n     * the user is typing as their password.\r\n     */\r\n    private static class Masker extends Thread {\r\n\r\n        private volatile boolean masking = true;\r\n\r\n        private final String mask;\r\n\r\n        /**\r\n         * @param prompt The prompt displayed to the user\r\n         */\r\n        public Masker(String prompt) {\r\n            // mask that will be printed every iteration\r\n            // it includes spaces to replace what's typed\r\n            // and backspaces to move back over them\r\n            mask = \"\\r\" + prompt + \"     \\010\\010\\010\\010\\010\";\r\n            // set our priority to something higher than the caller's\r\n            setPriority(Thread.currentThread().getPriority() + 1);\r\n        }\r\n\r\n        /**\r\n         * Keep masking until asked to stop\r\n         */\r\n        @Override\r\n        public void run() {\r\n            while (masking) {\r\n                System.out.print(mask);\r\n                try {\r\n                    sleep(100);\r\n                } catch (InterruptedException iex) {\r\n                    interrupt();\r\n                    masking = false;\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Stop masking the password\r\n         */\r\n        public void stopMasking() {\r\n            masking = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Our own implementation of the Java 1.6 IOError class.\r\n     */\r\n    public class IOError extends Error {\r\n\r\n        private static final long serialVersionUID = 20100629L;\r\n\r\n        public IOError(Throwable cause) {\r\n            super(cause);\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/PasswordReaderTest1.java",
		"test_prompt": "// PasswordReaderTest1.java\npackage net.sourceforge.schemaspy.util;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PushbackInputStream;\nimport java.util.Arrays;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PasswordReader}.\n* It contains ten unit test cases for the {@link PasswordReader#readPassword(String, Object[])} method.\n*/\nclass PasswordReaderTest1 {"
	},
	{
		"original_code": "// CaseInsensitiveMap.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy.util;\r\n\r\nimport java.util.HashMap;\r\nimport java.util.Iterator;\r\nimport java.util.Map;\r\n\r\n/**\r\n * A {@link HashMap} implementation that uses {@link String}s as its keys\r\n * where the keys are treated without regard to case.  That is, <code>get(\"MyTableName\")</code>\r\n * will return the same object as <code>get(\"MYTABLENAME\")</code>.\r\n *\r\n * @author John Currier\r\n */\r\npublic class CaseInsensitiveMap<V> extends HashMap<String, V> {\r\n\r\n    private static final long serialVersionUID = 1L;\r\n\r\n    public CaseInsensitiveMap() {\r\n    }\r\n\r\n    public CaseInsensitiveMap(int initialCapacity) {\r\n        super(initialCapacity);\r\n    }\r\n\r\n    @Override\r\n    public V get(Object key) {\r\n        return super.get(((String) key).toUpperCase());\r\n    }\r\n\r\n    @Override\r\n    public V put(String key, V value) {\r\n        return super.put(key.toUpperCase(), value);\r\n    }\r\n\r\n    @Override\r\n    public void putAll(Map<? extends String, ? extends V> map) {\r\n        Iterator<? extends Map.Entry<? extends String, ? extends V>> iter = map.entrySet().iterator();\r\n        while (iter.hasNext()) {\r\n            Map.Entry<? extends String, ? extends V> e = iter.next();\r\n            put(e.getKey(), e.getValue());\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public V remove(Object key) {\r\n        return super.remove(((String) key).toUpperCase());\r\n    }\r\n\r\n    @Override\r\n    public boolean containsKey(Object key) {\r\n        return super.containsKey(((String) key).toUpperCase());\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/CaseInsensitiveMapTest0.java",
		"test_prompt": "// CaseInsensitiveMapTest0.java\npackage net.sourceforge.schemaspy.util;\n\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CaseInsensitiveMap}.\n* It contains ten unit test cases for the {@link CaseInsensitiveMap#put(String, V)} method.\n*/\nclass CaseInsensitiveMapTest0 {"
	},
	{
		"original_code": "// CaseInsensitiveMap.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy.util;\r\n\r\nimport java.util.HashMap;\r\nimport java.util.Iterator;\r\nimport java.util.Map;\r\n\r\n/**\r\n * A {@link HashMap} implementation that uses {@link String}s as its keys\r\n * where the keys are treated without regard to case.  That is, <code>get(\"MyTableName\")</code>\r\n * will return the same object as <code>get(\"MYTABLENAME\")</code>.\r\n *\r\n * @author John Currier\r\n */\r\npublic class CaseInsensitiveMap<V> extends HashMap<String, V> {\r\n\r\n    private static final long serialVersionUID = 1L;\r\n\r\n    public CaseInsensitiveMap() {\r\n    }\r\n\r\n    public CaseInsensitiveMap(int initialCapacity) {\r\n        super(initialCapacity);\r\n    }\r\n\r\n    @Override\r\n    public V get(Object key) {\r\n        return super.get(((String) key).toUpperCase());\r\n    }\r\n\r\n    @Override\r\n    public V put(String key, V value) {\r\n        return super.put(key.toUpperCase(), value);\r\n    }\r\n\r\n    @Override\r\n    public void putAll(Map<? extends String, ? extends V> map) {\r\n        Iterator<? extends Map.Entry<? extends String, ? extends V>> iter = map.entrySet().iterator();\r\n        while (iter.hasNext()) {\r\n            Map.Entry<? extends String, ? extends V> e = iter.next();\r\n            put(e.getKey(), e.getValue());\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public V remove(Object key) {\r\n        return super.remove(((String) key).toUpperCase());\r\n    }\r\n\r\n    @Override\r\n    public boolean containsKey(Object key) {\r\n        return super.containsKey(((String) key).toUpperCase());\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/CaseInsensitiveMapTest1.java",
		"test_prompt": "// CaseInsensitiveMapTest1.java\npackage net.sourceforge.schemaspy.util;\n\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CaseInsensitiveMap}.\n* It contains ten unit test cases for the {@link CaseInsensitiveMap#remove(Object)} method.\n*/\nclass CaseInsensitiveMapTest1 {"
	},
	{
		"original_code": "// CaseInsensitiveMap.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy.util;\r\n\r\nimport java.util.HashMap;\r\nimport java.util.Iterator;\r\nimport java.util.Map;\r\n\r\n/**\r\n * A {@link HashMap} implementation that uses {@link String}s as its keys\r\n * where the keys are treated without regard to case.  That is, <code>get(\"MyTableName\")</code>\r\n * will return the same object as <code>get(\"MYTABLENAME\")</code>.\r\n *\r\n * @author John Currier\r\n */\r\npublic class CaseInsensitiveMap<V> extends HashMap<String, V> {\r\n\r\n    private static final long serialVersionUID = 1L;\r\n\r\n    public CaseInsensitiveMap() {\r\n    }\r\n\r\n    public CaseInsensitiveMap(int initialCapacity) {\r\n        super(initialCapacity);\r\n    }\r\n\r\n    @Override\r\n    public V get(Object key) {\r\n        return super.get(((String) key).toUpperCase());\r\n    }\r\n\r\n    @Override\r\n    public V put(String key, V value) {\r\n        return super.put(key.toUpperCase(), value);\r\n    }\r\n\r\n    @Override\r\n    public void putAll(Map<? extends String, ? extends V> map) {\r\n        Iterator<? extends Map.Entry<? extends String, ? extends V>> iter = map.entrySet().iterator();\r\n        while (iter.hasNext()) {\r\n            Map.Entry<? extends String, ? extends V> e = iter.next();\r\n            put(e.getKey(), e.getValue());\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public V remove(Object key) {\r\n        return super.remove(((String) key).toUpperCase());\r\n    }\r\n\r\n    @Override\r\n    public boolean containsKey(Object key) {\r\n        return super.containsKey(((String) key).toUpperCase());\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/CaseInsensitiveMapTest2.java",
		"test_prompt": "// CaseInsensitiveMapTest2.java\npackage net.sourceforge.schemaspy.util;\n\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CaseInsensitiveMap}.\n* It contains ten unit test cases for the {@link CaseInsensitiveMap#containsKey(Object)} method.\n*/\nclass CaseInsensitiveMapTest2 {"
	},
	{
		"original_code": "// ResultSetDumper.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2011 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy.util;\r\n\r\nimport java.sql.ResultSet;\r\nimport java.sql.ResultSetMetaData;\r\nimport java.sql.SQLException;\r\n\r\n/**\r\n * Simple diagnostic class to give a textual representation\r\n * of columns pointed to by a result set.\r\n *\r\n * @author John Currier\r\n */\r\npublic class ResultSetDumper {\r\n\r\n    public static String dump(ResultSet rs) throws SQLException {\r\n        ResultSetMetaData meta = rs.getMetaData();\r\n        int numCols = meta.getColumnCount();\r\n        StringBuilder buf = new StringBuilder();\r\n        for (int col = 1; col <= numCols; ++col) {\r\n            buf.append(meta.getColumnLabel(col));\r\n            buf.append(\"=\");\r\n            String value = rs.getString(col);\r\n            if (value != null)\r\n                buf.append('\\'');\r\n            buf.append(value);\r\n            if (value != null)\r\n                buf.append('\\'');\r\n            if (col < numCols)\r\n                buf.append(\", \");\r\n        }\r\n        return buf.toString();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/ResultSetDumperTest.java",
		"test_prompt": "// ResultSetDumperTest.java\npackage net.sourceforge.schemaspy.util;\n\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ResultSetDumper}.\n* It contains ten unit test cases for the {@link ResultSetDumper#dump(ResultSet)} method.\n*/\nclass ResultSetDumperTest {"
	},
	{
		"original_code": "// ConsolePasswordReader.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy.util;\r\n\r\nimport java.lang.reflect.InvocationTargetException;\r\nimport java.lang.reflect.Method;\r\n\r\n/**\r\n * Implementation of {@link PasswordReader} that takes advantage of the\r\n * built-in password reading abilities of Java6 (or higher).\r\n *\r\n * Use {@link PasswordReader#getInstance()} to get an instance of\r\n * PasswordReader that's appropriate for your JVM\r\n * (this one requires a Java6 or higher JVM).\r\n *\r\n * @author John Currier\r\n */\r\npublic class ConsolePasswordReader extends PasswordReader {\r\n\r\n    private final Object console;\r\n\r\n    private final Method readPassword;\r\n\r\n    /**\r\n     * Attempt to resolve the Console methods that were introduced in Java6.\r\n     *\r\n     * @throws SecurityException\r\n     * @throws NoSuchMethodException\r\n     * @throws InvocationTargetException\r\n     * @throws IllegalAccessException\r\n     * @throws IllegalArgumentException\r\n     */\r\n    protected ConsolePasswordReader() throws SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException {\r\n        // get the console by calling System.console() (Java6+ method)\r\n        Method consoleGetter = System.class.getMethod(\"console\", (Class[]) null);\r\n        console = consoleGetter.invoke(null, (Object[]) null);\r\n        // get Console.readPassword(String, Object[]) method\r\n        Class<?>[] paramTypes = new Class<?>[] { String.class, Object[].class };\r\n        readPassword = console.getClass().getMethod(\"readPassword\", paramTypes);\r\n    }\r\n\r\n    /**\r\n     * Attempt to use the previously resolved Console.\r\n     * If unable to use it then revert to the one implemented in the base class.\r\n     */\r\n    @Override\r\n    public char[] readPassword(String fmt, Object... args) {\r\n        try {\r\n            return (char[]) readPassword.invoke(console, fmt, args);\r\n        } catch (Throwable exc) {\r\n            return super.readPassword(fmt, args);\r\n        }\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/ConsolePasswordReaderTest.java",
		"test_prompt": "// ConsolePasswordReaderTest.java\npackage net.sourceforge.schemaspy.util;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ConsolePasswordReader}.\n* It contains ten unit test cases for the {@link ConsolePasswordReader#readPassword(String, Object[])} method.\n*/\nclass ConsolePasswordReaderTest {"
	},
	{
		"original_code": "// HtmlEncoder.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.util;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Simple (i.e. 'stupid') class that does a simple mapping between\n * HTML characters and their 'encoded' equivalents.\n *\n * @author John Currier\n */\npublic class HtmlEncoder {\n\n    private static final Map<String, String> map = new HashMap<String, String>();\n\n    static {\n        map.put(\"<\", \"&lt;\");\n        map.put(\">\", \"&gt;\");\n        map.put(\"\\n\", \"<br>\" + System.getProperty(\"line.separator\"));\n        map.put(\"\\r\", \"\");\n    }\n\n    private HtmlEncoder() {\n    }\n\n    /**\n     * Returns an HTML-encoded equivalent of the specified character.\n     *\n     * @param ch\n     * @return\n     */\n    public static String encodeToken(char ch) {\n        return encodeToken(String.valueOf(ch));\n    }\n\n    /**\n     * Returns an HTML-encoded equivalent of the specified tokenized string,\n     * where tokens such as '<', '>', '\\n' and '\\r' have been isolated from\n     * other tokens.\n     *\n     * @param str\n     * @return\n     */\n    public static String encodeToken(String str) {\n        String result = map.get(str);\n        return (result == null) ? str : result;\n    }\n\n    /**\n     * Returns an HTML-encoded version of the specified string\n     *\n     * @param str\n     * @return\n     */\n    public static String encodeString(String str) {\n        int len = str.length();\n        // x2 should limit # of reallocs\n        StringBuilder buf = new StringBuilder(len * 2);\n        for (int i = 0; i < len; i++) {\n            buf.append(encodeToken(str.charAt(i)));\n        }\n        return buf.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/HtmlEncoderTest0.java",
		"test_prompt": "// HtmlEncoderTest0.java\npackage net.sourceforge.schemaspy.util;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HtmlEncoder}.\n* It contains ten unit test cases for the {@link HtmlEncoder#encodeToken(char)} method.\n*/\nclass HtmlEncoderTest0 {"
	},
	{
		"original_code": "// HtmlEncoder.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.util;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Simple (i.e. 'stupid') class that does a simple mapping between\n * HTML characters and their 'encoded' equivalents.\n *\n * @author John Currier\n */\npublic class HtmlEncoder {\n\n    private static final Map<String, String> map = new HashMap<String, String>();\n\n    static {\n        map.put(\"<\", \"&lt;\");\n        map.put(\">\", \"&gt;\");\n        map.put(\"\\n\", \"<br>\" + System.getProperty(\"line.separator\"));\n        map.put(\"\\r\", \"\");\n    }\n\n    private HtmlEncoder() {\n    }\n\n    /**\n     * Returns an HTML-encoded equivalent of the specified character.\n     *\n     * @param ch\n     * @return\n     */\n    public static String encodeToken(char ch) {\n        return encodeToken(String.valueOf(ch));\n    }\n\n    /**\n     * Returns an HTML-encoded equivalent of the specified tokenized string,\n     * where tokens such as '<', '>', '\\n' and '\\r' have been isolated from\n     * other tokens.\n     *\n     * @param str\n     * @return\n     */\n    public static String encodeToken(String str) {\n        String result = map.get(str);\n        return (result == null) ? str : result;\n    }\n\n    /**\n     * Returns an HTML-encoded version of the specified string\n     *\n     * @param str\n     * @return\n     */\n    public static String encodeString(String str) {\n        int len = str.length();\n        // x2 should limit # of reallocs\n        StringBuilder buf = new StringBuilder(len * 2);\n        for (int i = 0; i < len; i++) {\n            buf.append(encodeToken(str.charAt(i)));\n        }\n        return buf.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/HtmlEncoderTest1.java",
		"test_prompt": "// HtmlEncoderTest1.java\npackage net.sourceforge.schemaspy.util;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HtmlEncoder}.\n* It contains ten unit test cases for the {@link HtmlEncoder#encodeToken(String)} method.\n*/\nclass HtmlEncoderTest1 {"
	},
	{
		"original_code": "// HtmlEncoder.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.util;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Simple (i.e. 'stupid') class that does a simple mapping between\n * HTML characters and their 'encoded' equivalents.\n *\n * @author John Currier\n */\npublic class HtmlEncoder {\n\n    private static final Map<String, String> map = new HashMap<String, String>();\n\n    static {\n        map.put(\"<\", \"&lt;\");\n        map.put(\">\", \"&gt;\");\n        map.put(\"\\n\", \"<br>\" + System.getProperty(\"line.separator\"));\n        map.put(\"\\r\", \"\");\n    }\n\n    private HtmlEncoder() {\n    }\n\n    /**\n     * Returns an HTML-encoded equivalent of the specified character.\n     *\n     * @param ch\n     * @return\n     */\n    public static String encodeToken(char ch) {\n        return encodeToken(String.valueOf(ch));\n    }\n\n    /**\n     * Returns an HTML-encoded equivalent of the specified tokenized string,\n     * where tokens such as '<', '>', '\\n' and '\\r' have been isolated from\n     * other tokens.\n     *\n     * @param str\n     * @return\n     */\n    public static String encodeToken(String str) {\n        String result = map.get(str);\n        return (result == null) ? str : result;\n    }\n\n    /**\n     * Returns an HTML-encoded version of the specified string\n     *\n     * @param str\n     * @return\n     */\n    public static String encodeString(String str) {\n        int len = str.length();\n        // x2 should limit # of reallocs\n        StringBuilder buf = new StringBuilder(len * 2);\n        for (int i = 0; i < len; i++) {\n            buf.append(encodeToken(str.charAt(i)));\n        }\n        return buf.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/HtmlEncoderTest2.java",
		"test_prompt": "// HtmlEncoderTest2.java\npackage net.sourceforge.schemaspy.util;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HtmlEncoder}.\n* It contains ten unit test cases for the {@link HtmlEncoder#encodeString(String)} method.\n*/\nclass HtmlEncoderTest2 {"
	},
	{
		"original_code": "// Dot.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.util;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\n\npublic class Dot {\n\n    private static Dot instance = new Dot();\n\n    private final Version version;\n\n    private final Version supportedVersion = new Version(\"2.2.1\");\n\n    private final Version badVersion = new Version(\"2.4\");\n\n    private final String lineSeparator = System.getProperty(\"line.separator\");\n\n    private String dotExe;\n\n    private String format = \"png\";\n\n    private String renderer;\n\n    private final Set<String> validatedRenderers = Collections.synchronizedSet(new HashSet<String>());\n\n    private final Set<String> invalidatedRenderers = Collections.synchronizedSet(new HashSet<String>());\n\n    private final Logger logger = Logger.getLogger(Dot.class.getName());\n\n    private Dot() {\n        String versionText = null;\n        // dot -V should return something similar to:\n        //  dot version 2.8 (Fri Feb  3 22:38:53 UTC 2006)\n        // or sometimes something like:\n        //  dot - Graphviz version 2.9.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)\n        String[] dotCommand = new String[] { getExe(), \"-V\" };\n        try {\n            Process process = Runtime.getRuntime().exec(dotCommand);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()));\n            String versionLine = reader.readLine();\n            logger.config(\"Version: \\\"\" + versionLine + \"\\\"\");\n            // look for a number followed numbers or dots\n            Matcher matcher = Pattern.compile(\"[0-9][0-9.]+\").matcher(versionLine);\n            if (matcher.find()) {\n                versionText = matcher.group();\n            } else {\n                if (Config.getInstance().isHtmlGenerationEnabled()) {\n                    System.err.println();\n                    logger.warning(\"Invalid dot configuration detected.  '\" + getDisplayableCommand(dotCommand) + \"' returned:\");\n                    logger.warning(\"   \" + versionLine);\n                }\n            }\n        } catch (Exception validDotDoesntExist) {\n            if (Config.getInstance().isHtmlGenerationEnabled()) {\n                System.err.println();\n                logger.warning(\"Failed to query Graphviz version information\");\n                logger.warning(\"  with: \" + getDisplayableCommand(dotCommand));\n                logger.warning(\"  \" + validDotDoesntExist);\n                logger.log(Level.INFO, \"Graphviz query failure details:\", validDotDoesntExist);\n            }\n        }\n        version = new Version(versionText);\n        validatedRenderers.add(\"\");\n    }\n\n    public static Dot getInstance() {\n        return instance;\n    }\n\n    public boolean exists() {\n        return version.toString() != null;\n    }\n\n    public Version getVersion() {\n        return version;\n    }\n\n    public boolean isValid() {\n        return exists() && (getVersion().equals(supportedVersion) || getVersion().compareTo(badVersion) > 0);\n    }\n\n    public String getSupportedVersions() {\n        return \"dot version \" + supportedVersion + \" or versions greater than \" + badVersion;\n    }\n\n    public boolean supportsCenteredEastWestEdges() {\n        return getVersion().compareTo(new Version(\"2.6\")) >= 0;\n    }\n\n    /**\n     * Set the image format to generate.  Defaults to <code>png</code>.\n     * See <a href='http://www.graphviz.org/doc/info/output.html'>http://www.graphviz.org/doc/info/output.html</a>\n     * for valid formats.\n     *\n     * @param format image format to generate\n     */\n    public void setFormat(String format) {\n        this.format = format;\n    }\n\n    /**\n     * @see #setFormat(String)\n     * @return\n     */\n    public String getFormat() {\n        return format;\n    }\n\n    /**\n     * Returns true if the installed dot requires specifying :gd as a renderer.\n     * This was added when Win 2.15 came out because it defaulted to Cairo, which produces\n     * better quality output, but at a significant speed and size penalty.<p>\n     *\n     * The intent of this property is to determine if it's ok to tack \":gd\" to\n     * the format specifier.  Earlier versions didn't require it and didn't know\n     * about the option.\n     *\n     * @return\n     */\n    public boolean requiresGdRenderer() {\n        return getVersion().compareTo(new Version(\"2.12\")) >= 0 && supportsRenderer(\":gd\");\n    }\n\n    /**\n     * Set the renderer to use for the -Tformat[:renderer[:formatter]] dot option as specified\n     * at <a href='http://www.graphviz.org/doc/info/command.html'>\n     * http://www.graphviz.org/doc/info/command.html</a> where \"format\" is specified by\n     * {@link #setFormat(String)}<p>\n     * Note that the leading \":\" is required while :formatter is optional.\n     *\n     * @param renderer\n     */\n    public void setRenderer(String renderer) {\n        if (isValid() && !supportsRenderer(renderer)) {\n            logger.info(\"renderer '\" + renderer + \"' is not supported by your version of dot\");\n        }\n        this.renderer = renderer;\n    }\n\n    /**\n     * @see #setRenderer(String)\n     * @return the renderer to use\n     */\n    public String getRenderer() {\n        if (renderer == null) {\n            setHighQuality(true);\n        }\n        return supportsRenderer(renderer) ? renderer : (requiresGdRenderer() ? \":gd\" : \"\");\n    }\n\n    /**\n     * If <code>true</code> then generate output of \"higher quality\".\n     * Note that the default is intended to be \"higher quality\",\n     * but various installations of Graphviz may have have different abilities.\n     * That is, some might not have the \"lower quality\" libraries and others might\n     * not have the \"higher quality\" libraries.\n     */\n    public void setHighQuality(boolean highQuality) {\n        if (highQuality && supportsRenderer(\":cairo\")) {\n            setRenderer(\":cairo\");\n        } else if (supportsRenderer(\":gd\")) {\n            setRenderer(\":gd\");\n        } else {\n            setRenderer(\"\");\n        }\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isHighQuality() {\n        return getRenderer().indexOf(\":cairo\") != -1;\n    }\n\n    /**\n     * Returns <code>true</code> if the specified renderer is supported.\n     * See {@link #setRenderer(String)} for renderer details.\n     *\n     * @param renderer\n     * @return\n     */\n    public boolean supportsRenderer(@SuppressWarnings(\"hiding\") String renderer) {\n        if (!exists())\n            return false;\n        if (validatedRenderers.contains(renderer))\n            return true;\n        if (invalidatedRenderers.contains(renderer))\n            return false;\n        try {\n            String[] dotCommand = new String[] { getExe(), \"-T\" + getFormat() + ':' };\n            Process process = Runtime.getRuntime().exec(dotCommand);\n            BufferedReader errors = new BufferedReader(new InputStreamReader(process.getErrorStream()));\n            String line;\n            while ((line = errors.readLine()) != null) {\n                if (line.contains(getFormat() + renderer)) {\n                    validatedRenderers.add(renderer);\n                }\n            }\n            process.waitFor();\n        } catch (Exception exc) {\n            exc.printStackTrace();\n        }\n        if (!validatedRenderers.contains(renderer)) {\n            logger.info(\"Failed to validate \" + getFormat() + \" renderer '\" + renderer + \"'.  Reverting to default renderer for \" + getFormat() + '.');\n            invalidatedRenderers.add(renderer);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns the executable to use to run dot\n     *\n     * @return\n     */\n    private String getExe() {\n        if (dotExe == null) {\n            File gv = Config.getInstance().getGraphvizDir();\n            if (gv == null) {\n                // default to finding dot in the PATH\n                dotExe = \"dot\";\n            } else {\n                // pull dot from the Graphviz bin directory specified\n                dotExe = new File(new File(gv, \"bin\"), \"dot\").toString();\n            }\n        }\n        return dotExe;\n    }\n\n    /**\n     * Using the specified .dot file generates an image returning the image's image map.\n     */\n    public String generateDiagram(File dotFile, File diagramFile) throws DotFailure {\n        StringBuilder mapBuffer = new StringBuilder(1024);\n        BufferedReader mapReader = null;\n        // this one is for executing.  it can (hopefully) deal with funky things in filenames.\n        String[] dotCommand = new String[] { getExe(), \"-T\" + getFormat() + getRenderer(), dotFile.toString(), \"-o\" + diagramFile, \"-Tcmapx\" };\n        // this one is for display purposes ONLY.\n        String commandLine = getDisplayableCommand(dotCommand);\n        logger.fine(commandLine);\n        try {\n            Process process = Runtime.getRuntime().exec(dotCommand);\n            new ProcessOutputReader(commandLine, process.getErrorStream()).start();\n            mapReader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = mapReader.readLine()) != null) {\n                mapBuffer.append(line);\n                mapBuffer.append(lineSeparator);\n            }\n            int rc = process.waitFor();\n            if (rc != 0)\n                throw new DotFailure(\"'\" + commandLine + \"' failed with return code \" + rc);\n            if (!diagramFile.exists())\n                throw new DotFailure(\"'\" + commandLine + \"' failed to create output file\");\n            // dot generates post-HTML 4.0.1 output...convert trailing />'s to >'s\n            return mapBuffer.toString().replace(\"/>\", \">\");\n        } catch (InterruptedException interrupted) {\n            throw new RuntimeException(interrupted);\n        } catch (DotFailure failed) {\n            diagramFile.delete();\n            throw failed;\n        } catch (IOException failed) {\n            diagramFile.delete();\n            throw new DotFailure(\"'\" + commandLine + \"' failed with exception \" + failed);\n        } finally {\n            if (mapReader != null) {\n                try {\n                    mapReader.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n\n    public class DotFailure extends IOException {\n\n        private static final long serialVersionUID = 3833743270181351987L;\n\n        public DotFailure(String msg) {\n            super(msg);\n        }\n    }\n\n    private static String getDisplayableCommand(String[] command) {\n        StringBuilder displayable = new StringBuilder();\n        for (int i = 0; i < command.length; ++i) {\n            displayable.append(command[i]);\n            if (i + 1 < command.length)\n                displayable.append(' ');\n        }\n        return displayable.toString();\n    }\n\n    private static class ProcessOutputReader extends Thread {\n\n        private final BufferedReader processReader;\n\n        private final String command;\n\n        ProcessOutputReader(String command, InputStream processStream) {\n            processReader = new BufferedReader(new InputStreamReader(processStream));\n            this.command = command;\n            setDaemon(true);\n        }\n\n        @Override\n        public void run() {\n            try {\n                String line;\n                while ((line = processReader.readLine()) != null) {\n                    // don't report port id unrecognized or unrecognized port\n                    if (line.indexOf(\"unrecognized\") == -1 && line.indexOf(\"port\") == -1)\n                        System.err.println(command + \": \" + line);\n                }\n            } catch (IOException ioException) {\n                ioException.printStackTrace();\n            } finally {\n                try {\n                    processReader.close();\n                } catch (Exception exc) {\n                    // shouldn't ever get here...but...\n                    exc.printStackTrace();\n                }\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/DotTest0.java",
		"test_prompt": "// DotTest0.java\npackage net.sourceforge.schemaspy.util;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Dot}.\n* It contains ten unit test cases for the {@link Dot#getInstance()} method.\n*/\nclass DotTest0 {"
	},
	{
		"original_code": "// Dot.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.util;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\n\npublic class Dot {\n\n    private static Dot instance = new Dot();\n\n    private final Version version;\n\n    private final Version supportedVersion = new Version(\"2.2.1\");\n\n    private final Version badVersion = new Version(\"2.4\");\n\n    private final String lineSeparator = System.getProperty(\"line.separator\");\n\n    private String dotExe;\n\n    private String format = \"png\";\n\n    private String renderer;\n\n    private final Set<String> validatedRenderers = Collections.synchronizedSet(new HashSet<String>());\n\n    private final Set<String> invalidatedRenderers = Collections.synchronizedSet(new HashSet<String>());\n\n    private final Logger logger = Logger.getLogger(Dot.class.getName());\n\n    private Dot() {\n        String versionText = null;\n        // dot -V should return something similar to:\n        //  dot version 2.8 (Fri Feb  3 22:38:53 UTC 2006)\n        // or sometimes something like:\n        //  dot - Graphviz version 2.9.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)\n        String[] dotCommand = new String[] { getExe(), \"-V\" };\n        try {\n            Process process = Runtime.getRuntime().exec(dotCommand);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()));\n            String versionLine = reader.readLine();\n            logger.config(\"Version: \\\"\" + versionLine + \"\\\"\");\n            // look for a number followed numbers or dots\n            Matcher matcher = Pattern.compile(\"[0-9][0-9.]+\").matcher(versionLine);\n            if (matcher.find()) {\n                versionText = matcher.group();\n            } else {\n                if (Config.getInstance().isHtmlGenerationEnabled()) {\n                    System.err.println();\n                    logger.warning(\"Invalid dot configuration detected.  '\" + getDisplayableCommand(dotCommand) + \"' returned:\");\n                    logger.warning(\"   \" + versionLine);\n                }\n            }\n        } catch (Exception validDotDoesntExist) {\n            if (Config.getInstance().isHtmlGenerationEnabled()) {\n                System.err.println();\n                logger.warning(\"Failed to query Graphviz version information\");\n                logger.warning(\"  with: \" + getDisplayableCommand(dotCommand));\n                logger.warning(\"  \" + validDotDoesntExist);\n                logger.log(Level.INFO, \"Graphviz query failure details:\", validDotDoesntExist);\n            }\n        }\n        version = new Version(versionText);\n        validatedRenderers.add(\"\");\n    }\n\n    public static Dot getInstance() {\n        return instance;\n    }\n\n    public boolean exists() {\n        return version.toString() != null;\n    }\n\n    public Version getVersion() {\n        return version;\n    }\n\n    public boolean isValid() {\n        return exists() && (getVersion().equals(supportedVersion) || getVersion().compareTo(badVersion) > 0);\n    }\n\n    public String getSupportedVersions() {\n        return \"dot version \" + supportedVersion + \" or versions greater than \" + badVersion;\n    }\n\n    public boolean supportsCenteredEastWestEdges() {\n        return getVersion().compareTo(new Version(\"2.6\")) >= 0;\n    }\n\n    /**\n     * Set the image format to generate.  Defaults to <code>png</code>.\n     * See <a href='http://www.graphviz.org/doc/info/output.html'>http://www.graphviz.org/doc/info/output.html</a>\n     * for valid formats.\n     *\n     * @param format image format to generate\n     */\n    public void setFormat(String format) {\n        this.format = format;\n    }\n\n    /**\n     * @see #setFormat(String)\n     * @return\n     */\n    public String getFormat() {\n        return format;\n    }\n\n    /**\n     * Returns true if the installed dot requires specifying :gd as a renderer.\n     * This was added when Win 2.15 came out because it defaulted to Cairo, which produces\n     * better quality output, but at a significant speed and size penalty.<p>\n     *\n     * The intent of this property is to determine if it's ok to tack \":gd\" to\n     * the format specifier.  Earlier versions didn't require it and didn't know\n     * about the option.\n     *\n     * @return\n     */\n    public boolean requiresGdRenderer() {\n        return getVersion().compareTo(new Version(\"2.12\")) >= 0 && supportsRenderer(\":gd\");\n    }\n\n    /**\n     * Set the renderer to use for the -Tformat[:renderer[:formatter]] dot option as specified\n     * at <a href='http://www.graphviz.org/doc/info/command.html'>\n     * http://www.graphviz.org/doc/info/command.html</a> where \"format\" is specified by\n     * {@link #setFormat(String)}<p>\n     * Note that the leading \":\" is required while :formatter is optional.\n     *\n     * @param renderer\n     */\n    public void setRenderer(String renderer) {\n        if (isValid() && !supportsRenderer(renderer)) {\n            logger.info(\"renderer '\" + renderer + \"' is not supported by your version of dot\");\n        }\n        this.renderer = renderer;\n    }\n\n    /**\n     * @see #setRenderer(String)\n     * @return the renderer to use\n     */\n    public String getRenderer() {\n        if (renderer == null) {\n            setHighQuality(true);\n        }\n        return supportsRenderer(renderer) ? renderer : (requiresGdRenderer() ? \":gd\" : \"\");\n    }\n\n    /**\n     * If <code>true</code> then generate output of \"higher quality\".\n     * Note that the default is intended to be \"higher quality\",\n     * but various installations of Graphviz may have have different abilities.\n     * That is, some might not have the \"lower quality\" libraries and others might\n     * not have the \"higher quality\" libraries.\n     */\n    public void setHighQuality(boolean highQuality) {\n        if (highQuality && supportsRenderer(\":cairo\")) {\n            setRenderer(\":cairo\");\n        } else if (supportsRenderer(\":gd\")) {\n            setRenderer(\":gd\");\n        } else {\n            setRenderer(\"\");\n        }\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isHighQuality() {\n        return getRenderer().indexOf(\":cairo\") != -1;\n    }\n\n    /**\n     * Returns <code>true</code> if the specified renderer is supported.\n     * See {@link #setRenderer(String)} for renderer details.\n     *\n     * @param renderer\n     * @return\n     */\n    public boolean supportsRenderer(@SuppressWarnings(\"hiding\") String renderer) {\n        if (!exists())\n            return false;\n        if (validatedRenderers.contains(renderer))\n            return true;\n        if (invalidatedRenderers.contains(renderer))\n            return false;\n        try {\n            String[] dotCommand = new String[] { getExe(), \"-T\" + getFormat() + ':' };\n            Process process = Runtime.getRuntime().exec(dotCommand);\n            BufferedReader errors = new BufferedReader(new InputStreamReader(process.getErrorStream()));\n            String line;\n            while ((line = errors.readLine()) != null) {\n                if (line.contains(getFormat() + renderer)) {\n                    validatedRenderers.add(renderer);\n                }\n            }\n            process.waitFor();\n        } catch (Exception exc) {\n            exc.printStackTrace();\n        }\n        if (!validatedRenderers.contains(renderer)) {\n            logger.info(\"Failed to validate \" + getFormat() + \" renderer '\" + renderer + \"'.  Reverting to default renderer for \" + getFormat() + '.');\n            invalidatedRenderers.add(renderer);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns the executable to use to run dot\n     *\n     * @return\n     */\n    private String getExe() {\n        if (dotExe == null) {\n            File gv = Config.getInstance().getGraphvizDir();\n            if (gv == null) {\n                // default to finding dot in the PATH\n                dotExe = \"dot\";\n            } else {\n                // pull dot from the Graphviz bin directory specified\n                dotExe = new File(new File(gv, \"bin\"), \"dot\").toString();\n            }\n        }\n        return dotExe;\n    }\n\n    /**\n     * Using the specified .dot file generates an image returning the image's image map.\n     */\n    public String generateDiagram(File dotFile, File diagramFile) throws DotFailure {\n        StringBuilder mapBuffer = new StringBuilder(1024);\n        BufferedReader mapReader = null;\n        // this one is for executing.  it can (hopefully) deal with funky things in filenames.\n        String[] dotCommand = new String[] { getExe(), \"-T\" + getFormat() + getRenderer(), dotFile.toString(), \"-o\" + diagramFile, \"-Tcmapx\" };\n        // this one is for display purposes ONLY.\n        String commandLine = getDisplayableCommand(dotCommand);\n        logger.fine(commandLine);\n        try {\n            Process process = Runtime.getRuntime().exec(dotCommand);\n            new ProcessOutputReader(commandLine, process.getErrorStream()).start();\n            mapReader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = mapReader.readLine()) != null) {\n                mapBuffer.append(line);\n                mapBuffer.append(lineSeparator);\n            }\n            int rc = process.waitFor();\n            if (rc != 0)\n                throw new DotFailure(\"'\" + commandLine + \"' failed with return code \" + rc);\n            if (!diagramFile.exists())\n                throw new DotFailure(\"'\" + commandLine + \"' failed to create output file\");\n            // dot generates post-HTML 4.0.1 output...convert trailing />'s to >'s\n            return mapBuffer.toString().replace(\"/>\", \">\");\n        } catch (InterruptedException interrupted) {\n            throw new RuntimeException(interrupted);\n        } catch (DotFailure failed) {\n            diagramFile.delete();\n            throw failed;\n        } catch (IOException failed) {\n            diagramFile.delete();\n            throw new DotFailure(\"'\" + commandLine + \"' failed with exception \" + failed);\n        } finally {\n            if (mapReader != null) {\n                try {\n                    mapReader.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n\n    public class DotFailure extends IOException {\n\n        private static final long serialVersionUID = 3833743270181351987L;\n\n        public DotFailure(String msg) {\n            super(msg);\n        }\n    }\n\n    private static String getDisplayableCommand(String[] command) {\n        StringBuilder displayable = new StringBuilder();\n        for (int i = 0; i < command.length; ++i) {\n            displayable.append(command[i]);\n            if (i + 1 < command.length)\n                displayable.append(' ');\n        }\n        return displayable.toString();\n    }\n\n    private static class ProcessOutputReader extends Thread {\n\n        private final BufferedReader processReader;\n\n        private final String command;\n\n        ProcessOutputReader(String command, InputStream processStream) {\n            processReader = new BufferedReader(new InputStreamReader(processStream));\n            this.command = command;\n            setDaemon(true);\n        }\n\n        @Override\n        public void run() {\n            try {\n                String line;\n                while ((line = processReader.readLine()) != null) {\n                    // don't report port id unrecognized or unrecognized port\n                    if (line.indexOf(\"unrecognized\") == -1 && line.indexOf(\"port\") == -1)\n                        System.err.println(command + \": \" + line);\n                }\n            } catch (IOException ioException) {\n                ioException.printStackTrace();\n            } finally {\n                try {\n                    processReader.close();\n                } catch (Exception exc) {\n                    // shouldn't ever get here...but...\n                    exc.printStackTrace();\n                }\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/DotTest1.java",
		"test_prompt": "// DotTest1.java\npackage net.sourceforge.schemaspy.util;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Dot}.\n* It contains ten unit test cases for the {@link Dot#exists()} method.\n*/\nclass DotTest1 {"
	},
	{
		"original_code": "// Dot.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.util;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\n\npublic class Dot {\n\n    private static Dot instance = new Dot();\n\n    private final Version version;\n\n    private final Version supportedVersion = new Version(\"2.2.1\");\n\n    private final Version badVersion = new Version(\"2.4\");\n\n    private final String lineSeparator = System.getProperty(\"line.separator\");\n\n    private String dotExe;\n\n    private String format = \"png\";\n\n    private String renderer;\n\n    private final Set<String> validatedRenderers = Collections.synchronizedSet(new HashSet<String>());\n\n    private final Set<String> invalidatedRenderers = Collections.synchronizedSet(new HashSet<String>());\n\n    private final Logger logger = Logger.getLogger(Dot.class.getName());\n\n    private Dot() {\n        String versionText = null;\n        // dot -V should return something similar to:\n        //  dot version 2.8 (Fri Feb  3 22:38:53 UTC 2006)\n        // or sometimes something like:\n        //  dot - Graphviz version 2.9.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)\n        String[] dotCommand = new String[] { getExe(), \"-V\" };\n        try {\n            Process process = Runtime.getRuntime().exec(dotCommand);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()));\n            String versionLine = reader.readLine();\n            logger.config(\"Version: \\\"\" + versionLine + \"\\\"\");\n            // look for a number followed numbers or dots\n            Matcher matcher = Pattern.compile(\"[0-9][0-9.]+\").matcher(versionLine);\n            if (matcher.find()) {\n                versionText = matcher.group();\n            } else {\n                if (Config.getInstance().isHtmlGenerationEnabled()) {\n                    System.err.println();\n                    logger.warning(\"Invalid dot configuration detected.  '\" + getDisplayableCommand(dotCommand) + \"' returned:\");\n                    logger.warning(\"   \" + versionLine);\n                }\n            }\n        } catch (Exception validDotDoesntExist) {\n            if (Config.getInstance().isHtmlGenerationEnabled()) {\n                System.err.println();\n                logger.warning(\"Failed to query Graphviz version information\");\n                logger.warning(\"  with: \" + getDisplayableCommand(dotCommand));\n                logger.warning(\"  \" + validDotDoesntExist);\n                logger.log(Level.INFO, \"Graphviz query failure details:\", validDotDoesntExist);\n            }\n        }\n        version = new Version(versionText);\n        validatedRenderers.add(\"\");\n    }\n\n    public static Dot getInstance() {\n        return instance;\n    }\n\n    public boolean exists() {\n        return version.toString() != null;\n    }\n\n    public Version getVersion() {\n        return version;\n    }\n\n    public boolean isValid() {\n        return exists() && (getVersion().equals(supportedVersion) || getVersion().compareTo(badVersion) > 0);\n    }\n\n    public String getSupportedVersions() {\n        return \"dot version \" + supportedVersion + \" or versions greater than \" + badVersion;\n    }\n\n    public boolean supportsCenteredEastWestEdges() {\n        return getVersion().compareTo(new Version(\"2.6\")) >= 0;\n    }\n\n    /**\n     * Set the image format to generate.  Defaults to <code>png</code>.\n     * See <a href='http://www.graphviz.org/doc/info/output.html'>http://www.graphviz.org/doc/info/output.html</a>\n     * for valid formats.\n     *\n     * @param format image format to generate\n     */\n    public void setFormat(String format) {\n        this.format = format;\n    }\n\n    /**\n     * @see #setFormat(String)\n     * @return\n     */\n    public String getFormat() {\n        return format;\n    }\n\n    /**\n     * Returns true if the installed dot requires specifying :gd as a renderer.\n     * This was added when Win 2.15 came out because it defaulted to Cairo, which produces\n     * better quality output, but at a significant speed and size penalty.<p>\n     *\n     * The intent of this property is to determine if it's ok to tack \":gd\" to\n     * the format specifier.  Earlier versions didn't require it and didn't know\n     * about the option.\n     *\n     * @return\n     */\n    public boolean requiresGdRenderer() {\n        return getVersion().compareTo(new Version(\"2.12\")) >= 0 && supportsRenderer(\":gd\");\n    }\n\n    /**\n     * Set the renderer to use for the -Tformat[:renderer[:formatter]] dot option as specified\n     * at <a href='http://www.graphviz.org/doc/info/command.html'>\n     * http://www.graphviz.org/doc/info/command.html</a> where \"format\" is specified by\n     * {@link #setFormat(String)}<p>\n     * Note that the leading \":\" is required while :formatter is optional.\n     *\n     * @param renderer\n     */\n    public void setRenderer(String renderer) {\n        if (isValid() && !supportsRenderer(renderer)) {\n            logger.info(\"renderer '\" + renderer + \"' is not supported by your version of dot\");\n        }\n        this.renderer = renderer;\n    }\n\n    /**\n     * @see #setRenderer(String)\n     * @return the renderer to use\n     */\n    public String getRenderer() {\n        if (renderer == null) {\n            setHighQuality(true);\n        }\n        return supportsRenderer(renderer) ? renderer : (requiresGdRenderer() ? \":gd\" : \"\");\n    }\n\n    /**\n     * If <code>true</code> then generate output of \"higher quality\".\n     * Note that the default is intended to be \"higher quality\",\n     * but various installations of Graphviz may have have different abilities.\n     * That is, some might not have the \"lower quality\" libraries and others might\n     * not have the \"higher quality\" libraries.\n     */\n    public void setHighQuality(boolean highQuality) {\n        if (highQuality && supportsRenderer(\":cairo\")) {\n            setRenderer(\":cairo\");\n        } else if (supportsRenderer(\":gd\")) {\n            setRenderer(\":gd\");\n        } else {\n            setRenderer(\"\");\n        }\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isHighQuality() {\n        return getRenderer().indexOf(\":cairo\") != -1;\n    }\n\n    /**\n     * Returns <code>true</code> if the specified renderer is supported.\n     * See {@link #setRenderer(String)} for renderer details.\n     *\n     * @param renderer\n     * @return\n     */\n    public boolean supportsRenderer(@SuppressWarnings(\"hiding\") String renderer) {\n        if (!exists())\n            return false;\n        if (validatedRenderers.contains(renderer))\n            return true;\n        if (invalidatedRenderers.contains(renderer))\n            return false;\n        try {\n            String[] dotCommand = new String[] { getExe(), \"-T\" + getFormat() + ':' };\n            Process process = Runtime.getRuntime().exec(dotCommand);\n            BufferedReader errors = new BufferedReader(new InputStreamReader(process.getErrorStream()));\n            String line;\n            while ((line = errors.readLine()) != null) {\n                if (line.contains(getFormat() + renderer)) {\n                    validatedRenderers.add(renderer);\n                }\n            }\n            process.waitFor();\n        } catch (Exception exc) {\n            exc.printStackTrace();\n        }\n        if (!validatedRenderers.contains(renderer)) {\n            logger.info(\"Failed to validate \" + getFormat() + \" renderer '\" + renderer + \"'.  Reverting to default renderer for \" + getFormat() + '.');\n            invalidatedRenderers.add(renderer);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns the executable to use to run dot\n     *\n     * @return\n     */\n    private String getExe() {\n        if (dotExe == null) {\n            File gv = Config.getInstance().getGraphvizDir();\n            if (gv == null) {\n                // default to finding dot in the PATH\n                dotExe = \"dot\";\n            } else {\n                // pull dot from the Graphviz bin directory specified\n                dotExe = new File(new File(gv, \"bin\"), \"dot\").toString();\n            }\n        }\n        return dotExe;\n    }\n\n    /**\n     * Using the specified .dot file generates an image returning the image's image map.\n     */\n    public String generateDiagram(File dotFile, File diagramFile) throws DotFailure {\n        StringBuilder mapBuffer = new StringBuilder(1024);\n        BufferedReader mapReader = null;\n        // this one is for executing.  it can (hopefully) deal with funky things in filenames.\n        String[] dotCommand = new String[] { getExe(), \"-T\" + getFormat() + getRenderer(), dotFile.toString(), \"-o\" + diagramFile, \"-Tcmapx\" };\n        // this one is for display purposes ONLY.\n        String commandLine = getDisplayableCommand(dotCommand);\n        logger.fine(commandLine);\n        try {\n            Process process = Runtime.getRuntime().exec(dotCommand);\n            new ProcessOutputReader(commandLine, process.getErrorStream()).start();\n            mapReader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = mapReader.readLine()) != null) {\n                mapBuffer.append(line);\n                mapBuffer.append(lineSeparator);\n            }\n            int rc = process.waitFor();\n            if (rc != 0)\n                throw new DotFailure(\"'\" + commandLine + \"' failed with return code \" + rc);\n            if (!diagramFile.exists())\n                throw new DotFailure(\"'\" + commandLine + \"' failed to create output file\");\n            // dot generates post-HTML 4.0.1 output...convert trailing />'s to >'s\n            return mapBuffer.toString().replace(\"/>\", \">\");\n        } catch (InterruptedException interrupted) {\n            throw new RuntimeException(interrupted);\n        } catch (DotFailure failed) {\n            diagramFile.delete();\n            throw failed;\n        } catch (IOException failed) {\n            diagramFile.delete();\n            throw new DotFailure(\"'\" + commandLine + \"' failed with exception \" + failed);\n        } finally {\n            if (mapReader != null) {\n                try {\n                    mapReader.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n\n    public class DotFailure extends IOException {\n\n        private static final long serialVersionUID = 3833743270181351987L;\n\n        public DotFailure(String msg) {\n            super(msg);\n        }\n    }\n\n    private static String getDisplayableCommand(String[] command) {\n        StringBuilder displayable = new StringBuilder();\n        for (int i = 0; i < command.length; ++i) {\n            displayable.append(command[i]);\n            if (i + 1 < command.length)\n                displayable.append(' ');\n        }\n        return displayable.toString();\n    }\n\n    private static class ProcessOutputReader extends Thread {\n\n        private final BufferedReader processReader;\n\n        private final String command;\n\n        ProcessOutputReader(String command, InputStream processStream) {\n            processReader = new BufferedReader(new InputStreamReader(processStream));\n            this.command = command;\n            setDaemon(true);\n        }\n\n        @Override\n        public void run() {\n            try {\n                String line;\n                while ((line = processReader.readLine()) != null) {\n                    // don't report port id unrecognized or unrecognized port\n                    if (line.indexOf(\"unrecognized\") == -1 && line.indexOf(\"port\") == -1)\n                        System.err.println(command + \": \" + line);\n                }\n            } catch (IOException ioException) {\n                ioException.printStackTrace();\n            } finally {\n                try {\n                    processReader.close();\n                } catch (Exception exc) {\n                    // shouldn't ever get here...but...\n                    exc.printStackTrace();\n                }\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/DotTest2.java",
		"test_prompt": "// DotTest2.java\npackage net.sourceforge.schemaspy.util;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Dot}.\n* It contains ten unit test cases for the {@link Dot#isValid()} method.\n*/\nclass DotTest2 {"
	},
	{
		"original_code": "// Dot.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.util;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\n\npublic class Dot {\n\n    private static Dot instance = new Dot();\n\n    private final Version version;\n\n    private final Version supportedVersion = new Version(\"2.2.1\");\n\n    private final Version badVersion = new Version(\"2.4\");\n\n    private final String lineSeparator = System.getProperty(\"line.separator\");\n\n    private String dotExe;\n\n    private String format = \"png\";\n\n    private String renderer;\n\n    private final Set<String> validatedRenderers = Collections.synchronizedSet(new HashSet<String>());\n\n    private final Set<String> invalidatedRenderers = Collections.synchronizedSet(new HashSet<String>());\n\n    private final Logger logger = Logger.getLogger(Dot.class.getName());\n\n    private Dot() {\n        String versionText = null;\n        // dot -V should return something similar to:\n        //  dot version 2.8 (Fri Feb  3 22:38:53 UTC 2006)\n        // or sometimes something like:\n        //  dot - Graphviz version 2.9.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)\n        String[] dotCommand = new String[] { getExe(), \"-V\" };\n        try {\n            Process process = Runtime.getRuntime().exec(dotCommand);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()));\n            String versionLine = reader.readLine();\n            logger.config(\"Version: \\\"\" + versionLine + \"\\\"\");\n            // look for a number followed numbers or dots\n            Matcher matcher = Pattern.compile(\"[0-9][0-9.]+\").matcher(versionLine);\n            if (matcher.find()) {\n                versionText = matcher.group();\n            } else {\n                if (Config.getInstance().isHtmlGenerationEnabled()) {\n                    System.err.println();\n                    logger.warning(\"Invalid dot configuration detected.  '\" + getDisplayableCommand(dotCommand) + \"' returned:\");\n                    logger.warning(\"   \" + versionLine);\n                }\n            }\n        } catch (Exception validDotDoesntExist) {\n            if (Config.getInstance().isHtmlGenerationEnabled()) {\n                System.err.println();\n                logger.warning(\"Failed to query Graphviz version information\");\n                logger.warning(\"  with: \" + getDisplayableCommand(dotCommand));\n                logger.warning(\"  \" + validDotDoesntExist);\n                logger.log(Level.INFO, \"Graphviz query failure details:\", validDotDoesntExist);\n            }\n        }\n        version = new Version(versionText);\n        validatedRenderers.add(\"\");\n    }\n\n    public static Dot getInstance() {\n        return instance;\n    }\n\n    public boolean exists() {\n        return version.toString() != null;\n    }\n\n    public Version getVersion() {\n        return version;\n    }\n\n    public boolean isValid() {\n        return exists() && (getVersion().equals(supportedVersion) || getVersion().compareTo(badVersion) > 0);\n    }\n\n    public String getSupportedVersions() {\n        return \"dot version \" + supportedVersion + \" or versions greater than \" + badVersion;\n    }\n\n    public boolean supportsCenteredEastWestEdges() {\n        return getVersion().compareTo(new Version(\"2.6\")) >= 0;\n    }\n\n    /**\n     * Set the image format to generate.  Defaults to <code>png</code>.\n     * See <a href='http://www.graphviz.org/doc/info/output.html'>http://www.graphviz.org/doc/info/output.html</a>\n     * for valid formats.\n     *\n     * @param format image format to generate\n     */\n    public void setFormat(String format) {\n        this.format = format;\n    }\n\n    /**\n     * @see #setFormat(String)\n     * @return\n     */\n    public String getFormat() {\n        return format;\n    }\n\n    /**\n     * Returns true if the installed dot requires specifying :gd as a renderer.\n     * This was added when Win 2.15 came out because it defaulted to Cairo, which produces\n     * better quality output, but at a significant speed and size penalty.<p>\n     *\n     * The intent of this property is to determine if it's ok to tack \":gd\" to\n     * the format specifier.  Earlier versions didn't require it and didn't know\n     * about the option.\n     *\n     * @return\n     */\n    public boolean requiresGdRenderer() {\n        return getVersion().compareTo(new Version(\"2.12\")) >= 0 && supportsRenderer(\":gd\");\n    }\n\n    /**\n     * Set the renderer to use for the -Tformat[:renderer[:formatter]] dot option as specified\n     * at <a href='http://www.graphviz.org/doc/info/command.html'>\n     * http://www.graphviz.org/doc/info/command.html</a> where \"format\" is specified by\n     * {@link #setFormat(String)}<p>\n     * Note that the leading \":\" is required while :formatter is optional.\n     *\n     * @param renderer\n     */\n    public void setRenderer(String renderer) {\n        if (isValid() && !supportsRenderer(renderer)) {\n            logger.info(\"renderer '\" + renderer + \"' is not supported by your version of dot\");\n        }\n        this.renderer = renderer;\n    }\n\n    /**\n     * @see #setRenderer(String)\n     * @return the renderer to use\n     */\n    public String getRenderer() {\n        if (renderer == null) {\n            setHighQuality(true);\n        }\n        return supportsRenderer(renderer) ? renderer : (requiresGdRenderer() ? \":gd\" : \"\");\n    }\n\n    /**\n     * If <code>true</code> then generate output of \"higher quality\".\n     * Note that the default is intended to be \"higher quality\",\n     * but various installations of Graphviz may have have different abilities.\n     * That is, some might not have the \"lower quality\" libraries and others might\n     * not have the \"higher quality\" libraries.\n     */\n    public void setHighQuality(boolean highQuality) {\n        if (highQuality && supportsRenderer(\":cairo\")) {\n            setRenderer(\":cairo\");\n        } else if (supportsRenderer(\":gd\")) {\n            setRenderer(\":gd\");\n        } else {\n            setRenderer(\"\");\n        }\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isHighQuality() {\n        return getRenderer().indexOf(\":cairo\") != -1;\n    }\n\n    /**\n     * Returns <code>true</code> if the specified renderer is supported.\n     * See {@link #setRenderer(String)} for renderer details.\n     *\n     * @param renderer\n     * @return\n     */\n    public boolean supportsRenderer(@SuppressWarnings(\"hiding\") String renderer) {\n        if (!exists())\n            return false;\n        if (validatedRenderers.contains(renderer))\n            return true;\n        if (invalidatedRenderers.contains(renderer))\n            return false;\n        try {\n            String[] dotCommand = new String[] { getExe(), \"-T\" + getFormat() + ':' };\n            Process process = Runtime.getRuntime().exec(dotCommand);\n            BufferedReader errors = new BufferedReader(new InputStreamReader(process.getErrorStream()));\n            String line;\n            while ((line = errors.readLine()) != null) {\n                if (line.contains(getFormat() + renderer)) {\n                    validatedRenderers.add(renderer);\n                }\n            }\n            process.waitFor();\n        } catch (Exception exc) {\n            exc.printStackTrace();\n        }\n        if (!validatedRenderers.contains(renderer)) {\n            logger.info(\"Failed to validate \" + getFormat() + \" renderer '\" + renderer + \"'.  Reverting to default renderer for \" + getFormat() + '.');\n            invalidatedRenderers.add(renderer);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns the executable to use to run dot\n     *\n     * @return\n     */\n    private String getExe() {\n        if (dotExe == null) {\n            File gv = Config.getInstance().getGraphvizDir();\n            if (gv == null) {\n                // default to finding dot in the PATH\n                dotExe = \"dot\";\n            } else {\n                // pull dot from the Graphviz bin directory specified\n                dotExe = new File(new File(gv, \"bin\"), \"dot\").toString();\n            }\n        }\n        return dotExe;\n    }\n\n    /**\n     * Using the specified .dot file generates an image returning the image's image map.\n     */\n    public String generateDiagram(File dotFile, File diagramFile) throws DotFailure {\n        StringBuilder mapBuffer = new StringBuilder(1024);\n        BufferedReader mapReader = null;\n        // this one is for executing.  it can (hopefully) deal with funky things in filenames.\n        String[] dotCommand = new String[] { getExe(), \"-T\" + getFormat() + getRenderer(), dotFile.toString(), \"-o\" + diagramFile, \"-Tcmapx\" };\n        // this one is for display purposes ONLY.\n        String commandLine = getDisplayableCommand(dotCommand);\n        logger.fine(commandLine);\n        try {\n            Process process = Runtime.getRuntime().exec(dotCommand);\n            new ProcessOutputReader(commandLine, process.getErrorStream()).start();\n            mapReader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = mapReader.readLine()) != null) {\n                mapBuffer.append(line);\n                mapBuffer.append(lineSeparator);\n            }\n            int rc = process.waitFor();\n            if (rc != 0)\n                throw new DotFailure(\"'\" + commandLine + \"' failed with return code \" + rc);\n            if (!diagramFile.exists())\n                throw new DotFailure(\"'\" + commandLine + \"' failed to create output file\");\n            // dot generates post-HTML 4.0.1 output...convert trailing />'s to >'s\n            return mapBuffer.toString().replace(\"/>\", \">\");\n        } catch (InterruptedException interrupted) {\n            throw new RuntimeException(interrupted);\n        } catch (DotFailure failed) {\n            diagramFile.delete();\n            throw failed;\n        } catch (IOException failed) {\n            diagramFile.delete();\n            throw new DotFailure(\"'\" + commandLine + \"' failed with exception \" + failed);\n        } finally {\n            if (mapReader != null) {\n                try {\n                    mapReader.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n\n    public class DotFailure extends IOException {\n\n        private static final long serialVersionUID = 3833743270181351987L;\n\n        public DotFailure(String msg) {\n            super(msg);\n        }\n    }\n\n    private static String getDisplayableCommand(String[] command) {\n        StringBuilder displayable = new StringBuilder();\n        for (int i = 0; i < command.length; ++i) {\n            displayable.append(command[i]);\n            if (i + 1 < command.length)\n                displayable.append(' ');\n        }\n        return displayable.toString();\n    }\n\n    private static class ProcessOutputReader extends Thread {\n\n        private final BufferedReader processReader;\n\n        private final String command;\n\n        ProcessOutputReader(String command, InputStream processStream) {\n            processReader = new BufferedReader(new InputStreamReader(processStream));\n            this.command = command;\n            setDaemon(true);\n        }\n\n        @Override\n        public void run() {\n            try {\n                String line;\n                while ((line = processReader.readLine()) != null) {\n                    // don't report port id unrecognized or unrecognized port\n                    if (line.indexOf(\"unrecognized\") == -1 && line.indexOf(\"port\") == -1)\n                        System.err.println(command + \": \" + line);\n                }\n            } catch (IOException ioException) {\n                ioException.printStackTrace();\n            } finally {\n                try {\n                    processReader.close();\n                } catch (Exception exc) {\n                    // shouldn't ever get here...but...\n                    exc.printStackTrace();\n                }\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/DotTest3.java",
		"test_prompt": "// DotTest3.java\npackage net.sourceforge.schemaspy.util;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Dot}.\n* It contains ten unit test cases for the {@link Dot#supportsCenteredEastWestEdges()} method.\n*/\nclass DotTest3 {"
	},
	{
		"original_code": "// Dot.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.util;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\n\npublic class Dot {\n\n    private static Dot instance = new Dot();\n\n    private final Version version;\n\n    private final Version supportedVersion = new Version(\"2.2.1\");\n\n    private final Version badVersion = new Version(\"2.4\");\n\n    private final String lineSeparator = System.getProperty(\"line.separator\");\n\n    private String dotExe;\n\n    private String format = \"png\";\n\n    private String renderer;\n\n    private final Set<String> validatedRenderers = Collections.synchronizedSet(new HashSet<String>());\n\n    private final Set<String> invalidatedRenderers = Collections.synchronizedSet(new HashSet<String>());\n\n    private final Logger logger = Logger.getLogger(Dot.class.getName());\n\n    private Dot() {\n        String versionText = null;\n        // dot -V should return something similar to:\n        //  dot version 2.8 (Fri Feb  3 22:38:53 UTC 2006)\n        // or sometimes something like:\n        //  dot - Graphviz version 2.9.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)\n        String[] dotCommand = new String[] { getExe(), \"-V\" };\n        try {\n            Process process = Runtime.getRuntime().exec(dotCommand);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()));\n            String versionLine = reader.readLine();\n            logger.config(\"Version: \\\"\" + versionLine + \"\\\"\");\n            // look for a number followed numbers or dots\n            Matcher matcher = Pattern.compile(\"[0-9][0-9.]+\").matcher(versionLine);\n            if (matcher.find()) {\n                versionText = matcher.group();\n            } else {\n                if (Config.getInstance().isHtmlGenerationEnabled()) {\n                    System.err.println();\n                    logger.warning(\"Invalid dot configuration detected.  '\" + getDisplayableCommand(dotCommand) + \"' returned:\");\n                    logger.warning(\"   \" + versionLine);\n                }\n            }\n        } catch (Exception validDotDoesntExist) {\n            if (Config.getInstance().isHtmlGenerationEnabled()) {\n                System.err.println();\n                logger.warning(\"Failed to query Graphviz version information\");\n                logger.warning(\"  with: \" + getDisplayableCommand(dotCommand));\n                logger.warning(\"  \" + validDotDoesntExist);\n                logger.log(Level.INFO, \"Graphviz query failure details:\", validDotDoesntExist);\n            }\n        }\n        version = new Version(versionText);\n        validatedRenderers.add(\"\");\n    }\n\n    public static Dot getInstance() {\n        return instance;\n    }\n\n    public boolean exists() {\n        return version.toString() != null;\n    }\n\n    public Version getVersion() {\n        return version;\n    }\n\n    public boolean isValid() {\n        return exists() && (getVersion().equals(supportedVersion) || getVersion().compareTo(badVersion) > 0);\n    }\n\n    public String getSupportedVersions() {\n        return \"dot version \" + supportedVersion + \" or versions greater than \" + badVersion;\n    }\n\n    public boolean supportsCenteredEastWestEdges() {\n        return getVersion().compareTo(new Version(\"2.6\")) >= 0;\n    }\n\n    /**\n     * Set the image format to generate.  Defaults to <code>png</code>.\n     * See <a href='http://www.graphviz.org/doc/info/output.html'>http://www.graphviz.org/doc/info/output.html</a>\n     * for valid formats.\n     *\n     * @param format image format to generate\n     */\n    public void setFormat(String format) {\n        this.format = format;\n    }\n\n    /**\n     * @see #setFormat(String)\n     * @return\n     */\n    public String getFormat() {\n        return format;\n    }\n\n    /**\n     * Returns true if the installed dot requires specifying :gd as a renderer.\n     * This was added when Win 2.15 came out because it defaulted to Cairo, which produces\n     * better quality output, but at a significant speed and size penalty.<p>\n     *\n     * The intent of this property is to determine if it's ok to tack \":gd\" to\n     * the format specifier.  Earlier versions didn't require it and didn't know\n     * about the option.\n     *\n     * @return\n     */\n    public boolean requiresGdRenderer() {\n        return getVersion().compareTo(new Version(\"2.12\")) >= 0 && supportsRenderer(\":gd\");\n    }\n\n    /**\n     * Set the renderer to use for the -Tformat[:renderer[:formatter]] dot option as specified\n     * at <a href='http://www.graphviz.org/doc/info/command.html'>\n     * http://www.graphviz.org/doc/info/command.html</a> where \"format\" is specified by\n     * {@link #setFormat(String)}<p>\n     * Note that the leading \":\" is required while :formatter is optional.\n     *\n     * @param renderer\n     */\n    public void setRenderer(String renderer) {\n        if (isValid() && !supportsRenderer(renderer)) {\n            logger.info(\"renderer '\" + renderer + \"' is not supported by your version of dot\");\n        }\n        this.renderer = renderer;\n    }\n\n    /**\n     * @see #setRenderer(String)\n     * @return the renderer to use\n     */\n    public String getRenderer() {\n        if (renderer == null) {\n            setHighQuality(true);\n        }\n        return supportsRenderer(renderer) ? renderer : (requiresGdRenderer() ? \":gd\" : \"\");\n    }\n\n    /**\n     * If <code>true</code> then generate output of \"higher quality\".\n     * Note that the default is intended to be \"higher quality\",\n     * but various installations of Graphviz may have have different abilities.\n     * That is, some might not have the \"lower quality\" libraries and others might\n     * not have the \"higher quality\" libraries.\n     */\n    public void setHighQuality(boolean highQuality) {\n        if (highQuality && supportsRenderer(\":cairo\")) {\n            setRenderer(\":cairo\");\n        } else if (supportsRenderer(\":gd\")) {\n            setRenderer(\":gd\");\n        } else {\n            setRenderer(\"\");\n        }\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isHighQuality() {\n        return getRenderer().indexOf(\":cairo\") != -1;\n    }\n\n    /**\n     * Returns <code>true</code> if the specified renderer is supported.\n     * See {@link #setRenderer(String)} for renderer details.\n     *\n     * @param renderer\n     * @return\n     */\n    public boolean supportsRenderer(@SuppressWarnings(\"hiding\") String renderer) {\n        if (!exists())\n            return false;\n        if (validatedRenderers.contains(renderer))\n            return true;\n        if (invalidatedRenderers.contains(renderer))\n            return false;\n        try {\n            String[] dotCommand = new String[] { getExe(), \"-T\" + getFormat() + ':' };\n            Process process = Runtime.getRuntime().exec(dotCommand);\n            BufferedReader errors = new BufferedReader(new InputStreamReader(process.getErrorStream()));\n            String line;\n            while ((line = errors.readLine()) != null) {\n                if (line.contains(getFormat() + renderer)) {\n                    validatedRenderers.add(renderer);\n                }\n            }\n            process.waitFor();\n        } catch (Exception exc) {\n            exc.printStackTrace();\n        }\n        if (!validatedRenderers.contains(renderer)) {\n            logger.info(\"Failed to validate \" + getFormat() + \" renderer '\" + renderer + \"'.  Reverting to default renderer for \" + getFormat() + '.');\n            invalidatedRenderers.add(renderer);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns the executable to use to run dot\n     *\n     * @return\n     */\n    private String getExe() {\n        if (dotExe == null) {\n            File gv = Config.getInstance().getGraphvizDir();\n            if (gv == null) {\n                // default to finding dot in the PATH\n                dotExe = \"dot\";\n            } else {\n                // pull dot from the Graphviz bin directory specified\n                dotExe = new File(new File(gv, \"bin\"), \"dot\").toString();\n            }\n        }\n        return dotExe;\n    }\n\n    /**\n     * Using the specified .dot file generates an image returning the image's image map.\n     */\n    public String generateDiagram(File dotFile, File diagramFile) throws DotFailure {\n        StringBuilder mapBuffer = new StringBuilder(1024);\n        BufferedReader mapReader = null;\n        // this one is for executing.  it can (hopefully) deal with funky things in filenames.\n        String[] dotCommand = new String[] { getExe(), \"-T\" + getFormat() + getRenderer(), dotFile.toString(), \"-o\" + diagramFile, \"-Tcmapx\" };\n        // this one is for display purposes ONLY.\n        String commandLine = getDisplayableCommand(dotCommand);\n        logger.fine(commandLine);\n        try {\n            Process process = Runtime.getRuntime().exec(dotCommand);\n            new ProcessOutputReader(commandLine, process.getErrorStream()).start();\n            mapReader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = mapReader.readLine()) != null) {\n                mapBuffer.append(line);\n                mapBuffer.append(lineSeparator);\n            }\n            int rc = process.waitFor();\n            if (rc != 0)\n                throw new DotFailure(\"'\" + commandLine + \"' failed with return code \" + rc);\n            if (!diagramFile.exists())\n                throw new DotFailure(\"'\" + commandLine + \"' failed to create output file\");\n            // dot generates post-HTML 4.0.1 output...convert trailing />'s to >'s\n            return mapBuffer.toString().replace(\"/>\", \">\");\n        } catch (InterruptedException interrupted) {\n            throw new RuntimeException(interrupted);\n        } catch (DotFailure failed) {\n            diagramFile.delete();\n            throw failed;\n        } catch (IOException failed) {\n            diagramFile.delete();\n            throw new DotFailure(\"'\" + commandLine + \"' failed with exception \" + failed);\n        } finally {\n            if (mapReader != null) {\n                try {\n                    mapReader.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n\n    public class DotFailure extends IOException {\n\n        private static final long serialVersionUID = 3833743270181351987L;\n\n        public DotFailure(String msg) {\n            super(msg);\n        }\n    }\n\n    private static String getDisplayableCommand(String[] command) {\n        StringBuilder displayable = new StringBuilder();\n        for (int i = 0; i < command.length; ++i) {\n            displayable.append(command[i]);\n            if (i + 1 < command.length)\n                displayable.append(' ');\n        }\n        return displayable.toString();\n    }\n\n    private static class ProcessOutputReader extends Thread {\n\n        private final BufferedReader processReader;\n\n        private final String command;\n\n        ProcessOutputReader(String command, InputStream processStream) {\n            processReader = new BufferedReader(new InputStreamReader(processStream));\n            this.command = command;\n            setDaemon(true);\n        }\n\n        @Override\n        public void run() {\n            try {\n                String line;\n                while ((line = processReader.readLine()) != null) {\n                    // don't report port id unrecognized or unrecognized port\n                    if (line.indexOf(\"unrecognized\") == -1 && line.indexOf(\"port\") == -1)\n                        System.err.println(command + \": \" + line);\n                }\n            } catch (IOException ioException) {\n                ioException.printStackTrace();\n            } finally {\n                try {\n                    processReader.close();\n                } catch (Exception exc) {\n                    // shouldn't ever get here...but...\n                    exc.printStackTrace();\n                }\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/DotTest4.java",
		"test_prompt": "// DotTest4.java\npackage net.sourceforge.schemaspy.util;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Dot}.\n* It contains ten unit test cases for the {@link Dot#requiresGdRenderer()} method.\n*/\nclass DotTest4 {"
	},
	{
		"original_code": "// Dot.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.util;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\n\npublic class Dot {\n\n    private static Dot instance = new Dot();\n\n    private final Version version;\n\n    private final Version supportedVersion = new Version(\"2.2.1\");\n\n    private final Version badVersion = new Version(\"2.4\");\n\n    private final String lineSeparator = System.getProperty(\"line.separator\");\n\n    private String dotExe;\n\n    private String format = \"png\";\n\n    private String renderer;\n\n    private final Set<String> validatedRenderers = Collections.synchronizedSet(new HashSet<String>());\n\n    private final Set<String> invalidatedRenderers = Collections.synchronizedSet(new HashSet<String>());\n\n    private final Logger logger = Logger.getLogger(Dot.class.getName());\n\n    private Dot() {\n        String versionText = null;\n        // dot -V should return something similar to:\n        //  dot version 2.8 (Fri Feb  3 22:38:53 UTC 2006)\n        // or sometimes something like:\n        //  dot - Graphviz version 2.9.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)\n        String[] dotCommand = new String[] { getExe(), \"-V\" };\n        try {\n            Process process = Runtime.getRuntime().exec(dotCommand);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()));\n            String versionLine = reader.readLine();\n            logger.config(\"Version: \\\"\" + versionLine + \"\\\"\");\n            // look for a number followed numbers or dots\n            Matcher matcher = Pattern.compile(\"[0-9][0-9.]+\").matcher(versionLine);\n            if (matcher.find()) {\n                versionText = matcher.group();\n            } else {\n                if (Config.getInstance().isHtmlGenerationEnabled()) {\n                    System.err.println();\n                    logger.warning(\"Invalid dot configuration detected.  '\" + getDisplayableCommand(dotCommand) + \"' returned:\");\n                    logger.warning(\"   \" + versionLine);\n                }\n            }\n        } catch (Exception validDotDoesntExist) {\n            if (Config.getInstance().isHtmlGenerationEnabled()) {\n                System.err.println();\n                logger.warning(\"Failed to query Graphviz version information\");\n                logger.warning(\"  with: \" + getDisplayableCommand(dotCommand));\n                logger.warning(\"  \" + validDotDoesntExist);\n                logger.log(Level.INFO, \"Graphviz query failure details:\", validDotDoesntExist);\n            }\n        }\n        version = new Version(versionText);\n        validatedRenderers.add(\"\");\n    }\n\n    public static Dot getInstance() {\n        return instance;\n    }\n\n    public boolean exists() {\n        return version.toString() != null;\n    }\n\n    public Version getVersion() {\n        return version;\n    }\n\n    public boolean isValid() {\n        return exists() && (getVersion().equals(supportedVersion) || getVersion().compareTo(badVersion) > 0);\n    }\n\n    public String getSupportedVersions() {\n        return \"dot version \" + supportedVersion + \" or versions greater than \" + badVersion;\n    }\n\n    public boolean supportsCenteredEastWestEdges() {\n        return getVersion().compareTo(new Version(\"2.6\")) >= 0;\n    }\n\n    /**\n     * Set the image format to generate.  Defaults to <code>png</code>.\n     * See <a href='http://www.graphviz.org/doc/info/output.html'>http://www.graphviz.org/doc/info/output.html</a>\n     * for valid formats.\n     *\n     * @param format image format to generate\n     */\n    public void setFormat(String format) {\n        this.format = format;\n    }\n\n    /**\n     * @see #setFormat(String)\n     * @return\n     */\n    public String getFormat() {\n        return format;\n    }\n\n    /**\n     * Returns true if the installed dot requires specifying :gd as a renderer.\n     * This was added when Win 2.15 came out because it defaulted to Cairo, which produces\n     * better quality output, but at a significant speed and size penalty.<p>\n     *\n     * The intent of this property is to determine if it's ok to tack \":gd\" to\n     * the format specifier.  Earlier versions didn't require it and didn't know\n     * about the option.\n     *\n     * @return\n     */\n    public boolean requiresGdRenderer() {\n        return getVersion().compareTo(new Version(\"2.12\")) >= 0 && supportsRenderer(\":gd\");\n    }\n\n    /**\n     * Set the renderer to use for the -Tformat[:renderer[:formatter]] dot option as specified\n     * at <a href='http://www.graphviz.org/doc/info/command.html'>\n     * http://www.graphviz.org/doc/info/command.html</a> where \"format\" is specified by\n     * {@link #setFormat(String)}<p>\n     * Note that the leading \":\" is required while :formatter is optional.\n     *\n     * @param renderer\n     */\n    public void setRenderer(String renderer) {\n        if (isValid() && !supportsRenderer(renderer)) {\n            logger.info(\"renderer '\" + renderer + \"' is not supported by your version of dot\");\n        }\n        this.renderer = renderer;\n    }\n\n    /**\n     * @see #setRenderer(String)\n     * @return the renderer to use\n     */\n    public String getRenderer() {\n        if (renderer == null) {\n            setHighQuality(true);\n        }\n        return supportsRenderer(renderer) ? renderer : (requiresGdRenderer() ? \":gd\" : \"\");\n    }\n\n    /**\n     * If <code>true</code> then generate output of \"higher quality\".\n     * Note that the default is intended to be \"higher quality\",\n     * but various installations of Graphviz may have have different abilities.\n     * That is, some might not have the \"lower quality\" libraries and others might\n     * not have the \"higher quality\" libraries.\n     */\n    public void setHighQuality(boolean highQuality) {\n        if (highQuality && supportsRenderer(\":cairo\")) {\n            setRenderer(\":cairo\");\n        } else if (supportsRenderer(\":gd\")) {\n            setRenderer(\":gd\");\n        } else {\n            setRenderer(\"\");\n        }\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isHighQuality() {\n        return getRenderer().indexOf(\":cairo\") != -1;\n    }\n\n    /**\n     * Returns <code>true</code> if the specified renderer is supported.\n     * See {@link #setRenderer(String)} for renderer details.\n     *\n     * @param renderer\n     * @return\n     */\n    public boolean supportsRenderer(@SuppressWarnings(\"hiding\") String renderer) {\n        if (!exists())\n            return false;\n        if (validatedRenderers.contains(renderer))\n            return true;\n        if (invalidatedRenderers.contains(renderer))\n            return false;\n        try {\n            String[] dotCommand = new String[] { getExe(), \"-T\" + getFormat() + ':' };\n            Process process = Runtime.getRuntime().exec(dotCommand);\n            BufferedReader errors = new BufferedReader(new InputStreamReader(process.getErrorStream()));\n            String line;\n            while ((line = errors.readLine()) != null) {\n                if (line.contains(getFormat() + renderer)) {\n                    validatedRenderers.add(renderer);\n                }\n            }\n            process.waitFor();\n        } catch (Exception exc) {\n            exc.printStackTrace();\n        }\n        if (!validatedRenderers.contains(renderer)) {\n            logger.info(\"Failed to validate \" + getFormat() + \" renderer '\" + renderer + \"'.  Reverting to default renderer for \" + getFormat() + '.');\n            invalidatedRenderers.add(renderer);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns the executable to use to run dot\n     *\n     * @return\n     */\n    private String getExe() {\n        if (dotExe == null) {\n            File gv = Config.getInstance().getGraphvizDir();\n            if (gv == null) {\n                // default to finding dot in the PATH\n                dotExe = \"dot\";\n            } else {\n                // pull dot from the Graphviz bin directory specified\n                dotExe = new File(new File(gv, \"bin\"), \"dot\").toString();\n            }\n        }\n        return dotExe;\n    }\n\n    /**\n     * Using the specified .dot file generates an image returning the image's image map.\n     */\n    public String generateDiagram(File dotFile, File diagramFile) throws DotFailure {\n        StringBuilder mapBuffer = new StringBuilder(1024);\n        BufferedReader mapReader = null;\n        // this one is for executing.  it can (hopefully) deal with funky things in filenames.\n        String[] dotCommand = new String[] { getExe(), \"-T\" + getFormat() + getRenderer(), dotFile.toString(), \"-o\" + diagramFile, \"-Tcmapx\" };\n        // this one is for display purposes ONLY.\n        String commandLine = getDisplayableCommand(dotCommand);\n        logger.fine(commandLine);\n        try {\n            Process process = Runtime.getRuntime().exec(dotCommand);\n            new ProcessOutputReader(commandLine, process.getErrorStream()).start();\n            mapReader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = mapReader.readLine()) != null) {\n                mapBuffer.append(line);\n                mapBuffer.append(lineSeparator);\n            }\n            int rc = process.waitFor();\n            if (rc != 0)\n                throw new DotFailure(\"'\" + commandLine + \"' failed with return code \" + rc);\n            if (!diagramFile.exists())\n                throw new DotFailure(\"'\" + commandLine + \"' failed to create output file\");\n            // dot generates post-HTML 4.0.1 output...convert trailing />'s to >'s\n            return mapBuffer.toString().replace(\"/>\", \">\");\n        } catch (InterruptedException interrupted) {\n            throw new RuntimeException(interrupted);\n        } catch (DotFailure failed) {\n            diagramFile.delete();\n            throw failed;\n        } catch (IOException failed) {\n            diagramFile.delete();\n            throw new DotFailure(\"'\" + commandLine + \"' failed with exception \" + failed);\n        } finally {\n            if (mapReader != null) {\n                try {\n                    mapReader.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n\n    public class DotFailure extends IOException {\n\n        private static final long serialVersionUID = 3833743270181351987L;\n\n        public DotFailure(String msg) {\n            super(msg);\n        }\n    }\n\n    private static String getDisplayableCommand(String[] command) {\n        StringBuilder displayable = new StringBuilder();\n        for (int i = 0; i < command.length; ++i) {\n            displayable.append(command[i]);\n            if (i + 1 < command.length)\n                displayable.append(' ');\n        }\n        return displayable.toString();\n    }\n\n    private static class ProcessOutputReader extends Thread {\n\n        private final BufferedReader processReader;\n\n        private final String command;\n\n        ProcessOutputReader(String command, InputStream processStream) {\n            processReader = new BufferedReader(new InputStreamReader(processStream));\n            this.command = command;\n            setDaemon(true);\n        }\n\n        @Override\n        public void run() {\n            try {\n                String line;\n                while ((line = processReader.readLine()) != null) {\n                    // don't report port id unrecognized or unrecognized port\n                    if (line.indexOf(\"unrecognized\") == -1 && line.indexOf(\"port\") == -1)\n                        System.err.println(command + \": \" + line);\n                }\n            } catch (IOException ioException) {\n                ioException.printStackTrace();\n            } finally {\n                try {\n                    processReader.close();\n                } catch (Exception exc) {\n                    // shouldn't ever get here...but...\n                    exc.printStackTrace();\n                }\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/DotTest5.java",
		"test_prompt": "// DotTest5.java\npackage net.sourceforge.schemaspy.util;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Dot}.\n* It contains ten unit test cases for the {@link Dot#isHighQuality()} method.\n*/\nclass DotTest5 {"
	},
	{
		"original_code": "// Dot.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.util;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\n\npublic class Dot {\n\n    private static Dot instance = new Dot();\n\n    private final Version version;\n\n    private final Version supportedVersion = new Version(\"2.2.1\");\n\n    private final Version badVersion = new Version(\"2.4\");\n\n    private final String lineSeparator = System.getProperty(\"line.separator\");\n\n    private String dotExe;\n\n    private String format = \"png\";\n\n    private String renderer;\n\n    private final Set<String> validatedRenderers = Collections.synchronizedSet(new HashSet<String>());\n\n    private final Set<String> invalidatedRenderers = Collections.synchronizedSet(new HashSet<String>());\n\n    private final Logger logger = Logger.getLogger(Dot.class.getName());\n\n    private Dot() {\n        String versionText = null;\n        // dot -V should return something similar to:\n        //  dot version 2.8 (Fri Feb  3 22:38:53 UTC 2006)\n        // or sometimes something like:\n        //  dot - Graphviz version 2.9.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)\n        String[] dotCommand = new String[] { getExe(), \"-V\" };\n        try {\n            Process process = Runtime.getRuntime().exec(dotCommand);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()));\n            String versionLine = reader.readLine();\n            logger.config(\"Version: \\\"\" + versionLine + \"\\\"\");\n            // look for a number followed numbers or dots\n            Matcher matcher = Pattern.compile(\"[0-9][0-9.]+\").matcher(versionLine);\n            if (matcher.find()) {\n                versionText = matcher.group();\n            } else {\n                if (Config.getInstance().isHtmlGenerationEnabled()) {\n                    System.err.println();\n                    logger.warning(\"Invalid dot configuration detected.  '\" + getDisplayableCommand(dotCommand) + \"' returned:\");\n                    logger.warning(\"   \" + versionLine);\n                }\n            }\n        } catch (Exception validDotDoesntExist) {\n            if (Config.getInstance().isHtmlGenerationEnabled()) {\n                System.err.println();\n                logger.warning(\"Failed to query Graphviz version information\");\n                logger.warning(\"  with: \" + getDisplayableCommand(dotCommand));\n                logger.warning(\"  \" + validDotDoesntExist);\n                logger.log(Level.INFO, \"Graphviz query failure details:\", validDotDoesntExist);\n            }\n        }\n        version = new Version(versionText);\n        validatedRenderers.add(\"\");\n    }\n\n    public static Dot getInstance() {\n        return instance;\n    }\n\n    public boolean exists() {\n        return version.toString() != null;\n    }\n\n    public Version getVersion() {\n        return version;\n    }\n\n    public boolean isValid() {\n        return exists() && (getVersion().equals(supportedVersion) || getVersion().compareTo(badVersion) > 0);\n    }\n\n    public String getSupportedVersions() {\n        return \"dot version \" + supportedVersion + \" or versions greater than \" + badVersion;\n    }\n\n    public boolean supportsCenteredEastWestEdges() {\n        return getVersion().compareTo(new Version(\"2.6\")) >= 0;\n    }\n\n    /**\n     * Set the image format to generate.  Defaults to <code>png</code>.\n     * See <a href='http://www.graphviz.org/doc/info/output.html'>http://www.graphviz.org/doc/info/output.html</a>\n     * for valid formats.\n     *\n     * @param format image format to generate\n     */\n    public void setFormat(String format) {\n        this.format = format;\n    }\n\n    /**\n     * @see #setFormat(String)\n     * @return\n     */\n    public String getFormat() {\n        return format;\n    }\n\n    /**\n     * Returns true if the installed dot requires specifying :gd as a renderer.\n     * This was added when Win 2.15 came out because it defaulted to Cairo, which produces\n     * better quality output, but at a significant speed and size penalty.<p>\n     *\n     * The intent of this property is to determine if it's ok to tack \":gd\" to\n     * the format specifier.  Earlier versions didn't require it and didn't know\n     * about the option.\n     *\n     * @return\n     */\n    public boolean requiresGdRenderer() {\n        return getVersion().compareTo(new Version(\"2.12\")) >= 0 && supportsRenderer(\":gd\");\n    }\n\n    /**\n     * Set the renderer to use for the -Tformat[:renderer[:formatter]] dot option as specified\n     * at <a href='http://www.graphviz.org/doc/info/command.html'>\n     * http://www.graphviz.org/doc/info/command.html</a> where \"format\" is specified by\n     * {@link #setFormat(String)}<p>\n     * Note that the leading \":\" is required while :formatter is optional.\n     *\n     * @param renderer\n     */\n    public void setRenderer(String renderer) {\n        if (isValid() && !supportsRenderer(renderer)) {\n            logger.info(\"renderer '\" + renderer + \"' is not supported by your version of dot\");\n        }\n        this.renderer = renderer;\n    }\n\n    /**\n     * @see #setRenderer(String)\n     * @return the renderer to use\n     */\n    public String getRenderer() {\n        if (renderer == null) {\n            setHighQuality(true);\n        }\n        return supportsRenderer(renderer) ? renderer : (requiresGdRenderer() ? \":gd\" : \"\");\n    }\n\n    /**\n     * If <code>true</code> then generate output of \"higher quality\".\n     * Note that the default is intended to be \"higher quality\",\n     * but various installations of Graphviz may have have different abilities.\n     * That is, some might not have the \"lower quality\" libraries and others might\n     * not have the \"higher quality\" libraries.\n     */\n    public void setHighQuality(boolean highQuality) {\n        if (highQuality && supportsRenderer(\":cairo\")) {\n            setRenderer(\":cairo\");\n        } else if (supportsRenderer(\":gd\")) {\n            setRenderer(\":gd\");\n        } else {\n            setRenderer(\"\");\n        }\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isHighQuality() {\n        return getRenderer().indexOf(\":cairo\") != -1;\n    }\n\n    /**\n     * Returns <code>true</code> if the specified renderer is supported.\n     * See {@link #setRenderer(String)} for renderer details.\n     *\n     * @param renderer\n     * @return\n     */\n    public boolean supportsRenderer(@SuppressWarnings(\"hiding\") String renderer) {\n        if (!exists())\n            return false;\n        if (validatedRenderers.contains(renderer))\n            return true;\n        if (invalidatedRenderers.contains(renderer))\n            return false;\n        try {\n            String[] dotCommand = new String[] { getExe(), \"-T\" + getFormat() + ':' };\n            Process process = Runtime.getRuntime().exec(dotCommand);\n            BufferedReader errors = new BufferedReader(new InputStreamReader(process.getErrorStream()));\n            String line;\n            while ((line = errors.readLine()) != null) {\n                if (line.contains(getFormat() + renderer)) {\n                    validatedRenderers.add(renderer);\n                }\n            }\n            process.waitFor();\n        } catch (Exception exc) {\n            exc.printStackTrace();\n        }\n        if (!validatedRenderers.contains(renderer)) {\n            logger.info(\"Failed to validate \" + getFormat() + \" renderer '\" + renderer + \"'.  Reverting to default renderer for \" + getFormat() + '.');\n            invalidatedRenderers.add(renderer);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns the executable to use to run dot\n     *\n     * @return\n     */\n    private String getExe() {\n        if (dotExe == null) {\n            File gv = Config.getInstance().getGraphvizDir();\n            if (gv == null) {\n                // default to finding dot in the PATH\n                dotExe = \"dot\";\n            } else {\n                // pull dot from the Graphviz bin directory specified\n                dotExe = new File(new File(gv, \"bin\"), \"dot\").toString();\n            }\n        }\n        return dotExe;\n    }\n\n    /**\n     * Using the specified .dot file generates an image returning the image's image map.\n     */\n    public String generateDiagram(File dotFile, File diagramFile) throws DotFailure {\n        StringBuilder mapBuffer = new StringBuilder(1024);\n        BufferedReader mapReader = null;\n        // this one is for executing.  it can (hopefully) deal with funky things in filenames.\n        String[] dotCommand = new String[] { getExe(), \"-T\" + getFormat() + getRenderer(), dotFile.toString(), \"-o\" + diagramFile, \"-Tcmapx\" };\n        // this one is for display purposes ONLY.\n        String commandLine = getDisplayableCommand(dotCommand);\n        logger.fine(commandLine);\n        try {\n            Process process = Runtime.getRuntime().exec(dotCommand);\n            new ProcessOutputReader(commandLine, process.getErrorStream()).start();\n            mapReader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = mapReader.readLine()) != null) {\n                mapBuffer.append(line);\n                mapBuffer.append(lineSeparator);\n            }\n            int rc = process.waitFor();\n            if (rc != 0)\n                throw new DotFailure(\"'\" + commandLine + \"' failed with return code \" + rc);\n            if (!diagramFile.exists())\n                throw new DotFailure(\"'\" + commandLine + \"' failed to create output file\");\n            // dot generates post-HTML 4.0.1 output...convert trailing />'s to >'s\n            return mapBuffer.toString().replace(\"/>\", \">\");\n        } catch (InterruptedException interrupted) {\n            throw new RuntimeException(interrupted);\n        } catch (DotFailure failed) {\n            diagramFile.delete();\n            throw failed;\n        } catch (IOException failed) {\n            diagramFile.delete();\n            throw new DotFailure(\"'\" + commandLine + \"' failed with exception \" + failed);\n        } finally {\n            if (mapReader != null) {\n                try {\n                    mapReader.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n\n    public class DotFailure extends IOException {\n\n        private static final long serialVersionUID = 3833743270181351987L;\n\n        public DotFailure(String msg) {\n            super(msg);\n        }\n    }\n\n    private static String getDisplayableCommand(String[] command) {\n        StringBuilder displayable = new StringBuilder();\n        for (int i = 0; i < command.length; ++i) {\n            displayable.append(command[i]);\n            if (i + 1 < command.length)\n                displayable.append(' ');\n        }\n        return displayable.toString();\n    }\n\n    private static class ProcessOutputReader extends Thread {\n\n        private final BufferedReader processReader;\n\n        private final String command;\n\n        ProcessOutputReader(String command, InputStream processStream) {\n            processReader = new BufferedReader(new InputStreamReader(processStream));\n            this.command = command;\n            setDaemon(true);\n        }\n\n        @Override\n        public void run() {\n            try {\n                String line;\n                while ((line = processReader.readLine()) != null) {\n                    // don't report port id unrecognized or unrecognized port\n                    if (line.indexOf(\"unrecognized\") == -1 && line.indexOf(\"port\") == -1)\n                        System.err.println(command + \": \" + line);\n                }\n            } catch (IOException ioException) {\n                ioException.printStackTrace();\n            } finally {\n                try {\n                    processReader.close();\n                } catch (Exception exc) {\n                    // shouldn't ever get here...but...\n                    exc.printStackTrace();\n                }\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/DotTest6.java",
		"test_prompt": "// DotTest6.java\npackage net.sourceforge.schemaspy.util;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Dot}.\n* It contains ten unit test cases for the {@link Dot#supportsRenderer(String)} method.\n*/\nclass DotTest6 {"
	},
	{
		"original_code": "// Dot.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.util;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\n\npublic class Dot {\n\n    private static Dot instance = new Dot();\n\n    private final Version version;\n\n    private final Version supportedVersion = new Version(\"2.2.1\");\n\n    private final Version badVersion = new Version(\"2.4\");\n\n    private final String lineSeparator = System.getProperty(\"line.separator\");\n\n    private String dotExe;\n\n    private String format = \"png\";\n\n    private String renderer;\n\n    private final Set<String> validatedRenderers = Collections.synchronizedSet(new HashSet<String>());\n\n    private final Set<String> invalidatedRenderers = Collections.synchronizedSet(new HashSet<String>());\n\n    private final Logger logger = Logger.getLogger(Dot.class.getName());\n\n    private Dot() {\n        String versionText = null;\n        // dot -V should return something similar to:\n        //  dot version 2.8 (Fri Feb  3 22:38:53 UTC 2006)\n        // or sometimes something like:\n        //  dot - Graphviz version 2.9.20061004.0440 (Wed Oct 4 21:01:52 GMT 2006)\n        String[] dotCommand = new String[] { getExe(), \"-V\" };\n        try {\n            Process process = Runtime.getRuntime().exec(dotCommand);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()));\n            String versionLine = reader.readLine();\n            logger.config(\"Version: \\\"\" + versionLine + \"\\\"\");\n            // look for a number followed numbers or dots\n            Matcher matcher = Pattern.compile(\"[0-9][0-9.]+\").matcher(versionLine);\n            if (matcher.find()) {\n                versionText = matcher.group();\n            } else {\n                if (Config.getInstance().isHtmlGenerationEnabled()) {\n                    System.err.println();\n                    logger.warning(\"Invalid dot configuration detected.  '\" + getDisplayableCommand(dotCommand) + \"' returned:\");\n                    logger.warning(\"   \" + versionLine);\n                }\n            }\n        } catch (Exception validDotDoesntExist) {\n            if (Config.getInstance().isHtmlGenerationEnabled()) {\n                System.err.println();\n                logger.warning(\"Failed to query Graphviz version information\");\n                logger.warning(\"  with: \" + getDisplayableCommand(dotCommand));\n                logger.warning(\"  \" + validDotDoesntExist);\n                logger.log(Level.INFO, \"Graphviz query failure details:\", validDotDoesntExist);\n            }\n        }\n        version = new Version(versionText);\n        validatedRenderers.add(\"\");\n    }\n\n    public static Dot getInstance() {\n        return instance;\n    }\n\n    public boolean exists() {\n        return version.toString() != null;\n    }\n\n    public Version getVersion() {\n        return version;\n    }\n\n    public boolean isValid() {\n        return exists() && (getVersion().equals(supportedVersion) || getVersion().compareTo(badVersion) > 0);\n    }\n\n    public String getSupportedVersions() {\n        return \"dot version \" + supportedVersion + \" or versions greater than \" + badVersion;\n    }\n\n    public boolean supportsCenteredEastWestEdges() {\n        return getVersion().compareTo(new Version(\"2.6\")) >= 0;\n    }\n\n    /**\n     * Set the image format to generate.  Defaults to <code>png</code>.\n     * See <a href='http://www.graphviz.org/doc/info/output.html'>http://www.graphviz.org/doc/info/output.html</a>\n     * for valid formats.\n     *\n     * @param format image format to generate\n     */\n    public void setFormat(String format) {\n        this.format = format;\n    }\n\n    /**\n     * @see #setFormat(String)\n     * @return\n     */\n    public String getFormat() {\n        return format;\n    }\n\n    /**\n     * Returns true if the installed dot requires specifying :gd as a renderer.\n     * This was added when Win 2.15 came out because it defaulted to Cairo, which produces\n     * better quality output, but at a significant speed and size penalty.<p>\n     *\n     * The intent of this property is to determine if it's ok to tack \":gd\" to\n     * the format specifier.  Earlier versions didn't require it and didn't know\n     * about the option.\n     *\n     * @return\n     */\n    public boolean requiresGdRenderer() {\n        return getVersion().compareTo(new Version(\"2.12\")) >= 0 && supportsRenderer(\":gd\");\n    }\n\n    /**\n     * Set the renderer to use for the -Tformat[:renderer[:formatter]] dot option as specified\n     * at <a href='http://www.graphviz.org/doc/info/command.html'>\n     * http://www.graphviz.org/doc/info/command.html</a> where \"format\" is specified by\n     * {@link #setFormat(String)}<p>\n     * Note that the leading \":\" is required while :formatter is optional.\n     *\n     * @param renderer\n     */\n    public void setRenderer(String renderer) {\n        if (isValid() && !supportsRenderer(renderer)) {\n            logger.info(\"renderer '\" + renderer + \"' is not supported by your version of dot\");\n        }\n        this.renderer = renderer;\n    }\n\n    /**\n     * @see #setRenderer(String)\n     * @return the renderer to use\n     */\n    public String getRenderer() {\n        if (renderer == null) {\n            setHighQuality(true);\n        }\n        return supportsRenderer(renderer) ? renderer : (requiresGdRenderer() ? \":gd\" : \"\");\n    }\n\n    /**\n     * If <code>true</code> then generate output of \"higher quality\".\n     * Note that the default is intended to be \"higher quality\",\n     * but various installations of Graphviz may have have different abilities.\n     * That is, some might not have the \"lower quality\" libraries and others might\n     * not have the \"higher quality\" libraries.\n     */\n    public void setHighQuality(boolean highQuality) {\n        if (highQuality && supportsRenderer(\":cairo\")) {\n            setRenderer(\":cairo\");\n        } else if (supportsRenderer(\":gd\")) {\n            setRenderer(\":gd\");\n        } else {\n            setRenderer(\"\");\n        }\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isHighQuality() {\n        return getRenderer().indexOf(\":cairo\") != -1;\n    }\n\n    /**\n     * Returns <code>true</code> if the specified renderer is supported.\n     * See {@link #setRenderer(String)} for renderer details.\n     *\n     * @param renderer\n     * @return\n     */\n    public boolean supportsRenderer(@SuppressWarnings(\"hiding\") String renderer) {\n        if (!exists())\n            return false;\n        if (validatedRenderers.contains(renderer))\n            return true;\n        if (invalidatedRenderers.contains(renderer))\n            return false;\n        try {\n            String[] dotCommand = new String[] { getExe(), \"-T\" + getFormat() + ':' };\n            Process process = Runtime.getRuntime().exec(dotCommand);\n            BufferedReader errors = new BufferedReader(new InputStreamReader(process.getErrorStream()));\n            String line;\n            while ((line = errors.readLine()) != null) {\n                if (line.contains(getFormat() + renderer)) {\n                    validatedRenderers.add(renderer);\n                }\n            }\n            process.waitFor();\n        } catch (Exception exc) {\n            exc.printStackTrace();\n        }\n        if (!validatedRenderers.contains(renderer)) {\n            logger.info(\"Failed to validate \" + getFormat() + \" renderer '\" + renderer + \"'.  Reverting to default renderer for \" + getFormat() + '.');\n            invalidatedRenderers.add(renderer);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns the executable to use to run dot\n     *\n     * @return\n     */\n    private String getExe() {\n        if (dotExe == null) {\n            File gv = Config.getInstance().getGraphvizDir();\n            if (gv == null) {\n                // default to finding dot in the PATH\n                dotExe = \"dot\";\n            } else {\n                // pull dot from the Graphviz bin directory specified\n                dotExe = new File(new File(gv, \"bin\"), \"dot\").toString();\n            }\n        }\n        return dotExe;\n    }\n\n    /**\n     * Using the specified .dot file generates an image returning the image's image map.\n     */\n    public String generateDiagram(File dotFile, File diagramFile) throws DotFailure {\n        StringBuilder mapBuffer = new StringBuilder(1024);\n        BufferedReader mapReader = null;\n        // this one is for executing.  it can (hopefully) deal with funky things in filenames.\n        String[] dotCommand = new String[] { getExe(), \"-T\" + getFormat() + getRenderer(), dotFile.toString(), \"-o\" + diagramFile, \"-Tcmapx\" };\n        // this one is for display purposes ONLY.\n        String commandLine = getDisplayableCommand(dotCommand);\n        logger.fine(commandLine);\n        try {\n            Process process = Runtime.getRuntime().exec(dotCommand);\n            new ProcessOutputReader(commandLine, process.getErrorStream()).start();\n            mapReader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = mapReader.readLine()) != null) {\n                mapBuffer.append(line);\n                mapBuffer.append(lineSeparator);\n            }\n            int rc = process.waitFor();\n            if (rc != 0)\n                throw new DotFailure(\"'\" + commandLine + \"' failed with return code \" + rc);\n            if (!diagramFile.exists())\n                throw new DotFailure(\"'\" + commandLine + \"' failed to create output file\");\n            // dot generates post-HTML 4.0.1 output...convert trailing />'s to >'s\n            return mapBuffer.toString().replace(\"/>\", \">\");\n        } catch (InterruptedException interrupted) {\n            throw new RuntimeException(interrupted);\n        } catch (DotFailure failed) {\n            diagramFile.delete();\n            throw failed;\n        } catch (IOException failed) {\n            diagramFile.delete();\n            throw new DotFailure(\"'\" + commandLine + \"' failed with exception \" + failed);\n        } finally {\n            if (mapReader != null) {\n                try {\n                    mapReader.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n\n    public class DotFailure extends IOException {\n\n        private static final long serialVersionUID = 3833743270181351987L;\n\n        public DotFailure(String msg) {\n            super(msg);\n        }\n    }\n\n    private static String getDisplayableCommand(String[] command) {\n        StringBuilder displayable = new StringBuilder();\n        for (int i = 0; i < command.length; ++i) {\n            displayable.append(command[i]);\n            if (i + 1 < command.length)\n                displayable.append(' ');\n        }\n        return displayable.toString();\n    }\n\n    private static class ProcessOutputReader extends Thread {\n\n        private final BufferedReader processReader;\n\n        private final String command;\n\n        ProcessOutputReader(String command, InputStream processStream) {\n            processReader = new BufferedReader(new InputStreamReader(processStream));\n            this.command = command;\n            setDaemon(true);\n        }\n\n        @Override\n        public void run() {\n            try {\n                String line;\n                while ((line = processReader.readLine()) != null) {\n                    // don't report port id unrecognized or unrecognized port\n                    if (line.indexOf(\"unrecognized\") == -1 && line.indexOf(\"port\") == -1)\n                        System.err.println(command + \": \" + line);\n                }\n            } catch (IOException ioException) {\n                ioException.printStackTrace();\n            } finally {\n                try {\n                    processReader.close();\n                } catch (Exception exc) {\n                    // shouldn't ever get here...but...\n                    exc.printStackTrace();\n                }\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/DotTest7.java",
		"test_prompt": "// DotTest7.java\npackage net.sourceforge.schemaspy.util;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Dot}.\n* It contains ten unit test cases for the {@link Dot#generateDiagram(File, File)} method.\n*/\nclass DotTest7 {"
	},
	{
		"original_code": "// LogFormatter.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy.util;\r\n\r\nimport java.io.PrintWriter;\r\nimport java.io.StringWriter;\r\nimport java.text.DateFormat;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Date;\r\nimport java.util.logging.Formatter;\r\nimport java.util.logging.LogRecord;\r\n\r\n/**\r\n * Format a LogRecord into a single concise line.\r\n *\r\n * @author John Currier\r\n */\r\npublic class LogFormatter extends Formatter {\r\n\r\n    private final String lineSeparator = System.getProperty(\"line.separator\");\r\n\r\n    private final int MAX_LEVEL_LEN = 7;\r\n\r\n    private static final String formatSpec = \"HH:mm:ss.\";\r\n\r\n    private static final long serialVersionUID = 1L;\r\n\r\n    /**\r\n     * Date formatter for time-to-text translation.\r\n     * These are very expensive to create and not thread-safe, so do it once per thread.\r\n     */\r\n    private static final ThreadLocal<DateFormat> dateFormatter = new ThreadLocal<DateFormat>() {\r\n\r\n        @Override\r\n        public DateFormat initialValue() {\r\n            SimpleDateFormat formatter = new SimpleDateFormat(formatSpec);\r\n            return formatter;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Optimization to keep from creating a new {@link java.util.Date} for every call to\r\n     * {@link #toString()}.\r\n     */\r\n    private static final ThreadLocal<Date> date = new ThreadLocal<Date>() {\r\n\r\n        @Override\r\n        public Date initialValue() {\r\n            return new Date();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Format the given LogRecord.\r\n     *\r\n     * @param record\r\n     *            the log record to be formatted.\r\n     * @return a formatted log record\r\n     */\r\n    @Override\r\n    public String format(LogRecord record) {\r\n        StringBuilder buf = new StringBuilder(128);\r\n        // format the date portion:\r\n        // thread-safe pseudo-singletons:\r\n        date.get().setTime(record.getMillis());\r\n        buf.append(dateFormatter.get().format(date.get()));\r\n        // compute frac as the number of milliseconds off of a whole second\r\n        long frac = record.getMillis() % 1000;\r\n        // force longFrac to overflow 1000 to give 1 followed by\r\n        // 'leading' zeros\r\n        frac += 1000;\r\n        // append the fraction of a second at the end (w/o leading overflowed 1)\r\n        buf.append(Long.toString(frac).substring(1));\r\n        buf.append(\" \");\r\n        StringBuilder level = new StringBuilder(record.getLevel().getLocalizedName());\r\n        if (level.length() > MAX_LEVEL_LEN)\r\n            level.setLength(MAX_LEVEL_LEN);\r\n        level.append(\":\");\r\n        while (level.length() < MAX_LEVEL_LEN + 1) level.append(' ');\r\n        buf.append(level);\r\n        buf.append(\" \");\r\n        String name;\r\n        if (record.getSourceClassName() != null) {\r\n            name = record.getSourceClassName();\r\n        } else {\r\n            name = record.getLoggerName();\r\n        }\r\n        int lastDot = name.lastIndexOf('.');\r\n        if (lastDot >= 0 && lastDot < name.length() - 1)\r\n            name = name.substring(lastDot + 1);\r\n        buf.append(name);\r\n        if (record.getSourceMethodName() != null) {\r\n            buf.append('.');\r\n            buf.append(record.getSourceMethodName());\r\n        }\r\n        buf.append(\" - \");\r\n        buf.append(formatMessage(record));\r\n        buf.append(lineSeparator);\r\n        if (record.getThrown() != null) {\r\n            try {\r\n                StringWriter stacktrace = new StringWriter();\r\n                record.getThrown().printStackTrace(new PrintWriter(stacktrace, true));\r\n                buf.append(stacktrace.toString());\r\n                // stack trace already has a line separator\r\n            } catch (Exception ignore) {\r\n            }\r\n        }\r\n        return buf.toString();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/LogFormatterTest.java",
		"test_prompt": "// LogFormatterTest.java\npackage net.sourceforge.schemaspy.util;\n\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.logging.Formatter;\nimport java.util.logging.LogRecord;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LogFormatter}.\n* It contains ten unit test cases for the {@link LogFormatter#format(LogRecord)} method.\n*/\nclass LogFormatterTest {"
	},
	{
		"original_code": "// ResourceWriter.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy.util;\r\n\r\nimport java.io.File;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.OutputStream;\r\n\r\npublic class ResourceWriter {\r\n\r\n    private static ResourceWriter instance = new ResourceWriter();\r\n\r\n    protected ResourceWriter() {\r\n    }\r\n\r\n    public static ResourceWriter getInstance() {\r\n        return instance;\r\n    }\r\n\r\n    /**\r\n     * Write the specified resource to the specified filename\r\n     *\r\n     * @param resourceName\r\n     * @param writeTo\r\n     * @throws IOException\r\n     */\r\n    public void writeResource(String resourceName, File writeTo) throws IOException {\r\n        writeTo.getParentFile().mkdirs();\r\n        InputStream in = getClass().getResourceAsStream(resourceName);\r\n        if (in == null)\r\n            throw new IOException(\"Resource \\\"\" + resourceName + \"\\\" not found\");\r\n        byte[] buf = new byte[4096];\r\n        OutputStream out = new FileOutputStream(writeTo);\r\n        int numBytes = 0;\r\n        while ((numBytes = in.read(buf)) != -1) {\r\n            out.write(buf, 0, numBytes);\r\n        }\r\n        in.close();\r\n        out.close();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/ResourceWriterTest.java",
		"test_prompt": "// ResourceWriterTest.java\npackage net.sourceforge.schemaspy.util;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ResourceWriter}.\n* It contains ten unit test cases for the {@link ResourceWriter#getInstance()} method.\n*/\nclass ResourceWriterTest {"
	},
	{
		"original_code": "// Version.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.util;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\n/**\n * Simple class that allows logical comparisons between \"dotted\" versions of products.\n *\n * e.g. version 2.1.4 should be less than version 2.1.10.\n *\n * @author John Currier\n * @version 1.0\n */\npublic class Version implements Comparable<Version> {\n\n    private final List<Integer> segments = new ArrayList<Integer>();\n\n    private final String asString;\n\n    private final int hashCode;\n\n    public Version(String version) {\n        asString = version;\n        int hash = 0;\n        if (version != null) {\n            StringTokenizer tokenizer = new StringTokenizer(version, \". -_\");\n            while (tokenizer.hasMoreTokens()) {\n                Integer segment = new Integer(tokenizer.nextToken());\n                segments.add(segment);\n                hash += segment.intValue();\n            }\n        }\n        hashCode = hash;\n    }\n\n    /**\n     * Compares this object with the specified object for order.  Returns a\n     * negative integer, zero, or a positive integer as this object is less\n     * than, equal to, or greater than the specified object.\n     */\n    public int compareTo(Version other) {\n        int size = Math.min(segments.size(), other.segments.size());\n        for (int i = 0; i < size; ++i) {\n            Integer thisSegment = segments.get(i);\n            Integer otherSegment = other.segments.get(i);\n            int result = thisSegment.compareTo(otherSegment);\n            if (result != 0)\n                return result;\n        }\n        if (segments.size() == other.segments.size())\n            return 0;\n        if (segments.size() > other.segments.size())\n            return 1;\n        return -1;\n    }\n\n    @Override\n    public boolean equals(Object other) {\n        if (other == null || !(other instanceof Version))\n            return false;\n        return compareTo((Version) other) == 0;\n    }\n\n    @Override\n    public int hashCode() {\n        return hashCode;\n    }\n\n    @Override\n    public String toString() {\n        return asString;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/VersionTest0.java",
		"test_prompt": "// VersionTest0.java\npackage net.sourceforge.schemaspy.util;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Version}.\n* It contains ten unit test cases for the {@link Version#compareTo(Version)} method.\n*/\nclass VersionTest0 {"
	},
	{
		"original_code": "// Version.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.util;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\n/**\n * Simple class that allows logical comparisons between \"dotted\" versions of products.\n *\n * e.g. version 2.1.4 should be less than version 2.1.10.\n *\n * @author John Currier\n * @version 1.0\n */\npublic class Version implements Comparable<Version> {\n\n    private final List<Integer> segments = new ArrayList<Integer>();\n\n    private final String asString;\n\n    private final int hashCode;\n\n    public Version(String version) {\n        asString = version;\n        int hash = 0;\n        if (version != null) {\n            StringTokenizer tokenizer = new StringTokenizer(version, \". -_\");\n            while (tokenizer.hasMoreTokens()) {\n                Integer segment = new Integer(tokenizer.nextToken());\n                segments.add(segment);\n                hash += segment.intValue();\n            }\n        }\n        hashCode = hash;\n    }\n\n    /**\n     * Compares this object with the specified object for order.  Returns a\n     * negative integer, zero, or a positive integer as this object is less\n     * than, equal to, or greater than the specified object.\n     */\n    public int compareTo(Version other) {\n        int size = Math.min(segments.size(), other.segments.size());\n        for (int i = 0; i < size; ++i) {\n            Integer thisSegment = segments.get(i);\n            Integer otherSegment = other.segments.get(i);\n            int result = thisSegment.compareTo(otherSegment);\n            if (result != 0)\n                return result;\n        }\n        if (segments.size() == other.segments.size())\n            return 0;\n        if (segments.size() > other.segments.size())\n            return 1;\n        return -1;\n    }\n\n    @Override\n    public boolean equals(Object other) {\n        if (other == null || !(other instanceof Version))\n            return false;\n        return compareTo((Version) other) == 0;\n    }\n\n    @Override\n    public int hashCode() {\n        return hashCode;\n    }\n\n    @Override\n    public String toString() {\n        return asString;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/VersionTest1.java",
		"test_prompt": "// VersionTest1.java\npackage net.sourceforge.schemaspy.util;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Version}.\n* It contains ten unit test cases for the {@link Version#equals(Object)} method.\n*/\nclass VersionTest1 {"
	},
	{
		"original_code": "// Version.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.util;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\n/**\n * Simple class that allows logical comparisons between \"dotted\" versions of products.\n *\n * e.g. version 2.1.4 should be less than version 2.1.10.\n *\n * @author John Currier\n * @version 1.0\n */\npublic class Version implements Comparable<Version> {\n\n    private final List<Integer> segments = new ArrayList<Integer>();\n\n    private final String asString;\n\n    private final int hashCode;\n\n    public Version(String version) {\n        asString = version;\n        int hash = 0;\n        if (version != null) {\n            StringTokenizer tokenizer = new StringTokenizer(version, \". -_\");\n            while (tokenizer.hasMoreTokens()) {\n                Integer segment = new Integer(tokenizer.nextToken());\n                segments.add(segment);\n                hash += segment.intValue();\n            }\n        }\n        hashCode = hash;\n    }\n\n    /**\n     * Compares this object with the specified object for order.  Returns a\n     * negative integer, zero, or a positive integer as this object is less\n     * than, equal to, or greater than the specified object.\n     */\n    public int compareTo(Version other) {\n        int size = Math.min(segments.size(), other.segments.size());\n        for (int i = 0; i < size; ++i) {\n            Integer thisSegment = segments.get(i);\n            Integer otherSegment = other.segments.get(i);\n            int result = thisSegment.compareTo(otherSegment);\n            if (result != 0)\n                return result;\n        }\n        if (segments.size() == other.segments.size())\n            return 0;\n        if (segments.size() > other.segments.size())\n            return 1;\n        return -1;\n    }\n\n    @Override\n    public boolean equals(Object other) {\n        if (other == null || !(other instanceof Version))\n            return false;\n        return compareTo((Version) other) == 0;\n    }\n\n    @Override\n    public int hashCode() {\n        return hashCode;\n    }\n\n    @Override\n    public String toString() {\n        return asString;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/util/VersionTest2.java",
		"test_prompt": "// VersionTest2.java\npackage net.sourceforge.schemaspy.util;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Version}.\n* It contains ten unit test cases for the {@link Version#hashCode()} method.\n*/\nclass VersionTest2 {"
	},
	{
		"original_code": "// MultipleSchemaAnalyzer.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.io.Reader;\nimport java.sql.DatabaseMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.model.ProcessExecutionException;\nimport net.sourceforge.schemaspy.util.LineWriter;\nimport net.sourceforge.schemaspy.view.HtmlMultipleSchemasIndexPage;\n\n/**\n * @author John Currier\n */\npublic final class MultipleSchemaAnalyzer {\n\n    private static MultipleSchemaAnalyzer instance = new MultipleSchemaAnalyzer();\n\n    private final Logger logger = Logger.getLogger(getClass().getName());\n\n    private final boolean fineEnabled = logger.isLoggable(Level.FINE);\n\n    private MultipleSchemaAnalyzer() {\n    }\n\n    public static MultipleSchemaAnalyzer getInstance() {\n        return instance;\n    }\n\n    public void analyze(String dbName, DatabaseMetaData meta, String schemaSpec, List<String> schemas, List<String> args, Config config) throws SQLException, IOException {\n        long start = System.currentTimeMillis();\n        String loadedFrom = Config.getLoadedFromJar();\n        File outputDir = config.getOutputDir();\n        List<String> genericCommand = new ArrayList<String>();\n        genericCommand.add(\"java\");\n        genericCommand.add(\"-Doneofmultipleschemas=true\");\n        if (new File(loadedFrom).isDirectory()) {\n            genericCommand.add(\"-cp\");\n            genericCommand.add(loadedFrom);\n            genericCommand.add(Main.class.getName());\n        } else {\n            genericCommand.add(\"-jar\");\n            genericCommand.add(loadedFrom);\n        }\n        // rude to modify caller's params, so make a copy\n        args = new ArrayList<String>(args);\n        args.remove(\"-all\");\n        SchemaAnalyzer.yankParam(args, \"-o\");\n        SchemaAnalyzer.yankParam(args, \"-s\");\n        // these are passed through environment variables\n        SchemaAnalyzer.yankParam(args, \"-p\");\n        SchemaAnalyzer.yankParam(args, \"-i\");\n        SchemaAnalyzer.yankParam(args, \"-I\");\n        SchemaAnalyzer.yankParam(args, \"-x\");\n        SchemaAnalyzer.yankParam(args, \"-X\");\n        for (String next : args) {\n            if (next.startsWith(\"-\"))\n                genericCommand.add(next);\n            else\n                genericCommand.add(\"\\\"\" + next + \"\\\"\");\n        }\n        List<String> populatedSchemas;\n        if (schemas == null) {\n            System.out.println(\"Analyzing schemas that match regular expression '\" + schemaSpec + \"':\");\n            System.out.println(\"(use -schemaSpec on command line or in .properties to exclude other schemas)\");\n            populatedSchemas = getPopulatedSchemas(meta, schemaSpec, false);\n            if (populatedSchemas.isEmpty())\n                populatedSchemas = getPopulatedSchemas(meta, schemaSpec, true);\n            if (populatedSchemas.isEmpty())\n                populatedSchemas = Arrays.asList(new String[] { config.getUser() });\n        } else {\n            System.out.println(\"Analyzing schemas:\");\n            populatedSchemas = schemas;\n        }\n        for (String populatedSchema : populatedSchemas) System.out.print(\" \" + populatedSchema);\n        System.out.println();\n        writeIndexPage(dbName, populatedSchemas, meta, outputDir, config.getCharset());\n        Map<String, String> env = System.getenv();\n        List<String> childEnv = new ArrayList<String>();\n        for (Entry<String, String> entry : env.entrySet()) {\n            childEnv.add(entry.getKey() + '=' + entry.getValue());\n        }\n        // safer to pass password in environment so it can't be directly seen in cmd line\n        childEnv.add(\"schemaspy.pw=\" + config.getPassword());\n        // some shells expand these regular expressions, so attempt to preserve them\n        // by passing in the environment\n        childEnv.add(\"schemaspy.tableInclusions=\" + config.getTableInclusions());\n        childEnv.add(\"schemaspy.tableExclusions=\" + config.getTableExclusions());\n        childEnv.add(\"schemaspy.columnExclusions=\" + config.getColumnExclusions());\n        childEnv.add(\"schemaspy.indirectColumnExclusions=\" + config.getIndirectColumnExclusions());\n        for (String schema : populatedSchemas) {\n            List<String> command = new ArrayList<String>(genericCommand);\n            // if no database was specified then we're dealing with a database\n            // that treats a schema as the database\n            if (dbName == null)\n                command.add(\"-db\");\n            else\n                command.add(\"-s\");\n            command.add(schema);\n            command.add(\"-o\");\n            command.add(new File(outputDir, schema).toString());\n            System.out.println(\"Analyzing \" + schema);\n            System.out.flush();\n            logger.fine(\"Analyzing schema with: \" + command);\n            Process java = Runtime.getRuntime().exec(command.toArray(new String[] {}), childEnv.toArray(new String[] {}));\n            new ProcessOutputReader(java.getInputStream(), System.out).start();\n            new ProcessOutputReader(java.getErrorStream(), System.err).start();\n            try {\n                int rc = java.waitFor();\n                if (rc != 0) {\n                    StringBuilder err = new StringBuilder(\"Failed to execute this process (rc \" + rc + \"):\");\n                    for (String chunk : command) {\n                        err.append(\" \");\n                        err.append(chunk);\n                    }\n                    throw new ProcessExecutionException(err.toString());\n                }\n            } catch (InterruptedException exc) {\n            }\n        }\n        long end = System.currentTimeMillis();\n        System.out.println();\n        System.out.println(\"Wrote relationship details of \" + populatedSchemas.size() + \" schema\" + (populatedSchemas.size() == 1 ? \"\" : \"s\") + \" in \" + (end - start) / 1000 + \" seconds.\");\n        System.out.println(\"Start with \" + new File(outputDir, \"index.html\"));\n    }\n\n    public void analyze(String dbName, List<String> schemas, List<String> args, Config config) throws SQLException, IOException {\n        analyze(dbName, null, null, schemas, args, config);\n    }\n\n    private void writeIndexPage(String dbName, List<String> populatedSchemas, DatabaseMetaData meta, File outputDir, String charset) throws IOException {\n        if (populatedSchemas.size() > 0) {\n            LineWriter index = new LineWriter(new File(outputDir, \"index.html\"), charset);\n            HtmlMultipleSchemasIndexPage.getInstance().write(dbName, populatedSchemas, meta, index);\n            index.close();\n        }\n    }\n\n    private List<String> getPopulatedSchemas(DatabaseMetaData meta, String schemaSpec, boolean isCatalog) throws SQLException {\n        List<String> populatedSchemas;\n        if ((!isCatalog && meta.supportsSchemasInTableDefinitions()) || (isCatalog && meta.supportsCatalogsInTableDefinitions())) {\n            Pattern schemaRegex = Pattern.compile(schemaSpec);\n            populatedSchemas = DbAnalyzer.getPopulatedSchemas(meta, schemaSpec, isCatalog);\n            Iterator<String> iter = populatedSchemas.iterator();\n            while (iter.hasNext()) {\n                String schema = iter.next();\n                if (!schemaRegex.matcher(schema).matches()) {\n                    if (fineEnabled) {\n                        logger.fine(\"Excluding schema \" + schema + \": doesn't match + \\\"\" + schemaRegex + '\"');\n                    }\n                    // remove those that we're not supposed to analyze\n                    iter.remove();\n                } else {\n                    if (fineEnabled) {\n                        logger.fine(\"Including schema \" + schema + \": matches + \\\"\" + schemaRegex + '\"');\n                    }\n                }\n            }\n        } else {\n            populatedSchemas = new ArrayList<String>();\n        }\n        return populatedSchemas;\n    }\n\n    private static class ProcessOutputReader extends Thread {\n\n        private final Reader processReader;\n\n        private final PrintStream out;\n\n        ProcessOutputReader(InputStream processStream, PrintStream out) {\n            processReader = new InputStreamReader(processStream);\n            this.out = out;\n            setDaemon(true);\n        }\n\n        @Override\n        public void run() {\n            try {\n                int ch;\n                while ((ch = processReader.read()) != -1) {\n                    out.print((char) ch);\n                    out.flush();\n                }\n            } catch (IOException ioException) {\n                ioException.printStackTrace();\n            } finally {\n                try {\n                    processReader.close();\n                } catch (Exception exc) {\n                    // shouldn't ever get here...but...\n                    exc.printStackTrace();\n                }\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/MultipleSchemaAnalyzerTest.java",
		"test_prompt": "// MultipleSchemaAnalyzerTest.java\npackage net.sourceforge.schemaspy;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.io.Reader;\nimport java.sql.DatabaseMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.model.ProcessExecutionException;\nimport net.sourceforge.schemaspy.util.LineWriter;\nimport net.sourceforge.schemaspy.view.HtmlMultipleSchemasIndexPage;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MultipleSchemaAnalyzer}.\n* It contains ten unit test cases for the {@link MultipleSchemaAnalyzer#getInstance()} method.\n*/\nclass MultipleSchemaAnalyzerTest {"
	},
	{
		"original_code": "// SchemaAnalyzer.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.sql.Connection;\nimport java.sql.DatabaseMetaData;\nimport java.sql.Driver;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.logging.ConsoleHandler;\nimport java.util.logging.Handler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport net.sourceforge.schemaspy.model.ConnectionFailure;\nimport net.sourceforge.schemaspy.model.Database;\nimport net.sourceforge.schemaspy.model.EmptySchemaException;\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.model.xml.SchemaMeta;\nimport net.sourceforge.schemaspy.util.ConnectionURLBuilder;\nimport net.sourceforge.schemaspy.util.DOMUtil;\nimport net.sourceforge.schemaspy.util.DbSpecificOption;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.LineWriter;\nimport net.sourceforge.schemaspy.util.LogFormatter;\nimport net.sourceforge.schemaspy.util.ResourceWriter;\nimport net.sourceforge.schemaspy.view.DotFormatter;\nimport net.sourceforge.schemaspy.view.HtmlAnomaliesPage;\nimport net.sourceforge.schemaspy.view.HtmlColumnsPage;\nimport net.sourceforge.schemaspy.view.HtmlConstraintsPage;\nimport net.sourceforge.schemaspy.view.HtmlMainIndexPage;\nimport net.sourceforge.schemaspy.view.HtmlOrphansPage;\nimport net.sourceforge.schemaspy.view.HtmlRelationshipsPage;\nimport net.sourceforge.schemaspy.view.HtmlRoutinesPage;\nimport net.sourceforge.schemaspy.view.HtmlTablePage;\nimport net.sourceforge.schemaspy.view.ImageWriter;\nimport net.sourceforge.schemaspy.view.StyleSheet;\nimport net.sourceforge.schemaspy.view.TextFormatter;\nimport net.sourceforge.schemaspy.view.WriteStats;\nimport net.sourceforge.schemaspy.view.XmlTableFormatter;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\n\n/**\n * @author John Currier\n */\npublic class SchemaAnalyzer {\n\n    private final Logger logger = Logger.getLogger(getClass().getName());\n\n    private boolean fineEnabled;\n\n    public Database analyze(Config config) throws Exception {\n        try {\n            if (config.isHelpRequired()) {\n                config.dumpUsage(null, false);\n                return null;\n            }\n            if (config.isDbHelpRequired()) {\n                config.dumpUsage(null, true);\n                return null;\n            }\n            // set the log level for the root logger\n            Logger.getLogger(\"\").setLevel(config.getLogLevel());\n            // clean-up console output a bit\n            for (Handler handler : Logger.getLogger(\"\").getHandlers()) {\n                if (handler instanceof ConsoleHandler) {\n                    ((ConsoleHandler) handler).setFormatter(new LogFormatter());\n                    handler.setLevel(config.getLogLevel());\n                }\n            }\n            fineEnabled = logger.isLoggable(Level.FINE);\n            logger.info(\"Starting schema analysis\");\n            long start = System.currentTimeMillis();\n            long startDiagrammingDetails = start;\n            long startSummarizing = start;\n            File outputDir = config.getOutputDir();\n            if (!outputDir.isDirectory()) {\n                if (!outputDir.mkdirs()) {\n                    throw new IOException(\"Failed to create directory '\" + outputDir + \"'\");\n                }\n            }\n            List<String> schemas = config.getSchemas();\n            if (schemas != null) {\n                List<String> args = config.asList();\n                // following params will be replaced by something appropriate\n                args.remove(\"-schemas\");\n                args.remove(\"-schemata\");\n                String dbName = config.getDb();\n                MultipleSchemaAnalyzer.getInstance().analyze(dbName, schemas, args, config);\n                return null;\n            }\n            Properties properties = config.determineDbProperties(config.getDbType());\n            ConnectionURLBuilder urlBuilder = new ConnectionURLBuilder(config, properties);\n            if (config.getDb() == null)\n                config.setDb(urlBuilder.getConnectionURL());\n            if (config.getRemainingParameters().size() != 0) {\n                StringBuilder msg = new StringBuilder(\"Unrecognized option(s):\");\n                for (String remnant : config.getRemainingParameters()) msg.append(\" \" + remnant);\n                logger.warning(msg.toString());\n            }\n            String driverClass = properties.getProperty(\"driver\");\n            String driverPath = properties.getProperty(\"driverPath\");\n            if (driverPath == null)\n                driverPath = \"\";\n            if (config.getDriverPath() != null)\n                driverPath = config.getDriverPath() + File.pathSeparator + driverPath;\n            Connection connection = getConnection(config, urlBuilder.getConnectionURL(), driverClass, driverPath);\n            DatabaseMetaData meta = connection.getMetaData();\n            String dbName = config.getDb();\n            String schema = config.getSchema();\n            if (config.isEvaluateAllEnabled()) {\n                List<String> args = config.asList();\n                for (DbSpecificOption option : urlBuilder.getOptions()) {\n                    if (!args.contains(\"-\" + option.getName())) {\n                        args.add(\"-\" + option.getName());\n                        args.add(option.getValue().toString());\n                    }\n                }\n                String schemaSpec = config.getSchemaSpec();\n                if (schemaSpec == null)\n                    schemaSpec = properties.getProperty(\"schemaSpec\", \".*\");\n                MultipleSchemaAnalyzer.getInstance().analyze(dbName, meta, schemaSpec, null, args, config);\n                // no database to return\n                return null;\n            }\n            String catalog = config.getCatalog();\n            logger.fine(\"supportsSchemasInTableDefinitions: \" + meta.supportsSchemasInTableDefinitions());\n            logger.fine(\"supportsCatalogsInTableDefinitions: \" + meta.supportsCatalogsInTableDefinitions());\n            if (schema == null && meta.supportsSchemasInTableDefinitions() && !config.isSchemaDisabled()) {\n                schema = config.getUser();\n                logger.fine(\"schema not specified for a database that requires one.  using user: '\" + schema + \"'\");\n                if (schema == null)\n                    throw new InvalidConfigurationException(\"Either a schema ('-s') or a user ('-u') must be specified\");\n                config.setSchema(schema);\n            }\n            if (catalog == null && schema == null && meta.supportsCatalogsInTableDefinitions()) {\n                catalog = dbName;\n                logger.fine(\"catalog not specified for a database that requires one.  using dbName: '\" + catalog + \"'\");\n                config.setCatalog(catalog);\n            }\n            SchemaMeta schemaMeta = config.getMeta() == null ? null : new SchemaMeta(config.getMeta(), dbName, schema);\n            if (config.isHtmlGenerationEnabled()) {\n                new File(outputDir, \"tables\").mkdirs();\n                new File(outputDir, \"diagrams/summary\").mkdirs();\n                logger.info(\"Connected to \" + meta.getDatabaseProductName() + \" - \" + meta.getDatabaseProductVersion());\n                if (schemaMeta != null && schemaMeta.getFile() != null) {\n                    logger.info(\"Using additional metadata from \" + schemaMeta.getFile());\n                }\n                logger.info(\"Gathering schema details\");\n                if (!fineEnabled)\n                    System.out.print(\"Gathering schema details...\");\n            }\n            //\n            // create our representation of the database\n            //\n            Database db = new Database(config, connection, meta, dbName, catalog, schema, schemaMeta);\n            // done with it so let GC reclaim it\n            schemaMeta = null;\n            LineWriter out;\n            Collection<Table> tables = new ArrayList<Table>(db.getTables());\n            tables.addAll(db.getViews());\n            if (tables.isEmpty()) {\n                dumpNoTablesMessage(schema, config.getUser(), meta, config.getTableInclusions() != null);\n                if (// don't bail if we're doing the whole enchilada\n                !config.isOneOfMultipleSchemas())\n                    throw new EmptySchemaException();\n            }\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document document = builder.newDocument();\n            Element rootNode = document.createElement(\"database\");\n            document.appendChild(rootNode);\n            DOMUtil.appendAttribute(rootNode, \"name\", dbName);\n            if (schema != null)\n                DOMUtil.appendAttribute(rootNode, \"schema\", schema);\n            DOMUtil.appendAttribute(rootNode, \"type\", db.getDatabaseProduct());\n            if (config.isHtmlGenerationEnabled()) {\n                startSummarizing = System.currentTimeMillis();\n                if (!fineEnabled) {\n                    System.out.println(\"(\" + (startSummarizing - start) / 1000 + \"sec)\");\n                }\n                logger.info(\"Gathered schema details in \" + (startSummarizing - start) / 1000 + \" seconds\");\n                logger.info(\"Writing/graphing summary\");\n                System.err.flush();\n                System.out.flush();\n                if (!fineEnabled) {\n                    System.out.print(\"Writing/graphing summary\");\n                    System.out.print(\".\");\n                }\n                ImageWriter.getInstance().writeImages(outputDir);\n                ResourceWriter.getInstance().writeResource(\"/jquery.js\", new File(outputDir, \"/jquery.js\"));\n                ResourceWriter.getInstance().writeResource(\"/schemaSpy.js\", new File(outputDir, \"/schemaSpy.js\"));\n                if (!fineEnabled)\n                    System.out.print(\".\");\n                boolean showDetailedTables = tables.size() <= config.getMaxDetailedTables();\n                final boolean includeImpliedConstraints = config.isImpliedConstraintsEnabled();\n                // if evaluating a 'ruby on rails-based' database then connect the columns\n                // based on RoR conventions\n                // note that this is done before 'hasRealRelationships' gets evaluated so\n                // we get a relationships ER diagram\n                if (config.isRailsEnabled())\n                    DbAnalyzer.getRailsConstraints(db.getTablesByName());\n                File summaryDir = new File(outputDir, \"diagrams/summary\");\n                // generate the compact form of the relationships .dot file\n                String dotBaseFilespec = \"relationships\";\n                out = new LineWriter(new File(summaryDir, dotBaseFilespec + \".real.compact.dot\"), Config.DOT_CHARSET);\n                WriteStats stats = new WriteStats(tables);\n                DotFormatter.getInstance().writeRealRelationships(db, tables, true, showDetailedTables, stats, out);\n                boolean hasRealRelationships = stats.getNumTablesWritten() > 0 || stats.getNumViewsWritten() > 0;\n                out.close();\n                if (hasRealRelationships) {\n                    // real relationships exist so generate the 'big' form of the relationships .dot file\n                    if (!fineEnabled)\n                        System.out.print(\".\");\n                    out = new LineWriter(new File(summaryDir, dotBaseFilespec + \".real.large.dot\"), Config.DOT_CHARSET);\n                    DotFormatter.getInstance().writeRealRelationships(db, tables, false, showDetailedTables, stats, out);\n                    out.close();\n                }\n                // getting implied constraints has a side-effect of associating the parent/child tables, so don't do it\n                // here unless they want that behavior\n                List<ImpliedForeignKeyConstraint> impliedConstraints = null;\n                if (includeImpliedConstraints)\n                    impliedConstraints = DbAnalyzer.getImpliedConstraints(tables);\n                else\n                    impliedConstraints = new ArrayList<ImpliedForeignKeyConstraint>();\n                List<Table> orphans = DbAnalyzer.getOrphans(tables);\n                config.setHasOrphans(!orphans.isEmpty() && Dot.getInstance().isValid());\n                config.setHasRoutines(!db.getRoutines().isEmpty());\n                if (!fineEnabled)\n                    System.out.print(\".\");\n                File impliedDotFile = new File(summaryDir, dotBaseFilespec + \".implied.compact.dot\");\n                out = new LineWriter(impliedDotFile, Config.DOT_CHARSET);\n                boolean hasImplied = DotFormatter.getInstance().writeAllRelationships(db, tables, true, showDetailedTables, stats, out);\n                Set<TableColumn> excludedColumns = stats.getExcludedColumns();\n                out.close();\n                if (hasImplied) {\n                    impliedDotFile = new File(summaryDir, dotBaseFilespec + \".implied.large.dot\");\n                    out = new LineWriter(impliedDotFile, Config.DOT_CHARSET);\n                    DotFormatter.getInstance().writeAllRelationships(db, tables, false, showDetailedTables, stats, out);\n                    out.close();\n                } else {\n                    impliedDotFile.delete();\n                }\n                out = new LineWriter(new File(outputDir, dotBaseFilespec + \".html\"), config.getCharset());\n                HtmlRelationshipsPage.getInstance().write(db, summaryDir, dotBaseFilespec, hasRealRelationships, hasImplied, excludedColumns, out);\n                out.close();\n                if (!fineEnabled)\n                    System.out.print(\".\");\n                dotBaseFilespec = \"utilities\";\n                File orphansDir = new File(outputDir, \"diagrams/orphans\");\n                orphansDir.mkdirs();\n                out = new LineWriter(new File(outputDir, dotBaseFilespec + \".html\"), config.getCharset());\n                HtmlOrphansPage.getInstance().write(db, orphans, orphansDir, out);\n                orphans = null;\n                out.close();\n                if (!fineEnabled)\n                    System.out.print(\".\");\n                out = new LineWriter(new File(outputDir, \"index.html\"), 64 * 1024, config.getCharset());\n                HtmlMainIndexPage.getInstance().write(db, tables, db.getRemoteTables(), out);\n                out.close();\n                if (!fineEnabled)\n                    System.out.print(\".\");\n                List<ForeignKeyConstraint> constraints = DbAnalyzer.getForeignKeyConstraints(tables);\n                out = new LineWriter(new File(outputDir, \"constraints.html\"), 256 * 1024, config.getCharset());\n                HtmlConstraintsPage constraintIndexFormatter = HtmlConstraintsPage.getInstance();\n                constraintIndexFormatter.write(db, constraints, tables, out);\n                out.close();\n                if (!fineEnabled)\n                    System.out.print(\".\");\n                out = new LineWriter(new File(outputDir, \"anomalies.html\"), 16 * 1024, config.getCharset());\n                HtmlAnomaliesPage.getInstance().write(db, tables, impliedConstraints, out);\n                out.close();\n                if (!fineEnabled)\n                    System.out.print(\".\");\n                for (HtmlColumnsPage.ColumnInfo columnInfo : HtmlColumnsPage.getInstance().getColumnInfos().values()) {\n                    out = new LineWriter(new File(outputDir, columnInfo.getLocation()), 16 * 1024, config.getCharset());\n                    HtmlColumnsPage.getInstance().write(db, tables, columnInfo, out);\n                    out.close();\n                }\n                if (!fineEnabled)\n                    System.out.print(\".\");\n                out = new LineWriter(new File(outputDir, \"routines.html\"), 16 * 1024, config.getCharset());\n                HtmlRoutinesPage.getInstance().write(db, out);\n                out.close();\n                // create detailed diagrams\n                startDiagrammingDetails = System.currentTimeMillis();\n                if (!fineEnabled)\n                    System.out.println(\"(\" + (startDiagrammingDetails - startSummarizing) / 1000 + \"sec)\");\n                logger.info(\"Completed summary in \" + (startDiagrammingDetails - startSummarizing) / 1000 + \" seconds\");\n                logger.info(\"Writing/diagramming details\");\n                if (!fineEnabled) {\n                    System.out.print(\"Writing/diagramming details\");\n                }\n                HtmlTablePage tableFormatter = HtmlTablePage.getInstance();\n                for (Table table : tables) {\n                    if (!fineEnabled)\n                        System.out.print('.');\n                    else\n                        logger.fine(\"Writing details of \" + table.getName());\n                    out = new LineWriter(new File(outputDir, \"tables/\" + table.getName() + \".html\"), 24 * 1024, config.getCharset());\n                    tableFormatter.write(db, table, outputDir, stats, out);\n                    out.close();\n                }\n                out = new LineWriter(new File(outputDir, \"schemaSpy.css\"), config.getCharset());\n                StyleSheet.getInstance().write(out);\n                out.close();\n            }\n            XmlTableFormatter.getInstance().appendTables(rootNode, tables);\n            String xmlName = dbName;\n            // some dbNames have path info in the name...strip it\n            xmlName = new File(xmlName).getName();\n            // some dbNames include jdbc driver details including :'s and @'s\n            String[] unusables = xmlName.split(\"[:@]\");\n            xmlName = unusables[unusables.length - 1];\n            if (schema != null)\n                xmlName += '.' + schema;\n            out = new LineWriter(new File(outputDir, xmlName + \".xml\"), Config.DOT_CHARSET);\n            document.getDocumentElement().normalize();\n            DOMUtil.printDOM(document, out);\n            out.close();\n            // 'try' to make some memory available for the sorting process\n            // (some people have run out of memory while RI sorting tables)\n            builder = null;\n            connection = null;\n            document = null;\n            factory = null;\n            meta = null;\n            properties = null;\n            rootNode = null;\n            urlBuilder = null;\n            List<ForeignKeyConstraint> recursiveConstraints = new ArrayList<ForeignKeyConstraint>();\n            // create an orderer to be able to determine insertion and deletion ordering of tables\n            TableOrderer orderer = new TableOrderer();\n            // side effect is that the RI relationships get trashed\n            // also populates the recursiveConstraints collection\n            List<Table> orderedTables = orderer.getTablesOrderedByRI(db.getTables(), recursiveConstraints);\n            out = new LineWriter(new File(outputDir, \"insertionOrder.txt\"), 16 * 1024, Config.DOT_CHARSET);\n            TextFormatter.getInstance().write(orderedTables, false, out);\n            out.close();\n            out = new LineWriter(new File(outputDir, \"deletionOrder.txt\"), 16 * 1024, Config.DOT_CHARSET);\n            Collections.reverse(orderedTables);\n            TextFormatter.getInstance().write(orderedTables, false, out);\n            out.close();\n            /* we'll eventually want to put this functionality back in with a\n             * database independent implementation\n            File constraintsFile = new File(outputDir, \"removeRecursiveConstraints.sql\");\n            constraintsFile.delete();\n            if (!recursiveConstraints.isEmpty()) {\n                out = new LineWriter(constraintsFile, 4 * 1024);\n                writeRemoveRecursiveConstraintsSql(recursiveConstraints, schema, out);\n                out.close();\n            }\n\n            constraintsFile = new File(outputDir, \"restoreRecursiveConstraints.sql\");\n            constraintsFile.delete();\n\n            if (!recursiveConstraints.isEmpty()) {\n                out = new LineWriter(constraintsFile, 4 * 1024);\n                writeRestoreRecursiveConstraintsSql(recursiveConstraints, schema, out);\n                out.close();\n            }\n            */\n            if (config.isHtmlGenerationEnabled()) {\n                long end = System.currentTimeMillis();\n                if (!fineEnabled)\n                    System.out.println(\"(\" + (end - startDiagrammingDetails) / 1000 + \"sec)\");\n                logger.info(\"Wrote table details in \" + (end - startDiagrammingDetails) / 1000 + \" seconds\");\n                if (logger.isLoggable(Level.INFO)) {\n                    logger.info(\"Wrote relationship details of \" + tables.size() + \" tables/views to directory '\" + config.getOutputDir() + \"' in \" + (end - start) / 1000 + \" seconds.\");\n                    logger.info(\"View the results by opening \" + new File(config.getOutputDir(), \"index.html\"));\n                } else {\n                    System.out.println(\"Wrote relationship details of \" + tables.size() + \" tables/views to directory '\" + config.getOutputDir() + \"' in \" + (end - start) / 1000 + \" seconds.\");\n                    System.out.println(\"View the results by opening \" + new File(config.getOutputDir(), \"index.html\"));\n                }\n            }\n            return db;\n        } catch (Config.MissingRequiredParameterException missingParam) {\n            config.dumpUsage(missingParam.getMessage(), missingParam.isDbTypeSpecific());\n            return null;\n        }\n    }\n\n    /**\n     * dumpNoDataMessage\n     *\n     * @param schema String\n     * @param user String\n     * @param meta DatabaseMetaData\n     */\n    private static void dumpNoTablesMessage(String schema, String user, DatabaseMetaData meta, boolean specifiedInclusions) throws SQLException {\n        System.out.println();\n        System.out.println();\n        System.out.println(\"No tables or views were found in schema '\" + schema + \"'.\");\n        List<String> schemas = null;\n        Exception failure = null;\n        try {\n            schemas = DbAnalyzer.getSchemas(meta);\n        } catch (SQLException exc) {\n            failure = exc;\n        } catch (RuntimeException exc) {\n            failure = exc;\n        }\n        if (schemas == null) {\n            System.out.println(\"The user you specified (\" + user + ')');\n            System.out.println(\"  might not have rights to read the database metadata.\");\n            System.out.flush();\n            if (// to appease the compiler\n            failure != null)\n                failure.printStackTrace();\n            return;\n        } else if (schema == null || schemas.contains(schema)) {\n            System.out.println(\"The schema exists in the database, but the user you specified (\" + user + ')');\n            System.out.println(\"  might not have rights to read its contents.\");\n            if (specifiedInclusions) {\n                System.out.println(\"Another possibility is that the regular expression that you specified\");\n                System.out.println(\"  for what to include (via -i) didn't match any tables.\");\n            }\n        } else {\n            System.out.println(\"The schema does not exist in the database.\");\n            System.out.println(\"Make sure that you specify a valid schema with the -s option and that\");\n            System.out.println(\"  the user specified (\" + user + \") can read from the schema.\");\n            System.out.println(\"Note that schema names are usually case sensitive.\");\n        }\n        System.out.println();\n        boolean plural = schemas.size() != 1;\n        System.out.println(schemas.size() + \" schema\" + (plural ? \"s\" : \"\") + \" exist\" + (plural ? \"\" : \"s\") + \" in this database.\");\n        System.out.println(\"Some of these \\\"schemas\\\" may be users or system schemas.\");\n        System.out.println();\n        for (String unknown : schemas) {\n            System.out.print(unknown + \" \");\n        }\n        System.out.println();\n        List<String> populatedSchemas = DbAnalyzer.getPopulatedSchemas(meta);\n        if (populatedSchemas.isEmpty()) {\n            System.out.println(\"Unable to determine if any of the schemas contain tables/views\");\n        } else {\n            System.out.println(\"These schemas contain tables/views that user '\" + user + \"' can see:\");\n            System.out.println();\n            for (String populated : populatedSchemas) {\n                System.out.print(\" \" + populated);\n            }\n        }\n    }\n\n    protected Connection getConnection(Config config, String connectionURL, String driverClass, String driverPath) throws FileNotFoundException, IOException {\n        if (logger.isLoggable(Level.INFO)) {\n            logger.info(\"Using database properties:\");\n            logger.info(\"  \" + config.getDbPropertiesLoadedFrom());\n        } else {\n            System.out.println(\"Using database properties:\");\n            System.out.println(\"  \" + config.getDbPropertiesLoadedFrom());\n        }\n        Driver driver = getDriver(driverClass, driverPath);\n        Properties connectionProperties = config.getConnectionProperties();\n        if (config.getUser() != null) {\n            connectionProperties.put(\"user\", config.getUser());\n        }\n        if (config.getPassword() != null) {\n            connectionProperties.put(\"password\", config.getPassword());\n        }\n        Connection connection = null;\n        try {\n            connection = driver.connect(connectionURL, connectionProperties);\n            if (connection == null) {\n                System.err.println();\n                System.err.println(\"Cannot connect to this database URL:\");\n                System.err.println(\"  \" + connectionURL);\n                System.err.println(\"with this driver:\");\n                System.err.println(\"  \" + driverClass);\n                System.err.println();\n                System.err.println(\"Additional connection information may be available in \");\n                System.err.println(\"  \" + config.getDbPropertiesLoadedFrom());\n                throw new ConnectionFailure(\"Cannot connect to '\" + connectionURL + \"' with driver '\" + driverClass + \"'\");\n            }\n        } catch (UnsatisfiedLinkError badPath) {\n            System.err.println();\n            System.err.println(\"Failed to load driver [\" + driverClass + \"] from classpath \" + getExistingUrls(driverPath));\n            System.err.println();\n            System.err.println(\"Make sure the reported library (.dll/.lib/.so) from the following line can be\");\n            System.err.println(\"found by your PATH (or LIB*PATH) environment variable\");\n            System.err.println();\n            badPath.printStackTrace();\n            throw new ConnectionFailure(badPath);\n        } catch (Exception exc) {\n            System.err.println();\n            System.err.println(\"Failed to connect to database URL [\" + connectionURL + \"]\");\n            System.err.println();\n            exc.printStackTrace();\n            throw new ConnectionFailure(exc);\n        }\n        return connection;\n    }\n\n    /**\n     * Returns an instance of {@link Driver} specified by <code>driverClass</code>\n     * loaded from <code>driverPath</code>.\n     *\n     * @param driverClass\n     * @param driverPath\n     * @return\n     * @throws MalformedURLException\n     */\n    protected Driver getDriver(String driverClass, String driverPath) throws MalformedURLException {\n        List<URL> classpath = getExistingUrls(driverPath);\n        ClassLoader loader = getDriverClassLoader(classpath);\n        Driver driver = null;\n        try {\n            driver = (Driver) Class.forName(driverClass, true, loader).newInstance();\n            // have to use deprecated method or we won't see messages generated by older drivers\n            //java.sql.DriverManager.setLogStream(System.err);\n        } catch (Exception exc) {\n            // people don't want to see a stack trace...\n            System.err.println(exc);\n            System.err.println();\n            System.err.print(\"Failed to load driver '\" + driverClass + \"'\");\n            if (classpath.isEmpty())\n                System.err.println();\n            else\n                System.err.println(\" from: \" + classpath);\n            List<File> invalidClasspathEntries = getMissingFiles(driverPath);\n            if (!invalidClasspathEntries.isEmpty()) {\n                if (invalidClasspathEntries.size() == 1)\n                    System.err.print(\"This entry doesn't point to a valid file/directory: \");\n                else\n                    System.err.print(\"These entries don't point to valid files/directories: \");\n                System.err.println(invalidClasspathEntries);\n            }\n            System.err.println();\n            System.err.println(\"Use the -dp option to specify the location of the database\");\n            System.err.println(\"drivers for your database (usually in a .jar or .zip/.Z).\");\n            System.err.println();\n            throw new ConnectionFailure(exc);\n        }\n        return driver;\n    }\n\n    /**\n     * Returns a {@link ClassLoader class loader} to use for resolving {@link Driver}s.\n     *\n     * @param classpath\n     * @return\n     */\n    protected ClassLoader getDriverClassLoader(List<URL> classpath) {\n        ClassLoader loader = null;\n        // if a classpath has been specified then use it to find the driver,\n        // otherwise use whatever was used to load this class.\n        // thanks to Bruno Leonardo Gon�alves for this implementation that he\n        // used to resolve issues when running under Maven\n        if (classpath.size() > 0) {\n            loader = new URLClassLoader(classpath.toArray(new URL[classpath.size()]));\n        } else {\n            loader = getClass().getClassLoader();\n        }\n        return loader;\n    }\n\n    /**\n     * Returns a list of {@link URL}s in <code>path</code> that point to files that\n     * exist.\n     *\n     * @param path\n     * @return\n     * @throws MalformedURLException\n     */\n    protected List<URL> getExistingUrls(String path) throws MalformedURLException {\n        List<URL> existingUrls = new ArrayList<URL>();\n        String[] pieces = path.split(File.pathSeparator);\n        for (String piece : pieces) {\n            File file = new File(piece);\n            if (file.exists())\n                existingUrls.add(file.toURI().toURL());\n        }\n        return existingUrls;\n    }\n\n    /**\n     * Returns a list of {@link File}s in <code>path</code> that do not exist.\n     * The intent is to aid in diagnosing invalid paths.\n     *\n     * @param path\n     * @return\n     */\n    protected List<File> getMissingFiles(String path) {\n        List<File> missingFiles = new ArrayList<File>();\n        String[] pieces = path.split(File.pathSeparator);\n        for (String piece : pieces) {\n            File file = new File(piece);\n            if (!file.exists())\n                missingFiles.add(file);\n        }\n        return missingFiles;\n    }\n\n    /**\n     * Currently very DB2-specific\n     * @param recursiveConstraints List\n     * @param schema String\n     * @param out LineWriter\n     * @throws IOException\n     */\n    /* we'll eventually want to put this functionality back in with a\n     * database independent implementation\n    private static void writeRemoveRecursiveConstraintsSql(List recursiveConstraints, String schema, LineWriter out) throws IOException {\n        for (Iterator iter = recursiveConstraints.iterator(); iter.hasNext(); ) {\n            ForeignKeyConstraint constraint = (ForeignKeyConstraint)iter.next();\n            out.writeln(\"ALTER TABLE \" + schema + \".\" + constraint.getChildTable() + \" DROP CONSTRAINT \" + constraint.getName() + \";\");\n        }\n    }\n    */\n    /**\n     * Currently very DB2-specific\n     * @param recursiveConstraints List\n     * @param schema String\n     * @param out LineWriter\n     * @throws IOException\n     */\n    /* we'll eventually want to put this functionality back in with a\n     * database independent implementation\n    private static void writeRestoreRecursiveConstraintsSql(List recursiveConstraints, String schema, LineWriter out) throws IOException {\n        Map ruleTextMapping = new HashMap();\n        ruleTextMapping.put(new Character('C'), \"CASCADE\");\n        ruleTextMapping.put(new Character('A'), \"NO ACTION\");\n        ruleTextMapping.put(new Character('N'), \"NO ACTION\"); // Oracle\n        ruleTextMapping.put(new Character('R'), \"RESTRICT\");\n        ruleTextMapping.put(new Character('S'), \"SET NULL\");  // Oracle\n\n        for (Iterator iter = recursiveConstraints.iterator(); iter.hasNext(); ) {\n            ForeignKeyConstraint constraint = (ForeignKeyConstraint)iter.next();\n            out.write(\"ALTER TABLE \\\"\" + schema + \"\\\".\\\"\" + constraint.getChildTable() + \"\\\" ADD CONSTRAINT \\\"\" + constraint.getName() + \"\\\"\");\n            StringBuffer buf = new StringBuffer();\n            for (Iterator columnIter = constraint.getChildColumns().iterator(); columnIter.hasNext(); ) {\n                buf.append(\"\\\"\");\n                buf.append(columnIter.next());\n                buf.append(\"\\\"\");\n                if (columnIter.hasNext())\n                    buf.append(\",\");\n            }\n            out.write(\" FOREIGN KEY (\" + buf.toString() + \")\");\n            out.write(\" REFERENCES \\\"\" + schema + \"\\\".\\\"\" + constraint.getParentTable() + \"\\\"\");\n            buf = new StringBuffer();\n            for (Iterator columnIter = constraint.getParentColumns().iterator(); columnIter.hasNext(); ) {\n                buf.append(\"\\\"\");\n                buf.append(columnIter.next());\n                buf.append(\"\\\"\");\n                if (columnIter.hasNext())\n                    buf.append(\",\");\n            }\n            out.write(\" (\" + buf.toString() + \")\");\n            out.write(\" ON DELETE \");\n            out.write(ruleTextMapping.get(new Character(constraint.getDeleteRule())).toString());\n            out.write(\" ON UPDATE \");\n            out.write(ruleTextMapping.get(new Character(constraint.getUpdateRule())).toString());\n            out.writeln(\";\");\n        }\n    }\n    */\n    static void yankParam(List<String> args, String paramId) {\n        int paramIndex = args.indexOf(paramId);\n        if (paramIndex >= 0) {\n            args.remove(paramIndex);\n            args.remove(paramIndex);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/SchemaAnalyzerTest.java",
		"test_prompt": "// SchemaAnalyzerTest.java\npackage net.sourceforge.schemaspy;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.sql.Connection;\nimport java.sql.DatabaseMetaData;\nimport java.sql.Driver;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.logging.ConsoleHandler;\nimport java.util.logging.Handler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport net.sourceforge.schemaspy.model.ConnectionFailure;\nimport net.sourceforge.schemaspy.model.Database;\nimport net.sourceforge.schemaspy.model.EmptySchemaException;\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.model.xml.SchemaMeta;\nimport net.sourceforge.schemaspy.util.ConnectionURLBuilder;\nimport net.sourceforge.schemaspy.util.DOMUtil;\nimport net.sourceforge.schemaspy.util.DbSpecificOption;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.LineWriter;\nimport net.sourceforge.schemaspy.util.LogFormatter;\nimport net.sourceforge.schemaspy.util.ResourceWriter;\nimport net.sourceforge.schemaspy.view.DotFormatter;\nimport net.sourceforge.schemaspy.view.HtmlAnomaliesPage;\nimport net.sourceforge.schemaspy.view.HtmlColumnsPage;\nimport net.sourceforge.schemaspy.view.HtmlConstraintsPage;\nimport net.sourceforge.schemaspy.view.HtmlMainIndexPage;\nimport net.sourceforge.schemaspy.view.HtmlOrphansPage;\nimport net.sourceforge.schemaspy.view.HtmlRelationshipsPage;\nimport net.sourceforge.schemaspy.view.HtmlRoutinesPage;\nimport net.sourceforge.schemaspy.view.HtmlTablePage;\nimport net.sourceforge.schemaspy.view.ImageWriter;\nimport net.sourceforge.schemaspy.view.StyleSheet;\nimport net.sourceforge.schemaspy.view.TextFormatter;\nimport net.sourceforge.schemaspy.view.WriteStats;\nimport net.sourceforge.schemaspy.view.XmlTableFormatter;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SchemaAnalyzer}.\n* It contains ten unit test cases for the {@link SchemaAnalyzer#analyze(Config)} method.\n*/\nclass SchemaAnalyzerTest {"
	},
	{
		"original_code": "// LogicalRemoteTable.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy.model;\r\n\r\nimport java.sql.SQLException;\r\n\r\n/**\r\n * A remote table (exists in another schema (logically or physically))\r\n * that was created via XML metadata.\r\n *\r\n * @author John Currier\r\n */\r\npublic class LogicalRemoteTable extends RemoteTable {\r\n\r\n    /**\r\n     * @param db\r\n     * @param catalog\r\n     * @param schema\r\n     * @param name\r\n     * @param baseSchema\r\n     * @throws SQLException\r\n     */\r\n    public LogicalRemoteTable(Database db, String catalog, String schema, String name, String baseSchema) throws SQLException {\r\n        super(db, catalog, schema, name, baseSchema);\r\n    }\r\n\r\n    /**\r\n     * Don't attempt to query our metadata from the database.\r\n     *\r\n     * @return true\r\n     */\r\n    @Override\r\n    public boolean isLogical() {\r\n        return true;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/LogicalRemoteTableTest.java",
		"test_prompt": "// LogicalRemoteTableTest.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.SQLException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LogicalRemoteTable}.\n* It contains ten unit test cases for the {@link LogicalRemoteTable#isLogical()} method.\n*/\nclass LogicalRemoteTableTest {"
	},
	{
		"original_code": "// LogicalTable.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2011 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy.model;\r\n\r\nimport java.sql.SQLException;\r\n\r\n/**\r\n * This is a logical (versus physical) table that represents something\r\n * that doesn't really exist in the current database.\r\n *\r\n * @author John Currier\r\n */\r\npublic class LogicalTable extends Table {\r\n\r\n    public LogicalTable(Database db, String catalog, String schema, String name, String comments) throws SQLException {\r\n        super(db, catalog, schema, name, comments);\r\n    }\r\n\r\n    /**\r\n     * Don't attempt to query our metadata from the database.\r\n     *\r\n     * @return true\r\n     */\r\n    @Override\r\n    public boolean isLogical() {\r\n        return true;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/LogicalTableTest.java",
		"test_prompt": "// LogicalTableTest.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.SQLException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LogicalTable}.\n* It contains ten unit test cases for the {@link LogicalTable#isLogical()} method.\n*/\nclass LogicalTableTest {"
	},
	{
		"original_code": "// TableColumn.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\n\npublic class TableColumn {\n\n    private final Table table;\n\n    private final String name;\n\n    private final Object id;\n\n    private String type;\n\n    private String shortType;\n\n    private final int length;\n\n    private final int decimalDigits;\n\n    private final String detailedSize;\n\n    private final boolean isNullable;\n\n    private boolean isAutoUpdated;\n\n    private Boolean isUnique;\n\n    private final Object defaultValue;\n\n    private String comments;\n\n    private final Map<TableColumn, ForeignKeyConstraint> parents = new HashMap<TableColumn, ForeignKeyConstraint>();\n\n    private final Map<TableColumn, ForeignKeyConstraint> children = new TreeMap<TableColumn, ForeignKeyConstraint>(new ColumnComparator());\n\n    private boolean allowImpliedParents = true;\n\n    private boolean allowImpliedChildren = true;\n\n    private boolean isExcluded = false;\n\n    private boolean isAllExcluded = false;\n\n    private static final Logger logger = Logger.getLogger(TableColumn.class.getName());\n\n    private static final boolean finerEnabled = logger.isLoggable(Level.FINER);\n\n    /**\n     * Create a column associated with a table.\n     *\n     * @param table Table the table that this column belongs to\n     * @param rs ResultSet returned from {@link DatabaseMetaData#getColumns(String, String, String, String)}\n     * @throws SQLException\n     */\n    TableColumn(Table table, ResultSet rs) throws SQLException {\n        this.table = table;\n        // names and types are typically reused *many* times in a database,\n        // so keep a single instance of each distinct one\n        // (thanks to Mike Barnes for the suggestion)\n        String tmp = rs.getString(\"COLUMN_NAME\");\n        name = tmp == null ? null : tmp.intern();\n        tmp = rs.getString(\"TYPE_NAME\");\n        type = tmp == null ? \"unknown\" : tmp.intern();\n        decimalDigits = rs.getInt(\"DECIMAL_DIGITS\");\n        Number bufLength = (Number) rs.getObject(\"BUFFER_LENGTH\");\n        if (bufLength != null && bufLength.shortValue() > 0)\n            length = bufLength.shortValue();\n        else\n            length = rs.getInt(\"COLUMN_SIZE\");\n        StringBuilder buf = new StringBuilder();\n        buf.append(length);\n        if (decimalDigits > 0) {\n            buf.append(',');\n            buf.append(decimalDigits);\n        }\n        detailedSize = buf.toString();\n        isNullable = rs.getInt(\"NULLABLE\") == DatabaseMetaData.columnNullable;\n        defaultValue = rs.getString(\"COLUMN_DEF\");\n        setComments(rs.getString(\"REMARKS\"));\n        id = new Integer(rs.getInt(\"ORDINAL_POSITION\") - 1);\n        Pattern excludeIndirectColumns = Config.getInstance().getIndirectColumnExclusions();\n        Pattern excludeColumns = Config.getInstance().getColumnExclusions();\n        isAllExcluded = matches(excludeColumns);\n        isExcluded = isAllExcluded || matches(excludeIndirectColumns);\n        if (isExcluded && finerEnabled) {\n            logger.finer(\"Excluding column \" + getTable() + '.' + getName() + \": matches \" + excludeColumns + \":\" + isAllExcluded + \" \" + excludeIndirectColumns + \":\" + matches(excludeIndirectColumns));\n        }\n    }\n\n    /**\n     * A TableColumn that's derived from something other than traditional database metadata\n     * (e.g. defined in XML).\n     *\n     * @param table\n     * @param colMeta\n     */\n    public TableColumn(Table table, TableColumnMeta colMeta) {\n        this.table = table;\n        name = colMeta.getName();\n        id = colMeta.getId();\n        type = colMeta.getType();\n        length = colMeta.getSize();\n        decimalDigits = colMeta.getDigits();\n        StringBuilder buf = new StringBuilder();\n        buf.append(length);\n        if (decimalDigits > 0) {\n            buf.append(',');\n            buf.append(decimalDigits);\n        }\n        detailedSize = buf.toString();\n        isNullable = colMeta.isNullable();\n        isAutoUpdated = colMeta.isAutoUpdated();\n        defaultValue = colMeta.getDefaultValue();\n        comments = colMeta.getComments();\n    }\n\n    /**\n     * Returns the {@link Table} that this column belongs to.\n     *\n     * @return\n     */\n    public Table getTable() {\n        return table;\n    }\n\n    /**\n     * Returns the column's name.\n     *\n     * @return\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the ID of the column or <code>null</code> if the database doesn't support the concept.\n     *\n     * @return\n     */\n    public Object getId() {\n        return id;\n    }\n\n    /**\n     * Type of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>TYPE_NAME</code>.\n     * @return\n     */\n    public String getType() {\n        return type;\n    }\n\n    /**\n     * Normally only used for \"special\" types such as enums.\n     *\n     * @param type\n     */\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    /**\n     * Abbreviated form of {@link #getType()}\n     *\n     * @return\n     */\n    public String getShortType() {\n        return shortType == null ? type : shortType;\n    }\n\n    /**\n     * Abbreviated form of {@link #setType(String)}\n     *\n     * @param shortType\n     */\n    public void setShortType(String shortType) {\n        this.shortType = shortType;\n    }\n\n    /**\n     * Length of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>BUFFER_LENGTH</code>,\n     * or if that's <code>null</code>, <code>COLUMN_SIZE</code>.\n     * @return\n     */\n    public int getLength() {\n        return length;\n    }\n\n    /**\n     * Decimal digits of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>DECIMAL_DIGITS</code>.\n     *\n     * @return\n     */\n    public int getDecimalDigits() {\n        return decimalDigits;\n    }\n\n    /**\n     * String representation of length with optional decimal digits (if decimal digits &gt; 0).\n     *\n     * @return\n     */\n    public String getDetailedSize() {\n        return detailedSize;\n    }\n\n    /**\n     * Returns <code>true</code> if null values are allowed\n     *\n     * @return\n     */\n    public boolean isNullable() {\n        return isNullable;\n    }\n\n    /**\n     * See {@link java.sql.ResultSetMetaData#isAutoIncrement(int)}\n     *\n     * @return\n     */\n    public boolean isAutoUpdated() {\n        return isAutoUpdated;\n    }\n\n    /**\n     * setIsAutoUpdated\n     *\n     * @param isAutoUpdated boolean\n     */\n    public void setIsAutoUpdated(boolean isAutoUpdated) {\n        this.isAutoUpdated = isAutoUpdated;\n    }\n\n    /**\n     * Returns <code>true</code> if this column can only contain unique values\n     *\n     * @return\n     */\n    public boolean isUnique() {\n        if (isUnique == null) {\n            // see if there's a unique index on this column by itself\n            for (TableIndex index : table.getIndexes()) {\n                if (index.isUnique()) {\n                    List<TableColumn> indexColumns = index.getColumns();\n                    if (indexColumns.size() == 1 && indexColumns.contains(this)) {\n                        isUnique = true;\n                        break;\n                    }\n                }\n            }\n            if (isUnique == null) {\n                // if it's a single PK column then it's unique\n                isUnique = table.getPrimaryColumns().size() == 1 && isPrimary();\n            }\n        }\n        return isUnique;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is a primary key\n     *\n     * @return\n     */\n    public boolean isPrimary() {\n        return table.getPrimaryColumns().contains(this);\n    }\n\n    /**\n     * Returns <code>true</code> if this column points to another table's primary key.\n     *\n     * @return\n     */\n    public boolean isForeignKey() {\n        return !parents.isEmpty();\n    }\n\n    /**\n     * Returns the value that the database uses for this column if one isn't provided.\n     *\n     * @return\n     */\n    public Object getDefaultValue() {\n        return defaultValue;\n    }\n\n    /**\n     * @return Comments associated with this column, or <code>null</code> if none.\n     */\n    public String getComments() {\n        return comments;\n    }\n\n    /**\n     * See {@link #getComments()}\n     * @param comments\n     */\n    public void setComments(String comments) {\n        this.comments = (comments == null || comments.trim().length() == 0) ? null : comments.trim();\n    }\n\n    /**\n     * Returns <code>true</code> if this column is to be excluded from relationship diagrams.\n     * Unless {@link #isAllExcluded()} is true this column will be included in the detailed\n     * diagrams of the containing table.\n     *\n     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables\n     * reference a given column.\n     *\n     * @return\n     */\n    public boolean isExcluded() {\n        return isExcluded;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is to be excluded from all relationships in\n     * relationship diagrams.  This includes the detailed diagrams of the containing table.\n     *\n     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables\n     * reference a given column.\n     *\n     * @return\n     */\n    public boolean isAllExcluded() {\n        return isAllExcluded;\n    }\n\n    /**\n     * Add a parent column (PK) to this column (FK) via the associated constraint\n     *\n     * @param parent\n     * @param constraint\n     */\n    public void addParent(TableColumn parent, ForeignKeyConstraint constraint) {\n        parents.put(parent, constraint);\n        table.addedParent();\n    }\n\n    /**\n     * Remove the specified parent column from this column\n     *\n     * @param parent\n     */\n    public void removeParent(TableColumn parent) {\n        parents.remove(parent);\n    }\n\n    /**\n     * Disassociate all parents from this column\n     */\n    public void unlinkParents() {\n        for (TableColumn parent : parents.keySet()) {\n            parent.removeChild(this);\n        }\n        parents.clear();\n    }\n\n    /**\n     * Returns the {@link Set} of all {@link TableColumn parents} associated with this column\n     *\n     * @return\n     */\n    public Set<TableColumn> getParents() {\n        return parents.keySet();\n    }\n\n    /**\n     * Returns the constraint that connects this column to the specified column (this 'child' column to specified 'parent' column)\n     */\n    public ForeignKeyConstraint getParentConstraint(TableColumn parent) {\n        return parents.get(parent);\n    }\n\n    /**\n     * Removes a parent constraint and returns it, or null if there are no parent constraints\n     *\n     * @return the removed {@link ForeignKeyConstraint}\n     */\n    public ForeignKeyConstraint removeAParentFKConstraint() {\n        for (TableColumn relatedColumn : parents.keySet()) {\n            ForeignKeyConstraint constraint = parents.remove(relatedColumn);\n            relatedColumn.removeChild(this);\n            return constraint;\n        }\n        return null;\n    }\n\n    /**\n     * Remove one child {@link ForeignKeyConstraint} that points to this column.\n     *\n     * @return the removed constraint, or <code>null</code> if none were available to be removed\n     */\n    public ForeignKeyConstraint removeAChildFKConstraint() {\n        for (TableColumn relatedColumn : children.keySet()) {\n            ForeignKeyConstraint constraint = children.remove(relatedColumn);\n            relatedColumn.removeParent(this);\n            return constraint;\n        }\n        return null;\n    }\n\n    /**\n     * Add a child column (FK) to this column (PK) via the associated constraint\n     *\n     * @param child\n     * @param constraint\n     */\n    public void addChild(TableColumn child, ForeignKeyConstraint constraint) {\n        children.put(child, constraint);\n        table.addedChild();\n    }\n\n    /**\n     * Remove the specified child column from this column\n     *\n     * @param child\n     */\n    public void removeChild(TableColumn child) {\n        children.remove(child);\n    }\n\n    /**\n     * Disassociate all children from this column\n     */\n    public void unlinkChildren() {\n        for (TableColumn child : children.keySet()) child.removeParent(this);\n        children.clear();\n    }\n\n    /**\n     * Returns <code>Set</code> of <code>TableColumn</code>s that have a real (or implied) foreign key that\n     * references this <code>TableColumn</code>.\n     * @return Set\n     */\n    public Set<TableColumn> getChildren() {\n        return children.keySet();\n    }\n\n    /**\n     * returns the constraint that connects the specified column to this column\n     * (specified 'child' to this 'parent' column)\n     */\n    public ForeignKeyConstraint getChildConstraint(TableColumn child) {\n        return children.get(child);\n    }\n\n    /**\n     * Returns <code>true</code> if tableName.columnName matches the supplied\n     * regular expression.\n     *\n     * @param regex\n     * @return\n     */\n    public boolean matches(Pattern regex) {\n        return regex.matcher(getTable().getName() + '.' + getName()).matches();\n    }\n\n    /**\n     * Update the state of this column with the supplied {@link TableColumnMeta}.\n     * Intended to be used with instances created by {@link #TableColumn(Table, TableColumnMeta)}.\n     *\n     * @param colMeta\n     */\n    public void update(TableColumnMeta colMeta) {\n        String newComments = colMeta.getComments();\n        if (newComments != null)\n            setComments(newComments);\n        if (!isPrimary() && colMeta.isPrimary()) {\n            table.setPrimaryColumn(this);\n        }\n        allowImpliedParents = !colMeta.isImpliedParentsDisabled();\n        allowImpliedChildren = !colMeta.isImpliedChildrenDisabled();\n        isExcluded |= colMeta.isExcluded();\n        isAllExcluded |= colMeta.isAllExcluded();\n    }\n\n    /**\n     * Returns the name of this column.\n     */\n    @Override\n    public String toString() {\n        return getName();\n    }\n\n    /**\n     * Two {@link TableColumn}s are considered equal if their tables and names match.\n     */\n    private class ColumnComparator implements Comparator<TableColumn> {\n\n        public int compare(TableColumn column1, TableColumn column2) {\n            int rc = column1.getTable().compareTo(column2.getTable());\n            if (rc == 0)\n                rc = column1.getName().compareToIgnoreCase(column2.getName());\n            return rc;\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if this column is permitted to be an implied FK\n     * (based on name/type/size matches to PKs).\n     *\n     * @return\n     */\n    public boolean allowsImpliedParents() {\n        return allowImpliedParents;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is permitted to be a PK to an implied FK\n     * (based on name/type/size matches to PKs).\n     *\n     * @return\n     */\n    public boolean allowsImpliedChildren() {\n        return allowImpliedChildren;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableColumnTest0.java",
		"test_prompt": "// TableColumnTest0.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TableColumn}.\n* It contains ten unit test cases for the {@link TableColumn#isNullable()} method.\n*/\nclass TableColumnTest0 {"
	},
	{
		"original_code": "// TableColumn.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\n\npublic class TableColumn {\n\n    private final Table table;\n\n    private final String name;\n\n    private final Object id;\n\n    private String type;\n\n    private String shortType;\n\n    private final int length;\n\n    private final int decimalDigits;\n\n    private final String detailedSize;\n\n    private final boolean isNullable;\n\n    private boolean isAutoUpdated;\n\n    private Boolean isUnique;\n\n    private final Object defaultValue;\n\n    private String comments;\n\n    private final Map<TableColumn, ForeignKeyConstraint> parents = new HashMap<TableColumn, ForeignKeyConstraint>();\n\n    private final Map<TableColumn, ForeignKeyConstraint> children = new TreeMap<TableColumn, ForeignKeyConstraint>(new ColumnComparator());\n\n    private boolean allowImpliedParents = true;\n\n    private boolean allowImpliedChildren = true;\n\n    private boolean isExcluded = false;\n\n    private boolean isAllExcluded = false;\n\n    private static final Logger logger = Logger.getLogger(TableColumn.class.getName());\n\n    private static final boolean finerEnabled = logger.isLoggable(Level.FINER);\n\n    /**\n     * Create a column associated with a table.\n     *\n     * @param table Table the table that this column belongs to\n     * @param rs ResultSet returned from {@link DatabaseMetaData#getColumns(String, String, String, String)}\n     * @throws SQLException\n     */\n    TableColumn(Table table, ResultSet rs) throws SQLException {\n        this.table = table;\n        // names and types are typically reused *many* times in a database,\n        // so keep a single instance of each distinct one\n        // (thanks to Mike Barnes for the suggestion)\n        String tmp = rs.getString(\"COLUMN_NAME\");\n        name = tmp == null ? null : tmp.intern();\n        tmp = rs.getString(\"TYPE_NAME\");\n        type = tmp == null ? \"unknown\" : tmp.intern();\n        decimalDigits = rs.getInt(\"DECIMAL_DIGITS\");\n        Number bufLength = (Number) rs.getObject(\"BUFFER_LENGTH\");\n        if (bufLength != null && bufLength.shortValue() > 0)\n            length = bufLength.shortValue();\n        else\n            length = rs.getInt(\"COLUMN_SIZE\");\n        StringBuilder buf = new StringBuilder();\n        buf.append(length);\n        if (decimalDigits > 0) {\n            buf.append(',');\n            buf.append(decimalDigits);\n        }\n        detailedSize = buf.toString();\n        isNullable = rs.getInt(\"NULLABLE\") == DatabaseMetaData.columnNullable;\n        defaultValue = rs.getString(\"COLUMN_DEF\");\n        setComments(rs.getString(\"REMARKS\"));\n        id = new Integer(rs.getInt(\"ORDINAL_POSITION\") - 1);\n        Pattern excludeIndirectColumns = Config.getInstance().getIndirectColumnExclusions();\n        Pattern excludeColumns = Config.getInstance().getColumnExclusions();\n        isAllExcluded = matches(excludeColumns);\n        isExcluded = isAllExcluded || matches(excludeIndirectColumns);\n        if (isExcluded && finerEnabled) {\n            logger.finer(\"Excluding column \" + getTable() + '.' + getName() + \": matches \" + excludeColumns + \":\" + isAllExcluded + \" \" + excludeIndirectColumns + \":\" + matches(excludeIndirectColumns));\n        }\n    }\n\n    /**\n     * A TableColumn that's derived from something other than traditional database metadata\n     * (e.g. defined in XML).\n     *\n     * @param table\n     * @param colMeta\n     */\n    public TableColumn(Table table, TableColumnMeta colMeta) {\n        this.table = table;\n        name = colMeta.getName();\n        id = colMeta.getId();\n        type = colMeta.getType();\n        length = colMeta.getSize();\n        decimalDigits = colMeta.getDigits();\n        StringBuilder buf = new StringBuilder();\n        buf.append(length);\n        if (decimalDigits > 0) {\n            buf.append(',');\n            buf.append(decimalDigits);\n        }\n        detailedSize = buf.toString();\n        isNullable = colMeta.isNullable();\n        isAutoUpdated = colMeta.isAutoUpdated();\n        defaultValue = colMeta.getDefaultValue();\n        comments = colMeta.getComments();\n    }\n\n    /**\n     * Returns the {@link Table} that this column belongs to.\n     *\n     * @return\n     */\n    public Table getTable() {\n        return table;\n    }\n\n    /**\n     * Returns the column's name.\n     *\n     * @return\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the ID of the column or <code>null</code> if the database doesn't support the concept.\n     *\n     * @return\n     */\n    public Object getId() {\n        return id;\n    }\n\n    /**\n     * Type of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>TYPE_NAME</code>.\n     * @return\n     */\n    public String getType() {\n        return type;\n    }\n\n    /**\n     * Normally only used for \"special\" types such as enums.\n     *\n     * @param type\n     */\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    /**\n     * Abbreviated form of {@link #getType()}\n     *\n     * @return\n     */\n    public String getShortType() {\n        return shortType == null ? type : shortType;\n    }\n\n    /**\n     * Abbreviated form of {@link #setType(String)}\n     *\n     * @param shortType\n     */\n    public void setShortType(String shortType) {\n        this.shortType = shortType;\n    }\n\n    /**\n     * Length of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>BUFFER_LENGTH</code>,\n     * or if that's <code>null</code>, <code>COLUMN_SIZE</code>.\n     * @return\n     */\n    public int getLength() {\n        return length;\n    }\n\n    /**\n     * Decimal digits of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>DECIMAL_DIGITS</code>.\n     *\n     * @return\n     */\n    public int getDecimalDigits() {\n        return decimalDigits;\n    }\n\n    /**\n     * String representation of length with optional decimal digits (if decimal digits &gt; 0).\n     *\n     * @return\n     */\n    public String getDetailedSize() {\n        return detailedSize;\n    }\n\n    /**\n     * Returns <code>true</code> if null values are allowed\n     *\n     * @return\n     */\n    public boolean isNullable() {\n        return isNullable;\n    }\n\n    /**\n     * See {@link java.sql.ResultSetMetaData#isAutoIncrement(int)}\n     *\n     * @return\n     */\n    public boolean isAutoUpdated() {\n        return isAutoUpdated;\n    }\n\n    /**\n     * setIsAutoUpdated\n     *\n     * @param isAutoUpdated boolean\n     */\n    public void setIsAutoUpdated(boolean isAutoUpdated) {\n        this.isAutoUpdated = isAutoUpdated;\n    }\n\n    /**\n     * Returns <code>true</code> if this column can only contain unique values\n     *\n     * @return\n     */\n    public boolean isUnique() {\n        if (isUnique == null) {\n            // see if there's a unique index on this column by itself\n            for (TableIndex index : table.getIndexes()) {\n                if (index.isUnique()) {\n                    List<TableColumn> indexColumns = index.getColumns();\n                    if (indexColumns.size() == 1 && indexColumns.contains(this)) {\n                        isUnique = true;\n                        break;\n                    }\n                }\n            }\n            if (isUnique == null) {\n                // if it's a single PK column then it's unique\n                isUnique = table.getPrimaryColumns().size() == 1 && isPrimary();\n            }\n        }\n        return isUnique;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is a primary key\n     *\n     * @return\n     */\n    public boolean isPrimary() {\n        return table.getPrimaryColumns().contains(this);\n    }\n\n    /**\n     * Returns <code>true</code> if this column points to another table's primary key.\n     *\n     * @return\n     */\n    public boolean isForeignKey() {\n        return !parents.isEmpty();\n    }\n\n    /**\n     * Returns the value that the database uses for this column if one isn't provided.\n     *\n     * @return\n     */\n    public Object getDefaultValue() {\n        return defaultValue;\n    }\n\n    /**\n     * @return Comments associated with this column, or <code>null</code> if none.\n     */\n    public String getComments() {\n        return comments;\n    }\n\n    /**\n     * See {@link #getComments()}\n     * @param comments\n     */\n    public void setComments(String comments) {\n        this.comments = (comments == null || comments.trim().length() == 0) ? null : comments.trim();\n    }\n\n    /**\n     * Returns <code>true</code> if this column is to be excluded from relationship diagrams.\n     * Unless {@link #isAllExcluded()} is true this column will be included in the detailed\n     * diagrams of the containing table.\n     *\n     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables\n     * reference a given column.\n     *\n     * @return\n     */\n    public boolean isExcluded() {\n        return isExcluded;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is to be excluded from all relationships in\n     * relationship diagrams.  This includes the detailed diagrams of the containing table.\n     *\n     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables\n     * reference a given column.\n     *\n     * @return\n     */\n    public boolean isAllExcluded() {\n        return isAllExcluded;\n    }\n\n    /**\n     * Add a parent column (PK) to this column (FK) via the associated constraint\n     *\n     * @param parent\n     * @param constraint\n     */\n    public void addParent(TableColumn parent, ForeignKeyConstraint constraint) {\n        parents.put(parent, constraint);\n        table.addedParent();\n    }\n\n    /**\n     * Remove the specified parent column from this column\n     *\n     * @param parent\n     */\n    public void removeParent(TableColumn parent) {\n        parents.remove(parent);\n    }\n\n    /**\n     * Disassociate all parents from this column\n     */\n    public void unlinkParents() {\n        for (TableColumn parent : parents.keySet()) {\n            parent.removeChild(this);\n        }\n        parents.clear();\n    }\n\n    /**\n     * Returns the {@link Set} of all {@link TableColumn parents} associated with this column\n     *\n     * @return\n     */\n    public Set<TableColumn> getParents() {\n        return parents.keySet();\n    }\n\n    /**\n     * Returns the constraint that connects this column to the specified column (this 'child' column to specified 'parent' column)\n     */\n    public ForeignKeyConstraint getParentConstraint(TableColumn parent) {\n        return parents.get(parent);\n    }\n\n    /**\n     * Removes a parent constraint and returns it, or null if there are no parent constraints\n     *\n     * @return the removed {@link ForeignKeyConstraint}\n     */\n    public ForeignKeyConstraint removeAParentFKConstraint() {\n        for (TableColumn relatedColumn : parents.keySet()) {\n            ForeignKeyConstraint constraint = parents.remove(relatedColumn);\n            relatedColumn.removeChild(this);\n            return constraint;\n        }\n        return null;\n    }\n\n    /**\n     * Remove one child {@link ForeignKeyConstraint} that points to this column.\n     *\n     * @return the removed constraint, or <code>null</code> if none were available to be removed\n     */\n    public ForeignKeyConstraint removeAChildFKConstraint() {\n        for (TableColumn relatedColumn : children.keySet()) {\n            ForeignKeyConstraint constraint = children.remove(relatedColumn);\n            relatedColumn.removeParent(this);\n            return constraint;\n        }\n        return null;\n    }\n\n    /**\n     * Add a child column (FK) to this column (PK) via the associated constraint\n     *\n     * @param child\n     * @param constraint\n     */\n    public void addChild(TableColumn child, ForeignKeyConstraint constraint) {\n        children.put(child, constraint);\n        table.addedChild();\n    }\n\n    /**\n     * Remove the specified child column from this column\n     *\n     * @param child\n     */\n    public void removeChild(TableColumn child) {\n        children.remove(child);\n    }\n\n    /**\n     * Disassociate all children from this column\n     */\n    public void unlinkChildren() {\n        for (TableColumn child : children.keySet()) child.removeParent(this);\n        children.clear();\n    }\n\n    /**\n     * Returns <code>Set</code> of <code>TableColumn</code>s that have a real (or implied) foreign key that\n     * references this <code>TableColumn</code>.\n     * @return Set\n     */\n    public Set<TableColumn> getChildren() {\n        return children.keySet();\n    }\n\n    /**\n     * returns the constraint that connects the specified column to this column\n     * (specified 'child' to this 'parent' column)\n     */\n    public ForeignKeyConstraint getChildConstraint(TableColumn child) {\n        return children.get(child);\n    }\n\n    /**\n     * Returns <code>true</code> if tableName.columnName matches the supplied\n     * regular expression.\n     *\n     * @param regex\n     * @return\n     */\n    public boolean matches(Pattern regex) {\n        return regex.matcher(getTable().getName() + '.' + getName()).matches();\n    }\n\n    /**\n     * Update the state of this column with the supplied {@link TableColumnMeta}.\n     * Intended to be used with instances created by {@link #TableColumn(Table, TableColumnMeta)}.\n     *\n     * @param colMeta\n     */\n    public void update(TableColumnMeta colMeta) {\n        String newComments = colMeta.getComments();\n        if (newComments != null)\n            setComments(newComments);\n        if (!isPrimary() && colMeta.isPrimary()) {\n            table.setPrimaryColumn(this);\n        }\n        allowImpliedParents = !colMeta.isImpliedParentsDisabled();\n        allowImpliedChildren = !colMeta.isImpliedChildrenDisabled();\n        isExcluded |= colMeta.isExcluded();\n        isAllExcluded |= colMeta.isAllExcluded();\n    }\n\n    /**\n     * Returns the name of this column.\n     */\n    @Override\n    public String toString() {\n        return getName();\n    }\n\n    /**\n     * Two {@link TableColumn}s are considered equal if their tables and names match.\n     */\n    private class ColumnComparator implements Comparator<TableColumn> {\n\n        public int compare(TableColumn column1, TableColumn column2) {\n            int rc = column1.getTable().compareTo(column2.getTable());\n            if (rc == 0)\n                rc = column1.getName().compareToIgnoreCase(column2.getName());\n            return rc;\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if this column is permitted to be an implied FK\n     * (based on name/type/size matches to PKs).\n     *\n     * @return\n     */\n    public boolean allowsImpliedParents() {\n        return allowImpliedParents;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is permitted to be a PK to an implied FK\n     * (based on name/type/size matches to PKs).\n     *\n     * @return\n     */\n    public boolean allowsImpliedChildren() {\n        return allowImpliedChildren;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableColumnTest1.java",
		"test_prompt": "// TableColumnTest1.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TableColumn}.\n* It contains ten unit test cases for the {@link TableColumn#isAutoUpdated()} method.\n*/\nclass TableColumnTest1 {"
	},
	{
		"original_code": "// TableColumn.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\n\npublic class TableColumn {\n\n    private final Table table;\n\n    private final String name;\n\n    private final Object id;\n\n    private String type;\n\n    private String shortType;\n\n    private final int length;\n\n    private final int decimalDigits;\n\n    private final String detailedSize;\n\n    private final boolean isNullable;\n\n    private boolean isAutoUpdated;\n\n    private Boolean isUnique;\n\n    private final Object defaultValue;\n\n    private String comments;\n\n    private final Map<TableColumn, ForeignKeyConstraint> parents = new HashMap<TableColumn, ForeignKeyConstraint>();\n\n    private final Map<TableColumn, ForeignKeyConstraint> children = new TreeMap<TableColumn, ForeignKeyConstraint>(new ColumnComparator());\n\n    private boolean allowImpliedParents = true;\n\n    private boolean allowImpliedChildren = true;\n\n    private boolean isExcluded = false;\n\n    private boolean isAllExcluded = false;\n\n    private static final Logger logger = Logger.getLogger(TableColumn.class.getName());\n\n    private static final boolean finerEnabled = logger.isLoggable(Level.FINER);\n\n    /**\n     * Create a column associated with a table.\n     *\n     * @param table Table the table that this column belongs to\n     * @param rs ResultSet returned from {@link DatabaseMetaData#getColumns(String, String, String, String)}\n     * @throws SQLException\n     */\n    TableColumn(Table table, ResultSet rs) throws SQLException {\n        this.table = table;\n        // names and types are typically reused *many* times in a database,\n        // so keep a single instance of each distinct one\n        // (thanks to Mike Barnes for the suggestion)\n        String tmp = rs.getString(\"COLUMN_NAME\");\n        name = tmp == null ? null : tmp.intern();\n        tmp = rs.getString(\"TYPE_NAME\");\n        type = tmp == null ? \"unknown\" : tmp.intern();\n        decimalDigits = rs.getInt(\"DECIMAL_DIGITS\");\n        Number bufLength = (Number) rs.getObject(\"BUFFER_LENGTH\");\n        if (bufLength != null && bufLength.shortValue() > 0)\n            length = bufLength.shortValue();\n        else\n            length = rs.getInt(\"COLUMN_SIZE\");\n        StringBuilder buf = new StringBuilder();\n        buf.append(length);\n        if (decimalDigits > 0) {\n            buf.append(',');\n            buf.append(decimalDigits);\n        }\n        detailedSize = buf.toString();\n        isNullable = rs.getInt(\"NULLABLE\") == DatabaseMetaData.columnNullable;\n        defaultValue = rs.getString(\"COLUMN_DEF\");\n        setComments(rs.getString(\"REMARKS\"));\n        id = new Integer(rs.getInt(\"ORDINAL_POSITION\") - 1);\n        Pattern excludeIndirectColumns = Config.getInstance().getIndirectColumnExclusions();\n        Pattern excludeColumns = Config.getInstance().getColumnExclusions();\n        isAllExcluded = matches(excludeColumns);\n        isExcluded = isAllExcluded || matches(excludeIndirectColumns);\n        if (isExcluded && finerEnabled) {\n            logger.finer(\"Excluding column \" + getTable() + '.' + getName() + \": matches \" + excludeColumns + \":\" + isAllExcluded + \" \" + excludeIndirectColumns + \":\" + matches(excludeIndirectColumns));\n        }\n    }\n\n    /**\n     * A TableColumn that's derived from something other than traditional database metadata\n     * (e.g. defined in XML).\n     *\n     * @param table\n     * @param colMeta\n     */\n    public TableColumn(Table table, TableColumnMeta colMeta) {\n        this.table = table;\n        name = colMeta.getName();\n        id = colMeta.getId();\n        type = colMeta.getType();\n        length = colMeta.getSize();\n        decimalDigits = colMeta.getDigits();\n        StringBuilder buf = new StringBuilder();\n        buf.append(length);\n        if (decimalDigits > 0) {\n            buf.append(',');\n            buf.append(decimalDigits);\n        }\n        detailedSize = buf.toString();\n        isNullable = colMeta.isNullable();\n        isAutoUpdated = colMeta.isAutoUpdated();\n        defaultValue = colMeta.getDefaultValue();\n        comments = colMeta.getComments();\n    }\n\n    /**\n     * Returns the {@link Table} that this column belongs to.\n     *\n     * @return\n     */\n    public Table getTable() {\n        return table;\n    }\n\n    /**\n     * Returns the column's name.\n     *\n     * @return\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the ID of the column or <code>null</code> if the database doesn't support the concept.\n     *\n     * @return\n     */\n    public Object getId() {\n        return id;\n    }\n\n    /**\n     * Type of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>TYPE_NAME</code>.\n     * @return\n     */\n    public String getType() {\n        return type;\n    }\n\n    /**\n     * Normally only used for \"special\" types such as enums.\n     *\n     * @param type\n     */\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    /**\n     * Abbreviated form of {@link #getType()}\n     *\n     * @return\n     */\n    public String getShortType() {\n        return shortType == null ? type : shortType;\n    }\n\n    /**\n     * Abbreviated form of {@link #setType(String)}\n     *\n     * @param shortType\n     */\n    public void setShortType(String shortType) {\n        this.shortType = shortType;\n    }\n\n    /**\n     * Length of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>BUFFER_LENGTH</code>,\n     * or if that's <code>null</code>, <code>COLUMN_SIZE</code>.\n     * @return\n     */\n    public int getLength() {\n        return length;\n    }\n\n    /**\n     * Decimal digits of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>DECIMAL_DIGITS</code>.\n     *\n     * @return\n     */\n    public int getDecimalDigits() {\n        return decimalDigits;\n    }\n\n    /**\n     * String representation of length with optional decimal digits (if decimal digits &gt; 0).\n     *\n     * @return\n     */\n    public String getDetailedSize() {\n        return detailedSize;\n    }\n\n    /**\n     * Returns <code>true</code> if null values are allowed\n     *\n     * @return\n     */\n    public boolean isNullable() {\n        return isNullable;\n    }\n\n    /**\n     * See {@link java.sql.ResultSetMetaData#isAutoIncrement(int)}\n     *\n     * @return\n     */\n    public boolean isAutoUpdated() {\n        return isAutoUpdated;\n    }\n\n    /**\n     * setIsAutoUpdated\n     *\n     * @param isAutoUpdated boolean\n     */\n    public void setIsAutoUpdated(boolean isAutoUpdated) {\n        this.isAutoUpdated = isAutoUpdated;\n    }\n\n    /**\n     * Returns <code>true</code> if this column can only contain unique values\n     *\n     * @return\n     */\n    public boolean isUnique() {\n        if (isUnique == null) {\n            // see if there's a unique index on this column by itself\n            for (TableIndex index : table.getIndexes()) {\n                if (index.isUnique()) {\n                    List<TableColumn> indexColumns = index.getColumns();\n                    if (indexColumns.size() == 1 && indexColumns.contains(this)) {\n                        isUnique = true;\n                        break;\n                    }\n                }\n            }\n            if (isUnique == null) {\n                // if it's a single PK column then it's unique\n                isUnique = table.getPrimaryColumns().size() == 1 && isPrimary();\n            }\n        }\n        return isUnique;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is a primary key\n     *\n     * @return\n     */\n    public boolean isPrimary() {\n        return table.getPrimaryColumns().contains(this);\n    }\n\n    /**\n     * Returns <code>true</code> if this column points to another table's primary key.\n     *\n     * @return\n     */\n    public boolean isForeignKey() {\n        return !parents.isEmpty();\n    }\n\n    /**\n     * Returns the value that the database uses for this column if one isn't provided.\n     *\n     * @return\n     */\n    public Object getDefaultValue() {\n        return defaultValue;\n    }\n\n    /**\n     * @return Comments associated with this column, or <code>null</code> if none.\n     */\n    public String getComments() {\n        return comments;\n    }\n\n    /**\n     * See {@link #getComments()}\n     * @param comments\n     */\n    public void setComments(String comments) {\n        this.comments = (comments == null || comments.trim().length() == 0) ? null : comments.trim();\n    }\n\n    /**\n     * Returns <code>true</code> if this column is to be excluded from relationship diagrams.\n     * Unless {@link #isAllExcluded()} is true this column will be included in the detailed\n     * diagrams of the containing table.\n     *\n     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables\n     * reference a given column.\n     *\n     * @return\n     */\n    public boolean isExcluded() {\n        return isExcluded;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is to be excluded from all relationships in\n     * relationship diagrams.  This includes the detailed diagrams of the containing table.\n     *\n     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables\n     * reference a given column.\n     *\n     * @return\n     */\n    public boolean isAllExcluded() {\n        return isAllExcluded;\n    }\n\n    /**\n     * Add a parent column (PK) to this column (FK) via the associated constraint\n     *\n     * @param parent\n     * @param constraint\n     */\n    public void addParent(TableColumn parent, ForeignKeyConstraint constraint) {\n        parents.put(parent, constraint);\n        table.addedParent();\n    }\n\n    /**\n     * Remove the specified parent column from this column\n     *\n     * @param parent\n     */\n    public void removeParent(TableColumn parent) {\n        parents.remove(parent);\n    }\n\n    /**\n     * Disassociate all parents from this column\n     */\n    public void unlinkParents() {\n        for (TableColumn parent : parents.keySet()) {\n            parent.removeChild(this);\n        }\n        parents.clear();\n    }\n\n    /**\n     * Returns the {@link Set} of all {@link TableColumn parents} associated with this column\n     *\n     * @return\n     */\n    public Set<TableColumn> getParents() {\n        return parents.keySet();\n    }\n\n    /**\n     * Returns the constraint that connects this column to the specified column (this 'child' column to specified 'parent' column)\n     */\n    public ForeignKeyConstraint getParentConstraint(TableColumn parent) {\n        return parents.get(parent);\n    }\n\n    /**\n     * Removes a parent constraint and returns it, or null if there are no parent constraints\n     *\n     * @return the removed {@link ForeignKeyConstraint}\n     */\n    public ForeignKeyConstraint removeAParentFKConstraint() {\n        for (TableColumn relatedColumn : parents.keySet()) {\n            ForeignKeyConstraint constraint = parents.remove(relatedColumn);\n            relatedColumn.removeChild(this);\n            return constraint;\n        }\n        return null;\n    }\n\n    /**\n     * Remove one child {@link ForeignKeyConstraint} that points to this column.\n     *\n     * @return the removed constraint, or <code>null</code> if none were available to be removed\n     */\n    public ForeignKeyConstraint removeAChildFKConstraint() {\n        for (TableColumn relatedColumn : children.keySet()) {\n            ForeignKeyConstraint constraint = children.remove(relatedColumn);\n            relatedColumn.removeParent(this);\n            return constraint;\n        }\n        return null;\n    }\n\n    /**\n     * Add a child column (FK) to this column (PK) via the associated constraint\n     *\n     * @param child\n     * @param constraint\n     */\n    public void addChild(TableColumn child, ForeignKeyConstraint constraint) {\n        children.put(child, constraint);\n        table.addedChild();\n    }\n\n    /**\n     * Remove the specified child column from this column\n     *\n     * @param child\n     */\n    public void removeChild(TableColumn child) {\n        children.remove(child);\n    }\n\n    /**\n     * Disassociate all children from this column\n     */\n    public void unlinkChildren() {\n        for (TableColumn child : children.keySet()) child.removeParent(this);\n        children.clear();\n    }\n\n    /**\n     * Returns <code>Set</code> of <code>TableColumn</code>s that have a real (or implied) foreign key that\n     * references this <code>TableColumn</code>.\n     * @return Set\n     */\n    public Set<TableColumn> getChildren() {\n        return children.keySet();\n    }\n\n    /**\n     * returns the constraint that connects the specified column to this column\n     * (specified 'child' to this 'parent' column)\n     */\n    public ForeignKeyConstraint getChildConstraint(TableColumn child) {\n        return children.get(child);\n    }\n\n    /**\n     * Returns <code>true</code> if tableName.columnName matches the supplied\n     * regular expression.\n     *\n     * @param regex\n     * @return\n     */\n    public boolean matches(Pattern regex) {\n        return regex.matcher(getTable().getName() + '.' + getName()).matches();\n    }\n\n    /**\n     * Update the state of this column with the supplied {@link TableColumnMeta}.\n     * Intended to be used with instances created by {@link #TableColumn(Table, TableColumnMeta)}.\n     *\n     * @param colMeta\n     */\n    public void update(TableColumnMeta colMeta) {\n        String newComments = colMeta.getComments();\n        if (newComments != null)\n            setComments(newComments);\n        if (!isPrimary() && colMeta.isPrimary()) {\n            table.setPrimaryColumn(this);\n        }\n        allowImpliedParents = !colMeta.isImpliedParentsDisabled();\n        allowImpliedChildren = !colMeta.isImpliedChildrenDisabled();\n        isExcluded |= colMeta.isExcluded();\n        isAllExcluded |= colMeta.isAllExcluded();\n    }\n\n    /**\n     * Returns the name of this column.\n     */\n    @Override\n    public String toString() {\n        return getName();\n    }\n\n    /**\n     * Two {@link TableColumn}s are considered equal if their tables and names match.\n     */\n    private class ColumnComparator implements Comparator<TableColumn> {\n\n        public int compare(TableColumn column1, TableColumn column2) {\n            int rc = column1.getTable().compareTo(column2.getTable());\n            if (rc == 0)\n                rc = column1.getName().compareToIgnoreCase(column2.getName());\n            return rc;\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if this column is permitted to be an implied FK\n     * (based on name/type/size matches to PKs).\n     *\n     * @return\n     */\n    public boolean allowsImpliedParents() {\n        return allowImpliedParents;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is permitted to be a PK to an implied FK\n     * (based on name/type/size matches to PKs).\n     *\n     * @return\n     */\n    public boolean allowsImpliedChildren() {\n        return allowImpliedChildren;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableColumnTest2.java",
		"test_prompt": "// TableColumnTest2.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TableColumn}.\n* It contains ten unit test cases for the {@link TableColumn#isUnique()} method.\n*/\nclass TableColumnTest2 {"
	},
	{
		"original_code": "// TableColumn.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\n\npublic class TableColumn {\n\n    private final Table table;\n\n    private final String name;\n\n    private final Object id;\n\n    private String type;\n\n    private String shortType;\n\n    private final int length;\n\n    private final int decimalDigits;\n\n    private final String detailedSize;\n\n    private final boolean isNullable;\n\n    private boolean isAutoUpdated;\n\n    private Boolean isUnique;\n\n    private final Object defaultValue;\n\n    private String comments;\n\n    private final Map<TableColumn, ForeignKeyConstraint> parents = new HashMap<TableColumn, ForeignKeyConstraint>();\n\n    private final Map<TableColumn, ForeignKeyConstraint> children = new TreeMap<TableColumn, ForeignKeyConstraint>(new ColumnComparator());\n\n    private boolean allowImpliedParents = true;\n\n    private boolean allowImpliedChildren = true;\n\n    private boolean isExcluded = false;\n\n    private boolean isAllExcluded = false;\n\n    private static final Logger logger = Logger.getLogger(TableColumn.class.getName());\n\n    private static final boolean finerEnabled = logger.isLoggable(Level.FINER);\n\n    /**\n     * Create a column associated with a table.\n     *\n     * @param table Table the table that this column belongs to\n     * @param rs ResultSet returned from {@link DatabaseMetaData#getColumns(String, String, String, String)}\n     * @throws SQLException\n     */\n    TableColumn(Table table, ResultSet rs) throws SQLException {\n        this.table = table;\n        // names and types are typically reused *many* times in a database,\n        // so keep a single instance of each distinct one\n        // (thanks to Mike Barnes for the suggestion)\n        String tmp = rs.getString(\"COLUMN_NAME\");\n        name = tmp == null ? null : tmp.intern();\n        tmp = rs.getString(\"TYPE_NAME\");\n        type = tmp == null ? \"unknown\" : tmp.intern();\n        decimalDigits = rs.getInt(\"DECIMAL_DIGITS\");\n        Number bufLength = (Number) rs.getObject(\"BUFFER_LENGTH\");\n        if (bufLength != null && bufLength.shortValue() > 0)\n            length = bufLength.shortValue();\n        else\n            length = rs.getInt(\"COLUMN_SIZE\");\n        StringBuilder buf = new StringBuilder();\n        buf.append(length);\n        if (decimalDigits > 0) {\n            buf.append(',');\n            buf.append(decimalDigits);\n        }\n        detailedSize = buf.toString();\n        isNullable = rs.getInt(\"NULLABLE\") == DatabaseMetaData.columnNullable;\n        defaultValue = rs.getString(\"COLUMN_DEF\");\n        setComments(rs.getString(\"REMARKS\"));\n        id = new Integer(rs.getInt(\"ORDINAL_POSITION\") - 1);\n        Pattern excludeIndirectColumns = Config.getInstance().getIndirectColumnExclusions();\n        Pattern excludeColumns = Config.getInstance().getColumnExclusions();\n        isAllExcluded = matches(excludeColumns);\n        isExcluded = isAllExcluded || matches(excludeIndirectColumns);\n        if (isExcluded && finerEnabled) {\n            logger.finer(\"Excluding column \" + getTable() + '.' + getName() + \": matches \" + excludeColumns + \":\" + isAllExcluded + \" \" + excludeIndirectColumns + \":\" + matches(excludeIndirectColumns));\n        }\n    }\n\n    /**\n     * A TableColumn that's derived from something other than traditional database metadata\n     * (e.g. defined in XML).\n     *\n     * @param table\n     * @param colMeta\n     */\n    public TableColumn(Table table, TableColumnMeta colMeta) {\n        this.table = table;\n        name = colMeta.getName();\n        id = colMeta.getId();\n        type = colMeta.getType();\n        length = colMeta.getSize();\n        decimalDigits = colMeta.getDigits();\n        StringBuilder buf = new StringBuilder();\n        buf.append(length);\n        if (decimalDigits > 0) {\n            buf.append(',');\n            buf.append(decimalDigits);\n        }\n        detailedSize = buf.toString();\n        isNullable = colMeta.isNullable();\n        isAutoUpdated = colMeta.isAutoUpdated();\n        defaultValue = colMeta.getDefaultValue();\n        comments = colMeta.getComments();\n    }\n\n    /**\n     * Returns the {@link Table} that this column belongs to.\n     *\n     * @return\n     */\n    public Table getTable() {\n        return table;\n    }\n\n    /**\n     * Returns the column's name.\n     *\n     * @return\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the ID of the column or <code>null</code> if the database doesn't support the concept.\n     *\n     * @return\n     */\n    public Object getId() {\n        return id;\n    }\n\n    /**\n     * Type of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>TYPE_NAME</code>.\n     * @return\n     */\n    public String getType() {\n        return type;\n    }\n\n    /**\n     * Normally only used for \"special\" types such as enums.\n     *\n     * @param type\n     */\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    /**\n     * Abbreviated form of {@link #getType()}\n     *\n     * @return\n     */\n    public String getShortType() {\n        return shortType == null ? type : shortType;\n    }\n\n    /**\n     * Abbreviated form of {@link #setType(String)}\n     *\n     * @param shortType\n     */\n    public void setShortType(String shortType) {\n        this.shortType = shortType;\n    }\n\n    /**\n     * Length of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>BUFFER_LENGTH</code>,\n     * or if that's <code>null</code>, <code>COLUMN_SIZE</code>.\n     * @return\n     */\n    public int getLength() {\n        return length;\n    }\n\n    /**\n     * Decimal digits of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>DECIMAL_DIGITS</code>.\n     *\n     * @return\n     */\n    public int getDecimalDigits() {\n        return decimalDigits;\n    }\n\n    /**\n     * String representation of length with optional decimal digits (if decimal digits &gt; 0).\n     *\n     * @return\n     */\n    public String getDetailedSize() {\n        return detailedSize;\n    }\n\n    /**\n     * Returns <code>true</code> if null values are allowed\n     *\n     * @return\n     */\n    public boolean isNullable() {\n        return isNullable;\n    }\n\n    /**\n     * See {@link java.sql.ResultSetMetaData#isAutoIncrement(int)}\n     *\n     * @return\n     */\n    public boolean isAutoUpdated() {\n        return isAutoUpdated;\n    }\n\n    /**\n     * setIsAutoUpdated\n     *\n     * @param isAutoUpdated boolean\n     */\n    public void setIsAutoUpdated(boolean isAutoUpdated) {\n        this.isAutoUpdated = isAutoUpdated;\n    }\n\n    /**\n     * Returns <code>true</code> if this column can only contain unique values\n     *\n     * @return\n     */\n    public boolean isUnique() {\n        if (isUnique == null) {\n            // see if there's a unique index on this column by itself\n            for (TableIndex index : table.getIndexes()) {\n                if (index.isUnique()) {\n                    List<TableColumn> indexColumns = index.getColumns();\n                    if (indexColumns.size() == 1 && indexColumns.contains(this)) {\n                        isUnique = true;\n                        break;\n                    }\n                }\n            }\n            if (isUnique == null) {\n                // if it's a single PK column then it's unique\n                isUnique = table.getPrimaryColumns().size() == 1 && isPrimary();\n            }\n        }\n        return isUnique;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is a primary key\n     *\n     * @return\n     */\n    public boolean isPrimary() {\n        return table.getPrimaryColumns().contains(this);\n    }\n\n    /**\n     * Returns <code>true</code> if this column points to another table's primary key.\n     *\n     * @return\n     */\n    public boolean isForeignKey() {\n        return !parents.isEmpty();\n    }\n\n    /**\n     * Returns the value that the database uses for this column if one isn't provided.\n     *\n     * @return\n     */\n    public Object getDefaultValue() {\n        return defaultValue;\n    }\n\n    /**\n     * @return Comments associated with this column, or <code>null</code> if none.\n     */\n    public String getComments() {\n        return comments;\n    }\n\n    /**\n     * See {@link #getComments()}\n     * @param comments\n     */\n    public void setComments(String comments) {\n        this.comments = (comments == null || comments.trim().length() == 0) ? null : comments.trim();\n    }\n\n    /**\n     * Returns <code>true</code> if this column is to be excluded from relationship diagrams.\n     * Unless {@link #isAllExcluded()} is true this column will be included in the detailed\n     * diagrams of the containing table.\n     *\n     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables\n     * reference a given column.\n     *\n     * @return\n     */\n    public boolean isExcluded() {\n        return isExcluded;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is to be excluded from all relationships in\n     * relationship diagrams.  This includes the detailed diagrams of the containing table.\n     *\n     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables\n     * reference a given column.\n     *\n     * @return\n     */\n    public boolean isAllExcluded() {\n        return isAllExcluded;\n    }\n\n    /**\n     * Add a parent column (PK) to this column (FK) via the associated constraint\n     *\n     * @param parent\n     * @param constraint\n     */\n    public void addParent(TableColumn parent, ForeignKeyConstraint constraint) {\n        parents.put(parent, constraint);\n        table.addedParent();\n    }\n\n    /**\n     * Remove the specified parent column from this column\n     *\n     * @param parent\n     */\n    public void removeParent(TableColumn parent) {\n        parents.remove(parent);\n    }\n\n    /**\n     * Disassociate all parents from this column\n     */\n    public void unlinkParents() {\n        for (TableColumn parent : parents.keySet()) {\n            parent.removeChild(this);\n        }\n        parents.clear();\n    }\n\n    /**\n     * Returns the {@link Set} of all {@link TableColumn parents} associated with this column\n     *\n     * @return\n     */\n    public Set<TableColumn> getParents() {\n        return parents.keySet();\n    }\n\n    /**\n     * Returns the constraint that connects this column to the specified column (this 'child' column to specified 'parent' column)\n     */\n    public ForeignKeyConstraint getParentConstraint(TableColumn parent) {\n        return parents.get(parent);\n    }\n\n    /**\n     * Removes a parent constraint and returns it, or null if there are no parent constraints\n     *\n     * @return the removed {@link ForeignKeyConstraint}\n     */\n    public ForeignKeyConstraint removeAParentFKConstraint() {\n        for (TableColumn relatedColumn : parents.keySet()) {\n            ForeignKeyConstraint constraint = parents.remove(relatedColumn);\n            relatedColumn.removeChild(this);\n            return constraint;\n        }\n        return null;\n    }\n\n    /**\n     * Remove one child {@link ForeignKeyConstraint} that points to this column.\n     *\n     * @return the removed constraint, or <code>null</code> if none were available to be removed\n     */\n    public ForeignKeyConstraint removeAChildFKConstraint() {\n        for (TableColumn relatedColumn : children.keySet()) {\n            ForeignKeyConstraint constraint = children.remove(relatedColumn);\n            relatedColumn.removeParent(this);\n            return constraint;\n        }\n        return null;\n    }\n\n    /**\n     * Add a child column (FK) to this column (PK) via the associated constraint\n     *\n     * @param child\n     * @param constraint\n     */\n    public void addChild(TableColumn child, ForeignKeyConstraint constraint) {\n        children.put(child, constraint);\n        table.addedChild();\n    }\n\n    /**\n     * Remove the specified child column from this column\n     *\n     * @param child\n     */\n    public void removeChild(TableColumn child) {\n        children.remove(child);\n    }\n\n    /**\n     * Disassociate all children from this column\n     */\n    public void unlinkChildren() {\n        for (TableColumn child : children.keySet()) child.removeParent(this);\n        children.clear();\n    }\n\n    /**\n     * Returns <code>Set</code> of <code>TableColumn</code>s that have a real (or implied) foreign key that\n     * references this <code>TableColumn</code>.\n     * @return Set\n     */\n    public Set<TableColumn> getChildren() {\n        return children.keySet();\n    }\n\n    /**\n     * returns the constraint that connects the specified column to this column\n     * (specified 'child' to this 'parent' column)\n     */\n    public ForeignKeyConstraint getChildConstraint(TableColumn child) {\n        return children.get(child);\n    }\n\n    /**\n     * Returns <code>true</code> if tableName.columnName matches the supplied\n     * regular expression.\n     *\n     * @param regex\n     * @return\n     */\n    public boolean matches(Pattern regex) {\n        return regex.matcher(getTable().getName() + '.' + getName()).matches();\n    }\n\n    /**\n     * Update the state of this column with the supplied {@link TableColumnMeta}.\n     * Intended to be used with instances created by {@link #TableColumn(Table, TableColumnMeta)}.\n     *\n     * @param colMeta\n     */\n    public void update(TableColumnMeta colMeta) {\n        String newComments = colMeta.getComments();\n        if (newComments != null)\n            setComments(newComments);\n        if (!isPrimary() && colMeta.isPrimary()) {\n            table.setPrimaryColumn(this);\n        }\n        allowImpliedParents = !colMeta.isImpliedParentsDisabled();\n        allowImpliedChildren = !colMeta.isImpliedChildrenDisabled();\n        isExcluded |= colMeta.isExcluded();\n        isAllExcluded |= colMeta.isAllExcluded();\n    }\n\n    /**\n     * Returns the name of this column.\n     */\n    @Override\n    public String toString() {\n        return getName();\n    }\n\n    /**\n     * Two {@link TableColumn}s are considered equal if their tables and names match.\n     */\n    private class ColumnComparator implements Comparator<TableColumn> {\n\n        public int compare(TableColumn column1, TableColumn column2) {\n            int rc = column1.getTable().compareTo(column2.getTable());\n            if (rc == 0)\n                rc = column1.getName().compareToIgnoreCase(column2.getName());\n            return rc;\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if this column is permitted to be an implied FK\n     * (based on name/type/size matches to PKs).\n     *\n     * @return\n     */\n    public boolean allowsImpliedParents() {\n        return allowImpliedParents;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is permitted to be a PK to an implied FK\n     * (based on name/type/size matches to PKs).\n     *\n     * @return\n     */\n    public boolean allowsImpliedChildren() {\n        return allowImpliedChildren;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableColumnTest3.java",
		"test_prompt": "// TableColumnTest3.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TableColumn}.\n* It contains ten unit test cases for the {@link TableColumn#isPrimary()} method.\n*/\nclass TableColumnTest3 {"
	},
	{
		"original_code": "// TableColumn.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\n\npublic class TableColumn {\n\n    private final Table table;\n\n    private final String name;\n\n    private final Object id;\n\n    private String type;\n\n    private String shortType;\n\n    private final int length;\n\n    private final int decimalDigits;\n\n    private final String detailedSize;\n\n    private final boolean isNullable;\n\n    private boolean isAutoUpdated;\n\n    private Boolean isUnique;\n\n    private final Object defaultValue;\n\n    private String comments;\n\n    private final Map<TableColumn, ForeignKeyConstraint> parents = new HashMap<TableColumn, ForeignKeyConstraint>();\n\n    private final Map<TableColumn, ForeignKeyConstraint> children = new TreeMap<TableColumn, ForeignKeyConstraint>(new ColumnComparator());\n\n    private boolean allowImpliedParents = true;\n\n    private boolean allowImpliedChildren = true;\n\n    private boolean isExcluded = false;\n\n    private boolean isAllExcluded = false;\n\n    private static final Logger logger = Logger.getLogger(TableColumn.class.getName());\n\n    private static final boolean finerEnabled = logger.isLoggable(Level.FINER);\n\n    /**\n     * Create a column associated with a table.\n     *\n     * @param table Table the table that this column belongs to\n     * @param rs ResultSet returned from {@link DatabaseMetaData#getColumns(String, String, String, String)}\n     * @throws SQLException\n     */\n    TableColumn(Table table, ResultSet rs) throws SQLException {\n        this.table = table;\n        // names and types are typically reused *many* times in a database,\n        // so keep a single instance of each distinct one\n        // (thanks to Mike Barnes for the suggestion)\n        String tmp = rs.getString(\"COLUMN_NAME\");\n        name = tmp == null ? null : tmp.intern();\n        tmp = rs.getString(\"TYPE_NAME\");\n        type = tmp == null ? \"unknown\" : tmp.intern();\n        decimalDigits = rs.getInt(\"DECIMAL_DIGITS\");\n        Number bufLength = (Number) rs.getObject(\"BUFFER_LENGTH\");\n        if (bufLength != null && bufLength.shortValue() > 0)\n            length = bufLength.shortValue();\n        else\n            length = rs.getInt(\"COLUMN_SIZE\");\n        StringBuilder buf = new StringBuilder();\n        buf.append(length);\n        if (decimalDigits > 0) {\n            buf.append(',');\n            buf.append(decimalDigits);\n        }\n        detailedSize = buf.toString();\n        isNullable = rs.getInt(\"NULLABLE\") == DatabaseMetaData.columnNullable;\n        defaultValue = rs.getString(\"COLUMN_DEF\");\n        setComments(rs.getString(\"REMARKS\"));\n        id = new Integer(rs.getInt(\"ORDINAL_POSITION\") - 1);\n        Pattern excludeIndirectColumns = Config.getInstance().getIndirectColumnExclusions();\n        Pattern excludeColumns = Config.getInstance().getColumnExclusions();\n        isAllExcluded = matches(excludeColumns);\n        isExcluded = isAllExcluded || matches(excludeIndirectColumns);\n        if (isExcluded && finerEnabled) {\n            logger.finer(\"Excluding column \" + getTable() + '.' + getName() + \": matches \" + excludeColumns + \":\" + isAllExcluded + \" \" + excludeIndirectColumns + \":\" + matches(excludeIndirectColumns));\n        }\n    }\n\n    /**\n     * A TableColumn that's derived from something other than traditional database metadata\n     * (e.g. defined in XML).\n     *\n     * @param table\n     * @param colMeta\n     */\n    public TableColumn(Table table, TableColumnMeta colMeta) {\n        this.table = table;\n        name = colMeta.getName();\n        id = colMeta.getId();\n        type = colMeta.getType();\n        length = colMeta.getSize();\n        decimalDigits = colMeta.getDigits();\n        StringBuilder buf = new StringBuilder();\n        buf.append(length);\n        if (decimalDigits > 0) {\n            buf.append(',');\n            buf.append(decimalDigits);\n        }\n        detailedSize = buf.toString();\n        isNullable = colMeta.isNullable();\n        isAutoUpdated = colMeta.isAutoUpdated();\n        defaultValue = colMeta.getDefaultValue();\n        comments = colMeta.getComments();\n    }\n\n    /**\n     * Returns the {@link Table} that this column belongs to.\n     *\n     * @return\n     */\n    public Table getTable() {\n        return table;\n    }\n\n    /**\n     * Returns the column's name.\n     *\n     * @return\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the ID of the column or <code>null</code> if the database doesn't support the concept.\n     *\n     * @return\n     */\n    public Object getId() {\n        return id;\n    }\n\n    /**\n     * Type of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>TYPE_NAME</code>.\n     * @return\n     */\n    public String getType() {\n        return type;\n    }\n\n    /**\n     * Normally only used for \"special\" types such as enums.\n     *\n     * @param type\n     */\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    /**\n     * Abbreviated form of {@link #getType()}\n     *\n     * @return\n     */\n    public String getShortType() {\n        return shortType == null ? type : shortType;\n    }\n\n    /**\n     * Abbreviated form of {@link #setType(String)}\n     *\n     * @param shortType\n     */\n    public void setShortType(String shortType) {\n        this.shortType = shortType;\n    }\n\n    /**\n     * Length of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>BUFFER_LENGTH</code>,\n     * or if that's <code>null</code>, <code>COLUMN_SIZE</code>.\n     * @return\n     */\n    public int getLength() {\n        return length;\n    }\n\n    /**\n     * Decimal digits of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>DECIMAL_DIGITS</code>.\n     *\n     * @return\n     */\n    public int getDecimalDigits() {\n        return decimalDigits;\n    }\n\n    /**\n     * String representation of length with optional decimal digits (if decimal digits &gt; 0).\n     *\n     * @return\n     */\n    public String getDetailedSize() {\n        return detailedSize;\n    }\n\n    /**\n     * Returns <code>true</code> if null values are allowed\n     *\n     * @return\n     */\n    public boolean isNullable() {\n        return isNullable;\n    }\n\n    /**\n     * See {@link java.sql.ResultSetMetaData#isAutoIncrement(int)}\n     *\n     * @return\n     */\n    public boolean isAutoUpdated() {\n        return isAutoUpdated;\n    }\n\n    /**\n     * setIsAutoUpdated\n     *\n     * @param isAutoUpdated boolean\n     */\n    public void setIsAutoUpdated(boolean isAutoUpdated) {\n        this.isAutoUpdated = isAutoUpdated;\n    }\n\n    /**\n     * Returns <code>true</code> if this column can only contain unique values\n     *\n     * @return\n     */\n    public boolean isUnique() {\n        if (isUnique == null) {\n            // see if there's a unique index on this column by itself\n            for (TableIndex index : table.getIndexes()) {\n                if (index.isUnique()) {\n                    List<TableColumn> indexColumns = index.getColumns();\n                    if (indexColumns.size() == 1 && indexColumns.contains(this)) {\n                        isUnique = true;\n                        break;\n                    }\n                }\n            }\n            if (isUnique == null) {\n                // if it's a single PK column then it's unique\n                isUnique = table.getPrimaryColumns().size() == 1 && isPrimary();\n            }\n        }\n        return isUnique;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is a primary key\n     *\n     * @return\n     */\n    public boolean isPrimary() {\n        return table.getPrimaryColumns().contains(this);\n    }\n\n    /**\n     * Returns <code>true</code> if this column points to another table's primary key.\n     *\n     * @return\n     */\n    public boolean isForeignKey() {\n        return !parents.isEmpty();\n    }\n\n    /**\n     * Returns the value that the database uses for this column if one isn't provided.\n     *\n     * @return\n     */\n    public Object getDefaultValue() {\n        return defaultValue;\n    }\n\n    /**\n     * @return Comments associated with this column, or <code>null</code> if none.\n     */\n    public String getComments() {\n        return comments;\n    }\n\n    /**\n     * See {@link #getComments()}\n     * @param comments\n     */\n    public void setComments(String comments) {\n        this.comments = (comments == null || comments.trim().length() == 0) ? null : comments.trim();\n    }\n\n    /**\n     * Returns <code>true</code> if this column is to be excluded from relationship diagrams.\n     * Unless {@link #isAllExcluded()} is true this column will be included in the detailed\n     * diagrams of the containing table.\n     *\n     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables\n     * reference a given column.\n     *\n     * @return\n     */\n    public boolean isExcluded() {\n        return isExcluded;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is to be excluded from all relationships in\n     * relationship diagrams.  This includes the detailed diagrams of the containing table.\n     *\n     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables\n     * reference a given column.\n     *\n     * @return\n     */\n    public boolean isAllExcluded() {\n        return isAllExcluded;\n    }\n\n    /**\n     * Add a parent column (PK) to this column (FK) via the associated constraint\n     *\n     * @param parent\n     * @param constraint\n     */\n    public void addParent(TableColumn parent, ForeignKeyConstraint constraint) {\n        parents.put(parent, constraint);\n        table.addedParent();\n    }\n\n    /**\n     * Remove the specified parent column from this column\n     *\n     * @param parent\n     */\n    public void removeParent(TableColumn parent) {\n        parents.remove(parent);\n    }\n\n    /**\n     * Disassociate all parents from this column\n     */\n    public void unlinkParents() {\n        for (TableColumn parent : parents.keySet()) {\n            parent.removeChild(this);\n        }\n        parents.clear();\n    }\n\n    /**\n     * Returns the {@link Set} of all {@link TableColumn parents} associated with this column\n     *\n     * @return\n     */\n    public Set<TableColumn> getParents() {\n        return parents.keySet();\n    }\n\n    /**\n     * Returns the constraint that connects this column to the specified column (this 'child' column to specified 'parent' column)\n     */\n    public ForeignKeyConstraint getParentConstraint(TableColumn parent) {\n        return parents.get(parent);\n    }\n\n    /**\n     * Removes a parent constraint and returns it, or null if there are no parent constraints\n     *\n     * @return the removed {@link ForeignKeyConstraint}\n     */\n    public ForeignKeyConstraint removeAParentFKConstraint() {\n        for (TableColumn relatedColumn : parents.keySet()) {\n            ForeignKeyConstraint constraint = parents.remove(relatedColumn);\n            relatedColumn.removeChild(this);\n            return constraint;\n        }\n        return null;\n    }\n\n    /**\n     * Remove one child {@link ForeignKeyConstraint} that points to this column.\n     *\n     * @return the removed constraint, or <code>null</code> if none were available to be removed\n     */\n    public ForeignKeyConstraint removeAChildFKConstraint() {\n        for (TableColumn relatedColumn : children.keySet()) {\n            ForeignKeyConstraint constraint = children.remove(relatedColumn);\n            relatedColumn.removeParent(this);\n            return constraint;\n        }\n        return null;\n    }\n\n    /**\n     * Add a child column (FK) to this column (PK) via the associated constraint\n     *\n     * @param child\n     * @param constraint\n     */\n    public void addChild(TableColumn child, ForeignKeyConstraint constraint) {\n        children.put(child, constraint);\n        table.addedChild();\n    }\n\n    /**\n     * Remove the specified child column from this column\n     *\n     * @param child\n     */\n    public void removeChild(TableColumn child) {\n        children.remove(child);\n    }\n\n    /**\n     * Disassociate all children from this column\n     */\n    public void unlinkChildren() {\n        for (TableColumn child : children.keySet()) child.removeParent(this);\n        children.clear();\n    }\n\n    /**\n     * Returns <code>Set</code> of <code>TableColumn</code>s that have a real (or implied) foreign key that\n     * references this <code>TableColumn</code>.\n     * @return Set\n     */\n    public Set<TableColumn> getChildren() {\n        return children.keySet();\n    }\n\n    /**\n     * returns the constraint that connects the specified column to this column\n     * (specified 'child' to this 'parent' column)\n     */\n    public ForeignKeyConstraint getChildConstraint(TableColumn child) {\n        return children.get(child);\n    }\n\n    /**\n     * Returns <code>true</code> if tableName.columnName matches the supplied\n     * regular expression.\n     *\n     * @param regex\n     * @return\n     */\n    public boolean matches(Pattern regex) {\n        return regex.matcher(getTable().getName() + '.' + getName()).matches();\n    }\n\n    /**\n     * Update the state of this column with the supplied {@link TableColumnMeta}.\n     * Intended to be used with instances created by {@link #TableColumn(Table, TableColumnMeta)}.\n     *\n     * @param colMeta\n     */\n    public void update(TableColumnMeta colMeta) {\n        String newComments = colMeta.getComments();\n        if (newComments != null)\n            setComments(newComments);\n        if (!isPrimary() && colMeta.isPrimary()) {\n            table.setPrimaryColumn(this);\n        }\n        allowImpliedParents = !colMeta.isImpliedParentsDisabled();\n        allowImpliedChildren = !colMeta.isImpliedChildrenDisabled();\n        isExcluded |= colMeta.isExcluded();\n        isAllExcluded |= colMeta.isAllExcluded();\n    }\n\n    /**\n     * Returns the name of this column.\n     */\n    @Override\n    public String toString() {\n        return getName();\n    }\n\n    /**\n     * Two {@link TableColumn}s are considered equal if their tables and names match.\n     */\n    private class ColumnComparator implements Comparator<TableColumn> {\n\n        public int compare(TableColumn column1, TableColumn column2) {\n            int rc = column1.getTable().compareTo(column2.getTable());\n            if (rc == 0)\n                rc = column1.getName().compareToIgnoreCase(column2.getName());\n            return rc;\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if this column is permitted to be an implied FK\n     * (based on name/type/size matches to PKs).\n     *\n     * @return\n     */\n    public boolean allowsImpliedParents() {\n        return allowImpliedParents;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is permitted to be a PK to an implied FK\n     * (based on name/type/size matches to PKs).\n     *\n     * @return\n     */\n    public boolean allowsImpliedChildren() {\n        return allowImpliedChildren;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableColumnTest4.java",
		"test_prompt": "// TableColumnTest4.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TableColumn}.\n* It contains ten unit test cases for the {@link TableColumn#isForeignKey()} method.\n*/\nclass TableColumnTest4 {"
	},
	{
		"original_code": "// TableColumn.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\n\npublic class TableColumn {\n\n    private final Table table;\n\n    private final String name;\n\n    private final Object id;\n\n    private String type;\n\n    private String shortType;\n\n    private final int length;\n\n    private final int decimalDigits;\n\n    private final String detailedSize;\n\n    private final boolean isNullable;\n\n    private boolean isAutoUpdated;\n\n    private Boolean isUnique;\n\n    private final Object defaultValue;\n\n    private String comments;\n\n    private final Map<TableColumn, ForeignKeyConstraint> parents = new HashMap<TableColumn, ForeignKeyConstraint>();\n\n    private final Map<TableColumn, ForeignKeyConstraint> children = new TreeMap<TableColumn, ForeignKeyConstraint>(new ColumnComparator());\n\n    private boolean allowImpliedParents = true;\n\n    private boolean allowImpliedChildren = true;\n\n    private boolean isExcluded = false;\n\n    private boolean isAllExcluded = false;\n\n    private static final Logger logger = Logger.getLogger(TableColumn.class.getName());\n\n    private static final boolean finerEnabled = logger.isLoggable(Level.FINER);\n\n    /**\n     * Create a column associated with a table.\n     *\n     * @param table Table the table that this column belongs to\n     * @param rs ResultSet returned from {@link DatabaseMetaData#getColumns(String, String, String, String)}\n     * @throws SQLException\n     */\n    TableColumn(Table table, ResultSet rs) throws SQLException {\n        this.table = table;\n        // names and types are typically reused *many* times in a database,\n        // so keep a single instance of each distinct one\n        // (thanks to Mike Barnes for the suggestion)\n        String tmp = rs.getString(\"COLUMN_NAME\");\n        name = tmp == null ? null : tmp.intern();\n        tmp = rs.getString(\"TYPE_NAME\");\n        type = tmp == null ? \"unknown\" : tmp.intern();\n        decimalDigits = rs.getInt(\"DECIMAL_DIGITS\");\n        Number bufLength = (Number) rs.getObject(\"BUFFER_LENGTH\");\n        if (bufLength != null && bufLength.shortValue() > 0)\n            length = bufLength.shortValue();\n        else\n            length = rs.getInt(\"COLUMN_SIZE\");\n        StringBuilder buf = new StringBuilder();\n        buf.append(length);\n        if (decimalDigits > 0) {\n            buf.append(',');\n            buf.append(decimalDigits);\n        }\n        detailedSize = buf.toString();\n        isNullable = rs.getInt(\"NULLABLE\") == DatabaseMetaData.columnNullable;\n        defaultValue = rs.getString(\"COLUMN_DEF\");\n        setComments(rs.getString(\"REMARKS\"));\n        id = new Integer(rs.getInt(\"ORDINAL_POSITION\") - 1);\n        Pattern excludeIndirectColumns = Config.getInstance().getIndirectColumnExclusions();\n        Pattern excludeColumns = Config.getInstance().getColumnExclusions();\n        isAllExcluded = matches(excludeColumns);\n        isExcluded = isAllExcluded || matches(excludeIndirectColumns);\n        if (isExcluded && finerEnabled) {\n            logger.finer(\"Excluding column \" + getTable() + '.' + getName() + \": matches \" + excludeColumns + \":\" + isAllExcluded + \" \" + excludeIndirectColumns + \":\" + matches(excludeIndirectColumns));\n        }\n    }\n\n    /**\n     * A TableColumn that's derived from something other than traditional database metadata\n     * (e.g. defined in XML).\n     *\n     * @param table\n     * @param colMeta\n     */\n    public TableColumn(Table table, TableColumnMeta colMeta) {\n        this.table = table;\n        name = colMeta.getName();\n        id = colMeta.getId();\n        type = colMeta.getType();\n        length = colMeta.getSize();\n        decimalDigits = colMeta.getDigits();\n        StringBuilder buf = new StringBuilder();\n        buf.append(length);\n        if (decimalDigits > 0) {\n            buf.append(',');\n            buf.append(decimalDigits);\n        }\n        detailedSize = buf.toString();\n        isNullable = colMeta.isNullable();\n        isAutoUpdated = colMeta.isAutoUpdated();\n        defaultValue = colMeta.getDefaultValue();\n        comments = colMeta.getComments();\n    }\n\n    /**\n     * Returns the {@link Table} that this column belongs to.\n     *\n     * @return\n     */\n    public Table getTable() {\n        return table;\n    }\n\n    /**\n     * Returns the column's name.\n     *\n     * @return\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the ID of the column or <code>null</code> if the database doesn't support the concept.\n     *\n     * @return\n     */\n    public Object getId() {\n        return id;\n    }\n\n    /**\n     * Type of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>TYPE_NAME</code>.\n     * @return\n     */\n    public String getType() {\n        return type;\n    }\n\n    /**\n     * Normally only used for \"special\" types such as enums.\n     *\n     * @param type\n     */\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    /**\n     * Abbreviated form of {@link #getType()}\n     *\n     * @return\n     */\n    public String getShortType() {\n        return shortType == null ? type : shortType;\n    }\n\n    /**\n     * Abbreviated form of {@link #setType(String)}\n     *\n     * @param shortType\n     */\n    public void setShortType(String shortType) {\n        this.shortType = shortType;\n    }\n\n    /**\n     * Length of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>BUFFER_LENGTH</code>,\n     * or if that's <code>null</code>, <code>COLUMN_SIZE</code>.\n     * @return\n     */\n    public int getLength() {\n        return length;\n    }\n\n    /**\n     * Decimal digits of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>DECIMAL_DIGITS</code>.\n     *\n     * @return\n     */\n    public int getDecimalDigits() {\n        return decimalDigits;\n    }\n\n    /**\n     * String representation of length with optional decimal digits (if decimal digits &gt; 0).\n     *\n     * @return\n     */\n    public String getDetailedSize() {\n        return detailedSize;\n    }\n\n    /**\n     * Returns <code>true</code> if null values are allowed\n     *\n     * @return\n     */\n    public boolean isNullable() {\n        return isNullable;\n    }\n\n    /**\n     * See {@link java.sql.ResultSetMetaData#isAutoIncrement(int)}\n     *\n     * @return\n     */\n    public boolean isAutoUpdated() {\n        return isAutoUpdated;\n    }\n\n    /**\n     * setIsAutoUpdated\n     *\n     * @param isAutoUpdated boolean\n     */\n    public void setIsAutoUpdated(boolean isAutoUpdated) {\n        this.isAutoUpdated = isAutoUpdated;\n    }\n\n    /**\n     * Returns <code>true</code> if this column can only contain unique values\n     *\n     * @return\n     */\n    public boolean isUnique() {\n        if (isUnique == null) {\n            // see if there's a unique index on this column by itself\n            for (TableIndex index : table.getIndexes()) {\n                if (index.isUnique()) {\n                    List<TableColumn> indexColumns = index.getColumns();\n                    if (indexColumns.size() == 1 && indexColumns.contains(this)) {\n                        isUnique = true;\n                        break;\n                    }\n                }\n            }\n            if (isUnique == null) {\n                // if it's a single PK column then it's unique\n                isUnique = table.getPrimaryColumns().size() == 1 && isPrimary();\n            }\n        }\n        return isUnique;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is a primary key\n     *\n     * @return\n     */\n    public boolean isPrimary() {\n        return table.getPrimaryColumns().contains(this);\n    }\n\n    /**\n     * Returns <code>true</code> if this column points to another table's primary key.\n     *\n     * @return\n     */\n    public boolean isForeignKey() {\n        return !parents.isEmpty();\n    }\n\n    /**\n     * Returns the value that the database uses for this column if one isn't provided.\n     *\n     * @return\n     */\n    public Object getDefaultValue() {\n        return defaultValue;\n    }\n\n    /**\n     * @return Comments associated with this column, or <code>null</code> if none.\n     */\n    public String getComments() {\n        return comments;\n    }\n\n    /**\n     * See {@link #getComments()}\n     * @param comments\n     */\n    public void setComments(String comments) {\n        this.comments = (comments == null || comments.trim().length() == 0) ? null : comments.trim();\n    }\n\n    /**\n     * Returns <code>true</code> if this column is to be excluded from relationship diagrams.\n     * Unless {@link #isAllExcluded()} is true this column will be included in the detailed\n     * diagrams of the containing table.\n     *\n     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables\n     * reference a given column.\n     *\n     * @return\n     */\n    public boolean isExcluded() {\n        return isExcluded;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is to be excluded from all relationships in\n     * relationship diagrams.  This includes the detailed diagrams of the containing table.\n     *\n     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables\n     * reference a given column.\n     *\n     * @return\n     */\n    public boolean isAllExcluded() {\n        return isAllExcluded;\n    }\n\n    /**\n     * Add a parent column (PK) to this column (FK) via the associated constraint\n     *\n     * @param parent\n     * @param constraint\n     */\n    public void addParent(TableColumn parent, ForeignKeyConstraint constraint) {\n        parents.put(parent, constraint);\n        table.addedParent();\n    }\n\n    /**\n     * Remove the specified parent column from this column\n     *\n     * @param parent\n     */\n    public void removeParent(TableColumn parent) {\n        parents.remove(parent);\n    }\n\n    /**\n     * Disassociate all parents from this column\n     */\n    public void unlinkParents() {\n        for (TableColumn parent : parents.keySet()) {\n            parent.removeChild(this);\n        }\n        parents.clear();\n    }\n\n    /**\n     * Returns the {@link Set} of all {@link TableColumn parents} associated with this column\n     *\n     * @return\n     */\n    public Set<TableColumn> getParents() {\n        return parents.keySet();\n    }\n\n    /**\n     * Returns the constraint that connects this column to the specified column (this 'child' column to specified 'parent' column)\n     */\n    public ForeignKeyConstraint getParentConstraint(TableColumn parent) {\n        return parents.get(parent);\n    }\n\n    /**\n     * Removes a parent constraint and returns it, or null if there are no parent constraints\n     *\n     * @return the removed {@link ForeignKeyConstraint}\n     */\n    public ForeignKeyConstraint removeAParentFKConstraint() {\n        for (TableColumn relatedColumn : parents.keySet()) {\n            ForeignKeyConstraint constraint = parents.remove(relatedColumn);\n            relatedColumn.removeChild(this);\n            return constraint;\n        }\n        return null;\n    }\n\n    /**\n     * Remove one child {@link ForeignKeyConstraint} that points to this column.\n     *\n     * @return the removed constraint, or <code>null</code> if none were available to be removed\n     */\n    public ForeignKeyConstraint removeAChildFKConstraint() {\n        for (TableColumn relatedColumn : children.keySet()) {\n            ForeignKeyConstraint constraint = children.remove(relatedColumn);\n            relatedColumn.removeParent(this);\n            return constraint;\n        }\n        return null;\n    }\n\n    /**\n     * Add a child column (FK) to this column (PK) via the associated constraint\n     *\n     * @param child\n     * @param constraint\n     */\n    public void addChild(TableColumn child, ForeignKeyConstraint constraint) {\n        children.put(child, constraint);\n        table.addedChild();\n    }\n\n    /**\n     * Remove the specified child column from this column\n     *\n     * @param child\n     */\n    public void removeChild(TableColumn child) {\n        children.remove(child);\n    }\n\n    /**\n     * Disassociate all children from this column\n     */\n    public void unlinkChildren() {\n        for (TableColumn child : children.keySet()) child.removeParent(this);\n        children.clear();\n    }\n\n    /**\n     * Returns <code>Set</code> of <code>TableColumn</code>s that have a real (or implied) foreign key that\n     * references this <code>TableColumn</code>.\n     * @return Set\n     */\n    public Set<TableColumn> getChildren() {\n        return children.keySet();\n    }\n\n    /**\n     * returns the constraint that connects the specified column to this column\n     * (specified 'child' to this 'parent' column)\n     */\n    public ForeignKeyConstraint getChildConstraint(TableColumn child) {\n        return children.get(child);\n    }\n\n    /**\n     * Returns <code>true</code> if tableName.columnName matches the supplied\n     * regular expression.\n     *\n     * @param regex\n     * @return\n     */\n    public boolean matches(Pattern regex) {\n        return regex.matcher(getTable().getName() + '.' + getName()).matches();\n    }\n\n    /**\n     * Update the state of this column with the supplied {@link TableColumnMeta}.\n     * Intended to be used with instances created by {@link #TableColumn(Table, TableColumnMeta)}.\n     *\n     * @param colMeta\n     */\n    public void update(TableColumnMeta colMeta) {\n        String newComments = colMeta.getComments();\n        if (newComments != null)\n            setComments(newComments);\n        if (!isPrimary() && colMeta.isPrimary()) {\n            table.setPrimaryColumn(this);\n        }\n        allowImpliedParents = !colMeta.isImpliedParentsDisabled();\n        allowImpliedChildren = !colMeta.isImpliedChildrenDisabled();\n        isExcluded |= colMeta.isExcluded();\n        isAllExcluded |= colMeta.isAllExcluded();\n    }\n\n    /**\n     * Returns the name of this column.\n     */\n    @Override\n    public String toString() {\n        return getName();\n    }\n\n    /**\n     * Two {@link TableColumn}s are considered equal if their tables and names match.\n     */\n    private class ColumnComparator implements Comparator<TableColumn> {\n\n        public int compare(TableColumn column1, TableColumn column2) {\n            int rc = column1.getTable().compareTo(column2.getTable());\n            if (rc == 0)\n                rc = column1.getName().compareToIgnoreCase(column2.getName());\n            return rc;\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if this column is permitted to be an implied FK\n     * (based on name/type/size matches to PKs).\n     *\n     * @return\n     */\n    public boolean allowsImpliedParents() {\n        return allowImpliedParents;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is permitted to be a PK to an implied FK\n     * (based on name/type/size matches to PKs).\n     *\n     * @return\n     */\n    public boolean allowsImpliedChildren() {\n        return allowImpliedChildren;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableColumnTest5.java",
		"test_prompt": "// TableColumnTest5.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TableColumn}.\n* It contains ten unit test cases for the {@link TableColumn#isExcluded()} method.\n*/\nclass TableColumnTest5 {"
	},
	{
		"original_code": "// TableColumn.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\n\npublic class TableColumn {\n\n    private final Table table;\n\n    private final String name;\n\n    private final Object id;\n\n    private String type;\n\n    private String shortType;\n\n    private final int length;\n\n    private final int decimalDigits;\n\n    private final String detailedSize;\n\n    private final boolean isNullable;\n\n    private boolean isAutoUpdated;\n\n    private Boolean isUnique;\n\n    private final Object defaultValue;\n\n    private String comments;\n\n    private final Map<TableColumn, ForeignKeyConstraint> parents = new HashMap<TableColumn, ForeignKeyConstraint>();\n\n    private final Map<TableColumn, ForeignKeyConstraint> children = new TreeMap<TableColumn, ForeignKeyConstraint>(new ColumnComparator());\n\n    private boolean allowImpliedParents = true;\n\n    private boolean allowImpliedChildren = true;\n\n    private boolean isExcluded = false;\n\n    private boolean isAllExcluded = false;\n\n    private static final Logger logger = Logger.getLogger(TableColumn.class.getName());\n\n    private static final boolean finerEnabled = logger.isLoggable(Level.FINER);\n\n    /**\n     * Create a column associated with a table.\n     *\n     * @param table Table the table that this column belongs to\n     * @param rs ResultSet returned from {@link DatabaseMetaData#getColumns(String, String, String, String)}\n     * @throws SQLException\n     */\n    TableColumn(Table table, ResultSet rs) throws SQLException {\n        this.table = table;\n        // names and types are typically reused *many* times in a database,\n        // so keep a single instance of each distinct one\n        // (thanks to Mike Barnes for the suggestion)\n        String tmp = rs.getString(\"COLUMN_NAME\");\n        name = tmp == null ? null : tmp.intern();\n        tmp = rs.getString(\"TYPE_NAME\");\n        type = tmp == null ? \"unknown\" : tmp.intern();\n        decimalDigits = rs.getInt(\"DECIMAL_DIGITS\");\n        Number bufLength = (Number) rs.getObject(\"BUFFER_LENGTH\");\n        if (bufLength != null && bufLength.shortValue() > 0)\n            length = bufLength.shortValue();\n        else\n            length = rs.getInt(\"COLUMN_SIZE\");\n        StringBuilder buf = new StringBuilder();\n        buf.append(length);\n        if (decimalDigits > 0) {\n            buf.append(',');\n            buf.append(decimalDigits);\n        }\n        detailedSize = buf.toString();\n        isNullable = rs.getInt(\"NULLABLE\") == DatabaseMetaData.columnNullable;\n        defaultValue = rs.getString(\"COLUMN_DEF\");\n        setComments(rs.getString(\"REMARKS\"));\n        id = new Integer(rs.getInt(\"ORDINAL_POSITION\") - 1);\n        Pattern excludeIndirectColumns = Config.getInstance().getIndirectColumnExclusions();\n        Pattern excludeColumns = Config.getInstance().getColumnExclusions();\n        isAllExcluded = matches(excludeColumns);\n        isExcluded = isAllExcluded || matches(excludeIndirectColumns);\n        if (isExcluded && finerEnabled) {\n            logger.finer(\"Excluding column \" + getTable() + '.' + getName() + \": matches \" + excludeColumns + \":\" + isAllExcluded + \" \" + excludeIndirectColumns + \":\" + matches(excludeIndirectColumns));\n        }\n    }\n\n    /**\n     * A TableColumn that's derived from something other than traditional database metadata\n     * (e.g. defined in XML).\n     *\n     * @param table\n     * @param colMeta\n     */\n    public TableColumn(Table table, TableColumnMeta colMeta) {\n        this.table = table;\n        name = colMeta.getName();\n        id = colMeta.getId();\n        type = colMeta.getType();\n        length = colMeta.getSize();\n        decimalDigits = colMeta.getDigits();\n        StringBuilder buf = new StringBuilder();\n        buf.append(length);\n        if (decimalDigits > 0) {\n            buf.append(',');\n            buf.append(decimalDigits);\n        }\n        detailedSize = buf.toString();\n        isNullable = colMeta.isNullable();\n        isAutoUpdated = colMeta.isAutoUpdated();\n        defaultValue = colMeta.getDefaultValue();\n        comments = colMeta.getComments();\n    }\n\n    /**\n     * Returns the {@link Table} that this column belongs to.\n     *\n     * @return\n     */\n    public Table getTable() {\n        return table;\n    }\n\n    /**\n     * Returns the column's name.\n     *\n     * @return\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the ID of the column or <code>null</code> if the database doesn't support the concept.\n     *\n     * @return\n     */\n    public Object getId() {\n        return id;\n    }\n\n    /**\n     * Type of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>TYPE_NAME</code>.\n     * @return\n     */\n    public String getType() {\n        return type;\n    }\n\n    /**\n     * Normally only used for \"special\" types such as enums.\n     *\n     * @param type\n     */\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    /**\n     * Abbreviated form of {@link #getType()}\n     *\n     * @return\n     */\n    public String getShortType() {\n        return shortType == null ? type : shortType;\n    }\n\n    /**\n     * Abbreviated form of {@link #setType(String)}\n     *\n     * @param shortType\n     */\n    public void setShortType(String shortType) {\n        this.shortType = shortType;\n    }\n\n    /**\n     * Length of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>BUFFER_LENGTH</code>,\n     * or if that's <code>null</code>, <code>COLUMN_SIZE</code>.\n     * @return\n     */\n    public int getLength() {\n        return length;\n    }\n\n    /**\n     * Decimal digits of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>DECIMAL_DIGITS</code>.\n     *\n     * @return\n     */\n    public int getDecimalDigits() {\n        return decimalDigits;\n    }\n\n    /**\n     * String representation of length with optional decimal digits (if decimal digits &gt; 0).\n     *\n     * @return\n     */\n    public String getDetailedSize() {\n        return detailedSize;\n    }\n\n    /**\n     * Returns <code>true</code> if null values are allowed\n     *\n     * @return\n     */\n    public boolean isNullable() {\n        return isNullable;\n    }\n\n    /**\n     * See {@link java.sql.ResultSetMetaData#isAutoIncrement(int)}\n     *\n     * @return\n     */\n    public boolean isAutoUpdated() {\n        return isAutoUpdated;\n    }\n\n    /**\n     * setIsAutoUpdated\n     *\n     * @param isAutoUpdated boolean\n     */\n    public void setIsAutoUpdated(boolean isAutoUpdated) {\n        this.isAutoUpdated = isAutoUpdated;\n    }\n\n    /**\n     * Returns <code>true</code> if this column can only contain unique values\n     *\n     * @return\n     */\n    public boolean isUnique() {\n        if (isUnique == null) {\n            // see if there's a unique index on this column by itself\n            for (TableIndex index : table.getIndexes()) {\n                if (index.isUnique()) {\n                    List<TableColumn> indexColumns = index.getColumns();\n                    if (indexColumns.size() == 1 && indexColumns.contains(this)) {\n                        isUnique = true;\n                        break;\n                    }\n                }\n            }\n            if (isUnique == null) {\n                // if it's a single PK column then it's unique\n                isUnique = table.getPrimaryColumns().size() == 1 && isPrimary();\n            }\n        }\n        return isUnique;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is a primary key\n     *\n     * @return\n     */\n    public boolean isPrimary() {\n        return table.getPrimaryColumns().contains(this);\n    }\n\n    /**\n     * Returns <code>true</code> if this column points to another table's primary key.\n     *\n     * @return\n     */\n    public boolean isForeignKey() {\n        return !parents.isEmpty();\n    }\n\n    /**\n     * Returns the value that the database uses for this column if one isn't provided.\n     *\n     * @return\n     */\n    public Object getDefaultValue() {\n        return defaultValue;\n    }\n\n    /**\n     * @return Comments associated with this column, or <code>null</code> if none.\n     */\n    public String getComments() {\n        return comments;\n    }\n\n    /**\n     * See {@link #getComments()}\n     * @param comments\n     */\n    public void setComments(String comments) {\n        this.comments = (comments == null || comments.trim().length() == 0) ? null : comments.trim();\n    }\n\n    /**\n     * Returns <code>true</code> if this column is to be excluded from relationship diagrams.\n     * Unless {@link #isAllExcluded()} is true this column will be included in the detailed\n     * diagrams of the containing table.\n     *\n     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables\n     * reference a given column.\n     *\n     * @return\n     */\n    public boolean isExcluded() {\n        return isExcluded;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is to be excluded from all relationships in\n     * relationship diagrams.  This includes the detailed diagrams of the containing table.\n     *\n     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables\n     * reference a given column.\n     *\n     * @return\n     */\n    public boolean isAllExcluded() {\n        return isAllExcluded;\n    }\n\n    /**\n     * Add a parent column (PK) to this column (FK) via the associated constraint\n     *\n     * @param parent\n     * @param constraint\n     */\n    public void addParent(TableColumn parent, ForeignKeyConstraint constraint) {\n        parents.put(parent, constraint);\n        table.addedParent();\n    }\n\n    /**\n     * Remove the specified parent column from this column\n     *\n     * @param parent\n     */\n    public void removeParent(TableColumn parent) {\n        parents.remove(parent);\n    }\n\n    /**\n     * Disassociate all parents from this column\n     */\n    public void unlinkParents() {\n        for (TableColumn parent : parents.keySet()) {\n            parent.removeChild(this);\n        }\n        parents.clear();\n    }\n\n    /**\n     * Returns the {@link Set} of all {@link TableColumn parents} associated with this column\n     *\n     * @return\n     */\n    public Set<TableColumn> getParents() {\n        return parents.keySet();\n    }\n\n    /**\n     * Returns the constraint that connects this column to the specified column (this 'child' column to specified 'parent' column)\n     */\n    public ForeignKeyConstraint getParentConstraint(TableColumn parent) {\n        return parents.get(parent);\n    }\n\n    /**\n     * Removes a parent constraint and returns it, or null if there are no parent constraints\n     *\n     * @return the removed {@link ForeignKeyConstraint}\n     */\n    public ForeignKeyConstraint removeAParentFKConstraint() {\n        for (TableColumn relatedColumn : parents.keySet()) {\n            ForeignKeyConstraint constraint = parents.remove(relatedColumn);\n            relatedColumn.removeChild(this);\n            return constraint;\n        }\n        return null;\n    }\n\n    /**\n     * Remove one child {@link ForeignKeyConstraint} that points to this column.\n     *\n     * @return the removed constraint, or <code>null</code> if none were available to be removed\n     */\n    public ForeignKeyConstraint removeAChildFKConstraint() {\n        for (TableColumn relatedColumn : children.keySet()) {\n            ForeignKeyConstraint constraint = children.remove(relatedColumn);\n            relatedColumn.removeParent(this);\n            return constraint;\n        }\n        return null;\n    }\n\n    /**\n     * Add a child column (FK) to this column (PK) via the associated constraint\n     *\n     * @param child\n     * @param constraint\n     */\n    public void addChild(TableColumn child, ForeignKeyConstraint constraint) {\n        children.put(child, constraint);\n        table.addedChild();\n    }\n\n    /**\n     * Remove the specified child column from this column\n     *\n     * @param child\n     */\n    public void removeChild(TableColumn child) {\n        children.remove(child);\n    }\n\n    /**\n     * Disassociate all children from this column\n     */\n    public void unlinkChildren() {\n        for (TableColumn child : children.keySet()) child.removeParent(this);\n        children.clear();\n    }\n\n    /**\n     * Returns <code>Set</code> of <code>TableColumn</code>s that have a real (or implied) foreign key that\n     * references this <code>TableColumn</code>.\n     * @return Set\n     */\n    public Set<TableColumn> getChildren() {\n        return children.keySet();\n    }\n\n    /**\n     * returns the constraint that connects the specified column to this column\n     * (specified 'child' to this 'parent' column)\n     */\n    public ForeignKeyConstraint getChildConstraint(TableColumn child) {\n        return children.get(child);\n    }\n\n    /**\n     * Returns <code>true</code> if tableName.columnName matches the supplied\n     * regular expression.\n     *\n     * @param regex\n     * @return\n     */\n    public boolean matches(Pattern regex) {\n        return regex.matcher(getTable().getName() + '.' + getName()).matches();\n    }\n\n    /**\n     * Update the state of this column with the supplied {@link TableColumnMeta}.\n     * Intended to be used with instances created by {@link #TableColumn(Table, TableColumnMeta)}.\n     *\n     * @param colMeta\n     */\n    public void update(TableColumnMeta colMeta) {\n        String newComments = colMeta.getComments();\n        if (newComments != null)\n            setComments(newComments);\n        if (!isPrimary() && colMeta.isPrimary()) {\n            table.setPrimaryColumn(this);\n        }\n        allowImpliedParents = !colMeta.isImpliedParentsDisabled();\n        allowImpliedChildren = !colMeta.isImpliedChildrenDisabled();\n        isExcluded |= colMeta.isExcluded();\n        isAllExcluded |= colMeta.isAllExcluded();\n    }\n\n    /**\n     * Returns the name of this column.\n     */\n    @Override\n    public String toString() {\n        return getName();\n    }\n\n    /**\n     * Two {@link TableColumn}s are considered equal if their tables and names match.\n     */\n    private class ColumnComparator implements Comparator<TableColumn> {\n\n        public int compare(TableColumn column1, TableColumn column2) {\n            int rc = column1.getTable().compareTo(column2.getTable());\n            if (rc == 0)\n                rc = column1.getName().compareToIgnoreCase(column2.getName());\n            return rc;\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if this column is permitted to be an implied FK\n     * (based on name/type/size matches to PKs).\n     *\n     * @return\n     */\n    public boolean allowsImpliedParents() {\n        return allowImpliedParents;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is permitted to be a PK to an implied FK\n     * (based on name/type/size matches to PKs).\n     *\n     * @return\n     */\n    public boolean allowsImpliedChildren() {\n        return allowImpliedChildren;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableColumnTest6.java",
		"test_prompt": "// TableColumnTest6.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TableColumn}.\n* It contains ten unit test cases for the {@link TableColumn#isAllExcluded()} method.\n*/\nclass TableColumnTest6 {"
	},
	{
		"original_code": "// TableColumn.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\n\npublic class TableColumn {\n\n    private final Table table;\n\n    private final String name;\n\n    private final Object id;\n\n    private String type;\n\n    private String shortType;\n\n    private final int length;\n\n    private final int decimalDigits;\n\n    private final String detailedSize;\n\n    private final boolean isNullable;\n\n    private boolean isAutoUpdated;\n\n    private Boolean isUnique;\n\n    private final Object defaultValue;\n\n    private String comments;\n\n    private final Map<TableColumn, ForeignKeyConstraint> parents = new HashMap<TableColumn, ForeignKeyConstraint>();\n\n    private final Map<TableColumn, ForeignKeyConstraint> children = new TreeMap<TableColumn, ForeignKeyConstraint>(new ColumnComparator());\n\n    private boolean allowImpliedParents = true;\n\n    private boolean allowImpliedChildren = true;\n\n    private boolean isExcluded = false;\n\n    private boolean isAllExcluded = false;\n\n    private static final Logger logger = Logger.getLogger(TableColumn.class.getName());\n\n    private static final boolean finerEnabled = logger.isLoggable(Level.FINER);\n\n    /**\n     * Create a column associated with a table.\n     *\n     * @param table Table the table that this column belongs to\n     * @param rs ResultSet returned from {@link DatabaseMetaData#getColumns(String, String, String, String)}\n     * @throws SQLException\n     */\n    TableColumn(Table table, ResultSet rs) throws SQLException {\n        this.table = table;\n        // names and types are typically reused *many* times in a database,\n        // so keep a single instance of each distinct one\n        // (thanks to Mike Barnes for the suggestion)\n        String tmp = rs.getString(\"COLUMN_NAME\");\n        name = tmp == null ? null : tmp.intern();\n        tmp = rs.getString(\"TYPE_NAME\");\n        type = tmp == null ? \"unknown\" : tmp.intern();\n        decimalDigits = rs.getInt(\"DECIMAL_DIGITS\");\n        Number bufLength = (Number) rs.getObject(\"BUFFER_LENGTH\");\n        if (bufLength != null && bufLength.shortValue() > 0)\n            length = bufLength.shortValue();\n        else\n            length = rs.getInt(\"COLUMN_SIZE\");\n        StringBuilder buf = new StringBuilder();\n        buf.append(length);\n        if (decimalDigits > 0) {\n            buf.append(',');\n            buf.append(decimalDigits);\n        }\n        detailedSize = buf.toString();\n        isNullable = rs.getInt(\"NULLABLE\") == DatabaseMetaData.columnNullable;\n        defaultValue = rs.getString(\"COLUMN_DEF\");\n        setComments(rs.getString(\"REMARKS\"));\n        id = new Integer(rs.getInt(\"ORDINAL_POSITION\") - 1);\n        Pattern excludeIndirectColumns = Config.getInstance().getIndirectColumnExclusions();\n        Pattern excludeColumns = Config.getInstance().getColumnExclusions();\n        isAllExcluded = matches(excludeColumns);\n        isExcluded = isAllExcluded || matches(excludeIndirectColumns);\n        if (isExcluded && finerEnabled) {\n            logger.finer(\"Excluding column \" + getTable() + '.' + getName() + \": matches \" + excludeColumns + \":\" + isAllExcluded + \" \" + excludeIndirectColumns + \":\" + matches(excludeIndirectColumns));\n        }\n    }\n\n    /**\n     * A TableColumn that's derived from something other than traditional database metadata\n     * (e.g. defined in XML).\n     *\n     * @param table\n     * @param colMeta\n     */\n    public TableColumn(Table table, TableColumnMeta colMeta) {\n        this.table = table;\n        name = colMeta.getName();\n        id = colMeta.getId();\n        type = colMeta.getType();\n        length = colMeta.getSize();\n        decimalDigits = colMeta.getDigits();\n        StringBuilder buf = new StringBuilder();\n        buf.append(length);\n        if (decimalDigits > 0) {\n            buf.append(',');\n            buf.append(decimalDigits);\n        }\n        detailedSize = buf.toString();\n        isNullable = colMeta.isNullable();\n        isAutoUpdated = colMeta.isAutoUpdated();\n        defaultValue = colMeta.getDefaultValue();\n        comments = colMeta.getComments();\n    }\n\n    /**\n     * Returns the {@link Table} that this column belongs to.\n     *\n     * @return\n     */\n    public Table getTable() {\n        return table;\n    }\n\n    /**\n     * Returns the column's name.\n     *\n     * @return\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the ID of the column or <code>null</code> if the database doesn't support the concept.\n     *\n     * @return\n     */\n    public Object getId() {\n        return id;\n    }\n\n    /**\n     * Type of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>TYPE_NAME</code>.\n     * @return\n     */\n    public String getType() {\n        return type;\n    }\n\n    /**\n     * Normally only used for \"special\" types such as enums.\n     *\n     * @param type\n     */\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    /**\n     * Abbreviated form of {@link #getType()}\n     *\n     * @return\n     */\n    public String getShortType() {\n        return shortType == null ? type : shortType;\n    }\n\n    /**\n     * Abbreviated form of {@link #setType(String)}\n     *\n     * @param shortType\n     */\n    public void setShortType(String shortType) {\n        this.shortType = shortType;\n    }\n\n    /**\n     * Length of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>BUFFER_LENGTH</code>,\n     * or if that's <code>null</code>, <code>COLUMN_SIZE</code>.\n     * @return\n     */\n    public int getLength() {\n        return length;\n    }\n\n    /**\n     * Decimal digits of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>DECIMAL_DIGITS</code>.\n     *\n     * @return\n     */\n    public int getDecimalDigits() {\n        return decimalDigits;\n    }\n\n    /**\n     * String representation of length with optional decimal digits (if decimal digits &gt; 0).\n     *\n     * @return\n     */\n    public String getDetailedSize() {\n        return detailedSize;\n    }\n\n    /**\n     * Returns <code>true</code> if null values are allowed\n     *\n     * @return\n     */\n    public boolean isNullable() {\n        return isNullable;\n    }\n\n    /**\n     * See {@link java.sql.ResultSetMetaData#isAutoIncrement(int)}\n     *\n     * @return\n     */\n    public boolean isAutoUpdated() {\n        return isAutoUpdated;\n    }\n\n    /**\n     * setIsAutoUpdated\n     *\n     * @param isAutoUpdated boolean\n     */\n    public void setIsAutoUpdated(boolean isAutoUpdated) {\n        this.isAutoUpdated = isAutoUpdated;\n    }\n\n    /**\n     * Returns <code>true</code> if this column can only contain unique values\n     *\n     * @return\n     */\n    public boolean isUnique() {\n        if (isUnique == null) {\n            // see if there's a unique index on this column by itself\n            for (TableIndex index : table.getIndexes()) {\n                if (index.isUnique()) {\n                    List<TableColumn> indexColumns = index.getColumns();\n                    if (indexColumns.size() == 1 && indexColumns.contains(this)) {\n                        isUnique = true;\n                        break;\n                    }\n                }\n            }\n            if (isUnique == null) {\n                // if it's a single PK column then it's unique\n                isUnique = table.getPrimaryColumns().size() == 1 && isPrimary();\n            }\n        }\n        return isUnique;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is a primary key\n     *\n     * @return\n     */\n    public boolean isPrimary() {\n        return table.getPrimaryColumns().contains(this);\n    }\n\n    /**\n     * Returns <code>true</code> if this column points to another table's primary key.\n     *\n     * @return\n     */\n    public boolean isForeignKey() {\n        return !parents.isEmpty();\n    }\n\n    /**\n     * Returns the value that the database uses for this column if one isn't provided.\n     *\n     * @return\n     */\n    public Object getDefaultValue() {\n        return defaultValue;\n    }\n\n    /**\n     * @return Comments associated with this column, or <code>null</code> if none.\n     */\n    public String getComments() {\n        return comments;\n    }\n\n    /**\n     * See {@link #getComments()}\n     * @param comments\n     */\n    public void setComments(String comments) {\n        this.comments = (comments == null || comments.trim().length() == 0) ? null : comments.trim();\n    }\n\n    /**\n     * Returns <code>true</code> if this column is to be excluded from relationship diagrams.\n     * Unless {@link #isAllExcluded()} is true this column will be included in the detailed\n     * diagrams of the containing table.\n     *\n     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables\n     * reference a given column.\n     *\n     * @return\n     */\n    public boolean isExcluded() {\n        return isExcluded;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is to be excluded from all relationships in\n     * relationship diagrams.  This includes the detailed diagrams of the containing table.\n     *\n     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables\n     * reference a given column.\n     *\n     * @return\n     */\n    public boolean isAllExcluded() {\n        return isAllExcluded;\n    }\n\n    /**\n     * Add a parent column (PK) to this column (FK) via the associated constraint\n     *\n     * @param parent\n     * @param constraint\n     */\n    public void addParent(TableColumn parent, ForeignKeyConstraint constraint) {\n        parents.put(parent, constraint);\n        table.addedParent();\n    }\n\n    /**\n     * Remove the specified parent column from this column\n     *\n     * @param parent\n     */\n    public void removeParent(TableColumn parent) {\n        parents.remove(parent);\n    }\n\n    /**\n     * Disassociate all parents from this column\n     */\n    public void unlinkParents() {\n        for (TableColumn parent : parents.keySet()) {\n            parent.removeChild(this);\n        }\n        parents.clear();\n    }\n\n    /**\n     * Returns the {@link Set} of all {@link TableColumn parents} associated with this column\n     *\n     * @return\n     */\n    public Set<TableColumn> getParents() {\n        return parents.keySet();\n    }\n\n    /**\n     * Returns the constraint that connects this column to the specified column (this 'child' column to specified 'parent' column)\n     */\n    public ForeignKeyConstraint getParentConstraint(TableColumn parent) {\n        return parents.get(parent);\n    }\n\n    /**\n     * Removes a parent constraint and returns it, or null if there are no parent constraints\n     *\n     * @return the removed {@link ForeignKeyConstraint}\n     */\n    public ForeignKeyConstraint removeAParentFKConstraint() {\n        for (TableColumn relatedColumn : parents.keySet()) {\n            ForeignKeyConstraint constraint = parents.remove(relatedColumn);\n            relatedColumn.removeChild(this);\n            return constraint;\n        }\n        return null;\n    }\n\n    /**\n     * Remove one child {@link ForeignKeyConstraint} that points to this column.\n     *\n     * @return the removed constraint, or <code>null</code> if none were available to be removed\n     */\n    public ForeignKeyConstraint removeAChildFKConstraint() {\n        for (TableColumn relatedColumn : children.keySet()) {\n            ForeignKeyConstraint constraint = children.remove(relatedColumn);\n            relatedColumn.removeParent(this);\n            return constraint;\n        }\n        return null;\n    }\n\n    /**\n     * Add a child column (FK) to this column (PK) via the associated constraint\n     *\n     * @param child\n     * @param constraint\n     */\n    public void addChild(TableColumn child, ForeignKeyConstraint constraint) {\n        children.put(child, constraint);\n        table.addedChild();\n    }\n\n    /**\n     * Remove the specified child column from this column\n     *\n     * @param child\n     */\n    public void removeChild(TableColumn child) {\n        children.remove(child);\n    }\n\n    /**\n     * Disassociate all children from this column\n     */\n    public void unlinkChildren() {\n        for (TableColumn child : children.keySet()) child.removeParent(this);\n        children.clear();\n    }\n\n    /**\n     * Returns <code>Set</code> of <code>TableColumn</code>s that have a real (or implied) foreign key that\n     * references this <code>TableColumn</code>.\n     * @return Set\n     */\n    public Set<TableColumn> getChildren() {\n        return children.keySet();\n    }\n\n    /**\n     * returns the constraint that connects the specified column to this column\n     * (specified 'child' to this 'parent' column)\n     */\n    public ForeignKeyConstraint getChildConstraint(TableColumn child) {\n        return children.get(child);\n    }\n\n    /**\n     * Returns <code>true</code> if tableName.columnName matches the supplied\n     * regular expression.\n     *\n     * @param regex\n     * @return\n     */\n    public boolean matches(Pattern regex) {\n        return regex.matcher(getTable().getName() + '.' + getName()).matches();\n    }\n\n    /**\n     * Update the state of this column with the supplied {@link TableColumnMeta}.\n     * Intended to be used with instances created by {@link #TableColumn(Table, TableColumnMeta)}.\n     *\n     * @param colMeta\n     */\n    public void update(TableColumnMeta colMeta) {\n        String newComments = colMeta.getComments();\n        if (newComments != null)\n            setComments(newComments);\n        if (!isPrimary() && colMeta.isPrimary()) {\n            table.setPrimaryColumn(this);\n        }\n        allowImpliedParents = !colMeta.isImpliedParentsDisabled();\n        allowImpliedChildren = !colMeta.isImpliedChildrenDisabled();\n        isExcluded |= colMeta.isExcluded();\n        isAllExcluded |= colMeta.isAllExcluded();\n    }\n\n    /**\n     * Returns the name of this column.\n     */\n    @Override\n    public String toString() {\n        return getName();\n    }\n\n    /**\n     * Two {@link TableColumn}s are considered equal if their tables and names match.\n     */\n    private class ColumnComparator implements Comparator<TableColumn> {\n\n        public int compare(TableColumn column1, TableColumn column2) {\n            int rc = column1.getTable().compareTo(column2.getTable());\n            if (rc == 0)\n                rc = column1.getName().compareToIgnoreCase(column2.getName());\n            return rc;\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if this column is permitted to be an implied FK\n     * (based on name/type/size matches to PKs).\n     *\n     * @return\n     */\n    public boolean allowsImpliedParents() {\n        return allowImpliedParents;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is permitted to be a PK to an implied FK\n     * (based on name/type/size matches to PKs).\n     *\n     * @return\n     */\n    public boolean allowsImpliedChildren() {\n        return allowImpliedChildren;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableColumnTest7.java",
		"test_prompt": "// TableColumnTest7.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TableColumn}.\n* It contains ten unit test cases for the {@link TableColumn#removeAParentFKConstraint()} method.\n*/\nclass TableColumnTest7 {"
	},
	{
		"original_code": "// TableColumn.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\n\npublic class TableColumn {\n\n    private final Table table;\n\n    private final String name;\n\n    private final Object id;\n\n    private String type;\n\n    private String shortType;\n\n    private final int length;\n\n    private final int decimalDigits;\n\n    private final String detailedSize;\n\n    private final boolean isNullable;\n\n    private boolean isAutoUpdated;\n\n    private Boolean isUnique;\n\n    private final Object defaultValue;\n\n    private String comments;\n\n    private final Map<TableColumn, ForeignKeyConstraint> parents = new HashMap<TableColumn, ForeignKeyConstraint>();\n\n    private final Map<TableColumn, ForeignKeyConstraint> children = new TreeMap<TableColumn, ForeignKeyConstraint>(new ColumnComparator());\n\n    private boolean allowImpliedParents = true;\n\n    private boolean allowImpliedChildren = true;\n\n    private boolean isExcluded = false;\n\n    private boolean isAllExcluded = false;\n\n    private static final Logger logger = Logger.getLogger(TableColumn.class.getName());\n\n    private static final boolean finerEnabled = logger.isLoggable(Level.FINER);\n\n    /**\n     * Create a column associated with a table.\n     *\n     * @param table Table the table that this column belongs to\n     * @param rs ResultSet returned from {@link DatabaseMetaData#getColumns(String, String, String, String)}\n     * @throws SQLException\n     */\n    TableColumn(Table table, ResultSet rs) throws SQLException {\n        this.table = table;\n        // names and types are typically reused *many* times in a database,\n        // so keep a single instance of each distinct one\n        // (thanks to Mike Barnes for the suggestion)\n        String tmp = rs.getString(\"COLUMN_NAME\");\n        name = tmp == null ? null : tmp.intern();\n        tmp = rs.getString(\"TYPE_NAME\");\n        type = tmp == null ? \"unknown\" : tmp.intern();\n        decimalDigits = rs.getInt(\"DECIMAL_DIGITS\");\n        Number bufLength = (Number) rs.getObject(\"BUFFER_LENGTH\");\n        if (bufLength != null && bufLength.shortValue() > 0)\n            length = bufLength.shortValue();\n        else\n            length = rs.getInt(\"COLUMN_SIZE\");\n        StringBuilder buf = new StringBuilder();\n        buf.append(length);\n        if (decimalDigits > 0) {\n            buf.append(',');\n            buf.append(decimalDigits);\n        }\n        detailedSize = buf.toString();\n        isNullable = rs.getInt(\"NULLABLE\") == DatabaseMetaData.columnNullable;\n        defaultValue = rs.getString(\"COLUMN_DEF\");\n        setComments(rs.getString(\"REMARKS\"));\n        id = new Integer(rs.getInt(\"ORDINAL_POSITION\") - 1);\n        Pattern excludeIndirectColumns = Config.getInstance().getIndirectColumnExclusions();\n        Pattern excludeColumns = Config.getInstance().getColumnExclusions();\n        isAllExcluded = matches(excludeColumns);\n        isExcluded = isAllExcluded || matches(excludeIndirectColumns);\n        if (isExcluded && finerEnabled) {\n            logger.finer(\"Excluding column \" + getTable() + '.' + getName() + \": matches \" + excludeColumns + \":\" + isAllExcluded + \" \" + excludeIndirectColumns + \":\" + matches(excludeIndirectColumns));\n        }\n    }\n\n    /**\n     * A TableColumn that's derived from something other than traditional database metadata\n     * (e.g. defined in XML).\n     *\n     * @param table\n     * @param colMeta\n     */\n    public TableColumn(Table table, TableColumnMeta colMeta) {\n        this.table = table;\n        name = colMeta.getName();\n        id = colMeta.getId();\n        type = colMeta.getType();\n        length = colMeta.getSize();\n        decimalDigits = colMeta.getDigits();\n        StringBuilder buf = new StringBuilder();\n        buf.append(length);\n        if (decimalDigits > 0) {\n            buf.append(',');\n            buf.append(decimalDigits);\n        }\n        detailedSize = buf.toString();\n        isNullable = colMeta.isNullable();\n        isAutoUpdated = colMeta.isAutoUpdated();\n        defaultValue = colMeta.getDefaultValue();\n        comments = colMeta.getComments();\n    }\n\n    /**\n     * Returns the {@link Table} that this column belongs to.\n     *\n     * @return\n     */\n    public Table getTable() {\n        return table;\n    }\n\n    /**\n     * Returns the column's name.\n     *\n     * @return\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the ID of the column or <code>null</code> if the database doesn't support the concept.\n     *\n     * @return\n     */\n    public Object getId() {\n        return id;\n    }\n\n    /**\n     * Type of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>TYPE_NAME</code>.\n     * @return\n     */\n    public String getType() {\n        return type;\n    }\n\n    /**\n     * Normally only used for \"special\" types such as enums.\n     *\n     * @param type\n     */\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    /**\n     * Abbreviated form of {@link #getType()}\n     *\n     * @return\n     */\n    public String getShortType() {\n        return shortType == null ? type : shortType;\n    }\n\n    /**\n     * Abbreviated form of {@link #setType(String)}\n     *\n     * @param shortType\n     */\n    public void setShortType(String shortType) {\n        this.shortType = shortType;\n    }\n\n    /**\n     * Length of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>BUFFER_LENGTH</code>,\n     * or if that's <code>null</code>, <code>COLUMN_SIZE</code>.\n     * @return\n     */\n    public int getLength() {\n        return length;\n    }\n\n    /**\n     * Decimal digits of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>DECIMAL_DIGITS</code>.\n     *\n     * @return\n     */\n    public int getDecimalDigits() {\n        return decimalDigits;\n    }\n\n    /**\n     * String representation of length with optional decimal digits (if decimal digits &gt; 0).\n     *\n     * @return\n     */\n    public String getDetailedSize() {\n        return detailedSize;\n    }\n\n    /**\n     * Returns <code>true</code> if null values are allowed\n     *\n     * @return\n     */\n    public boolean isNullable() {\n        return isNullable;\n    }\n\n    /**\n     * See {@link java.sql.ResultSetMetaData#isAutoIncrement(int)}\n     *\n     * @return\n     */\n    public boolean isAutoUpdated() {\n        return isAutoUpdated;\n    }\n\n    /**\n     * setIsAutoUpdated\n     *\n     * @param isAutoUpdated boolean\n     */\n    public void setIsAutoUpdated(boolean isAutoUpdated) {\n        this.isAutoUpdated = isAutoUpdated;\n    }\n\n    /**\n     * Returns <code>true</code> if this column can only contain unique values\n     *\n     * @return\n     */\n    public boolean isUnique() {\n        if (isUnique == null) {\n            // see if there's a unique index on this column by itself\n            for (TableIndex index : table.getIndexes()) {\n                if (index.isUnique()) {\n                    List<TableColumn> indexColumns = index.getColumns();\n                    if (indexColumns.size() == 1 && indexColumns.contains(this)) {\n                        isUnique = true;\n                        break;\n                    }\n                }\n            }\n            if (isUnique == null) {\n                // if it's a single PK column then it's unique\n                isUnique = table.getPrimaryColumns().size() == 1 && isPrimary();\n            }\n        }\n        return isUnique;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is a primary key\n     *\n     * @return\n     */\n    public boolean isPrimary() {\n        return table.getPrimaryColumns().contains(this);\n    }\n\n    /**\n     * Returns <code>true</code> if this column points to another table's primary key.\n     *\n     * @return\n     */\n    public boolean isForeignKey() {\n        return !parents.isEmpty();\n    }\n\n    /**\n     * Returns the value that the database uses for this column if one isn't provided.\n     *\n     * @return\n     */\n    public Object getDefaultValue() {\n        return defaultValue;\n    }\n\n    /**\n     * @return Comments associated with this column, or <code>null</code> if none.\n     */\n    public String getComments() {\n        return comments;\n    }\n\n    /**\n     * See {@link #getComments()}\n     * @param comments\n     */\n    public void setComments(String comments) {\n        this.comments = (comments == null || comments.trim().length() == 0) ? null : comments.trim();\n    }\n\n    /**\n     * Returns <code>true</code> if this column is to be excluded from relationship diagrams.\n     * Unless {@link #isAllExcluded()} is true this column will be included in the detailed\n     * diagrams of the containing table.\n     *\n     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables\n     * reference a given column.\n     *\n     * @return\n     */\n    public boolean isExcluded() {\n        return isExcluded;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is to be excluded from all relationships in\n     * relationship diagrams.  This includes the detailed diagrams of the containing table.\n     *\n     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables\n     * reference a given column.\n     *\n     * @return\n     */\n    public boolean isAllExcluded() {\n        return isAllExcluded;\n    }\n\n    /**\n     * Add a parent column (PK) to this column (FK) via the associated constraint\n     *\n     * @param parent\n     * @param constraint\n     */\n    public void addParent(TableColumn parent, ForeignKeyConstraint constraint) {\n        parents.put(parent, constraint);\n        table.addedParent();\n    }\n\n    /**\n     * Remove the specified parent column from this column\n     *\n     * @param parent\n     */\n    public void removeParent(TableColumn parent) {\n        parents.remove(parent);\n    }\n\n    /**\n     * Disassociate all parents from this column\n     */\n    public void unlinkParents() {\n        for (TableColumn parent : parents.keySet()) {\n            parent.removeChild(this);\n        }\n        parents.clear();\n    }\n\n    /**\n     * Returns the {@link Set} of all {@link TableColumn parents} associated with this column\n     *\n     * @return\n     */\n    public Set<TableColumn> getParents() {\n        return parents.keySet();\n    }\n\n    /**\n     * Returns the constraint that connects this column to the specified column (this 'child' column to specified 'parent' column)\n     */\n    public ForeignKeyConstraint getParentConstraint(TableColumn parent) {\n        return parents.get(parent);\n    }\n\n    /**\n     * Removes a parent constraint and returns it, or null if there are no parent constraints\n     *\n     * @return the removed {@link ForeignKeyConstraint}\n     */\n    public ForeignKeyConstraint removeAParentFKConstraint() {\n        for (TableColumn relatedColumn : parents.keySet()) {\n            ForeignKeyConstraint constraint = parents.remove(relatedColumn);\n            relatedColumn.removeChild(this);\n            return constraint;\n        }\n        return null;\n    }\n\n    /**\n     * Remove one child {@link ForeignKeyConstraint} that points to this column.\n     *\n     * @return the removed constraint, or <code>null</code> if none were available to be removed\n     */\n    public ForeignKeyConstraint removeAChildFKConstraint() {\n        for (TableColumn relatedColumn : children.keySet()) {\n            ForeignKeyConstraint constraint = children.remove(relatedColumn);\n            relatedColumn.removeParent(this);\n            return constraint;\n        }\n        return null;\n    }\n\n    /**\n     * Add a child column (FK) to this column (PK) via the associated constraint\n     *\n     * @param child\n     * @param constraint\n     */\n    public void addChild(TableColumn child, ForeignKeyConstraint constraint) {\n        children.put(child, constraint);\n        table.addedChild();\n    }\n\n    /**\n     * Remove the specified child column from this column\n     *\n     * @param child\n     */\n    public void removeChild(TableColumn child) {\n        children.remove(child);\n    }\n\n    /**\n     * Disassociate all children from this column\n     */\n    public void unlinkChildren() {\n        for (TableColumn child : children.keySet()) child.removeParent(this);\n        children.clear();\n    }\n\n    /**\n     * Returns <code>Set</code> of <code>TableColumn</code>s that have a real (or implied) foreign key that\n     * references this <code>TableColumn</code>.\n     * @return Set\n     */\n    public Set<TableColumn> getChildren() {\n        return children.keySet();\n    }\n\n    /**\n     * returns the constraint that connects the specified column to this column\n     * (specified 'child' to this 'parent' column)\n     */\n    public ForeignKeyConstraint getChildConstraint(TableColumn child) {\n        return children.get(child);\n    }\n\n    /**\n     * Returns <code>true</code> if tableName.columnName matches the supplied\n     * regular expression.\n     *\n     * @param regex\n     * @return\n     */\n    public boolean matches(Pattern regex) {\n        return regex.matcher(getTable().getName() + '.' + getName()).matches();\n    }\n\n    /**\n     * Update the state of this column with the supplied {@link TableColumnMeta}.\n     * Intended to be used with instances created by {@link #TableColumn(Table, TableColumnMeta)}.\n     *\n     * @param colMeta\n     */\n    public void update(TableColumnMeta colMeta) {\n        String newComments = colMeta.getComments();\n        if (newComments != null)\n            setComments(newComments);\n        if (!isPrimary() && colMeta.isPrimary()) {\n            table.setPrimaryColumn(this);\n        }\n        allowImpliedParents = !colMeta.isImpliedParentsDisabled();\n        allowImpliedChildren = !colMeta.isImpliedChildrenDisabled();\n        isExcluded |= colMeta.isExcluded();\n        isAllExcluded |= colMeta.isAllExcluded();\n    }\n\n    /**\n     * Returns the name of this column.\n     */\n    @Override\n    public String toString() {\n        return getName();\n    }\n\n    /**\n     * Two {@link TableColumn}s are considered equal if their tables and names match.\n     */\n    private class ColumnComparator implements Comparator<TableColumn> {\n\n        public int compare(TableColumn column1, TableColumn column2) {\n            int rc = column1.getTable().compareTo(column2.getTable());\n            if (rc == 0)\n                rc = column1.getName().compareToIgnoreCase(column2.getName());\n            return rc;\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if this column is permitted to be an implied FK\n     * (based on name/type/size matches to PKs).\n     *\n     * @return\n     */\n    public boolean allowsImpliedParents() {\n        return allowImpliedParents;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is permitted to be a PK to an implied FK\n     * (based on name/type/size matches to PKs).\n     *\n     * @return\n     */\n    public boolean allowsImpliedChildren() {\n        return allowImpliedChildren;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableColumnTest8.java",
		"test_prompt": "// TableColumnTest8.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TableColumn}.\n* It contains ten unit test cases for the {@link TableColumn#removeAChildFKConstraint()} method.\n*/\nclass TableColumnTest8 {"
	},
	{
		"original_code": "// TableColumn.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\n\npublic class TableColumn {\n\n    private final Table table;\n\n    private final String name;\n\n    private final Object id;\n\n    private String type;\n\n    private String shortType;\n\n    private final int length;\n\n    private final int decimalDigits;\n\n    private final String detailedSize;\n\n    private final boolean isNullable;\n\n    private boolean isAutoUpdated;\n\n    private Boolean isUnique;\n\n    private final Object defaultValue;\n\n    private String comments;\n\n    private final Map<TableColumn, ForeignKeyConstraint> parents = new HashMap<TableColumn, ForeignKeyConstraint>();\n\n    private final Map<TableColumn, ForeignKeyConstraint> children = new TreeMap<TableColumn, ForeignKeyConstraint>(new ColumnComparator());\n\n    private boolean allowImpliedParents = true;\n\n    private boolean allowImpliedChildren = true;\n\n    private boolean isExcluded = false;\n\n    private boolean isAllExcluded = false;\n\n    private static final Logger logger = Logger.getLogger(TableColumn.class.getName());\n\n    private static final boolean finerEnabled = logger.isLoggable(Level.FINER);\n\n    /**\n     * Create a column associated with a table.\n     *\n     * @param table Table the table that this column belongs to\n     * @param rs ResultSet returned from {@link DatabaseMetaData#getColumns(String, String, String, String)}\n     * @throws SQLException\n     */\n    TableColumn(Table table, ResultSet rs) throws SQLException {\n        this.table = table;\n        // names and types are typically reused *many* times in a database,\n        // so keep a single instance of each distinct one\n        // (thanks to Mike Barnes for the suggestion)\n        String tmp = rs.getString(\"COLUMN_NAME\");\n        name = tmp == null ? null : tmp.intern();\n        tmp = rs.getString(\"TYPE_NAME\");\n        type = tmp == null ? \"unknown\" : tmp.intern();\n        decimalDigits = rs.getInt(\"DECIMAL_DIGITS\");\n        Number bufLength = (Number) rs.getObject(\"BUFFER_LENGTH\");\n        if (bufLength != null && bufLength.shortValue() > 0)\n            length = bufLength.shortValue();\n        else\n            length = rs.getInt(\"COLUMN_SIZE\");\n        StringBuilder buf = new StringBuilder();\n        buf.append(length);\n        if (decimalDigits > 0) {\n            buf.append(',');\n            buf.append(decimalDigits);\n        }\n        detailedSize = buf.toString();\n        isNullable = rs.getInt(\"NULLABLE\") == DatabaseMetaData.columnNullable;\n        defaultValue = rs.getString(\"COLUMN_DEF\");\n        setComments(rs.getString(\"REMARKS\"));\n        id = new Integer(rs.getInt(\"ORDINAL_POSITION\") - 1);\n        Pattern excludeIndirectColumns = Config.getInstance().getIndirectColumnExclusions();\n        Pattern excludeColumns = Config.getInstance().getColumnExclusions();\n        isAllExcluded = matches(excludeColumns);\n        isExcluded = isAllExcluded || matches(excludeIndirectColumns);\n        if (isExcluded && finerEnabled) {\n            logger.finer(\"Excluding column \" + getTable() + '.' + getName() + \": matches \" + excludeColumns + \":\" + isAllExcluded + \" \" + excludeIndirectColumns + \":\" + matches(excludeIndirectColumns));\n        }\n    }\n\n    /**\n     * A TableColumn that's derived from something other than traditional database metadata\n     * (e.g. defined in XML).\n     *\n     * @param table\n     * @param colMeta\n     */\n    public TableColumn(Table table, TableColumnMeta colMeta) {\n        this.table = table;\n        name = colMeta.getName();\n        id = colMeta.getId();\n        type = colMeta.getType();\n        length = colMeta.getSize();\n        decimalDigits = colMeta.getDigits();\n        StringBuilder buf = new StringBuilder();\n        buf.append(length);\n        if (decimalDigits > 0) {\n            buf.append(',');\n            buf.append(decimalDigits);\n        }\n        detailedSize = buf.toString();\n        isNullable = colMeta.isNullable();\n        isAutoUpdated = colMeta.isAutoUpdated();\n        defaultValue = colMeta.getDefaultValue();\n        comments = colMeta.getComments();\n    }\n\n    /**\n     * Returns the {@link Table} that this column belongs to.\n     *\n     * @return\n     */\n    public Table getTable() {\n        return table;\n    }\n\n    /**\n     * Returns the column's name.\n     *\n     * @return\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the ID of the column or <code>null</code> if the database doesn't support the concept.\n     *\n     * @return\n     */\n    public Object getId() {\n        return id;\n    }\n\n    /**\n     * Type of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>TYPE_NAME</code>.\n     * @return\n     */\n    public String getType() {\n        return type;\n    }\n\n    /**\n     * Normally only used for \"special\" types such as enums.\n     *\n     * @param type\n     */\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    /**\n     * Abbreviated form of {@link #getType()}\n     *\n     * @return\n     */\n    public String getShortType() {\n        return shortType == null ? type : shortType;\n    }\n\n    /**\n     * Abbreviated form of {@link #setType(String)}\n     *\n     * @param shortType\n     */\n    public void setShortType(String shortType) {\n        this.shortType = shortType;\n    }\n\n    /**\n     * Length of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>BUFFER_LENGTH</code>,\n     * or if that's <code>null</code>, <code>COLUMN_SIZE</code>.\n     * @return\n     */\n    public int getLength() {\n        return length;\n    }\n\n    /**\n     * Decimal digits of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>DECIMAL_DIGITS</code>.\n     *\n     * @return\n     */\n    public int getDecimalDigits() {\n        return decimalDigits;\n    }\n\n    /**\n     * String representation of length with optional decimal digits (if decimal digits &gt; 0).\n     *\n     * @return\n     */\n    public String getDetailedSize() {\n        return detailedSize;\n    }\n\n    /**\n     * Returns <code>true</code> if null values are allowed\n     *\n     * @return\n     */\n    public boolean isNullable() {\n        return isNullable;\n    }\n\n    /**\n     * See {@link java.sql.ResultSetMetaData#isAutoIncrement(int)}\n     *\n     * @return\n     */\n    public boolean isAutoUpdated() {\n        return isAutoUpdated;\n    }\n\n    /**\n     * setIsAutoUpdated\n     *\n     * @param isAutoUpdated boolean\n     */\n    public void setIsAutoUpdated(boolean isAutoUpdated) {\n        this.isAutoUpdated = isAutoUpdated;\n    }\n\n    /**\n     * Returns <code>true</code> if this column can only contain unique values\n     *\n     * @return\n     */\n    public boolean isUnique() {\n        if (isUnique == null) {\n            // see if there's a unique index on this column by itself\n            for (TableIndex index : table.getIndexes()) {\n                if (index.isUnique()) {\n                    List<TableColumn> indexColumns = index.getColumns();\n                    if (indexColumns.size() == 1 && indexColumns.contains(this)) {\n                        isUnique = true;\n                        break;\n                    }\n                }\n            }\n            if (isUnique == null) {\n                // if it's a single PK column then it's unique\n                isUnique = table.getPrimaryColumns().size() == 1 && isPrimary();\n            }\n        }\n        return isUnique;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is a primary key\n     *\n     * @return\n     */\n    public boolean isPrimary() {\n        return table.getPrimaryColumns().contains(this);\n    }\n\n    /**\n     * Returns <code>true</code> if this column points to another table's primary key.\n     *\n     * @return\n     */\n    public boolean isForeignKey() {\n        return !parents.isEmpty();\n    }\n\n    /**\n     * Returns the value that the database uses for this column if one isn't provided.\n     *\n     * @return\n     */\n    public Object getDefaultValue() {\n        return defaultValue;\n    }\n\n    /**\n     * @return Comments associated with this column, or <code>null</code> if none.\n     */\n    public String getComments() {\n        return comments;\n    }\n\n    /**\n     * See {@link #getComments()}\n     * @param comments\n     */\n    public void setComments(String comments) {\n        this.comments = (comments == null || comments.trim().length() == 0) ? null : comments.trim();\n    }\n\n    /**\n     * Returns <code>true</code> if this column is to be excluded from relationship diagrams.\n     * Unless {@link #isAllExcluded()} is true this column will be included in the detailed\n     * diagrams of the containing table.\n     *\n     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables\n     * reference a given column.\n     *\n     * @return\n     */\n    public boolean isExcluded() {\n        return isExcluded;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is to be excluded from all relationships in\n     * relationship diagrams.  This includes the detailed diagrams of the containing table.\n     *\n     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables\n     * reference a given column.\n     *\n     * @return\n     */\n    public boolean isAllExcluded() {\n        return isAllExcluded;\n    }\n\n    /**\n     * Add a parent column (PK) to this column (FK) via the associated constraint\n     *\n     * @param parent\n     * @param constraint\n     */\n    public void addParent(TableColumn parent, ForeignKeyConstraint constraint) {\n        parents.put(parent, constraint);\n        table.addedParent();\n    }\n\n    /**\n     * Remove the specified parent column from this column\n     *\n     * @param parent\n     */\n    public void removeParent(TableColumn parent) {\n        parents.remove(parent);\n    }\n\n    /**\n     * Disassociate all parents from this column\n     */\n    public void unlinkParents() {\n        for (TableColumn parent : parents.keySet()) {\n            parent.removeChild(this);\n        }\n        parents.clear();\n    }\n\n    /**\n     * Returns the {@link Set} of all {@link TableColumn parents} associated with this column\n     *\n     * @return\n     */\n    public Set<TableColumn> getParents() {\n        return parents.keySet();\n    }\n\n    /**\n     * Returns the constraint that connects this column to the specified column (this 'child' column to specified 'parent' column)\n     */\n    public ForeignKeyConstraint getParentConstraint(TableColumn parent) {\n        return parents.get(parent);\n    }\n\n    /**\n     * Removes a parent constraint and returns it, or null if there are no parent constraints\n     *\n     * @return the removed {@link ForeignKeyConstraint}\n     */\n    public ForeignKeyConstraint removeAParentFKConstraint() {\n        for (TableColumn relatedColumn : parents.keySet()) {\n            ForeignKeyConstraint constraint = parents.remove(relatedColumn);\n            relatedColumn.removeChild(this);\n            return constraint;\n        }\n        return null;\n    }\n\n    /**\n     * Remove one child {@link ForeignKeyConstraint} that points to this column.\n     *\n     * @return the removed constraint, or <code>null</code> if none were available to be removed\n     */\n    public ForeignKeyConstraint removeAChildFKConstraint() {\n        for (TableColumn relatedColumn : children.keySet()) {\n            ForeignKeyConstraint constraint = children.remove(relatedColumn);\n            relatedColumn.removeParent(this);\n            return constraint;\n        }\n        return null;\n    }\n\n    /**\n     * Add a child column (FK) to this column (PK) via the associated constraint\n     *\n     * @param child\n     * @param constraint\n     */\n    public void addChild(TableColumn child, ForeignKeyConstraint constraint) {\n        children.put(child, constraint);\n        table.addedChild();\n    }\n\n    /**\n     * Remove the specified child column from this column\n     *\n     * @param child\n     */\n    public void removeChild(TableColumn child) {\n        children.remove(child);\n    }\n\n    /**\n     * Disassociate all children from this column\n     */\n    public void unlinkChildren() {\n        for (TableColumn child : children.keySet()) child.removeParent(this);\n        children.clear();\n    }\n\n    /**\n     * Returns <code>Set</code> of <code>TableColumn</code>s that have a real (or implied) foreign key that\n     * references this <code>TableColumn</code>.\n     * @return Set\n     */\n    public Set<TableColumn> getChildren() {\n        return children.keySet();\n    }\n\n    /**\n     * returns the constraint that connects the specified column to this column\n     * (specified 'child' to this 'parent' column)\n     */\n    public ForeignKeyConstraint getChildConstraint(TableColumn child) {\n        return children.get(child);\n    }\n\n    /**\n     * Returns <code>true</code> if tableName.columnName matches the supplied\n     * regular expression.\n     *\n     * @param regex\n     * @return\n     */\n    public boolean matches(Pattern regex) {\n        return regex.matcher(getTable().getName() + '.' + getName()).matches();\n    }\n\n    /**\n     * Update the state of this column with the supplied {@link TableColumnMeta}.\n     * Intended to be used with instances created by {@link #TableColumn(Table, TableColumnMeta)}.\n     *\n     * @param colMeta\n     */\n    public void update(TableColumnMeta colMeta) {\n        String newComments = colMeta.getComments();\n        if (newComments != null)\n            setComments(newComments);\n        if (!isPrimary() && colMeta.isPrimary()) {\n            table.setPrimaryColumn(this);\n        }\n        allowImpliedParents = !colMeta.isImpliedParentsDisabled();\n        allowImpliedChildren = !colMeta.isImpliedChildrenDisabled();\n        isExcluded |= colMeta.isExcluded();\n        isAllExcluded |= colMeta.isAllExcluded();\n    }\n\n    /**\n     * Returns the name of this column.\n     */\n    @Override\n    public String toString() {\n        return getName();\n    }\n\n    /**\n     * Two {@link TableColumn}s are considered equal if their tables and names match.\n     */\n    private class ColumnComparator implements Comparator<TableColumn> {\n\n        public int compare(TableColumn column1, TableColumn column2) {\n            int rc = column1.getTable().compareTo(column2.getTable());\n            if (rc == 0)\n                rc = column1.getName().compareToIgnoreCase(column2.getName());\n            return rc;\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if this column is permitted to be an implied FK\n     * (based on name/type/size matches to PKs).\n     *\n     * @return\n     */\n    public boolean allowsImpliedParents() {\n        return allowImpliedParents;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is permitted to be a PK to an implied FK\n     * (based on name/type/size matches to PKs).\n     *\n     * @return\n     */\n    public boolean allowsImpliedChildren() {\n        return allowImpliedChildren;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableColumnTest9.java",
		"test_prompt": "// TableColumnTest9.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TableColumn}.\n* It contains ten unit test cases for the {@link TableColumn#matches(Pattern)} method.\n*/\nclass TableColumnTest9 {"
	},
	{
		"original_code": "// TableColumn.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\n\npublic class TableColumn {\n\n    private final Table table;\n\n    private final String name;\n\n    private final Object id;\n\n    private String type;\n\n    private String shortType;\n\n    private final int length;\n\n    private final int decimalDigits;\n\n    private final String detailedSize;\n\n    private final boolean isNullable;\n\n    private boolean isAutoUpdated;\n\n    private Boolean isUnique;\n\n    private final Object defaultValue;\n\n    private String comments;\n\n    private final Map<TableColumn, ForeignKeyConstraint> parents = new HashMap<TableColumn, ForeignKeyConstraint>();\n\n    private final Map<TableColumn, ForeignKeyConstraint> children = new TreeMap<TableColumn, ForeignKeyConstraint>(new ColumnComparator());\n\n    private boolean allowImpliedParents = true;\n\n    private boolean allowImpliedChildren = true;\n\n    private boolean isExcluded = false;\n\n    private boolean isAllExcluded = false;\n\n    private static final Logger logger = Logger.getLogger(TableColumn.class.getName());\n\n    private static final boolean finerEnabled = logger.isLoggable(Level.FINER);\n\n    /**\n     * Create a column associated with a table.\n     *\n     * @param table Table the table that this column belongs to\n     * @param rs ResultSet returned from {@link DatabaseMetaData#getColumns(String, String, String, String)}\n     * @throws SQLException\n     */\n    TableColumn(Table table, ResultSet rs) throws SQLException {\n        this.table = table;\n        // names and types are typically reused *many* times in a database,\n        // so keep a single instance of each distinct one\n        // (thanks to Mike Barnes for the suggestion)\n        String tmp = rs.getString(\"COLUMN_NAME\");\n        name = tmp == null ? null : tmp.intern();\n        tmp = rs.getString(\"TYPE_NAME\");\n        type = tmp == null ? \"unknown\" : tmp.intern();\n        decimalDigits = rs.getInt(\"DECIMAL_DIGITS\");\n        Number bufLength = (Number) rs.getObject(\"BUFFER_LENGTH\");\n        if (bufLength != null && bufLength.shortValue() > 0)\n            length = bufLength.shortValue();\n        else\n            length = rs.getInt(\"COLUMN_SIZE\");\n        StringBuilder buf = new StringBuilder();\n        buf.append(length);\n        if (decimalDigits > 0) {\n            buf.append(',');\n            buf.append(decimalDigits);\n        }\n        detailedSize = buf.toString();\n        isNullable = rs.getInt(\"NULLABLE\") == DatabaseMetaData.columnNullable;\n        defaultValue = rs.getString(\"COLUMN_DEF\");\n        setComments(rs.getString(\"REMARKS\"));\n        id = new Integer(rs.getInt(\"ORDINAL_POSITION\") - 1);\n        Pattern excludeIndirectColumns = Config.getInstance().getIndirectColumnExclusions();\n        Pattern excludeColumns = Config.getInstance().getColumnExclusions();\n        isAllExcluded = matches(excludeColumns);\n        isExcluded = isAllExcluded || matches(excludeIndirectColumns);\n        if (isExcluded && finerEnabled) {\n            logger.finer(\"Excluding column \" + getTable() + '.' + getName() + \": matches \" + excludeColumns + \":\" + isAllExcluded + \" \" + excludeIndirectColumns + \":\" + matches(excludeIndirectColumns));\n        }\n    }\n\n    /**\n     * A TableColumn that's derived from something other than traditional database metadata\n     * (e.g. defined in XML).\n     *\n     * @param table\n     * @param colMeta\n     */\n    public TableColumn(Table table, TableColumnMeta colMeta) {\n        this.table = table;\n        name = colMeta.getName();\n        id = colMeta.getId();\n        type = colMeta.getType();\n        length = colMeta.getSize();\n        decimalDigits = colMeta.getDigits();\n        StringBuilder buf = new StringBuilder();\n        buf.append(length);\n        if (decimalDigits > 0) {\n            buf.append(',');\n            buf.append(decimalDigits);\n        }\n        detailedSize = buf.toString();\n        isNullable = colMeta.isNullable();\n        isAutoUpdated = colMeta.isAutoUpdated();\n        defaultValue = colMeta.getDefaultValue();\n        comments = colMeta.getComments();\n    }\n\n    /**\n     * Returns the {@link Table} that this column belongs to.\n     *\n     * @return\n     */\n    public Table getTable() {\n        return table;\n    }\n\n    /**\n     * Returns the column's name.\n     *\n     * @return\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the ID of the column or <code>null</code> if the database doesn't support the concept.\n     *\n     * @return\n     */\n    public Object getId() {\n        return id;\n    }\n\n    /**\n     * Type of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>TYPE_NAME</code>.\n     * @return\n     */\n    public String getType() {\n        return type;\n    }\n\n    /**\n     * Normally only used for \"special\" types such as enums.\n     *\n     * @param type\n     */\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    /**\n     * Abbreviated form of {@link #getType()}\n     *\n     * @return\n     */\n    public String getShortType() {\n        return shortType == null ? type : shortType;\n    }\n\n    /**\n     * Abbreviated form of {@link #setType(String)}\n     *\n     * @param shortType\n     */\n    public void setShortType(String shortType) {\n        this.shortType = shortType;\n    }\n\n    /**\n     * Length of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>BUFFER_LENGTH</code>,\n     * or if that's <code>null</code>, <code>COLUMN_SIZE</code>.\n     * @return\n     */\n    public int getLength() {\n        return length;\n    }\n\n    /**\n     * Decimal digits of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>DECIMAL_DIGITS</code>.\n     *\n     * @return\n     */\n    public int getDecimalDigits() {\n        return decimalDigits;\n    }\n\n    /**\n     * String representation of length with optional decimal digits (if decimal digits &gt; 0).\n     *\n     * @return\n     */\n    public String getDetailedSize() {\n        return detailedSize;\n    }\n\n    /**\n     * Returns <code>true</code> if null values are allowed\n     *\n     * @return\n     */\n    public boolean isNullable() {\n        return isNullable;\n    }\n\n    /**\n     * See {@link java.sql.ResultSetMetaData#isAutoIncrement(int)}\n     *\n     * @return\n     */\n    public boolean isAutoUpdated() {\n        return isAutoUpdated;\n    }\n\n    /**\n     * setIsAutoUpdated\n     *\n     * @param isAutoUpdated boolean\n     */\n    public void setIsAutoUpdated(boolean isAutoUpdated) {\n        this.isAutoUpdated = isAutoUpdated;\n    }\n\n    /**\n     * Returns <code>true</code> if this column can only contain unique values\n     *\n     * @return\n     */\n    public boolean isUnique() {\n        if (isUnique == null) {\n            // see if there's a unique index on this column by itself\n            for (TableIndex index : table.getIndexes()) {\n                if (index.isUnique()) {\n                    List<TableColumn> indexColumns = index.getColumns();\n                    if (indexColumns.size() == 1 && indexColumns.contains(this)) {\n                        isUnique = true;\n                        break;\n                    }\n                }\n            }\n            if (isUnique == null) {\n                // if it's a single PK column then it's unique\n                isUnique = table.getPrimaryColumns().size() == 1 && isPrimary();\n            }\n        }\n        return isUnique;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is a primary key\n     *\n     * @return\n     */\n    public boolean isPrimary() {\n        return table.getPrimaryColumns().contains(this);\n    }\n\n    /**\n     * Returns <code>true</code> if this column points to another table's primary key.\n     *\n     * @return\n     */\n    public boolean isForeignKey() {\n        return !parents.isEmpty();\n    }\n\n    /**\n     * Returns the value that the database uses for this column if one isn't provided.\n     *\n     * @return\n     */\n    public Object getDefaultValue() {\n        return defaultValue;\n    }\n\n    /**\n     * @return Comments associated with this column, or <code>null</code> if none.\n     */\n    public String getComments() {\n        return comments;\n    }\n\n    /**\n     * See {@link #getComments()}\n     * @param comments\n     */\n    public void setComments(String comments) {\n        this.comments = (comments == null || comments.trim().length() == 0) ? null : comments.trim();\n    }\n\n    /**\n     * Returns <code>true</code> if this column is to be excluded from relationship diagrams.\n     * Unless {@link #isAllExcluded()} is true this column will be included in the detailed\n     * diagrams of the containing table.\n     *\n     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables\n     * reference a given column.\n     *\n     * @return\n     */\n    public boolean isExcluded() {\n        return isExcluded;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is to be excluded from all relationships in\n     * relationship diagrams.  This includes the detailed diagrams of the containing table.\n     *\n     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables\n     * reference a given column.\n     *\n     * @return\n     */\n    public boolean isAllExcluded() {\n        return isAllExcluded;\n    }\n\n    /**\n     * Add a parent column (PK) to this column (FK) via the associated constraint\n     *\n     * @param parent\n     * @param constraint\n     */\n    public void addParent(TableColumn parent, ForeignKeyConstraint constraint) {\n        parents.put(parent, constraint);\n        table.addedParent();\n    }\n\n    /**\n     * Remove the specified parent column from this column\n     *\n     * @param parent\n     */\n    public void removeParent(TableColumn parent) {\n        parents.remove(parent);\n    }\n\n    /**\n     * Disassociate all parents from this column\n     */\n    public void unlinkParents() {\n        for (TableColumn parent : parents.keySet()) {\n            parent.removeChild(this);\n        }\n        parents.clear();\n    }\n\n    /**\n     * Returns the {@link Set} of all {@link TableColumn parents} associated with this column\n     *\n     * @return\n     */\n    public Set<TableColumn> getParents() {\n        return parents.keySet();\n    }\n\n    /**\n     * Returns the constraint that connects this column to the specified column (this 'child' column to specified 'parent' column)\n     */\n    public ForeignKeyConstraint getParentConstraint(TableColumn parent) {\n        return parents.get(parent);\n    }\n\n    /**\n     * Removes a parent constraint and returns it, or null if there are no parent constraints\n     *\n     * @return the removed {@link ForeignKeyConstraint}\n     */\n    public ForeignKeyConstraint removeAParentFKConstraint() {\n        for (TableColumn relatedColumn : parents.keySet()) {\n            ForeignKeyConstraint constraint = parents.remove(relatedColumn);\n            relatedColumn.removeChild(this);\n            return constraint;\n        }\n        return null;\n    }\n\n    /**\n     * Remove one child {@link ForeignKeyConstraint} that points to this column.\n     *\n     * @return the removed constraint, or <code>null</code> if none were available to be removed\n     */\n    public ForeignKeyConstraint removeAChildFKConstraint() {\n        for (TableColumn relatedColumn : children.keySet()) {\n            ForeignKeyConstraint constraint = children.remove(relatedColumn);\n            relatedColumn.removeParent(this);\n            return constraint;\n        }\n        return null;\n    }\n\n    /**\n     * Add a child column (FK) to this column (PK) via the associated constraint\n     *\n     * @param child\n     * @param constraint\n     */\n    public void addChild(TableColumn child, ForeignKeyConstraint constraint) {\n        children.put(child, constraint);\n        table.addedChild();\n    }\n\n    /**\n     * Remove the specified child column from this column\n     *\n     * @param child\n     */\n    public void removeChild(TableColumn child) {\n        children.remove(child);\n    }\n\n    /**\n     * Disassociate all children from this column\n     */\n    public void unlinkChildren() {\n        for (TableColumn child : children.keySet()) child.removeParent(this);\n        children.clear();\n    }\n\n    /**\n     * Returns <code>Set</code> of <code>TableColumn</code>s that have a real (or implied) foreign key that\n     * references this <code>TableColumn</code>.\n     * @return Set\n     */\n    public Set<TableColumn> getChildren() {\n        return children.keySet();\n    }\n\n    /**\n     * returns the constraint that connects the specified column to this column\n     * (specified 'child' to this 'parent' column)\n     */\n    public ForeignKeyConstraint getChildConstraint(TableColumn child) {\n        return children.get(child);\n    }\n\n    /**\n     * Returns <code>true</code> if tableName.columnName matches the supplied\n     * regular expression.\n     *\n     * @param regex\n     * @return\n     */\n    public boolean matches(Pattern regex) {\n        return regex.matcher(getTable().getName() + '.' + getName()).matches();\n    }\n\n    /**\n     * Update the state of this column with the supplied {@link TableColumnMeta}.\n     * Intended to be used with instances created by {@link #TableColumn(Table, TableColumnMeta)}.\n     *\n     * @param colMeta\n     */\n    public void update(TableColumnMeta colMeta) {\n        String newComments = colMeta.getComments();\n        if (newComments != null)\n            setComments(newComments);\n        if (!isPrimary() && colMeta.isPrimary()) {\n            table.setPrimaryColumn(this);\n        }\n        allowImpliedParents = !colMeta.isImpliedParentsDisabled();\n        allowImpliedChildren = !colMeta.isImpliedChildrenDisabled();\n        isExcluded |= colMeta.isExcluded();\n        isAllExcluded |= colMeta.isAllExcluded();\n    }\n\n    /**\n     * Returns the name of this column.\n     */\n    @Override\n    public String toString() {\n        return getName();\n    }\n\n    /**\n     * Two {@link TableColumn}s are considered equal if their tables and names match.\n     */\n    private class ColumnComparator implements Comparator<TableColumn> {\n\n        public int compare(TableColumn column1, TableColumn column2) {\n            int rc = column1.getTable().compareTo(column2.getTable());\n            if (rc == 0)\n                rc = column1.getName().compareToIgnoreCase(column2.getName());\n            return rc;\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if this column is permitted to be an implied FK\n     * (based on name/type/size matches to PKs).\n     *\n     * @return\n     */\n    public boolean allowsImpliedParents() {\n        return allowImpliedParents;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is permitted to be a PK to an implied FK\n     * (based on name/type/size matches to PKs).\n     *\n     * @return\n     */\n    public boolean allowsImpliedChildren() {\n        return allowImpliedChildren;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableColumnTest10.java",
		"test_prompt": "// TableColumnTest10.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TableColumn}.\n* It contains ten unit test cases for the {@link TableColumn#allowsImpliedParents()} method.\n*/\nclass TableColumnTest10 {"
	},
	{
		"original_code": "// TableColumn.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\n\npublic class TableColumn {\n\n    private final Table table;\n\n    private final String name;\n\n    private final Object id;\n\n    private String type;\n\n    private String shortType;\n\n    private final int length;\n\n    private final int decimalDigits;\n\n    private final String detailedSize;\n\n    private final boolean isNullable;\n\n    private boolean isAutoUpdated;\n\n    private Boolean isUnique;\n\n    private final Object defaultValue;\n\n    private String comments;\n\n    private final Map<TableColumn, ForeignKeyConstraint> parents = new HashMap<TableColumn, ForeignKeyConstraint>();\n\n    private final Map<TableColumn, ForeignKeyConstraint> children = new TreeMap<TableColumn, ForeignKeyConstraint>(new ColumnComparator());\n\n    private boolean allowImpliedParents = true;\n\n    private boolean allowImpliedChildren = true;\n\n    private boolean isExcluded = false;\n\n    private boolean isAllExcluded = false;\n\n    private static final Logger logger = Logger.getLogger(TableColumn.class.getName());\n\n    private static final boolean finerEnabled = logger.isLoggable(Level.FINER);\n\n    /**\n     * Create a column associated with a table.\n     *\n     * @param table Table the table that this column belongs to\n     * @param rs ResultSet returned from {@link DatabaseMetaData#getColumns(String, String, String, String)}\n     * @throws SQLException\n     */\n    TableColumn(Table table, ResultSet rs) throws SQLException {\n        this.table = table;\n        // names and types are typically reused *many* times in a database,\n        // so keep a single instance of each distinct one\n        // (thanks to Mike Barnes for the suggestion)\n        String tmp = rs.getString(\"COLUMN_NAME\");\n        name = tmp == null ? null : tmp.intern();\n        tmp = rs.getString(\"TYPE_NAME\");\n        type = tmp == null ? \"unknown\" : tmp.intern();\n        decimalDigits = rs.getInt(\"DECIMAL_DIGITS\");\n        Number bufLength = (Number) rs.getObject(\"BUFFER_LENGTH\");\n        if (bufLength != null && bufLength.shortValue() > 0)\n            length = bufLength.shortValue();\n        else\n            length = rs.getInt(\"COLUMN_SIZE\");\n        StringBuilder buf = new StringBuilder();\n        buf.append(length);\n        if (decimalDigits > 0) {\n            buf.append(',');\n            buf.append(decimalDigits);\n        }\n        detailedSize = buf.toString();\n        isNullable = rs.getInt(\"NULLABLE\") == DatabaseMetaData.columnNullable;\n        defaultValue = rs.getString(\"COLUMN_DEF\");\n        setComments(rs.getString(\"REMARKS\"));\n        id = new Integer(rs.getInt(\"ORDINAL_POSITION\") - 1);\n        Pattern excludeIndirectColumns = Config.getInstance().getIndirectColumnExclusions();\n        Pattern excludeColumns = Config.getInstance().getColumnExclusions();\n        isAllExcluded = matches(excludeColumns);\n        isExcluded = isAllExcluded || matches(excludeIndirectColumns);\n        if (isExcluded && finerEnabled) {\n            logger.finer(\"Excluding column \" + getTable() + '.' + getName() + \": matches \" + excludeColumns + \":\" + isAllExcluded + \" \" + excludeIndirectColumns + \":\" + matches(excludeIndirectColumns));\n        }\n    }\n\n    /**\n     * A TableColumn that's derived from something other than traditional database metadata\n     * (e.g. defined in XML).\n     *\n     * @param table\n     * @param colMeta\n     */\n    public TableColumn(Table table, TableColumnMeta colMeta) {\n        this.table = table;\n        name = colMeta.getName();\n        id = colMeta.getId();\n        type = colMeta.getType();\n        length = colMeta.getSize();\n        decimalDigits = colMeta.getDigits();\n        StringBuilder buf = new StringBuilder();\n        buf.append(length);\n        if (decimalDigits > 0) {\n            buf.append(',');\n            buf.append(decimalDigits);\n        }\n        detailedSize = buf.toString();\n        isNullable = colMeta.isNullable();\n        isAutoUpdated = colMeta.isAutoUpdated();\n        defaultValue = colMeta.getDefaultValue();\n        comments = colMeta.getComments();\n    }\n\n    /**\n     * Returns the {@link Table} that this column belongs to.\n     *\n     * @return\n     */\n    public Table getTable() {\n        return table;\n    }\n\n    /**\n     * Returns the column's name.\n     *\n     * @return\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the ID of the column or <code>null</code> if the database doesn't support the concept.\n     *\n     * @return\n     */\n    public Object getId() {\n        return id;\n    }\n\n    /**\n     * Type of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>TYPE_NAME</code>.\n     * @return\n     */\n    public String getType() {\n        return type;\n    }\n\n    /**\n     * Normally only used for \"special\" types such as enums.\n     *\n     * @param type\n     */\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    /**\n     * Abbreviated form of {@link #getType()}\n     *\n     * @return\n     */\n    public String getShortType() {\n        return shortType == null ? type : shortType;\n    }\n\n    /**\n     * Abbreviated form of {@link #setType(String)}\n     *\n     * @param shortType\n     */\n    public void setShortType(String shortType) {\n        this.shortType = shortType;\n    }\n\n    /**\n     * Length of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>BUFFER_LENGTH</code>,\n     * or if that's <code>null</code>, <code>COLUMN_SIZE</code>.\n     * @return\n     */\n    public int getLength() {\n        return length;\n    }\n\n    /**\n     * Decimal digits of the column.\n     * See {@link DatabaseMetaData#getColumns(String, String, String, String)}'s <code>DECIMAL_DIGITS</code>.\n     *\n     * @return\n     */\n    public int getDecimalDigits() {\n        return decimalDigits;\n    }\n\n    /**\n     * String representation of length with optional decimal digits (if decimal digits &gt; 0).\n     *\n     * @return\n     */\n    public String getDetailedSize() {\n        return detailedSize;\n    }\n\n    /**\n     * Returns <code>true</code> if null values are allowed\n     *\n     * @return\n     */\n    public boolean isNullable() {\n        return isNullable;\n    }\n\n    /**\n     * See {@link java.sql.ResultSetMetaData#isAutoIncrement(int)}\n     *\n     * @return\n     */\n    public boolean isAutoUpdated() {\n        return isAutoUpdated;\n    }\n\n    /**\n     * setIsAutoUpdated\n     *\n     * @param isAutoUpdated boolean\n     */\n    public void setIsAutoUpdated(boolean isAutoUpdated) {\n        this.isAutoUpdated = isAutoUpdated;\n    }\n\n    /**\n     * Returns <code>true</code> if this column can only contain unique values\n     *\n     * @return\n     */\n    public boolean isUnique() {\n        if (isUnique == null) {\n            // see if there's a unique index on this column by itself\n            for (TableIndex index : table.getIndexes()) {\n                if (index.isUnique()) {\n                    List<TableColumn> indexColumns = index.getColumns();\n                    if (indexColumns.size() == 1 && indexColumns.contains(this)) {\n                        isUnique = true;\n                        break;\n                    }\n                }\n            }\n            if (isUnique == null) {\n                // if it's a single PK column then it's unique\n                isUnique = table.getPrimaryColumns().size() == 1 && isPrimary();\n            }\n        }\n        return isUnique;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is a primary key\n     *\n     * @return\n     */\n    public boolean isPrimary() {\n        return table.getPrimaryColumns().contains(this);\n    }\n\n    /**\n     * Returns <code>true</code> if this column points to another table's primary key.\n     *\n     * @return\n     */\n    public boolean isForeignKey() {\n        return !parents.isEmpty();\n    }\n\n    /**\n     * Returns the value that the database uses for this column if one isn't provided.\n     *\n     * @return\n     */\n    public Object getDefaultValue() {\n        return defaultValue;\n    }\n\n    /**\n     * @return Comments associated with this column, or <code>null</code> if none.\n     */\n    public String getComments() {\n        return comments;\n    }\n\n    /**\n     * See {@link #getComments()}\n     * @param comments\n     */\n    public void setComments(String comments) {\n        this.comments = (comments == null || comments.trim().length() == 0) ? null : comments.trim();\n    }\n\n    /**\n     * Returns <code>true</code> if this column is to be excluded from relationship diagrams.\n     * Unless {@link #isAllExcluded()} is true this column will be included in the detailed\n     * diagrams of the containing table.\n     *\n     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables\n     * reference a given column.\n     *\n     * @return\n     */\n    public boolean isExcluded() {\n        return isExcluded;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is to be excluded from all relationships in\n     * relationship diagrams.  This includes the detailed diagrams of the containing table.\n     *\n     * <p>This is typically an attempt to reduce clutter that can be introduced when many tables\n     * reference a given column.\n     *\n     * @return\n     */\n    public boolean isAllExcluded() {\n        return isAllExcluded;\n    }\n\n    /**\n     * Add a parent column (PK) to this column (FK) via the associated constraint\n     *\n     * @param parent\n     * @param constraint\n     */\n    public void addParent(TableColumn parent, ForeignKeyConstraint constraint) {\n        parents.put(parent, constraint);\n        table.addedParent();\n    }\n\n    /**\n     * Remove the specified parent column from this column\n     *\n     * @param parent\n     */\n    public void removeParent(TableColumn parent) {\n        parents.remove(parent);\n    }\n\n    /**\n     * Disassociate all parents from this column\n     */\n    public void unlinkParents() {\n        for (TableColumn parent : parents.keySet()) {\n            parent.removeChild(this);\n        }\n        parents.clear();\n    }\n\n    /**\n     * Returns the {@link Set} of all {@link TableColumn parents} associated with this column\n     *\n     * @return\n     */\n    public Set<TableColumn> getParents() {\n        return parents.keySet();\n    }\n\n    /**\n     * Returns the constraint that connects this column to the specified column (this 'child' column to specified 'parent' column)\n     */\n    public ForeignKeyConstraint getParentConstraint(TableColumn parent) {\n        return parents.get(parent);\n    }\n\n    /**\n     * Removes a parent constraint and returns it, or null if there are no parent constraints\n     *\n     * @return the removed {@link ForeignKeyConstraint}\n     */\n    public ForeignKeyConstraint removeAParentFKConstraint() {\n        for (TableColumn relatedColumn : parents.keySet()) {\n            ForeignKeyConstraint constraint = parents.remove(relatedColumn);\n            relatedColumn.removeChild(this);\n            return constraint;\n        }\n        return null;\n    }\n\n    /**\n     * Remove one child {@link ForeignKeyConstraint} that points to this column.\n     *\n     * @return the removed constraint, or <code>null</code> if none were available to be removed\n     */\n    public ForeignKeyConstraint removeAChildFKConstraint() {\n        for (TableColumn relatedColumn : children.keySet()) {\n            ForeignKeyConstraint constraint = children.remove(relatedColumn);\n            relatedColumn.removeParent(this);\n            return constraint;\n        }\n        return null;\n    }\n\n    /**\n     * Add a child column (FK) to this column (PK) via the associated constraint\n     *\n     * @param child\n     * @param constraint\n     */\n    public void addChild(TableColumn child, ForeignKeyConstraint constraint) {\n        children.put(child, constraint);\n        table.addedChild();\n    }\n\n    /**\n     * Remove the specified child column from this column\n     *\n     * @param child\n     */\n    public void removeChild(TableColumn child) {\n        children.remove(child);\n    }\n\n    /**\n     * Disassociate all children from this column\n     */\n    public void unlinkChildren() {\n        for (TableColumn child : children.keySet()) child.removeParent(this);\n        children.clear();\n    }\n\n    /**\n     * Returns <code>Set</code> of <code>TableColumn</code>s that have a real (or implied) foreign key that\n     * references this <code>TableColumn</code>.\n     * @return Set\n     */\n    public Set<TableColumn> getChildren() {\n        return children.keySet();\n    }\n\n    /**\n     * returns the constraint that connects the specified column to this column\n     * (specified 'child' to this 'parent' column)\n     */\n    public ForeignKeyConstraint getChildConstraint(TableColumn child) {\n        return children.get(child);\n    }\n\n    /**\n     * Returns <code>true</code> if tableName.columnName matches the supplied\n     * regular expression.\n     *\n     * @param regex\n     * @return\n     */\n    public boolean matches(Pattern regex) {\n        return regex.matcher(getTable().getName() + '.' + getName()).matches();\n    }\n\n    /**\n     * Update the state of this column with the supplied {@link TableColumnMeta}.\n     * Intended to be used with instances created by {@link #TableColumn(Table, TableColumnMeta)}.\n     *\n     * @param colMeta\n     */\n    public void update(TableColumnMeta colMeta) {\n        String newComments = colMeta.getComments();\n        if (newComments != null)\n            setComments(newComments);\n        if (!isPrimary() && colMeta.isPrimary()) {\n            table.setPrimaryColumn(this);\n        }\n        allowImpliedParents = !colMeta.isImpliedParentsDisabled();\n        allowImpliedChildren = !colMeta.isImpliedChildrenDisabled();\n        isExcluded |= colMeta.isExcluded();\n        isAllExcluded |= colMeta.isAllExcluded();\n    }\n\n    /**\n     * Returns the name of this column.\n     */\n    @Override\n    public String toString() {\n        return getName();\n    }\n\n    /**\n     * Two {@link TableColumn}s are considered equal if their tables and names match.\n     */\n    private class ColumnComparator implements Comparator<TableColumn> {\n\n        public int compare(TableColumn column1, TableColumn column2) {\n            int rc = column1.getTable().compareTo(column2.getTable());\n            if (rc == 0)\n                rc = column1.getName().compareToIgnoreCase(column2.getName());\n            return rc;\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if this column is permitted to be an implied FK\n     * (based on name/type/size matches to PKs).\n     *\n     * @return\n     */\n    public boolean allowsImpliedParents() {\n        return allowImpliedParents;\n    }\n\n    /**\n     * Returns <code>true</code> if this column is permitted to be a PK to an implied FK\n     * (based on name/type/size matches to PKs).\n     *\n     * @return\n     */\n    public boolean allowsImpliedChildren() {\n        return allowImpliedChildren;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableColumnTest11.java",
		"test_prompt": "// TableColumnTest11.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TableColumn}.\n* It contains ten unit test cases for the {@link TableColumn#allowsImpliedChildren()} method.\n*/\nclass TableColumnTest11 {"
	},
	{
		"original_code": "// RemoteTable.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy.model;\r\n\r\nimport java.sql.ResultSet;\r\nimport java.sql.SQLException;\r\nimport java.util.Map;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport net.sourceforge.schemaspy.Config;\r\n\r\n/**\r\n * A table that's outside of the default schema but is referenced\r\n * by or references a table in the default schema.\r\n *\r\n * @author John Currier\r\n */\r\npublic class RemoteTable extends Table {\r\n\r\n    private final String baseContainer;\r\n\r\n    private final static Logger logger = Logger.getLogger(RemoteTable.class.getName());\r\n\r\n    private final static boolean finerEnabled = logger.isLoggable(Level.FINER);\r\n\r\n    /**\r\n     * @param db\r\n     * @param catalog\r\n     * @param schema\r\n     * @param name\r\n     * @param baseContainer\r\n     * @throws SQLException\r\n     */\r\n    public RemoteTable(Database db, String catalog, String schema, String name, String baseContainer) throws SQLException {\r\n        super(db, catalog, schema, name, null);\r\n        this.baseContainer = baseContainer;\r\n    }\r\n\r\n    /**\r\n     * Connect to the PK's referenced by this table that live in the original schema\r\n     * @param tables\r\n     * @param excludeIndirectColumns\r\n     * @param excludeColumns\r\n     * @throws SQLException\r\n     */\r\n    @Override\r\n    public void connectForeignKeys(Map<String, Table> tables) throws SQLException {\r\n        if (finerEnabled)\r\n            logger.finer(\"Connecting foreign keys to \" + getFullName());\r\n        ResultSet rs = null;\r\n        try {\r\n            // get remote table's FKs that reference PKs in our schema\r\n            rs = db.getMetaData().getImportedKeys(getCatalog(), getSchema(), getName());\r\n            while (rs.next()) {\r\n                String otherSchema = rs.getString(\"PKTABLE_SCHEM\");\r\n                String otherCatalog = rs.getString(\"PKTABLE_CAT\");\r\n                // if it points back to our schema then use it\r\n                if (baseContainer.equals(otherSchema) || baseContainer.equals(otherCatalog)) {\r\n                    addForeignKey(rs.getString(\"FK_NAME\"), rs.getString(\"FKCOLUMN_NAME\"), otherCatalog, otherSchema, rs.getString(\"PKTABLE_NAME\"), rs.getString(\"PKCOLUMN_NAME\"), rs.getInt(\"UPDATE_RULE\"), rs.getInt(\"DELETE_RULE\"), tables);\r\n                }\r\n            }\r\n        } catch (SQLException sqlExc) {\r\n            if (!isLogical()) {\r\n                // if explicitly asking for these details then propagate the exception\r\n                if (Config.getInstance().isOneOfMultipleSchemas())\r\n                    throw sqlExc;\r\n                // otherwise just report the fact that we tried & couldn't\r\n                System.err.println(\"Couldn't resolve foreign keys for remote table \" + getFullName() + \": \" + sqlExc);\r\n            }\r\n        } finally {\r\n            if (rs != null)\r\n                rs.close();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public boolean isRemote() {\r\n        return true;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/RemoteTableTest.java",
		"test_prompt": "// RemoteTableTest.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Map;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport net.sourceforge.schemaspy.Config;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RemoteTable}.\n* It contains ten unit test cases for the {@link RemoteTable#isRemote()} method.\n*/\nclass RemoteTableTest {"
	},
	{
		"original_code": "// Table.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\nimport net.sourceforge.schemaspy.model.xml.TableMeta;\nimport net.sourceforge.schemaspy.util.CaseInsensitiveMap;\n\n/**\n * A <code>Table</code> is one of the basic building blocks of SchemaSpy\n * that knows everything about the database table's metadata.\n *\n * @author John Currier\n */\npublic class Table implements Comparable<Table> {\n\n    private final String catalog;\n\n    private final String schema;\n\n    private final String name;\n\n    private final String fullName;\n\n    private final String container;\n\n    protected final CaseInsensitiveMap<TableColumn> columns = new CaseInsensitiveMap<TableColumn>();\n\n    private final List<TableColumn> primaryKeys = new ArrayList<TableColumn>();\n\n    private final CaseInsensitiveMap<ForeignKeyConstraint> foreignKeys = new CaseInsensitiveMap<ForeignKeyConstraint>();\n\n    private final CaseInsensitiveMap<TableIndex> indexes = new CaseInsensitiveMap<TableIndex>();\n\n    private Object id;\n\n    private final Map<String, String> checkConstraints = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);\n\n    private Long numRows;\n\n    protected final Database db;\n\n    private String comments;\n\n    private int maxChildren;\n\n    private int maxParents;\n\n    private final static Logger logger = Logger.getLogger(Table.class.getName());\n\n    private final static boolean fineEnabled = logger.isLoggable(Level.FINE);\n\n    private final static boolean finerEnabled = logger.isLoggable(Level.FINER);\n\n    /**\n     * Construct a table that knows everything about the database table's metadata\n     *\n     * @param db\n     * @param catalog\n     * @param schema\n     * @param name\n     * @param comments\n     * @throws SQLException\n     */\n    public Table(Database db, String catalog, String schema, String name, String comments) throws SQLException {\n        this.db = db;\n        this.catalog = catalog;\n        this.schema = schema;\n        this.container = schema != null ? schema : catalog != null ? catalog : db.getName();\n        this.name = name;\n        this.fullName = getFullName(db.getName(), catalog, schema, name);\n        if (fineEnabled)\n            logger.fine(\"Creating \" + getClass().getSimpleName() + \" \" + fullName);\n        setComments(comments);\n        initColumns();\n        initIndexes();\n        initPrimaryKeys();\n    }\n\n    /**\n     * \"Connect\" all of this table's foreign keys to their referenced primary keys\n     * (and, in some cases, do the reverse as well).\n     *\n     * @param tables\n     * @throws SQLException\n     */\n    public void connectForeignKeys(Map<String, Table> tables) throws SQLException {\n        if (finerEnabled)\n            logger.finer(\"Connecting foreign keys to \" + getFullName());\n        ResultSet rs = null;\n        try {\n            // get our foreign keys that reference other tables' primary keys\n            rs = db.getMetaData().getImportedKeys(getCatalog(), getSchema(), getName());\n            while (rs.next()) {\n                addForeignKey(rs.getString(\"FK_NAME\"), rs.getString(\"FKCOLUMN_NAME\"), rs.getString(\"PKTABLE_CAT\"), rs.getString(\"PKTABLE_SCHEM\"), rs.getString(\"PKTABLE_NAME\"), rs.getString(\"PKCOLUMN_NAME\"), rs.getInt(\"UPDATE_RULE\"), rs.getInt(\"DELETE_RULE\"), tables);\n            }\n        } finally {\n            if (rs != null)\n                rs.close();\n        }\n        // also try to find all of the 'remote' tables in other schemas that\n        // point to our primary keys (not necessary in the normal case\n        // as we infer this from the opposite direction)\n        if (getSchema() != null || getCatalog() != null) {\n            try {\n                // get the foreign keys that reference our primary keys\n                rs = db.getMetaData().getExportedKeys(getCatalog(), getSchema(), getName());\n                while (rs.next()) {\n                    String otherCatalog = rs.getString(\"FKTABLE_CAT\");\n                    String otherSchema = rs.getString(\"FKTABLE_SCHEM\");\n                    if (!String.valueOf(getSchema()).equals(String.valueOf(otherSchema)) || !String.valueOf(getCatalog()).equals(String.valueOf(otherCatalog))) {\n                        db.addRemoteTable(otherCatalog, otherSchema, rs.getString(\"FKTABLE_NAME\"), getSchema(), false);\n                    }\n                }\n            } finally {\n                if (rs != null)\n                    rs.close();\n            }\n        }\n    }\n\n    /**\n     * Get the foreign keys associated with this table\n     *\n     * @return\n     */\n    public Collection<ForeignKeyConstraint> getForeignKeys() {\n        return Collections.unmodifiableCollection(foreignKeys.values());\n    }\n\n    /**\n     * Add a check constraint to the table\n     * (no real details, just name and textual representation)\n     *\n     * @param constraintName\n     * @param text\n     */\n    public void addCheckConstraint(String constraintName, String text) {\n        checkConstraints.put(constraintName, text);\n    }\n\n    /**\n     * @param rs ResultSet from {@link DatabaseMetaData#getImportedKeys(String, String, String)}\n     * rs.getString(\"FK_NAME\");\n     * rs.getString(\"FKCOLUMN_NAME\");\n     * rs.getString(\"PKTABLE_CAT\");\n     * rs.getString(\"PKTABLE_SCHEM\");\n     * rs.getString(\"PKTABLE_NAME\");\n     * rs.getString(\"PKCOLUMN_NAME\");\n     * @param tables Map\n     * @param db\n     * @throws SQLException\n     */\n    protected void addForeignKey(String fkName, String fkColName, String pkCatalog, String pkSchema, String pkTableName, String pkColName, int updateRule, int deleteRule, Map<String, Table> tables) throws SQLException {\n        if (fkName == null)\n            return;\n        Pattern include = Config.getInstance().getTableInclusions();\n        Pattern exclude = Config.getInstance().getTableExclusions();\n        if (!include.matcher(pkTableName).matches() || exclude.matcher(pkTableName).matches()) {\n            if (fineEnabled)\n                logger.fine(\"Ignoring \" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName) + \" referenced by FK \" + fkName);\n            return;\n        }\n        ForeignKeyConstraint foreignKey = foreignKeys.get(fkName);\n        if (foreignKey == null) {\n            foreignKey = new ForeignKeyConstraint(this, fkName, updateRule, deleteRule);\n            foreignKeys.put(fkName, foreignKey);\n        }\n        TableColumn childColumn = getColumn(fkColName);\n        if (childColumn != null) {\n            foreignKey.addChildColumn(childColumn);\n            Config config = Config.getInstance();\n            Table parentTable = tables.get(pkTableName);\n            String parentContainer = pkSchema != null ? pkSchema : pkCatalog != null ? pkCatalog : db.getName();\n            String baseContainer = config.getSchema() != null ? config.getSchema() : config.getCatalog() != null ? config.getCatalog() : db.getName();\n            // if named table doesn't exist in this schema\n            // or exists here but really referencing same named table in another schema\n            if (parentTable == null || !baseContainer.equals(parentContainer)) {\n                if (fineEnabled)\n                    logger.fine(\"Adding remote table \" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName));\n                parentTable = db.addRemoteTable(pkCatalog, pkSchema, pkTableName, baseContainer, false);\n            }\n            if (parentTable != null) {\n                TableColumn parentColumn = parentTable.getColumn(pkColName);\n                if (parentColumn != null) {\n                    foreignKey.addParentColumn(parentColumn);\n                    childColumn.addParent(parentColumn, foreignKey);\n                    parentColumn.addChild(childColumn, foreignKey);\n                } else {\n                    logger.warning(\"Couldn't add FK '\" + foreignKey.getName() + \"' to table '\" + this + \"' - Column '\" + pkColName + \"' doesn't exist in table '\" + parentTable + \"'\");\n                }\n            } else {\n                logger.warning(\"Couldn't add FK '\" + foreignKey.getName() + \"' to table '\" + this + \"' - Unknown Referenced Table '\" + pkTableName + \"'\");\n            }\n        } else {\n            logger.warning(\"Couldn't add FK '\" + foreignKey.getName() + \"' to table '\" + this + \"' - Column '\" + fkColName + \"' doesn't exist\");\n        }\n    }\n\n    /**\n     * @param meta\n     * @throws SQLException\n     */\n    private void initPrimaryKeys() throws SQLException {\n        ResultSet rs = null;\n        try {\n            if (fineEnabled)\n                logger.fine(\"Querying primary keys for \" + getFullName());\n            rs = db.getMetaData().getPrimaryKeys(getCatalog(), getSchema(), getName());\n            while (rs.next()) setPrimaryColumn(rs);\n        } catch (SQLException exc) {\n            if (!isLogical()) {\n                throw exc;\n            }\n        } finally {\n            if (rs != null)\n                rs.close();\n        }\n    }\n\n    /**\n     * @param rs\n     * @throws SQLException\n     */\n    private void setPrimaryColumn(ResultSet rs) throws SQLException {\n        String pkName = rs.getString(\"PK_NAME\");\n        if (pkName == null)\n            return;\n        TableIndex index = getIndex(pkName);\n        if (index != null) {\n            index.setIsPrimaryKey(true);\n        }\n        String columnName = rs.getString(\"COLUMN_NAME\");\n        setPrimaryColumn(getColumn(columnName));\n    }\n\n    /**\n     * @param primaryColumn\n     */\n    void setPrimaryColumn(TableColumn primaryColumn) {\n        primaryKeys.add(primaryColumn);\n    }\n\n    /**\n     * @throws SQLException\n     */\n    private void initColumns() throws SQLException {\n        ResultSet rs = null;\n        synchronized (Table.class) {\n            try {\n                rs = db.getMetaData().getColumns(getCatalog(), getSchema(), getName(), \"%\");\n                while (rs.next()) addColumn(rs);\n            } catch (SQLException exc) {\n                if (!isLogical()) {\n                    class ColumnInitializationFailure extends SQLException {\n\n                        private static final long serialVersionUID = 1L;\n\n                        public ColumnInitializationFailure(SQLException failure) {\n                            super(\"Failed to collect column details for \" + (isView() ? \"view\" : \"table\") + \" '\" + getName() + \"' in schema '\" + getContainer() + \"'\");\n                            initCause(failure);\n                        }\n                    }\n                    throw new ColumnInitializationFailure(exc);\n                }\n            } finally {\n                if (rs != null)\n                    rs.close();\n            }\n        }\n        initColumnAutoUpdate(false);\n    }\n\n    /**\n     * @param forceQuotes\n     * @throws SQLException\n     */\n    private void initColumnAutoUpdate(boolean forceQuotes) throws SQLException {\n        ResultSet rs = null;\n        PreparedStatement stmt = null;\n        if (isView() || isRemote())\n            return;\n        // we've got to get a result set with all the columns in it\n        // so we can ask if the columns are auto updated\n        // Ugh!!!  Should have been in DatabaseMetaData instead!!!\n        StringBuilder sql = new StringBuilder(\"select * from \");\n        if (getSchema() != null) {\n            sql.append(getSchema());\n            sql.append('.');\n        } else if (getCatalog() != null) {\n            sql.append(getCatalog());\n            sql.append('.');\n        }\n        if (forceQuotes) {\n            String quote = db.getMetaData().getIdentifierQuoteString().trim();\n            sql.append(quote + getName() + quote);\n        } else\n            sql.append(db.getQuotedIdentifier(getName()));\n        sql.append(\" where 0 = 1\");\n        try {\n            stmt = db.getMetaData().getConnection().prepareStatement(sql.toString());\n            rs = stmt.executeQuery();\n            ResultSetMetaData rsMeta = rs.getMetaData();\n            for (int i = rsMeta.getColumnCount(); i > 0; --i) {\n                TableColumn column = getColumn(rsMeta.getColumnName(i));\n                column.setIsAutoUpdated(rsMeta.isAutoIncrement(i));\n            }\n        } catch (SQLException exc) {\n            if (forceQuotes) {\n                if (!isLogical()) {\n                    // don't completely choke just because we couldn't do this....\n                    logger.warning(\"Failed to determine auto increment status: \" + exc);\n                    logger.warning(\"SQL: \" + sql.toString());\n                }\n            } else {\n                initColumnAutoUpdate(true);\n            }\n        } finally {\n            if (rs != null)\n                rs.close();\n            if (stmt != null)\n                stmt.close();\n        }\n    }\n\n    /**\n     * @param rs - from {@link DatabaseMetaData#getColumns(String, String, String, String)}\n     * @throws SQLException\n     */\n    protected void addColumn(ResultSet rs) throws SQLException {\n        String columnName = rs.getString(\"COLUMN_NAME\");\n        if (columnName == null)\n            return;\n        if (getColumn(columnName) == null) {\n            TableColumn column = new TableColumn(this, rs);\n            columns.put(column.getName(), column);\n        }\n    }\n\n    /**\n     * Add a column that's defined in xml metadata.\n     * Assumes that a column named colMeta.getName() doesn't already exist in <code>columns</code>.\n     * @param colMeta\n     * @return\n     */\n    protected TableColumn addColumn(TableColumnMeta colMeta) {\n        TableColumn column = new TableColumn(this, colMeta);\n        columns.put(column.getName(), column);\n        return column;\n    }\n\n    /**\n     * Initialize index information\n     *\n     * @throws SQLException\n     */\n    private void initIndexes() throws SQLException {\n        if (isView() || isRemote())\n            return;\n        // first try to initialize using the index query spec'd in the .properties\n        // do this first because some DB's (e.g. Oracle) do 'bad' things with getIndexInfo()\n        // (they try to do a DDL analyze command that has some bad side-effects)\n        if (initIndexes(Config.getInstance().getDbProperties().getProperty(\"selectIndexesSql\")))\n            return;\n        // couldn't, so try the old fashioned approach\n        ResultSet rs = null;\n        try {\n            rs = db.getMetaData().getIndexInfo(getCatalog(), getSchema(), getName(), false, true);\n            while (rs.next()) {\n                if (rs.getShort(\"TYPE\") != DatabaseMetaData.tableIndexStatistic)\n                    addIndex(rs);\n            }\n        } catch (SQLException exc) {\n            if (!isLogical())\n                logger.warning(\"Unable to extract index info for table '\" + getName() + \"' in schema '\" + getContainer() + \"': \" + exc);\n        } finally {\n            if (rs != null)\n                rs.close();\n        }\n    }\n\n    /**\n     * Try to initialize index information based on the specified SQL\n     *\n     * @return boolean <code>true</code> if it worked, otherwise <code>false</code>\n     */\n    private boolean initIndexes(String selectIndexesSql) {\n        if (selectIndexesSql == null)\n            return false;\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = db.prepareStatement(selectIndexesSql, getName());\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                if (rs.getShort(\"TYPE\") != DatabaseMetaData.tableIndexStatistic)\n                    addIndex(rs);\n            }\n        } catch (SQLException sqlException) {\n            logger.warning(\"Failed to query index information with SQL: \" + selectIndexesSql);\n            logger.warning(sqlException.toString());\n            return false;\n        } finally {\n            if (rs != null) {\n                try {\n                    rs.close();\n                } catch (Exception exc) {\n                    exc.printStackTrace();\n                }\n            }\n            if (stmt != null) {\n                try {\n                    stmt.close();\n                } catch (Exception exc) {\n                    exc.printStackTrace();\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @param indexName\n     * @return\n     */\n    public TableIndex getIndex(String indexName) {\n        return indexes.get(indexName);\n    }\n\n    /**\n     * @param rs\n     * @throws SQLException\n     */\n    private void addIndex(ResultSet rs) throws SQLException {\n        String indexName = rs.getString(\"INDEX_NAME\");\n        if (indexName == null)\n            return;\n        TableIndex index = getIndex(indexName);\n        if (index == null) {\n            index = new TableIndex(rs);\n            indexes.put(index.getName(), index);\n        }\n        index.addColumn(getColumn(rs.getString(\"COLUMN_NAME\")), rs.getString(\"ASC_OR_DESC\"));\n    }\n\n    /**\n     * Returns the catalog that the table belongs to\n     *\n     * @return\n     */\n    public String getCatalog() {\n        return catalog;\n    }\n\n    /**\n     * Returns the schema that the table belongs to\n     *\n     * @return\n     */\n    public String getSchema() {\n        return schema;\n    }\n\n    /**\n     * Returns the logical 'container' that the table\n     * lives in.  Basically it's the first non-<code>null</code>\n     * item out of <code>schema</code>, <code>catalog</code>\n     * and <code>database</code>.\n     *\n     * @return\n     */\n    public String getContainer() {\n        return container;\n    }\n\n    /**\n     * Returns the name of the table\n     *\n     * @return\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the fully-qualified name of this table\n     *\n     * @return\n     */\n    public String getFullName() {\n        return fullName;\n    }\n\n    /**\n     * Returns the fully-qualified name of a table\n     *\n     * @return\n     */\n    public static String getFullName(String db, String catalog, String schema, String table) {\n        String fullName = (catalog == null && schema == null ? db + '.' : \"\") + (catalog == null ? \"\" : catalog + '.') + (schema == null ? \"\" : schema + '.') + table;\n        return fullName;\n    }\n\n    /**\n     * Object IDs are useful for tables such as DB/2 that many times\n     * give error messages based on object ID and not name\n     *\n     * @param id\n     */\n    public void setId(Object id) {\n        this.id = id;\n    }\n\n    /**\n     * @see #setId(Object)\n     *\n     * @return\n     */\n    public Object getId() {\n        return id;\n    }\n\n    /**\n     * Returns the check constraints associated with this table\n     *\n     * @return\n     */\n    public Map<String, String> getCheckConstraints() {\n        return checkConstraints;\n    }\n\n    /**\n     * Returns the indexes that are applied to this table\n     *\n     * @return\n     */\n    public Set<TableIndex> getIndexes() {\n        return new HashSet<TableIndex>(indexes.values());\n    }\n\n    /**\n     * Returns a collection of table columns that have been identified as \"primary\"\n     *\n     * @return\n     */\n    public List<TableColumn> getPrimaryColumns() {\n        return primaryKeys;\n    }\n\n    /**\n     * @return Comments associated with this table, or <code>null</code> if none.\n     */\n    public String getComments() {\n        return comments;\n    }\n\n    /**\n     * Sets the comments that are associated with this table\n     *\n     * @param comments\n     */\n    public void setComments(String comments) {\n        String cmts = (comments == null || comments.trim().length() == 0) ? null : comments.trim();\n        // MySQL's InnoDB engine does some insane crap of storing erroneous details in\n        // with table comments.  Here I attempt to strip the \"crap\" out without impacting\n        // other databases.  Ideally this should happen in selectColumnCommentsSql (and\n        // therefore isolate it to MySQL), but it's a bit too complex to do cleanly.\n        if (cmts != null) {\n            int crapIndex = cmts.indexOf(\"; InnoDB free: \");\n            if (crapIndex == -1)\n                crapIndex = cmts.startsWith(\"InnoDB free: \") ? 0 : -1;\n            if (crapIndex != -1) {\n                cmts = cmts.substring(0, crapIndex).trim();\n                cmts = cmts.length() == 0 ? null : cmts;\n            }\n        }\n        this.comments = cmts;\n    }\n\n    /**\n     * Returns the {@link TableColumn} with the given name, or <code>null</code>\n     * if it doesn't exist\n     *\n     * @param columnName\n     * @return\n     */\n    public TableColumn getColumn(String columnName) {\n        return columns.get(columnName);\n    }\n\n    /**\n     * Returns <code>List</code> of <code>TableColumn</code>s in ascending column number order.\n     *\n     * @return\n     */\n    public List<TableColumn> getColumns() {\n        Set<TableColumn> sorted = new TreeSet<TableColumn>(new ByColumnIdComparator());\n        sorted.addAll(columns.values());\n        return new ArrayList<TableColumn>(sorted);\n    }\n\n    /**\n     * Returns <code>true</code> if this table references no other tables..<p/>\n     * Used in dependency analysis.\n     * @return\n     */\n    public boolean isRoot() {\n        for (TableColumn column : columns.values()) {\n            if (column.isForeignKey()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns <code>true</code> if this table is referenced by no other tables.<p/>\n     * Used in dependency analysis.\n     * @return\n     */\n    public boolean isLeaf() {\n        for (TableColumn column : columns.values()) {\n            if (!column.getChildren().isEmpty()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the maximum number of parents that this table has had before\n     * any had been removed during dependency analysis\n     *\n     * @return\n     */\n    public int getMaxParents() {\n        return maxParents;\n    }\n\n    /**\n     * Notification that's called to indicate that a parent has been added to\n     * this table\n     */\n    public void addedParent() {\n        maxParents++;\n    }\n\n    /**\n     * \"Unlink\" all of the parent tables from this table\n     */\n    public void unlinkParents() {\n        for (TableColumn column : columns.values()) {\n            column.unlinkParents();\n        }\n    }\n\n    /**\n     * Returns the maximum number of children that this table has had before\n     * any had been removed during dependency analysis\n     *\n     * @return\n     */\n    public int getMaxChildren() {\n        return maxChildren;\n    }\n\n    /**\n     * Notification that's called to indicate that a child has been added to\n     * this table\n     */\n    public void addedChild() {\n        maxChildren++;\n    }\n\n    /**\n     * \"Unlink\" all of the child tables from this table\n     */\n    public void unlinkChildren() {\n        for (TableColumn column : columns.values()) {\n            column.unlinkChildren();\n        }\n    }\n\n    /**\n     * Remove a single self referencing constraint if one exists.\n     *\n     * @return\n     */\n    public ForeignKeyConstraint removeSelfReferencingConstraint() {\n        return remove(getSelfReferencingConstraint());\n    }\n\n    /**\n     * Remove the specified {@link ForeignKeyConstraint} from this table.<p>\n     *\n     * This is a more drastic removal solution that was proposed by Remke Rutgers\n     *\n     * @param constraint\n     */\n    private ForeignKeyConstraint remove(ForeignKeyConstraint constraint) {\n        if (constraint != null) {\n            for (int i = 0; i < constraint.getChildColumns().size(); i++) {\n                TableColumn childColumn = constraint.getChildColumns().get(i);\n                TableColumn parentColumn = constraint.getParentColumns().get(i);\n                childColumn.removeParent(parentColumn);\n                parentColumn.removeChild(childColumn);\n            }\n        }\n        return constraint;\n    }\n\n    /**\n     * Return a self referencing constraint if one exists\n     *\n     * @return\n     */\n    private ForeignKeyConstraint getSelfReferencingConstraint() {\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                if (compareTo(parentColumn.getTable()) == 0) {\n                    return column.getParentConstraint(parentColumn);\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Remove any non-real foreign keys\n     *\n     * @return\n     */\n    public List<ForeignKeyConstraint> removeNonRealForeignKeys() {\n        List<ForeignKeyConstraint> nonReals = new ArrayList<ForeignKeyConstraint>();\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                ForeignKeyConstraint constraint = column.getParentConstraint(parentColumn);\n                if (constraint != null && !constraint.isReal()) {\n                    nonReals.add(constraint);\n                }\n            }\n        }\n        // remove constraints outside of above loop to prevent\n        // concurrent modification exceptions while iterating\n        for (ForeignKeyConstraint constraint : nonReals) {\n            remove(constraint);\n        }\n        return nonReals;\n    }\n\n    /**\n     * Returns the number of tables that reference this table\n     *\n     * @return\n     */\n    public int getNumChildren() {\n        int numChildren = 0;\n        for (TableColumn column : columns.values()) {\n            numChildren += column.getChildren().size();\n        }\n        return numChildren;\n    }\n\n    /**\n     * Returns the number of non-implied children\n     * @return\n     */\n    public int getNumNonImpliedChildren() {\n        int numChildren = 0;\n        for (TableColumn column : columns.values()) {\n            for (TableColumn childColumn : column.getChildren()) {\n                if (!column.getChildConstraint(childColumn).isImplied())\n                    ++numChildren;\n            }\n        }\n        return numChildren;\n    }\n\n    /**\n     * Returns the number of tables that are referenced by this table\n     *\n     * @return\n     */\n    public int getNumParents() {\n        int numParents = 0;\n        for (TableColumn column : columns.values()) {\n            numParents += column.getParents().size();\n        }\n        return numParents;\n    }\n\n    /**\n     * Returns the number of non-implied parents\n     *\n     * @return\n     */\n    public int getNumNonImpliedParents() {\n        int numParents = 0;\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                if (!column.getParentConstraint(parentColumn).isImplied())\n                    ++numParents;\n            }\n        }\n        return numParents;\n    }\n\n    /**\n     * Remove one foreign key constraint.\n     *\n     * <p/>Used during dependency analysis phase.\n     *\n     * @return\n     */\n    public ForeignKeyConstraint removeAForeignKeyConstraint() {\n        @SuppressWarnings(\"hiding\")\n        final List<TableColumn> columns = getColumns();\n        int numParents = 0;\n        int numChildren = 0;\n        // remove either a child or parent, choosing which based on which has the\n        // least number of foreign key associations (when either gets to zero then\n        // the table can be pruned)\n        for (TableColumn column : columns) {\n            numParents += column.getParents().size();\n            numChildren += column.getChildren().size();\n        }\n        for (TableColumn column : columns) {\n            ForeignKeyConstraint constraint;\n            if (numParents <= numChildren)\n                constraint = column.removeAParentFKConstraint();\n            else\n                constraint = column.removeAChildFKConstraint();\n            if (constraint != null)\n                return constraint;\n        }\n        return null;\n    }\n\n    /**\n     * Returns <code>true</code> if this table is logical (not physical), <code>false</code> otherwise\n     * @return\n     */\n    public boolean isLogical() {\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if this is a view, <code>false</code> otherwise\n     *\n     * @return\n     */\n    public boolean isView() {\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if this table is remote (in another schema), <code>false</code> otherwise\n     * @return\n     */\n    public boolean isRemote() {\n        return false;\n    }\n\n    /**\n     * If this is a view it returns the SQL used to create the view (if it's available).\n     * <code>null</code> if it's not a view or the SQL isn't available.\n     * @return\n     * @see #isView()\n     */\n    public String getViewSql() {\n        return null;\n    }\n\n    /**\n     * Returns the number of rows contained in this table, or -1 if unable to determine\n     * the number of rows.\n     *\n     * @return\n     */\n    public long getNumRows() {\n        if (numRows == null) {\n            numRows = Config.getInstance().isNumRowsEnabled() ? fetchNumRows() : -1;\n        }\n        return numRows;\n    }\n\n    /**\n     * Explicitly set the number of rows in this table\n     *\n     * @param numRows\n     */\n    public void setNumRows(long numRows) {\n        this.numRows = numRows;\n    }\n\n    /**\n     * Fetch the number of rows contained in this table.\n     *\n     * returns -1 if unable to successfully fetch the row count\n     *\n     * @param db Database\n     * @return int\n     * @throws SQLException\n     */\n    protected long fetchNumRows() {\n        if (isView() || isRemote())\n            return -1;\n        SQLException originalFailure = null;\n        String sql = Config.getInstance().getDbProperties().getProperty(\"selectRowCountSql\");\n        if (sql != null) {\n            PreparedStatement stmt = null;\n            ResultSet rs = null;\n            try {\n                stmt = db.prepareStatement(sql, getName());\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    return rs.getLong(\"row_count\");\n                }\n            } catch (SQLException sqlException) {\n                // don't die just because this failed\n                originalFailure = sqlException;\n            } finally {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    } catch (SQLException exc) {\n                    }\n                }\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException exc) {\n                    }\n                }\n            }\n        }\n        // if we get here then we either didn't have custom SQL or it didn't work\n        try {\n            // '*' should work best for the majority of cases\n            return fetchNumRows(\"count(*)\", false);\n        } catch (SQLException try2Exception) {\n            try {\n                // except nested tables...try using '1' instead\n                return fetchNumRows(\"count(1)\", false);\n            } catch (SQLException try3Exception) {\n                if (!isLogical()) {\n                    logger.warning(\"Unable to extract the number of rows for table \" + getName() + \", using '-1'\");\n                    if (originalFailure != null)\n                        logger.warning(originalFailure.toString());\n                    logger.warning(try2Exception.toString());\n                    if (!String.valueOf(try2Exception.toString()).equals(try3Exception.toString()))\n                        logger.warning(try3Exception.toString());\n                }\n                return -1;\n            }\n        }\n    }\n\n    protected long fetchNumRows(String clause, boolean forceQuotes) throws SQLException {\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        StringBuilder sql = new StringBuilder(\"select \");\n        sql.append(clause);\n        sql.append(\" from \");\n        if (getSchema() != null) {\n            sql.append(getSchema());\n            sql.append('.');\n        } else if (getCatalog() != null) {\n            sql.append(getCatalog());\n            sql.append('.');\n        }\n        if (forceQuotes) {\n            String quote = db.getMetaData().getIdentifierQuoteString().trim();\n            sql.append(quote + getName() + quote);\n        } else\n            sql.append(db.getQuotedIdentifier(getName()));\n        try {\n            if (finerEnabled)\n                logger.finer(sql.toString());\n            stmt = db.getConnection().prepareStatement(sql.toString());\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                return rs.getLong(1);\n            }\n            return -1;\n        } catch (SQLException exc) {\n            if (// we tried with and w/o quotes...fail this attempt\n            forceQuotes)\n                throw exc;\n            return fetchNumRows(clause, true);\n        } finally {\n            if (rs != null)\n                rs.close();\n            if (stmt != null)\n                stmt.close();\n        }\n    }\n\n    /**\n     * Update the table with the specified XML-derived metadata\n     *\n     * @param tableMeta\n     */\n    public void update(TableMeta tableMeta) {\n        String newComments = tableMeta.getComments();\n        if (newComments != null) {\n            comments = newComments;\n        }\n        for (TableColumnMeta colMeta : tableMeta.getColumns()) {\n            TableColumn col = getColumn(colMeta.getName());\n            if (col == null) {\n                col = addColumn(colMeta);\n            }\n            // update the column with the changes\n            col.update(colMeta);\n        }\n    }\n\n    /**\n     * Same as {@link #connectForeignKeys(Map, Database, Properties)},\n     * but uses XML-based metadata\n     *\n     * @param tableMeta\n     * @param tables\n     */\n    public void connect(TableMeta tableMeta, Map<String, Table> tables) {\n        for (TableColumnMeta colMeta : tableMeta.getColumns()) {\n            TableColumn col = getColumn(colMeta.getName());\n            if (col != null) {\n                // go thru the new foreign key defs and associate them with our columns\n                for (ForeignKeyMeta fk : colMeta.getForeignKeys()) {\n                    Table parent;\n                    if (fk.getRemoteCatalog() != null || fk.getRemoteSchema() != null) {\n                        try {\n                            // adds if doesn't exist\n                            parent = db.addRemoteTable(fk.getRemoteCatalog(), fk.getRemoteSchema(), fk.getTableName(), getContainer(), true);\n                        } catch (SQLException exc) {\n                            parent = null;\n                        }\n                    } else {\n                        parent = tables.get(fk.getTableName());\n                    }\n                    if (parent != null) {\n                        TableColumn parentColumn = parent.getColumn(fk.getColumnName());\n                        if (parentColumn == null) {\n                            logger.warning(\"Undefined column '\" + parent.getName() + '.' + fk.getColumnName() + \"' referenced by '\" + col.getTable() + '.' + col + \"' in XML metadata\");\n                        } else {\n                            /**\n                             * Merely instantiating a foreign key constraint ties it\n                             * into its parent and child columns (& therefore their tables)\n                             */\n                            @SuppressWarnings(\"unused\")\n                            ForeignKeyConstraint unused = new ForeignKeyConstraint(parentColumn, col) {\n\n                                @Override\n                                public String getName() {\n                                    return \"Defined in XML\";\n                                }\n                            };\n                            // they forgot to say it was a primary key\n                            if (!parentColumn.isPrimary()) {\n                                logger.warning(\"Assuming \" + parentColumn.getTable() + '.' + parentColumn + \" is a primary key due to being referenced by \" + col.getTable() + '.' + col);\n                                parent.setPrimaryColumn(parentColumn);\n                            }\n                        }\n                    } else {\n                        logger.warning(\"Undefined table '\" + fk.getTableName() + \"' referenced by '\" + getName() + '.' + col.getName() + \"' in XML metadata\");\n                    }\n                }\n            } else {\n                logger.warning(\"Undefined column '\" + getName() + '.' + colMeta.getName() + \"' in XML metadata\");\n            }\n        }\n    }\n\n    @Override\n    public String toString() {\n        return getName();\n    }\n\n    /**\n     * Returns <code>true</code> if this table has no relationships\n     *\n     * @param withImpliedRelationships boolean\n     * @return boolean\n     */\n    public boolean isOrphan(boolean withImpliedRelationships) {\n        if (withImpliedRelationships)\n            return getMaxParents() == 0 && getMaxChildren() == 0;\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                if (!column.getParentConstraint(parentColumn).isImplied())\n                    return false;\n            }\n            for (TableColumn childColumn : column.getChildren()) {\n                if (!column.getChildConstraint(childColumn).isImplied())\n                    return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compare this table to another table.\n     * Results are based on 1: identity, 2: table name, 3: schema name<p/>\n     *\n     * This implementation was put in place to deal with analyzing multiple\n     * schemas that contain identically named tables.\n     *\n     * @see {@link Comparable#compareTo(Object)}\n     */\n    public int compareTo(Table other) {\n        if (// fast way out\n        other == this)\n            return 0;\n        return getFullName().compareToIgnoreCase(other.getFullName());\n    }\n\n    /**\n     * Implementation of {@link Comparator} that sorts {@link TableColumn}s\n     * by {@link TableColumn#getId() ID} (ignored if <code>null</code>)\n     * followed by {@link TableColumn#getName() Name}.\n     */\n    public static class ByColumnIdComparator implements Comparator<TableColumn> {\n\n        public int compare(TableColumn column1, TableColumn column2) {\n            Object id1 = column1.getId();\n            Object id2 = column2.getId();\n            if (id1 == null || id2 == null)\n                return column1.getName().compareToIgnoreCase(column2.getName());\n            if (id1 instanceof Number && id2 instanceof Number)\n                return ((Number) id1).intValue() - ((Number) id2).intValue();\n            return id1.toString().compareToIgnoreCase(id2.toString());\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableTest0.java",
		"test_prompt": "// TableTest0.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\nimport net.sourceforge.schemaspy.model.xml.TableMeta;\nimport net.sourceforge.schemaspy.util.CaseInsensitiveMap;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Table}.\n* It contains ten unit test cases for the {@link Table#getFullName(String, String, String, String)} method.\n*/\nclass TableTest0 {"
	},
	{
		"original_code": "// Table.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\nimport net.sourceforge.schemaspy.model.xml.TableMeta;\nimport net.sourceforge.schemaspy.util.CaseInsensitiveMap;\n\n/**\n * A <code>Table</code> is one of the basic building blocks of SchemaSpy\n * that knows everything about the database table's metadata.\n *\n * @author John Currier\n */\npublic class Table implements Comparable<Table> {\n\n    private final String catalog;\n\n    private final String schema;\n\n    private final String name;\n\n    private final String fullName;\n\n    private final String container;\n\n    protected final CaseInsensitiveMap<TableColumn> columns = new CaseInsensitiveMap<TableColumn>();\n\n    private final List<TableColumn> primaryKeys = new ArrayList<TableColumn>();\n\n    private final CaseInsensitiveMap<ForeignKeyConstraint> foreignKeys = new CaseInsensitiveMap<ForeignKeyConstraint>();\n\n    private final CaseInsensitiveMap<TableIndex> indexes = new CaseInsensitiveMap<TableIndex>();\n\n    private Object id;\n\n    private final Map<String, String> checkConstraints = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);\n\n    private Long numRows;\n\n    protected final Database db;\n\n    private String comments;\n\n    private int maxChildren;\n\n    private int maxParents;\n\n    private final static Logger logger = Logger.getLogger(Table.class.getName());\n\n    private final static boolean fineEnabled = logger.isLoggable(Level.FINE);\n\n    private final static boolean finerEnabled = logger.isLoggable(Level.FINER);\n\n    /**\n     * Construct a table that knows everything about the database table's metadata\n     *\n     * @param db\n     * @param catalog\n     * @param schema\n     * @param name\n     * @param comments\n     * @throws SQLException\n     */\n    public Table(Database db, String catalog, String schema, String name, String comments) throws SQLException {\n        this.db = db;\n        this.catalog = catalog;\n        this.schema = schema;\n        this.container = schema != null ? schema : catalog != null ? catalog : db.getName();\n        this.name = name;\n        this.fullName = getFullName(db.getName(), catalog, schema, name);\n        if (fineEnabled)\n            logger.fine(\"Creating \" + getClass().getSimpleName() + \" \" + fullName);\n        setComments(comments);\n        initColumns();\n        initIndexes();\n        initPrimaryKeys();\n    }\n\n    /**\n     * \"Connect\" all of this table's foreign keys to their referenced primary keys\n     * (and, in some cases, do the reverse as well).\n     *\n     * @param tables\n     * @throws SQLException\n     */\n    public void connectForeignKeys(Map<String, Table> tables) throws SQLException {\n        if (finerEnabled)\n            logger.finer(\"Connecting foreign keys to \" + getFullName());\n        ResultSet rs = null;\n        try {\n            // get our foreign keys that reference other tables' primary keys\n            rs = db.getMetaData().getImportedKeys(getCatalog(), getSchema(), getName());\n            while (rs.next()) {\n                addForeignKey(rs.getString(\"FK_NAME\"), rs.getString(\"FKCOLUMN_NAME\"), rs.getString(\"PKTABLE_CAT\"), rs.getString(\"PKTABLE_SCHEM\"), rs.getString(\"PKTABLE_NAME\"), rs.getString(\"PKCOLUMN_NAME\"), rs.getInt(\"UPDATE_RULE\"), rs.getInt(\"DELETE_RULE\"), tables);\n            }\n        } finally {\n            if (rs != null)\n                rs.close();\n        }\n        // also try to find all of the 'remote' tables in other schemas that\n        // point to our primary keys (not necessary in the normal case\n        // as we infer this from the opposite direction)\n        if (getSchema() != null || getCatalog() != null) {\n            try {\n                // get the foreign keys that reference our primary keys\n                rs = db.getMetaData().getExportedKeys(getCatalog(), getSchema(), getName());\n                while (rs.next()) {\n                    String otherCatalog = rs.getString(\"FKTABLE_CAT\");\n                    String otherSchema = rs.getString(\"FKTABLE_SCHEM\");\n                    if (!String.valueOf(getSchema()).equals(String.valueOf(otherSchema)) || !String.valueOf(getCatalog()).equals(String.valueOf(otherCatalog))) {\n                        db.addRemoteTable(otherCatalog, otherSchema, rs.getString(\"FKTABLE_NAME\"), getSchema(), false);\n                    }\n                }\n            } finally {\n                if (rs != null)\n                    rs.close();\n            }\n        }\n    }\n\n    /**\n     * Get the foreign keys associated with this table\n     *\n     * @return\n     */\n    public Collection<ForeignKeyConstraint> getForeignKeys() {\n        return Collections.unmodifiableCollection(foreignKeys.values());\n    }\n\n    /**\n     * Add a check constraint to the table\n     * (no real details, just name and textual representation)\n     *\n     * @param constraintName\n     * @param text\n     */\n    public void addCheckConstraint(String constraintName, String text) {\n        checkConstraints.put(constraintName, text);\n    }\n\n    /**\n     * @param rs ResultSet from {@link DatabaseMetaData#getImportedKeys(String, String, String)}\n     * rs.getString(\"FK_NAME\");\n     * rs.getString(\"FKCOLUMN_NAME\");\n     * rs.getString(\"PKTABLE_CAT\");\n     * rs.getString(\"PKTABLE_SCHEM\");\n     * rs.getString(\"PKTABLE_NAME\");\n     * rs.getString(\"PKCOLUMN_NAME\");\n     * @param tables Map\n     * @param db\n     * @throws SQLException\n     */\n    protected void addForeignKey(String fkName, String fkColName, String pkCatalog, String pkSchema, String pkTableName, String pkColName, int updateRule, int deleteRule, Map<String, Table> tables) throws SQLException {\n        if (fkName == null)\n            return;\n        Pattern include = Config.getInstance().getTableInclusions();\n        Pattern exclude = Config.getInstance().getTableExclusions();\n        if (!include.matcher(pkTableName).matches() || exclude.matcher(pkTableName).matches()) {\n            if (fineEnabled)\n                logger.fine(\"Ignoring \" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName) + \" referenced by FK \" + fkName);\n            return;\n        }\n        ForeignKeyConstraint foreignKey = foreignKeys.get(fkName);\n        if (foreignKey == null) {\n            foreignKey = new ForeignKeyConstraint(this, fkName, updateRule, deleteRule);\n            foreignKeys.put(fkName, foreignKey);\n        }\n        TableColumn childColumn = getColumn(fkColName);\n        if (childColumn != null) {\n            foreignKey.addChildColumn(childColumn);\n            Config config = Config.getInstance();\n            Table parentTable = tables.get(pkTableName);\n            String parentContainer = pkSchema != null ? pkSchema : pkCatalog != null ? pkCatalog : db.getName();\n            String baseContainer = config.getSchema() != null ? config.getSchema() : config.getCatalog() != null ? config.getCatalog() : db.getName();\n            // if named table doesn't exist in this schema\n            // or exists here but really referencing same named table in another schema\n            if (parentTable == null || !baseContainer.equals(parentContainer)) {\n                if (fineEnabled)\n                    logger.fine(\"Adding remote table \" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName));\n                parentTable = db.addRemoteTable(pkCatalog, pkSchema, pkTableName, baseContainer, false);\n            }\n            if (parentTable != null) {\n                TableColumn parentColumn = parentTable.getColumn(pkColName);\n                if (parentColumn != null) {\n                    foreignKey.addParentColumn(parentColumn);\n                    childColumn.addParent(parentColumn, foreignKey);\n                    parentColumn.addChild(childColumn, foreignKey);\n                } else {\n                    logger.warning(\"Couldn't add FK '\" + foreignKey.getName() + \"' to table '\" + this + \"' - Column '\" + pkColName + \"' doesn't exist in table '\" + parentTable + \"'\");\n                }\n            } else {\n                logger.warning(\"Couldn't add FK '\" + foreignKey.getName() + \"' to table '\" + this + \"' - Unknown Referenced Table '\" + pkTableName + \"'\");\n            }\n        } else {\n            logger.warning(\"Couldn't add FK '\" + foreignKey.getName() + \"' to table '\" + this + \"' - Column '\" + fkColName + \"' doesn't exist\");\n        }\n    }\n\n    /**\n     * @param meta\n     * @throws SQLException\n     */\n    private void initPrimaryKeys() throws SQLException {\n        ResultSet rs = null;\n        try {\n            if (fineEnabled)\n                logger.fine(\"Querying primary keys for \" + getFullName());\n            rs = db.getMetaData().getPrimaryKeys(getCatalog(), getSchema(), getName());\n            while (rs.next()) setPrimaryColumn(rs);\n        } catch (SQLException exc) {\n            if (!isLogical()) {\n                throw exc;\n            }\n        } finally {\n            if (rs != null)\n                rs.close();\n        }\n    }\n\n    /**\n     * @param rs\n     * @throws SQLException\n     */\n    private void setPrimaryColumn(ResultSet rs) throws SQLException {\n        String pkName = rs.getString(\"PK_NAME\");\n        if (pkName == null)\n            return;\n        TableIndex index = getIndex(pkName);\n        if (index != null) {\n            index.setIsPrimaryKey(true);\n        }\n        String columnName = rs.getString(\"COLUMN_NAME\");\n        setPrimaryColumn(getColumn(columnName));\n    }\n\n    /**\n     * @param primaryColumn\n     */\n    void setPrimaryColumn(TableColumn primaryColumn) {\n        primaryKeys.add(primaryColumn);\n    }\n\n    /**\n     * @throws SQLException\n     */\n    private void initColumns() throws SQLException {\n        ResultSet rs = null;\n        synchronized (Table.class) {\n            try {\n                rs = db.getMetaData().getColumns(getCatalog(), getSchema(), getName(), \"%\");\n                while (rs.next()) addColumn(rs);\n            } catch (SQLException exc) {\n                if (!isLogical()) {\n                    class ColumnInitializationFailure extends SQLException {\n\n                        private static final long serialVersionUID = 1L;\n\n                        public ColumnInitializationFailure(SQLException failure) {\n                            super(\"Failed to collect column details for \" + (isView() ? \"view\" : \"table\") + \" '\" + getName() + \"' in schema '\" + getContainer() + \"'\");\n                            initCause(failure);\n                        }\n                    }\n                    throw new ColumnInitializationFailure(exc);\n                }\n            } finally {\n                if (rs != null)\n                    rs.close();\n            }\n        }\n        initColumnAutoUpdate(false);\n    }\n\n    /**\n     * @param forceQuotes\n     * @throws SQLException\n     */\n    private void initColumnAutoUpdate(boolean forceQuotes) throws SQLException {\n        ResultSet rs = null;\n        PreparedStatement stmt = null;\n        if (isView() || isRemote())\n            return;\n        // we've got to get a result set with all the columns in it\n        // so we can ask if the columns are auto updated\n        // Ugh!!!  Should have been in DatabaseMetaData instead!!!\n        StringBuilder sql = new StringBuilder(\"select * from \");\n        if (getSchema() != null) {\n            sql.append(getSchema());\n            sql.append('.');\n        } else if (getCatalog() != null) {\n            sql.append(getCatalog());\n            sql.append('.');\n        }\n        if (forceQuotes) {\n            String quote = db.getMetaData().getIdentifierQuoteString().trim();\n            sql.append(quote + getName() + quote);\n        } else\n            sql.append(db.getQuotedIdentifier(getName()));\n        sql.append(\" where 0 = 1\");\n        try {\n            stmt = db.getMetaData().getConnection().prepareStatement(sql.toString());\n            rs = stmt.executeQuery();\n            ResultSetMetaData rsMeta = rs.getMetaData();\n            for (int i = rsMeta.getColumnCount(); i > 0; --i) {\n                TableColumn column = getColumn(rsMeta.getColumnName(i));\n                column.setIsAutoUpdated(rsMeta.isAutoIncrement(i));\n            }\n        } catch (SQLException exc) {\n            if (forceQuotes) {\n                if (!isLogical()) {\n                    // don't completely choke just because we couldn't do this....\n                    logger.warning(\"Failed to determine auto increment status: \" + exc);\n                    logger.warning(\"SQL: \" + sql.toString());\n                }\n            } else {\n                initColumnAutoUpdate(true);\n            }\n        } finally {\n            if (rs != null)\n                rs.close();\n            if (stmt != null)\n                stmt.close();\n        }\n    }\n\n    /**\n     * @param rs - from {@link DatabaseMetaData#getColumns(String, String, String, String)}\n     * @throws SQLException\n     */\n    protected void addColumn(ResultSet rs) throws SQLException {\n        String columnName = rs.getString(\"COLUMN_NAME\");\n        if (columnName == null)\n            return;\n        if (getColumn(columnName) == null) {\n            TableColumn column = new TableColumn(this, rs);\n            columns.put(column.getName(), column);\n        }\n    }\n\n    /**\n     * Add a column that's defined in xml metadata.\n     * Assumes that a column named colMeta.getName() doesn't already exist in <code>columns</code>.\n     * @param colMeta\n     * @return\n     */\n    protected TableColumn addColumn(TableColumnMeta colMeta) {\n        TableColumn column = new TableColumn(this, colMeta);\n        columns.put(column.getName(), column);\n        return column;\n    }\n\n    /**\n     * Initialize index information\n     *\n     * @throws SQLException\n     */\n    private void initIndexes() throws SQLException {\n        if (isView() || isRemote())\n            return;\n        // first try to initialize using the index query spec'd in the .properties\n        // do this first because some DB's (e.g. Oracle) do 'bad' things with getIndexInfo()\n        // (they try to do a DDL analyze command that has some bad side-effects)\n        if (initIndexes(Config.getInstance().getDbProperties().getProperty(\"selectIndexesSql\")))\n            return;\n        // couldn't, so try the old fashioned approach\n        ResultSet rs = null;\n        try {\n            rs = db.getMetaData().getIndexInfo(getCatalog(), getSchema(), getName(), false, true);\n            while (rs.next()) {\n                if (rs.getShort(\"TYPE\") != DatabaseMetaData.tableIndexStatistic)\n                    addIndex(rs);\n            }\n        } catch (SQLException exc) {\n            if (!isLogical())\n                logger.warning(\"Unable to extract index info for table '\" + getName() + \"' in schema '\" + getContainer() + \"': \" + exc);\n        } finally {\n            if (rs != null)\n                rs.close();\n        }\n    }\n\n    /**\n     * Try to initialize index information based on the specified SQL\n     *\n     * @return boolean <code>true</code> if it worked, otherwise <code>false</code>\n     */\n    private boolean initIndexes(String selectIndexesSql) {\n        if (selectIndexesSql == null)\n            return false;\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = db.prepareStatement(selectIndexesSql, getName());\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                if (rs.getShort(\"TYPE\") != DatabaseMetaData.tableIndexStatistic)\n                    addIndex(rs);\n            }\n        } catch (SQLException sqlException) {\n            logger.warning(\"Failed to query index information with SQL: \" + selectIndexesSql);\n            logger.warning(sqlException.toString());\n            return false;\n        } finally {\n            if (rs != null) {\n                try {\n                    rs.close();\n                } catch (Exception exc) {\n                    exc.printStackTrace();\n                }\n            }\n            if (stmt != null) {\n                try {\n                    stmt.close();\n                } catch (Exception exc) {\n                    exc.printStackTrace();\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @param indexName\n     * @return\n     */\n    public TableIndex getIndex(String indexName) {\n        return indexes.get(indexName);\n    }\n\n    /**\n     * @param rs\n     * @throws SQLException\n     */\n    private void addIndex(ResultSet rs) throws SQLException {\n        String indexName = rs.getString(\"INDEX_NAME\");\n        if (indexName == null)\n            return;\n        TableIndex index = getIndex(indexName);\n        if (index == null) {\n            index = new TableIndex(rs);\n            indexes.put(index.getName(), index);\n        }\n        index.addColumn(getColumn(rs.getString(\"COLUMN_NAME\")), rs.getString(\"ASC_OR_DESC\"));\n    }\n\n    /**\n     * Returns the catalog that the table belongs to\n     *\n     * @return\n     */\n    public String getCatalog() {\n        return catalog;\n    }\n\n    /**\n     * Returns the schema that the table belongs to\n     *\n     * @return\n     */\n    public String getSchema() {\n        return schema;\n    }\n\n    /**\n     * Returns the logical 'container' that the table\n     * lives in.  Basically it's the first non-<code>null</code>\n     * item out of <code>schema</code>, <code>catalog</code>\n     * and <code>database</code>.\n     *\n     * @return\n     */\n    public String getContainer() {\n        return container;\n    }\n\n    /**\n     * Returns the name of the table\n     *\n     * @return\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the fully-qualified name of this table\n     *\n     * @return\n     */\n    public String getFullName() {\n        return fullName;\n    }\n\n    /**\n     * Returns the fully-qualified name of a table\n     *\n     * @return\n     */\n    public static String getFullName(String db, String catalog, String schema, String table) {\n        String fullName = (catalog == null && schema == null ? db + '.' : \"\") + (catalog == null ? \"\" : catalog + '.') + (schema == null ? \"\" : schema + '.') + table;\n        return fullName;\n    }\n\n    /**\n     * Object IDs are useful for tables such as DB/2 that many times\n     * give error messages based on object ID and not name\n     *\n     * @param id\n     */\n    public void setId(Object id) {\n        this.id = id;\n    }\n\n    /**\n     * @see #setId(Object)\n     *\n     * @return\n     */\n    public Object getId() {\n        return id;\n    }\n\n    /**\n     * Returns the check constraints associated with this table\n     *\n     * @return\n     */\n    public Map<String, String> getCheckConstraints() {\n        return checkConstraints;\n    }\n\n    /**\n     * Returns the indexes that are applied to this table\n     *\n     * @return\n     */\n    public Set<TableIndex> getIndexes() {\n        return new HashSet<TableIndex>(indexes.values());\n    }\n\n    /**\n     * Returns a collection of table columns that have been identified as \"primary\"\n     *\n     * @return\n     */\n    public List<TableColumn> getPrimaryColumns() {\n        return primaryKeys;\n    }\n\n    /**\n     * @return Comments associated with this table, or <code>null</code> if none.\n     */\n    public String getComments() {\n        return comments;\n    }\n\n    /**\n     * Sets the comments that are associated with this table\n     *\n     * @param comments\n     */\n    public void setComments(String comments) {\n        String cmts = (comments == null || comments.trim().length() == 0) ? null : comments.trim();\n        // MySQL's InnoDB engine does some insane crap of storing erroneous details in\n        // with table comments.  Here I attempt to strip the \"crap\" out without impacting\n        // other databases.  Ideally this should happen in selectColumnCommentsSql (and\n        // therefore isolate it to MySQL), but it's a bit too complex to do cleanly.\n        if (cmts != null) {\n            int crapIndex = cmts.indexOf(\"; InnoDB free: \");\n            if (crapIndex == -1)\n                crapIndex = cmts.startsWith(\"InnoDB free: \") ? 0 : -1;\n            if (crapIndex != -1) {\n                cmts = cmts.substring(0, crapIndex).trim();\n                cmts = cmts.length() == 0 ? null : cmts;\n            }\n        }\n        this.comments = cmts;\n    }\n\n    /**\n     * Returns the {@link TableColumn} with the given name, or <code>null</code>\n     * if it doesn't exist\n     *\n     * @param columnName\n     * @return\n     */\n    public TableColumn getColumn(String columnName) {\n        return columns.get(columnName);\n    }\n\n    /**\n     * Returns <code>List</code> of <code>TableColumn</code>s in ascending column number order.\n     *\n     * @return\n     */\n    public List<TableColumn> getColumns() {\n        Set<TableColumn> sorted = new TreeSet<TableColumn>(new ByColumnIdComparator());\n        sorted.addAll(columns.values());\n        return new ArrayList<TableColumn>(sorted);\n    }\n\n    /**\n     * Returns <code>true</code> if this table references no other tables..<p/>\n     * Used in dependency analysis.\n     * @return\n     */\n    public boolean isRoot() {\n        for (TableColumn column : columns.values()) {\n            if (column.isForeignKey()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns <code>true</code> if this table is referenced by no other tables.<p/>\n     * Used in dependency analysis.\n     * @return\n     */\n    public boolean isLeaf() {\n        for (TableColumn column : columns.values()) {\n            if (!column.getChildren().isEmpty()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the maximum number of parents that this table has had before\n     * any had been removed during dependency analysis\n     *\n     * @return\n     */\n    public int getMaxParents() {\n        return maxParents;\n    }\n\n    /**\n     * Notification that's called to indicate that a parent has been added to\n     * this table\n     */\n    public void addedParent() {\n        maxParents++;\n    }\n\n    /**\n     * \"Unlink\" all of the parent tables from this table\n     */\n    public void unlinkParents() {\n        for (TableColumn column : columns.values()) {\n            column.unlinkParents();\n        }\n    }\n\n    /**\n     * Returns the maximum number of children that this table has had before\n     * any had been removed during dependency analysis\n     *\n     * @return\n     */\n    public int getMaxChildren() {\n        return maxChildren;\n    }\n\n    /**\n     * Notification that's called to indicate that a child has been added to\n     * this table\n     */\n    public void addedChild() {\n        maxChildren++;\n    }\n\n    /**\n     * \"Unlink\" all of the child tables from this table\n     */\n    public void unlinkChildren() {\n        for (TableColumn column : columns.values()) {\n            column.unlinkChildren();\n        }\n    }\n\n    /**\n     * Remove a single self referencing constraint if one exists.\n     *\n     * @return\n     */\n    public ForeignKeyConstraint removeSelfReferencingConstraint() {\n        return remove(getSelfReferencingConstraint());\n    }\n\n    /**\n     * Remove the specified {@link ForeignKeyConstraint} from this table.<p>\n     *\n     * This is a more drastic removal solution that was proposed by Remke Rutgers\n     *\n     * @param constraint\n     */\n    private ForeignKeyConstraint remove(ForeignKeyConstraint constraint) {\n        if (constraint != null) {\n            for (int i = 0; i < constraint.getChildColumns().size(); i++) {\n                TableColumn childColumn = constraint.getChildColumns().get(i);\n                TableColumn parentColumn = constraint.getParentColumns().get(i);\n                childColumn.removeParent(parentColumn);\n                parentColumn.removeChild(childColumn);\n            }\n        }\n        return constraint;\n    }\n\n    /**\n     * Return a self referencing constraint if one exists\n     *\n     * @return\n     */\n    private ForeignKeyConstraint getSelfReferencingConstraint() {\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                if (compareTo(parentColumn.getTable()) == 0) {\n                    return column.getParentConstraint(parentColumn);\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Remove any non-real foreign keys\n     *\n     * @return\n     */\n    public List<ForeignKeyConstraint> removeNonRealForeignKeys() {\n        List<ForeignKeyConstraint> nonReals = new ArrayList<ForeignKeyConstraint>();\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                ForeignKeyConstraint constraint = column.getParentConstraint(parentColumn);\n                if (constraint != null && !constraint.isReal()) {\n                    nonReals.add(constraint);\n                }\n            }\n        }\n        // remove constraints outside of above loop to prevent\n        // concurrent modification exceptions while iterating\n        for (ForeignKeyConstraint constraint : nonReals) {\n            remove(constraint);\n        }\n        return nonReals;\n    }\n\n    /**\n     * Returns the number of tables that reference this table\n     *\n     * @return\n     */\n    public int getNumChildren() {\n        int numChildren = 0;\n        for (TableColumn column : columns.values()) {\n            numChildren += column.getChildren().size();\n        }\n        return numChildren;\n    }\n\n    /**\n     * Returns the number of non-implied children\n     * @return\n     */\n    public int getNumNonImpliedChildren() {\n        int numChildren = 0;\n        for (TableColumn column : columns.values()) {\n            for (TableColumn childColumn : column.getChildren()) {\n                if (!column.getChildConstraint(childColumn).isImplied())\n                    ++numChildren;\n            }\n        }\n        return numChildren;\n    }\n\n    /**\n     * Returns the number of tables that are referenced by this table\n     *\n     * @return\n     */\n    public int getNumParents() {\n        int numParents = 0;\n        for (TableColumn column : columns.values()) {\n            numParents += column.getParents().size();\n        }\n        return numParents;\n    }\n\n    /**\n     * Returns the number of non-implied parents\n     *\n     * @return\n     */\n    public int getNumNonImpliedParents() {\n        int numParents = 0;\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                if (!column.getParentConstraint(parentColumn).isImplied())\n                    ++numParents;\n            }\n        }\n        return numParents;\n    }\n\n    /**\n     * Remove one foreign key constraint.\n     *\n     * <p/>Used during dependency analysis phase.\n     *\n     * @return\n     */\n    public ForeignKeyConstraint removeAForeignKeyConstraint() {\n        @SuppressWarnings(\"hiding\")\n        final List<TableColumn> columns = getColumns();\n        int numParents = 0;\n        int numChildren = 0;\n        // remove either a child or parent, choosing which based on which has the\n        // least number of foreign key associations (when either gets to zero then\n        // the table can be pruned)\n        for (TableColumn column : columns) {\n            numParents += column.getParents().size();\n            numChildren += column.getChildren().size();\n        }\n        for (TableColumn column : columns) {\n            ForeignKeyConstraint constraint;\n            if (numParents <= numChildren)\n                constraint = column.removeAParentFKConstraint();\n            else\n                constraint = column.removeAChildFKConstraint();\n            if (constraint != null)\n                return constraint;\n        }\n        return null;\n    }\n\n    /**\n     * Returns <code>true</code> if this table is logical (not physical), <code>false</code> otherwise\n     * @return\n     */\n    public boolean isLogical() {\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if this is a view, <code>false</code> otherwise\n     *\n     * @return\n     */\n    public boolean isView() {\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if this table is remote (in another schema), <code>false</code> otherwise\n     * @return\n     */\n    public boolean isRemote() {\n        return false;\n    }\n\n    /**\n     * If this is a view it returns the SQL used to create the view (if it's available).\n     * <code>null</code> if it's not a view or the SQL isn't available.\n     * @return\n     * @see #isView()\n     */\n    public String getViewSql() {\n        return null;\n    }\n\n    /**\n     * Returns the number of rows contained in this table, or -1 if unable to determine\n     * the number of rows.\n     *\n     * @return\n     */\n    public long getNumRows() {\n        if (numRows == null) {\n            numRows = Config.getInstance().isNumRowsEnabled() ? fetchNumRows() : -1;\n        }\n        return numRows;\n    }\n\n    /**\n     * Explicitly set the number of rows in this table\n     *\n     * @param numRows\n     */\n    public void setNumRows(long numRows) {\n        this.numRows = numRows;\n    }\n\n    /**\n     * Fetch the number of rows contained in this table.\n     *\n     * returns -1 if unable to successfully fetch the row count\n     *\n     * @param db Database\n     * @return int\n     * @throws SQLException\n     */\n    protected long fetchNumRows() {\n        if (isView() || isRemote())\n            return -1;\n        SQLException originalFailure = null;\n        String sql = Config.getInstance().getDbProperties().getProperty(\"selectRowCountSql\");\n        if (sql != null) {\n            PreparedStatement stmt = null;\n            ResultSet rs = null;\n            try {\n                stmt = db.prepareStatement(sql, getName());\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    return rs.getLong(\"row_count\");\n                }\n            } catch (SQLException sqlException) {\n                // don't die just because this failed\n                originalFailure = sqlException;\n            } finally {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    } catch (SQLException exc) {\n                    }\n                }\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException exc) {\n                    }\n                }\n            }\n        }\n        // if we get here then we either didn't have custom SQL or it didn't work\n        try {\n            // '*' should work best for the majority of cases\n            return fetchNumRows(\"count(*)\", false);\n        } catch (SQLException try2Exception) {\n            try {\n                // except nested tables...try using '1' instead\n                return fetchNumRows(\"count(1)\", false);\n            } catch (SQLException try3Exception) {\n                if (!isLogical()) {\n                    logger.warning(\"Unable to extract the number of rows for table \" + getName() + \", using '-1'\");\n                    if (originalFailure != null)\n                        logger.warning(originalFailure.toString());\n                    logger.warning(try2Exception.toString());\n                    if (!String.valueOf(try2Exception.toString()).equals(try3Exception.toString()))\n                        logger.warning(try3Exception.toString());\n                }\n                return -1;\n            }\n        }\n    }\n\n    protected long fetchNumRows(String clause, boolean forceQuotes) throws SQLException {\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        StringBuilder sql = new StringBuilder(\"select \");\n        sql.append(clause);\n        sql.append(\" from \");\n        if (getSchema() != null) {\n            sql.append(getSchema());\n            sql.append('.');\n        } else if (getCatalog() != null) {\n            sql.append(getCatalog());\n            sql.append('.');\n        }\n        if (forceQuotes) {\n            String quote = db.getMetaData().getIdentifierQuoteString().trim();\n            sql.append(quote + getName() + quote);\n        } else\n            sql.append(db.getQuotedIdentifier(getName()));\n        try {\n            if (finerEnabled)\n                logger.finer(sql.toString());\n            stmt = db.getConnection().prepareStatement(sql.toString());\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                return rs.getLong(1);\n            }\n            return -1;\n        } catch (SQLException exc) {\n            if (// we tried with and w/o quotes...fail this attempt\n            forceQuotes)\n                throw exc;\n            return fetchNumRows(clause, true);\n        } finally {\n            if (rs != null)\n                rs.close();\n            if (stmt != null)\n                stmt.close();\n        }\n    }\n\n    /**\n     * Update the table with the specified XML-derived metadata\n     *\n     * @param tableMeta\n     */\n    public void update(TableMeta tableMeta) {\n        String newComments = tableMeta.getComments();\n        if (newComments != null) {\n            comments = newComments;\n        }\n        for (TableColumnMeta colMeta : tableMeta.getColumns()) {\n            TableColumn col = getColumn(colMeta.getName());\n            if (col == null) {\n                col = addColumn(colMeta);\n            }\n            // update the column with the changes\n            col.update(colMeta);\n        }\n    }\n\n    /**\n     * Same as {@link #connectForeignKeys(Map, Database, Properties)},\n     * but uses XML-based metadata\n     *\n     * @param tableMeta\n     * @param tables\n     */\n    public void connect(TableMeta tableMeta, Map<String, Table> tables) {\n        for (TableColumnMeta colMeta : tableMeta.getColumns()) {\n            TableColumn col = getColumn(colMeta.getName());\n            if (col != null) {\n                // go thru the new foreign key defs and associate them with our columns\n                for (ForeignKeyMeta fk : colMeta.getForeignKeys()) {\n                    Table parent;\n                    if (fk.getRemoteCatalog() != null || fk.getRemoteSchema() != null) {\n                        try {\n                            // adds if doesn't exist\n                            parent = db.addRemoteTable(fk.getRemoteCatalog(), fk.getRemoteSchema(), fk.getTableName(), getContainer(), true);\n                        } catch (SQLException exc) {\n                            parent = null;\n                        }\n                    } else {\n                        parent = tables.get(fk.getTableName());\n                    }\n                    if (parent != null) {\n                        TableColumn parentColumn = parent.getColumn(fk.getColumnName());\n                        if (parentColumn == null) {\n                            logger.warning(\"Undefined column '\" + parent.getName() + '.' + fk.getColumnName() + \"' referenced by '\" + col.getTable() + '.' + col + \"' in XML metadata\");\n                        } else {\n                            /**\n                             * Merely instantiating a foreign key constraint ties it\n                             * into its parent and child columns (& therefore their tables)\n                             */\n                            @SuppressWarnings(\"unused\")\n                            ForeignKeyConstraint unused = new ForeignKeyConstraint(parentColumn, col) {\n\n                                @Override\n                                public String getName() {\n                                    return \"Defined in XML\";\n                                }\n                            };\n                            // they forgot to say it was a primary key\n                            if (!parentColumn.isPrimary()) {\n                                logger.warning(\"Assuming \" + parentColumn.getTable() + '.' + parentColumn + \" is a primary key due to being referenced by \" + col.getTable() + '.' + col);\n                                parent.setPrimaryColumn(parentColumn);\n                            }\n                        }\n                    } else {\n                        logger.warning(\"Undefined table '\" + fk.getTableName() + \"' referenced by '\" + getName() + '.' + col.getName() + \"' in XML metadata\");\n                    }\n                }\n            } else {\n                logger.warning(\"Undefined column '\" + getName() + '.' + colMeta.getName() + \"' in XML metadata\");\n            }\n        }\n    }\n\n    @Override\n    public String toString() {\n        return getName();\n    }\n\n    /**\n     * Returns <code>true</code> if this table has no relationships\n     *\n     * @param withImpliedRelationships boolean\n     * @return boolean\n     */\n    public boolean isOrphan(boolean withImpliedRelationships) {\n        if (withImpliedRelationships)\n            return getMaxParents() == 0 && getMaxChildren() == 0;\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                if (!column.getParentConstraint(parentColumn).isImplied())\n                    return false;\n            }\n            for (TableColumn childColumn : column.getChildren()) {\n                if (!column.getChildConstraint(childColumn).isImplied())\n                    return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compare this table to another table.\n     * Results are based on 1: identity, 2: table name, 3: schema name<p/>\n     *\n     * This implementation was put in place to deal with analyzing multiple\n     * schemas that contain identically named tables.\n     *\n     * @see {@link Comparable#compareTo(Object)}\n     */\n    public int compareTo(Table other) {\n        if (// fast way out\n        other == this)\n            return 0;\n        return getFullName().compareToIgnoreCase(other.getFullName());\n    }\n\n    /**\n     * Implementation of {@link Comparator} that sorts {@link TableColumn}s\n     * by {@link TableColumn#getId() ID} (ignored if <code>null</code>)\n     * followed by {@link TableColumn#getName() Name}.\n     */\n    public static class ByColumnIdComparator implements Comparator<TableColumn> {\n\n        public int compare(TableColumn column1, TableColumn column2) {\n            Object id1 = column1.getId();\n            Object id2 = column2.getId();\n            if (id1 == null || id2 == null)\n                return column1.getName().compareToIgnoreCase(column2.getName());\n            if (id1 instanceof Number && id2 instanceof Number)\n                return ((Number) id1).intValue() - ((Number) id2).intValue();\n            return id1.toString().compareToIgnoreCase(id2.toString());\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableTest1.java",
		"test_prompt": "// TableTest1.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\nimport net.sourceforge.schemaspy.model.xml.TableMeta;\nimport net.sourceforge.schemaspy.util.CaseInsensitiveMap;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Table}.\n* It contains ten unit test cases for the {@link Table#isRoot()} method.\n*/\nclass TableTest1 {"
	},
	{
		"original_code": "// Table.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\nimport net.sourceforge.schemaspy.model.xml.TableMeta;\nimport net.sourceforge.schemaspy.util.CaseInsensitiveMap;\n\n/**\n * A <code>Table</code> is one of the basic building blocks of SchemaSpy\n * that knows everything about the database table's metadata.\n *\n * @author John Currier\n */\npublic class Table implements Comparable<Table> {\n\n    private final String catalog;\n\n    private final String schema;\n\n    private final String name;\n\n    private final String fullName;\n\n    private final String container;\n\n    protected final CaseInsensitiveMap<TableColumn> columns = new CaseInsensitiveMap<TableColumn>();\n\n    private final List<TableColumn> primaryKeys = new ArrayList<TableColumn>();\n\n    private final CaseInsensitiveMap<ForeignKeyConstraint> foreignKeys = new CaseInsensitiveMap<ForeignKeyConstraint>();\n\n    private final CaseInsensitiveMap<TableIndex> indexes = new CaseInsensitiveMap<TableIndex>();\n\n    private Object id;\n\n    private final Map<String, String> checkConstraints = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);\n\n    private Long numRows;\n\n    protected final Database db;\n\n    private String comments;\n\n    private int maxChildren;\n\n    private int maxParents;\n\n    private final static Logger logger = Logger.getLogger(Table.class.getName());\n\n    private final static boolean fineEnabled = logger.isLoggable(Level.FINE);\n\n    private final static boolean finerEnabled = logger.isLoggable(Level.FINER);\n\n    /**\n     * Construct a table that knows everything about the database table's metadata\n     *\n     * @param db\n     * @param catalog\n     * @param schema\n     * @param name\n     * @param comments\n     * @throws SQLException\n     */\n    public Table(Database db, String catalog, String schema, String name, String comments) throws SQLException {\n        this.db = db;\n        this.catalog = catalog;\n        this.schema = schema;\n        this.container = schema != null ? schema : catalog != null ? catalog : db.getName();\n        this.name = name;\n        this.fullName = getFullName(db.getName(), catalog, schema, name);\n        if (fineEnabled)\n            logger.fine(\"Creating \" + getClass().getSimpleName() + \" \" + fullName);\n        setComments(comments);\n        initColumns();\n        initIndexes();\n        initPrimaryKeys();\n    }\n\n    /**\n     * \"Connect\" all of this table's foreign keys to their referenced primary keys\n     * (and, in some cases, do the reverse as well).\n     *\n     * @param tables\n     * @throws SQLException\n     */\n    public void connectForeignKeys(Map<String, Table> tables) throws SQLException {\n        if (finerEnabled)\n            logger.finer(\"Connecting foreign keys to \" + getFullName());\n        ResultSet rs = null;\n        try {\n            // get our foreign keys that reference other tables' primary keys\n            rs = db.getMetaData().getImportedKeys(getCatalog(), getSchema(), getName());\n            while (rs.next()) {\n                addForeignKey(rs.getString(\"FK_NAME\"), rs.getString(\"FKCOLUMN_NAME\"), rs.getString(\"PKTABLE_CAT\"), rs.getString(\"PKTABLE_SCHEM\"), rs.getString(\"PKTABLE_NAME\"), rs.getString(\"PKCOLUMN_NAME\"), rs.getInt(\"UPDATE_RULE\"), rs.getInt(\"DELETE_RULE\"), tables);\n            }\n        } finally {\n            if (rs != null)\n                rs.close();\n        }\n        // also try to find all of the 'remote' tables in other schemas that\n        // point to our primary keys (not necessary in the normal case\n        // as we infer this from the opposite direction)\n        if (getSchema() != null || getCatalog() != null) {\n            try {\n                // get the foreign keys that reference our primary keys\n                rs = db.getMetaData().getExportedKeys(getCatalog(), getSchema(), getName());\n                while (rs.next()) {\n                    String otherCatalog = rs.getString(\"FKTABLE_CAT\");\n                    String otherSchema = rs.getString(\"FKTABLE_SCHEM\");\n                    if (!String.valueOf(getSchema()).equals(String.valueOf(otherSchema)) || !String.valueOf(getCatalog()).equals(String.valueOf(otherCatalog))) {\n                        db.addRemoteTable(otherCatalog, otherSchema, rs.getString(\"FKTABLE_NAME\"), getSchema(), false);\n                    }\n                }\n            } finally {\n                if (rs != null)\n                    rs.close();\n            }\n        }\n    }\n\n    /**\n     * Get the foreign keys associated with this table\n     *\n     * @return\n     */\n    public Collection<ForeignKeyConstraint> getForeignKeys() {\n        return Collections.unmodifiableCollection(foreignKeys.values());\n    }\n\n    /**\n     * Add a check constraint to the table\n     * (no real details, just name and textual representation)\n     *\n     * @param constraintName\n     * @param text\n     */\n    public void addCheckConstraint(String constraintName, String text) {\n        checkConstraints.put(constraintName, text);\n    }\n\n    /**\n     * @param rs ResultSet from {@link DatabaseMetaData#getImportedKeys(String, String, String)}\n     * rs.getString(\"FK_NAME\");\n     * rs.getString(\"FKCOLUMN_NAME\");\n     * rs.getString(\"PKTABLE_CAT\");\n     * rs.getString(\"PKTABLE_SCHEM\");\n     * rs.getString(\"PKTABLE_NAME\");\n     * rs.getString(\"PKCOLUMN_NAME\");\n     * @param tables Map\n     * @param db\n     * @throws SQLException\n     */\n    protected void addForeignKey(String fkName, String fkColName, String pkCatalog, String pkSchema, String pkTableName, String pkColName, int updateRule, int deleteRule, Map<String, Table> tables) throws SQLException {\n        if (fkName == null)\n            return;\n        Pattern include = Config.getInstance().getTableInclusions();\n        Pattern exclude = Config.getInstance().getTableExclusions();\n        if (!include.matcher(pkTableName).matches() || exclude.matcher(pkTableName).matches()) {\n            if (fineEnabled)\n                logger.fine(\"Ignoring \" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName) + \" referenced by FK \" + fkName);\n            return;\n        }\n        ForeignKeyConstraint foreignKey = foreignKeys.get(fkName);\n        if (foreignKey == null) {\n            foreignKey = new ForeignKeyConstraint(this, fkName, updateRule, deleteRule);\n            foreignKeys.put(fkName, foreignKey);\n        }\n        TableColumn childColumn = getColumn(fkColName);\n        if (childColumn != null) {\n            foreignKey.addChildColumn(childColumn);\n            Config config = Config.getInstance();\n            Table parentTable = tables.get(pkTableName);\n            String parentContainer = pkSchema != null ? pkSchema : pkCatalog != null ? pkCatalog : db.getName();\n            String baseContainer = config.getSchema() != null ? config.getSchema() : config.getCatalog() != null ? config.getCatalog() : db.getName();\n            // if named table doesn't exist in this schema\n            // or exists here but really referencing same named table in another schema\n            if (parentTable == null || !baseContainer.equals(parentContainer)) {\n                if (fineEnabled)\n                    logger.fine(\"Adding remote table \" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName));\n                parentTable = db.addRemoteTable(pkCatalog, pkSchema, pkTableName, baseContainer, false);\n            }\n            if (parentTable != null) {\n                TableColumn parentColumn = parentTable.getColumn(pkColName);\n                if (parentColumn != null) {\n                    foreignKey.addParentColumn(parentColumn);\n                    childColumn.addParent(parentColumn, foreignKey);\n                    parentColumn.addChild(childColumn, foreignKey);\n                } else {\n                    logger.warning(\"Couldn't add FK '\" + foreignKey.getName() + \"' to table '\" + this + \"' - Column '\" + pkColName + \"' doesn't exist in table '\" + parentTable + \"'\");\n                }\n            } else {\n                logger.warning(\"Couldn't add FK '\" + foreignKey.getName() + \"' to table '\" + this + \"' - Unknown Referenced Table '\" + pkTableName + \"'\");\n            }\n        } else {\n            logger.warning(\"Couldn't add FK '\" + foreignKey.getName() + \"' to table '\" + this + \"' - Column '\" + fkColName + \"' doesn't exist\");\n        }\n    }\n\n    /**\n     * @param meta\n     * @throws SQLException\n     */\n    private void initPrimaryKeys() throws SQLException {\n        ResultSet rs = null;\n        try {\n            if (fineEnabled)\n                logger.fine(\"Querying primary keys for \" + getFullName());\n            rs = db.getMetaData().getPrimaryKeys(getCatalog(), getSchema(), getName());\n            while (rs.next()) setPrimaryColumn(rs);\n        } catch (SQLException exc) {\n            if (!isLogical()) {\n                throw exc;\n            }\n        } finally {\n            if (rs != null)\n                rs.close();\n        }\n    }\n\n    /**\n     * @param rs\n     * @throws SQLException\n     */\n    private void setPrimaryColumn(ResultSet rs) throws SQLException {\n        String pkName = rs.getString(\"PK_NAME\");\n        if (pkName == null)\n            return;\n        TableIndex index = getIndex(pkName);\n        if (index != null) {\n            index.setIsPrimaryKey(true);\n        }\n        String columnName = rs.getString(\"COLUMN_NAME\");\n        setPrimaryColumn(getColumn(columnName));\n    }\n\n    /**\n     * @param primaryColumn\n     */\n    void setPrimaryColumn(TableColumn primaryColumn) {\n        primaryKeys.add(primaryColumn);\n    }\n\n    /**\n     * @throws SQLException\n     */\n    private void initColumns() throws SQLException {\n        ResultSet rs = null;\n        synchronized (Table.class) {\n            try {\n                rs = db.getMetaData().getColumns(getCatalog(), getSchema(), getName(), \"%\");\n                while (rs.next()) addColumn(rs);\n            } catch (SQLException exc) {\n                if (!isLogical()) {\n                    class ColumnInitializationFailure extends SQLException {\n\n                        private static final long serialVersionUID = 1L;\n\n                        public ColumnInitializationFailure(SQLException failure) {\n                            super(\"Failed to collect column details for \" + (isView() ? \"view\" : \"table\") + \" '\" + getName() + \"' in schema '\" + getContainer() + \"'\");\n                            initCause(failure);\n                        }\n                    }\n                    throw new ColumnInitializationFailure(exc);\n                }\n            } finally {\n                if (rs != null)\n                    rs.close();\n            }\n        }\n        initColumnAutoUpdate(false);\n    }\n\n    /**\n     * @param forceQuotes\n     * @throws SQLException\n     */\n    private void initColumnAutoUpdate(boolean forceQuotes) throws SQLException {\n        ResultSet rs = null;\n        PreparedStatement stmt = null;\n        if (isView() || isRemote())\n            return;\n        // we've got to get a result set with all the columns in it\n        // so we can ask if the columns are auto updated\n        // Ugh!!!  Should have been in DatabaseMetaData instead!!!\n        StringBuilder sql = new StringBuilder(\"select * from \");\n        if (getSchema() != null) {\n            sql.append(getSchema());\n            sql.append('.');\n        } else if (getCatalog() != null) {\n            sql.append(getCatalog());\n            sql.append('.');\n        }\n        if (forceQuotes) {\n            String quote = db.getMetaData().getIdentifierQuoteString().trim();\n            sql.append(quote + getName() + quote);\n        } else\n            sql.append(db.getQuotedIdentifier(getName()));\n        sql.append(\" where 0 = 1\");\n        try {\n            stmt = db.getMetaData().getConnection().prepareStatement(sql.toString());\n            rs = stmt.executeQuery();\n            ResultSetMetaData rsMeta = rs.getMetaData();\n            for (int i = rsMeta.getColumnCount(); i > 0; --i) {\n                TableColumn column = getColumn(rsMeta.getColumnName(i));\n                column.setIsAutoUpdated(rsMeta.isAutoIncrement(i));\n            }\n        } catch (SQLException exc) {\n            if (forceQuotes) {\n                if (!isLogical()) {\n                    // don't completely choke just because we couldn't do this....\n                    logger.warning(\"Failed to determine auto increment status: \" + exc);\n                    logger.warning(\"SQL: \" + sql.toString());\n                }\n            } else {\n                initColumnAutoUpdate(true);\n            }\n        } finally {\n            if (rs != null)\n                rs.close();\n            if (stmt != null)\n                stmt.close();\n        }\n    }\n\n    /**\n     * @param rs - from {@link DatabaseMetaData#getColumns(String, String, String, String)}\n     * @throws SQLException\n     */\n    protected void addColumn(ResultSet rs) throws SQLException {\n        String columnName = rs.getString(\"COLUMN_NAME\");\n        if (columnName == null)\n            return;\n        if (getColumn(columnName) == null) {\n            TableColumn column = new TableColumn(this, rs);\n            columns.put(column.getName(), column);\n        }\n    }\n\n    /**\n     * Add a column that's defined in xml metadata.\n     * Assumes that a column named colMeta.getName() doesn't already exist in <code>columns</code>.\n     * @param colMeta\n     * @return\n     */\n    protected TableColumn addColumn(TableColumnMeta colMeta) {\n        TableColumn column = new TableColumn(this, colMeta);\n        columns.put(column.getName(), column);\n        return column;\n    }\n\n    /**\n     * Initialize index information\n     *\n     * @throws SQLException\n     */\n    private void initIndexes() throws SQLException {\n        if (isView() || isRemote())\n            return;\n        // first try to initialize using the index query spec'd in the .properties\n        // do this first because some DB's (e.g. Oracle) do 'bad' things with getIndexInfo()\n        // (they try to do a DDL analyze command that has some bad side-effects)\n        if (initIndexes(Config.getInstance().getDbProperties().getProperty(\"selectIndexesSql\")))\n            return;\n        // couldn't, so try the old fashioned approach\n        ResultSet rs = null;\n        try {\n            rs = db.getMetaData().getIndexInfo(getCatalog(), getSchema(), getName(), false, true);\n            while (rs.next()) {\n                if (rs.getShort(\"TYPE\") != DatabaseMetaData.tableIndexStatistic)\n                    addIndex(rs);\n            }\n        } catch (SQLException exc) {\n            if (!isLogical())\n                logger.warning(\"Unable to extract index info for table '\" + getName() + \"' in schema '\" + getContainer() + \"': \" + exc);\n        } finally {\n            if (rs != null)\n                rs.close();\n        }\n    }\n\n    /**\n     * Try to initialize index information based on the specified SQL\n     *\n     * @return boolean <code>true</code> if it worked, otherwise <code>false</code>\n     */\n    private boolean initIndexes(String selectIndexesSql) {\n        if (selectIndexesSql == null)\n            return false;\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = db.prepareStatement(selectIndexesSql, getName());\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                if (rs.getShort(\"TYPE\") != DatabaseMetaData.tableIndexStatistic)\n                    addIndex(rs);\n            }\n        } catch (SQLException sqlException) {\n            logger.warning(\"Failed to query index information with SQL: \" + selectIndexesSql);\n            logger.warning(sqlException.toString());\n            return false;\n        } finally {\n            if (rs != null) {\n                try {\n                    rs.close();\n                } catch (Exception exc) {\n                    exc.printStackTrace();\n                }\n            }\n            if (stmt != null) {\n                try {\n                    stmt.close();\n                } catch (Exception exc) {\n                    exc.printStackTrace();\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @param indexName\n     * @return\n     */\n    public TableIndex getIndex(String indexName) {\n        return indexes.get(indexName);\n    }\n\n    /**\n     * @param rs\n     * @throws SQLException\n     */\n    private void addIndex(ResultSet rs) throws SQLException {\n        String indexName = rs.getString(\"INDEX_NAME\");\n        if (indexName == null)\n            return;\n        TableIndex index = getIndex(indexName);\n        if (index == null) {\n            index = new TableIndex(rs);\n            indexes.put(index.getName(), index);\n        }\n        index.addColumn(getColumn(rs.getString(\"COLUMN_NAME\")), rs.getString(\"ASC_OR_DESC\"));\n    }\n\n    /**\n     * Returns the catalog that the table belongs to\n     *\n     * @return\n     */\n    public String getCatalog() {\n        return catalog;\n    }\n\n    /**\n     * Returns the schema that the table belongs to\n     *\n     * @return\n     */\n    public String getSchema() {\n        return schema;\n    }\n\n    /**\n     * Returns the logical 'container' that the table\n     * lives in.  Basically it's the first non-<code>null</code>\n     * item out of <code>schema</code>, <code>catalog</code>\n     * and <code>database</code>.\n     *\n     * @return\n     */\n    public String getContainer() {\n        return container;\n    }\n\n    /**\n     * Returns the name of the table\n     *\n     * @return\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the fully-qualified name of this table\n     *\n     * @return\n     */\n    public String getFullName() {\n        return fullName;\n    }\n\n    /**\n     * Returns the fully-qualified name of a table\n     *\n     * @return\n     */\n    public static String getFullName(String db, String catalog, String schema, String table) {\n        String fullName = (catalog == null && schema == null ? db + '.' : \"\") + (catalog == null ? \"\" : catalog + '.') + (schema == null ? \"\" : schema + '.') + table;\n        return fullName;\n    }\n\n    /**\n     * Object IDs are useful for tables such as DB/2 that many times\n     * give error messages based on object ID and not name\n     *\n     * @param id\n     */\n    public void setId(Object id) {\n        this.id = id;\n    }\n\n    /**\n     * @see #setId(Object)\n     *\n     * @return\n     */\n    public Object getId() {\n        return id;\n    }\n\n    /**\n     * Returns the check constraints associated with this table\n     *\n     * @return\n     */\n    public Map<String, String> getCheckConstraints() {\n        return checkConstraints;\n    }\n\n    /**\n     * Returns the indexes that are applied to this table\n     *\n     * @return\n     */\n    public Set<TableIndex> getIndexes() {\n        return new HashSet<TableIndex>(indexes.values());\n    }\n\n    /**\n     * Returns a collection of table columns that have been identified as \"primary\"\n     *\n     * @return\n     */\n    public List<TableColumn> getPrimaryColumns() {\n        return primaryKeys;\n    }\n\n    /**\n     * @return Comments associated with this table, or <code>null</code> if none.\n     */\n    public String getComments() {\n        return comments;\n    }\n\n    /**\n     * Sets the comments that are associated with this table\n     *\n     * @param comments\n     */\n    public void setComments(String comments) {\n        String cmts = (comments == null || comments.trim().length() == 0) ? null : comments.trim();\n        // MySQL's InnoDB engine does some insane crap of storing erroneous details in\n        // with table comments.  Here I attempt to strip the \"crap\" out without impacting\n        // other databases.  Ideally this should happen in selectColumnCommentsSql (and\n        // therefore isolate it to MySQL), but it's a bit too complex to do cleanly.\n        if (cmts != null) {\n            int crapIndex = cmts.indexOf(\"; InnoDB free: \");\n            if (crapIndex == -1)\n                crapIndex = cmts.startsWith(\"InnoDB free: \") ? 0 : -1;\n            if (crapIndex != -1) {\n                cmts = cmts.substring(0, crapIndex).trim();\n                cmts = cmts.length() == 0 ? null : cmts;\n            }\n        }\n        this.comments = cmts;\n    }\n\n    /**\n     * Returns the {@link TableColumn} with the given name, or <code>null</code>\n     * if it doesn't exist\n     *\n     * @param columnName\n     * @return\n     */\n    public TableColumn getColumn(String columnName) {\n        return columns.get(columnName);\n    }\n\n    /**\n     * Returns <code>List</code> of <code>TableColumn</code>s in ascending column number order.\n     *\n     * @return\n     */\n    public List<TableColumn> getColumns() {\n        Set<TableColumn> sorted = new TreeSet<TableColumn>(new ByColumnIdComparator());\n        sorted.addAll(columns.values());\n        return new ArrayList<TableColumn>(sorted);\n    }\n\n    /**\n     * Returns <code>true</code> if this table references no other tables..<p/>\n     * Used in dependency analysis.\n     * @return\n     */\n    public boolean isRoot() {\n        for (TableColumn column : columns.values()) {\n            if (column.isForeignKey()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns <code>true</code> if this table is referenced by no other tables.<p/>\n     * Used in dependency analysis.\n     * @return\n     */\n    public boolean isLeaf() {\n        for (TableColumn column : columns.values()) {\n            if (!column.getChildren().isEmpty()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the maximum number of parents that this table has had before\n     * any had been removed during dependency analysis\n     *\n     * @return\n     */\n    public int getMaxParents() {\n        return maxParents;\n    }\n\n    /**\n     * Notification that's called to indicate that a parent has been added to\n     * this table\n     */\n    public void addedParent() {\n        maxParents++;\n    }\n\n    /**\n     * \"Unlink\" all of the parent tables from this table\n     */\n    public void unlinkParents() {\n        for (TableColumn column : columns.values()) {\n            column.unlinkParents();\n        }\n    }\n\n    /**\n     * Returns the maximum number of children that this table has had before\n     * any had been removed during dependency analysis\n     *\n     * @return\n     */\n    public int getMaxChildren() {\n        return maxChildren;\n    }\n\n    /**\n     * Notification that's called to indicate that a child has been added to\n     * this table\n     */\n    public void addedChild() {\n        maxChildren++;\n    }\n\n    /**\n     * \"Unlink\" all of the child tables from this table\n     */\n    public void unlinkChildren() {\n        for (TableColumn column : columns.values()) {\n            column.unlinkChildren();\n        }\n    }\n\n    /**\n     * Remove a single self referencing constraint if one exists.\n     *\n     * @return\n     */\n    public ForeignKeyConstraint removeSelfReferencingConstraint() {\n        return remove(getSelfReferencingConstraint());\n    }\n\n    /**\n     * Remove the specified {@link ForeignKeyConstraint} from this table.<p>\n     *\n     * This is a more drastic removal solution that was proposed by Remke Rutgers\n     *\n     * @param constraint\n     */\n    private ForeignKeyConstraint remove(ForeignKeyConstraint constraint) {\n        if (constraint != null) {\n            for (int i = 0; i < constraint.getChildColumns().size(); i++) {\n                TableColumn childColumn = constraint.getChildColumns().get(i);\n                TableColumn parentColumn = constraint.getParentColumns().get(i);\n                childColumn.removeParent(parentColumn);\n                parentColumn.removeChild(childColumn);\n            }\n        }\n        return constraint;\n    }\n\n    /**\n     * Return a self referencing constraint if one exists\n     *\n     * @return\n     */\n    private ForeignKeyConstraint getSelfReferencingConstraint() {\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                if (compareTo(parentColumn.getTable()) == 0) {\n                    return column.getParentConstraint(parentColumn);\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Remove any non-real foreign keys\n     *\n     * @return\n     */\n    public List<ForeignKeyConstraint> removeNonRealForeignKeys() {\n        List<ForeignKeyConstraint> nonReals = new ArrayList<ForeignKeyConstraint>();\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                ForeignKeyConstraint constraint = column.getParentConstraint(parentColumn);\n                if (constraint != null && !constraint.isReal()) {\n                    nonReals.add(constraint);\n                }\n            }\n        }\n        // remove constraints outside of above loop to prevent\n        // concurrent modification exceptions while iterating\n        for (ForeignKeyConstraint constraint : nonReals) {\n            remove(constraint);\n        }\n        return nonReals;\n    }\n\n    /**\n     * Returns the number of tables that reference this table\n     *\n     * @return\n     */\n    public int getNumChildren() {\n        int numChildren = 0;\n        for (TableColumn column : columns.values()) {\n            numChildren += column.getChildren().size();\n        }\n        return numChildren;\n    }\n\n    /**\n     * Returns the number of non-implied children\n     * @return\n     */\n    public int getNumNonImpliedChildren() {\n        int numChildren = 0;\n        for (TableColumn column : columns.values()) {\n            for (TableColumn childColumn : column.getChildren()) {\n                if (!column.getChildConstraint(childColumn).isImplied())\n                    ++numChildren;\n            }\n        }\n        return numChildren;\n    }\n\n    /**\n     * Returns the number of tables that are referenced by this table\n     *\n     * @return\n     */\n    public int getNumParents() {\n        int numParents = 0;\n        for (TableColumn column : columns.values()) {\n            numParents += column.getParents().size();\n        }\n        return numParents;\n    }\n\n    /**\n     * Returns the number of non-implied parents\n     *\n     * @return\n     */\n    public int getNumNonImpliedParents() {\n        int numParents = 0;\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                if (!column.getParentConstraint(parentColumn).isImplied())\n                    ++numParents;\n            }\n        }\n        return numParents;\n    }\n\n    /**\n     * Remove one foreign key constraint.\n     *\n     * <p/>Used during dependency analysis phase.\n     *\n     * @return\n     */\n    public ForeignKeyConstraint removeAForeignKeyConstraint() {\n        @SuppressWarnings(\"hiding\")\n        final List<TableColumn> columns = getColumns();\n        int numParents = 0;\n        int numChildren = 0;\n        // remove either a child or parent, choosing which based on which has the\n        // least number of foreign key associations (when either gets to zero then\n        // the table can be pruned)\n        for (TableColumn column : columns) {\n            numParents += column.getParents().size();\n            numChildren += column.getChildren().size();\n        }\n        for (TableColumn column : columns) {\n            ForeignKeyConstraint constraint;\n            if (numParents <= numChildren)\n                constraint = column.removeAParentFKConstraint();\n            else\n                constraint = column.removeAChildFKConstraint();\n            if (constraint != null)\n                return constraint;\n        }\n        return null;\n    }\n\n    /**\n     * Returns <code>true</code> if this table is logical (not physical), <code>false</code> otherwise\n     * @return\n     */\n    public boolean isLogical() {\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if this is a view, <code>false</code> otherwise\n     *\n     * @return\n     */\n    public boolean isView() {\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if this table is remote (in another schema), <code>false</code> otherwise\n     * @return\n     */\n    public boolean isRemote() {\n        return false;\n    }\n\n    /**\n     * If this is a view it returns the SQL used to create the view (if it's available).\n     * <code>null</code> if it's not a view or the SQL isn't available.\n     * @return\n     * @see #isView()\n     */\n    public String getViewSql() {\n        return null;\n    }\n\n    /**\n     * Returns the number of rows contained in this table, or -1 if unable to determine\n     * the number of rows.\n     *\n     * @return\n     */\n    public long getNumRows() {\n        if (numRows == null) {\n            numRows = Config.getInstance().isNumRowsEnabled() ? fetchNumRows() : -1;\n        }\n        return numRows;\n    }\n\n    /**\n     * Explicitly set the number of rows in this table\n     *\n     * @param numRows\n     */\n    public void setNumRows(long numRows) {\n        this.numRows = numRows;\n    }\n\n    /**\n     * Fetch the number of rows contained in this table.\n     *\n     * returns -1 if unable to successfully fetch the row count\n     *\n     * @param db Database\n     * @return int\n     * @throws SQLException\n     */\n    protected long fetchNumRows() {\n        if (isView() || isRemote())\n            return -1;\n        SQLException originalFailure = null;\n        String sql = Config.getInstance().getDbProperties().getProperty(\"selectRowCountSql\");\n        if (sql != null) {\n            PreparedStatement stmt = null;\n            ResultSet rs = null;\n            try {\n                stmt = db.prepareStatement(sql, getName());\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    return rs.getLong(\"row_count\");\n                }\n            } catch (SQLException sqlException) {\n                // don't die just because this failed\n                originalFailure = sqlException;\n            } finally {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    } catch (SQLException exc) {\n                    }\n                }\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException exc) {\n                    }\n                }\n            }\n        }\n        // if we get here then we either didn't have custom SQL or it didn't work\n        try {\n            // '*' should work best for the majority of cases\n            return fetchNumRows(\"count(*)\", false);\n        } catch (SQLException try2Exception) {\n            try {\n                // except nested tables...try using '1' instead\n                return fetchNumRows(\"count(1)\", false);\n            } catch (SQLException try3Exception) {\n                if (!isLogical()) {\n                    logger.warning(\"Unable to extract the number of rows for table \" + getName() + \", using '-1'\");\n                    if (originalFailure != null)\n                        logger.warning(originalFailure.toString());\n                    logger.warning(try2Exception.toString());\n                    if (!String.valueOf(try2Exception.toString()).equals(try3Exception.toString()))\n                        logger.warning(try3Exception.toString());\n                }\n                return -1;\n            }\n        }\n    }\n\n    protected long fetchNumRows(String clause, boolean forceQuotes) throws SQLException {\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        StringBuilder sql = new StringBuilder(\"select \");\n        sql.append(clause);\n        sql.append(\" from \");\n        if (getSchema() != null) {\n            sql.append(getSchema());\n            sql.append('.');\n        } else if (getCatalog() != null) {\n            sql.append(getCatalog());\n            sql.append('.');\n        }\n        if (forceQuotes) {\n            String quote = db.getMetaData().getIdentifierQuoteString().trim();\n            sql.append(quote + getName() + quote);\n        } else\n            sql.append(db.getQuotedIdentifier(getName()));\n        try {\n            if (finerEnabled)\n                logger.finer(sql.toString());\n            stmt = db.getConnection().prepareStatement(sql.toString());\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                return rs.getLong(1);\n            }\n            return -1;\n        } catch (SQLException exc) {\n            if (// we tried with and w/o quotes...fail this attempt\n            forceQuotes)\n                throw exc;\n            return fetchNumRows(clause, true);\n        } finally {\n            if (rs != null)\n                rs.close();\n            if (stmt != null)\n                stmt.close();\n        }\n    }\n\n    /**\n     * Update the table with the specified XML-derived metadata\n     *\n     * @param tableMeta\n     */\n    public void update(TableMeta tableMeta) {\n        String newComments = tableMeta.getComments();\n        if (newComments != null) {\n            comments = newComments;\n        }\n        for (TableColumnMeta colMeta : tableMeta.getColumns()) {\n            TableColumn col = getColumn(colMeta.getName());\n            if (col == null) {\n                col = addColumn(colMeta);\n            }\n            // update the column with the changes\n            col.update(colMeta);\n        }\n    }\n\n    /**\n     * Same as {@link #connectForeignKeys(Map, Database, Properties)},\n     * but uses XML-based metadata\n     *\n     * @param tableMeta\n     * @param tables\n     */\n    public void connect(TableMeta tableMeta, Map<String, Table> tables) {\n        for (TableColumnMeta colMeta : tableMeta.getColumns()) {\n            TableColumn col = getColumn(colMeta.getName());\n            if (col != null) {\n                // go thru the new foreign key defs and associate them with our columns\n                for (ForeignKeyMeta fk : colMeta.getForeignKeys()) {\n                    Table parent;\n                    if (fk.getRemoteCatalog() != null || fk.getRemoteSchema() != null) {\n                        try {\n                            // adds if doesn't exist\n                            parent = db.addRemoteTable(fk.getRemoteCatalog(), fk.getRemoteSchema(), fk.getTableName(), getContainer(), true);\n                        } catch (SQLException exc) {\n                            parent = null;\n                        }\n                    } else {\n                        parent = tables.get(fk.getTableName());\n                    }\n                    if (parent != null) {\n                        TableColumn parentColumn = parent.getColumn(fk.getColumnName());\n                        if (parentColumn == null) {\n                            logger.warning(\"Undefined column '\" + parent.getName() + '.' + fk.getColumnName() + \"' referenced by '\" + col.getTable() + '.' + col + \"' in XML metadata\");\n                        } else {\n                            /**\n                             * Merely instantiating a foreign key constraint ties it\n                             * into its parent and child columns (& therefore their tables)\n                             */\n                            @SuppressWarnings(\"unused\")\n                            ForeignKeyConstraint unused = new ForeignKeyConstraint(parentColumn, col) {\n\n                                @Override\n                                public String getName() {\n                                    return \"Defined in XML\";\n                                }\n                            };\n                            // they forgot to say it was a primary key\n                            if (!parentColumn.isPrimary()) {\n                                logger.warning(\"Assuming \" + parentColumn.getTable() + '.' + parentColumn + \" is a primary key due to being referenced by \" + col.getTable() + '.' + col);\n                                parent.setPrimaryColumn(parentColumn);\n                            }\n                        }\n                    } else {\n                        logger.warning(\"Undefined table '\" + fk.getTableName() + \"' referenced by '\" + getName() + '.' + col.getName() + \"' in XML metadata\");\n                    }\n                }\n            } else {\n                logger.warning(\"Undefined column '\" + getName() + '.' + colMeta.getName() + \"' in XML metadata\");\n            }\n        }\n    }\n\n    @Override\n    public String toString() {\n        return getName();\n    }\n\n    /**\n     * Returns <code>true</code> if this table has no relationships\n     *\n     * @param withImpliedRelationships boolean\n     * @return boolean\n     */\n    public boolean isOrphan(boolean withImpliedRelationships) {\n        if (withImpliedRelationships)\n            return getMaxParents() == 0 && getMaxChildren() == 0;\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                if (!column.getParentConstraint(parentColumn).isImplied())\n                    return false;\n            }\n            for (TableColumn childColumn : column.getChildren()) {\n                if (!column.getChildConstraint(childColumn).isImplied())\n                    return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compare this table to another table.\n     * Results are based on 1: identity, 2: table name, 3: schema name<p/>\n     *\n     * This implementation was put in place to deal with analyzing multiple\n     * schemas that contain identically named tables.\n     *\n     * @see {@link Comparable#compareTo(Object)}\n     */\n    public int compareTo(Table other) {\n        if (// fast way out\n        other == this)\n            return 0;\n        return getFullName().compareToIgnoreCase(other.getFullName());\n    }\n\n    /**\n     * Implementation of {@link Comparator} that sorts {@link TableColumn}s\n     * by {@link TableColumn#getId() ID} (ignored if <code>null</code>)\n     * followed by {@link TableColumn#getName() Name}.\n     */\n    public static class ByColumnIdComparator implements Comparator<TableColumn> {\n\n        public int compare(TableColumn column1, TableColumn column2) {\n            Object id1 = column1.getId();\n            Object id2 = column2.getId();\n            if (id1 == null || id2 == null)\n                return column1.getName().compareToIgnoreCase(column2.getName());\n            if (id1 instanceof Number && id2 instanceof Number)\n                return ((Number) id1).intValue() - ((Number) id2).intValue();\n            return id1.toString().compareToIgnoreCase(id2.toString());\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableTest2.java",
		"test_prompt": "// TableTest2.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\nimport net.sourceforge.schemaspy.model.xml.TableMeta;\nimport net.sourceforge.schemaspy.util.CaseInsensitiveMap;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Table}.\n* It contains ten unit test cases for the {@link Table#isLeaf()} method.\n*/\nclass TableTest2 {"
	},
	{
		"original_code": "// Table.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\nimport net.sourceforge.schemaspy.model.xml.TableMeta;\nimport net.sourceforge.schemaspy.util.CaseInsensitiveMap;\n\n/**\n * A <code>Table</code> is one of the basic building blocks of SchemaSpy\n * that knows everything about the database table's metadata.\n *\n * @author John Currier\n */\npublic class Table implements Comparable<Table> {\n\n    private final String catalog;\n\n    private final String schema;\n\n    private final String name;\n\n    private final String fullName;\n\n    private final String container;\n\n    protected final CaseInsensitiveMap<TableColumn> columns = new CaseInsensitiveMap<TableColumn>();\n\n    private final List<TableColumn> primaryKeys = new ArrayList<TableColumn>();\n\n    private final CaseInsensitiveMap<ForeignKeyConstraint> foreignKeys = new CaseInsensitiveMap<ForeignKeyConstraint>();\n\n    private final CaseInsensitiveMap<TableIndex> indexes = new CaseInsensitiveMap<TableIndex>();\n\n    private Object id;\n\n    private final Map<String, String> checkConstraints = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);\n\n    private Long numRows;\n\n    protected final Database db;\n\n    private String comments;\n\n    private int maxChildren;\n\n    private int maxParents;\n\n    private final static Logger logger = Logger.getLogger(Table.class.getName());\n\n    private final static boolean fineEnabled = logger.isLoggable(Level.FINE);\n\n    private final static boolean finerEnabled = logger.isLoggable(Level.FINER);\n\n    /**\n     * Construct a table that knows everything about the database table's metadata\n     *\n     * @param db\n     * @param catalog\n     * @param schema\n     * @param name\n     * @param comments\n     * @throws SQLException\n     */\n    public Table(Database db, String catalog, String schema, String name, String comments) throws SQLException {\n        this.db = db;\n        this.catalog = catalog;\n        this.schema = schema;\n        this.container = schema != null ? schema : catalog != null ? catalog : db.getName();\n        this.name = name;\n        this.fullName = getFullName(db.getName(), catalog, schema, name);\n        if (fineEnabled)\n            logger.fine(\"Creating \" + getClass().getSimpleName() + \" \" + fullName);\n        setComments(comments);\n        initColumns();\n        initIndexes();\n        initPrimaryKeys();\n    }\n\n    /**\n     * \"Connect\" all of this table's foreign keys to their referenced primary keys\n     * (and, in some cases, do the reverse as well).\n     *\n     * @param tables\n     * @throws SQLException\n     */\n    public void connectForeignKeys(Map<String, Table> tables) throws SQLException {\n        if (finerEnabled)\n            logger.finer(\"Connecting foreign keys to \" + getFullName());\n        ResultSet rs = null;\n        try {\n            // get our foreign keys that reference other tables' primary keys\n            rs = db.getMetaData().getImportedKeys(getCatalog(), getSchema(), getName());\n            while (rs.next()) {\n                addForeignKey(rs.getString(\"FK_NAME\"), rs.getString(\"FKCOLUMN_NAME\"), rs.getString(\"PKTABLE_CAT\"), rs.getString(\"PKTABLE_SCHEM\"), rs.getString(\"PKTABLE_NAME\"), rs.getString(\"PKCOLUMN_NAME\"), rs.getInt(\"UPDATE_RULE\"), rs.getInt(\"DELETE_RULE\"), tables);\n            }\n        } finally {\n            if (rs != null)\n                rs.close();\n        }\n        // also try to find all of the 'remote' tables in other schemas that\n        // point to our primary keys (not necessary in the normal case\n        // as we infer this from the opposite direction)\n        if (getSchema() != null || getCatalog() != null) {\n            try {\n                // get the foreign keys that reference our primary keys\n                rs = db.getMetaData().getExportedKeys(getCatalog(), getSchema(), getName());\n                while (rs.next()) {\n                    String otherCatalog = rs.getString(\"FKTABLE_CAT\");\n                    String otherSchema = rs.getString(\"FKTABLE_SCHEM\");\n                    if (!String.valueOf(getSchema()).equals(String.valueOf(otherSchema)) || !String.valueOf(getCatalog()).equals(String.valueOf(otherCatalog))) {\n                        db.addRemoteTable(otherCatalog, otherSchema, rs.getString(\"FKTABLE_NAME\"), getSchema(), false);\n                    }\n                }\n            } finally {\n                if (rs != null)\n                    rs.close();\n            }\n        }\n    }\n\n    /**\n     * Get the foreign keys associated with this table\n     *\n     * @return\n     */\n    public Collection<ForeignKeyConstraint> getForeignKeys() {\n        return Collections.unmodifiableCollection(foreignKeys.values());\n    }\n\n    /**\n     * Add a check constraint to the table\n     * (no real details, just name and textual representation)\n     *\n     * @param constraintName\n     * @param text\n     */\n    public void addCheckConstraint(String constraintName, String text) {\n        checkConstraints.put(constraintName, text);\n    }\n\n    /**\n     * @param rs ResultSet from {@link DatabaseMetaData#getImportedKeys(String, String, String)}\n     * rs.getString(\"FK_NAME\");\n     * rs.getString(\"FKCOLUMN_NAME\");\n     * rs.getString(\"PKTABLE_CAT\");\n     * rs.getString(\"PKTABLE_SCHEM\");\n     * rs.getString(\"PKTABLE_NAME\");\n     * rs.getString(\"PKCOLUMN_NAME\");\n     * @param tables Map\n     * @param db\n     * @throws SQLException\n     */\n    protected void addForeignKey(String fkName, String fkColName, String pkCatalog, String pkSchema, String pkTableName, String pkColName, int updateRule, int deleteRule, Map<String, Table> tables) throws SQLException {\n        if (fkName == null)\n            return;\n        Pattern include = Config.getInstance().getTableInclusions();\n        Pattern exclude = Config.getInstance().getTableExclusions();\n        if (!include.matcher(pkTableName).matches() || exclude.matcher(pkTableName).matches()) {\n            if (fineEnabled)\n                logger.fine(\"Ignoring \" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName) + \" referenced by FK \" + fkName);\n            return;\n        }\n        ForeignKeyConstraint foreignKey = foreignKeys.get(fkName);\n        if (foreignKey == null) {\n            foreignKey = new ForeignKeyConstraint(this, fkName, updateRule, deleteRule);\n            foreignKeys.put(fkName, foreignKey);\n        }\n        TableColumn childColumn = getColumn(fkColName);\n        if (childColumn != null) {\n            foreignKey.addChildColumn(childColumn);\n            Config config = Config.getInstance();\n            Table parentTable = tables.get(pkTableName);\n            String parentContainer = pkSchema != null ? pkSchema : pkCatalog != null ? pkCatalog : db.getName();\n            String baseContainer = config.getSchema() != null ? config.getSchema() : config.getCatalog() != null ? config.getCatalog() : db.getName();\n            // if named table doesn't exist in this schema\n            // or exists here but really referencing same named table in another schema\n            if (parentTable == null || !baseContainer.equals(parentContainer)) {\n                if (fineEnabled)\n                    logger.fine(\"Adding remote table \" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName));\n                parentTable = db.addRemoteTable(pkCatalog, pkSchema, pkTableName, baseContainer, false);\n            }\n            if (parentTable != null) {\n                TableColumn parentColumn = parentTable.getColumn(pkColName);\n                if (parentColumn != null) {\n                    foreignKey.addParentColumn(parentColumn);\n                    childColumn.addParent(parentColumn, foreignKey);\n                    parentColumn.addChild(childColumn, foreignKey);\n                } else {\n                    logger.warning(\"Couldn't add FK '\" + foreignKey.getName() + \"' to table '\" + this + \"' - Column '\" + pkColName + \"' doesn't exist in table '\" + parentTable + \"'\");\n                }\n            } else {\n                logger.warning(\"Couldn't add FK '\" + foreignKey.getName() + \"' to table '\" + this + \"' - Unknown Referenced Table '\" + pkTableName + \"'\");\n            }\n        } else {\n            logger.warning(\"Couldn't add FK '\" + foreignKey.getName() + \"' to table '\" + this + \"' - Column '\" + fkColName + \"' doesn't exist\");\n        }\n    }\n\n    /**\n     * @param meta\n     * @throws SQLException\n     */\n    private void initPrimaryKeys() throws SQLException {\n        ResultSet rs = null;\n        try {\n            if (fineEnabled)\n                logger.fine(\"Querying primary keys for \" + getFullName());\n            rs = db.getMetaData().getPrimaryKeys(getCatalog(), getSchema(), getName());\n            while (rs.next()) setPrimaryColumn(rs);\n        } catch (SQLException exc) {\n            if (!isLogical()) {\n                throw exc;\n            }\n        } finally {\n            if (rs != null)\n                rs.close();\n        }\n    }\n\n    /**\n     * @param rs\n     * @throws SQLException\n     */\n    private void setPrimaryColumn(ResultSet rs) throws SQLException {\n        String pkName = rs.getString(\"PK_NAME\");\n        if (pkName == null)\n            return;\n        TableIndex index = getIndex(pkName);\n        if (index != null) {\n            index.setIsPrimaryKey(true);\n        }\n        String columnName = rs.getString(\"COLUMN_NAME\");\n        setPrimaryColumn(getColumn(columnName));\n    }\n\n    /**\n     * @param primaryColumn\n     */\n    void setPrimaryColumn(TableColumn primaryColumn) {\n        primaryKeys.add(primaryColumn);\n    }\n\n    /**\n     * @throws SQLException\n     */\n    private void initColumns() throws SQLException {\n        ResultSet rs = null;\n        synchronized (Table.class) {\n            try {\n                rs = db.getMetaData().getColumns(getCatalog(), getSchema(), getName(), \"%\");\n                while (rs.next()) addColumn(rs);\n            } catch (SQLException exc) {\n                if (!isLogical()) {\n                    class ColumnInitializationFailure extends SQLException {\n\n                        private static final long serialVersionUID = 1L;\n\n                        public ColumnInitializationFailure(SQLException failure) {\n                            super(\"Failed to collect column details for \" + (isView() ? \"view\" : \"table\") + \" '\" + getName() + \"' in schema '\" + getContainer() + \"'\");\n                            initCause(failure);\n                        }\n                    }\n                    throw new ColumnInitializationFailure(exc);\n                }\n            } finally {\n                if (rs != null)\n                    rs.close();\n            }\n        }\n        initColumnAutoUpdate(false);\n    }\n\n    /**\n     * @param forceQuotes\n     * @throws SQLException\n     */\n    private void initColumnAutoUpdate(boolean forceQuotes) throws SQLException {\n        ResultSet rs = null;\n        PreparedStatement stmt = null;\n        if (isView() || isRemote())\n            return;\n        // we've got to get a result set with all the columns in it\n        // so we can ask if the columns are auto updated\n        // Ugh!!!  Should have been in DatabaseMetaData instead!!!\n        StringBuilder sql = new StringBuilder(\"select * from \");\n        if (getSchema() != null) {\n            sql.append(getSchema());\n            sql.append('.');\n        } else if (getCatalog() != null) {\n            sql.append(getCatalog());\n            sql.append('.');\n        }\n        if (forceQuotes) {\n            String quote = db.getMetaData().getIdentifierQuoteString().trim();\n            sql.append(quote + getName() + quote);\n        } else\n            sql.append(db.getQuotedIdentifier(getName()));\n        sql.append(\" where 0 = 1\");\n        try {\n            stmt = db.getMetaData().getConnection().prepareStatement(sql.toString());\n            rs = stmt.executeQuery();\n            ResultSetMetaData rsMeta = rs.getMetaData();\n            for (int i = rsMeta.getColumnCount(); i > 0; --i) {\n                TableColumn column = getColumn(rsMeta.getColumnName(i));\n                column.setIsAutoUpdated(rsMeta.isAutoIncrement(i));\n            }\n        } catch (SQLException exc) {\n            if (forceQuotes) {\n                if (!isLogical()) {\n                    // don't completely choke just because we couldn't do this....\n                    logger.warning(\"Failed to determine auto increment status: \" + exc);\n                    logger.warning(\"SQL: \" + sql.toString());\n                }\n            } else {\n                initColumnAutoUpdate(true);\n            }\n        } finally {\n            if (rs != null)\n                rs.close();\n            if (stmt != null)\n                stmt.close();\n        }\n    }\n\n    /**\n     * @param rs - from {@link DatabaseMetaData#getColumns(String, String, String, String)}\n     * @throws SQLException\n     */\n    protected void addColumn(ResultSet rs) throws SQLException {\n        String columnName = rs.getString(\"COLUMN_NAME\");\n        if (columnName == null)\n            return;\n        if (getColumn(columnName) == null) {\n            TableColumn column = new TableColumn(this, rs);\n            columns.put(column.getName(), column);\n        }\n    }\n\n    /**\n     * Add a column that's defined in xml metadata.\n     * Assumes that a column named colMeta.getName() doesn't already exist in <code>columns</code>.\n     * @param colMeta\n     * @return\n     */\n    protected TableColumn addColumn(TableColumnMeta colMeta) {\n        TableColumn column = new TableColumn(this, colMeta);\n        columns.put(column.getName(), column);\n        return column;\n    }\n\n    /**\n     * Initialize index information\n     *\n     * @throws SQLException\n     */\n    private void initIndexes() throws SQLException {\n        if (isView() || isRemote())\n            return;\n        // first try to initialize using the index query spec'd in the .properties\n        // do this first because some DB's (e.g. Oracle) do 'bad' things with getIndexInfo()\n        // (they try to do a DDL analyze command that has some bad side-effects)\n        if (initIndexes(Config.getInstance().getDbProperties().getProperty(\"selectIndexesSql\")))\n            return;\n        // couldn't, so try the old fashioned approach\n        ResultSet rs = null;\n        try {\n            rs = db.getMetaData().getIndexInfo(getCatalog(), getSchema(), getName(), false, true);\n            while (rs.next()) {\n                if (rs.getShort(\"TYPE\") != DatabaseMetaData.tableIndexStatistic)\n                    addIndex(rs);\n            }\n        } catch (SQLException exc) {\n            if (!isLogical())\n                logger.warning(\"Unable to extract index info for table '\" + getName() + \"' in schema '\" + getContainer() + \"': \" + exc);\n        } finally {\n            if (rs != null)\n                rs.close();\n        }\n    }\n\n    /**\n     * Try to initialize index information based on the specified SQL\n     *\n     * @return boolean <code>true</code> if it worked, otherwise <code>false</code>\n     */\n    private boolean initIndexes(String selectIndexesSql) {\n        if (selectIndexesSql == null)\n            return false;\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = db.prepareStatement(selectIndexesSql, getName());\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                if (rs.getShort(\"TYPE\") != DatabaseMetaData.tableIndexStatistic)\n                    addIndex(rs);\n            }\n        } catch (SQLException sqlException) {\n            logger.warning(\"Failed to query index information with SQL: \" + selectIndexesSql);\n            logger.warning(sqlException.toString());\n            return false;\n        } finally {\n            if (rs != null) {\n                try {\n                    rs.close();\n                } catch (Exception exc) {\n                    exc.printStackTrace();\n                }\n            }\n            if (stmt != null) {\n                try {\n                    stmt.close();\n                } catch (Exception exc) {\n                    exc.printStackTrace();\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @param indexName\n     * @return\n     */\n    public TableIndex getIndex(String indexName) {\n        return indexes.get(indexName);\n    }\n\n    /**\n     * @param rs\n     * @throws SQLException\n     */\n    private void addIndex(ResultSet rs) throws SQLException {\n        String indexName = rs.getString(\"INDEX_NAME\");\n        if (indexName == null)\n            return;\n        TableIndex index = getIndex(indexName);\n        if (index == null) {\n            index = new TableIndex(rs);\n            indexes.put(index.getName(), index);\n        }\n        index.addColumn(getColumn(rs.getString(\"COLUMN_NAME\")), rs.getString(\"ASC_OR_DESC\"));\n    }\n\n    /**\n     * Returns the catalog that the table belongs to\n     *\n     * @return\n     */\n    public String getCatalog() {\n        return catalog;\n    }\n\n    /**\n     * Returns the schema that the table belongs to\n     *\n     * @return\n     */\n    public String getSchema() {\n        return schema;\n    }\n\n    /**\n     * Returns the logical 'container' that the table\n     * lives in.  Basically it's the first non-<code>null</code>\n     * item out of <code>schema</code>, <code>catalog</code>\n     * and <code>database</code>.\n     *\n     * @return\n     */\n    public String getContainer() {\n        return container;\n    }\n\n    /**\n     * Returns the name of the table\n     *\n     * @return\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the fully-qualified name of this table\n     *\n     * @return\n     */\n    public String getFullName() {\n        return fullName;\n    }\n\n    /**\n     * Returns the fully-qualified name of a table\n     *\n     * @return\n     */\n    public static String getFullName(String db, String catalog, String schema, String table) {\n        String fullName = (catalog == null && schema == null ? db + '.' : \"\") + (catalog == null ? \"\" : catalog + '.') + (schema == null ? \"\" : schema + '.') + table;\n        return fullName;\n    }\n\n    /**\n     * Object IDs are useful for tables such as DB/2 that many times\n     * give error messages based on object ID and not name\n     *\n     * @param id\n     */\n    public void setId(Object id) {\n        this.id = id;\n    }\n\n    /**\n     * @see #setId(Object)\n     *\n     * @return\n     */\n    public Object getId() {\n        return id;\n    }\n\n    /**\n     * Returns the check constraints associated with this table\n     *\n     * @return\n     */\n    public Map<String, String> getCheckConstraints() {\n        return checkConstraints;\n    }\n\n    /**\n     * Returns the indexes that are applied to this table\n     *\n     * @return\n     */\n    public Set<TableIndex> getIndexes() {\n        return new HashSet<TableIndex>(indexes.values());\n    }\n\n    /**\n     * Returns a collection of table columns that have been identified as \"primary\"\n     *\n     * @return\n     */\n    public List<TableColumn> getPrimaryColumns() {\n        return primaryKeys;\n    }\n\n    /**\n     * @return Comments associated with this table, or <code>null</code> if none.\n     */\n    public String getComments() {\n        return comments;\n    }\n\n    /**\n     * Sets the comments that are associated with this table\n     *\n     * @param comments\n     */\n    public void setComments(String comments) {\n        String cmts = (comments == null || comments.trim().length() == 0) ? null : comments.trim();\n        // MySQL's InnoDB engine does some insane crap of storing erroneous details in\n        // with table comments.  Here I attempt to strip the \"crap\" out without impacting\n        // other databases.  Ideally this should happen in selectColumnCommentsSql (and\n        // therefore isolate it to MySQL), but it's a bit too complex to do cleanly.\n        if (cmts != null) {\n            int crapIndex = cmts.indexOf(\"; InnoDB free: \");\n            if (crapIndex == -1)\n                crapIndex = cmts.startsWith(\"InnoDB free: \") ? 0 : -1;\n            if (crapIndex != -1) {\n                cmts = cmts.substring(0, crapIndex).trim();\n                cmts = cmts.length() == 0 ? null : cmts;\n            }\n        }\n        this.comments = cmts;\n    }\n\n    /**\n     * Returns the {@link TableColumn} with the given name, or <code>null</code>\n     * if it doesn't exist\n     *\n     * @param columnName\n     * @return\n     */\n    public TableColumn getColumn(String columnName) {\n        return columns.get(columnName);\n    }\n\n    /**\n     * Returns <code>List</code> of <code>TableColumn</code>s in ascending column number order.\n     *\n     * @return\n     */\n    public List<TableColumn> getColumns() {\n        Set<TableColumn> sorted = new TreeSet<TableColumn>(new ByColumnIdComparator());\n        sorted.addAll(columns.values());\n        return new ArrayList<TableColumn>(sorted);\n    }\n\n    /**\n     * Returns <code>true</code> if this table references no other tables..<p/>\n     * Used in dependency analysis.\n     * @return\n     */\n    public boolean isRoot() {\n        for (TableColumn column : columns.values()) {\n            if (column.isForeignKey()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns <code>true</code> if this table is referenced by no other tables.<p/>\n     * Used in dependency analysis.\n     * @return\n     */\n    public boolean isLeaf() {\n        for (TableColumn column : columns.values()) {\n            if (!column.getChildren().isEmpty()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the maximum number of parents that this table has had before\n     * any had been removed during dependency analysis\n     *\n     * @return\n     */\n    public int getMaxParents() {\n        return maxParents;\n    }\n\n    /**\n     * Notification that's called to indicate that a parent has been added to\n     * this table\n     */\n    public void addedParent() {\n        maxParents++;\n    }\n\n    /**\n     * \"Unlink\" all of the parent tables from this table\n     */\n    public void unlinkParents() {\n        for (TableColumn column : columns.values()) {\n            column.unlinkParents();\n        }\n    }\n\n    /**\n     * Returns the maximum number of children that this table has had before\n     * any had been removed during dependency analysis\n     *\n     * @return\n     */\n    public int getMaxChildren() {\n        return maxChildren;\n    }\n\n    /**\n     * Notification that's called to indicate that a child has been added to\n     * this table\n     */\n    public void addedChild() {\n        maxChildren++;\n    }\n\n    /**\n     * \"Unlink\" all of the child tables from this table\n     */\n    public void unlinkChildren() {\n        for (TableColumn column : columns.values()) {\n            column.unlinkChildren();\n        }\n    }\n\n    /**\n     * Remove a single self referencing constraint if one exists.\n     *\n     * @return\n     */\n    public ForeignKeyConstraint removeSelfReferencingConstraint() {\n        return remove(getSelfReferencingConstraint());\n    }\n\n    /**\n     * Remove the specified {@link ForeignKeyConstraint} from this table.<p>\n     *\n     * This is a more drastic removal solution that was proposed by Remke Rutgers\n     *\n     * @param constraint\n     */\n    private ForeignKeyConstraint remove(ForeignKeyConstraint constraint) {\n        if (constraint != null) {\n            for (int i = 0; i < constraint.getChildColumns().size(); i++) {\n                TableColumn childColumn = constraint.getChildColumns().get(i);\n                TableColumn parentColumn = constraint.getParentColumns().get(i);\n                childColumn.removeParent(parentColumn);\n                parentColumn.removeChild(childColumn);\n            }\n        }\n        return constraint;\n    }\n\n    /**\n     * Return a self referencing constraint if one exists\n     *\n     * @return\n     */\n    private ForeignKeyConstraint getSelfReferencingConstraint() {\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                if (compareTo(parentColumn.getTable()) == 0) {\n                    return column.getParentConstraint(parentColumn);\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Remove any non-real foreign keys\n     *\n     * @return\n     */\n    public List<ForeignKeyConstraint> removeNonRealForeignKeys() {\n        List<ForeignKeyConstraint> nonReals = new ArrayList<ForeignKeyConstraint>();\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                ForeignKeyConstraint constraint = column.getParentConstraint(parentColumn);\n                if (constraint != null && !constraint.isReal()) {\n                    nonReals.add(constraint);\n                }\n            }\n        }\n        // remove constraints outside of above loop to prevent\n        // concurrent modification exceptions while iterating\n        for (ForeignKeyConstraint constraint : nonReals) {\n            remove(constraint);\n        }\n        return nonReals;\n    }\n\n    /**\n     * Returns the number of tables that reference this table\n     *\n     * @return\n     */\n    public int getNumChildren() {\n        int numChildren = 0;\n        for (TableColumn column : columns.values()) {\n            numChildren += column.getChildren().size();\n        }\n        return numChildren;\n    }\n\n    /**\n     * Returns the number of non-implied children\n     * @return\n     */\n    public int getNumNonImpliedChildren() {\n        int numChildren = 0;\n        for (TableColumn column : columns.values()) {\n            for (TableColumn childColumn : column.getChildren()) {\n                if (!column.getChildConstraint(childColumn).isImplied())\n                    ++numChildren;\n            }\n        }\n        return numChildren;\n    }\n\n    /**\n     * Returns the number of tables that are referenced by this table\n     *\n     * @return\n     */\n    public int getNumParents() {\n        int numParents = 0;\n        for (TableColumn column : columns.values()) {\n            numParents += column.getParents().size();\n        }\n        return numParents;\n    }\n\n    /**\n     * Returns the number of non-implied parents\n     *\n     * @return\n     */\n    public int getNumNonImpliedParents() {\n        int numParents = 0;\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                if (!column.getParentConstraint(parentColumn).isImplied())\n                    ++numParents;\n            }\n        }\n        return numParents;\n    }\n\n    /**\n     * Remove one foreign key constraint.\n     *\n     * <p/>Used during dependency analysis phase.\n     *\n     * @return\n     */\n    public ForeignKeyConstraint removeAForeignKeyConstraint() {\n        @SuppressWarnings(\"hiding\")\n        final List<TableColumn> columns = getColumns();\n        int numParents = 0;\n        int numChildren = 0;\n        // remove either a child or parent, choosing which based on which has the\n        // least number of foreign key associations (when either gets to zero then\n        // the table can be pruned)\n        for (TableColumn column : columns) {\n            numParents += column.getParents().size();\n            numChildren += column.getChildren().size();\n        }\n        for (TableColumn column : columns) {\n            ForeignKeyConstraint constraint;\n            if (numParents <= numChildren)\n                constraint = column.removeAParentFKConstraint();\n            else\n                constraint = column.removeAChildFKConstraint();\n            if (constraint != null)\n                return constraint;\n        }\n        return null;\n    }\n\n    /**\n     * Returns <code>true</code> if this table is logical (not physical), <code>false</code> otherwise\n     * @return\n     */\n    public boolean isLogical() {\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if this is a view, <code>false</code> otherwise\n     *\n     * @return\n     */\n    public boolean isView() {\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if this table is remote (in another schema), <code>false</code> otherwise\n     * @return\n     */\n    public boolean isRemote() {\n        return false;\n    }\n\n    /**\n     * If this is a view it returns the SQL used to create the view (if it's available).\n     * <code>null</code> if it's not a view or the SQL isn't available.\n     * @return\n     * @see #isView()\n     */\n    public String getViewSql() {\n        return null;\n    }\n\n    /**\n     * Returns the number of rows contained in this table, or -1 if unable to determine\n     * the number of rows.\n     *\n     * @return\n     */\n    public long getNumRows() {\n        if (numRows == null) {\n            numRows = Config.getInstance().isNumRowsEnabled() ? fetchNumRows() : -1;\n        }\n        return numRows;\n    }\n\n    /**\n     * Explicitly set the number of rows in this table\n     *\n     * @param numRows\n     */\n    public void setNumRows(long numRows) {\n        this.numRows = numRows;\n    }\n\n    /**\n     * Fetch the number of rows contained in this table.\n     *\n     * returns -1 if unable to successfully fetch the row count\n     *\n     * @param db Database\n     * @return int\n     * @throws SQLException\n     */\n    protected long fetchNumRows() {\n        if (isView() || isRemote())\n            return -1;\n        SQLException originalFailure = null;\n        String sql = Config.getInstance().getDbProperties().getProperty(\"selectRowCountSql\");\n        if (sql != null) {\n            PreparedStatement stmt = null;\n            ResultSet rs = null;\n            try {\n                stmt = db.prepareStatement(sql, getName());\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    return rs.getLong(\"row_count\");\n                }\n            } catch (SQLException sqlException) {\n                // don't die just because this failed\n                originalFailure = sqlException;\n            } finally {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    } catch (SQLException exc) {\n                    }\n                }\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException exc) {\n                    }\n                }\n            }\n        }\n        // if we get here then we either didn't have custom SQL or it didn't work\n        try {\n            // '*' should work best for the majority of cases\n            return fetchNumRows(\"count(*)\", false);\n        } catch (SQLException try2Exception) {\n            try {\n                // except nested tables...try using '1' instead\n                return fetchNumRows(\"count(1)\", false);\n            } catch (SQLException try3Exception) {\n                if (!isLogical()) {\n                    logger.warning(\"Unable to extract the number of rows for table \" + getName() + \", using '-1'\");\n                    if (originalFailure != null)\n                        logger.warning(originalFailure.toString());\n                    logger.warning(try2Exception.toString());\n                    if (!String.valueOf(try2Exception.toString()).equals(try3Exception.toString()))\n                        logger.warning(try3Exception.toString());\n                }\n                return -1;\n            }\n        }\n    }\n\n    protected long fetchNumRows(String clause, boolean forceQuotes) throws SQLException {\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        StringBuilder sql = new StringBuilder(\"select \");\n        sql.append(clause);\n        sql.append(\" from \");\n        if (getSchema() != null) {\n            sql.append(getSchema());\n            sql.append('.');\n        } else if (getCatalog() != null) {\n            sql.append(getCatalog());\n            sql.append('.');\n        }\n        if (forceQuotes) {\n            String quote = db.getMetaData().getIdentifierQuoteString().trim();\n            sql.append(quote + getName() + quote);\n        } else\n            sql.append(db.getQuotedIdentifier(getName()));\n        try {\n            if (finerEnabled)\n                logger.finer(sql.toString());\n            stmt = db.getConnection().prepareStatement(sql.toString());\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                return rs.getLong(1);\n            }\n            return -1;\n        } catch (SQLException exc) {\n            if (// we tried with and w/o quotes...fail this attempt\n            forceQuotes)\n                throw exc;\n            return fetchNumRows(clause, true);\n        } finally {\n            if (rs != null)\n                rs.close();\n            if (stmt != null)\n                stmt.close();\n        }\n    }\n\n    /**\n     * Update the table with the specified XML-derived metadata\n     *\n     * @param tableMeta\n     */\n    public void update(TableMeta tableMeta) {\n        String newComments = tableMeta.getComments();\n        if (newComments != null) {\n            comments = newComments;\n        }\n        for (TableColumnMeta colMeta : tableMeta.getColumns()) {\n            TableColumn col = getColumn(colMeta.getName());\n            if (col == null) {\n                col = addColumn(colMeta);\n            }\n            // update the column with the changes\n            col.update(colMeta);\n        }\n    }\n\n    /**\n     * Same as {@link #connectForeignKeys(Map, Database, Properties)},\n     * but uses XML-based metadata\n     *\n     * @param tableMeta\n     * @param tables\n     */\n    public void connect(TableMeta tableMeta, Map<String, Table> tables) {\n        for (TableColumnMeta colMeta : tableMeta.getColumns()) {\n            TableColumn col = getColumn(colMeta.getName());\n            if (col != null) {\n                // go thru the new foreign key defs and associate them with our columns\n                for (ForeignKeyMeta fk : colMeta.getForeignKeys()) {\n                    Table parent;\n                    if (fk.getRemoteCatalog() != null || fk.getRemoteSchema() != null) {\n                        try {\n                            // adds if doesn't exist\n                            parent = db.addRemoteTable(fk.getRemoteCatalog(), fk.getRemoteSchema(), fk.getTableName(), getContainer(), true);\n                        } catch (SQLException exc) {\n                            parent = null;\n                        }\n                    } else {\n                        parent = tables.get(fk.getTableName());\n                    }\n                    if (parent != null) {\n                        TableColumn parentColumn = parent.getColumn(fk.getColumnName());\n                        if (parentColumn == null) {\n                            logger.warning(\"Undefined column '\" + parent.getName() + '.' + fk.getColumnName() + \"' referenced by '\" + col.getTable() + '.' + col + \"' in XML metadata\");\n                        } else {\n                            /**\n                             * Merely instantiating a foreign key constraint ties it\n                             * into its parent and child columns (& therefore their tables)\n                             */\n                            @SuppressWarnings(\"unused\")\n                            ForeignKeyConstraint unused = new ForeignKeyConstraint(parentColumn, col) {\n\n                                @Override\n                                public String getName() {\n                                    return \"Defined in XML\";\n                                }\n                            };\n                            // they forgot to say it was a primary key\n                            if (!parentColumn.isPrimary()) {\n                                logger.warning(\"Assuming \" + parentColumn.getTable() + '.' + parentColumn + \" is a primary key due to being referenced by \" + col.getTable() + '.' + col);\n                                parent.setPrimaryColumn(parentColumn);\n                            }\n                        }\n                    } else {\n                        logger.warning(\"Undefined table '\" + fk.getTableName() + \"' referenced by '\" + getName() + '.' + col.getName() + \"' in XML metadata\");\n                    }\n                }\n            } else {\n                logger.warning(\"Undefined column '\" + getName() + '.' + colMeta.getName() + \"' in XML metadata\");\n            }\n        }\n    }\n\n    @Override\n    public String toString() {\n        return getName();\n    }\n\n    /**\n     * Returns <code>true</code> if this table has no relationships\n     *\n     * @param withImpliedRelationships boolean\n     * @return boolean\n     */\n    public boolean isOrphan(boolean withImpliedRelationships) {\n        if (withImpliedRelationships)\n            return getMaxParents() == 0 && getMaxChildren() == 0;\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                if (!column.getParentConstraint(parentColumn).isImplied())\n                    return false;\n            }\n            for (TableColumn childColumn : column.getChildren()) {\n                if (!column.getChildConstraint(childColumn).isImplied())\n                    return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compare this table to another table.\n     * Results are based on 1: identity, 2: table name, 3: schema name<p/>\n     *\n     * This implementation was put in place to deal with analyzing multiple\n     * schemas that contain identically named tables.\n     *\n     * @see {@link Comparable#compareTo(Object)}\n     */\n    public int compareTo(Table other) {\n        if (// fast way out\n        other == this)\n            return 0;\n        return getFullName().compareToIgnoreCase(other.getFullName());\n    }\n\n    /**\n     * Implementation of {@link Comparator} that sorts {@link TableColumn}s\n     * by {@link TableColumn#getId() ID} (ignored if <code>null</code>)\n     * followed by {@link TableColumn#getName() Name}.\n     */\n    public static class ByColumnIdComparator implements Comparator<TableColumn> {\n\n        public int compare(TableColumn column1, TableColumn column2) {\n            Object id1 = column1.getId();\n            Object id2 = column2.getId();\n            if (id1 == null || id2 == null)\n                return column1.getName().compareToIgnoreCase(column2.getName());\n            if (id1 instanceof Number && id2 instanceof Number)\n                return ((Number) id1).intValue() - ((Number) id2).intValue();\n            return id1.toString().compareToIgnoreCase(id2.toString());\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableTest3.java",
		"test_prompt": "// TableTest3.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\nimport net.sourceforge.schemaspy.model.xml.TableMeta;\nimport net.sourceforge.schemaspy.util.CaseInsensitiveMap;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Table}.\n* It contains ten unit test cases for the {@link Table#removeSelfReferencingConstraint()} method.\n*/\nclass TableTest3 {"
	},
	{
		"original_code": "// Table.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\nimport net.sourceforge.schemaspy.model.xml.TableMeta;\nimport net.sourceforge.schemaspy.util.CaseInsensitiveMap;\n\n/**\n * A <code>Table</code> is one of the basic building blocks of SchemaSpy\n * that knows everything about the database table's metadata.\n *\n * @author John Currier\n */\npublic class Table implements Comparable<Table> {\n\n    private final String catalog;\n\n    private final String schema;\n\n    private final String name;\n\n    private final String fullName;\n\n    private final String container;\n\n    protected final CaseInsensitiveMap<TableColumn> columns = new CaseInsensitiveMap<TableColumn>();\n\n    private final List<TableColumn> primaryKeys = new ArrayList<TableColumn>();\n\n    private final CaseInsensitiveMap<ForeignKeyConstraint> foreignKeys = new CaseInsensitiveMap<ForeignKeyConstraint>();\n\n    private final CaseInsensitiveMap<TableIndex> indexes = new CaseInsensitiveMap<TableIndex>();\n\n    private Object id;\n\n    private final Map<String, String> checkConstraints = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);\n\n    private Long numRows;\n\n    protected final Database db;\n\n    private String comments;\n\n    private int maxChildren;\n\n    private int maxParents;\n\n    private final static Logger logger = Logger.getLogger(Table.class.getName());\n\n    private final static boolean fineEnabled = logger.isLoggable(Level.FINE);\n\n    private final static boolean finerEnabled = logger.isLoggable(Level.FINER);\n\n    /**\n     * Construct a table that knows everything about the database table's metadata\n     *\n     * @param db\n     * @param catalog\n     * @param schema\n     * @param name\n     * @param comments\n     * @throws SQLException\n     */\n    public Table(Database db, String catalog, String schema, String name, String comments) throws SQLException {\n        this.db = db;\n        this.catalog = catalog;\n        this.schema = schema;\n        this.container = schema != null ? schema : catalog != null ? catalog : db.getName();\n        this.name = name;\n        this.fullName = getFullName(db.getName(), catalog, schema, name);\n        if (fineEnabled)\n            logger.fine(\"Creating \" + getClass().getSimpleName() + \" \" + fullName);\n        setComments(comments);\n        initColumns();\n        initIndexes();\n        initPrimaryKeys();\n    }\n\n    /**\n     * \"Connect\" all of this table's foreign keys to their referenced primary keys\n     * (and, in some cases, do the reverse as well).\n     *\n     * @param tables\n     * @throws SQLException\n     */\n    public void connectForeignKeys(Map<String, Table> tables) throws SQLException {\n        if (finerEnabled)\n            logger.finer(\"Connecting foreign keys to \" + getFullName());\n        ResultSet rs = null;\n        try {\n            // get our foreign keys that reference other tables' primary keys\n            rs = db.getMetaData().getImportedKeys(getCatalog(), getSchema(), getName());\n            while (rs.next()) {\n                addForeignKey(rs.getString(\"FK_NAME\"), rs.getString(\"FKCOLUMN_NAME\"), rs.getString(\"PKTABLE_CAT\"), rs.getString(\"PKTABLE_SCHEM\"), rs.getString(\"PKTABLE_NAME\"), rs.getString(\"PKCOLUMN_NAME\"), rs.getInt(\"UPDATE_RULE\"), rs.getInt(\"DELETE_RULE\"), tables);\n            }\n        } finally {\n            if (rs != null)\n                rs.close();\n        }\n        // also try to find all of the 'remote' tables in other schemas that\n        // point to our primary keys (not necessary in the normal case\n        // as we infer this from the opposite direction)\n        if (getSchema() != null || getCatalog() != null) {\n            try {\n                // get the foreign keys that reference our primary keys\n                rs = db.getMetaData().getExportedKeys(getCatalog(), getSchema(), getName());\n                while (rs.next()) {\n                    String otherCatalog = rs.getString(\"FKTABLE_CAT\");\n                    String otherSchema = rs.getString(\"FKTABLE_SCHEM\");\n                    if (!String.valueOf(getSchema()).equals(String.valueOf(otherSchema)) || !String.valueOf(getCatalog()).equals(String.valueOf(otherCatalog))) {\n                        db.addRemoteTable(otherCatalog, otherSchema, rs.getString(\"FKTABLE_NAME\"), getSchema(), false);\n                    }\n                }\n            } finally {\n                if (rs != null)\n                    rs.close();\n            }\n        }\n    }\n\n    /**\n     * Get the foreign keys associated with this table\n     *\n     * @return\n     */\n    public Collection<ForeignKeyConstraint> getForeignKeys() {\n        return Collections.unmodifiableCollection(foreignKeys.values());\n    }\n\n    /**\n     * Add a check constraint to the table\n     * (no real details, just name and textual representation)\n     *\n     * @param constraintName\n     * @param text\n     */\n    public void addCheckConstraint(String constraintName, String text) {\n        checkConstraints.put(constraintName, text);\n    }\n\n    /**\n     * @param rs ResultSet from {@link DatabaseMetaData#getImportedKeys(String, String, String)}\n     * rs.getString(\"FK_NAME\");\n     * rs.getString(\"FKCOLUMN_NAME\");\n     * rs.getString(\"PKTABLE_CAT\");\n     * rs.getString(\"PKTABLE_SCHEM\");\n     * rs.getString(\"PKTABLE_NAME\");\n     * rs.getString(\"PKCOLUMN_NAME\");\n     * @param tables Map\n     * @param db\n     * @throws SQLException\n     */\n    protected void addForeignKey(String fkName, String fkColName, String pkCatalog, String pkSchema, String pkTableName, String pkColName, int updateRule, int deleteRule, Map<String, Table> tables) throws SQLException {\n        if (fkName == null)\n            return;\n        Pattern include = Config.getInstance().getTableInclusions();\n        Pattern exclude = Config.getInstance().getTableExclusions();\n        if (!include.matcher(pkTableName).matches() || exclude.matcher(pkTableName).matches()) {\n            if (fineEnabled)\n                logger.fine(\"Ignoring \" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName) + \" referenced by FK \" + fkName);\n            return;\n        }\n        ForeignKeyConstraint foreignKey = foreignKeys.get(fkName);\n        if (foreignKey == null) {\n            foreignKey = new ForeignKeyConstraint(this, fkName, updateRule, deleteRule);\n            foreignKeys.put(fkName, foreignKey);\n        }\n        TableColumn childColumn = getColumn(fkColName);\n        if (childColumn != null) {\n            foreignKey.addChildColumn(childColumn);\n            Config config = Config.getInstance();\n            Table parentTable = tables.get(pkTableName);\n            String parentContainer = pkSchema != null ? pkSchema : pkCatalog != null ? pkCatalog : db.getName();\n            String baseContainer = config.getSchema() != null ? config.getSchema() : config.getCatalog() != null ? config.getCatalog() : db.getName();\n            // if named table doesn't exist in this schema\n            // or exists here but really referencing same named table in another schema\n            if (parentTable == null || !baseContainer.equals(parentContainer)) {\n                if (fineEnabled)\n                    logger.fine(\"Adding remote table \" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName));\n                parentTable = db.addRemoteTable(pkCatalog, pkSchema, pkTableName, baseContainer, false);\n            }\n            if (parentTable != null) {\n                TableColumn parentColumn = parentTable.getColumn(pkColName);\n                if (parentColumn != null) {\n                    foreignKey.addParentColumn(parentColumn);\n                    childColumn.addParent(parentColumn, foreignKey);\n                    parentColumn.addChild(childColumn, foreignKey);\n                } else {\n                    logger.warning(\"Couldn't add FK '\" + foreignKey.getName() + \"' to table '\" + this + \"' - Column '\" + pkColName + \"' doesn't exist in table '\" + parentTable + \"'\");\n                }\n            } else {\n                logger.warning(\"Couldn't add FK '\" + foreignKey.getName() + \"' to table '\" + this + \"' - Unknown Referenced Table '\" + pkTableName + \"'\");\n            }\n        } else {\n            logger.warning(\"Couldn't add FK '\" + foreignKey.getName() + \"' to table '\" + this + \"' - Column '\" + fkColName + \"' doesn't exist\");\n        }\n    }\n\n    /**\n     * @param meta\n     * @throws SQLException\n     */\n    private void initPrimaryKeys() throws SQLException {\n        ResultSet rs = null;\n        try {\n            if (fineEnabled)\n                logger.fine(\"Querying primary keys for \" + getFullName());\n            rs = db.getMetaData().getPrimaryKeys(getCatalog(), getSchema(), getName());\n            while (rs.next()) setPrimaryColumn(rs);\n        } catch (SQLException exc) {\n            if (!isLogical()) {\n                throw exc;\n            }\n        } finally {\n            if (rs != null)\n                rs.close();\n        }\n    }\n\n    /**\n     * @param rs\n     * @throws SQLException\n     */\n    private void setPrimaryColumn(ResultSet rs) throws SQLException {\n        String pkName = rs.getString(\"PK_NAME\");\n        if (pkName == null)\n            return;\n        TableIndex index = getIndex(pkName);\n        if (index != null) {\n            index.setIsPrimaryKey(true);\n        }\n        String columnName = rs.getString(\"COLUMN_NAME\");\n        setPrimaryColumn(getColumn(columnName));\n    }\n\n    /**\n     * @param primaryColumn\n     */\n    void setPrimaryColumn(TableColumn primaryColumn) {\n        primaryKeys.add(primaryColumn);\n    }\n\n    /**\n     * @throws SQLException\n     */\n    private void initColumns() throws SQLException {\n        ResultSet rs = null;\n        synchronized (Table.class) {\n            try {\n                rs = db.getMetaData().getColumns(getCatalog(), getSchema(), getName(), \"%\");\n                while (rs.next()) addColumn(rs);\n            } catch (SQLException exc) {\n                if (!isLogical()) {\n                    class ColumnInitializationFailure extends SQLException {\n\n                        private static final long serialVersionUID = 1L;\n\n                        public ColumnInitializationFailure(SQLException failure) {\n                            super(\"Failed to collect column details for \" + (isView() ? \"view\" : \"table\") + \" '\" + getName() + \"' in schema '\" + getContainer() + \"'\");\n                            initCause(failure);\n                        }\n                    }\n                    throw new ColumnInitializationFailure(exc);\n                }\n            } finally {\n                if (rs != null)\n                    rs.close();\n            }\n        }\n        initColumnAutoUpdate(false);\n    }\n\n    /**\n     * @param forceQuotes\n     * @throws SQLException\n     */\n    private void initColumnAutoUpdate(boolean forceQuotes) throws SQLException {\n        ResultSet rs = null;\n        PreparedStatement stmt = null;\n        if (isView() || isRemote())\n            return;\n        // we've got to get a result set with all the columns in it\n        // so we can ask if the columns are auto updated\n        // Ugh!!!  Should have been in DatabaseMetaData instead!!!\n        StringBuilder sql = new StringBuilder(\"select * from \");\n        if (getSchema() != null) {\n            sql.append(getSchema());\n            sql.append('.');\n        } else if (getCatalog() != null) {\n            sql.append(getCatalog());\n            sql.append('.');\n        }\n        if (forceQuotes) {\n            String quote = db.getMetaData().getIdentifierQuoteString().trim();\n            sql.append(quote + getName() + quote);\n        } else\n            sql.append(db.getQuotedIdentifier(getName()));\n        sql.append(\" where 0 = 1\");\n        try {\n            stmt = db.getMetaData().getConnection().prepareStatement(sql.toString());\n            rs = stmt.executeQuery();\n            ResultSetMetaData rsMeta = rs.getMetaData();\n            for (int i = rsMeta.getColumnCount(); i > 0; --i) {\n                TableColumn column = getColumn(rsMeta.getColumnName(i));\n                column.setIsAutoUpdated(rsMeta.isAutoIncrement(i));\n            }\n        } catch (SQLException exc) {\n            if (forceQuotes) {\n                if (!isLogical()) {\n                    // don't completely choke just because we couldn't do this....\n                    logger.warning(\"Failed to determine auto increment status: \" + exc);\n                    logger.warning(\"SQL: \" + sql.toString());\n                }\n            } else {\n                initColumnAutoUpdate(true);\n            }\n        } finally {\n            if (rs != null)\n                rs.close();\n            if (stmt != null)\n                stmt.close();\n        }\n    }\n\n    /**\n     * @param rs - from {@link DatabaseMetaData#getColumns(String, String, String, String)}\n     * @throws SQLException\n     */\n    protected void addColumn(ResultSet rs) throws SQLException {\n        String columnName = rs.getString(\"COLUMN_NAME\");\n        if (columnName == null)\n            return;\n        if (getColumn(columnName) == null) {\n            TableColumn column = new TableColumn(this, rs);\n            columns.put(column.getName(), column);\n        }\n    }\n\n    /**\n     * Add a column that's defined in xml metadata.\n     * Assumes that a column named colMeta.getName() doesn't already exist in <code>columns</code>.\n     * @param colMeta\n     * @return\n     */\n    protected TableColumn addColumn(TableColumnMeta colMeta) {\n        TableColumn column = new TableColumn(this, colMeta);\n        columns.put(column.getName(), column);\n        return column;\n    }\n\n    /**\n     * Initialize index information\n     *\n     * @throws SQLException\n     */\n    private void initIndexes() throws SQLException {\n        if (isView() || isRemote())\n            return;\n        // first try to initialize using the index query spec'd in the .properties\n        // do this first because some DB's (e.g. Oracle) do 'bad' things with getIndexInfo()\n        // (they try to do a DDL analyze command that has some bad side-effects)\n        if (initIndexes(Config.getInstance().getDbProperties().getProperty(\"selectIndexesSql\")))\n            return;\n        // couldn't, so try the old fashioned approach\n        ResultSet rs = null;\n        try {\n            rs = db.getMetaData().getIndexInfo(getCatalog(), getSchema(), getName(), false, true);\n            while (rs.next()) {\n                if (rs.getShort(\"TYPE\") != DatabaseMetaData.tableIndexStatistic)\n                    addIndex(rs);\n            }\n        } catch (SQLException exc) {\n            if (!isLogical())\n                logger.warning(\"Unable to extract index info for table '\" + getName() + \"' in schema '\" + getContainer() + \"': \" + exc);\n        } finally {\n            if (rs != null)\n                rs.close();\n        }\n    }\n\n    /**\n     * Try to initialize index information based on the specified SQL\n     *\n     * @return boolean <code>true</code> if it worked, otherwise <code>false</code>\n     */\n    private boolean initIndexes(String selectIndexesSql) {\n        if (selectIndexesSql == null)\n            return false;\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = db.prepareStatement(selectIndexesSql, getName());\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                if (rs.getShort(\"TYPE\") != DatabaseMetaData.tableIndexStatistic)\n                    addIndex(rs);\n            }\n        } catch (SQLException sqlException) {\n            logger.warning(\"Failed to query index information with SQL: \" + selectIndexesSql);\n            logger.warning(sqlException.toString());\n            return false;\n        } finally {\n            if (rs != null) {\n                try {\n                    rs.close();\n                } catch (Exception exc) {\n                    exc.printStackTrace();\n                }\n            }\n            if (stmt != null) {\n                try {\n                    stmt.close();\n                } catch (Exception exc) {\n                    exc.printStackTrace();\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @param indexName\n     * @return\n     */\n    public TableIndex getIndex(String indexName) {\n        return indexes.get(indexName);\n    }\n\n    /**\n     * @param rs\n     * @throws SQLException\n     */\n    private void addIndex(ResultSet rs) throws SQLException {\n        String indexName = rs.getString(\"INDEX_NAME\");\n        if (indexName == null)\n            return;\n        TableIndex index = getIndex(indexName);\n        if (index == null) {\n            index = new TableIndex(rs);\n            indexes.put(index.getName(), index);\n        }\n        index.addColumn(getColumn(rs.getString(\"COLUMN_NAME\")), rs.getString(\"ASC_OR_DESC\"));\n    }\n\n    /**\n     * Returns the catalog that the table belongs to\n     *\n     * @return\n     */\n    public String getCatalog() {\n        return catalog;\n    }\n\n    /**\n     * Returns the schema that the table belongs to\n     *\n     * @return\n     */\n    public String getSchema() {\n        return schema;\n    }\n\n    /**\n     * Returns the logical 'container' that the table\n     * lives in.  Basically it's the first non-<code>null</code>\n     * item out of <code>schema</code>, <code>catalog</code>\n     * and <code>database</code>.\n     *\n     * @return\n     */\n    public String getContainer() {\n        return container;\n    }\n\n    /**\n     * Returns the name of the table\n     *\n     * @return\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the fully-qualified name of this table\n     *\n     * @return\n     */\n    public String getFullName() {\n        return fullName;\n    }\n\n    /**\n     * Returns the fully-qualified name of a table\n     *\n     * @return\n     */\n    public static String getFullName(String db, String catalog, String schema, String table) {\n        String fullName = (catalog == null && schema == null ? db + '.' : \"\") + (catalog == null ? \"\" : catalog + '.') + (schema == null ? \"\" : schema + '.') + table;\n        return fullName;\n    }\n\n    /**\n     * Object IDs are useful for tables such as DB/2 that many times\n     * give error messages based on object ID and not name\n     *\n     * @param id\n     */\n    public void setId(Object id) {\n        this.id = id;\n    }\n\n    /**\n     * @see #setId(Object)\n     *\n     * @return\n     */\n    public Object getId() {\n        return id;\n    }\n\n    /**\n     * Returns the check constraints associated with this table\n     *\n     * @return\n     */\n    public Map<String, String> getCheckConstraints() {\n        return checkConstraints;\n    }\n\n    /**\n     * Returns the indexes that are applied to this table\n     *\n     * @return\n     */\n    public Set<TableIndex> getIndexes() {\n        return new HashSet<TableIndex>(indexes.values());\n    }\n\n    /**\n     * Returns a collection of table columns that have been identified as \"primary\"\n     *\n     * @return\n     */\n    public List<TableColumn> getPrimaryColumns() {\n        return primaryKeys;\n    }\n\n    /**\n     * @return Comments associated with this table, or <code>null</code> if none.\n     */\n    public String getComments() {\n        return comments;\n    }\n\n    /**\n     * Sets the comments that are associated with this table\n     *\n     * @param comments\n     */\n    public void setComments(String comments) {\n        String cmts = (comments == null || comments.trim().length() == 0) ? null : comments.trim();\n        // MySQL's InnoDB engine does some insane crap of storing erroneous details in\n        // with table comments.  Here I attempt to strip the \"crap\" out without impacting\n        // other databases.  Ideally this should happen in selectColumnCommentsSql (and\n        // therefore isolate it to MySQL), but it's a bit too complex to do cleanly.\n        if (cmts != null) {\n            int crapIndex = cmts.indexOf(\"; InnoDB free: \");\n            if (crapIndex == -1)\n                crapIndex = cmts.startsWith(\"InnoDB free: \") ? 0 : -1;\n            if (crapIndex != -1) {\n                cmts = cmts.substring(0, crapIndex).trim();\n                cmts = cmts.length() == 0 ? null : cmts;\n            }\n        }\n        this.comments = cmts;\n    }\n\n    /**\n     * Returns the {@link TableColumn} with the given name, or <code>null</code>\n     * if it doesn't exist\n     *\n     * @param columnName\n     * @return\n     */\n    public TableColumn getColumn(String columnName) {\n        return columns.get(columnName);\n    }\n\n    /**\n     * Returns <code>List</code> of <code>TableColumn</code>s in ascending column number order.\n     *\n     * @return\n     */\n    public List<TableColumn> getColumns() {\n        Set<TableColumn> sorted = new TreeSet<TableColumn>(new ByColumnIdComparator());\n        sorted.addAll(columns.values());\n        return new ArrayList<TableColumn>(sorted);\n    }\n\n    /**\n     * Returns <code>true</code> if this table references no other tables..<p/>\n     * Used in dependency analysis.\n     * @return\n     */\n    public boolean isRoot() {\n        for (TableColumn column : columns.values()) {\n            if (column.isForeignKey()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns <code>true</code> if this table is referenced by no other tables.<p/>\n     * Used in dependency analysis.\n     * @return\n     */\n    public boolean isLeaf() {\n        for (TableColumn column : columns.values()) {\n            if (!column.getChildren().isEmpty()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the maximum number of parents that this table has had before\n     * any had been removed during dependency analysis\n     *\n     * @return\n     */\n    public int getMaxParents() {\n        return maxParents;\n    }\n\n    /**\n     * Notification that's called to indicate that a parent has been added to\n     * this table\n     */\n    public void addedParent() {\n        maxParents++;\n    }\n\n    /**\n     * \"Unlink\" all of the parent tables from this table\n     */\n    public void unlinkParents() {\n        for (TableColumn column : columns.values()) {\n            column.unlinkParents();\n        }\n    }\n\n    /**\n     * Returns the maximum number of children that this table has had before\n     * any had been removed during dependency analysis\n     *\n     * @return\n     */\n    public int getMaxChildren() {\n        return maxChildren;\n    }\n\n    /**\n     * Notification that's called to indicate that a child has been added to\n     * this table\n     */\n    public void addedChild() {\n        maxChildren++;\n    }\n\n    /**\n     * \"Unlink\" all of the child tables from this table\n     */\n    public void unlinkChildren() {\n        for (TableColumn column : columns.values()) {\n            column.unlinkChildren();\n        }\n    }\n\n    /**\n     * Remove a single self referencing constraint if one exists.\n     *\n     * @return\n     */\n    public ForeignKeyConstraint removeSelfReferencingConstraint() {\n        return remove(getSelfReferencingConstraint());\n    }\n\n    /**\n     * Remove the specified {@link ForeignKeyConstraint} from this table.<p>\n     *\n     * This is a more drastic removal solution that was proposed by Remke Rutgers\n     *\n     * @param constraint\n     */\n    private ForeignKeyConstraint remove(ForeignKeyConstraint constraint) {\n        if (constraint != null) {\n            for (int i = 0; i < constraint.getChildColumns().size(); i++) {\n                TableColumn childColumn = constraint.getChildColumns().get(i);\n                TableColumn parentColumn = constraint.getParentColumns().get(i);\n                childColumn.removeParent(parentColumn);\n                parentColumn.removeChild(childColumn);\n            }\n        }\n        return constraint;\n    }\n\n    /**\n     * Return a self referencing constraint if one exists\n     *\n     * @return\n     */\n    private ForeignKeyConstraint getSelfReferencingConstraint() {\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                if (compareTo(parentColumn.getTable()) == 0) {\n                    return column.getParentConstraint(parentColumn);\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Remove any non-real foreign keys\n     *\n     * @return\n     */\n    public List<ForeignKeyConstraint> removeNonRealForeignKeys() {\n        List<ForeignKeyConstraint> nonReals = new ArrayList<ForeignKeyConstraint>();\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                ForeignKeyConstraint constraint = column.getParentConstraint(parentColumn);\n                if (constraint != null && !constraint.isReal()) {\n                    nonReals.add(constraint);\n                }\n            }\n        }\n        // remove constraints outside of above loop to prevent\n        // concurrent modification exceptions while iterating\n        for (ForeignKeyConstraint constraint : nonReals) {\n            remove(constraint);\n        }\n        return nonReals;\n    }\n\n    /**\n     * Returns the number of tables that reference this table\n     *\n     * @return\n     */\n    public int getNumChildren() {\n        int numChildren = 0;\n        for (TableColumn column : columns.values()) {\n            numChildren += column.getChildren().size();\n        }\n        return numChildren;\n    }\n\n    /**\n     * Returns the number of non-implied children\n     * @return\n     */\n    public int getNumNonImpliedChildren() {\n        int numChildren = 0;\n        for (TableColumn column : columns.values()) {\n            for (TableColumn childColumn : column.getChildren()) {\n                if (!column.getChildConstraint(childColumn).isImplied())\n                    ++numChildren;\n            }\n        }\n        return numChildren;\n    }\n\n    /**\n     * Returns the number of tables that are referenced by this table\n     *\n     * @return\n     */\n    public int getNumParents() {\n        int numParents = 0;\n        for (TableColumn column : columns.values()) {\n            numParents += column.getParents().size();\n        }\n        return numParents;\n    }\n\n    /**\n     * Returns the number of non-implied parents\n     *\n     * @return\n     */\n    public int getNumNonImpliedParents() {\n        int numParents = 0;\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                if (!column.getParentConstraint(parentColumn).isImplied())\n                    ++numParents;\n            }\n        }\n        return numParents;\n    }\n\n    /**\n     * Remove one foreign key constraint.\n     *\n     * <p/>Used during dependency analysis phase.\n     *\n     * @return\n     */\n    public ForeignKeyConstraint removeAForeignKeyConstraint() {\n        @SuppressWarnings(\"hiding\")\n        final List<TableColumn> columns = getColumns();\n        int numParents = 0;\n        int numChildren = 0;\n        // remove either a child or parent, choosing which based on which has the\n        // least number of foreign key associations (when either gets to zero then\n        // the table can be pruned)\n        for (TableColumn column : columns) {\n            numParents += column.getParents().size();\n            numChildren += column.getChildren().size();\n        }\n        for (TableColumn column : columns) {\n            ForeignKeyConstraint constraint;\n            if (numParents <= numChildren)\n                constraint = column.removeAParentFKConstraint();\n            else\n                constraint = column.removeAChildFKConstraint();\n            if (constraint != null)\n                return constraint;\n        }\n        return null;\n    }\n\n    /**\n     * Returns <code>true</code> if this table is logical (not physical), <code>false</code> otherwise\n     * @return\n     */\n    public boolean isLogical() {\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if this is a view, <code>false</code> otherwise\n     *\n     * @return\n     */\n    public boolean isView() {\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if this table is remote (in another schema), <code>false</code> otherwise\n     * @return\n     */\n    public boolean isRemote() {\n        return false;\n    }\n\n    /**\n     * If this is a view it returns the SQL used to create the view (if it's available).\n     * <code>null</code> if it's not a view or the SQL isn't available.\n     * @return\n     * @see #isView()\n     */\n    public String getViewSql() {\n        return null;\n    }\n\n    /**\n     * Returns the number of rows contained in this table, or -1 if unable to determine\n     * the number of rows.\n     *\n     * @return\n     */\n    public long getNumRows() {\n        if (numRows == null) {\n            numRows = Config.getInstance().isNumRowsEnabled() ? fetchNumRows() : -1;\n        }\n        return numRows;\n    }\n\n    /**\n     * Explicitly set the number of rows in this table\n     *\n     * @param numRows\n     */\n    public void setNumRows(long numRows) {\n        this.numRows = numRows;\n    }\n\n    /**\n     * Fetch the number of rows contained in this table.\n     *\n     * returns -1 if unable to successfully fetch the row count\n     *\n     * @param db Database\n     * @return int\n     * @throws SQLException\n     */\n    protected long fetchNumRows() {\n        if (isView() || isRemote())\n            return -1;\n        SQLException originalFailure = null;\n        String sql = Config.getInstance().getDbProperties().getProperty(\"selectRowCountSql\");\n        if (sql != null) {\n            PreparedStatement stmt = null;\n            ResultSet rs = null;\n            try {\n                stmt = db.prepareStatement(sql, getName());\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    return rs.getLong(\"row_count\");\n                }\n            } catch (SQLException sqlException) {\n                // don't die just because this failed\n                originalFailure = sqlException;\n            } finally {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    } catch (SQLException exc) {\n                    }\n                }\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException exc) {\n                    }\n                }\n            }\n        }\n        // if we get here then we either didn't have custom SQL or it didn't work\n        try {\n            // '*' should work best for the majority of cases\n            return fetchNumRows(\"count(*)\", false);\n        } catch (SQLException try2Exception) {\n            try {\n                // except nested tables...try using '1' instead\n                return fetchNumRows(\"count(1)\", false);\n            } catch (SQLException try3Exception) {\n                if (!isLogical()) {\n                    logger.warning(\"Unable to extract the number of rows for table \" + getName() + \", using '-1'\");\n                    if (originalFailure != null)\n                        logger.warning(originalFailure.toString());\n                    logger.warning(try2Exception.toString());\n                    if (!String.valueOf(try2Exception.toString()).equals(try3Exception.toString()))\n                        logger.warning(try3Exception.toString());\n                }\n                return -1;\n            }\n        }\n    }\n\n    protected long fetchNumRows(String clause, boolean forceQuotes) throws SQLException {\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        StringBuilder sql = new StringBuilder(\"select \");\n        sql.append(clause);\n        sql.append(\" from \");\n        if (getSchema() != null) {\n            sql.append(getSchema());\n            sql.append('.');\n        } else if (getCatalog() != null) {\n            sql.append(getCatalog());\n            sql.append('.');\n        }\n        if (forceQuotes) {\n            String quote = db.getMetaData().getIdentifierQuoteString().trim();\n            sql.append(quote + getName() + quote);\n        } else\n            sql.append(db.getQuotedIdentifier(getName()));\n        try {\n            if (finerEnabled)\n                logger.finer(sql.toString());\n            stmt = db.getConnection().prepareStatement(sql.toString());\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                return rs.getLong(1);\n            }\n            return -1;\n        } catch (SQLException exc) {\n            if (// we tried with and w/o quotes...fail this attempt\n            forceQuotes)\n                throw exc;\n            return fetchNumRows(clause, true);\n        } finally {\n            if (rs != null)\n                rs.close();\n            if (stmt != null)\n                stmt.close();\n        }\n    }\n\n    /**\n     * Update the table with the specified XML-derived metadata\n     *\n     * @param tableMeta\n     */\n    public void update(TableMeta tableMeta) {\n        String newComments = tableMeta.getComments();\n        if (newComments != null) {\n            comments = newComments;\n        }\n        for (TableColumnMeta colMeta : tableMeta.getColumns()) {\n            TableColumn col = getColumn(colMeta.getName());\n            if (col == null) {\n                col = addColumn(colMeta);\n            }\n            // update the column with the changes\n            col.update(colMeta);\n        }\n    }\n\n    /**\n     * Same as {@link #connectForeignKeys(Map, Database, Properties)},\n     * but uses XML-based metadata\n     *\n     * @param tableMeta\n     * @param tables\n     */\n    public void connect(TableMeta tableMeta, Map<String, Table> tables) {\n        for (TableColumnMeta colMeta : tableMeta.getColumns()) {\n            TableColumn col = getColumn(colMeta.getName());\n            if (col != null) {\n                // go thru the new foreign key defs and associate them with our columns\n                for (ForeignKeyMeta fk : colMeta.getForeignKeys()) {\n                    Table parent;\n                    if (fk.getRemoteCatalog() != null || fk.getRemoteSchema() != null) {\n                        try {\n                            // adds if doesn't exist\n                            parent = db.addRemoteTable(fk.getRemoteCatalog(), fk.getRemoteSchema(), fk.getTableName(), getContainer(), true);\n                        } catch (SQLException exc) {\n                            parent = null;\n                        }\n                    } else {\n                        parent = tables.get(fk.getTableName());\n                    }\n                    if (parent != null) {\n                        TableColumn parentColumn = parent.getColumn(fk.getColumnName());\n                        if (parentColumn == null) {\n                            logger.warning(\"Undefined column '\" + parent.getName() + '.' + fk.getColumnName() + \"' referenced by '\" + col.getTable() + '.' + col + \"' in XML metadata\");\n                        } else {\n                            /**\n                             * Merely instantiating a foreign key constraint ties it\n                             * into its parent and child columns (& therefore their tables)\n                             */\n                            @SuppressWarnings(\"unused\")\n                            ForeignKeyConstraint unused = new ForeignKeyConstraint(parentColumn, col) {\n\n                                @Override\n                                public String getName() {\n                                    return \"Defined in XML\";\n                                }\n                            };\n                            // they forgot to say it was a primary key\n                            if (!parentColumn.isPrimary()) {\n                                logger.warning(\"Assuming \" + parentColumn.getTable() + '.' + parentColumn + \" is a primary key due to being referenced by \" + col.getTable() + '.' + col);\n                                parent.setPrimaryColumn(parentColumn);\n                            }\n                        }\n                    } else {\n                        logger.warning(\"Undefined table '\" + fk.getTableName() + \"' referenced by '\" + getName() + '.' + col.getName() + \"' in XML metadata\");\n                    }\n                }\n            } else {\n                logger.warning(\"Undefined column '\" + getName() + '.' + colMeta.getName() + \"' in XML metadata\");\n            }\n        }\n    }\n\n    @Override\n    public String toString() {\n        return getName();\n    }\n\n    /**\n     * Returns <code>true</code> if this table has no relationships\n     *\n     * @param withImpliedRelationships boolean\n     * @return boolean\n     */\n    public boolean isOrphan(boolean withImpliedRelationships) {\n        if (withImpliedRelationships)\n            return getMaxParents() == 0 && getMaxChildren() == 0;\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                if (!column.getParentConstraint(parentColumn).isImplied())\n                    return false;\n            }\n            for (TableColumn childColumn : column.getChildren()) {\n                if (!column.getChildConstraint(childColumn).isImplied())\n                    return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compare this table to another table.\n     * Results are based on 1: identity, 2: table name, 3: schema name<p/>\n     *\n     * This implementation was put in place to deal with analyzing multiple\n     * schemas that contain identically named tables.\n     *\n     * @see {@link Comparable#compareTo(Object)}\n     */\n    public int compareTo(Table other) {\n        if (// fast way out\n        other == this)\n            return 0;\n        return getFullName().compareToIgnoreCase(other.getFullName());\n    }\n\n    /**\n     * Implementation of {@link Comparator} that sorts {@link TableColumn}s\n     * by {@link TableColumn#getId() ID} (ignored if <code>null</code>)\n     * followed by {@link TableColumn#getName() Name}.\n     */\n    public static class ByColumnIdComparator implements Comparator<TableColumn> {\n\n        public int compare(TableColumn column1, TableColumn column2) {\n            Object id1 = column1.getId();\n            Object id2 = column2.getId();\n            if (id1 == null || id2 == null)\n                return column1.getName().compareToIgnoreCase(column2.getName());\n            if (id1 instanceof Number && id2 instanceof Number)\n                return ((Number) id1).intValue() - ((Number) id2).intValue();\n            return id1.toString().compareToIgnoreCase(id2.toString());\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableTest4.java",
		"test_prompt": "// TableTest4.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\nimport net.sourceforge.schemaspy.model.xml.TableMeta;\nimport net.sourceforge.schemaspy.util.CaseInsensitiveMap;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Table}.\n* It contains ten unit test cases for the {@link Table#removeNonRealForeignKeys()} method.\n*/\nclass TableTest4 {"
	},
	{
		"original_code": "// Table.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\nimport net.sourceforge.schemaspy.model.xml.TableMeta;\nimport net.sourceforge.schemaspy.util.CaseInsensitiveMap;\n\n/**\n * A <code>Table</code> is one of the basic building blocks of SchemaSpy\n * that knows everything about the database table's metadata.\n *\n * @author John Currier\n */\npublic class Table implements Comparable<Table> {\n\n    private final String catalog;\n\n    private final String schema;\n\n    private final String name;\n\n    private final String fullName;\n\n    private final String container;\n\n    protected final CaseInsensitiveMap<TableColumn> columns = new CaseInsensitiveMap<TableColumn>();\n\n    private final List<TableColumn> primaryKeys = new ArrayList<TableColumn>();\n\n    private final CaseInsensitiveMap<ForeignKeyConstraint> foreignKeys = new CaseInsensitiveMap<ForeignKeyConstraint>();\n\n    private final CaseInsensitiveMap<TableIndex> indexes = new CaseInsensitiveMap<TableIndex>();\n\n    private Object id;\n\n    private final Map<String, String> checkConstraints = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);\n\n    private Long numRows;\n\n    protected final Database db;\n\n    private String comments;\n\n    private int maxChildren;\n\n    private int maxParents;\n\n    private final static Logger logger = Logger.getLogger(Table.class.getName());\n\n    private final static boolean fineEnabled = logger.isLoggable(Level.FINE);\n\n    private final static boolean finerEnabled = logger.isLoggable(Level.FINER);\n\n    /**\n     * Construct a table that knows everything about the database table's metadata\n     *\n     * @param db\n     * @param catalog\n     * @param schema\n     * @param name\n     * @param comments\n     * @throws SQLException\n     */\n    public Table(Database db, String catalog, String schema, String name, String comments) throws SQLException {\n        this.db = db;\n        this.catalog = catalog;\n        this.schema = schema;\n        this.container = schema != null ? schema : catalog != null ? catalog : db.getName();\n        this.name = name;\n        this.fullName = getFullName(db.getName(), catalog, schema, name);\n        if (fineEnabled)\n            logger.fine(\"Creating \" + getClass().getSimpleName() + \" \" + fullName);\n        setComments(comments);\n        initColumns();\n        initIndexes();\n        initPrimaryKeys();\n    }\n\n    /**\n     * \"Connect\" all of this table's foreign keys to their referenced primary keys\n     * (and, in some cases, do the reverse as well).\n     *\n     * @param tables\n     * @throws SQLException\n     */\n    public void connectForeignKeys(Map<String, Table> tables) throws SQLException {\n        if (finerEnabled)\n            logger.finer(\"Connecting foreign keys to \" + getFullName());\n        ResultSet rs = null;\n        try {\n            // get our foreign keys that reference other tables' primary keys\n            rs = db.getMetaData().getImportedKeys(getCatalog(), getSchema(), getName());\n            while (rs.next()) {\n                addForeignKey(rs.getString(\"FK_NAME\"), rs.getString(\"FKCOLUMN_NAME\"), rs.getString(\"PKTABLE_CAT\"), rs.getString(\"PKTABLE_SCHEM\"), rs.getString(\"PKTABLE_NAME\"), rs.getString(\"PKCOLUMN_NAME\"), rs.getInt(\"UPDATE_RULE\"), rs.getInt(\"DELETE_RULE\"), tables);\n            }\n        } finally {\n            if (rs != null)\n                rs.close();\n        }\n        // also try to find all of the 'remote' tables in other schemas that\n        // point to our primary keys (not necessary in the normal case\n        // as we infer this from the opposite direction)\n        if (getSchema() != null || getCatalog() != null) {\n            try {\n                // get the foreign keys that reference our primary keys\n                rs = db.getMetaData().getExportedKeys(getCatalog(), getSchema(), getName());\n                while (rs.next()) {\n                    String otherCatalog = rs.getString(\"FKTABLE_CAT\");\n                    String otherSchema = rs.getString(\"FKTABLE_SCHEM\");\n                    if (!String.valueOf(getSchema()).equals(String.valueOf(otherSchema)) || !String.valueOf(getCatalog()).equals(String.valueOf(otherCatalog))) {\n                        db.addRemoteTable(otherCatalog, otherSchema, rs.getString(\"FKTABLE_NAME\"), getSchema(), false);\n                    }\n                }\n            } finally {\n                if (rs != null)\n                    rs.close();\n            }\n        }\n    }\n\n    /**\n     * Get the foreign keys associated with this table\n     *\n     * @return\n     */\n    public Collection<ForeignKeyConstraint> getForeignKeys() {\n        return Collections.unmodifiableCollection(foreignKeys.values());\n    }\n\n    /**\n     * Add a check constraint to the table\n     * (no real details, just name and textual representation)\n     *\n     * @param constraintName\n     * @param text\n     */\n    public void addCheckConstraint(String constraintName, String text) {\n        checkConstraints.put(constraintName, text);\n    }\n\n    /**\n     * @param rs ResultSet from {@link DatabaseMetaData#getImportedKeys(String, String, String)}\n     * rs.getString(\"FK_NAME\");\n     * rs.getString(\"FKCOLUMN_NAME\");\n     * rs.getString(\"PKTABLE_CAT\");\n     * rs.getString(\"PKTABLE_SCHEM\");\n     * rs.getString(\"PKTABLE_NAME\");\n     * rs.getString(\"PKCOLUMN_NAME\");\n     * @param tables Map\n     * @param db\n     * @throws SQLException\n     */\n    protected void addForeignKey(String fkName, String fkColName, String pkCatalog, String pkSchema, String pkTableName, String pkColName, int updateRule, int deleteRule, Map<String, Table> tables) throws SQLException {\n        if (fkName == null)\n            return;\n        Pattern include = Config.getInstance().getTableInclusions();\n        Pattern exclude = Config.getInstance().getTableExclusions();\n        if (!include.matcher(pkTableName).matches() || exclude.matcher(pkTableName).matches()) {\n            if (fineEnabled)\n                logger.fine(\"Ignoring \" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName) + \" referenced by FK \" + fkName);\n            return;\n        }\n        ForeignKeyConstraint foreignKey = foreignKeys.get(fkName);\n        if (foreignKey == null) {\n            foreignKey = new ForeignKeyConstraint(this, fkName, updateRule, deleteRule);\n            foreignKeys.put(fkName, foreignKey);\n        }\n        TableColumn childColumn = getColumn(fkColName);\n        if (childColumn != null) {\n            foreignKey.addChildColumn(childColumn);\n            Config config = Config.getInstance();\n            Table parentTable = tables.get(pkTableName);\n            String parentContainer = pkSchema != null ? pkSchema : pkCatalog != null ? pkCatalog : db.getName();\n            String baseContainer = config.getSchema() != null ? config.getSchema() : config.getCatalog() != null ? config.getCatalog() : db.getName();\n            // if named table doesn't exist in this schema\n            // or exists here but really referencing same named table in another schema\n            if (parentTable == null || !baseContainer.equals(parentContainer)) {\n                if (fineEnabled)\n                    logger.fine(\"Adding remote table \" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName));\n                parentTable = db.addRemoteTable(pkCatalog, pkSchema, pkTableName, baseContainer, false);\n            }\n            if (parentTable != null) {\n                TableColumn parentColumn = parentTable.getColumn(pkColName);\n                if (parentColumn != null) {\n                    foreignKey.addParentColumn(parentColumn);\n                    childColumn.addParent(parentColumn, foreignKey);\n                    parentColumn.addChild(childColumn, foreignKey);\n                } else {\n                    logger.warning(\"Couldn't add FK '\" + foreignKey.getName() + \"' to table '\" + this + \"' - Column '\" + pkColName + \"' doesn't exist in table '\" + parentTable + \"'\");\n                }\n            } else {\n                logger.warning(\"Couldn't add FK '\" + foreignKey.getName() + \"' to table '\" + this + \"' - Unknown Referenced Table '\" + pkTableName + \"'\");\n            }\n        } else {\n            logger.warning(\"Couldn't add FK '\" + foreignKey.getName() + \"' to table '\" + this + \"' - Column '\" + fkColName + \"' doesn't exist\");\n        }\n    }\n\n    /**\n     * @param meta\n     * @throws SQLException\n     */\n    private void initPrimaryKeys() throws SQLException {\n        ResultSet rs = null;\n        try {\n            if (fineEnabled)\n                logger.fine(\"Querying primary keys for \" + getFullName());\n            rs = db.getMetaData().getPrimaryKeys(getCatalog(), getSchema(), getName());\n            while (rs.next()) setPrimaryColumn(rs);\n        } catch (SQLException exc) {\n            if (!isLogical()) {\n                throw exc;\n            }\n        } finally {\n            if (rs != null)\n                rs.close();\n        }\n    }\n\n    /**\n     * @param rs\n     * @throws SQLException\n     */\n    private void setPrimaryColumn(ResultSet rs) throws SQLException {\n        String pkName = rs.getString(\"PK_NAME\");\n        if (pkName == null)\n            return;\n        TableIndex index = getIndex(pkName);\n        if (index != null) {\n            index.setIsPrimaryKey(true);\n        }\n        String columnName = rs.getString(\"COLUMN_NAME\");\n        setPrimaryColumn(getColumn(columnName));\n    }\n\n    /**\n     * @param primaryColumn\n     */\n    void setPrimaryColumn(TableColumn primaryColumn) {\n        primaryKeys.add(primaryColumn);\n    }\n\n    /**\n     * @throws SQLException\n     */\n    private void initColumns() throws SQLException {\n        ResultSet rs = null;\n        synchronized (Table.class) {\n            try {\n                rs = db.getMetaData().getColumns(getCatalog(), getSchema(), getName(), \"%\");\n                while (rs.next()) addColumn(rs);\n            } catch (SQLException exc) {\n                if (!isLogical()) {\n                    class ColumnInitializationFailure extends SQLException {\n\n                        private static final long serialVersionUID = 1L;\n\n                        public ColumnInitializationFailure(SQLException failure) {\n                            super(\"Failed to collect column details for \" + (isView() ? \"view\" : \"table\") + \" '\" + getName() + \"' in schema '\" + getContainer() + \"'\");\n                            initCause(failure);\n                        }\n                    }\n                    throw new ColumnInitializationFailure(exc);\n                }\n            } finally {\n                if (rs != null)\n                    rs.close();\n            }\n        }\n        initColumnAutoUpdate(false);\n    }\n\n    /**\n     * @param forceQuotes\n     * @throws SQLException\n     */\n    private void initColumnAutoUpdate(boolean forceQuotes) throws SQLException {\n        ResultSet rs = null;\n        PreparedStatement stmt = null;\n        if (isView() || isRemote())\n            return;\n        // we've got to get a result set with all the columns in it\n        // so we can ask if the columns are auto updated\n        // Ugh!!!  Should have been in DatabaseMetaData instead!!!\n        StringBuilder sql = new StringBuilder(\"select * from \");\n        if (getSchema() != null) {\n            sql.append(getSchema());\n            sql.append('.');\n        } else if (getCatalog() != null) {\n            sql.append(getCatalog());\n            sql.append('.');\n        }\n        if (forceQuotes) {\n            String quote = db.getMetaData().getIdentifierQuoteString().trim();\n            sql.append(quote + getName() + quote);\n        } else\n            sql.append(db.getQuotedIdentifier(getName()));\n        sql.append(\" where 0 = 1\");\n        try {\n            stmt = db.getMetaData().getConnection().prepareStatement(sql.toString());\n            rs = stmt.executeQuery();\n            ResultSetMetaData rsMeta = rs.getMetaData();\n            for (int i = rsMeta.getColumnCount(); i > 0; --i) {\n                TableColumn column = getColumn(rsMeta.getColumnName(i));\n                column.setIsAutoUpdated(rsMeta.isAutoIncrement(i));\n            }\n        } catch (SQLException exc) {\n            if (forceQuotes) {\n                if (!isLogical()) {\n                    // don't completely choke just because we couldn't do this....\n                    logger.warning(\"Failed to determine auto increment status: \" + exc);\n                    logger.warning(\"SQL: \" + sql.toString());\n                }\n            } else {\n                initColumnAutoUpdate(true);\n            }\n        } finally {\n            if (rs != null)\n                rs.close();\n            if (stmt != null)\n                stmt.close();\n        }\n    }\n\n    /**\n     * @param rs - from {@link DatabaseMetaData#getColumns(String, String, String, String)}\n     * @throws SQLException\n     */\n    protected void addColumn(ResultSet rs) throws SQLException {\n        String columnName = rs.getString(\"COLUMN_NAME\");\n        if (columnName == null)\n            return;\n        if (getColumn(columnName) == null) {\n            TableColumn column = new TableColumn(this, rs);\n            columns.put(column.getName(), column);\n        }\n    }\n\n    /**\n     * Add a column that's defined in xml metadata.\n     * Assumes that a column named colMeta.getName() doesn't already exist in <code>columns</code>.\n     * @param colMeta\n     * @return\n     */\n    protected TableColumn addColumn(TableColumnMeta colMeta) {\n        TableColumn column = new TableColumn(this, colMeta);\n        columns.put(column.getName(), column);\n        return column;\n    }\n\n    /**\n     * Initialize index information\n     *\n     * @throws SQLException\n     */\n    private void initIndexes() throws SQLException {\n        if (isView() || isRemote())\n            return;\n        // first try to initialize using the index query spec'd in the .properties\n        // do this first because some DB's (e.g. Oracle) do 'bad' things with getIndexInfo()\n        // (they try to do a DDL analyze command that has some bad side-effects)\n        if (initIndexes(Config.getInstance().getDbProperties().getProperty(\"selectIndexesSql\")))\n            return;\n        // couldn't, so try the old fashioned approach\n        ResultSet rs = null;\n        try {\n            rs = db.getMetaData().getIndexInfo(getCatalog(), getSchema(), getName(), false, true);\n            while (rs.next()) {\n                if (rs.getShort(\"TYPE\") != DatabaseMetaData.tableIndexStatistic)\n                    addIndex(rs);\n            }\n        } catch (SQLException exc) {\n            if (!isLogical())\n                logger.warning(\"Unable to extract index info for table '\" + getName() + \"' in schema '\" + getContainer() + \"': \" + exc);\n        } finally {\n            if (rs != null)\n                rs.close();\n        }\n    }\n\n    /**\n     * Try to initialize index information based on the specified SQL\n     *\n     * @return boolean <code>true</code> if it worked, otherwise <code>false</code>\n     */\n    private boolean initIndexes(String selectIndexesSql) {\n        if (selectIndexesSql == null)\n            return false;\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = db.prepareStatement(selectIndexesSql, getName());\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                if (rs.getShort(\"TYPE\") != DatabaseMetaData.tableIndexStatistic)\n                    addIndex(rs);\n            }\n        } catch (SQLException sqlException) {\n            logger.warning(\"Failed to query index information with SQL: \" + selectIndexesSql);\n            logger.warning(sqlException.toString());\n            return false;\n        } finally {\n            if (rs != null) {\n                try {\n                    rs.close();\n                } catch (Exception exc) {\n                    exc.printStackTrace();\n                }\n            }\n            if (stmt != null) {\n                try {\n                    stmt.close();\n                } catch (Exception exc) {\n                    exc.printStackTrace();\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @param indexName\n     * @return\n     */\n    public TableIndex getIndex(String indexName) {\n        return indexes.get(indexName);\n    }\n\n    /**\n     * @param rs\n     * @throws SQLException\n     */\n    private void addIndex(ResultSet rs) throws SQLException {\n        String indexName = rs.getString(\"INDEX_NAME\");\n        if (indexName == null)\n            return;\n        TableIndex index = getIndex(indexName);\n        if (index == null) {\n            index = new TableIndex(rs);\n            indexes.put(index.getName(), index);\n        }\n        index.addColumn(getColumn(rs.getString(\"COLUMN_NAME\")), rs.getString(\"ASC_OR_DESC\"));\n    }\n\n    /**\n     * Returns the catalog that the table belongs to\n     *\n     * @return\n     */\n    public String getCatalog() {\n        return catalog;\n    }\n\n    /**\n     * Returns the schema that the table belongs to\n     *\n     * @return\n     */\n    public String getSchema() {\n        return schema;\n    }\n\n    /**\n     * Returns the logical 'container' that the table\n     * lives in.  Basically it's the first non-<code>null</code>\n     * item out of <code>schema</code>, <code>catalog</code>\n     * and <code>database</code>.\n     *\n     * @return\n     */\n    public String getContainer() {\n        return container;\n    }\n\n    /**\n     * Returns the name of the table\n     *\n     * @return\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the fully-qualified name of this table\n     *\n     * @return\n     */\n    public String getFullName() {\n        return fullName;\n    }\n\n    /**\n     * Returns the fully-qualified name of a table\n     *\n     * @return\n     */\n    public static String getFullName(String db, String catalog, String schema, String table) {\n        String fullName = (catalog == null && schema == null ? db + '.' : \"\") + (catalog == null ? \"\" : catalog + '.') + (schema == null ? \"\" : schema + '.') + table;\n        return fullName;\n    }\n\n    /**\n     * Object IDs are useful for tables such as DB/2 that many times\n     * give error messages based on object ID and not name\n     *\n     * @param id\n     */\n    public void setId(Object id) {\n        this.id = id;\n    }\n\n    /**\n     * @see #setId(Object)\n     *\n     * @return\n     */\n    public Object getId() {\n        return id;\n    }\n\n    /**\n     * Returns the check constraints associated with this table\n     *\n     * @return\n     */\n    public Map<String, String> getCheckConstraints() {\n        return checkConstraints;\n    }\n\n    /**\n     * Returns the indexes that are applied to this table\n     *\n     * @return\n     */\n    public Set<TableIndex> getIndexes() {\n        return new HashSet<TableIndex>(indexes.values());\n    }\n\n    /**\n     * Returns a collection of table columns that have been identified as \"primary\"\n     *\n     * @return\n     */\n    public List<TableColumn> getPrimaryColumns() {\n        return primaryKeys;\n    }\n\n    /**\n     * @return Comments associated with this table, or <code>null</code> if none.\n     */\n    public String getComments() {\n        return comments;\n    }\n\n    /**\n     * Sets the comments that are associated with this table\n     *\n     * @param comments\n     */\n    public void setComments(String comments) {\n        String cmts = (comments == null || comments.trim().length() == 0) ? null : comments.trim();\n        // MySQL's InnoDB engine does some insane crap of storing erroneous details in\n        // with table comments.  Here I attempt to strip the \"crap\" out without impacting\n        // other databases.  Ideally this should happen in selectColumnCommentsSql (and\n        // therefore isolate it to MySQL), but it's a bit too complex to do cleanly.\n        if (cmts != null) {\n            int crapIndex = cmts.indexOf(\"; InnoDB free: \");\n            if (crapIndex == -1)\n                crapIndex = cmts.startsWith(\"InnoDB free: \") ? 0 : -1;\n            if (crapIndex != -1) {\n                cmts = cmts.substring(0, crapIndex).trim();\n                cmts = cmts.length() == 0 ? null : cmts;\n            }\n        }\n        this.comments = cmts;\n    }\n\n    /**\n     * Returns the {@link TableColumn} with the given name, or <code>null</code>\n     * if it doesn't exist\n     *\n     * @param columnName\n     * @return\n     */\n    public TableColumn getColumn(String columnName) {\n        return columns.get(columnName);\n    }\n\n    /**\n     * Returns <code>List</code> of <code>TableColumn</code>s in ascending column number order.\n     *\n     * @return\n     */\n    public List<TableColumn> getColumns() {\n        Set<TableColumn> sorted = new TreeSet<TableColumn>(new ByColumnIdComparator());\n        sorted.addAll(columns.values());\n        return new ArrayList<TableColumn>(sorted);\n    }\n\n    /**\n     * Returns <code>true</code> if this table references no other tables..<p/>\n     * Used in dependency analysis.\n     * @return\n     */\n    public boolean isRoot() {\n        for (TableColumn column : columns.values()) {\n            if (column.isForeignKey()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns <code>true</code> if this table is referenced by no other tables.<p/>\n     * Used in dependency analysis.\n     * @return\n     */\n    public boolean isLeaf() {\n        for (TableColumn column : columns.values()) {\n            if (!column.getChildren().isEmpty()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the maximum number of parents that this table has had before\n     * any had been removed during dependency analysis\n     *\n     * @return\n     */\n    public int getMaxParents() {\n        return maxParents;\n    }\n\n    /**\n     * Notification that's called to indicate that a parent has been added to\n     * this table\n     */\n    public void addedParent() {\n        maxParents++;\n    }\n\n    /**\n     * \"Unlink\" all of the parent tables from this table\n     */\n    public void unlinkParents() {\n        for (TableColumn column : columns.values()) {\n            column.unlinkParents();\n        }\n    }\n\n    /**\n     * Returns the maximum number of children that this table has had before\n     * any had been removed during dependency analysis\n     *\n     * @return\n     */\n    public int getMaxChildren() {\n        return maxChildren;\n    }\n\n    /**\n     * Notification that's called to indicate that a child has been added to\n     * this table\n     */\n    public void addedChild() {\n        maxChildren++;\n    }\n\n    /**\n     * \"Unlink\" all of the child tables from this table\n     */\n    public void unlinkChildren() {\n        for (TableColumn column : columns.values()) {\n            column.unlinkChildren();\n        }\n    }\n\n    /**\n     * Remove a single self referencing constraint if one exists.\n     *\n     * @return\n     */\n    public ForeignKeyConstraint removeSelfReferencingConstraint() {\n        return remove(getSelfReferencingConstraint());\n    }\n\n    /**\n     * Remove the specified {@link ForeignKeyConstraint} from this table.<p>\n     *\n     * This is a more drastic removal solution that was proposed by Remke Rutgers\n     *\n     * @param constraint\n     */\n    private ForeignKeyConstraint remove(ForeignKeyConstraint constraint) {\n        if (constraint != null) {\n            for (int i = 0; i < constraint.getChildColumns().size(); i++) {\n                TableColumn childColumn = constraint.getChildColumns().get(i);\n                TableColumn parentColumn = constraint.getParentColumns().get(i);\n                childColumn.removeParent(parentColumn);\n                parentColumn.removeChild(childColumn);\n            }\n        }\n        return constraint;\n    }\n\n    /**\n     * Return a self referencing constraint if one exists\n     *\n     * @return\n     */\n    private ForeignKeyConstraint getSelfReferencingConstraint() {\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                if (compareTo(parentColumn.getTable()) == 0) {\n                    return column.getParentConstraint(parentColumn);\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Remove any non-real foreign keys\n     *\n     * @return\n     */\n    public List<ForeignKeyConstraint> removeNonRealForeignKeys() {\n        List<ForeignKeyConstraint> nonReals = new ArrayList<ForeignKeyConstraint>();\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                ForeignKeyConstraint constraint = column.getParentConstraint(parentColumn);\n                if (constraint != null && !constraint.isReal()) {\n                    nonReals.add(constraint);\n                }\n            }\n        }\n        // remove constraints outside of above loop to prevent\n        // concurrent modification exceptions while iterating\n        for (ForeignKeyConstraint constraint : nonReals) {\n            remove(constraint);\n        }\n        return nonReals;\n    }\n\n    /**\n     * Returns the number of tables that reference this table\n     *\n     * @return\n     */\n    public int getNumChildren() {\n        int numChildren = 0;\n        for (TableColumn column : columns.values()) {\n            numChildren += column.getChildren().size();\n        }\n        return numChildren;\n    }\n\n    /**\n     * Returns the number of non-implied children\n     * @return\n     */\n    public int getNumNonImpliedChildren() {\n        int numChildren = 0;\n        for (TableColumn column : columns.values()) {\n            for (TableColumn childColumn : column.getChildren()) {\n                if (!column.getChildConstraint(childColumn).isImplied())\n                    ++numChildren;\n            }\n        }\n        return numChildren;\n    }\n\n    /**\n     * Returns the number of tables that are referenced by this table\n     *\n     * @return\n     */\n    public int getNumParents() {\n        int numParents = 0;\n        for (TableColumn column : columns.values()) {\n            numParents += column.getParents().size();\n        }\n        return numParents;\n    }\n\n    /**\n     * Returns the number of non-implied parents\n     *\n     * @return\n     */\n    public int getNumNonImpliedParents() {\n        int numParents = 0;\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                if (!column.getParentConstraint(parentColumn).isImplied())\n                    ++numParents;\n            }\n        }\n        return numParents;\n    }\n\n    /**\n     * Remove one foreign key constraint.\n     *\n     * <p/>Used during dependency analysis phase.\n     *\n     * @return\n     */\n    public ForeignKeyConstraint removeAForeignKeyConstraint() {\n        @SuppressWarnings(\"hiding\")\n        final List<TableColumn> columns = getColumns();\n        int numParents = 0;\n        int numChildren = 0;\n        // remove either a child or parent, choosing which based on which has the\n        // least number of foreign key associations (when either gets to zero then\n        // the table can be pruned)\n        for (TableColumn column : columns) {\n            numParents += column.getParents().size();\n            numChildren += column.getChildren().size();\n        }\n        for (TableColumn column : columns) {\n            ForeignKeyConstraint constraint;\n            if (numParents <= numChildren)\n                constraint = column.removeAParentFKConstraint();\n            else\n                constraint = column.removeAChildFKConstraint();\n            if (constraint != null)\n                return constraint;\n        }\n        return null;\n    }\n\n    /**\n     * Returns <code>true</code> if this table is logical (not physical), <code>false</code> otherwise\n     * @return\n     */\n    public boolean isLogical() {\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if this is a view, <code>false</code> otherwise\n     *\n     * @return\n     */\n    public boolean isView() {\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if this table is remote (in another schema), <code>false</code> otherwise\n     * @return\n     */\n    public boolean isRemote() {\n        return false;\n    }\n\n    /**\n     * If this is a view it returns the SQL used to create the view (if it's available).\n     * <code>null</code> if it's not a view or the SQL isn't available.\n     * @return\n     * @see #isView()\n     */\n    public String getViewSql() {\n        return null;\n    }\n\n    /**\n     * Returns the number of rows contained in this table, or -1 if unable to determine\n     * the number of rows.\n     *\n     * @return\n     */\n    public long getNumRows() {\n        if (numRows == null) {\n            numRows = Config.getInstance().isNumRowsEnabled() ? fetchNumRows() : -1;\n        }\n        return numRows;\n    }\n\n    /**\n     * Explicitly set the number of rows in this table\n     *\n     * @param numRows\n     */\n    public void setNumRows(long numRows) {\n        this.numRows = numRows;\n    }\n\n    /**\n     * Fetch the number of rows contained in this table.\n     *\n     * returns -1 if unable to successfully fetch the row count\n     *\n     * @param db Database\n     * @return int\n     * @throws SQLException\n     */\n    protected long fetchNumRows() {\n        if (isView() || isRemote())\n            return -1;\n        SQLException originalFailure = null;\n        String sql = Config.getInstance().getDbProperties().getProperty(\"selectRowCountSql\");\n        if (sql != null) {\n            PreparedStatement stmt = null;\n            ResultSet rs = null;\n            try {\n                stmt = db.prepareStatement(sql, getName());\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    return rs.getLong(\"row_count\");\n                }\n            } catch (SQLException sqlException) {\n                // don't die just because this failed\n                originalFailure = sqlException;\n            } finally {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    } catch (SQLException exc) {\n                    }\n                }\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException exc) {\n                    }\n                }\n            }\n        }\n        // if we get here then we either didn't have custom SQL or it didn't work\n        try {\n            // '*' should work best for the majority of cases\n            return fetchNumRows(\"count(*)\", false);\n        } catch (SQLException try2Exception) {\n            try {\n                // except nested tables...try using '1' instead\n                return fetchNumRows(\"count(1)\", false);\n            } catch (SQLException try3Exception) {\n                if (!isLogical()) {\n                    logger.warning(\"Unable to extract the number of rows for table \" + getName() + \", using '-1'\");\n                    if (originalFailure != null)\n                        logger.warning(originalFailure.toString());\n                    logger.warning(try2Exception.toString());\n                    if (!String.valueOf(try2Exception.toString()).equals(try3Exception.toString()))\n                        logger.warning(try3Exception.toString());\n                }\n                return -1;\n            }\n        }\n    }\n\n    protected long fetchNumRows(String clause, boolean forceQuotes) throws SQLException {\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        StringBuilder sql = new StringBuilder(\"select \");\n        sql.append(clause);\n        sql.append(\" from \");\n        if (getSchema() != null) {\n            sql.append(getSchema());\n            sql.append('.');\n        } else if (getCatalog() != null) {\n            sql.append(getCatalog());\n            sql.append('.');\n        }\n        if (forceQuotes) {\n            String quote = db.getMetaData().getIdentifierQuoteString().trim();\n            sql.append(quote + getName() + quote);\n        } else\n            sql.append(db.getQuotedIdentifier(getName()));\n        try {\n            if (finerEnabled)\n                logger.finer(sql.toString());\n            stmt = db.getConnection().prepareStatement(sql.toString());\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                return rs.getLong(1);\n            }\n            return -1;\n        } catch (SQLException exc) {\n            if (// we tried with and w/o quotes...fail this attempt\n            forceQuotes)\n                throw exc;\n            return fetchNumRows(clause, true);\n        } finally {\n            if (rs != null)\n                rs.close();\n            if (stmt != null)\n                stmt.close();\n        }\n    }\n\n    /**\n     * Update the table with the specified XML-derived metadata\n     *\n     * @param tableMeta\n     */\n    public void update(TableMeta tableMeta) {\n        String newComments = tableMeta.getComments();\n        if (newComments != null) {\n            comments = newComments;\n        }\n        for (TableColumnMeta colMeta : tableMeta.getColumns()) {\n            TableColumn col = getColumn(colMeta.getName());\n            if (col == null) {\n                col = addColumn(colMeta);\n            }\n            // update the column with the changes\n            col.update(colMeta);\n        }\n    }\n\n    /**\n     * Same as {@link #connectForeignKeys(Map, Database, Properties)},\n     * but uses XML-based metadata\n     *\n     * @param tableMeta\n     * @param tables\n     */\n    public void connect(TableMeta tableMeta, Map<String, Table> tables) {\n        for (TableColumnMeta colMeta : tableMeta.getColumns()) {\n            TableColumn col = getColumn(colMeta.getName());\n            if (col != null) {\n                // go thru the new foreign key defs and associate them with our columns\n                for (ForeignKeyMeta fk : colMeta.getForeignKeys()) {\n                    Table parent;\n                    if (fk.getRemoteCatalog() != null || fk.getRemoteSchema() != null) {\n                        try {\n                            // adds if doesn't exist\n                            parent = db.addRemoteTable(fk.getRemoteCatalog(), fk.getRemoteSchema(), fk.getTableName(), getContainer(), true);\n                        } catch (SQLException exc) {\n                            parent = null;\n                        }\n                    } else {\n                        parent = tables.get(fk.getTableName());\n                    }\n                    if (parent != null) {\n                        TableColumn parentColumn = parent.getColumn(fk.getColumnName());\n                        if (parentColumn == null) {\n                            logger.warning(\"Undefined column '\" + parent.getName() + '.' + fk.getColumnName() + \"' referenced by '\" + col.getTable() + '.' + col + \"' in XML metadata\");\n                        } else {\n                            /**\n                             * Merely instantiating a foreign key constraint ties it\n                             * into its parent and child columns (& therefore their tables)\n                             */\n                            @SuppressWarnings(\"unused\")\n                            ForeignKeyConstraint unused = new ForeignKeyConstraint(parentColumn, col) {\n\n                                @Override\n                                public String getName() {\n                                    return \"Defined in XML\";\n                                }\n                            };\n                            // they forgot to say it was a primary key\n                            if (!parentColumn.isPrimary()) {\n                                logger.warning(\"Assuming \" + parentColumn.getTable() + '.' + parentColumn + \" is a primary key due to being referenced by \" + col.getTable() + '.' + col);\n                                parent.setPrimaryColumn(parentColumn);\n                            }\n                        }\n                    } else {\n                        logger.warning(\"Undefined table '\" + fk.getTableName() + \"' referenced by '\" + getName() + '.' + col.getName() + \"' in XML metadata\");\n                    }\n                }\n            } else {\n                logger.warning(\"Undefined column '\" + getName() + '.' + colMeta.getName() + \"' in XML metadata\");\n            }\n        }\n    }\n\n    @Override\n    public String toString() {\n        return getName();\n    }\n\n    /**\n     * Returns <code>true</code> if this table has no relationships\n     *\n     * @param withImpliedRelationships boolean\n     * @return boolean\n     */\n    public boolean isOrphan(boolean withImpliedRelationships) {\n        if (withImpliedRelationships)\n            return getMaxParents() == 0 && getMaxChildren() == 0;\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                if (!column.getParentConstraint(parentColumn).isImplied())\n                    return false;\n            }\n            for (TableColumn childColumn : column.getChildren()) {\n                if (!column.getChildConstraint(childColumn).isImplied())\n                    return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compare this table to another table.\n     * Results are based on 1: identity, 2: table name, 3: schema name<p/>\n     *\n     * This implementation was put in place to deal with analyzing multiple\n     * schemas that contain identically named tables.\n     *\n     * @see {@link Comparable#compareTo(Object)}\n     */\n    public int compareTo(Table other) {\n        if (// fast way out\n        other == this)\n            return 0;\n        return getFullName().compareToIgnoreCase(other.getFullName());\n    }\n\n    /**\n     * Implementation of {@link Comparator} that sorts {@link TableColumn}s\n     * by {@link TableColumn#getId() ID} (ignored if <code>null</code>)\n     * followed by {@link TableColumn#getName() Name}.\n     */\n    public static class ByColumnIdComparator implements Comparator<TableColumn> {\n\n        public int compare(TableColumn column1, TableColumn column2) {\n            Object id1 = column1.getId();\n            Object id2 = column2.getId();\n            if (id1 == null || id2 == null)\n                return column1.getName().compareToIgnoreCase(column2.getName());\n            if (id1 instanceof Number && id2 instanceof Number)\n                return ((Number) id1).intValue() - ((Number) id2).intValue();\n            return id1.toString().compareToIgnoreCase(id2.toString());\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableTest5.java",
		"test_prompt": "// TableTest5.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\nimport net.sourceforge.schemaspy.model.xml.TableMeta;\nimport net.sourceforge.schemaspy.util.CaseInsensitiveMap;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Table}.\n* It contains ten unit test cases for the {@link Table#removeAForeignKeyConstraint()} method.\n*/\nclass TableTest5 {"
	},
	{
		"original_code": "// Table.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\nimport net.sourceforge.schemaspy.model.xml.TableMeta;\nimport net.sourceforge.schemaspy.util.CaseInsensitiveMap;\n\n/**\n * A <code>Table</code> is one of the basic building blocks of SchemaSpy\n * that knows everything about the database table's metadata.\n *\n * @author John Currier\n */\npublic class Table implements Comparable<Table> {\n\n    private final String catalog;\n\n    private final String schema;\n\n    private final String name;\n\n    private final String fullName;\n\n    private final String container;\n\n    protected final CaseInsensitiveMap<TableColumn> columns = new CaseInsensitiveMap<TableColumn>();\n\n    private final List<TableColumn> primaryKeys = new ArrayList<TableColumn>();\n\n    private final CaseInsensitiveMap<ForeignKeyConstraint> foreignKeys = new CaseInsensitiveMap<ForeignKeyConstraint>();\n\n    private final CaseInsensitiveMap<TableIndex> indexes = new CaseInsensitiveMap<TableIndex>();\n\n    private Object id;\n\n    private final Map<String, String> checkConstraints = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);\n\n    private Long numRows;\n\n    protected final Database db;\n\n    private String comments;\n\n    private int maxChildren;\n\n    private int maxParents;\n\n    private final static Logger logger = Logger.getLogger(Table.class.getName());\n\n    private final static boolean fineEnabled = logger.isLoggable(Level.FINE);\n\n    private final static boolean finerEnabled = logger.isLoggable(Level.FINER);\n\n    /**\n     * Construct a table that knows everything about the database table's metadata\n     *\n     * @param db\n     * @param catalog\n     * @param schema\n     * @param name\n     * @param comments\n     * @throws SQLException\n     */\n    public Table(Database db, String catalog, String schema, String name, String comments) throws SQLException {\n        this.db = db;\n        this.catalog = catalog;\n        this.schema = schema;\n        this.container = schema != null ? schema : catalog != null ? catalog : db.getName();\n        this.name = name;\n        this.fullName = getFullName(db.getName(), catalog, schema, name);\n        if (fineEnabled)\n            logger.fine(\"Creating \" + getClass().getSimpleName() + \" \" + fullName);\n        setComments(comments);\n        initColumns();\n        initIndexes();\n        initPrimaryKeys();\n    }\n\n    /**\n     * \"Connect\" all of this table's foreign keys to their referenced primary keys\n     * (and, in some cases, do the reverse as well).\n     *\n     * @param tables\n     * @throws SQLException\n     */\n    public void connectForeignKeys(Map<String, Table> tables) throws SQLException {\n        if (finerEnabled)\n            logger.finer(\"Connecting foreign keys to \" + getFullName());\n        ResultSet rs = null;\n        try {\n            // get our foreign keys that reference other tables' primary keys\n            rs = db.getMetaData().getImportedKeys(getCatalog(), getSchema(), getName());\n            while (rs.next()) {\n                addForeignKey(rs.getString(\"FK_NAME\"), rs.getString(\"FKCOLUMN_NAME\"), rs.getString(\"PKTABLE_CAT\"), rs.getString(\"PKTABLE_SCHEM\"), rs.getString(\"PKTABLE_NAME\"), rs.getString(\"PKCOLUMN_NAME\"), rs.getInt(\"UPDATE_RULE\"), rs.getInt(\"DELETE_RULE\"), tables);\n            }\n        } finally {\n            if (rs != null)\n                rs.close();\n        }\n        // also try to find all of the 'remote' tables in other schemas that\n        // point to our primary keys (not necessary in the normal case\n        // as we infer this from the opposite direction)\n        if (getSchema() != null || getCatalog() != null) {\n            try {\n                // get the foreign keys that reference our primary keys\n                rs = db.getMetaData().getExportedKeys(getCatalog(), getSchema(), getName());\n                while (rs.next()) {\n                    String otherCatalog = rs.getString(\"FKTABLE_CAT\");\n                    String otherSchema = rs.getString(\"FKTABLE_SCHEM\");\n                    if (!String.valueOf(getSchema()).equals(String.valueOf(otherSchema)) || !String.valueOf(getCatalog()).equals(String.valueOf(otherCatalog))) {\n                        db.addRemoteTable(otherCatalog, otherSchema, rs.getString(\"FKTABLE_NAME\"), getSchema(), false);\n                    }\n                }\n            } finally {\n                if (rs != null)\n                    rs.close();\n            }\n        }\n    }\n\n    /**\n     * Get the foreign keys associated with this table\n     *\n     * @return\n     */\n    public Collection<ForeignKeyConstraint> getForeignKeys() {\n        return Collections.unmodifiableCollection(foreignKeys.values());\n    }\n\n    /**\n     * Add a check constraint to the table\n     * (no real details, just name and textual representation)\n     *\n     * @param constraintName\n     * @param text\n     */\n    public void addCheckConstraint(String constraintName, String text) {\n        checkConstraints.put(constraintName, text);\n    }\n\n    /**\n     * @param rs ResultSet from {@link DatabaseMetaData#getImportedKeys(String, String, String)}\n     * rs.getString(\"FK_NAME\");\n     * rs.getString(\"FKCOLUMN_NAME\");\n     * rs.getString(\"PKTABLE_CAT\");\n     * rs.getString(\"PKTABLE_SCHEM\");\n     * rs.getString(\"PKTABLE_NAME\");\n     * rs.getString(\"PKCOLUMN_NAME\");\n     * @param tables Map\n     * @param db\n     * @throws SQLException\n     */\n    protected void addForeignKey(String fkName, String fkColName, String pkCatalog, String pkSchema, String pkTableName, String pkColName, int updateRule, int deleteRule, Map<String, Table> tables) throws SQLException {\n        if (fkName == null)\n            return;\n        Pattern include = Config.getInstance().getTableInclusions();\n        Pattern exclude = Config.getInstance().getTableExclusions();\n        if (!include.matcher(pkTableName).matches() || exclude.matcher(pkTableName).matches()) {\n            if (fineEnabled)\n                logger.fine(\"Ignoring \" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName) + \" referenced by FK \" + fkName);\n            return;\n        }\n        ForeignKeyConstraint foreignKey = foreignKeys.get(fkName);\n        if (foreignKey == null) {\n            foreignKey = new ForeignKeyConstraint(this, fkName, updateRule, deleteRule);\n            foreignKeys.put(fkName, foreignKey);\n        }\n        TableColumn childColumn = getColumn(fkColName);\n        if (childColumn != null) {\n            foreignKey.addChildColumn(childColumn);\n            Config config = Config.getInstance();\n            Table parentTable = tables.get(pkTableName);\n            String parentContainer = pkSchema != null ? pkSchema : pkCatalog != null ? pkCatalog : db.getName();\n            String baseContainer = config.getSchema() != null ? config.getSchema() : config.getCatalog() != null ? config.getCatalog() : db.getName();\n            // if named table doesn't exist in this schema\n            // or exists here but really referencing same named table in another schema\n            if (parentTable == null || !baseContainer.equals(parentContainer)) {\n                if (fineEnabled)\n                    logger.fine(\"Adding remote table \" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName));\n                parentTable = db.addRemoteTable(pkCatalog, pkSchema, pkTableName, baseContainer, false);\n            }\n            if (parentTable != null) {\n                TableColumn parentColumn = parentTable.getColumn(pkColName);\n                if (parentColumn != null) {\n                    foreignKey.addParentColumn(parentColumn);\n                    childColumn.addParent(parentColumn, foreignKey);\n                    parentColumn.addChild(childColumn, foreignKey);\n                } else {\n                    logger.warning(\"Couldn't add FK '\" + foreignKey.getName() + \"' to table '\" + this + \"' - Column '\" + pkColName + \"' doesn't exist in table '\" + parentTable + \"'\");\n                }\n            } else {\n                logger.warning(\"Couldn't add FK '\" + foreignKey.getName() + \"' to table '\" + this + \"' - Unknown Referenced Table '\" + pkTableName + \"'\");\n            }\n        } else {\n            logger.warning(\"Couldn't add FK '\" + foreignKey.getName() + \"' to table '\" + this + \"' - Column '\" + fkColName + \"' doesn't exist\");\n        }\n    }\n\n    /**\n     * @param meta\n     * @throws SQLException\n     */\n    private void initPrimaryKeys() throws SQLException {\n        ResultSet rs = null;\n        try {\n            if (fineEnabled)\n                logger.fine(\"Querying primary keys for \" + getFullName());\n            rs = db.getMetaData().getPrimaryKeys(getCatalog(), getSchema(), getName());\n            while (rs.next()) setPrimaryColumn(rs);\n        } catch (SQLException exc) {\n            if (!isLogical()) {\n                throw exc;\n            }\n        } finally {\n            if (rs != null)\n                rs.close();\n        }\n    }\n\n    /**\n     * @param rs\n     * @throws SQLException\n     */\n    private void setPrimaryColumn(ResultSet rs) throws SQLException {\n        String pkName = rs.getString(\"PK_NAME\");\n        if (pkName == null)\n            return;\n        TableIndex index = getIndex(pkName);\n        if (index != null) {\n            index.setIsPrimaryKey(true);\n        }\n        String columnName = rs.getString(\"COLUMN_NAME\");\n        setPrimaryColumn(getColumn(columnName));\n    }\n\n    /**\n     * @param primaryColumn\n     */\n    void setPrimaryColumn(TableColumn primaryColumn) {\n        primaryKeys.add(primaryColumn);\n    }\n\n    /**\n     * @throws SQLException\n     */\n    private void initColumns() throws SQLException {\n        ResultSet rs = null;\n        synchronized (Table.class) {\n            try {\n                rs = db.getMetaData().getColumns(getCatalog(), getSchema(), getName(), \"%\");\n                while (rs.next()) addColumn(rs);\n            } catch (SQLException exc) {\n                if (!isLogical()) {\n                    class ColumnInitializationFailure extends SQLException {\n\n                        private static final long serialVersionUID = 1L;\n\n                        public ColumnInitializationFailure(SQLException failure) {\n                            super(\"Failed to collect column details for \" + (isView() ? \"view\" : \"table\") + \" '\" + getName() + \"' in schema '\" + getContainer() + \"'\");\n                            initCause(failure);\n                        }\n                    }\n                    throw new ColumnInitializationFailure(exc);\n                }\n            } finally {\n                if (rs != null)\n                    rs.close();\n            }\n        }\n        initColumnAutoUpdate(false);\n    }\n\n    /**\n     * @param forceQuotes\n     * @throws SQLException\n     */\n    private void initColumnAutoUpdate(boolean forceQuotes) throws SQLException {\n        ResultSet rs = null;\n        PreparedStatement stmt = null;\n        if (isView() || isRemote())\n            return;\n        // we've got to get a result set with all the columns in it\n        // so we can ask if the columns are auto updated\n        // Ugh!!!  Should have been in DatabaseMetaData instead!!!\n        StringBuilder sql = new StringBuilder(\"select * from \");\n        if (getSchema() != null) {\n            sql.append(getSchema());\n            sql.append('.');\n        } else if (getCatalog() != null) {\n            sql.append(getCatalog());\n            sql.append('.');\n        }\n        if (forceQuotes) {\n            String quote = db.getMetaData().getIdentifierQuoteString().trim();\n            sql.append(quote + getName() + quote);\n        } else\n            sql.append(db.getQuotedIdentifier(getName()));\n        sql.append(\" where 0 = 1\");\n        try {\n            stmt = db.getMetaData().getConnection().prepareStatement(sql.toString());\n            rs = stmt.executeQuery();\n            ResultSetMetaData rsMeta = rs.getMetaData();\n            for (int i = rsMeta.getColumnCount(); i > 0; --i) {\n                TableColumn column = getColumn(rsMeta.getColumnName(i));\n                column.setIsAutoUpdated(rsMeta.isAutoIncrement(i));\n            }\n        } catch (SQLException exc) {\n            if (forceQuotes) {\n                if (!isLogical()) {\n                    // don't completely choke just because we couldn't do this....\n                    logger.warning(\"Failed to determine auto increment status: \" + exc);\n                    logger.warning(\"SQL: \" + sql.toString());\n                }\n            } else {\n                initColumnAutoUpdate(true);\n            }\n        } finally {\n            if (rs != null)\n                rs.close();\n            if (stmt != null)\n                stmt.close();\n        }\n    }\n\n    /**\n     * @param rs - from {@link DatabaseMetaData#getColumns(String, String, String, String)}\n     * @throws SQLException\n     */\n    protected void addColumn(ResultSet rs) throws SQLException {\n        String columnName = rs.getString(\"COLUMN_NAME\");\n        if (columnName == null)\n            return;\n        if (getColumn(columnName) == null) {\n            TableColumn column = new TableColumn(this, rs);\n            columns.put(column.getName(), column);\n        }\n    }\n\n    /**\n     * Add a column that's defined in xml metadata.\n     * Assumes that a column named colMeta.getName() doesn't already exist in <code>columns</code>.\n     * @param colMeta\n     * @return\n     */\n    protected TableColumn addColumn(TableColumnMeta colMeta) {\n        TableColumn column = new TableColumn(this, colMeta);\n        columns.put(column.getName(), column);\n        return column;\n    }\n\n    /**\n     * Initialize index information\n     *\n     * @throws SQLException\n     */\n    private void initIndexes() throws SQLException {\n        if (isView() || isRemote())\n            return;\n        // first try to initialize using the index query spec'd in the .properties\n        // do this first because some DB's (e.g. Oracle) do 'bad' things with getIndexInfo()\n        // (they try to do a DDL analyze command that has some bad side-effects)\n        if (initIndexes(Config.getInstance().getDbProperties().getProperty(\"selectIndexesSql\")))\n            return;\n        // couldn't, so try the old fashioned approach\n        ResultSet rs = null;\n        try {\n            rs = db.getMetaData().getIndexInfo(getCatalog(), getSchema(), getName(), false, true);\n            while (rs.next()) {\n                if (rs.getShort(\"TYPE\") != DatabaseMetaData.tableIndexStatistic)\n                    addIndex(rs);\n            }\n        } catch (SQLException exc) {\n            if (!isLogical())\n                logger.warning(\"Unable to extract index info for table '\" + getName() + \"' in schema '\" + getContainer() + \"': \" + exc);\n        } finally {\n            if (rs != null)\n                rs.close();\n        }\n    }\n\n    /**\n     * Try to initialize index information based on the specified SQL\n     *\n     * @return boolean <code>true</code> if it worked, otherwise <code>false</code>\n     */\n    private boolean initIndexes(String selectIndexesSql) {\n        if (selectIndexesSql == null)\n            return false;\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = db.prepareStatement(selectIndexesSql, getName());\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                if (rs.getShort(\"TYPE\") != DatabaseMetaData.tableIndexStatistic)\n                    addIndex(rs);\n            }\n        } catch (SQLException sqlException) {\n            logger.warning(\"Failed to query index information with SQL: \" + selectIndexesSql);\n            logger.warning(sqlException.toString());\n            return false;\n        } finally {\n            if (rs != null) {\n                try {\n                    rs.close();\n                } catch (Exception exc) {\n                    exc.printStackTrace();\n                }\n            }\n            if (stmt != null) {\n                try {\n                    stmt.close();\n                } catch (Exception exc) {\n                    exc.printStackTrace();\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @param indexName\n     * @return\n     */\n    public TableIndex getIndex(String indexName) {\n        return indexes.get(indexName);\n    }\n\n    /**\n     * @param rs\n     * @throws SQLException\n     */\n    private void addIndex(ResultSet rs) throws SQLException {\n        String indexName = rs.getString(\"INDEX_NAME\");\n        if (indexName == null)\n            return;\n        TableIndex index = getIndex(indexName);\n        if (index == null) {\n            index = new TableIndex(rs);\n            indexes.put(index.getName(), index);\n        }\n        index.addColumn(getColumn(rs.getString(\"COLUMN_NAME\")), rs.getString(\"ASC_OR_DESC\"));\n    }\n\n    /**\n     * Returns the catalog that the table belongs to\n     *\n     * @return\n     */\n    public String getCatalog() {\n        return catalog;\n    }\n\n    /**\n     * Returns the schema that the table belongs to\n     *\n     * @return\n     */\n    public String getSchema() {\n        return schema;\n    }\n\n    /**\n     * Returns the logical 'container' that the table\n     * lives in.  Basically it's the first non-<code>null</code>\n     * item out of <code>schema</code>, <code>catalog</code>\n     * and <code>database</code>.\n     *\n     * @return\n     */\n    public String getContainer() {\n        return container;\n    }\n\n    /**\n     * Returns the name of the table\n     *\n     * @return\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the fully-qualified name of this table\n     *\n     * @return\n     */\n    public String getFullName() {\n        return fullName;\n    }\n\n    /**\n     * Returns the fully-qualified name of a table\n     *\n     * @return\n     */\n    public static String getFullName(String db, String catalog, String schema, String table) {\n        String fullName = (catalog == null && schema == null ? db + '.' : \"\") + (catalog == null ? \"\" : catalog + '.') + (schema == null ? \"\" : schema + '.') + table;\n        return fullName;\n    }\n\n    /**\n     * Object IDs are useful for tables such as DB/2 that many times\n     * give error messages based on object ID and not name\n     *\n     * @param id\n     */\n    public void setId(Object id) {\n        this.id = id;\n    }\n\n    /**\n     * @see #setId(Object)\n     *\n     * @return\n     */\n    public Object getId() {\n        return id;\n    }\n\n    /**\n     * Returns the check constraints associated with this table\n     *\n     * @return\n     */\n    public Map<String, String> getCheckConstraints() {\n        return checkConstraints;\n    }\n\n    /**\n     * Returns the indexes that are applied to this table\n     *\n     * @return\n     */\n    public Set<TableIndex> getIndexes() {\n        return new HashSet<TableIndex>(indexes.values());\n    }\n\n    /**\n     * Returns a collection of table columns that have been identified as \"primary\"\n     *\n     * @return\n     */\n    public List<TableColumn> getPrimaryColumns() {\n        return primaryKeys;\n    }\n\n    /**\n     * @return Comments associated with this table, or <code>null</code> if none.\n     */\n    public String getComments() {\n        return comments;\n    }\n\n    /**\n     * Sets the comments that are associated with this table\n     *\n     * @param comments\n     */\n    public void setComments(String comments) {\n        String cmts = (comments == null || comments.trim().length() == 0) ? null : comments.trim();\n        // MySQL's InnoDB engine does some insane crap of storing erroneous details in\n        // with table comments.  Here I attempt to strip the \"crap\" out without impacting\n        // other databases.  Ideally this should happen in selectColumnCommentsSql (and\n        // therefore isolate it to MySQL), but it's a bit too complex to do cleanly.\n        if (cmts != null) {\n            int crapIndex = cmts.indexOf(\"; InnoDB free: \");\n            if (crapIndex == -1)\n                crapIndex = cmts.startsWith(\"InnoDB free: \") ? 0 : -1;\n            if (crapIndex != -1) {\n                cmts = cmts.substring(0, crapIndex).trim();\n                cmts = cmts.length() == 0 ? null : cmts;\n            }\n        }\n        this.comments = cmts;\n    }\n\n    /**\n     * Returns the {@link TableColumn} with the given name, or <code>null</code>\n     * if it doesn't exist\n     *\n     * @param columnName\n     * @return\n     */\n    public TableColumn getColumn(String columnName) {\n        return columns.get(columnName);\n    }\n\n    /**\n     * Returns <code>List</code> of <code>TableColumn</code>s in ascending column number order.\n     *\n     * @return\n     */\n    public List<TableColumn> getColumns() {\n        Set<TableColumn> sorted = new TreeSet<TableColumn>(new ByColumnIdComparator());\n        sorted.addAll(columns.values());\n        return new ArrayList<TableColumn>(sorted);\n    }\n\n    /**\n     * Returns <code>true</code> if this table references no other tables..<p/>\n     * Used in dependency analysis.\n     * @return\n     */\n    public boolean isRoot() {\n        for (TableColumn column : columns.values()) {\n            if (column.isForeignKey()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns <code>true</code> if this table is referenced by no other tables.<p/>\n     * Used in dependency analysis.\n     * @return\n     */\n    public boolean isLeaf() {\n        for (TableColumn column : columns.values()) {\n            if (!column.getChildren().isEmpty()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the maximum number of parents that this table has had before\n     * any had been removed during dependency analysis\n     *\n     * @return\n     */\n    public int getMaxParents() {\n        return maxParents;\n    }\n\n    /**\n     * Notification that's called to indicate that a parent has been added to\n     * this table\n     */\n    public void addedParent() {\n        maxParents++;\n    }\n\n    /**\n     * \"Unlink\" all of the parent tables from this table\n     */\n    public void unlinkParents() {\n        for (TableColumn column : columns.values()) {\n            column.unlinkParents();\n        }\n    }\n\n    /**\n     * Returns the maximum number of children that this table has had before\n     * any had been removed during dependency analysis\n     *\n     * @return\n     */\n    public int getMaxChildren() {\n        return maxChildren;\n    }\n\n    /**\n     * Notification that's called to indicate that a child has been added to\n     * this table\n     */\n    public void addedChild() {\n        maxChildren++;\n    }\n\n    /**\n     * \"Unlink\" all of the child tables from this table\n     */\n    public void unlinkChildren() {\n        for (TableColumn column : columns.values()) {\n            column.unlinkChildren();\n        }\n    }\n\n    /**\n     * Remove a single self referencing constraint if one exists.\n     *\n     * @return\n     */\n    public ForeignKeyConstraint removeSelfReferencingConstraint() {\n        return remove(getSelfReferencingConstraint());\n    }\n\n    /**\n     * Remove the specified {@link ForeignKeyConstraint} from this table.<p>\n     *\n     * This is a more drastic removal solution that was proposed by Remke Rutgers\n     *\n     * @param constraint\n     */\n    private ForeignKeyConstraint remove(ForeignKeyConstraint constraint) {\n        if (constraint != null) {\n            for (int i = 0; i < constraint.getChildColumns().size(); i++) {\n                TableColumn childColumn = constraint.getChildColumns().get(i);\n                TableColumn parentColumn = constraint.getParentColumns().get(i);\n                childColumn.removeParent(parentColumn);\n                parentColumn.removeChild(childColumn);\n            }\n        }\n        return constraint;\n    }\n\n    /**\n     * Return a self referencing constraint if one exists\n     *\n     * @return\n     */\n    private ForeignKeyConstraint getSelfReferencingConstraint() {\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                if (compareTo(parentColumn.getTable()) == 0) {\n                    return column.getParentConstraint(parentColumn);\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Remove any non-real foreign keys\n     *\n     * @return\n     */\n    public List<ForeignKeyConstraint> removeNonRealForeignKeys() {\n        List<ForeignKeyConstraint> nonReals = new ArrayList<ForeignKeyConstraint>();\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                ForeignKeyConstraint constraint = column.getParentConstraint(parentColumn);\n                if (constraint != null && !constraint.isReal()) {\n                    nonReals.add(constraint);\n                }\n            }\n        }\n        // remove constraints outside of above loop to prevent\n        // concurrent modification exceptions while iterating\n        for (ForeignKeyConstraint constraint : nonReals) {\n            remove(constraint);\n        }\n        return nonReals;\n    }\n\n    /**\n     * Returns the number of tables that reference this table\n     *\n     * @return\n     */\n    public int getNumChildren() {\n        int numChildren = 0;\n        for (TableColumn column : columns.values()) {\n            numChildren += column.getChildren().size();\n        }\n        return numChildren;\n    }\n\n    /**\n     * Returns the number of non-implied children\n     * @return\n     */\n    public int getNumNonImpliedChildren() {\n        int numChildren = 0;\n        for (TableColumn column : columns.values()) {\n            for (TableColumn childColumn : column.getChildren()) {\n                if (!column.getChildConstraint(childColumn).isImplied())\n                    ++numChildren;\n            }\n        }\n        return numChildren;\n    }\n\n    /**\n     * Returns the number of tables that are referenced by this table\n     *\n     * @return\n     */\n    public int getNumParents() {\n        int numParents = 0;\n        for (TableColumn column : columns.values()) {\n            numParents += column.getParents().size();\n        }\n        return numParents;\n    }\n\n    /**\n     * Returns the number of non-implied parents\n     *\n     * @return\n     */\n    public int getNumNonImpliedParents() {\n        int numParents = 0;\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                if (!column.getParentConstraint(parentColumn).isImplied())\n                    ++numParents;\n            }\n        }\n        return numParents;\n    }\n\n    /**\n     * Remove one foreign key constraint.\n     *\n     * <p/>Used during dependency analysis phase.\n     *\n     * @return\n     */\n    public ForeignKeyConstraint removeAForeignKeyConstraint() {\n        @SuppressWarnings(\"hiding\")\n        final List<TableColumn> columns = getColumns();\n        int numParents = 0;\n        int numChildren = 0;\n        // remove either a child or parent, choosing which based on which has the\n        // least number of foreign key associations (when either gets to zero then\n        // the table can be pruned)\n        for (TableColumn column : columns) {\n            numParents += column.getParents().size();\n            numChildren += column.getChildren().size();\n        }\n        for (TableColumn column : columns) {\n            ForeignKeyConstraint constraint;\n            if (numParents <= numChildren)\n                constraint = column.removeAParentFKConstraint();\n            else\n                constraint = column.removeAChildFKConstraint();\n            if (constraint != null)\n                return constraint;\n        }\n        return null;\n    }\n\n    /**\n     * Returns <code>true</code> if this table is logical (not physical), <code>false</code> otherwise\n     * @return\n     */\n    public boolean isLogical() {\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if this is a view, <code>false</code> otherwise\n     *\n     * @return\n     */\n    public boolean isView() {\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if this table is remote (in another schema), <code>false</code> otherwise\n     * @return\n     */\n    public boolean isRemote() {\n        return false;\n    }\n\n    /**\n     * If this is a view it returns the SQL used to create the view (if it's available).\n     * <code>null</code> if it's not a view or the SQL isn't available.\n     * @return\n     * @see #isView()\n     */\n    public String getViewSql() {\n        return null;\n    }\n\n    /**\n     * Returns the number of rows contained in this table, or -1 if unable to determine\n     * the number of rows.\n     *\n     * @return\n     */\n    public long getNumRows() {\n        if (numRows == null) {\n            numRows = Config.getInstance().isNumRowsEnabled() ? fetchNumRows() : -1;\n        }\n        return numRows;\n    }\n\n    /**\n     * Explicitly set the number of rows in this table\n     *\n     * @param numRows\n     */\n    public void setNumRows(long numRows) {\n        this.numRows = numRows;\n    }\n\n    /**\n     * Fetch the number of rows contained in this table.\n     *\n     * returns -1 if unable to successfully fetch the row count\n     *\n     * @param db Database\n     * @return int\n     * @throws SQLException\n     */\n    protected long fetchNumRows() {\n        if (isView() || isRemote())\n            return -1;\n        SQLException originalFailure = null;\n        String sql = Config.getInstance().getDbProperties().getProperty(\"selectRowCountSql\");\n        if (sql != null) {\n            PreparedStatement stmt = null;\n            ResultSet rs = null;\n            try {\n                stmt = db.prepareStatement(sql, getName());\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    return rs.getLong(\"row_count\");\n                }\n            } catch (SQLException sqlException) {\n                // don't die just because this failed\n                originalFailure = sqlException;\n            } finally {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    } catch (SQLException exc) {\n                    }\n                }\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException exc) {\n                    }\n                }\n            }\n        }\n        // if we get here then we either didn't have custom SQL or it didn't work\n        try {\n            // '*' should work best for the majority of cases\n            return fetchNumRows(\"count(*)\", false);\n        } catch (SQLException try2Exception) {\n            try {\n                // except nested tables...try using '1' instead\n                return fetchNumRows(\"count(1)\", false);\n            } catch (SQLException try3Exception) {\n                if (!isLogical()) {\n                    logger.warning(\"Unable to extract the number of rows for table \" + getName() + \", using '-1'\");\n                    if (originalFailure != null)\n                        logger.warning(originalFailure.toString());\n                    logger.warning(try2Exception.toString());\n                    if (!String.valueOf(try2Exception.toString()).equals(try3Exception.toString()))\n                        logger.warning(try3Exception.toString());\n                }\n                return -1;\n            }\n        }\n    }\n\n    protected long fetchNumRows(String clause, boolean forceQuotes) throws SQLException {\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        StringBuilder sql = new StringBuilder(\"select \");\n        sql.append(clause);\n        sql.append(\" from \");\n        if (getSchema() != null) {\n            sql.append(getSchema());\n            sql.append('.');\n        } else if (getCatalog() != null) {\n            sql.append(getCatalog());\n            sql.append('.');\n        }\n        if (forceQuotes) {\n            String quote = db.getMetaData().getIdentifierQuoteString().trim();\n            sql.append(quote + getName() + quote);\n        } else\n            sql.append(db.getQuotedIdentifier(getName()));\n        try {\n            if (finerEnabled)\n                logger.finer(sql.toString());\n            stmt = db.getConnection().prepareStatement(sql.toString());\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                return rs.getLong(1);\n            }\n            return -1;\n        } catch (SQLException exc) {\n            if (// we tried with and w/o quotes...fail this attempt\n            forceQuotes)\n                throw exc;\n            return fetchNumRows(clause, true);\n        } finally {\n            if (rs != null)\n                rs.close();\n            if (stmt != null)\n                stmt.close();\n        }\n    }\n\n    /**\n     * Update the table with the specified XML-derived metadata\n     *\n     * @param tableMeta\n     */\n    public void update(TableMeta tableMeta) {\n        String newComments = tableMeta.getComments();\n        if (newComments != null) {\n            comments = newComments;\n        }\n        for (TableColumnMeta colMeta : tableMeta.getColumns()) {\n            TableColumn col = getColumn(colMeta.getName());\n            if (col == null) {\n                col = addColumn(colMeta);\n            }\n            // update the column with the changes\n            col.update(colMeta);\n        }\n    }\n\n    /**\n     * Same as {@link #connectForeignKeys(Map, Database, Properties)},\n     * but uses XML-based metadata\n     *\n     * @param tableMeta\n     * @param tables\n     */\n    public void connect(TableMeta tableMeta, Map<String, Table> tables) {\n        for (TableColumnMeta colMeta : tableMeta.getColumns()) {\n            TableColumn col = getColumn(colMeta.getName());\n            if (col != null) {\n                // go thru the new foreign key defs and associate them with our columns\n                for (ForeignKeyMeta fk : colMeta.getForeignKeys()) {\n                    Table parent;\n                    if (fk.getRemoteCatalog() != null || fk.getRemoteSchema() != null) {\n                        try {\n                            // adds if doesn't exist\n                            parent = db.addRemoteTable(fk.getRemoteCatalog(), fk.getRemoteSchema(), fk.getTableName(), getContainer(), true);\n                        } catch (SQLException exc) {\n                            parent = null;\n                        }\n                    } else {\n                        parent = tables.get(fk.getTableName());\n                    }\n                    if (parent != null) {\n                        TableColumn parentColumn = parent.getColumn(fk.getColumnName());\n                        if (parentColumn == null) {\n                            logger.warning(\"Undefined column '\" + parent.getName() + '.' + fk.getColumnName() + \"' referenced by '\" + col.getTable() + '.' + col + \"' in XML metadata\");\n                        } else {\n                            /**\n                             * Merely instantiating a foreign key constraint ties it\n                             * into its parent and child columns (& therefore their tables)\n                             */\n                            @SuppressWarnings(\"unused\")\n                            ForeignKeyConstraint unused = new ForeignKeyConstraint(parentColumn, col) {\n\n                                @Override\n                                public String getName() {\n                                    return \"Defined in XML\";\n                                }\n                            };\n                            // they forgot to say it was a primary key\n                            if (!parentColumn.isPrimary()) {\n                                logger.warning(\"Assuming \" + parentColumn.getTable() + '.' + parentColumn + \" is a primary key due to being referenced by \" + col.getTable() + '.' + col);\n                                parent.setPrimaryColumn(parentColumn);\n                            }\n                        }\n                    } else {\n                        logger.warning(\"Undefined table '\" + fk.getTableName() + \"' referenced by '\" + getName() + '.' + col.getName() + \"' in XML metadata\");\n                    }\n                }\n            } else {\n                logger.warning(\"Undefined column '\" + getName() + '.' + colMeta.getName() + \"' in XML metadata\");\n            }\n        }\n    }\n\n    @Override\n    public String toString() {\n        return getName();\n    }\n\n    /**\n     * Returns <code>true</code> if this table has no relationships\n     *\n     * @param withImpliedRelationships boolean\n     * @return boolean\n     */\n    public boolean isOrphan(boolean withImpliedRelationships) {\n        if (withImpliedRelationships)\n            return getMaxParents() == 0 && getMaxChildren() == 0;\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                if (!column.getParentConstraint(parentColumn).isImplied())\n                    return false;\n            }\n            for (TableColumn childColumn : column.getChildren()) {\n                if (!column.getChildConstraint(childColumn).isImplied())\n                    return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compare this table to another table.\n     * Results are based on 1: identity, 2: table name, 3: schema name<p/>\n     *\n     * This implementation was put in place to deal with analyzing multiple\n     * schemas that contain identically named tables.\n     *\n     * @see {@link Comparable#compareTo(Object)}\n     */\n    public int compareTo(Table other) {\n        if (// fast way out\n        other == this)\n            return 0;\n        return getFullName().compareToIgnoreCase(other.getFullName());\n    }\n\n    /**\n     * Implementation of {@link Comparator} that sorts {@link TableColumn}s\n     * by {@link TableColumn#getId() ID} (ignored if <code>null</code>)\n     * followed by {@link TableColumn#getName() Name}.\n     */\n    public static class ByColumnIdComparator implements Comparator<TableColumn> {\n\n        public int compare(TableColumn column1, TableColumn column2) {\n            Object id1 = column1.getId();\n            Object id2 = column2.getId();\n            if (id1 == null || id2 == null)\n                return column1.getName().compareToIgnoreCase(column2.getName());\n            if (id1 instanceof Number && id2 instanceof Number)\n                return ((Number) id1).intValue() - ((Number) id2).intValue();\n            return id1.toString().compareToIgnoreCase(id2.toString());\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableTest6.java",
		"test_prompt": "// TableTest6.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\nimport net.sourceforge.schemaspy.model.xml.TableMeta;\nimport net.sourceforge.schemaspy.util.CaseInsensitiveMap;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Table}.\n* It contains ten unit test cases for the {@link Table#isLogical()} method.\n*/\nclass TableTest6 {"
	},
	{
		"original_code": "// Table.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\nimport net.sourceforge.schemaspy.model.xml.TableMeta;\nimport net.sourceforge.schemaspy.util.CaseInsensitiveMap;\n\n/**\n * A <code>Table</code> is one of the basic building blocks of SchemaSpy\n * that knows everything about the database table's metadata.\n *\n * @author John Currier\n */\npublic class Table implements Comparable<Table> {\n\n    private final String catalog;\n\n    private final String schema;\n\n    private final String name;\n\n    private final String fullName;\n\n    private final String container;\n\n    protected final CaseInsensitiveMap<TableColumn> columns = new CaseInsensitiveMap<TableColumn>();\n\n    private final List<TableColumn> primaryKeys = new ArrayList<TableColumn>();\n\n    private final CaseInsensitiveMap<ForeignKeyConstraint> foreignKeys = new CaseInsensitiveMap<ForeignKeyConstraint>();\n\n    private final CaseInsensitiveMap<TableIndex> indexes = new CaseInsensitiveMap<TableIndex>();\n\n    private Object id;\n\n    private final Map<String, String> checkConstraints = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);\n\n    private Long numRows;\n\n    protected final Database db;\n\n    private String comments;\n\n    private int maxChildren;\n\n    private int maxParents;\n\n    private final static Logger logger = Logger.getLogger(Table.class.getName());\n\n    private final static boolean fineEnabled = logger.isLoggable(Level.FINE);\n\n    private final static boolean finerEnabled = logger.isLoggable(Level.FINER);\n\n    /**\n     * Construct a table that knows everything about the database table's metadata\n     *\n     * @param db\n     * @param catalog\n     * @param schema\n     * @param name\n     * @param comments\n     * @throws SQLException\n     */\n    public Table(Database db, String catalog, String schema, String name, String comments) throws SQLException {\n        this.db = db;\n        this.catalog = catalog;\n        this.schema = schema;\n        this.container = schema != null ? schema : catalog != null ? catalog : db.getName();\n        this.name = name;\n        this.fullName = getFullName(db.getName(), catalog, schema, name);\n        if (fineEnabled)\n            logger.fine(\"Creating \" + getClass().getSimpleName() + \" \" + fullName);\n        setComments(comments);\n        initColumns();\n        initIndexes();\n        initPrimaryKeys();\n    }\n\n    /**\n     * \"Connect\" all of this table's foreign keys to their referenced primary keys\n     * (and, in some cases, do the reverse as well).\n     *\n     * @param tables\n     * @throws SQLException\n     */\n    public void connectForeignKeys(Map<String, Table> tables) throws SQLException {\n        if (finerEnabled)\n            logger.finer(\"Connecting foreign keys to \" + getFullName());\n        ResultSet rs = null;\n        try {\n            // get our foreign keys that reference other tables' primary keys\n            rs = db.getMetaData().getImportedKeys(getCatalog(), getSchema(), getName());\n            while (rs.next()) {\n                addForeignKey(rs.getString(\"FK_NAME\"), rs.getString(\"FKCOLUMN_NAME\"), rs.getString(\"PKTABLE_CAT\"), rs.getString(\"PKTABLE_SCHEM\"), rs.getString(\"PKTABLE_NAME\"), rs.getString(\"PKCOLUMN_NAME\"), rs.getInt(\"UPDATE_RULE\"), rs.getInt(\"DELETE_RULE\"), tables);\n            }\n        } finally {\n            if (rs != null)\n                rs.close();\n        }\n        // also try to find all of the 'remote' tables in other schemas that\n        // point to our primary keys (not necessary in the normal case\n        // as we infer this from the opposite direction)\n        if (getSchema() != null || getCatalog() != null) {\n            try {\n                // get the foreign keys that reference our primary keys\n                rs = db.getMetaData().getExportedKeys(getCatalog(), getSchema(), getName());\n                while (rs.next()) {\n                    String otherCatalog = rs.getString(\"FKTABLE_CAT\");\n                    String otherSchema = rs.getString(\"FKTABLE_SCHEM\");\n                    if (!String.valueOf(getSchema()).equals(String.valueOf(otherSchema)) || !String.valueOf(getCatalog()).equals(String.valueOf(otherCatalog))) {\n                        db.addRemoteTable(otherCatalog, otherSchema, rs.getString(\"FKTABLE_NAME\"), getSchema(), false);\n                    }\n                }\n            } finally {\n                if (rs != null)\n                    rs.close();\n            }\n        }\n    }\n\n    /**\n     * Get the foreign keys associated with this table\n     *\n     * @return\n     */\n    public Collection<ForeignKeyConstraint> getForeignKeys() {\n        return Collections.unmodifiableCollection(foreignKeys.values());\n    }\n\n    /**\n     * Add a check constraint to the table\n     * (no real details, just name and textual representation)\n     *\n     * @param constraintName\n     * @param text\n     */\n    public void addCheckConstraint(String constraintName, String text) {\n        checkConstraints.put(constraintName, text);\n    }\n\n    /**\n     * @param rs ResultSet from {@link DatabaseMetaData#getImportedKeys(String, String, String)}\n     * rs.getString(\"FK_NAME\");\n     * rs.getString(\"FKCOLUMN_NAME\");\n     * rs.getString(\"PKTABLE_CAT\");\n     * rs.getString(\"PKTABLE_SCHEM\");\n     * rs.getString(\"PKTABLE_NAME\");\n     * rs.getString(\"PKCOLUMN_NAME\");\n     * @param tables Map\n     * @param db\n     * @throws SQLException\n     */\n    protected void addForeignKey(String fkName, String fkColName, String pkCatalog, String pkSchema, String pkTableName, String pkColName, int updateRule, int deleteRule, Map<String, Table> tables) throws SQLException {\n        if (fkName == null)\n            return;\n        Pattern include = Config.getInstance().getTableInclusions();\n        Pattern exclude = Config.getInstance().getTableExclusions();\n        if (!include.matcher(pkTableName).matches() || exclude.matcher(pkTableName).matches()) {\n            if (fineEnabled)\n                logger.fine(\"Ignoring \" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName) + \" referenced by FK \" + fkName);\n            return;\n        }\n        ForeignKeyConstraint foreignKey = foreignKeys.get(fkName);\n        if (foreignKey == null) {\n            foreignKey = new ForeignKeyConstraint(this, fkName, updateRule, deleteRule);\n            foreignKeys.put(fkName, foreignKey);\n        }\n        TableColumn childColumn = getColumn(fkColName);\n        if (childColumn != null) {\n            foreignKey.addChildColumn(childColumn);\n            Config config = Config.getInstance();\n            Table parentTable = tables.get(pkTableName);\n            String parentContainer = pkSchema != null ? pkSchema : pkCatalog != null ? pkCatalog : db.getName();\n            String baseContainer = config.getSchema() != null ? config.getSchema() : config.getCatalog() != null ? config.getCatalog() : db.getName();\n            // if named table doesn't exist in this schema\n            // or exists here but really referencing same named table in another schema\n            if (parentTable == null || !baseContainer.equals(parentContainer)) {\n                if (fineEnabled)\n                    logger.fine(\"Adding remote table \" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName));\n                parentTable = db.addRemoteTable(pkCatalog, pkSchema, pkTableName, baseContainer, false);\n            }\n            if (parentTable != null) {\n                TableColumn parentColumn = parentTable.getColumn(pkColName);\n                if (parentColumn != null) {\n                    foreignKey.addParentColumn(parentColumn);\n                    childColumn.addParent(parentColumn, foreignKey);\n                    parentColumn.addChild(childColumn, foreignKey);\n                } else {\n                    logger.warning(\"Couldn't add FK '\" + foreignKey.getName() + \"' to table '\" + this + \"' - Column '\" + pkColName + \"' doesn't exist in table '\" + parentTable + \"'\");\n                }\n            } else {\n                logger.warning(\"Couldn't add FK '\" + foreignKey.getName() + \"' to table '\" + this + \"' - Unknown Referenced Table '\" + pkTableName + \"'\");\n            }\n        } else {\n            logger.warning(\"Couldn't add FK '\" + foreignKey.getName() + \"' to table '\" + this + \"' - Column '\" + fkColName + \"' doesn't exist\");\n        }\n    }\n\n    /**\n     * @param meta\n     * @throws SQLException\n     */\n    private void initPrimaryKeys() throws SQLException {\n        ResultSet rs = null;\n        try {\n            if (fineEnabled)\n                logger.fine(\"Querying primary keys for \" + getFullName());\n            rs = db.getMetaData().getPrimaryKeys(getCatalog(), getSchema(), getName());\n            while (rs.next()) setPrimaryColumn(rs);\n        } catch (SQLException exc) {\n            if (!isLogical()) {\n                throw exc;\n            }\n        } finally {\n            if (rs != null)\n                rs.close();\n        }\n    }\n\n    /**\n     * @param rs\n     * @throws SQLException\n     */\n    private void setPrimaryColumn(ResultSet rs) throws SQLException {\n        String pkName = rs.getString(\"PK_NAME\");\n        if (pkName == null)\n            return;\n        TableIndex index = getIndex(pkName);\n        if (index != null) {\n            index.setIsPrimaryKey(true);\n        }\n        String columnName = rs.getString(\"COLUMN_NAME\");\n        setPrimaryColumn(getColumn(columnName));\n    }\n\n    /**\n     * @param primaryColumn\n     */\n    void setPrimaryColumn(TableColumn primaryColumn) {\n        primaryKeys.add(primaryColumn);\n    }\n\n    /**\n     * @throws SQLException\n     */\n    private void initColumns() throws SQLException {\n        ResultSet rs = null;\n        synchronized (Table.class) {\n            try {\n                rs = db.getMetaData().getColumns(getCatalog(), getSchema(), getName(), \"%\");\n                while (rs.next()) addColumn(rs);\n            } catch (SQLException exc) {\n                if (!isLogical()) {\n                    class ColumnInitializationFailure extends SQLException {\n\n                        private static final long serialVersionUID = 1L;\n\n                        public ColumnInitializationFailure(SQLException failure) {\n                            super(\"Failed to collect column details for \" + (isView() ? \"view\" : \"table\") + \" '\" + getName() + \"' in schema '\" + getContainer() + \"'\");\n                            initCause(failure);\n                        }\n                    }\n                    throw new ColumnInitializationFailure(exc);\n                }\n            } finally {\n                if (rs != null)\n                    rs.close();\n            }\n        }\n        initColumnAutoUpdate(false);\n    }\n\n    /**\n     * @param forceQuotes\n     * @throws SQLException\n     */\n    private void initColumnAutoUpdate(boolean forceQuotes) throws SQLException {\n        ResultSet rs = null;\n        PreparedStatement stmt = null;\n        if (isView() || isRemote())\n            return;\n        // we've got to get a result set with all the columns in it\n        // so we can ask if the columns are auto updated\n        // Ugh!!!  Should have been in DatabaseMetaData instead!!!\n        StringBuilder sql = new StringBuilder(\"select * from \");\n        if (getSchema() != null) {\n            sql.append(getSchema());\n            sql.append('.');\n        } else if (getCatalog() != null) {\n            sql.append(getCatalog());\n            sql.append('.');\n        }\n        if (forceQuotes) {\n            String quote = db.getMetaData().getIdentifierQuoteString().trim();\n            sql.append(quote + getName() + quote);\n        } else\n            sql.append(db.getQuotedIdentifier(getName()));\n        sql.append(\" where 0 = 1\");\n        try {\n            stmt = db.getMetaData().getConnection().prepareStatement(sql.toString());\n            rs = stmt.executeQuery();\n            ResultSetMetaData rsMeta = rs.getMetaData();\n            for (int i = rsMeta.getColumnCount(); i > 0; --i) {\n                TableColumn column = getColumn(rsMeta.getColumnName(i));\n                column.setIsAutoUpdated(rsMeta.isAutoIncrement(i));\n            }\n        } catch (SQLException exc) {\n            if (forceQuotes) {\n                if (!isLogical()) {\n                    // don't completely choke just because we couldn't do this....\n                    logger.warning(\"Failed to determine auto increment status: \" + exc);\n                    logger.warning(\"SQL: \" + sql.toString());\n                }\n            } else {\n                initColumnAutoUpdate(true);\n            }\n        } finally {\n            if (rs != null)\n                rs.close();\n            if (stmt != null)\n                stmt.close();\n        }\n    }\n\n    /**\n     * @param rs - from {@link DatabaseMetaData#getColumns(String, String, String, String)}\n     * @throws SQLException\n     */\n    protected void addColumn(ResultSet rs) throws SQLException {\n        String columnName = rs.getString(\"COLUMN_NAME\");\n        if (columnName == null)\n            return;\n        if (getColumn(columnName) == null) {\n            TableColumn column = new TableColumn(this, rs);\n            columns.put(column.getName(), column);\n        }\n    }\n\n    /**\n     * Add a column that's defined in xml metadata.\n     * Assumes that a column named colMeta.getName() doesn't already exist in <code>columns</code>.\n     * @param colMeta\n     * @return\n     */\n    protected TableColumn addColumn(TableColumnMeta colMeta) {\n        TableColumn column = new TableColumn(this, colMeta);\n        columns.put(column.getName(), column);\n        return column;\n    }\n\n    /**\n     * Initialize index information\n     *\n     * @throws SQLException\n     */\n    private void initIndexes() throws SQLException {\n        if (isView() || isRemote())\n            return;\n        // first try to initialize using the index query spec'd in the .properties\n        // do this first because some DB's (e.g. Oracle) do 'bad' things with getIndexInfo()\n        // (they try to do a DDL analyze command that has some bad side-effects)\n        if (initIndexes(Config.getInstance().getDbProperties().getProperty(\"selectIndexesSql\")))\n            return;\n        // couldn't, so try the old fashioned approach\n        ResultSet rs = null;\n        try {\n            rs = db.getMetaData().getIndexInfo(getCatalog(), getSchema(), getName(), false, true);\n            while (rs.next()) {\n                if (rs.getShort(\"TYPE\") != DatabaseMetaData.tableIndexStatistic)\n                    addIndex(rs);\n            }\n        } catch (SQLException exc) {\n            if (!isLogical())\n                logger.warning(\"Unable to extract index info for table '\" + getName() + \"' in schema '\" + getContainer() + \"': \" + exc);\n        } finally {\n            if (rs != null)\n                rs.close();\n        }\n    }\n\n    /**\n     * Try to initialize index information based on the specified SQL\n     *\n     * @return boolean <code>true</code> if it worked, otherwise <code>false</code>\n     */\n    private boolean initIndexes(String selectIndexesSql) {\n        if (selectIndexesSql == null)\n            return false;\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = db.prepareStatement(selectIndexesSql, getName());\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                if (rs.getShort(\"TYPE\") != DatabaseMetaData.tableIndexStatistic)\n                    addIndex(rs);\n            }\n        } catch (SQLException sqlException) {\n            logger.warning(\"Failed to query index information with SQL: \" + selectIndexesSql);\n            logger.warning(sqlException.toString());\n            return false;\n        } finally {\n            if (rs != null) {\n                try {\n                    rs.close();\n                } catch (Exception exc) {\n                    exc.printStackTrace();\n                }\n            }\n            if (stmt != null) {\n                try {\n                    stmt.close();\n                } catch (Exception exc) {\n                    exc.printStackTrace();\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @param indexName\n     * @return\n     */\n    public TableIndex getIndex(String indexName) {\n        return indexes.get(indexName);\n    }\n\n    /**\n     * @param rs\n     * @throws SQLException\n     */\n    private void addIndex(ResultSet rs) throws SQLException {\n        String indexName = rs.getString(\"INDEX_NAME\");\n        if (indexName == null)\n            return;\n        TableIndex index = getIndex(indexName);\n        if (index == null) {\n            index = new TableIndex(rs);\n            indexes.put(index.getName(), index);\n        }\n        index.addColumn(getColumn(rs.getString(\"COLUMN_NAME\")), rs.getString(\"ASC_OR_DESC\"));\n    }\n\n    /**\n     * Returns the catalog that the table belongs to\n     *\n     * @return\n     */\n    public String getCatalog() {\n        return catalog;\n    }\n\n    /**\n     * Returns the schema that the table belongs to\n     *\n     * @return\n     */\n    public String getSchema() {\n        return schema;\n    }\n\n    /**\n     * Returns the logical 'container' that the table\n     * lives in.  Basically it's the first non-<code>null</code>\n     * item out of <code>schema</code>, <code>catalog</code>\n     * and <code>database</code>.\n     *\n     * @return\n     */\n    public String getContainer() {\n        return container;\n    }\n\n    /**\n     * Returns the name of the table\n     *\n     * @return\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the fully-qualified name of this table\n     *\n     * @return\n     */\n    public String getFullName() {\n        return fullName;\n    }\n\n    /**\n     * Returns the fully-qualified name of a table\n     *\n     * @return\n     */\n    public static String getFullName(String db, String catalog, String schema, String table) {\n        String fullName = (catalog == null && schema == null ? db + '.' : \"\") + (catalog == null ? \"\" : catalog + '.') + (schema == null ? \"\" : schema + '.') + table;\n        return fullName;\n    }\n\n    /**\n     * Object IDs are useful for tables such as DB/2 that many times\n     * give error messages based on object ID and not name\n     *\n     * @param id\n     */\n    public void setId(Object id) {\n        this.id = id;\n    }\n\n    /**\n     * @see #setId(Object)\n     *\n     * @return\n     */\n    public Object getId() {\n        return id;\n    }\n\n    /**\n     * Returns the check constraints associated with this table\n     *\n     * @return\n     */\n    public Map<String, String> getCheckConstraints() {\n        return checkConstraints;\n    }\n\n    /**\n     * Returns the indexes that are applied to this table\n     *\n     * @return\n     */\n    public Set<TableIndex> getIndexes() {\n        return new HashSet<TableIndex>(indexes.values());\n    }\n\n    /**\n     * Returns a collection of table columns that have been identified as \"primary\"\n     *\n     * @return\n     */\n    public List<TableColumn> getPrimaryColumns() {\n        return primaryKeys;\n    }\n\n    /**\n     * @return Comments associated with this table, or <code>null</code> if none.\n     */\n    public String getComments() {\n        return comments;\n    }\n\n    /**\n     * Sets the comments that are associated with this table\n     *\n     * @param comments\n     */\n    public void setComments(String comments) {\n        String cmts = (comments == null || comments.trim().length() == 0) ? null : comments.trim();\n        // MySQL's InnoDB engine does some insane crap of storing erroneous details in\n        // with table comments.  Here I attempt to strip the \"crap\" out without impacting\n        // other databases.  Ideally this should happen in selectColumnCommentsSql (and\n        // therefore isolate it to MySQL), but it's a bit too complex to do cleanly.\n        if (cmts != null) {\n            int crapIndex = cmts.indexOf(\"; InnoDB free: \");\n            if (crapIndex == -1)\n                crapIndex = cmts.startsWith(\"InnoDB free: \") ? 0 : -1;\n            if (crapIndex != -1) {\n                cmts = cmts.substring(0, crapIndex).trim();\n                cmts = cmts.length() == 0 ? null : cmts;\n            }\n        }\n        this.comments = cmts;\n    }\n\n    /**\n     * Returns the {@link TableColumn} with the given name, or <code>null</code>\n     * if it doesn't exist\n     *\n     * @param columnName\n     * @return\n     */\n    public TableColumn getColumn(String columnName) {\n        return columns.get(columnName);\n    }\n\n    /**\n     * Returns <code>List</code> of <code>TableColumn</code>s in ascending column number order.\n     *\n     * @return\n     */\n    public List<TableColumn> getColumns() {\n        Set<TableColumn> sorted = new TreeSet<TableColumn>(new ByColumnIdComparator());\n        sorted.addAll(columns.values());\n        return new ArrayList<TableColumn>(sorted);\n    }\n\n    /**\n     * Returns <code>true</code> if this table references no other tables..<p/>\n     * Used in dependency analysis.\n     * @return\n     */\n    public boolean isRoot() {\n        for (TableColumn column : columns.values()) {\n            if (column.isForeignKey()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns <code>true</code> if this table is referenced by no other tables.<p/>\n     * Used in dependency analysis.\n     * @return\n     */\n    public boolean isLeaf() {\n        for (TableColumn column : columns.values()) {\n            if (!column.getChildren().isEmpty()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the maximum number of parents that this table has had before\n     * any had been removed during dependency analysis\n     *\n     * @return\n     */\n    public int getMaxParents() {\n        return maxParents;\n    }\n\n    /**\n     * Notification that's called to indicate that a parent has been added to\n     * this table\n     */\n    public void addedParent() {\n        maxParents++;\n    }\n\n    /**\n     * \"Unlink\" all of the parent tables from this table\n     */\n    public void unlinkParents() {\n        for (TableColumn column : columns.values()) {\n            column.unlinkParents();\n        }\n    }\n\n    /**\n     * Returns the maximum number of children that this table has had before\n     * any had been removed during dependency analysis\n     *\n     * @return\n     */\n    public int getMaxChildren() {\n        return maxChildren;\n    }\n\n    /**\n     * Notification that's called to indicate that a child has been added to\n     * this table\n     */\n    public void addedChild() {\n        maxChildren++;\n    }\n\n    /**\n     * \"Unlink\" all of the child tables from this table\n     */\n    public void unlinkChildren() {\n        for (TableColumn column : columns.values()) {\n            column.unlinkChildren();\n        }\n    }\n\n    /**\n     * Remove a single self referencing constraint if one exists.\n     *\n     * @return\n     */\n    public ForeignKeyConstraint removeSelfReferencingConstraint() {\n        return remove(getSelfReferencingConstraint());\n    }\n\n    /**\n     * Remove the specified {@link ForeignKeyConstraint} from this table.<p>\n     *\n     * This is a more drastic removal solution that was proposed by Remke Rutgers\n     *\n     * @param constraint\n     */\n    private ForeignKeyConstraint remove(ForeignKeyConstraint constraint) {\n        if (constraint != null) {\n            for (int i = 0; i < constraint.getChildColumns().size(); i++) {\n                TableColumn childColumn = constraint.getChildColumns().get(i);\n                TableColumn parentColumn = constraint.getParentColumns().get(i);\n                childColumn.removeParent(parentColumn);\n                parentColumn.removeChild(childColumn);\n            }\n        }\n        return constraint;\n    }\n\n    /**\n     * Return a self referencing constraint if one exists\n     *\n     * @return\n     */\n    private ForeignKeyConstraint getSelfReferencingConstraint() {\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                if (compareTo(parentColumn.getTable()) == 0) {\n                    return column.getParentConstraint(parentColumn);\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Remove any non-real foreign keys\n     *\n     * @return\n     */\n    public List<ForeignKeyConstraint> removeNonRealForeignKeys() {\n        List<ForeignKeyConstraint> nonReals = new ArrayList<ForeignKeyConstraint>();\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                ForeignKeyConstraint constraint = column.getParentConstraint(parentColumn);\n                if (constraint != null && !constraint.isReal()) {\n                    nonReals.add(constraint);\n                }\n            }\n        }\n        // remove constraints outside of above loop to prevent\n        // concurrent modification exceptions while iterating\n        for (ForeignKeyConstraint constraint : nonReals) {\n            remove(constraint);\n        }\n        return nonReals;\n    }\n\n    /**\n     * Returns the number of tables that reference this table\n     *\n     * @return\n     */\n    public int getNumChildren() {\n        int numChildren = 0;\n        for (TableColumn column : columns.values()) {\n            numChildren += column.getChildren().size();\n        }\n        return numChildren;\n    }\n\n    /**\n     * Returns the number of non-implied children\n     * @return\n     */\n    public int getNumNonImpliedChildren() {\n        int numChildren = 0;\n        for (TableColumn column : columns.values()) {\n            for (TableColumn childColumn : column.getChildren()) {\n                if (!column.getChildConstraint(childColumn).isImplied())\n                    ++numChildren;\n            }\n        }\n        return numChildren;\n    }\n\n    /**\n     * Returns the number of tables that are referenced by this table\n     *\n     * @return\n     */\n    public int getNumParents() {\n        int numParents = 0;\n        for (TableColumn column : columns.values()) {\n            numParents += column.getParents().size();\n        }\n        return numParents;\n    }\n\n    /**\n     * Returns the number of non-implied parents\n     *\n     * @return\n     */\n    public int getNumNonImpliedParents() {\n        int numParents = 0;\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                if (!column.getParentConstraint(parentColumn).isImplied())\n                    ++numParents;\n            }\n        }\n        return numParents;\n    }\n\n    /**\n     * Remove one foreign key constraint.\n     *\n     * <p/>Used during dependency analysis phase.\n     *\n     * @return\n     */\n    public ForeignKeyConstraint removeAForeignKeyConstraint() {\n        @SuppressWarnings(\"hiding\")\n        final List<TableColumn> columns = getColumns();\n        int numParents = 0;\n        int numChildren = 0;\n        // remove either a child or parent, choosing which based on which has the\n        // least number of foreign key associations (when either gets to zero then\n        // the table can be pruned)\n        for (TableColumn column : columns) {\n            numParents += column.getParents().size();\n            numChildren += column.getChildren().size();\n        }\n        for (TableColumn column : columns) {\n            ForeignKeyConstraint constraint;\n            if (numParents <= numChildren)\n                constraint = column.removeAParentFKConstraint();\n            else\n                constraint = column.removeAChildFKConstraint();\n            if (constraint != null)\n                return constraint;\n        }\n        return null;\n    }\n\n    /**\n     * Returns <code>true</code> if this table is logical (not physical), <code>false</code> otherwise\n     * @return\n     */\n    public boolean isLogical() {\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if this is a view, <code>false</code> otherwise\n     *\n     * @return\n     */\n    public boolean isView() {\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if this table is remote (in another schema), <code>false</code> otherwise\n     * @return\n     */\n    public boolean isRemote() {\n        return false;\n    }\n\n    /**\n     * If this is a view it returns the SQL used to create the view (if it's available).\n     * <code>null</code> if it's not a view or the SQL isn't available.\n     * @return\n     * @see #isView()\n     */\n    public String getViewSql() {\n        return null;\n    }\n\n    /**\n     * Returns the number of rows contained in this table, or -1 if unable to determine\n     * the number of rows.\n     *\n     * @return\n     */\n    public long getNumRows() {\n        if (numRows == null) {\n            numRows = Config.getInstance().isNumRowsEnabled() ? fetchNumRows() : -1;\n        }\n        return numRows;\n    }\n\n    /**\n     * Explicitly set the number of rows in this table\n     *\n     * @param numRows\n     */\n    public void setNumRows(long numRows) {\n        this.numRows = numRows;\n    }\n\n    /**\n     * Fetch the number of rows contained in this table.\n     *\n     * returns -1 if unable to successfully fetch the row count\n     *\n     * @param db Database\n     * @return int\n     * @throws SQLException\n     */\n    protected long fetchNumRows() {\n        if (isView() || isRemote())\n            return -1;\n        SQLException originalFailure = null;\n        String sql = Config.getInstance().getDbProperties().getProperty(\"selectRowCountSql\");\n        if (sql != null) {\n            PreparedStatement stmt = null;\n            ResultSet rs = null;\n            try {\n                stmt = db.prepareStatement(sql, getName());\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    return rs.getLong(\"row_count\");\n                }\n            } catch (SQLException sqlException) {\n                // don't die just because this failed\n                originalFailure = sqlException;\n            } finally {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    } catch (SQLException exc) {\n                    }\n                }\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException exc) {\n                    }\n                }\n            }\n        }\n        // if we get here then we either didn't have custom SQL or it didn't work\n        try {\n            // '*' should work best for the majority of cases\n            return fetchNumRows(\"count(*)\", false);\n        } catch (SQLException try2Exception) {\n            try {\n                // except nested tables...try using '1' instead\n                return fetchNumRows(\"count(1)\", false);\n            } catch (SQLException try3Exception) {\n                if (!isLogical()) {\n                    logger.warning(\"Unable to extract the number of rows for table \" + getName() + \", using '-1'\");\n                    if (originalFailure != null)\n                        logger.warning(originalFailure.toString());\n                    logger.warning(try2Exception.toString());\n                    if (!String.valueOf(try2Exception.toString()).equals(try3Exception.toString()))\n                        logger.warning(try3Exception.toString());\n                }\n                return -1;\n            }\n        }\n    }\n\n    protected long fetchNumRows(String clause, boolean forceQuotes) throws SQLException {\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        StringBuilder sql = new StringBuilder(\"select \");\n        sql.append(clause);\n        sql.append(\" from \");\n        if (getSchema() != null) {\n            sql.append(getSchema());\n            sql.append('.');\n        } else if (getCatalog() != null) {\n            sql.append(getCatalog());\n            sql.append('.');\n        }\n        if (forceQuotes) {\n            String quote = db.getMetaData().getIdentifierQuoteString().trim();\n            sql.append(quote + getName() + quote);\n        } else\n            sql.append(db.getQuotedIdentifier(getName()));\n        try {\n            if (finerEnabled)\n                logger.finer(sql.toString());\n            stmt = db.getConnection().prepareStatement(sql.toString());\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                return rs.getLong(1);\n            }\n            return -1;\n        } catch (SQLException exc) {\n            if (// we tried with and w/o quotes...fail this attempt\n            forceQuotes)\n                throw exc;\n            return fetchNumRows(clause, true);\n        } finally {\n            if (rs != null)\n                rs.close();\n            if (stmt != null)\n                stmt.close();\n        }\n    }\n\n    /**\n     * Update the table with the specified XML-derived metadata\n     *\n     * @param tableMeta\n     */\n    public void update(TableMeta tableMeta) {\n        String newComments = tableMeta.getComments();\n        if (newComments != null) {\n            comments = newComments;\n        }\n        for (TableColumnMeta colMeta : tableMeta.getColumns()) {\n            TableColumn col = getColumn(colMeta.getName());\n            if (col == null) {\n                col = addColumn(colMeta);\n            }\n            // update the column with the changes\n            col.update(colMeta);\n        }\n    }\n\n    /**\n     * Same as {@link #connectForeignKeys(Map, Database, Properties)},\n     * but uses XML-based metadata\n     *\n     * @param tableMeta\n     * @param tables\n     */\n    public void connect(TableMeta tableMeta, Map<String, Table> tables) {\n        for (TableColumnMeta colMeta : tableMeta.getColumns()) {\n            TableColumn col = getColumn(colMeta.getName());\n            if (col != null) {\n                // go thru the new foreign key defs and associate them with our columns\n                for (ForeignKeyMeta fk : colMeta.getForeignKeys()) {\n                    Table parent;\n                    if (fk.getRemoteCatalog() != null || fk.getRemoteSchema() != null) {\n                        try {\n                            // adds if doesn't exist\n                            parent = db.addRemoteTable(fk.getRemoteCatalog(), fk.getRemoteSchema(), fk.getTableName(), getContainer(), true);\n                        } catch (SQLException exc) {\n                            parent = null;\n                        }\n                    } else {\n                        parent = tables.get(fk.getTableName());\n                    }\n                    if (parent != null) {\n                        TableColumn parentColumn = parent.getColumn(fk.getColumnName());\n                        if (parentColumn == null) {\n                            logger.warning(\"Undefined column '\" + parent.getName() + '.' + fk.getColumnName() + \"' referenced by '\" + col.getTable() + '.' + col + \"' in XML metadata\");\n                        } else {\n                            /**\n                             * Merely instantiating a foreign key constraint ties it\n                             * into its parent and child columns (& therefore their tables)\n                             */\n                            @SuppressWarnings(\"unused\")\n                            ForeignKeyConstraint unused = new ForeignKeyConstraint(parentColumn, col) {\n\n                                @Override\n                                public String getName() {\n                                    return \"Defined in XML\";\n                                }\n                            };\n                            // they forgot to say it was a primary key\n                            if (!parentColumn.isPrimary()) {\n                                logger.warning(\"Assuming \" + parentColumn.getTable() + '.' + parentColumn + \" is a primary key due to being referenced by \" + col.getTable() + '.' + col);\n                                parent.setPrimaryColumn(parentColumn);\n                            }\n                        }\n                    } else {\n                        logger.warning(\"Undefined table '\" + fk.getTableName() + \"' referenced by '\" + getName() + '.' + col.getName() + \"' in XML metadata\");\n                    }\n                }\n            } else {\n                logger.warning(\"Undefined column '\" + getName() + '.' + colMeta.getName() + \"' in XML metadata\");\n            }\n        }\n    }\n\n    @Override\n    public String toString() {\n        return getName();\n    }\n\n    /**\n     * Returns <code>true</code> if this table has no relationships\n     *\n     * @param withImpliedRelationships boolean\n     * @return boolean\n     */\n    public boolean isOrphan(boolean withImpliedRelationships) {\n        if (withImpliedRelationships)\n            return getMaxParents() == 0 && getMaxChildren() == 0;\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                if (!column.getParentConstraint(parentColumn).isImplied())\n                    return false;\n            }\n            for (TableColumn childColumn : column.getChildren()) {\n                if (!column.getChildConstraint(childColumn).isImplied())\n                    return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compare this table to another table.\n     * Results are based on 1: identity, 2: table name, 3: schema name<p/>\n     *\n     * This implementation was put in place to deal with analyzing multiple\n     * schemas that contain identically named tables.\n     *\n     * @see {@link Comparable#compareTo(Object)}\n     */\n    public int compareTo(Table other) {\n        if (// fast way out\n        other == this)\n            return 0;\n        return getFullName().compareToIgnoreCase(other.getFullName());\n    }\n\n    /**\n     * Implementation of {@link Comparator} that sorts {@link TableColumn}s\n     * by {@link TableColumn#getId() ID} (ignored if <code>null</code>)\n     * followed by {@link TableColumn#getName() Name}.\n     */\n    public static class ByColumnIdComparator implements Comparator<TableColumn> {\n\n        public int compare(TableColumn column1, TableColumn column2) {\n            Object id1 = column1.getId();\n            Object id2 = column2.getId();\n            if (id1 == null || id2 == null)\n                return column1.getName().compareToIgnoreCase(column2.getName());\n            if (id1 instanceof Number && id2 instanceof Number)\n                return ((Number) id1).intValue() - ((Number) id2).intValue();\n            return id1.toString().compareToIgnoreCase(id2.toString());\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableTest7.java",
		"test_prompt": "// TableTest7.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\nimport net.sourceforge.schemaspy.model.xml.TableMeta;\nimport net.sourceforge.schemaspy.util.CaseInsensitiveMap;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Table}.\n* It contains ten unit test cases for the {@link Table#isView()} method.\n*/\nclass TableTest7 {"
	},
	{
		"original_code": "// Table.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\nimport net.sourceforge.schemaspy.model.xml.TableMeta;\nimport net.sourceforge.schemaspy.util.CaseInsensitiveMap;\n\n/**\n * A <code>Table</code> is one of the basic building blocks of SchemaSpy\n * that knows everything about the database table's metadata.\n *\n * @author John Currier\n */\npublic class Table implements Comparable<Table> {\n\n    private final String catalog;\n\n    private final String schema;\n\n    private final String name;\n\n    private final String fullName;\n\n    private final String container;\n\n    protected final CaseInsensitiveMap<TableColumn> columns = new CaseInsensitiveMap<TableColumn>();\n\n    private final List<TableColumn> primaryKeys = new ArrayList<TableColumn>();\n\n    private final CaseInsensitiveMap<ForeignKeyConstraint> foreignKeys = new CaseInsensitiveMap<ForeignKeyConstraint>();\n\n    private final CaseInsensitiveMap<TableIndex> indexes = new CaseInsensitiveMap<TableIndex>();\n\n    private Object id;\n\n    private final Map<String, String> checkConstraints = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);\n\n    private Long numRows;\n\n    protected final Database db;\n\n    private String comments;\n\n    private int maxChildren;\n\n    private int maxParents;\n\n    private final static Logger logger = Logger.getLogger(Table.class.getName());\n\n    private final static boolean fineEnabled = logger.isLoggable(Level.FINE);\n\n    private final static boolean finerEnabled = logger.isLoggable(Level.FINER);\n\n    /**\n     * Construct a table that knows everything about the database table's metadata\n     *\n     * @param db\n     * @param catalog\n     * @param schema\n     * @param name\n     * @param comments\n     * @throws SQLException\n     */\n    public Table(Database db, String catalog, String schema, String name, String comments) throws SQLException {\n        this.db = db;\n        this.catalog = catalog;\n        this.schema = schema;\n        this.container = schema != null ? schema : catalog != null ? catalog : db.getName();\n        this.name = name;\n        this.fullName = getFullName(db.getName(), catalog, schema, name);\n        if (fineEnabled)\n            logger.fine(\"Creating \" + getClass().getSimpleName() + \" \" + fullName);\n        setComments(comments);\n        initColumns();\n        initIndexes();\n        initPrimaryKeys();\n    }\n\n    /**\n     * \"Connect\" all of this table's foreign keys to their referenced primary keys\n     * (and, in some cases, do the reverse as well).\n     *\n     * @param tables\n     * @throws SQLException\n     */\n    public void connectForeignKeys(Map<String, Table> tables) throws SQLException {\n        if (finerEnabled)\n            logger.finer(\"Connecting foreign keys to \" + getFullName());\n        ResultSet rs = null;\n        try {\n            // get our foreign keys that reference other tables' primary keys\n            rs = db.getMetaData().getImportedKeys(getCatalog(), getSchema(), getName());\n            while (rs.next()) {\n                addForeignKey(rs.getString(\"FK_NAME\"), rs.getString(\"FKCOLUMN_NAME\"), rs.getString(\"PKTABLE_CAT\"), rs.getString(\"PKTABLE_SCHEM\"), rs.getString(\"PKTABLE_NAME\"), rs.getString(\"PKCOLUMN_NAME\"), rs.getInt(\"UPDATE_RULE\"), rs.getInt(\"DELETE_RULE\"), tables);\n            }\n        } finally {\n            if (rs != null)\n                rs.close();\n        }\n        // also try to find all of the 'remote' tables in other schemas that\n        // point to our primary keys (not necessary in the normal case\n        // as we infer this from the opposite direction)\n        if (getSchema() != null || getCatalog() != null) {\n            try {\n                // get the foreign keys that reference our primary keys\n                rs = db.getMetaData().getExportedKeys(getCatalog(), getSchema(), getName());\n                while (rs.next()) {\n                    String otherCatalog = rs.getString(\"FKTABLE_CAT\");\n                    String otherSchema = rs.getString(\"FKTABLE_SCHEM\");\n                    if (!String.valueOf(getSchema()).equals(String.valueOf(otherSchema)) || !String.valueOf(getCatalog()).equals(String.valueOf(otherCatalog))) {\n                        db.addRemoteTable(otherCatalog, otherSchema, rs.getString(\"FKTABLE_NAME\"), getSchema(), false);\n                    }\n                }\n            } finally {\n                if (rs != null)\n                    rs.close();\n            }\n        }\n    }\n\n    /**\n     * Get the foreign keys associated with this table\n     *\n     * @return\n     */\n    public Collection<ForeignKeyConstraint> getForeignKeys() {\n        return Collections.unmodifiableCollection(foreignKeys.values());\n    }\n\n    /**\n     * Add a check constraint to the table\n     * (no real details, just name and textual representation)\n     *\n     * @param constraintName\n     * @param text\n     */\n    public void addCheckConstraint(String constraintName, String text) {\n        checkConstraints.put(constraintName, text);\n    }\n\n    /**\n     * @param rs ResultSet from {@link DatabaseMetaData#getImportedKeys(String, String, String)}\n     * rs.getString(\"FK_NAME\");\n     * rs.getString(\"FKCOLUMN_NAME\");\n     * rs.getString(\"PKTABLE_CAT\");\n     * rs.getString(\"PKTABLE_SCHEM\");\n     * rs.getString(\"PKTABLE_NAME\");\n     * rs.getString(\"PKCOLUMN_NAME\");\n     * @param tables Map\n     * @param db\n     * @throws SQLException\n     */\n    protected void addForeignKey(String fkName, String fkColName, String pkCatalog, String pkSchema, String pkTableName, String pkColName, int updateRule, int deleteRule, Map<String, Table> tables) throws SQLException {\n        if (fkName == null)\n            return;\n        Pattern include = Config.getInstance().getTableInclusions();\n        Pattern exclude = Config.getInstance().getTableExclusions();\n        if (!include.matcher(pkTableName).matches() || exclude.matcher(pkTableName).matches()) {\n            if (fineEnabled)\n                logger.fine(\"Ignoring \" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName) + \" referenced by FK \" + fkName);\n            return;\n        }\n        ForeignKeyConstraint foreignKey = foreignKeys.get(fkName);\n        if (foreignKey == null) {\n            foreignKey = new ForeignKeyConstraint(this, fkName, updateRule, deleteRule);\n            foreignKeys.put(fkName, foreignKey);\n        }\n        TableColumn childColumn = getColumn(fkColName);\n        if (childColumn != null) {\n            foreignKey.addChildColumn(childColumn);\n            Config config = Config.getInstance();\n            Table parentTable = tables.get(pkTableName);\n            String parentContainer = pkSchema != null ? pkSchema : pkCatalog != null ? pkCatalog : db.getName();\n            String baseContainer = config.getSchema() != null ? config.getSchema() : config.getCatalog() != null ? config.getCatalog() : db.getName();\n            // if named table doesn't exist in this schema\n            // or exists here but really referencing same named table in another schema\n            if (parentTable == null || !baseContainer.equals(parentContainer)) {\n                if (fineEnabled)\n                    logger.fine(\"Adding remote table \" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName));\n                parentTable = db.addRemoteTable(pkCatalog, pkSchema, pkTableName, baseContainer, false);\n            }\n            if (parentTable != null) {\n                TableColumn parentColumn = parentTable.getColumn(pkColName);\n                if (parentColumn != null) {\n                    foreignKey.addParentColumn(parentColumn);\n                    childColumn.addParent(parentColumn, foreignKey);\n                    parentColumn.addChild(childColumn, foreignKey);\n                } else {\n                    logger.warning(\"Couldn't add FK '\" + foreignKey.getName() + \"' to table '\" + this + \"' - Column '\" + pkColName + \"' doesn't exist in table '\" + parentTable + \"'\");\n                }\n            } else {\n                logger.warning(\"Couldn't add FK '\" + foreignKey.getName() + \"' to table '\" + this + \"' - Unknown Referenced Table '\" + pkTableName + \"'\");\n            }\n        } else {\n            logger.warning(\"Couldn't add FK '\" + foreignKey.getName() + \"' to table '\" + this + \"' - Column '\" + fkColName + \"' doesn't exist\");\n        }\n    }\n\n    /**\n     * @param meta\n     * @throws SQLException\n     */\n    private void initPrimaryKeys() throws SQLException {\n        ResultSet rs = null;\n        try {\n            if (fineEnabled)\n                logger.fine(\"Querying primary keys for \" + getFullName());\n            rs = db.getMetaData().getPrimaryKeys(getCatalog(), getSchema(), getName());\n            while (rs.next()) setPrimaryColumn(rs);\n        } catch (SQLException exc) {\n            if (!isLogical()) {\n                throw exc;\n            }\n        } finally {\n            if (rs != null)\n                rs.close();\n        }\n    }\n\n    /**\n     * @param rs\n     * @throws SQLException\n     */\n    private void setPrimaryColumn(ResultSet rs) throws SQLException {\n        String pkName = rs.getString(\"PK_NAME\");\n        if (pkName == null)\n            return;\n        TableIndex index = getIndex(pkName);\n        if (index != null) {\n            index.setIsPrimaryKey(true);\n        }\n        String columnName = rs.getString(\"COLUMN_NAME\");\n        setPrimaryColumn(getColumn(columnName));\n    }\n\n    /**\n     * @param primaryColumn\n     */\n    void setPrimaryColumn(TableColumn primaryColumn) {\n        primaryKeys.add(primaryColumn);\n    }\n\n    /**\n     * @throws SQLException\n     */\n    private void initColumns() throws SQLException {\n        ResultSet rs = null;\n        synchronized (Table.class) {\n            try {\n                rs = db.getMetaData().getColumns(getCatalog(), getSchema(), getName(), \"%\");\n                while (rs.next()) addColumn(rs);\n            } catch (SQLException exc) {\n                if (!isLogical()) {\n                    class ColumnInitializationFailure extends SQLException {\n\n                        private static final long serialVersionUID = 1L;\n\n                        public ColumnInitializationFailure(SQLException failure) {\n                            super(\"Failed to collect column details for \" + (isView() ? \"view\" : \"table\") + \" '\" + getName() + \"' in schema '\" + getContainer() + \"'\");\n                            initCause(failure);\n                        }\n                    }\n                    throw new ColumnInitializationFailure(exc);\n                }\n            } finally {\n                if (rs != null)\n                    rs.close();\n            }\n        }\n        initColumnAutoUpdate(false);\n    }\n\n    /**\n     * @param forceQuotes\n     * @throws SQLException\n     */\n    private void initColumnAutoUpdate(boolean forceQuotes) throws SQLException {\n        ResultSet rs = null;\n        PreparedStatement stmt = null;\n        if (isView() || isRemote())\n            return;\n        // we've got to get a result set with all the columns in it\n        // so we can ask if the columns are auto updated\n        // Ugh!!!  Should have been in DatabaseMetaData instead!!!\n        StringBuilder sql = new StringBuilder(\"select * from \");\n        if (getSchema() != null) {\n            sql.append(getSchema());\n            sql.append('.');\n        } else if (getCatalog() != null) {\n            sql.append(getCatalog());\n            sql.append('.');\n        }\n        if (forceQuotes) {\n            String quote = db.getMetaData().getIdentifierQuoteString().trim();\n            sql.append(quote + getName() + quote);\n        } else\n            sql.append(db.getQuotedIdentifier(getName()));\n        sql.append(\" where 0 = 1\");\n        try {\n            stmt = db.getMetaData().getConnection().prepareStatement(sql.toString());\n            rs = stmt.executeQuery();\n            ResultSetMetaData rsMeta = rs.getMetaData();\n            for (int i = rsMeta.getColumnCount(); i > 0; --i) {\n                TableColumn column = getColumn(rsMeta.getColumnName(i));\n                column.setIsAutoUpdated(rsMeta.isAutoIncrement(i));\n            }\n        } catch (SQLException exc) {\n            if (forceQuotes) {\n                if (!isLogical()) {\n                    // don't completely choke just because we couldn't do this....\n                    logger.warning(\"Failed to determine auto increment status: \" + exc);\n                    logger.warning(\"SQL: \" + sql.toString());\n                }\n            } else {\n                initColumnAutoUpdate(true);\n            }\n        } finally {\n            if (rs != null)\n                rs.close();\n            if (stmt != null)\n                stmt.close();\n        }\n    }\n\n    /**\n     * @param rs - from {@link DatabaseMetaData#getColumns(String, String, String, String)}\n     * @throws SQLException\n     */\n    protected void addColumn(ResultSet rs) throws SQLException {\n        String columnName = rs.getString(\"COLUMN_NAME\");\n        if (columnName == null)\n            return;\n        if (getColumn(columnName) == null) {\n            TableColumn column = new TableColumn(this, rs);\n            columns.put(column.getName(), column);\n        }\n    }\n\n    /**\n     * Add a column that's defined in xml metadata.\n     * Assumes that a column named colMeta.getName() doesn't already exist in <code>columns</code>.\n     * @param colMeta\n     * @return\n     */\n    protected TableColumn addColumn(TableColumnMeta colMeta) {\n        TableColumn column = new TableColumn(this, colMeta);\n        columns.put(column.getName(), column);\n        return column;\n    }\n\n    /**\n     * Initialize index information\n     *\n     * @throws SQLException\n     */\n    private void initIndexes() throws SQLException {\n        if (isView() || isRemote())\n            return;\n        // first try to initialize using the index query spec'd in the .properties\n        // do this first because some DB's (e.g. Oracle) do 'bad' things with getIndexInfo()\n        // (they try to do a DDL analyze command that has some bad side-effects)\n        if (initIndexes(Config.getInstance().getDbProperties().getProperty(\"selectIndexesSql\")))\n            return;\n        // couldn't, so try the old fashioned approach\n        ResultSet rs = null;\n        try {\n            rs = db.getMetaData().getIndexInfo(getCatalog(), getSchema(), getName(), false, true);\n            while (rs.next()) {\n                if (rs.getShort(\"TYPE\") != DatabaseMetaData.tableIndexStatistic)\n                    addIndex(rs);\n            }\n        } catch (SQLException exc) {\n            if (!isLogical())\n                logger.warning(\"Unable to extract index info for table '\" + getName() + \"' in schema '\" + getContainer() + \"': \" + exc);\n        } finally {\n            if (rs != null)\n                rs.close();\n        }\n    }\n\n    /**\n     * Try to initialize index information based on the specified SQL\n     *\n     * @return boolean <code>true</code> if it worked, otherwise <code>false</code>\n     */\n    private boolean initIndexes(String selectIndexesSql) {\n        if (selectIndexesSql == null)\n            return false;\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = db.prepareStatement(selectIndexesSql, getName());\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                if (rs.getShort(\"TYPE\") != DatabaseMetaData.tableIndexStatistic)\n                    addIndex(rs);\n            }\n        } catch (SQLException sqlException) {\n            logger.warning(\"Failed to query index information with SQL: \" + selectIndexesSql);\n            logger.warning(sqlException.toString());\n            return false;\n        } finally {\n            if (rs != null) {\n                try {\n                    rs.close();\n                } catch (Exception exc) {\n                    exc.printStackTrace();\n                }\n            }\n            if (stmt != null) {\n                try {\n                    stmt.close();\n                } catch (Exception exc) {\n                    exc.printStackTrace();\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @param indexName\n     * @return\n     */\n    public TableIndex getIndex(String indexName) {\n        return indexes.get(indexName);\n    }\n\n    /**\n     * @param rs\n     * @throws SQLException\n     */\n    private void addIndex(ResultSet rs) throws SQLException {\n        String indexName = rs.getString(\"INDEX_NAME\");\n        if (indexName == null)\n            return;\n        TableIndex index = getIndex(indexName);\n        if (index == null) {\n            index = new TableIndex(rs);\n            indexes.put(index.getName(), index);\n        }\n        index.addColumn(getColumn(rs.getString(\"COLUMN_NAME\")), rs.getString(\"ASC_OR_DESC\"));\n    }\n\n    /**\n     * Returns the catalog that the table belongs to\n     *\n     * @return\n     */\n    public String getCatalog() {\n        return catalog;\n    }\n\n    /**\n     * Returns the schema that the table belongs to\n     *\n     * @return\n     */\n    public String getSchema() {\n        return schema;\n    }\n\n    /**\n     * Returns the logical 'container' that the table\n     * lives in.  Basically it's the first non-<code>null</code>\n     * item out of <code>schema</code>, <code>catalog</code>\n     * and <code>database</code>.\n     *\n     * @return\n     */\n    public String getContainer() {\n        return container;\n    }\n\n    /**\n     * Returns the name of the table\n     *\n     * @return\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the fully-qualified name of this table\n     *\n     * @return\n     */\n    public String getFullName() {\n        return fullName;\n    }\n\n    /**\n     * Returns the fully-qualified name of a table\n     *\n     * @return\n     */\n    public static String getFullName(String db, String catalog, String schema, String table) {\n        String fullName = (catalog == null && schema == null ? db + '.' : \"\") + (catalog == null ? \"\" : catalog + '.') + (schema == null ? \"\" : schema + '.') + table;\n        return fullName;\n    }\n\n    /**\n     * Object IDs are useful for tables such as DB/2 that many times\n     * give error messages based on object ID and not name\n     *\n     * @param id\n     */\n    public void setId(Object id) {\n        this.id = id;\n    }\n\n    /**\n     * @see #setId(Object)\n     *\n     * @return\n     */\n    public Object getId() {\n        return id;\n    }\n\n    /**\n     * Returns the check constraints associated with this table\n     *\n     * @return\n     */\n    public Map<String, String> getCheckConstraints() {\n        return checkConstraints;\n    }\n\n    /**\n     * Returns the indexes that are applied to this table\n     *\n     * @return\n     */\n    public Set<TableIndex> getIndexes() {\n        return new HashSet<TableIndex>(indexes.values());\n    }\n\n    /**\n     * Returns a collection of table columns that have been identified as \"primary\"\n     *\n     * @return\n     */\n    public List<TableColumn> getPrimaryColumns() {\n        return primaryKeys;\n    }\n\n    /**\n     * @return Comments associated with this table, or <code>null</code> if none.\n     */\n    public String getComments() {\n        return comments;\n    }\n\n    /**\n     * Sets the comments that are associated with this table\n     *\n     * @param comments\n     */\n    public void setComments(String comments) {\n        String cmts = (comments == null || comments.trim().length() == 0) ? null : comments.trim();\n        // MySQL's InnoDB engine does some insane crap of storing erroneous details in\n        // with table comments.  Here I attempt to strip the \"crap\" out without impacting\n        // other databases.  Ideally this should happen in selectColumnCommentsSql (and\n        // therefore isolate it to MySQL), but it's a bit too complex to do cleanly.\n        if (cmts != null) {\n            int crapIndex = cmts.indexOf(\"; InnoDB free: \");\n            if (crapIndex == -1)\n                crapIndex = cmts.startsWith(\"InnoDB free: \") ? 0 : -1;\n            if (crapIndex != -1) {\n                cmts = cmts.substring(0, crapIndex).trim();\n                cmts = cmts.length() == 0 ? null : cmts;\n            }\n        }\n        this.comments = cmts;\n    }\n\n    /**\n     * Returns the {@link TableColumn} with the given name, or <code>null</code>\n     * if it doesn't exist\n     *\n     * @param columnName\n     * @return\n     */\n    public TableColumn getColumn(String columnName) {\n        return columns.get(columnName);\n    }\n\n    /**\n     * Returns <code>List</code> of <code>TableColumn</code>s in ascending column number order.\n     *\n     * @return\n     */\n    public List<TableColumn> getColumns() {\n        Set<TableColumn> sorted = new TreeSet<TableColumn>(new ByColumnIdComparator());\n        sorted.addAll(columns.values());\n        return new ArrayList<TableColumn>(sorted);\n    }\n\n    /**\n     * Returns <code>true</code> if this table references no other tables..<p/>\n     * Used in dependency analysis.\n     * @return\n     */\n    public boolean isRoot() {\n        for (TableColumn column : columns.values()) {\n            if (column.isForeignKey()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns <code>true</code> if this table is referenced by no other tables.<p/>\n     * Used in dependency analysis.\n     * @return\n     */\n    public boolean isLeaf() {\n        for (TableColumn column : columns.values()) {\n            if (!column.getChildren().isEmpty()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the maximum number of parents that this table has had before\n     * any had been removed during dependency analysis\n     *\n     * @return\n     */\n    public int getMaxParents() {\n        return maxParents;\n    }\n\n    /**\n     * Notification that's called to indicate that a parent has been added to\n     * this table\n     */\n    public void addedParent() {\n        maxParents++;\n    }\n\n    /**\n     * \"Unlink\" all of the parent tables from this table\n     */\n    public void unlinkParents() {\n        for (TableColumn column : columns.values()) {\n            column.unlinkParents();\n        }\n    }\n\n    /**\n     * Returns the maximum number of children that this table has had before\n     * any had been removed during dependency analysis\n     *\n     * @return\n     */\n    public int getMaxChildren() {\n        return maxChildren;\n    }\n\n    /**\n     * Notification that's called to indicate that a child has been added to\n     * this table\n     */\n    public void addedChild() {\n        maxChildren++;\n    }\n\n    /**\n     * \"Unlink\" all of the child tables from this table\n     */\n    public void unlinkChildren() {\n        for (TableColumn column : columns.values()) {\n            column.unlinkChildren();\n        }\n    }\n\n    /**\n     * Remove a single self referencing constraint if one exists.\n     *\n     * @return\n     */\n    public ForeignKeyConstraint removeSelfReferencingConstraint() {\n        return remove(getSelfReferencingConstraint());\n    }\n\n    /**\n     * Remove the specified {@link ForeignKeyConstraint} from this table.<p>\n     *\n     * This is a more drastic removal solution that was proposed by Remke Rutgers\n     *\n     * @param constraint\n     */\n    private ForeignKeyConstraint remove(ForeignKeyConstraint constraint) {\n        if (constraint != null) {\n            for (int i = 0; i < constraint.getChildColumns().size(); i++) {\n                TableColumn childColumn = constraint.getChildColumns().get(i);\n                TableColumn parentColumn = constraint.getParentColumns().get(i);\n                childColumn.removeParent(parentColumn);\n                parentColumn.removeChild(childColumn);\n            }\n        }\n        return constraint;\n    }\n\n    /**\n     * Return a self referencing constraint if one exists\n     *\n     * @return\n     */\n    private ForeignKeyConstraint getSelfReferencingConstraint() {\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                if (compareTo(parentColumn.getTable()) == 0) {\n                    return column.getParentConstraint(parentColumn);\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Remove any non-real foreign keys\n     *\n     * @return\n     */\n    public List<ForeignKeyConstraint> removeNonRealForeignKeys() {\n        List<ForeignKeyConstraint> nonReals = new ArrayList<ForeignKeyConstraint>();\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                ForeignKeyConstraint constraint = column.getParentConstraint(parentColumn);\n                if (constraint != null && !constraint.isReal()) {\n                    nonReals.add(constraint);\n                }\n            }\n        }\n        // remove constraints outside of above loop to prevent\n        // concurrent modification exceptions while iterating\n        for (ForeignKeyConstraint constraint : nonReals) {\n            remove(constraint);\n        }\n        return nonReals;\n    }\n\n    /**\n     * Returns the number of tables that reference this table\n     *\n     * @return\n     */\n    public int getNumChildren() {\n        int numChildren = 0;\n        for (TableColumn column : columns.values()) {\n            numChildren += column.getChildren().size();\n        }\n        return numChildren;\n    }\n\n    /**\n     * Returns the number of non-implied children\n     * @return\n     */\n    public int getNumNonImpliedChildren() {\n        int numChildren = 0;\n        for (TableColumn column : columns.values()) {\n            for (TableColumn childColumn : column.getChildren()) {\n                if (!column.getChildConstraint(childColumn).isImplied())\n                    ++numChildren;\n            }\n        }\n        return numChildren;\n    }\n\n    /**\n     * Returns the number of tables that are referenced by this table\n     *\n     * @return\n     */\n    public int getNumParents() {\n        int numParents = 0;\n        for (TableColumn column : columns.values()) {\n            numParents += column.getParents().size();\n        }\n        return numParents;\n    }\n\n    /**\n     * Returns the number of non-implied parents\n     *\n     * @return\n     */\n    public int getNumNonImpliedParents() {\n        int numParents = 0;\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                if (!column.getParentConstraint(parentColumn).isImplied())\n                    ++numParents;\n            }\n        }\n        return numParents;\n    }\n\n    /**\n     * Remove one foreign key constraint.\n     *\n     * <p/>Used during dependency analysis phase.\n     *\n     * @return\n     */\n    public ForeignKeyConstraint removeAForeignKeyConstraint() {\n        @SuppressWarnings(\"hiding\")\n        final List<TableColumn> columns = getColumns();\n        int numParents = 0;\n        int numChildren = 0;\n        // remove either a child or parent, choosing which based on which has the\n        // least number of foreign key associations (when either gets to zero then\n        // the table can be pruned)\n        for (TableColumn column : columns) {\n            numParents += column.getParents().size();\n            numChildren += column.getChildren().size();\n        }\n        for (TableColumn column : columns) {\n            ForeignKeyConstraint constraint;\n            if (numParents <= numChildren)\n                constraint = column.removeAParentFKConstraint();\n            else\n                constraint = column.removeAChildFKConstraint();\n            if (constraint != null)\n                return constraint;\n        }\n        return null;\n    }\n\n    /**\n     * Returns <code>true</code> if this table is logical (not physical), <code>false</code> otherwise\n     * @return\n     */\n    public boolean isLogical() {\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if this is a view, <code>false</code> otherwise\n     *\n     * @return\n     */\n    public boolean isView() {\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if this table is remote (in another schema), <code>false</code> otherwise\n     * @return\n     */\n    public boolean isRemote() {\n        return false;\n    }\n\n    /**\n     * If this is a view it returns the SQL used to create the view (if it's available).\n     * <code>null</code> if it's not a view or the SQL isn't available.\n     * @return\n     * @see #isView()\n     */\n    public String getViewSql() {\n        return null;\n    }\n\n    /**\n     * Returns the number of rows contained in this table, or -1 if unable to determine\n     * the number of rows.\n     *\n     * @return\n     */\n    public long getNumRows() {\n        if (numRows == null) {\n            numRows = Config.getInstance().isNumRowsEnabled() ? fetchNumRows() : -1;\n        }\n        return numRows;\n    }\n\n    /**\n     * Explicitly set the number of rows in this table\n     *\n     * @param numRows\n     */\n    public void setNumRows(long numRows) {\n        this.numRows = numRows;\n    }\n\n    /**\n     * Fetch the number of rows contained in this table.\n     *\n     * returns -1 if unable to successfully fetch the row count\n     *\n     * @param db Database\n     * @return int\n     * @throws SQLException\n     */\n    protected long fetchNumRows() {\n        if (isView() || isRemote())\n            return -1;\n        SQLException originalFailure = null;\n        String sql = Config.getInstance().getDbProperties().getProperty(\"selectRowCountSql\");\n        if (sql != null) {\n            PreparedStatement stmt = null;\n            ResultSet rs = null;\n            try {\n                stmt = db.prepareStatement(sql, getName());\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    return rs.getLong(\"row_count\");\n                }\n            } catch (SQLException sqlException) {\n                // don't die just because this failed\n                originalFailure = sqlException;\n            } finally {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    } catch (SQLException exc) {\n                    }\n                }\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException exc) {\n                    }\n                }\n            }\n        }\n        // if we get here then we either didn't have custom SQL or it didn't work\n        try {\n            // '*' should work best for the majority of cases\n            return fetchNumRows(\"count(*)\", false);\n        } catch (SQLException try2Exception) {\n            try {\n                // except nested tables...try using '1' instead\n                return fetchNumRows(\"count(1)\", false);\n            } catch (SQLException try3Exception) {\n                if (!isLogical()) {\n                    logger.warning(\"Unable to extract the number of rows for table \" + getName() + \", using '-1'\");\n                    if (originalFailure != null)\n                        logger.warning(originalFailure.toString());\n                    logger.warning(try2Exception.toString());\n                    if (!String.valueOf(try2Exception.toString()).equals(try3Exception.toString()))\n                        logger.warning(try3Exception.toString());\n                }\n                return -1;\n            }\n        }\n    }\n\n    protected long fetchNumRows(String clause, boolean forceQuotes) throws SQLException {\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        StringBuilder sql = new StringBuilder(\"select \");\n        sql.append(clause);\n        sql.append(\" from \");\n        if (getSchema() != null) {\n            sql.append(getSchema());\n            sql.append('.');\n        } else if (getCatalog() != null) {\n            sql.append(getCatalog());\n            sql.append('.');\n        }\n        if (forceQuotes) {\n            String quote = db.getMetaData().getIdentifierQuoteString().trim();\n            sql.append(quote + getName() + quote);\n        } else\n            sql.append(db.getQuotedIdentifier(getName()));\n        try {\n            if (finerEnabled)\n                logger.finer(sql.toString());\n            stmt = db.getConnection().prepareStatement(sql.toString());\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                return rs.getLong(1);\n            }\n            return -1;\n        } catch (SQLException exc) {\n            if (// we tried with and w/o quotes...fail this attempt\n            forceQuotes)\n                throw exc;\n            return fetchNumRows(clause, true);\n        } finally {\n            if (rs != null)\n                rs.close();\n            if (stmt != null)\n                stmt.close();\n        }\n    }\n\n    /**\n     * Update the table with the specified XML-derived metadata\n     *\n     * @param tableMeta\n     */\n    public void update(TableMeta tableMeta) {\n        String newComments = tableMeta.getComments();\n        if (newComments != null) {\n            comments = newComments;\n        }\n        for (TableColumnMeta colMeta : tableMeta.getColumns()) {\n            TableColumn col = getColumn(colMeta.getName());\n            if (col == null) {\n                col = addColumn(colMeta);\n            }\n            // update the column with the changes\n            col.update(colMeta);\n        }\n    }\n\n    /**\n     * Same as {@link #connectForeignKeys(Map, Database, Properties)},\n     * but uses XML-based metadata\n     *\n     * @param tableMeta\n     * @param tables\n     */\n    public void connect(TableMeta tableMeta, Map<String, Table> tables) {\n        for (TableColumnMeta colMeta : tableMeta.getColumns()) {\n            TableColumn col = getColumn(colMeta.getName());\n            if (col != null) {\n                // go thru the new foreign key defs and associate them with our columns\n                for (ForeignKeyMeta fk : colMeta.getForeignKeys()) {\n                    Table parent;\n                    if (fk.getRemoteCatalog() != null || fk.getRemoteSchema() != null) {\n                        try {\n                            // adds if doesn't exist\n                            parent = db.addRemoteTable(fk.getRemoteCatalog(), fk.getRemoteSchema(), fk.getTableName(), getContainer(), true);\n                        } catch (SQLException exc) {\n                            parent = null;\n                        }\n                    } else {\n                        parent = tables.get(fk.getTableName());\n                    }\n                    if (parent != null) {\n                        TableColumn parentColumn = parent.getColumn(fk.getColumnName());\n                        if (parentColumn == null) {\n                            logger.warning(\"Undefined column '\" + parent.getName() + '.' + fk.getColumnName() + \"' referenced by '\" + col.getTable() + '.' + col + \"' in XML metadata\");\n                        } else {\n                            /**\n                             * Merely instantiating a foreign key constraint ties it\n                             * into its parent and child columns (& therefore their tables)\n                             */\n                            @SuppressWarnings(\"unused\")\n                            ForeignKeyConstraint unused = new ForeignKeyConstraint(parentColumn, col) {\n\n                                @Override\n                                public String getName() {\n                                    return \"Defined in XML\";\n                                }\n                            };\n                            // they forgot to say it was a primary key\n                            if (!parentColumn.isPrimary()) {\n                                logger.warning(\"Assuming \" + parentColumn.getTable() + '.' + parentColumn + \" is a primary key due to being referenced by \" + col.getTable() + '.' + col);\n                                parent.setPrimaryColumn(parentColumn);\n                            }\n                        }\n                    } else {\n                        logger.warning(\"Undefined table '\" + fk.getTableName() + \"' referenced by '\" + getName() + '.' + col.getName() + \"' in XML metadata\");\n                    }\n                }\n            } else {\n                logger.warning(\"Undefined column '\" + getName() + '.' + colMeta.getName() + \"' in XML metadata\");\n            }\n        }\n    }\n\n    @Override\n    public String toString() {\n        return getName();\n    }\n\n    /**\n     * Returns <code>true</code> if this table has no relationships\n     *\n     * @param withImpliedRelationships boolean\n     * @return boolean\n     */\n    public boolean isOrphan(boolean withImpliedRelationships) {\n        if (withImpliedRelationships)\n            return getMaxParents() == 0 && getMaxChildren() == 0;\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                if (!column.getParentConstraint(parentColumn).isImplied())\n                    return false;\n            }\n            for (TableColumn childColumn : column.getChildren()) {\n                if (!column.getChildConstraint(childColumn).isImplied())\n                    return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compare this table to another table.\n     * Results are based on 1: identity, 2: table name, 3: schema name<p/>\n     *\n     * This implementation was put in place to deal with analyzing multiple\n     * schemas that contain identically named tables.\n     *\n     * @see {@link Comparable#compareTo(Object)}\n     */\n    public int compareTo(Table other) {\n        if (// fast way out\n        other == this)\n            return 0;\n        return getFullName().compareToIgnoreCase(other.getFullName());\n    }\n\n    /**\n     * Implementation of {@link Comparator} that sorts {@link TableColumn}s\n     * by {@link TableColumn#getId() ID} (ignored if <code>null</code>)\n     * followed by {@link TableColumn#getName() Name}.\n     */\n    public static class ByColumnIdComparator implements Comparator<TableColumn> {\n\n        public int compare(TableColumn column1, TableColumn column2) {\n            Object id1 = column1.getId();\n            Object id2 = column2.getId();\n            if (id1 == null || id2 == null)\n                return column1.getName().compareToIgnoreCase(column2.getName());\n            if (id1 instanceof Number && id2 instanceof Number)\n                return ((Number) id1).intValue() - ((Number) id2).intValue();\n            return id1.toString().compareToIgnoreCase(id2.toString());\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableTest8.java",
		"test_prompt": "// TableTest8.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\nimport net.sourceforge.schemaspy.model.xml.TableMeta;\nimport net.sourceforge.schemaspy.util.CaseInsensitiveMap;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Table}.\n* It contains ten unit test cases for the {@link Table#isRemote()} method.\n*/\nclass TableTest8 {"
	},
	{
		"original_code": "// Table.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\nimport net.sourceforge.schemaspy.model.xml.TableMeta;\nimport net.sourceforge.schemaspy.util.CaseInsensitiveMap;\n\n/**\n * A <code>Table</code> is one of the basic building blocks of SchemaSpy\n * that knows everything about the database table's metadata.\n *\n * @author John Currier\n */\npublic class Table implements Comparable<Table> {\n\n    private final String catalog;\n\n    private final String schema;\n\n    private final String name;\n\n    private final String fullName;\n\n    private final String container;\n\n    protected final CaseInsensitiveMap<TableColumn> columns = new CaseInsensitiveMap<TableColumn>();\n\n    private final List<TableColumn> primaryKeys = new ArrayList<TableColumn>();\n\n    private final CaseInsensitiveMap<ForeignKeyConstraint> foreignKeys = new CaseInsensitiveMap<ForeignKeyConstraint>();\n\n    private final CaseInsensitiveMap<TableIndex> indexes = new CaseInsensitiveMap<TableIndex>();\n\n    private Object id;\n\n    private final Map<String, String> checkConstraints = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);\n\n    private Long numRows;\n\n    protected final Database db;\n\n    private String comments;\n\n    private int maxChildren;\n\n    private int maxParents;\n\n    private final static Logger logger = Logger.getLogger(Table.class.getName());\n\n    private final static boolean fineEnabled = logger.isLoggable(Level.FINE);\n\n    private final static boolean finerEnabled = logger.isLoggable(Level.FINER);\n\n    /**\n     * Construct a table that knows everything about the database table's metadata\n     *\n     * @param db\n     * @param catalog\n     * @param schema\n     * @param name\n     * @param comments\n     * @throws SQLException\n     */\n    public Table(Database db, String catalog, String schema, String name, String comments) throws SQLException {\n        this.db = db;\n        this.catalog = catalog;\n        this.schema = schema;\n        this.container = schema != null ? schema : catalog != null ? catalog : db.getName();\n        this.name = name;\n        this.fullName = getFullName(db.getName(), catalog, schema, name);\n        if (fineEnabled)\n            logger.fine(\"Creating \" + getClass().getSimpleName() + \" \" + fullName);\n        setComments(comments);\n        initColumns();\n        initIndexes();\n        initPrimaryKeys();\n    }\n\n    /**\n     * \"Connect\" all of this table's foreign keys to their referenced primary keys\n     * (and, in some cases, do the reverse as well).\n     *\n     * @param tables\n     * @throws SQLException\n     */\n    public void connectForeignKeys(Map<String, Table> tables) throws SQLException {\n        if (finerEnabled)\n            logger.finer(\"Connecting foreign keys to \" + getFullName());\n        ResultSet rs = null;\n        try {\n            // get our foreign keys that reference other tables' primary keys\n            rs = db.getMetaData().getImportedKeys(getCatalog(), getSchema(), getName());\n            while (rs.next()) {\n                addForeignKey(rs.getString(\"FK_NAME\"), rs.getString(\"FKCOLUMN_NAME\"), rs.getString(\"PKTABLE_CAT\"), rs.getString(\"PKTABLE_SCHEM\"), rs.getString(\"PKTABLE_NAME\"), rs.getString(\"PKCOLUMN_NAME\"), rs.getInt(\"UPDATE_RULE\"), rs.getInt(\"DELETE_RULE\"), tables);\n            }\n        } finally {\n            if (rs != null)\n                rs.close();\n        }\n        // also try to find all of the 'remote' tables in other schemas that\n        // point to our primary keys (not necessary in the normal case\n        // as we infer this from the opposite direction)\n        if (getSchema() != null || getCatalog() != null) {\n            try {\n                // get the foreign keys that reference our primary keys\n                rs = db.getMetaData().getExportedKeys(getCatalog(), getSchema(), getName());\n                while (rs.next()) {\n                    String otherCatalog = rs.getString(\"FKTABLE_CAT\");\n                    String otherSchema = rs.getString(\"FKTABLE_SCHEM\");\n                    if (!String.valueOf(getSchema()).equals(String.valueOf(otherSchema)) || !String.valueOf(getCatalog()).equals(String.valueOf(otherCatalog))) {\n                        db.addRemoteTable(otherCatalog, otherSchema, rs.getString(\"FKTABLE_NAME\"), getSchema(), false);\n                    }\n                }\n            } finally {\n                if (rs != null)\n                    rs.close();\n            }\n        }\n    }\n\n    /**\n     * Get the foreign keys associated with this table\n     *\n     * @return\n     */\n    public Collection<ForeignKeyConstraint> getForeignKeys() {\n        return Collections.unmodifiableCollection(foreignKeys.values());\n    }\n\n    /**\n     * Add a check constraint to the table\n     * (no real details, just name and textual representation)\n     *\n     * @param constraintName\n     * @param text\n     */\n    public void addCheckConstraint(String constraintName, String text) {\n        checkConstraints.put(constraintName, text);\n    }\n\n    /**\n     * @param rs ResultSet from {@link DatabaseMetaData#getImportedKeys(String, String, String)}\n     * rs.getString(\"FK_NAME\");\n     * rs.getString(\"FKCOLUMN_NAME\");\n     * rs.getString(\"PKTABLE_CAT\");\n     * rs.getString(\"PKTABLE_SCHEM\");\n     * rs.getString(\"PKTABLE_NAME\");\n     * rs.getString(\"PKCOLUMN_NAME\");\n     * @param tables Map\n     * @param db\n     * @throws SQLException\n     */\n    protected void addForeignKey(String fkName, String fkColName, String pkCatalog, String pkSchema, String pkTableName, String pkColName, int updateRule, int deleteRule, Map<String, Table> tables) throws SQLException {\n        if (fkName == null)\n            return;\n        Pattern include = Config.getInstance().getTableInclusions();\n        Pattern exclude = Config.getInstance().getTableExclusions();\n        if (!include.matcher(pkTableName).matches() || exclude.matcher(pkTableName).matches()) {\n            if (fineEnabled)\n                logger.fine(\"Ignoring \" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName) + \" referenced by FK \" + fkName);\n            return;\n        }\n        ForeignKeyConstraint foreignKey = foreignKeys.get(fkName);\n        if (foreignKey == null) {\n            foreignKey = new ForeignKeyConstraint(this, fkName, updateRule, deleteRule);\n            foreignKeys.put(fkName, foreignKey);\n        }\n        TableColumn childColumn = getColumn(fkColName);\n        if (childColumn != null) {\n            foreignKey.addChildColumn(childColumn);\n            Config config = Config.getInstance();\n            Table parentTable = tables.get(pkTableName);\n            String parentContainer = pkSchema != null ? pkSchema : pkCatalog != null ? pkCatalog : db.getName();\n            String baseContainer = config.getSchema() != null ? config.getSchema() : config.getCatalog() != null ? config.getCatalog() : db.getName();\n            // if named table doesn't exist in this schema\n            // or exists here but really referencing same named table in another schema\n            if (parentTable == null || !baseContainer.equals(parentContainer)) {\n                if (fineEnabled)\n                    logger.fine(\"Adding remote table \" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName));\n                parentTable = db.addRemoteTable(pkCatalog, pkSchema, pkTableName, baseContainer, false);\n            }\n            if (parentTable != null) {\n                TableColumn parentColumn = parentTable.getColumn(pkColName);\n                if (parentColumn != null) {\n                    foreignKey.addParentColumn(parentColumn);\n                    childColumn.addParent(parentColumn, foreignKey);\n                    parentColumn.addChild(childColumn, foreignKey);\n                } else {\n                    logger.warning(\"Couldn't add FK '\" + foreignKey.getName() + \"' to table '\" + this + \"' - Column '\" + pkColName + \"' doesn't exist in table '\" + parentTable + \"'\");\n                }\n            } else {\n                logger.warning(\"Couldn't add FK '\" + foreignKey.getName() + \"' to table '\" + this + \"' - Unknown Referenced Table '\" + pkTableName + \"'\");\n            }\n        } else {\n            logger.warning(\"Couldn't add FK '\" + foreignKey.getName() + \"' to table '\" + this + \"' - Column '\" + fkColName + \"' doesn't exist\");\n        }\n    }\n\n    /**\n     * @param meta\n     * @throws SQLException\n     */\n    private void initPrimaryKeys() throws SQLException {\n        ResultSet rs = null;\n        try {\n            if (fineEnabled)\n                logger.fine(\"Querying primary keys for \" + getFullName());\n            rs = db.getMetaData().getPrimaryKeys(getCatalog(), getSchema(), getName());\n            while (rs.next()) setPrimaryColumn(rs);\n        } catch (SQLException exc) {\n            if (!isLogical()) {\n                throw exc;\n            }\n        } finally {\n            if (rs != null)\n                rs.close();\n        }\n    }\n\n    /**\n     * @param rs\n     * @throws SQLException\n     */\n    private void setPrimaryColumn(ResultSet rs) throws SQLException {\n        String pkName = rs.getString(\"PK_NAME\");\n        if (pkName == null)\n            return;\n        TableIndex index = getIndex(pkName);\n        if (index != null) {\n            index.setIsPrimaryKey(true);\n        }\n        String columnName = rs.getString(\"COLUMN_NAME\");\n        setPrimaryColumn(getColumn(columnName));\n    }\n\n    /**\n     * @param primaryColumn\n     */\n    void setPrimaryColumn(TableColumn primaryColumn) {\n        primaryKeys.add(primaryColumn);\n    }\n\n    /**\n     * @throws SQLException\n     */\n    private void initColumns() throws SQLException {\n        ResultSet rs = null;\n        synchronized (Table.class) {\n            try {\n                rs = db.getMetaData().getColumns(getCatalog(), getSchema(), getName(), \"%\");\n                while (rs.next()) addColumn(rs);\n            } catch (SQLException exc) {\n                if (!isLogical()) {\n                    class ColumnInitializationFailure extends SQLException {\n\n                        private static final long serialVersionUID = 1L;\n\n                        public ColumnInitializationFailure(SQLException failure) {\n                            super(\"Failed to collect column details for \" + (isView() ? \"view\" : \"table\") + \" '\" + getName() + \"' in schema '\" + getContainer() + \"'\");\n                            initCause(failure);\n                        }\n                    }\n                    throw new ColumnInitializationFailure(exc);\n                }\n            } finally {\n                if (rs != null)\n                    rs.close();\n            }\n        }\n        initColumnAutoUpdate(false);\n    }\n\n    /**\n     * @param forceQuotes\n     * @throws SQLException\n     */\n    private void initColumnAutoUpdate(boolean forceQuotes) throws SQLException {\n        ResultSet rs = null;\n        PreparedStatement stmt = null;\n        if (isView() || isRemote())\n            return;\n        // we've got to get a result set with all the columns in it\n        // so we can ask if the columns are auto updated\n        // Ugh!!!  Should have been in DatabaseMetaData instead!!!\n        StringBuilder sql = new StringBuilder(\"select * from \");\n        if (getSchema() != null) {\n            sql.append(getSchema());\n            sql.append('.');\n        } else if (getCatalog() != null) {\n            sql.append(getCatalog());\n            sql.append('.');\n        }\n        if (forceQuotes) {\n            String quote = db.getMetaData().getIdentifierQuoteString().trim();\n            sql.append(quote + getName() + quote);\n        } else\n            sql.append(db.getQuotedIdentifier(getName()));\n        sql.append(\" where 0 = 1\");\n        try {\n            stmt = db.getMetaData().getConnection().prepareStatement(sql.toString());\n            rs = stmt.executeQuery();\n            ResultSetMetaData rsMeta = rs.getMetaData();\n            for (int i = rsMeta.getColumnCount(); i > 0; --i) {\n                TableColumn column = getColumn(rsMeta.getColumnName(i));\n                column.setIsAutoUpdated(rsMeta.isAutoIncrement(i));\n            }\n        } catch (SQLException exc) {\n            if (forceQuotes) {\n                if (!isLogical()) {\n                    // don't completely choke just because we couldn't do this....\n                    logger.warning(\"Failed to determine auto increment status: \" + exc);\n                    logger.warning(\"SQL: \" + sql.toString());\n                }\n            } else {\n                initColumnAutoUpdate(true);\n            }\n        } finally {\n            if (rs != null)\n                rs.close();\n            if (stmt != null)\n                stmt.close();\n        }\n    }\n\n    /**\n     * @param rs - from {@link DatabaseMetaData#getColumns(String, String, String, String)}\n     * @throws SQLException\n     */\n    protected void addColumn(ResultSet rs) throws SQLException {\n        String columnName = rs.getString(\"COLUMN_NAME\");\n        if (columnName == null)\n            return;\n        if (getColumn(columnName) == null) {\n            TableColumn column = new TableColumn(this, rs);\n            columns.put(column.getName(), column);\n        }\n    }\n\n    /**\n     * Add a column that's defined in xml metadata.\n     * Assumes that a column named colMeta.getName() doesn't already exist in <code>columns</code>.\n     * @param colMeta\n     * @return\n     */\n    protected TableColumn addColumn(TableColumnMeta colMeta) {\n        TableColumn column = new TableColumn(this, colMeta);\n        columns.put(column.getName(), column);\n        return column;\n    }\n\n    /**\n     * Initialize index information\n     *\n     * @throws SQLException\n     */\n    private void initIndexes() throws SQLException {\n        if (isView() || isRemote())\n            return;\n        // first try to initialize using the index query spec'd in the .properties\n        // do this first because some DB's (e.g. Oracle) do 'bad' things with getIndexInfo()\n        // (they try to do a DDL analyze command that has some bad side-effects)\n        if (initIndexes(Config.getInstance().getDbProperties().getProperty(\"selectIndexesSql\")))\n            return;\n        // couldn't, so try the old fashioned approach\n        ResultSet rs = null;\n        try {\n            rs = db.getMetaData().getIndexInfo(getCatalog(), getSchema(), getName(), false, true);\n            while (rs.next()) {\n                if (rs.getShort(\"TYPE\") != DatabaseMetaData.tableIndexStatistic)\n                    addIndex(rs);\n            }\n        } catch (SQLException exc) {\n            if (!isLogical())\n                logger.warning(\"Unable to extract index info for table '\" + getName() + \"' in schema '\" + getContainer() + \"': \" + exc);\n        } finally {\n            if (rs != null)\n                rs.close();\n        }\n    }\n\n    /**\n     * Try to initialize index information based on the specified SQL\n     *\n     * @return boolean <code>true</code> if it worked, otherwise <code>false</code>\n     */\n    private boolean initIndexes(String selectIndexesSql) {\n        if (selectIndexesSql == null)\n            return false;\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = db.prepareStatement(selectIndexesSql, getName());\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                if (rs.getShort(\"TYPE\") != DatabaseMetaData.tableIndexStatistic)\n                    addIndex(rs);\n            }\n        } catch (SQLException sqlException) {\n            logger.warning(\"Failed to query index information with SQL: \" + selectIndexesSql);\n            logger.warning(sqlException.toString());\n            return false;\n        } finally {\n            if (rs != null) {\n                try {\n                    rs.close();\n                } catch (Exception exc) {\n                    exc.printStackTrace();\n                }\n            }\n            if (stmt != null) {\n                try {\n                    stmt.close();\n                } catch (Exception exc) {\n                    exc.printStackTrace();\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @param indexName\n     * @return\n     */\n    public TableIndex getIndex(String indexName) {\n        return indexes.get(indexName);\n    }\n\n    /**\n     * @param rs\n     * @throws SQLException\n     */\n    private void addIndex(ResultSet rs) throws SQLException {\n        String indexName = rs.getString(\"INDEX_NAME\");\n        if (indexName == null)\n            return;\n        TableIndex index = getIndex(indexName);\n        if (index == null) {\n            index = new TableIndex(rs);\n            indexes.put(index.getName(), index);\n        }\n        index.addColumn(getColumn(rs.getString(\"COLUMN_NAME\")), rs.getString(\"ASC_OR_DESC\"));\n    }\n\n    /**\n     * Returns the catalog that the table belongs to\n     *\n     * @return\n     */\n    public String getCatalog() {\n        return catalog;\n    }\n\n    /**\n     * Returns the schema that the table belongs to\n     *\n     * @return\n     */\n    public String getSchema() {\n        return schema;\n    }\n\n    /**\n     * Returns the logical 'container' that the table\n     * lives in.  Basically it's the first non-<code>null</code>\n     * item out of <code>schema</code>, <code>catalog</code>\n     * and <code>database</code>.\n     *\n     * @return\n     */\n    public String getContainer() {\n        return container;\n    }\n\n    /**\n     * Returns the name of the table\n     *\n     * @return\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the fully-qualified name of this table\n     *\n     * @return\n     */\n    public String getFullName() {\n        return fullName;\n    }\n\n    /**\n     * Returns the fully-qualified name of a table\n     *\n     * @return\n     */\n    public static String getFullName(String db, String catalog, String schema, String table) {\n        String fullName = (catalog == null && schema == null ? db + '.' : \"\") + (catalog == null ? \"\" : catalog + '.') + (schema == null ? \"\" : schema + '.') + table;\n        return fullName;\n    }\n\n    /**\n     * Object IDs are useful for tables such as DB/2 that many times\n     * give error messages based on object ID and not name\n     *\n     * @param id\n     */\n    public void setId(Object id) {\n        this.id = id;\n    }\n\n    /**\n     * @see #setId(Object)\n     *\n     * @return\n     */\n    public Object getId() {\n        return id;\n    }\n\n    /**\n     * Returns the check constraints associated with this table\n     *\n     * @return\n     */\n    public Map<String, String> getCheckConstraints() {\n        return checkConstraints;\n    }\n\n    /**\n     * Returns the indexes that are applied to this table\n     *\n     * @return\n     */\n    public Set<TableIndex> getIndexes() {\n        return new HashSet<TableIndex>(indexes.values());\n    }\n\n    /**\n     * Returns a collection of table columns that have been identified as \"primary\"\n     *\n     * @return\n     */\n    public List<TableColumn> getPrimaryColumns() {\n        return primaryKeys;\n    }\n\n    /**\n     * @return Comments associated with this table, or <code>null</code> if none.\n     */\n    public String getComments() {\n        return comments;\n    }\n\n    /**\n     * Sets the comments that are associated with this table\n     *\n     * @param comments\n     */\n    public void setComments(String comments) {\n        String cmts = (comments == null || comments.trim().length() == 0) ? null : comments.trim();\n        // MySQL's InnoDB engine does some insane crap of storing erroneous details in\n        // with table comments.  Here I attempt to strip the \"crap\" out without impacting\n        // other databases.  Ideally this should happen in selectColumnCommentsSql (and\n        // therefore isolate it to MySQL), but it's a bit too complex to do cleanly.\n        if (cmts != null) {\n            int crapIndex = cmts.indexOf(\"; InnoDB free: \");\n            if (crapIndex == -1)\n                crapIndex = cmts.startsWith(\"InnoDB free: \") ? 0 : -1;\n            if (crapIndex != -1) {\n                cmts = cmts.substring(0, crapIndex).trim();\n                cmts = cmts.length() == 0 ? null : cmts;\n            }\n        }\n        this.comments = cmts;\n    }\n\n    /**\n     * Returns the {@link TableColumn} with the given name, or <code>null</code>\n     * if it doesn't exist\n     *\n     * @param columnName\n     * @return\n     */\n    public TableColumn getColumn(String columnName) {\n        return columns.get(columnName);\n    }\n\n    /**\n     * Returns <code>List</code> of <code>TableColumn</code>s in ascending column number order.\n     *\n     * @return\n     */\n    public List<TableColumn> getColumns() {\n        Set<TableColumn> sorted = new TreeSet<TableColumn>(new ByColumnIdComparator());\n        sorted.addAll(columns.values());\n        return new ArrayList<TableColumn>(sorted);\n    }\n\n    /**\n     * Returns <code>true</code> if this table references no other tables..<p/>\n     * Used in dependency analysis.\n     * @return\n     */\n    public boolean isRoot() {\n        for (TableColumn column : columns.values()) {\n            if (column.isForeignKey()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns <code>true</code> if this table is referenced by no other tables.<p/>\n     * Used in dependency analysis.\n     * @return\n     */\n    public boolean isLeaf() {\n        for (TableColumn column : columns.values()) {\n            if (!column.getChildren().isEmpty()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the maximum number of parents that this table has had before\n     * any had been removed during dependency analysis\n     *\n     * @return\n     */\n    public int getMaxParents() {\n        return maxParents;\n    }\n\n    /**\n     * Notification that's called to indicate that a parent has been added to\n     * this table\n     */\n    public void addedParent() {\n        maxParents++;\n    }\n\n    /**\n     * \"Unlink\" all of the parent tables from this table\n     */\n    public void unlinkParents() {\n        for (TableColumn column : columns.values()) {\n            column.unlinkParents();\n        }\n    }\n\n    /**\n     * Returns the maximum number of children that this table has had before\n     * any had been removed during dependency analysis\n     *\n     * @return\n     */\n    public int getMaxChildren() {\n        return maxChildren;\n    }\n\n    /**\n     * Notification that's called to indicate that a child has been added to\n     * this table\n     */\n    public void addedChild() {\n        maxChildren++;\n    }\n\n    /**\n     * \"Unlink\" all of the child tables from this table\n     */\n    public void unlinkChildren() {\n        for (TableColumn column : columns.values()) {\n            column.unlinkChildren();\n        }\n    }\n\n    /**\n     * Remove a single self referencing constraint if one exists.\n     *\n     * @return\n     */\n    public ForeignKeyConstraint removeSelfReferencingConstraint() {\n        return remove(getSelfReferencingConstraint());\n    }\n\n    /**\n     * Remove the specified {@link ForeignKeyConstraint} from this table.<p>\n     *\n     * This is a more drastic removal solution that was proposed by Remke Rutgers\n     *\n     * @param constraint\n     */\n    private ForeignKeyConstraint remove(ForeignKeyConstraint constraint) {\n        if (constraint != null) {\n            for (int i = 0; i < constraint.getChildColumns().size(); i++) {\n                TableColumn childColumn = constraint.getChildColumns().get(i);\n                TableColumn parentColumn = constraint.getParentColumns().get(i);\n                childColumn.removeParent(parentColumn);\n                parentColumn.removeChild(childColumn);\n            }\n        }\n        return constraint;\n    }\n\n    /**\n     * Return a self referencing constraint if one exists\n     *\n     * @return\n     */\n    private ForeignKeyConstraint getSelfReferencingConstraint() {\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                if (compareTo(parentColumn.getTable()) == 0) {\n                    return column.getParentConstraint(parentColumn);\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Remove any non-real foreign keys\n     *\n     * @return\n     */\n    public List<ForeignKeyConstraint> removeNonRealForeignKeys() {\n        List<ForeignKeyConstraint> nonReals = new ArrayList<ForeignKeyConstraint>();\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                ForeignKeyConstraint constraint = column.getParentConstraint(parentColumn);\n                if (constraint != null && !constraint.isReal()) {\n                    nonReals.add(constraint);\n                }\n            }\n        }\n        // remove constraints outside of above loop to prevent\n        // concurrent modification exceptions while iterating\n        for (ForeignKeyConstraint constraint : nonReals) {\n            remove(constraint);\n        }\n        return nonReals;\n    }\n\n    /**\n     * Returns the number of tables that reference this table\n     *\n     * @return\n     */\n    public int getNumChildren() {\n        int numChildren = 0;\n        for (TableColumn column : columns.values()) {\n            numChildren += column.getChildren().size();\n        }\n        return numChildren;\n    }\n\n    /**\n     * Returns the number of non-implied children\n     * @return\n     */\n    public int getNumNonImpliedChildren() {\n        int numChildren = 0;\n        for (TableColumn column : columns.values()) {\n            for (TableColumn childColumn : column.getChildren()) {\n                if (!column.getChildConstraint(childColumn).isImplied())\n                    ++numChildren;\n            }\n        }\n        return numChildren;\n    }\n\n    /**\n     * Returns the number of tables that are referenced by this table\n     *\n     * @return\n     */\n    public int getNumParents() {\n        int numParents = 0;\n        for (TableColumn column : columns.values()) {\n            numParents += column.getParents().size();\n        }\n        return numParents;\n    }\n\n    /**\n     * Returns the number of non-implied parents\n     *\n     * @return\n     */\n    public int getNumNonImpliedParents() {\n        int numParents = 0;\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                if (!column.getParentConstraint(parentColumn).isImplied())\n                    ++numParents;\n            }\n        }\n        return numParents;\n    }\n\n    /**\n     * Remove one foreign key constraint.\n     *\n     * <p/>Used during dependency analysis phase.\n     *\n     * @return\n     */\n    public ForeignKeyConstraint removeAForeignKeyConstraint() {\n        @SuppressWarnings(\"hiding\")\n        final List<TableColumn> columns = getColumns();\n        int numParents = 0;\n        int numChildren = 0;\n        // remove either a child or parent, choosing which based on which has the\n        // least number of foreign key associations (when either gets to zero then\n        // the table can be pruned)\n        for (TableColumn column : columns) {\n            numParents += column.getParents().size();\n            numChildren += column.getChildren().size();\n        }\n        for (TableColumn column : columns) {\n            ForeignKeyConstraint constraint;\n            if (numParents <= numChildren)\n                constraint = column.removeAParentFKConstraint();\n            else\n                constraint = column.removeAChildFKConstraint();\n            if (constraint != null)\n                return constraint;\n        }\n        return null;\n    }\n\n    /**\n     * Returns <code>true</code> if this table is logical (not physical), <code>false</code> otherwise\n     * @return\n     */\n    public boolean isLogical() {\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if this is a view, <code>false</code> otherwise\n     *\n     * @return\n     */\n    public boolean isView() {\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if this table is remote (in another schema), <code>false</code> otherwise\n     * @return\n     */\n    public boolean isRemote() {\n        return false;\n    }\n\n    /**\n     * If this is a view it returns the SQL used to create the view (if it's available).\n     * <code>null</code> if it's not a view or the SQL isn't available.\n     * @return\n     * @see #isView()\n     */\n    public String getViewSql() {\n        return null;\n    }\n\n    /**\n     * Returns the number of rows contained in this table, or -1 if unable to determine\n     * the number of rows.\n     *\n     * @return\n     */\n    public long getNumRows() {\n        if (numRows == null) {\n            numRows = Config.getInstance().isNumRowsEnabled() ? fetchNumRows() : -1;\n        }\n        return numRows;\n    }\n\n    /**\n     * Explicitly set the number of rows in this table\n     *\n     * @param numRows\n     */\n    public void setNumRows(long numRows) {\n        this.numRows = numRows;\n    }\n\n    /**\n     * Fetch the number of rows contained in this table.\n     *\n     * returns -1 if unable to successfully fetch the row count\n     *\n     * @param db Database\n     * @return int\n     * @throws SQLException\n     */\n    protected long fetchNumRows() {\n        if (isView() || isRemote())\n            return -1;\n        SQLException originalFailure = null;\n        String sql = Config.getInstance().getDbProperties().getProperty(\"selectRowCountSql\");\n        if (sql != null) {\n            PreparedStatement stmt = null;\n            ResultSet rs = null;\n            try {\n                stmt = db.prepareStatement(sql, getName());\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    return rs.getLong(\"row_count\");\n                }\n            } catch (SQLException sqlException) {\n                // don't die just because this failed\n                originalFailure = sqlException;\n            } finally {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    } catch (SQLException exc) {\n                    }\n                }\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException exc) {\n                    }\n                }\n            }\n        }\n        // if we get here then we either didn't have custom SQL or it didn't work\n        try {\n            // '*' should work best for the majority of cases\n            return fetchNumRows(\"count(*)\", false);\n        } catch (SQLException try2Exception) {\n            try {\n                // except nested tables...try using '1' instead\n                return fetchNumRows(\"count(1)\", false);\n            } catch (SQLException try3Exception) {\n                if (!isLogical()) {\n                    logger.warning(\"Unable to extract the number of rows for table \" + getName() + \", using '-1'\");\n                    if (originalFailure != null)\n                        logger.warning(originalFailure.toString());\n                    logger.warning(try2Exception.toString());\n                    if (!String.valueOf(try2Exception.toString()).equals(try3Exception.toString()))\n                        logger.warning(try3Exception.toString());\n                }\n                return -1;\n            }\n        }\n    }\n\n    protected long fetchNumRows(String clause, boolean forceQuotes) throws SQLException {\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        StringBuilder sql = new StringBuilder(\"select \");\n        sql.append(clause);\n        sql.append(\" from \");\n        if (getSchema() != null) {\n            sql.append(getSchema());\n            sql.append('.');\n        } else if (getCatalog() != null) {\n            sql.append(getCatalog());\n            sql.append('.');\n        }\n        if (forceQuotes) {\n            String quote = db.getMetaData().getIdentifierQuoteString().trim();\n            sql.append(quote + getName() + quote);\n        } else\n            sql.append(db.getQuotedIdentifier(getName()));\n        try {\n            if (finerEnabled)\n                logger.finer(sql.toString());\n            stmt = db.getConnection().prepareStatement(sql.toString());\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                return rs.getLong(1);\n            }\n            return -1;\n        } catch (SQLException exc) {\n            if (// we tried with and w/o quotes...fail this attempt\n            forceQuotes)\n                throw exc;\n            return fetchNumRows(clause, true);\n        } finally {\n            if (rs != null)\n                rs.close();\n            if (stmt != null)\n                stmt.close();\n        }\n    }\n\n    /**\n     * Update the table with the specified XML-derived metadata\n     *\n     * @param tableMeta\n     */\n    public void update(TableMeta tableMeta) {\n        String newComments = tableMeta.getComments();\n        if (newComments != null) {\n            comments = newComments;\n        }\n        for (TableColumnMeta colMeta : tableMeta.getColumns()) {\n            TableColumn col = getColumn(colMeta.getName());\n            if (col == null) {\n                col = addColumn(colMeta);\n            }\n            // update the column with the changes\n            col.update(colMeta);\n        }\n    }\n\n    /**\n     * Same as {@link #connectForeignKeys(Map, Database, Properties)},\n     * but uses XML-based metadata\n     *\n     * @param tableMeta\n     * @param tables\n     */\n    public void connect(TableMeta tableMeta, Map<String, Table> tables) {\n        for (TableColumnMeta colMeta : tableMeta.getColumns()) {\n            TableColumn col = getColumn(colMeta.getName());\n            if (col != null) {\n                // go thru the new foreign key defs and associate them with our columns\n                for (ForeignKeyMeta fk : colMeta.getForeignKeys()) {\n                    Table parent;\n                    if (fk.getRemoteCatalog() != null || fk.getRemoteSchema() != null) {\n                        try {\n                            // adds if doesn't exist\n                            parent = db.addRemoteTable(fk.getRemoteCatalog(), fk.getRemoteSchema(), fk.getTableName(), getContainer(), true);\n                        } catch (SQLException exc) {\n                            parent = null;\n                        }\n                    } else {\n                        parent = tables.get(fk.getTableName());\n                    }\n                    if (parent != null) {\n                        TableColumn parentColumn = parent.getColumn(fk.getColumnName());\n                        if (parentColumn == null) {\n                            logger.warning(\"Undefined column '\" + parent.getName() + '.' + fk.getColumnName() + \"' referenced by '\" + col.getTable() + '.' + col + \"' in XML metadata\");\n                        } else {\n                            /**\n                             * Merely instantiating a foreign key constraint ties it\n                             * into its parent and child columns (& therefore their tables)\n                             */\n                            @SuppressWarnings(\"unused\")\n                            ForeignKeyConstraint unused = new ForeignKeyConstraint(parentColumn, col) {\n\n                                @Override\n                                public String getName() {\n                                    return \"Defined in XML\";\n                                }\n                            };\n                            // they forgot to say it was a primary key\n                            if (!parentColumn.isPrimary()) {\n                                logger.warning(\"Assuming \" + parentColumn.getTable() + '.' + parentColumn + \" is a primary key due to being referenced by \" + col.getTable() + '.' + col);\n                                parent.setPrimaryColumn(parentColumn);\n                            }\n                        }\n                    } else {\n                        logger.warning(\"Undefined table '\" + fk.getTableName() + \"' referenced by '\" + getName() + '.' + col.getName() + \"' in XML metadata\");\n                    }\n                }\n            } else {\n                logger.warning(\"Undefined column '\" + getName() + '.' + colMeta.getName() + \"' in XML metadata\");\n            }\n        }\n    }\n\n    @Override\n    public String toString() {\n        return getName();\n    }\n\n    /**\n     * Returns <code>true</code> if this table has no relationships\n     *\n     * @param withImpliedRelationships boolean\n     * @return boolean\n     */\n    public boolean isOrphan(boolean withImpliedRelationships) {\n        if (withImpliedRelationships)\n            return getMaxParents() == 0 && getMaxChildren() == 0;\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                if (!column.getParentConstraint(parentColumn).isImplied())\n                    return false;\n            }\n            for (TableColumn childColumn : column.getChildren()) {\n                if (!column.getChildConstraint(childColumn).isImplied())\n                    return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compare this table to another table.\n     * Results are based on 1: identity, 2: table name, 3: schema name<p/>\n     *\n     * This implementation was put in place to deal with analyzing multiple\n     * schemas that contain identically named tables.\n     *\n     * @see {@link Comparable#compareTo(Object)}\n     */\n    public int compareTo(Table other) {\n        if (// fast way out\n        other == this)\n            return 0;\n        return getFullName().compareToIgnoreCase(other.getFullName());\n    }\n\n    /**\n     * Implementation of {@link Comparator} that sorts {@link TableColumn}s\n     * by {@link TableColumn#getId() ID} (ignored if <code>null</code>)\n     * followed by {@link TableColumn#getName() Name}.\n     */\n    public static class ByColumnIdComparator implements Comparator<TableColumn> {\n\n        public int compare(TableColumn column1, TableColumn column2) {\n            Object id1 = column1.getId();\n            Object id2 = column2.getId();\n            if (id1 == null || id2 == null)\n                return column1.getName().compareToIgnoreCase(column2.getName());\n            if (id1 instanceof Number && id2 instanceof Number)\n                return ((Number) id1).intValue() - ((Number) id2).intValue();\n            return id1.toString().compareToIgnoreCase(id2.toString());\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableTest9.java",
		"test_prompt": "// TableTest9.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\nimport net.sourceforge.schemaspy.model.xml.TableMeta;\nimport net.sourceforge.schemaspy.util.CaseInsensitiveMap;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Table}.\n* It contains ten unit test cases for the {@link Table#isOrphan(boolean)} method.\n*/\nclass TableTest9 {"
	},
	{
		"original_code": "// Table.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\nimport net.sourceforge.schemaspy.model.xml.TableMeta;\nimport net.sourceforge.schemaspy.util.CaseInsensitiveMap;\n\n/**\n * A <code>Table</code> is one of the basic building blocks of SchemaSpy\n * that knows everything about the database table's metadata.\n *\n * @author John Currier\n */\npublic class Table implements Comparable<Table> {\n\n    private final String catalog;\n\n    private final String schema;\n\n    private final String name;\n\n    private final String fullName;\n\n    private final String container;\n\n    protected final CaseInsensitiveMap<TableColumn> columns = new CaseInsensitiveMap<TableColumn>();\n\n    private final List<TableColumn> primaryKeys = new ArrayList<TableColumn>();\n\n    private final CaseInsensitiveMap<ForeignKeyConstraint> foreignKeys = new CaseInsensitiveMap<ForeignKeyConstraint>();\n\n    private final CaseInsensitiveMap<TableIndex> indexes = new CaseInsensitiveMap<TableIndex>();\n\n    private Object id;\n\n    private final Map<String, String> checkConstraints = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);\n\n    private Long numRows;\n\n    protected final Database db;\n\n    private String comments;\n\n    private int maxChildren;\n\n    private int maxParents;\n\n    private final static Logger logger = Logger.getLogger(Table.class.getName());\n\n    private final static boolean fineEnabled = logger.isLoggable(Level.FINE);\n\n    private final static boolean finerEnabled = logger.isLoggable(Level.FINER);\n\n    /**\n     * Construct a table that knows everything about the database table's metadata\n     *\n     * @param db\n     * @param catalog\n     * @param schema\n     * @param name\n     * @param comments\n     * @throws SQLException\n     */\n    public Table(Database db, String catalog, String schema, String name, String comments) throws SQLException {\n        this.db = db;\n        this.catalog = catalog;\n        this.schema = schema;\n        this.container = schema != null ? schema : catalog != null ? catalog : db.getName();\n        this.name = name;\n        this.fullName = getFullName(db.getName(), catalog, schema, name);\n        if (fineEnabled)\n            logger.fine(\"Creating \" + getClass().getSimpleName() + \" \" + fullName);\n        setComments(comments);\n        initColumns();\n        initIndexes();\n        initPrimaryKeys();\n    }\n\n    /**\n     * \"Connect\" all of this table's foreign keys to their referenced primary keys\n     * (and, in some cases, do the reverse as well).\n     *\n     * @param tables\n     * @throws SQLException\n     */\n    public void connectForeignKeys(Map<String, Table> tables) throws SQLException {\n        if (finerEnabled)\n            logger.finer(\"Connecting foreign keys to \" + getFullName());\n        ResultSet rs = null;\n        try {\n            // get our foreign keys that reference other tables' primary keys\n            rs = db.getMetaData().getImportedKeys(getCatalog(), getSchema(), getName());\n            while (rs.next()) {\n                addForeignKey(rs.getString(\"FK_NAME\"), rs.getString(\"FKCOLUMN_NAME\"), rs.getString(\"PKTABLE_CAT\"), rs.getString(\"PKTABLE_SCHEM\"), rs.getString(\"PKTABLE_NAME\"), rs.getString(\"PKCOLUMN_NAME\"), rs.getInt(\"UPDATE_RULE\"), rs.getInt(\"DELETE_RULE\"), tables);\n            }\n        } finally {\n            if (rs != null)\n                rs.close();\n        }\n        // also try to find all of the 'remote' tables in other schemas that\n        // point to our primary keys (not necessary in the normal case\n        // as we infer this from the opposite direction)\n        if (getSchema() != null || getCatalog() != null) {\n            try {\n                // get the foreign keys that reference our primary keys\n                rs = db.getMetaData().getExportedKeys(getCatalog(), getSchema(), getName());\n                while (rs.next()) {\n                    String otherCatalog = rs.getString(\"FKTABLE_CAT\");\n                    String otherSchema = rs.getString(\"FKTABLE_SCHEM\");\n                    if (!String.valueOf(getSchema()).equals(String.valueOf(otherSchema)) || !String.valueOf(getCatalog()).equals(String.valueOf(otherCatalog))) {\n                        db.addRemoteTable(otherCatalog, otherSchema, rs.getString(\"FKTABLE_NAME\"), getSchema(), false);\n                    }\n                }\n            } finally {\n                if (rs != null)\n                    rs.close();\n            }\n        }\n    }\n\n    /**\n     * Get the foreign keys associated with this table\n     *\n     * @return\n     */\n    public Collection<ForeignKeyConstraint> getForeignKeys() {\n        return Collections.unmodifiableCollection(foreignKeys.values());\n    }\n\n    /**\n     * Add a check constraint to the table\n     * (no real details, just name and textual representation)\n     *\n     * @param constraintName\n     * @param text\n     */\n    public void addCheckConstraint(String constraintName, String text) {\n        checkConstraints.put(constraintName, text);\n    }\n\n    /**\n     * @param rs ResultSet from {@link DatabaseMetaData#getImportedKeys(String, String, String)}\n     * rs.getString(\"FK_NAME\");\n     * rs.getString(\"FKCOLUMN_NAME\");\n     * rs.getString(\"PKTABLE_CAT\");\n     * rs.getString(\"PKTABLE_SCHEM\");\n     * rs.getString(\"PKTABLE_NAME\");\n     * rs.getString(\"PKCOLUMN_NAME\");\n     * @param tables Map\n     * @param db\n     * @throws SQLException\n     */\n    protected void addForeignKey(String fkName, String fkColName, String pkCatalog, String pkSchema, String pkTableName, String pkColName, int updateRule, int deleteRule, Map<String, Table> tables) throws SQLException {\n        if (fkName == null)\n            return;\n        Pattern include = Config.getInstance().getTableInclusions();\n        Pattern exclude = Config.getInstance().getTableExclusions();\n        if (!include.matcher(pkTableName).matches() || exclude.matcher(pkTableName).matches()) {\n            if (fineEnabled)\n                logger.fine(\"Ignoring \" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName) + \" referenced by FK \" + fkName);\n            return;\n        }\n        ForeignKeyConstraint foreignKey = foreignKeys.get(fkName);\n        if (foreignKey == null) {\n            foreignKey = new ForeignKeyConstraint(this, fkName, updateRule, deleteRule);\n            foreignKeys.put(fkName, foreignKey);\n        }\n        TableColumn childColumn = getColumn(fkColName);\n        if (childColumn != null) {\n            foreignKey.addChildColumn(childColumn);\n            Config config = Config.getInstance();\n            Table parentTable = tables.get(pkTableName);\n            String parentContainer = pkSchema != null ? pkSchema : pkCatalog != null ? pkCatalog : db.getName();\n            String baseContainer = config.getSchema() != null ? config.getSchema() : config.getCatalog() != null ? config.getCatalog() : db.getName();\n            // if named table doesn't exist in this schema\n            // or exists here but really referencing same named table in another schema\n            if (parentTable == null || !baseContainer.equals(parentContainer)) {\n                if (fineEnabled)\n                    logger.fine(\"Adding remote table \" + getFullName(db.getName(), pkCatalog, pkSchema, pkTableName));\n                parentTable = db.addRemoteTable(pkCatalog, pkSchema, pkTableName, baseContainer, false);\n            }\n            if (parentTable != null) {\n                TableColumn parentColumn = parentTable.getColumn(pkColName);\n                if (parentColumn != null) {\n                    foreignKey.addParentColumn(parentColumn);\n                    childColumn.addParent(parentColumn, foreignKey);\n                    parentColumn.addChild(childColumn, foreignKey);\n                } else {\n                    logger.warning(\"Couldn't add FK '\" + foreignKey.getName() + \"' to table '\" + this + \"' - Column '\" + pkColName + \"' doesn't exist in table '\" + parentTable + \"'\");\n                }\n            } else {\n                logger.warning(\"Couldn't add FK '\" + foreignKey.getName() + \"' to table '\" + this + \"' - Unknown Referenced Table '\" + pkTableName + \"'\");\n            }\n        } else {\n            logger.warning(\"Couldn't add FK '\" + foreignKey.getName() + \"' to table '\" + this + \"' - Column '\" + fkColName + \"' doesn't exist\");\n        }\n    }\n\n    /**\n     * @param meta\n     * @throws SQLException\n     */\n    private void initPrimaryKeys() throws SQLException {\n        ResultSet rs = null;\n        try {\n            if (fineEnabled)\n                logger.fine(\"Querying primary keys for \" + getFullName());\n            rs = db.getMetaData().getPrimaryKeys(getCatalog(), getSchema(), getName());\n            while (rs.next()) setPrimaryColumn(rs);\n        } catch (SQLException exc) {\n            if (!isLogical()) {\n                throw exc;\n            }\n        } finally {\n            if (rs != null)\n                rs.close();\n        }\n    }\n\n    /**\n     * @param rs\n     * @throws SQLException\n     */\n    private void setPrimaryColumn(ResultSet rs) throws SQLException {\n        String pkName = rs.getString(\"PK_NAME\");\n        if (pkName == null)\n            return;\n        TableIndex index = getIndex(pkName);\n        if (index != null) {\n            index.setIsPrimaryKey(true);\n        }\n        String columnName = rs.getString(\"COLUMN_NAME\");\n        setPrimaryColumn(getColumn(columnName));\n    }\n\n    /**\n     * @param primaryColumn\n     */\n    void setPrimaryColumn(TableColumn primaryColumn) {\n        primaryKeys.add(primaryColumn);\n    }\n\n    /**\n     * @throws SQLException\n     */\n    private void initColumns() throws SQLException {\n        ResultSet rs = null;\n        synchronized (Table.class) {\n            try {\n                rs = db.getMetaData().getColumns(getCatalog(), getSchema(), getName(), \"%\");\n                while (rs.next()) addColumn(rs);\n            } catch (SQLException exc) {\n                if (!isLogical()) {\n                    class ColumnInitializationFailure extends SQLException {\n\n                        private static final long serialVersionUID = 1L;\n\n                        public ColumnInitializationFailure(SQLException failure) {\n                            super(\"Failed to collect column details for \" + (isView() ? \"view\" : \"table\") + \" '\" + getName() + \"' in schema '\" + getContainer() + \"'\");\n                            initCause(failure);\n                        }\n                    }\n                    throw new ColumnInitializationFailure(exc);\n                }\n            } finally {\n                if (rs != null)\n                    rs.close();\n            }\n        }\n        initColumnAutoUpdate(false);\n    }\n\n    /**\n     * @param forceQuotes\n     * @throws SQLException\n     */\n    private void initColumnAutoUpdate(boolean forceQuotes) throws SQLException {\n        ResultSet rs = null;\n        PreparedStatement stmt = null;\n        if (isView() || isRemote())\n            return;\n        // we've got to get a result set with all the columns in it\n        // so we can ask if the columns are auto updated\n        // Ugh!!!  Should have been in DatabaseMetaData instead!!!\n        StringBuilder sql = new StringBuilder(\"select * from \");\n        if (getSchema() != null) {\n            sql.append(getSchema());\n            sql.append('.');\n        } else if (getCatalog() != null) {\n            sql.append(getCatalog());\n            sql.append('.');\n        }\n        if (forceQuotes) {\n            String quote = db.getMetaData().getIdentifierQuoteString().trim();\n            sql.append(quote + getName() + quote);\n        } else\n            sql.append(db.getQuotedIdentifier(getName()));\n        sql.append(\" where 0 = 1\");\n        try {\n            stmt = db.getMetaData().getConnection().prepareStatement(sql.toString());\n            rs = stmt.executeQuery();\n            ResultSetMetaData rsMeta = rs.getMetaData();\n            for (int i = rsMeta.getColumnCount(); i > 0; --i) {\n                TableColumn column = getColumn(rsMeta.getColumnName(i));\n                column.setIsAutoUpdated(rsMeta.isAutoIncrement(i));\n            }\n        } catch (SQLException exc) {\n            if (forceQuotes) {\n                if (!isLogical()) {\n                    // don't completely choke just because we couldn't do this....\n                    logger.warning(\"Failed to determine auto increment status: \" + exc);\n                    logger.warning(\"SQL: \" + sql.toString());\n                }\n            } else {\n                initColumnAutoUpdate(true);\n            }\n        } finally {\n            if (rs != null)\n                rs.close();\n            if (stmt != null)\n                stmt.close();\n        }\n    }\n\n    /**\n     * @param rs - from {@link DatabaseMetaData#getColumns(String, String, String, String)}\n     * @throws SQLException\n     */\n    protected void addColumn(ResultSet rs) throws SQLException {\n        String columnName = rs.getString(\"COLUMN_NAME\");\n        if (columnName == null)\n            return;\n        if (getColumn(columnName) == null) {\n            TableColumn column = new TableColumn(this, rs);\n            columns.put(column.getName(), column);\n        }\n    }\n\n    /**\n     * Add a column that's defined in xml metadata.\n     * Assumes that a column named colMeta.getName() doesn't already exist in <code>columns</code>.\n     * @param colMeta\n     * @return\n     */\n    protected TableColumn addColumn(TableColumnMeta colMeta) {\n        TableColumn column = new TableColumn(this, colMeta);\n        columns.put(column.getName(), column);\n        return column;\n    }\n\n    /**\n     * Initialize index information\n     *\n     * @throws SQLException\n     */\n    private void initIndexes() throws SQLException {\n        if (isView() || isRemote())\n            return;\n        // first try to initialize using the index query spec'd in the .properties\n        // do this first because some DB's (e.g. Oracle) do 'bad' things with getIndexInfo()\n        // (they try to do a DDL analyze command that has some bad side-effects)\n        if (initIndexes(Config.getInstance().getDbProperties().getProperty(\"selectIndexesSql\")))\n            return;\n        // couldn't, so try the old fashioned approach\n        ResultSet rs = null;\n        try {\n            rs = db.getMetaData().getIndexInfo(getCatalog(), getSchema(), getName(), false, true);\n            while (rs.next()) {\n                if (rs.getShort(\"TYPE\") != DatabaseMetaData.tableIndexStatistic)\n                    addIndex(rs);\n            }\n        } catch (SQLException exc) {\n            if (!isLogical())\n                logger.warning(\"Unable to extract index info for table '\" + getName() + \"' in schema '\" + getContainer() + \"': \" + exc);\n        } finally {\n            if (rs != null)\n                rs.close();\n        }\n    }\n\n    /**\n     * Try to initialize index information based on the specified SQL\n     *\n     * @return boolean <code>true</code> if it worked, otherwise <code>false</code>\n     */\n    private boolean initIndexes(String selectIndexesSql) {\n        if (selectIndexesSql == null)\n            return false;\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = db.prepareStatement(selectIndexesSql, getName());\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                if (rs.getShort(\"TYPE\") != DatabaseMetaData.tableIndexStatistic)\n                    addIndex(rs);\n            }\n        } catch (SQLException sqlException) {\n            logger.warning(\"Failed to query index information with SQL: \" + selectIndexesSql);\n            logger.warning(sqlException.toString());\n            return false;\n        } finally {\n            if (rs != null) {\n                try {\n                    rs.close();\n                } catch (Exception exc) {\n                    exc.printStackTrace();\n                }\n            }\n            if (stmt != null) {\n                try {\n                    stmt.close();\n                } catch (Exception exc) {\n                    exc.printStackTrace();\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @param indexName\n     * @return\n     */\n    public TableIndex getIndex(String indexName) {\n        return indexes.get(indexName);\n    }\n\n    /**\n     * @param rs\n     * @throws SQLException\n     */\n    private void addIndex(ResultSet rs) throws SQLException {\n        String indexName = rs.getString(\"INDEX_NAME\");\n        if (indexName == null)\n            return;\n        TableIndex index = getIndex(indexName);\n        if (index == null) {\n            index = new TableIndex(rs);\n            indexes.put(index.getName(), index);\n        }\n        index.addColumn(getColumn(rs.getString(\"COLUMN_NAME\")), rs.getString(\"ASC_OR_DESC\"));\n    }\n\n    /**\n     * Returns the catalog that the table belongs to\n     *\n     * @return\n     */\n    public String getCatalog() {\n        return catalog;\n    }\n\n    /**\n     * Returns the schema that the table belongs to\n     *\n     * @return\n     */\n    public String getSchema() {\n        return schema;\n    }\n\n    /**\n     * Returns the logical 'container' that the table\n     * lives in.  Basically it's the first non-<code>null</code>\n     * item out of <code>schema</code>, <code>catalog</code>\n     * and <code>database</code>.\n     *\n     * @return\n     */\n    public String getContainer() {\n        return container;\n    }\n\n    /**\n     * Returns the name of the table\n     *\n     * @return\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the fully-qualified name of this table\n     *\n     * @return\n     */\n    public String getFullName() {\n        return fullName;\n    }\n\n    /**\n     * Returns the fully-qualified name of a table\n     *\n     * @return\n     */\n    public static String getFullName(String db, String catalog, String schema, String table) {\n        String fullName = (catalog == null && schema == null ? db + '.' : \"\") + (catalog == null ? \"\" : catalog + '.') + (schema == null ? \"\" : schema + '.') + table;\n        return fullName;\n    }\n\n    /**\n     * Object IDs are useful for tables such as DB/2 that many times\n     * give error messages based on object ID and not name\n     *\n     * @param id\n     */\n    public void setId(Object id) {\n        this.id = id;\n    }\n\n    /**\n     * @see #setId(Object)\n     *\n     * @return\n     */\n    public Object getId() {\n        return id;\n    }\n\n    /**\n     * Returns the check constraints associated with this table\n     *\n     * @return\n     */\n    public Map<String, String> getCheckConstraints() {\n        return checkConstraints;\n    }\n\n    /**\n     * Returns the indexes that are applied to this table\n     *\n     * @return\n     */\n    public Set<TableIndex> getIndexes() {\n        return new HashSet<TableIndex>(indexes.values());\n    }\n\n    /**\n     * Returns a collection of table columns that have been identified as \"primary\"\n     *\n     * @return\n     */\n    public List<TableColumn> getPrimaryColumns() {\n        return primaryKeys;\n    }\n\n    /**\n     * @return Comments associated with this table, or <code>null</code> if none.\n     */\n    public String getComments() {\n        return comments;\n    }\n\n    /**\n     * Sets the comments that are associated with this table\n     *\n     * @param comments\n     */\n    public void setComments(String comments) {\n        String cmts = (comments == null || comments.trim().length() == 0) ? null : comments.trim();\n        // MySQL's InnoDB engine does some insane crap of storing erroneous details in\n        // with table comments.  Here I attempt to strip the \"crap\" out without impacting\n        // other databases.  Ideally this should happen in selectColumnCommentsSql (and\n        // therefore isolate it to MySQL), but it's a bit too complex to do cleanly.\n        if (cmts != null) {\n            int crapIndex = cmts.indexOf(\"; InnoDB free: \");\n            if (crapIndex == -1)\n                crapIndex = cmts.startsWith(\"InnoDB free: \") ? 0 : -1;\n            if (crapIndex != -1) {\n                cmts = cmts.substring(0, crapIndex).trim();\n                cmts = cmts.length() == 0 ? null : cmts;\n            }\n        }\n        this.comments = cmts;\n    }\n\n    /**\n     * Returns the {@link TableColumn} with the given name, or <code>null</code>\n     * if it doesn't exist\n     *\n     * @param columnName\n     * @return\n     */\n    public TableColumn getColumn(String columnName) {\n        return columns.get(columnName);\n    }\n\n    /**\n     * Returns <code>List</code> of <code>TableColumn</code>s in ascending column number order.\n     *\n     * @return\n     */\n    public List<TableColumn> getColumns() {\n        Set<TableColumn> sorted = new TreeSet<TableColumn>(new ByColumnIdComparator());\n        sorted.addAll(columns.values());\n        return new ArrayList<TableColumn>(sorted);\n    }\n\n    /**\n     * Returns <code>true</code> if this table references no other tables..<p/>\n     * Used in dependency analysis.\n     * @return\n     */\n    public boolean isRoot() {\n        for (TableColumn column : columns.values()) {\n            if (column.isForeignKey()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns <code>true</code> if this table is referenced by no other tables.<p/>\n     * Used in dependency analysis.\n     * @return\n     */\n    public boolean isLeaf() {\n        for (TableColumn column : columns.values()) {\n            if (!column.getChildren().isEmpty()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the maximum number of parents that this table has had before\n     * any had been removed during dependency analysis\n     *\n     * @return\n     */\n    public int getMaxParents() {\n        return maxParents;\n    }\n\n    /**\n     * Notification that's called to indicate that a parent has been added to\n     * this table\n     */\n    public void addedParent() {\n        maxParents++;\n    }\n\n    /**\n     * \"Unlink\" all of the parent tables from this table\n     */\n    public void unlinkParents() {\n        for (TableColumn column : columns.values()) {\n            column.unlinkParents();\n        }\n    }\n\n    /**\n     * Returns the maximum number of children that this table has had before\n     * any had been removed during dependency analysis\n     *\n     * @return\n     */\n    public int getMaxChildren() {\n        return maxChildren;\n    }\n\n    /**\n     * Notification that's called to indicate that a child has been added to\n     * this table\n     */\n    public void addedChild() {\n        maxChildren++;\n    }\n\n    /**\n     * \"Unlink\" all of the child tables from this table\n     */\n    public void unlinkChildren() {\n        for (TableColumn column : columns.values()) {\n            column.unlinkChildren();\n        }\n    }\n\n    /**\n     * Remove a single self referencing constraint if one exists.\n     *\n     * @return\n     */\n    public ForeignKeyConstraint removeSelfReferencingConstraint() {\n        return remove(getSelfReferencingConstraint());\n    }\n\n    /**\n     * Remove the specified {@link ForeignKeyConstraint} from this table.<p>\n     *\n     * This is a more drastic removal solution that was proposed by Remke Rutgers\n     *\n     * @param constraint\n     */\n    private ForeignKeyConstraint remove(ForeignKeyConstraint constraint) {\n        if (constraint != null) {\n            for (int i = 0; i < constraint.getChildColumns().size(); i++) {\n                TableColumn childColumn = constraint.getChildColumns().get(i);\n                TableColumn parentColumn = constraint.getParentColumns().get(i);\n                childColumn.removeParent(parentColumn);\n                parentColumn.removeChild(childColumn);\n            }\n        }\n        return constraint;\n    }\n\n    /**\n     * Return a self referencing constraint if one exists\n     *\n     * @return\n     */\n    private ForeignKeyConstraint getSelfReferencingConstraint() {\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                if (compareTo(parentColumn.getTable()) == 0) {\n                    return column.getParentConstraint(parentColumn);\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Remove any non-real foreign keys\n     *\n     * @return\n     */\n    public List<ForeignKeyConstraint> removeNonRealForeignKeys() {\n        List<ForeignKeyConstraint> nonReals = new ArrayList<ForeignKeyConstraint>();\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                ForeignKeyConstraint constraint = column.getParentConstraint(parentColumn);\n                if (constraint != null && !constraint.isReal()) {\n                    nonReals.add(constraint);\n                }\n            }\n        }\n        // remove constraints outside of above loop to prevent\n        // concurrent modification exceptions while iterating\n        for (ForeignKeyConstraint constraint : nonReals) {\n            remove(constraint);\n        }\n        return nonReals;\n    }\n\n    /**\n     * Returns the number of tables that reference this table\n     *\n     * @return\n     */\n    public int getNumChildren() {\n        int numChildren = 0;\n        for (TableColumn column : columns.values()) {\n            numChildren += column.getChildren().size();\n        }\n        return numChildren;\n    }\n\n    /**\n     * Returns the number of non-implied children\n     * @return\n     */\n    public int getNumNonImpliedChildren() {\n        int numChildren = 0;\n        for (TableColumn column : columns.values()) {\n            for (TableColumn childColumn : column.getChildren()) {\n                if (!column.getChildConstraint(childColumn).isImplied())\n                    ++numChildren;\n            }\n        }\n        return numChildren;\n    }\n\n    /**\n     * Returns the number of tables that are referenced by this table\n     *\n     * @return\n     */\n    public int getNumParents() {\n        int numParents = 0;\n        for (TableColumn column : columns.values()) {\n            numParents += column.getParents().size();\n        }\n        return numParents;\n    }\n\n    /**\n     * Returns the number of non-implied parents\n     *\n     * @return\n     */\n    public int getNumNonImpliedParents() {\n        int numParents = 0;\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                if (!column.getParentConstraint(parentColumn).isImplied())\n                    ++numParents;\n            }\n        }\n        return numParents;\n    }\n\n    /**\n     * Remove one foreign key constraint.\n     *\n     * <p/>Used during dependency analysis phase.\n     *\n     * @return\n     */\n    public ForeignKeyConstraint removeAForeignKeyConstraint() {\n        @SuppressWarnings(\"hiding\")\n        final List<TableColumn> columns = getColumns();\n        int numParents = 0;\n        int numChildren = 0;\n        // remove either a child or parent, choosing which based on which has the\n        // least number of foreign key associations (when either gets to zero then\n        // the table can be pruned)\n        for (TableColumn column : columns) {\n            numParents += column.getParents().size();\n            numChildren += column.getChildren().size();\n        }\n        for (TableColumn column : columns) {\n            ForeignKeyConstraint constraint;\n            if (numParents <= numChildren)\n                constraint = column.removeAParentFKConstraint();\n            else\n                constraint = column.removeAChildFKConstraint();\n            if (constraint != null)\n                return constraint;\n        }\n        return null;\n    }\n\n    /**\n     * Returns <code>true</code> if this table is logical (not physical), <code>false</code> otherwise\n     * @return\n     */\n    public boolean isLogical() {\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if this is a view, <code>false</code> otherwise\n     *\n     * @return\n     */\n    public boolean isView() {\n        return false;\n    }\n\n    /**\n     * Returns <code>true</code> if this table is remote (in another schema), <code>false</code> otherwise\n     * @return\n     */\n    public boolean isRemote() {\n        return false;\n    }\n\n    /**\n     * If this is a view it returns the SQL used to create the view (if it's available).\n     * <code>null</code> if it's not a view or the SQL isn't available.\n     * @return\n     * @see #isView()\n     */\n    public String getViewSql() {\n        return null;\n    }\n\n    /**\n     * Returns the number of rows contained in this table, or -1 if unable to determine\n     * the number of rows.\n     *\n     * @return\n     */\n    public long getNumRows() {\n        if (numRows == null) {\n            numRows = Config.getInstance().isNumRowsEnabled() ? fetchNumRows() : -1;\n        }\n        return numRows;\n    }\n\n    /**\n     * Explicitly set the number of rows in this table\n     *\n     * @param numRows\n     */\n    public void setNumRows(long numRows) {\n        this.numRows = numRows;\n    }\n\n    /**\n     * Fetch the number of rows contained in this table.\n     *\n     * returns -1 if unable to successfully fetch the row count\n     *\n     * @param db Database\n     * @return int\n     * @throws SQLException\n     */\n    protected long fetchNumRows() {\n        if (isView() || isRemote())\n            return -1;\n        SQLException originalFailure = null;\n        String sql = Config.getInstance().getDbProperties().getProperty(\"selectRowCountSql\");\n        if (sql != null) {\n            PreparedStatement stmt = null;\n            ResultSet rs = null;\n            try {\n                stmt = db.prepareStatement(sql, getName());\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    return rs.getLong(\"row_count\");\n                }\n            } catch (SQLException sqlException) {\n                // don't die just because this failed\n                originalFailure = sqlException;\n            } finally {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    } catch (SQLException exc) {\n                    }\n                }\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException exc) {\n                    }\n                }\n            }\n        }\n        // if we get here then we either didn't have custom SQL or it didn't work\n        try {\n            // '*' should work best for the majority of cases\n            return fetchNumRows(\"count(*)\", false);\n        } catch (SQLException try2Exception) {\n            try {\n                // except nested tables...try using '1' instead\n                return fetchNumRows(\"count(1)\", false);\n            } catch (SQLException try3Exception) {\n                if (!isLogical()) {\n                    logger.warning(\"Unable to extract the number of rows for table \" + getName() + \", using '-1'\");\n                    if (originalFailure != null)\n                        logger.warning(originalFailure.toString());\n                    logger.warning(try2Exception.toString());\n                    if (!String.valueOf(try2Exception.toString()).equals(try3Exception.toString()))\n                        logger.warning(try3Exception.toString());\n                }\n                return -1;\n            }\n        }\n    }\n\n    protected long fetchNumRows(String clause, boolean forceQuotes) throws SQLException {\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        StringBuilder sql = new StringBuilder(\"select \");\n        sql.append(clause);\n        sql.append(\" from \");\n        if (getSchema() != null) {\n            sql.append(getSchema());\n            sql.append('.');\n        } else if (getCatalog() != null) {\n            sql.append(getCatalog());\n            sql.append('.');\n        }\n        if (forceQuotes) {\n            String quote = db.getMetaData().getIdentifierQuoteString().trim();\n            sql.append(quote + getName() + quote);\n        } else\n            sql.append(db.getQuotedIdentifier(getName()));\n        try {\n            if (finerEnabled)\n                logger.finer(sql.toString());\n            stmt = db.getConnection().prepareStatement(sql.toString());\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                return rs.getLong(1);\n            }\n            return -1;\n        } catch (SQLException exc) {\n            if (// we tried with and w/o quotes...fail this attempt\n            forceQuotes)\n                throw exc;\n            return fetchNumRows(clause, true);\n        } finally {\n            if (rs != null)\n                rs.close();\n            if (stmt != null)\n                stmt.close();\n        }\n    }\n\n    /**\n     * Update the table with the specified XML-derived metadata\n     *\n     * @param tableMeta\n     */\n    public void update(TableMeta tableMeta) {\n        String newComments = tableMeta.getComments();\n        if (newComments != null) {\n            comments = newComments;\n        }\n        for (TableColumnMeta colMeta : tableMeta.getColumns()) {\n            TableColumn col = getColumn(colMeta.getName());\n            if (col == null) {\n                col = addColumn(colMeta);\n            }\n            // update the column with the changes\n            col.update(colMeta);\n        }\n    }\n\n    /**\n     * Same as {@link #connectForeignKeys(Map, Database, Properties)},\n     * but uses XML-based metadata\n     *\n     * @param tableMeta\n     * @param tables\n     */\n    public void connect(TableMeta tableMeta, Map<String, Table> tables) {\n        for (TableColumnMeta colMeta : tableMeta.getColumns()) {\n            TableColumn col = getColumn(colMeta.getName());\n            if (col != null) {\n                // go thru the new foreign key defs and associate them with our columns\n                for (ForeignKeyMeta fk : colMeta.getForeignKeys()) {\n                    Table parent;\n                    if (fk.getRemoteCatalog() != null || fk.getRemoteSchema() != null) {\n                        try {\n                            // adds if doesn't exist\n                            parent = db.addRemoteTable(fk.getRemoteCatalog(), fk.getRemoteSchema(), fk.getTableName(), getContainer(), true);\n                        } catch (SQLException exc) {\n                            parent = null;\n                        }\n                    } else {\n                        parent = tables.get(fk.getTableName());\n                    }\n                    if (parent != null) {\n                        TableColumn parentColumn = parent.getColumn(fk.getColumnName());\n                        if (parentColumn == null) {\n                            logger.warning(\"Undefined column '\" + parent.getName() + '.' + fk.getColumnName() + \"' referenced by '\" + col.getTable() + '.' + col + \"' in XML metadata\");\n                        } else {\n                            /**\n                             * Merely instantiating a foreign key constraint ties it\n                             * into its parent and child columns (& therefore their tables)\n                             */\n                            @SuppressWarnings(\"unused\")\n                            ForeignKeyConstraint unused = new ForeignKeyConstraint(parentColumn, col) {\n\n                                @Override\n                                public String getName() {\n                                    return \"Defined in XML\";\n                                }\n                            };\n                            // they forgot to say it was a primary key\n                            if (!parentColumn.isPrimary()) {\n                                logger.warning(\"Assuming \" + parentColumn.getTable() + '.' + parentColumn + \" is a primary key due to being referenced by \" + col.getTable() + '.' + col);\n                                parent.setPrimaryColumn(parentColumn);\n                            }\n                        }\n                    } else {\n                        logger.warning(\"Undefined table '\" + fk.getTableName() + \"' referenced by '\" + getName() + '.' + col.getName() + \"' in XML metadata\");\n                    }\n                }\n            } else {\n                logger.warning(\"Undefined column '\" + getName() + '.' + colMeta.getName() + \"' in XML metadata\");\n            }\n        }\n    }\n\n    @Override\n    public String toString() {\n        return getName();\n    }\n\n    /**\n     * Returns <code>true</code> if this table has no relationships\n     *\n     * @param withImpliedRelationships boolean\n     * @return boolean\n     */\n    public boolean isOrphan(boolean withImpliedRelationships) {\n        if (withImpliedRelationships)\n            return getMaxParents() == 0 && getMaxChildren() == 0;\n        for (TableColumn column : columns.values()) {\n            for (TableColumn parentColumn : column.getParents()) {\n                if (!column.getParentConstraint(parentColumn).isImplied())\n                    return false;\n            }\n            for (TableColumn childColumn : column.getChildren()) {\n                if (!column.getChildConstraint(childColumn).isImplied())\n                    return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compare this table to another table.\n     * Results are based on 1: identity, 2: table name, 3: schema name<p/>\n     *\n     * This implementation was put in place to deal with analyzing multiple\n     * schemas that contain identically named tables.\n     *\n     * @see {@link Comparable#compareTo(Object)}\n     */\n    public int compareTo(Table other) {\n        if (// fast way out\n        other == this)\n            return 0;\n        return getFullName().compareToIgnoreCase(other.getFullName());\n    }\n\n    /**\n     * Implementation of {@link Comparator} that sorts {@link TableColumn}s\n     * by {@link TableColumn#getId() ID} (ignored if <code>null</code>)\n     * followed by {@link TableColumn#getName() Name}.\n     */\n    public static class ByColumnIdComparator implements Comparator<TableColumn> {\n\n        public int compare(TableColumn column1, TableColumn column2) {\n            Object id1 = column1.getId();\n            Object id2 = column2.getId();\n            if (id1 == null || id2 == null)\n                return column1.getName().compareToIgnoreCase(column2.getName());\n            if (id1 instanceof Number && id2 instanceof Number)\n                return ((Number) id1).intValue() - ((Number) id2).intValue();\n            return id1.toString().compareToIgnoreCase(id2.toString());\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableTest10.java",
		"test_prompt": "// TableTest10.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.ForeignKeyMeta;\nimport net.sourceforge.schemaspy.model.xml.TableColumnMeta;\nimport net.sourceforge.schemaspy.model.xml.TableMeta;\nimport net.sourceforge.schemaspy.util.CaseInsensitiveMap;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Table}.\n* It contains ten unit test cases for the {@link Table#compareTo(Table)} method.\n*/\nclass TableTest10 {"
	},
	{
		"original_code": "// Database.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.Connection;\nimport java.sql.DatabaseMetaData;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.MissingResourceException;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.SchemaMeta;\nimport net.sourceforge.schemaspy.model.xml.TableMeta;\nimport net.sourceforge.schemaspy.util.CaseInsensitiveMap;\n\npublic class Database {\n\n    private final Config config;\n\n    private final String databaseName;\n\n    private final String catalog;\n\n    private final String schema;\n\n    private final Map<String, Table> tables = new CaseInsensitiveMap<Table>();\n\n    private final Map<String, View> views = new CaseInsensitiveMap<View>();\n\n    // key: schema.tableName\n    private final Map<String, Table> remoteTables = new CaseInsensitiveMap<Table>();\n\n    private final Map<String, Table> locals = new CombinedMap(tables, views);\n\n    private final Map<String, Routine> routines = new CaseInsensitiveMap<Routine>();\n\n    private final DatabaseMetaData meta;\n\n    private final Connection connection;\n\n    private final String connectTime = new SimpleDateFormat(\"EEE MMM dd HH:mm z yyyy\").format(new Date());\n\n    private Set<String> sqlKeywords;\n\n    private Pattern invalidIdentifierPattern;\n\n    private final Logger logger = Logger.getLogger(getClass().getName());\n\n    private final boolean fineEnabled = logger.isLoggable(Level.FINE);\n\n    public Database(Config config, Connection connection, DatabaseMetaData meta, String name, String catalog, String schema, SchemaMeta schemaMeta) throws SQLException, MissingResourceException {\n        this.config = config;\n        this.connection = connection;\n        this.meta = meta;\n        this.databaseName = name;\n        this.catalog = catalog;\n        this.schema = schema;\n        initTables(meta);\n        if (config.isViewsEnabled())\n            initViews(meta);\n        initCheckConstraints();\n        initTableIds();\n        initIndexIds();\n        initTableComments();\n        initTableColumnComments();\n        initViewComments();\n        initViewColumnComments();\n        initColumnTypes();\n        initRoutines();\n        connectTables();\n        updateFromXmlMetadata(schemaMeta);\n    }\n\n    public String getName() {\n        return databaseName;\n    }\n\n    public String getCatalog() {\n        return catalog;\n    }\n\n    public String getSchema() {\n        return schema;\n    }\n\n    /**\n     * Details of the database type that's running under the covers.\n     *\n     * @return null if a description wasn't specified.\n     */\n    public String getDescription() {\n        return config.getDescription();\n    }\n\n    public Collection<Table> getTables() {\n        return tables.values();\n    }\n\n    /**\n     * Return a {@link Map} of all {@link Table}s keyed by their name.\n     *\n     * @return\n     */\n    public Map<String, Table> getTablesByName() {\n        return tables;\n    }\n\n    public Collection<View> getViews() {\n        return views.values();\n    }\n\n    public Collection<Table> getRemoteTables() {\n        return remoteTables.values();\n    }\n\n    public Collection<Routine> getRoutines() {\n        return routines.values();\n    }\n\n    public Connection getConnection() {\n        return connection;\n    }\n\n    public DatabaseMetaData getMetaData() {\n        return meta;\n    }\n\n    public String getConnectTime() {\n        return connectTime;\n    }\n\n    public String getDatabaseProduct() {\n        try {\n            return meta.getDatabaseProductName() + \" - \" + meta.getDatabaseProductVersion();\n        } catch (SQLException exc) {\n            return \"\";\n        }\n    }\n\n    /**\n     *  \"macro\" to validate that a table is somewhat valid\n     */\n    class NameValidator {\n\n        private final String clazz;\n\n        private final Pattern include;\n\n        private final Pattern exclude;\n\n        private final Set<String> validTypes;\n\n        /**\n         * @param clazz table or view\n         * @param include\n         * @param exclude\n         * @param verbose\n         * @param validTypes\n         */\n        NameValidator(String clazz, Pattern include, Pattern exclude, String[] validTypes) {\n            this.clazz = clazz;\n            this.include = include;\n            this.exclude = exclude;\n            this.validTypes = new HashSet<String>();\n            for (String type : validTypes) {\n                this.validTypes.add(type.toUpperCase());\n            }\n        }\n\n        /**\n         * Returns <code>true</code> if the table/view name is deemed \"valid\"\n         *\n         * @param name name of the table or view\n         * @param type type as returned by metadata.getTables():TABLE_TYPE\n         * @return\n         */\n        boolean isValid(String name, String type) {\n            // some databases (MySQL) return more than we wanted\n            if (!validTypes.contains(type.toUpperCase()))\n                return false;\n            // Oracle 10g introduced problematic flashback tables\n            // with bizarre illegal names\n            if (name.indexOf(\"$\") != -1) {\n                if (fineEnabled) {\n                    logger.fine(\"Excluding \" + clazz + \" \" + name + \": embedded $ implies illegal name\");\n                }\n                return false;\n            }\n            if (exclude.matcher(name).matches()) {\n                if (fineEnabled) {\n                    logger.fine(\"Excluding \" + clazz + \" \" + name + \": matches exclusion pattern \\\"\" + exclude + '\"');\n                }\n                return false;\n            }\n            boolean valid = include.matcher(name).matches();\n            if (fineEnabled) {\n                if (valid) {\n                    logger.fine(\"Including \" + clazz + \" \" + name + \": matches inclusion pattern \\\"\" + include + '\"');\n                } else {\n                    logger.fine(\"Excluding \" + clazz + \" \" + name + \": doesn't match inclusion pattern \\\"\" + include + '\"');\n                }\n            }\n            return valid;\n        }\n    }\n\n    /**\n     * Create/initialize any tables in the schema.\n     *\n     * @param metadata\n     * @throws SQLException\n     */\n    private void initTables(final DatabaseMetaData metadata) throws SQLException {\n        final Pattern include = config.getTableInclusions();\n        final Pattern exclude = config.getTableExclusions();\n        final int maxThreads = config.getMaxDbThreads();\n        String[] types = getTypes(\"tableTypes\", \"TABLE\");\n        NameValidator validator = new NameValidator(\"table\", include, exclude, types);\n        List<BasicTableMeta> entries = getBasicTableMeta(metadata, true, types);\n        TableCreator creator;\n        if (maxThreads == 1) {\n            creator = new TableCreator();\n        } else {\n            // creating tables takes a LONG time (based on JProbe analysis),\n            // so attempt to speed it up by doing several in parallel.\n            // note that it's actually DatabaseMetaData.getIndexInfo() that's expensive\n            creator = new ThreadedTableCreator(maxThreads);\n            // \"prime the pump\" so if there's a database problem we'll probably see it now\n            // and not in a secondary thread\n            while (!entries.isEmpty()) {\n                BasicTableMeta entry = entries.remove(0);\n                if (validator.isValid(entry.name, entry.type)) {\n                    new TableCreator().create(entry);\n                    break;\n                }\n            }\n        }\n        // kick off the secondary threads to do the creation in parallel\n        for (BasicTableMeta entry : entries) {\n            if (validator.isValid(entry.name, entry.type)) {\n                creator.create(entry);\n            }\n        }\n        // wait for everyone to finish\n        creator.join();\n    }\n\n    /**\n     * Create/initialize any views in the schema.\n     *\n     * @param metadata\n     * @throws SQLException\n     */\n    private void initViews(DatabaseMetaData metadata) throws SQLException {\n        Pattern includeTables = config.getTableInclusions();\n        Pattern excludeTables = config.getTableExclusions();\n        String[] types = getTypes(\"viewTypes\", \"VIEW\");\n        NameValidator validator = new NameValidator(\"view\", includeTables, excludeTables, types);\n        for (BasicTableMeta entry : getBasicTableMeta(metadata, false, types)) {\n            if (validator.isValid(entry.name, entry.type)) {\n                View view = new View(this, entry.catalog, entry.schema, entry.name, entry.remarks, entry.viewSql);\n                views.put(view.getName(), view);\n                if (fineEnabled) {\n                    logger.fine(\"Found details of view \" + view.getName());\n                } else {\n                    System.out.print('.');\n                }\n            }\n        }\n    }\n\n    /**\n     * Collection of fundamental table/view metadata\n     */\n    private class BasicTableMeta {\n\n        @SuppressWarnings(\"hiding\")\n        final String catalog;\n\n        @SuppressWarnings(\"hiding\")\n        final String schema;\n\n        final String name;\n\n        final String type;\n\n        final String remarks;\n\n        final String viewSql;\n\n        // -1 if not determined\n        final int numRows;\n\n        /**\n         * @param schema\n         * @param name\n         * @param type typically \"TABLE\" or \"VIEW\"\n         * @param remarks\n         * @param text optional textual SQL used to create the view\n         * @param numRows number of rows, or -1 if not determined\n         */\n        BasicTableMeta(String catalog, String schema, String name, String type, String remarks, String text, int numRows) {\n            this.catalog = catalog;\n            this.schema = schema;\n            this.name = name;\n            this.type = type;\n            this.remarks = remarks;\n            viewSql = text;\n            this.numRows = numRows;\n        }\n    }\n\n    /**\n     * Return a list of basic details of the tables in the schema.\n     *\n     * @param metadata\n     * @param forTables true if we're getting table data, false if getting view data\n     * @return\n     * @throws SQLException\n     */\n    private List<BasicTableMeta> getBasicTableMeta(DatabaseMetaData metadata, boolean forTables, String... types) throws SQLException {\n        String queryName = forTables ? \"selectTablesSql\" : \"selectViewsSql\";\n        String sql = Config.getInstance().getDbProperties().getProperty(queryName);\n        List<BasicTableMeta> basics = new ArrayList<BasicTableMeta>();\n        ResultSet rs = null;\n        if (sql != null) {\n            String clazz = forTables ? \"table\" : \"view\";\n            PreparedStatement stmt = null;\n            try {\n                stmt = prepareStatement(sql, null);\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    String name = rs.getString(clazz + \"_name\");\n                    String cat = getOptionalString(rs, clazz + \"_catalog\");\n                    String sch = getOptionalString(rs, clazz + \"_schema\");\n                    if (cat == null && sch == null)\n                        sch = schema;\n                    String remarks = getOptionalString(rs, clazz + \"_comment\");\n                    String text = forTables ? null : getOptionalString(rs, \"view_definition\");\n                    String rows = forTables ? getOptionalString(rs, \"table_rows\") : null;\n                    int numRows = rows == null ? -1 : Integer.parseInt(rows);\n                    basics.add(new BasicTableMeta(cat, sch, name, clazz, remarks, text, numRows));\n                }\n            } catch (SQLException sqlException) {\n                // don't die just because this failed\n                warning(\"Failed to retrieve \" + clazz + \" names with custom SQL: \" + sqlException, sql);\n            } finally {\n                if (rs != null)\n                    rs.close();\n                if (stmt != null)\n                    stmt.close();\n            }\n        }\n        if (basics.isEmpty()) {\n            rs = metadata.getTables(null, schema, \"%\", types);\n            try {\n                while (rs.next()) {\n                    String name = rs.getString(\"TABLE_NAME\");\n                    String type = rs.getString(\"TABLE_TYPE\");\n                    String cat = rs.getString(\"TABLE_CAT\");\n                    String schem = rs.getString(\"TABLE_SCHEM\");\n                    String remarks = getOptionalString(rs, \"REMARKS\");\n                    basics.add(new BasicTableMeta(cat, schem, name, type, remarks, null, -1));\n                }\n            } catch (SQLException exc) {\n                if (forTables)\n                    throw exc;\n                System.out.flush();\n                System.err.println();\n                System.err.println(\"Ignoring view \" + rs.getString(\"TABLE_NAME\") + \" due to exception:\");\n                exc.printStackTrace();\n                System.err.println(\"Continuing analysis.\");\n            } finally {\n                if (rs != null)\n                    rs.close();\n            }\n        }\n        return basics;\n    }\n\n    /**\n     * Return a database-specific array of types from the .properties file\n     * with the specified property name.\n     *\n     * @param propName\n     * @param defaultValue\n     * @return\n     */\n    private String[] getTypes(String propName, String defaultValue) {\n        String value = config.getDbProperties().getProperty(propName, defaultValue);\n        List<String> types = new ArrayList<String>();\n        for (String type : value.split(\",\")) {\n            type = type.trim();\n            if (type.length() > 0)\n                types.add(type);\n        }\n        return types.toArray(new String[types.size()]);\n    }\n\n    /**\n     * Some databases don't play nice with their metadata.\n     * E.g. Oracle doesn't have a REMARKS column at all.\n     * This method ignores those types of failures, replacing them with null.\n     */\n    public String getOptionalString(ResultSet rs, String columnName) {\n        try {\n            return rs.getString(columnName);\n        } catch (SQLException ignore) {\n            return null;\n        }\n    }\n\n    private void initCheckConstraints() throws SQLException {\n        String sql = config.getDbProperties().getProperty(\"selectCheckConstraintsSql\");\n        if (sql != null) {\n            PreparedStatement stmt = null;\n            ResultSet rs = null;\n            try {\n                stmt = prepareStatement(sql, null);\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    String tableName = rs.getString(\"table_name\");\n                    Table table = locals.get(tableName);\n                    if (table != null)\n                        table.addCheckConstraint(rs.getString(\"constraint_name\"), rs.getString(\"text\"));\n                }\n            } catch (SQLException sqlException) {\n                // don't die just because this failed\n                warning(\"Failed to retrieve check constraints: \" + sqlException, sql);\n            } finally {\n                if (rs != null)\n                    rs.close();\n                if (stmt != null)\n                    stmt.close();\n            }\n        }\n    }\n\n    private void initColumnTypes() throws SQLException {\n        String sql = config.getDbProperties().getProperty(\"selectColumnTypesSql\");\n        if (sql != null) {\n            PreparedStatement stmt = null;\n            ResultSet rs = null;\n            try {\n                stmt = prepareStatement(sql, null);\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    String tableName = rs.getString(\"table_name\");\n                    Table table = locals.get(tableName);\n                    if (table != null) {\n                        String columnName = rs.getString(\"column_name\");\n                        TableColumn column = table.getColumn(columnName);\n                        if (column != null) {\n                            column.setType(rs.getString(\"column_type\"));\n                            column.setShortType(getOptionalString(rs, \"short_column_type\"));\n                        }\n                    }\n                }\n            } catch (SQLException sqlException) {\n                // don't die just because this failed\n                warning(\"Failed to retrieve column type details: \" + sqlException, sql);\n            } finally {\n                if (rs != null)\n                    rs.close();\n                if (stmt != null)\n                    stmt.close();\n            }\n        }\n    }\n\n    private void initTableIds() throws SQLException {\n        String sql = config.getDbProperties().getProperty(\"selectTableIdsSql\");\n        if (sql != null) {\n            PreparedStatement stmt = null;\n            ResultSet rs = null;\n            try {\n                stmt = prepareStatement(sql, null);\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    String tableName = rs.getString(\"table_name\");\n                    Table table = locals.get(tableName);\n                    if (table != null)\n                        table.setId(rs.getObject(\"table_id\"));\n                }\n            } catch (SQLException sqlException) {\n                System.err.println();\n                System.err.println(sql);\n                throw sqlException;\n            } finally {\n                if (rs != null)\n                    rs.close();\n                if (stmt != null)\n                    stmt.close();\n            }\n        }\n    }\n\n    private void initIndexIds() throws SQLException {\n        String sql = config.getDbProperties().getProperty(\"selectIndexIdsSql\");\n        if (sql != null) {\n            PreparedStatement stmt = null;\n            ResultSet rs = null;\n            try {\n                stmt = prepareStatement(sql, null);\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    String tableName = rs.getString(\"table_name\");\n                    Table table = locals.get(tableName);\n                    if (table != null) {\n                        TableIndex index = table.getIndex(rs.getString(\"index_name\"));\n                        if (index != null)\n                            index.setId(rs.getObject(\"index_id\"));\n                    }\n                }\n            } catch (SQLException sqlException) {\n                System.err.println();\n                System.err.println(sql);\n                throw sqlException;\n            } finally {\n                if (rs != null)\n                    rs.close();\n                if (stmt != null)\n                    stmt.close();\n            }\n        }\n    }\n\n    /**\n     * Initializes table comments.\n     * If the SQL also returns view comments then they're plugged into the\n     * appropriate views.\n     *\n     * @throws SQLException\n     */\n    private void initTableComments() throws SQLException {\n        String sql = config.getDbProperties().getProperty(\"selectTableCommentsSql\");\n        if (sql != null) {\n            PreparedStatement stmt = null;\n            ResultSet rs = null;\n            try {\n                stmt = prepareStatement(sql, null);\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    String tableName = rs.getString(\"table_name\");\n                    Table table = locals.get(tableName);\n                    if (table != null)\n                        table.setComments(rs.getString(\"comments\"));\n                }\n            } catch (SQLException sqlException) {\n                // don't die just because this failed\n                warning(\"Failed to retrieve table/view comments: \" + sqlException, sql);\n            } finally {\n                if (rs != null)\n                    rs.close();\n                if (stmt != null)\n                    stmt.close();\n            }\n        }\n    }\n\n    /**\n     * Initializes view comments.\n     *\n     * @throws SQLException\n     */\n    private void initViewComments() throws SQLException {\n        String sql = config.getDbProperties().getProperty(\"selectViewCommentsSql\");\n        if (sql != null) {\n            PreparedStatement stmt = null;\n            ResultSet rs = null;\n            try {\n                stmt = prepareStatement(sql, null);\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    String viewName = rs.getString(\"view_name\");\n                    if (viewName == null)\n                        viewName = rs.getString(\"table_name\");\n                    Table view = views.get(viewName);\n                    if (view != null)\n                        view.setComments(rs.getString(\"comments\"));\n                }\n            } catch (SQLException sqlException) {\n                // don't die just because this failed\n                warning(\"Failed to retrieve table/view comments: \" + sqlException, sql);\n            } finally {\n                if (rs != null)\n                    rs.close();\n                if (stmt != null)\n                    stmt.close();\n            }\n        }\n    }\n\n    /**\n     * Initializes table column comments.\n     * If the SQL also returns view column comments then they're plugged into the\n     * appropriate views.\n     *\n     * @throws SQLException\n     */\n    private void initTableColumnComments() throws SQLException {\n        String sql = config.getDbProperties().getProperty(\"selectColumnCommentsSql\");\n        if (sql != null) {\n            PreparedStatement stmt = null;\n            ResultSet rs = null;\n            try {\n                stmt = prepareStatement(sql, null);\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    String tableName = rs.getString(\"table_name\");\n                    Table table = locals.get(tableName);\n                    if (table != null) {\n                        TableColumn column = table.getColumn(rs.getString(\"column_name\"));\n                        if (column != null)\n                            column.setComments(rs.getString(\"comments\"));\n                    }\n                }\n            } catch (SQLException sqlException) {\n                // don't die just because this failed\n                warning(\"Failed to retrieve column comments: \" + sqlException, sql);\n            } finally {\n                if (rs != null)\n                    rs.close();\n                if (stmt != null)\n                    stmt.close();\n            }\n        }\n    }\n\n    /**\n     * Initializes view column comments.\n     *\n     * @throws SQLException\n     */\n    private void initViewColumnComments() throws SQLException {\n        String sql = config.getDbProperties().getProperty(\"selectViewColumnCommentsSql\");\n        if (sql != null) {\n            PreparedStatement stmt = null;\n            ResultSet rs = null;\n            try {\n                stmt = prepareStatement(sql, null);\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    String viewName = rs.getString(\"view_name\");\n                    if (viewName == null)\n                        viewName = rs.getString(\"table_name\");\n                    Table view = views.get(viewName);\n                    if (view != null) {\n                        TableColumn column = view.getColumn(rs.getString(\"column_name\"));\n                        if (column != null)\n                            column.setComments(rs.getString(\"comments\"));\n                    }\n                }\n            } catch (SQLException sqlException) {\n                // don't die just because this failed\n                warning(\"Failed to retrieve view column comments: \" + sqlException, sql);\n            } finally {\n                if (rs != null)\n                    rs.close();\n                if (stmt != null)\n                    stmt.close();\n            }\n        }\n    }\n\n    /**\n     * Initializes stored procedures / functions.\n     *\n     * @throws SQLException\n     */\n    private void initRoutines() throws SQLException {\n        String sql = config.getDbProperties().getProperty(\"selectRoutinesSql\");\n        if (sql != null) {\n            PreparedStatement stmt = null;\n            ResultSet rs = null;\n            try {\n                stmt = prepareStatement(sql, null);\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    String routineName = rs.getString(\"routine_name\");\n                    String routineType = rs.getString(\"routine_type\");\n                    String returnType = rs.getString(\"dtd_identifier\");\n                    String definitionLanguage = rs.getString(\"routine_body\");\n                    String definition = rs.getString(\"routine_definition\");\n                    String dataAccess = rs.getString(\"sql_data_access\");\n                    String securityType = rs.getString(\"security_type\");\n                    boolean deterministic = rs.getBoolean(\"is_deterministic\");\n                    String comment = getOptionalString(rs, \"routine_comment\");\n                    Routine routine = new Routine(routineName, routineType, returnType, definitionLanguage, definition, deterministic, dataAccess, securityType, comment);\n                    routines.put(routineName, routine);\n                }\n            } catch (SQLException sqlException) {\n                // don't die just because this failed\n                warning(\"Failed to retrieve stored procedure/function details: \" + sqlException, sql);\n            } finally {\n                if (rs != null)\n                    rs.close();\n                if (stmt != null)\n                    stmt.close();\n                rs = null;\n                stmt = null;\n            }\n        }\n        sql = config.getDbProperties().getProperty(\"selectRoutineParametersSql\");\n        if (sql != null) {\n            PreparedStatement stmt = null;\n            ResultSet rs = null;\n            try {\n                stmt = prepareStatement(sql, null);\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    String routineName = rs.getString(\"specific_name\");\n                    Routine routine = routines.get(routineName);\n                    if (routine != null) {\n                        String paramName = rs.getString(\"parameter_name\");\n                        String type = rs.getString(\"dtd_identifier\");\n                        String mode = rs.getString(\"parameter_mode\");\n                        RoutineParameter param = new RoutineParameter(paramName, type, mode);\n                        routine.addParameter(param);\n                    }\n                }\n            } catch (SQLException sqlException) {\n                // don't die just because this failed\n                warning(\"Failed to retrieve stored procedure/function details: \" + sqlException, sql);\n            } finally {\n                if (rs != null)\n                    rs.close();\n                if (stmt != null)\n                    stmt.close();\n            }\n        }\n    }\n\n    /**\n     * Dump a warning message out to a new line\n     *\n     * @param msg1\n     * @param msg2\n     */\n    private void warning(String msg1, String msg2) {\n        System.out.println();\n        System.out.flush();\n        logger.warning(msg1);\n        if (msg2 != null)\n            logger.warning(msg2);\n    }\n\n    /**\n     * Create a <code>PreparedStatement</code> from the specified SQL.\n     * The SQL can contain these named parameters (but <b>not</b> question marks).\n     * <ol>\n     * <li>:schema - replaced with the name of the schema\n     * <li>:owner - alias for :schema\n     * <li>:table - replaced with the name of the table\n     * </ol>\n     * @param sql String - SQL without question marks\n     * @param tableName String - <code>null</code> if the statement doesn't deal with <code>Table</code>-level details.\n     * @throws SQLException\n     * @return PreparedStatement\n     */\n    public PreparedStatement prepareStatement(String sql, String tableName) throws SQLException {\n        StringBuilder sqlBuf = new StringBuilder(sql);\n        // modifies sqlBuf\n        List<String> sqlParams = getSqlParams(sqlBuf, tableName);\n        if (fineEnabled)\n            logger.fine(sqlBuf + \" \" + sqlParams);\n        PreparedStatement stmt = getConnection().prepareStatement(sqlBuf.toString());\n        try {\n            for (int i = 0; i < sqlParams.size(); ++i) {\n                stmt.setString(i + 1, sqlParams.get(i).toString());\n            }\n        } catch (SQLException exc) {\n            stmt.close();\n            throw exc;\n        }\n        return stmt;\n    }\n\n    public Table addRemoteTable(String remoteCatalog, String remoteSchema, String remoteTableName, String baseContainer, boolean logical) throws SQLException {\n        String fullName = getRemoteTableKey(remoteCatalog, remoteSchema, remoteTableName);\n        Table remoteTable = remoteTables.get(fullName);\n        if (remoteTable == null) {\n            if (fineEnabled)\n                logger.fine(\"Creating remote table \" + fullName);\n            if (logical)\n                remoteTable = new LogicalRemoteTable(this, remoteCatalog, remoteSchema, remoteTableName, baseContainer);\n            else\n                remoteTable = new RemoteTable(this, remoteCatalog, remoteSchema, remoteTableName, baseContainer);\n            if (fineEnabled)\n                logger.fine(\"Adding remote table \" + fullName);\n            remoteTables.put(fullName, remoteTable);\n            remoteTable.connectForeignKeys(locals);\n        }\n        return remoteTable;\n    }\n\n    /**\n     * Return an uppercased <code>Set</code> of all SQL keywords used by a database\n     *\n     * @return\n     * @throws SQLException\n     */\n    public Set<String> getSqlKeywords() throws SQLException {\n        if (sqlKeywords == null) {\n            // from http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt:\n            String[] sql92Keywords = (\"ADA\" + \"| C | CATALOG_NAME | CHARACTER_SET_CATALOG | CHARACTER_SET_NAME\" + \"| CHARACTER_SET_SCHEMA | CLASS_ORIGIN | COBOL | COLLATION_CATALOG\" + \"| COLLATION_NAME | COLLATION_SCHEMA | COLUMN_NAME | COMMAND_FUNCTION | COMMITTED\" + \"| CONDITION_NUMBER | CONNECTION_NAME | CONSTRAINT_CATALOG | CONSTRAINT_NAME\" + \"| CONSTRAINT_SCHEMA | CURSOR_NAME\" + \"| DATA | DATETIME_INTERVAL_CODE | DATETIME_INTERVAL_PRECISION | DYNAMIC_FUNCTION\" + \"| FORTRAN\" + \"| LENGTH\" + \"| MESSAGE_LENGTH | MESSAGE_OCTET_LENGTH | MESSAGE_TEXT | MORE | MUMPS\" + \"| NAME | NULLABLE | NUMBER\" + \"| PASCAL | PLI\" + \"| REPEATABLE | RETURNED_LENGTH | RETURNED_OCTET_LENGTH | RETURNED_SQLSTATE\" + \"| ROW_COUNT\" + \"| SCALE | SCHEMA_NAME | SERIALIZABLE | SERVER_NAME | SUBCLASS_ORIGIN\" + \"| TABLE_NAME | TYPE\" + \"| UNCOMMITTED | UNNAMED\" + \"| ABSOLUTE | ACTION | ADD | ALL | ALLOCATE | ALTER | AND\" + \"| ANY | ARE | AS | ASC\" + \"| ASSERTION | AT | AUTHORIZATION | AVG\" + \"| BEGIN | BETWEEN | BIT | BIT_LENGTH | BOTH | BY\" + \"| CASCADE | CASCADED | CASE | CAST | CATALOG | CHAR | CHARACTER | CHAR_LENGTH\" + \"| CHARACTER_LENGTH | CHECK | CLOSE | COALESCE | COLLATE | COLLATION\" + \"| COLUMN | COMMIT | CONNECT | CONNECTION | CONSTRAINT\" + \"| CONSTRAINTS | CONTINUE\" + \"| CONVERT | CORRESPONDING | COUNT | CREATE | CROSS | CURRENT\" + \"| CURRENT_DATE | CURRENT_TIME | CURRENT_TIMESTAMP | CURRENT_USER | CURSOR\" + \"| DATE | DAY | DEALLOCATE | DEC | DECIMAL | DECLARE | DEFAULT | DEFERRABLE\" + \"| DEFERRED | DELETE | DESC | DESCRIBE | DESCRIPTOR | DIAGNOSTICS\" + \"| DISCONNECT | DISTINCT | DOMAIN | DOUBLE | DROP\" + \"| ELSE | END | END-EXEC | ESCAPE | EXCEPT | EXCEPTION\" + \"| EXEC | EXECUTE | EXISTS\" + \"| EXTERNAL | EXTRACT\" + \"| FALSE | FETCH | FIRST | FLOAT | FOR | FOREIGN | FOUND | FROM | FULL\" + \"| GET | GLOBAL | GO | GOTO | GRANT | GROUP\" + \"| HAVING | HOUR\" + \"| IDENTITY | IMMEDIATE | IN | INDICATOR | INITIALLY | INNER | INPUT\" + \"| INSENSITIVE | INSERT | INT | INTEGER | INTERSECT | INTERVAL | INTO | IS\" + \"| ISOLATION\" + \"| JOIN\" + \"| KEY\" + \"| LANGUAGE | LAST | LEADING | LEFT | LEVEL | LIKE | LOCAL | LOWER\" + \"| MATCH | MAX | MIN | MINUTE | MODULE | MONTH\" + \"| NAMES | NATIONAL | NATURAL | NCHAR | NEXT | NO | NOT | NULL\" + \"| NULLIF | NUMERIC\" + \"| OCTET_LENGTH | OF | ON | ONLY | OPEN | OPTION | OR\" + \"| ORDER | OUTER\" + \"| OUTPUT | OVERLAPS\" + \"| PAD | PARTIAL | POSITION | PRECISION | PREPARE | PRESERVE | PRIMARY\" + \"| PRIOR | PRIVILEGES | PROCEDURE | PUBLIC\" + \"| READ | REAL | REFERENCES | RELATIVE | RESTRICT | REVOKE | RIGHT\" + \"| ROLLBACK | ROWS\" + \"| SCHEMA | SCROLL | SECOND | SECTION | SELECT | SESSION | SESSION_USER | SET\" + \"| SIZE | SMALLINT | SOME | SPACE | SQL | SQLCODE | SQLERROR | SQLSTATE\" + \"| SUBSTRING | SUM | SYSTEM_USER\" + \"| TABLE | TEMPORARY | THEN | TIME | TIMESTAMP | TIMEZONE_HOUR | TIMEZONE_MINUTE\" + \"| TO | TRAILING | TRANSACTION | TRANSLATE | TRANSLATION | TRIM | TRUE\" + \"| UNION | UNIQUE | UNKNOWN | UPDATE | UPPER | USAGE | USER | USING\" + \"| VALUE | VALUES | VARCHAR | VARYING | VIEW\" + \"| WHEN | WHENEVER | WHERE | WITH | WORK | WRITE\" + \"| YEAR\" + \"| ZONE\").split(\"[| ]+\");\n            String[] nonSql92Keywords = getMetaData().getSQLKeywords().toUpperCase().split(\",\\\\s*\");\n            sqlKeywords = new HashSet<String>() {\n\n                private static final long serialVersionUID = 1L;\n\n                @Override\n                public boolean contains(Object key) {\n                    return super.contains(((String) key).toUpperCase());\n                }\n            };\n            sqlKeywords.addAll(Arrays.asList(sql92Keywords));\n            sqlKeywords.addAll(Arrays.asList(nonSql92Keywords));\n        }\n        return sqlKeywords;\n    }\n\n    /**\n     * Return <code>id</code> quoted if required, otherwise return <code>id</code>\n     *\n     * @param id\n     * @return\n     * @throws SQLException\n     */\n    public String getQuotedIdentifier(String id) throws SQLException {\n        // look for any character that isn't valid (then matcher.find() returns true)\n        Matcher matcher = getInvalidIdentifierPattern().matcher(id);\n        boolean quotesRequired = matcher.find() || getSqlKeywords().contains(id);\n        if (quotesRequired) {\n            // name contains something that must be quoted\n            String quote = getMetaData().getIdentifierQuoteString().trim();\n            return quote + id + quote;\n        }\n        // no quoting necessary\n        return id;\n    }\n\n    /**\n     * Return a <code>Pattern</code> whose matcher will return <code>true</code>\n     * when run against an identifier that contains a character that is not\n     * acceptable by the database without being quoted.\n     */\n    private Pattern getInvalidIdentifierPattern() throws SQLException {\n        if (invalidIdentifierPattern == null) {\n            String validChars = \"a-zA-Z0-9_\";\n            String reservedRegexChars = \"-&^\";\n            String extraValidChars = getMetaData().getExtraNameCharacters();\n            for (int i = 0; i < extraValidChars.length(); ++i) {\n                char ch = extraValidChars.charAt(i);\n                if (reservedRegexChars.indexOf(ch) >= 0)\n                    validChars += \"\\\\\";\n                validChars += ch;\n            }\n            invalidIdentifierPattern = Pattern.compile(\"[^\" + validChars + \"]\");\n        }\n        return invalidIdentifierPattern;\n    }\n\n    /**\n     * Replaces named parameters in <code>sql</code> with question marks and\n     * returns appropriate matching values in the returned <code>List</code> of <code>String</code>s.\n     *\n     * @param sql StringBuffer input SQL with named parameters, output named params are replaced with ?'s.\n     * @param tableName String\n     * @return List of Strings\n     *\n     * @see #prepareStatement(String, String)\n     */\n    private List<String> getSqlParams(StringBuilder sql, String tableName) {\n        Map<String, String> namedParams = new HashMap<String, String>();\n        @SuppressWarnings(\"hiding\")\n        String schema = getSchema();\n        if (schema == null)\n            // some 'schema-less' db's treat the db name like a schema (unusual case)\n            schema = getName();\n        namedParams.put(\":schema\", schema);\n        // alias for :schema\n        namedParams.put(\":owner\", schema);\n        if (tableName != null) {\n            namedParams.put(\":table\", tableName);\n            // alias for :table\n            namedParams.put(\":view\", tableName);\n        }\n        List<String> sqlParams = new ArrayList<String>();\n        int nextColon = sql.indexOf(\":\");\n        while (nextColon != -1) {\n            String paramName = new StringTokenizer(sql.substring(nextColon), \" ,\\\"')\").nextToken();\n            String paramValue = namedParams.get(paramName);\n            if (paramValue == null)\n                throw new InvalidConfigurationException(\"Unexpected named parameter '\" + paramName + \"' found in SQL '\" + sql + \"'\");\n            sqlParams.add(paramValue);\n            // replace with a ?\n            sql.replace(nextColon, nextColon + paramName.length(), \"?\");\n            nextColon = sql.indexOf(\":\", nextColon);\n        }\n        return sqlParams;\n    }\n\n    /**\n     * Take the supplied XML-based metadata and update our model of the schema with it\n     *\n     * @param schemaMeta\n     * @throws SQLException\n     */\n    private void updateFromXmlMetadata(SchemaMeta schemaMeta) throws SQLException {\n        if (schemaMeta != null) {\n            config.setDescription(schemaMeta.getComments());\n            // done in three passes:\n            // 1: create any new tables\n            // 2: add/mod columns\n            // 3: connect\n            // add the newly defined tables and columns first\n            for (TableMeta tableMeta : schemaMeta.getTables()) {\n                Table table;\n                if (tableMeta.getRemoteSchema() != null || tableMeta.getRemoteCatalog() != null) {\n                    // will add it if it doesn't already exist\n                    table = addRemoteTable(tableMeta.getRemoteCatalog(), tableMeta.getRemoteSchema(), tableMeta.getName(), getSchema(), true);\n                } else {\n                    table = locals.get(tableMeta.getName());\n                    if (table == null) {\n                        // new table defined only in XML metadata\n                        table = new LogicalTable(this, getCatalog(), getSchema(), tableMeta.getName(), tableMeta.getComments());\n                        tables.put(table.getName(), table);\n                    }\n                }\n                table.update(tableMeta);\n            }\n            // then tie the tables together\n            for (TableMeta tableMeta : schemaMeta.getTables()) {\n                Table table;\n                if (tableMeta.getRemoteCatalog() != null || tableMeta.getRemoteSchema() != null) {\n                    table = remoteTables.get(getRemoteTableKey(tableMeta.getRemoteCatalog(), tableMeta.getRemoteSchema(), tableMeta.getName()));\n                } else {\n                    table = locals.get(tableMeta.getName());\n                }\n                table.connect(tableMeta, locals);\n            }\n        }\n    }\n\n    private void connectTables() throws SQLException {\n        for (Table table : tables.values()) {\n            table.connectForeignKeys(locals);\n        }\n        for (Table view : views.values()) {\n            view.connectForeignKeys(locals);\n        }\n    }\n\n    /**\n     * Returns a 'key' that's used to identify a remote table\n     * in the remoteTables map.\n     *\n     * @param cat\n     * @param sch\n     * @param table\n     * @return\n     */\n    public String getRemoteTableKey(String cat, String sch, String table) {\n        return Table.getFullName(getName(), cat, sch, table);\n    }\n\n    /**\n     * Single-threaded implementation of a class that creates tables\n     */\n    private class TableCreator {\n\n        /**\n         * Create a table and put it into <code>tables</code>\n         */\n        void create(BasicTableMeta tableMeta) throws SQLException {\n            createImpl(tableMeta);\n        }\n\n        protected void createImpl(BasicTableMeta tableMeta) throws SQLException {\n            Table table = new Table(Database.this, tableMeta.catalog, tableMeta.schema, tableMeta.name, tableMeta.remarks);\n            if (tableMeta.numRows != -1) {\n                table.setNumRows(tableMeta.numRows);\n            }\n            synchronized (tables) {\n                tables.put(table.getName(), table);\n            }\n            if (logger.isLoggable(Level.FINE)) {\n                logger.fine(\"Retrieved details of \" + table.getFullName());\n            } else {\n                System.out.print('.');\n            }\n        }\n\n        /**\n         * Wait for all of the tables to be created.\n         * By default this does nothing since this implementation isn't threaded.\n         */\n        void join() {\n        }\n    }\n\n    /**\n     * Multi-threaded implementation of a class that creates tables\n     */\n    private class ThreadedTableCreator extends TableCreator {\n\n        private final Set<Thread> threads = new HashSet<Thread>();\n\n        private final int maxThreads;\n\n        ThreadedTableCreator(int maxThreads) {\n            this.maxThreads = maxThreads;\n        }\n\n        @Override\n        void create(final BasicTableMeta tableMeta) throws SQLException {\n            Thread runner = new Thread() {\n\n                @Override\n                public void run() {\n                    try {\n                        createImpl(tableMeta);\n                    } catch (SQLException exc) {\n                        // nobody above us in call stack...dump it here\n                        exc.printStackTrace();\n                    } finally {\n                        synchronized (threads) {\n                            threads.remove(this);\n                            threads.notify();\n                        }\n                    }\n                }\n            };\n            synchronized (threads) {\n                // wait for enough 'room'\n                while (threads.size() >= maxThreads) {\n                    try {\n                        threads.wait();\n                    } catch (InterruptedException interrupted) {\n                    }\n                }\n                threads.add(runner);\n            }\n            runner.start();\n        }\n\n        /**\n         * Wait for all of the started threads to complete\n         */\n        @Override\n        public void join() {\n            while (true) {\n                Thread thread;\n                synchronized (threads) {\n                    Iterator<Thread> iter = threads.iterator();\n                    if (!iter.hasNext())\n                        break;\n                    thread = iter.next();\n                }\n                try {\n                    thread.join();\n                } catch (InterruptedException exc) {\n                }\n            }\n        }\n    }\n\n    /**\n     * A read-only map that treats both collections of Tables and Views as one\n     * combined collection.\n     * This is a bit strange, but it simplifies logic that otherwise treats\n     * the two as if they were one collection.\n     */\n    private class CombinedMap implements Map<String, Table> {\n\n        private final Map<String, ? extends Table> map1;\n\n        private final Map<String, ? extends Table> map2;\n\n        public CombinedMap(Map<String, ? extends Table> map1, Map<String, ? extends Table> map2) {\n            this.map1 = map1;\n            this.map2 = map2;\n        }\n\n        public Table get(Object name) {\n            Table table = map1.get(name);\n            if (table == null)\n                table = map2.get(name);\n            return table;\n        }\n\n        public int size() {\n            return map1.size() + map2.size();\n        }\n\n        public boolean isEmpty() {\n            return map1.isEmpty() && map2.isEmpty();\n        }\n\n        public boolean containsKey(Object key) {\n            return map1.containsKey(key) || map2.containsKey(key);\n        }\n\n        public boolean containsValue(Object value) {\n            return map1.containsValue(value) || map2.containsValue(value);\n        }\n\n        public Table put(String name, Table table) {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * Warning: potentially expensive operation\n         */\n        public Set<String> keySet() {\n            return getCombined().keySet();\n        }\n\n        /**\n         * Warning: potentially expensive operation\n         */\n        public Set<Map.Entry<String, Table>> entrySet() {\n            return getCombined().entrySet();\n        }\n\n        /**\n         * Warning: potentially expensive operation\n         */\n        public Collection<Table> values() {\n            return getCombined().values();\n        }\n\n        private Map<String, Table> getCombined() {\n            Map<String, Table> all = new CaseInsensitiveMap<Table>(size());\n            all.putAll(map1);\n            all.putAll(map2);\n            return all;\n        }\n\n        public Table remove(Object key) {\n            throw new UnsupportedOperationException();\n        }\n\n        public void putAll(Map<? extends String, ? extends Table> table) {\n            throw new UnsupportedOperationException();\n        }\n\n        public void clear() {\n            throw new UnsupportedOperationException();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/DatabaseTest0.java",
		"test_prompt": "// DatabaseTest0.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.Connection;\nimport java.sql.DatabaseMetaData;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.MissingResourceException;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.SchemaMeta;\nimport net.sourceforge.schemaspy.model.xml.TableMeta;\nimport net.sourceforge.schemaspy.util.CaseInsensitiveMap;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Database}.\n* It contains ten unit test cases for the {@link Database#prepareStatement(String, String)} method.\n*/\nclass DatabaseTest0 {"
	},
	{
		"original_code": "// Database.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.Connection;\nimport java.sql.DatabaseMetaData;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.MissingResourceException;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.SchemaMeta;\nimport net.sourceforge.schemaspy.model.xml.TableMeta;\nimport net.sourceforge.schemaspy.util.CaseInsensitiveMap;\n\npublic class Database {\n\n    private final Config config;\n\n    private final String databaseName;\n\n    private final String catalog;\n\n    private final String schema;\n\n    private final Map<String, Table> tables = new CaseInsensitiveMap<Table>();\n\n    private final Map<String, View> views = new CaseInsensitiveMap<View>();\n\n    // key: schema.tableName\n    private final Map<String, Table> remoteTables = new CaseInsensitiveMap<Table>();\n\n    private final Map<String, Table> locals = new CombinedMap(tables, views);\n\n    private final Map<String, Routine> routines = new CaseInsensitiveMap<Routine>();\n\n    private final DatabaseMetaData meta;\n\n    private final Connection connection;\n\n    private final String connectTime = new SimpleDateFormat(\"EEE MMM dd HH:mm z yyyy\").format(new Date());\n\n    private Set<String> sqlKeywords;\n\n    private Pattern invalidIdentifierPattern;\n\n    private final Logger logger = Logger.getLogger(getClass().getName());\n\n    private final boolean fineEnabled = logger.isLoggable(Level.FINE);\n\n    public Database(Config config, Connection connection, DatabaseMetaData meta, String name, String catalog, String schema, SchemaMeta schemaMeta) throws SQLException, MissingResourceException {\n        this.config = config;\n        this.connection = connection;\n        this.meta = meta;\n        this.databaseName = name;\n        this.catalog = catalog;\n        this.schema = schema;\n        initTables(meta);\n        if (config.isViewsEnabled())\n            initViews(meta);\n        initCheckConstraints();\n        initTableIds();\n        initIndexIds();\n        initTableComments();\n        initTableColumnComments();\n        initViewComments();\n        initViewColumnComments();\n        initColumnTypes();\n        initRoutines();\n        connectTables();\n        updateFromXmlMetadata(schemaMeta);\n    }\n\n    public String getName() {\n        return databaseName;\n    }\n\n    public String getCatalog() {\n        return catalog;\n    }\n\n    public String getSchema() {\n        return schema;\n    }\n\n    /**\n     * Details of the database type that's running under the covers.\n     *\n     * @return null if a description wasn't specified.\n     */\n    public String getDescription() {\n        return config.getDescription();\n    }\n\n    public Collection<Table> getTables() {\n        return tables.values();\n    }\n\n    /**\n     * Return a {@link Map} of all {@link Table}s keyed by their name.\n     *\n     * @return\n     */\n    public Map<String, Table> getTablesByName() {\n        return tables;\n    }\n\n    public Collection<View> getViews() {\n        return views.values();\n    }\n\n    public Collection<Table> getRemoteTables() {\n        return remoteTables.values();\n    }\n\n    public Collection<Routine> getRoutines() {\n        return routines.values();\n    }\n\n    public Connection getConnection() {\n        return connection;\n    }\n\n    public DatabaseMetaData getMetaData() {\n        return meta;\n    }\n\n    public String getConnectTime() {\n        return connectTime;\n    }\n\n    public String getDatabaseProduct() {\n        try {\n            return meta.getDatabaseProductName() + \" - \" + meta.getDatabaseProductVersion();\n        } catch (SQLException exc) {\n            return \"\";\n        }\n    }\n\n    /**\n     *  \"macro\" to validate that a table is somewhat valid\n     */\n    class NameValidator {\n\n        private final String clazz;\n\n        private final Pattern include;\n\n        private final Pattern exclude;\n\n        private final Set<String> validTypes;\n\n        /**\n         * @param clazz table or view\n         * @param include\n         * @param exclude\n         * @param verbose\n         * @param validTypes\n         */\n        NameValidator(String clazz, Pattern include, Pattern exclude, String[] validTypes) {\n            this.clazz = clazz;\n            this.include = include;\n            this.exclude = exclude;\n            this.validTypes = new HashSet<String>();\n            for (String type : validTypes) {\n                this.validTypes.add(type.toUpperCase());\n            }\n        }\n\n        /**\n         * Returns <code>true</code> if the table/view name is deemed \"valid\"\n         *\n         * @param name name of the table or view\n         * @param type type as returned by metadata.getTables():TABLE_TYPE\n         * @return\n         */\n        boolean isValid(String name, String type) {\n            // some databases (MySQL) return more than we wanted\n            if (!validTypes.contains(type.toUpperCase()))\n                return false;\n            // Oracle 10g introduced problematic flashback tables\n            // with bizarre illegal names\n            if (name.indexOf(\"$\") != -1) {\n                if (fineEnabled) {\n                    logger.fine(\"Excluding \" + clazz + \" \" + name + \": embedded $ implies illegal name\");\n                }\n                return false;\n            }\n            if (exclude.matcher(name).matches()) {\n                if (fineEnabled) {\n                    logger.fine(\"Excluding \" + clazz + \" \" + name + \": matches exclusion pattern \\\"\" + exclude + '\"');\n                }\n                return false;\n            }\n            boolean valid = include.matcher(name).matches();\n            if (fineEnabled) {\n                if (valid) {\n                    logger.fine(\"Including \" + clazz + \" \" + name + \": matches inclusion pattern \\\"\" + include + '\"');\n                } else {\n                    logger.fine(\"Excluding \" + clazz + \" \" + name + \": doesn't match inclusion pattern \\\"\" + include + '\"');\n                }\n            }\n            return valid;\n        }\n    }\n\n    /**\n     * Create/initialize any tables in the schema.\n     *\n     * @param metadata\n     * @throws SQLException\n     */\n    private void initTables(final DatabaseMetaData metadata) throws SQLException {\n        final Pattern include = config.getTableInclusions();\n        final Pattern exclude = config.getTableExclusions();\n        final int maxThreads = config.getMaxDbThreads();\n        String[] types = getTypes(\"tableTypes\", \"TABLE\");\n        NameValidator validator = new NameValidator(\"table\", include, exclude, types);\n        List<BasicTableMeta> entries = getBasicTableMeta(metadata, true, types);\n        TableCreator creator;\n        if (maxThreads == 1) {\n            creator = new TableCreator();\n        } else {\n            // creating tables takes a LONG time (based on JProbe analysis),\n            // so attempt to speed it up by doing several in parallel.\n            // note that it's actually DatabaseMetaData.getIndexInfo() that's expensive\n            creator = new ThreadedTableCreator(maxThreads);\n            // \"prime the pump\" so if there's a database problem we'll probably see it now\n            // and not in a secondary thread\n            while (!entries.isEmpty()) {\n                BasicTableMeta entry = entries.remove(0);\n                if (validator.isValid(entry.name, entry.type)) {\n                    new TableCreator().create(entry);\n                    break;\n                }\n            }\n        }\n        // kick off the secondary threads to do the creation in parallel\n        for (BasicTableMeta entry : entries) {\n            if (validator.isValid(entry.name, entry.type)) {\n                creator.create(entry);\n            }\n        }\n        // wait for everyone to finish\n        creator.join();\n    }\n\n    /**\n     * Create/initialize any views in the schema.\n     *\n     * @param metadata\n     * @throws SQLException\n     */\n    private void initViews(DatabaseMetaData metadata) throws SQLException {\n        Pattern includeTables = config.getTableInclusions();\n        Pattern excludeTables = config.getTableExclusions();\n        String[] types = getTypes(\"viewTypes\", \"VIEW\");\n        NameValidator validator = new NameValidator(\"view\", includeTables, excludeTables, types);\n        for (BasicTableMeta entry : getBasicTableMeta(metadata, false, types)) {\n            if (validator.isValid(entry.name, entry.type)) {\n                View view = new View(this, entry.catalog, entry.schema, entry.name, entry.remarks, entry.viewSql);\n                views.put(view.getName(), view);\n                if (fineEnabled) {\n                    logger.fine(\"Found details of view \" + view.getName());\n                } else {\n                    System.out.print('.');\n                }\n            }\n        }\n    }\n\n    /**\n     * Collection of fundamental table/view metadata\n     */\n    private class BasicTableMeta {\n\n        @SuppressWarnings(\"hiding\")\n        final String catalog;\n\n        @SuppressWarnings(\"hiding\")\n        final String schema;\n\n        final String name;\n\n        final String type;\n\n        final String remarks;\n\n        final String viewSql;\n\n        // -1 if not determined\n        final int numRows;\n\n        /**\n         * @param schema\n         * @param name\n         * @param type typically \"TABLE\" or \"VIEW\"\n         * @param remarks\n         * @param text optional textual SQL used to create the view\n         * @param numRows number of rows, or -1 if not determined\n         */\n        BasicTableMeta(String catalog, String schema, String name, String type, String remarks, String text, int numRows) {\n            this.catalog = catalog;\n            this.schema = schema;\n            this.name = name;\n            this.type = type;\n            this.remarks = remarks;\n            viewSql = text;\n            this.numRows = numRows;\n        }\n    }\n\n    /**\n     * Return a list of basic details of the tables in the schema.\n     *\n     * @param metadata\n     * @param forTables true if we're getting table data, false if getting view data\n     * @return\n     * @throws SQLException\n     */\n    private List<BasicTableMeta> getBasicTableMeta(DatabaseMetaData metadata, boolean forTables, String... types) throws SQLException {\n        String queryName = forTables ? \"selectTablesSql\" : \"selectViewsSql\";\n        String sql = Config.getInstance().getDbProperties().getProperty(queryName);\n        List<BasicTableMeta> basics = new ArrayList<BasicTableMeta>();\n        ResultSet rs = null;\n        if (sql != null) {\n            String clazz = forTables ? \"table\" : \"view\";\n            PreparedStatement stmt = null;\n            try {\n                stmt = prepareStatement(sql, null);\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    String name = rs.getString(clazz + \"_name\");\n                    String cat = getOptionalString(rs, clazz + \"_catalog\");\n                    String sch = getOptionalString(rs, clazz + \"_schema\");\n                    if (cat == null && sch == null)\n                        sch = schema;\n                    String remarks = getOptionalString(rs, clazz + \"_comment\");\n                    String text = forTables ? null : getOptionalString(rs, \"view_definition\");\n                    String rows = forTables ? getOptionalString(rs, \"table_rows\") : null;\n                    int numRows = rows == null ? -1 : Integer.parseInt(rows);\n                    basics.add(new BasicTableMeta(cat, sch, name, clazz, remarks, text, numRows));\n                }\n            } catch (SQLException sqlException) {\n                // don't die just because this failed\n                warning(\"Failed to retrieve \" + clazz + \" names with custom SQL: \" + sqlException, sql);\n            } finally {\n                if (rs != null)\n                    rs.close();\n                if (stmt != null)\n                    stmt.close();\n            }\n        }\n        if (basics.isEmpty()) {\n            rs = metadata.getTables(null, schema, \"%\", types);\n            try {\n                while (rs.next()) {\n                    String name = rs.getString(\"TABLE_NAME\");\n                    String type = rs.getString(\"TABLE_TYPE\");\n                    String cat = rs.getString(\"TABLE_CAT\");\n                    String schem = rs.getString(\"TABLE_SCHEM\");\n                    String remarks = getOptionalString(rs, \"REMARKS\");\n                    basics.add(new BasicTableMeta(cat, schem, name, type, remarks, null, -1));\n                }\n            } catch (SQLException exc) {\n                if (forTables)\n                    throw exc;\n                System.out.flush();\n                System.err.println();\n                System.err.println(\"Ignoring view \" + rs.getString(\"TABLE_NAME\") + \" due to exception:\");\n                exc.printStackTrace();\n                System.err.println(\"Continuing analysis.\");\n            } finally {\n                if (rs != null)\n                    rs.close();\n            }\n        }\n        return basics;\n    }\n\n    /**\n     * Return a database-specific array of types from the .properties file\n     * with the specified property name.\n     *\n     * @param propName\n     * @param defaultValue\n     * @return\n     */\n    private String[] getTypes(String propName, String defaultValue) {\n        String value = config.getDbProperties().getProperty(propName, defaultValue);\n        List<String> types = new ArrayList<String>();\n        for (String type : value.split(\",\")) {\n            type = type.trim();\n            if (type.length() > 0)\n                types.add(type);\n        }\n        return types.toArray(new String[types.size()]);\n    }\n\n    /**\n     * Some databases don't play nice with their metadata.\n     * E.g. Oracle doesn't have a REMARKS column at all.\n     * This method ignores those types of failures, replacing them with null.\n     */\n    public String getOptionalString(ResultSet rs, String columnName) {\n        try {\n            return rs.getString(columnName);\n        } catch (SQLException ignore) {\n            return null;\n        }\n    }\n\n    private void initCheckConstraints() throws SQLException {\n        String sql = config.getDbProperties().getProperty(\"selectCheckConstraintsSql\");\n        if (sql != null) {\n            PreparedStatement stmt = null;\n            ResultSet rs = null;\n            try {\n                stmt = prepareStatement(sql, null);\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    String tableName = rs.getString(\"table_name\");\n                    Table table = locals.get(tableName);\n                    if (table != null)\n                        table.addCheckConstraint(rs.getString(\"constraint_name\"), rs.getString(\"text\"));\n                }\n            } catch (SQLException sqlException) {\n                // don't die just because this failed\n                warning(\"Failed to retrieve check constraints: \" + sqlException, sql);\n            } finally {\n                if (rs != null)\n                    rs.close();\n                if (stmt != null)\n                    stmt.close();\n            }\n        }\n    }\n\n    private void initColumnTypes() throws SQLException {\n        String sql = config.getDbProperties().getProperty(\"selectColumnTypesSql\");\n        if (sql != null) {\n            PreparedStatement stmt = null;\n            ResultSet rs = null;\n            try {\n                stmt = prepareStatement(sql, null);\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    String tableName = rs.getString(\"table_name\");\n                    Table table = locals.get(tableName);\n                    if (table != null) {\n                        String columnName = rs.getString(\"column_name\");\n                        TableColumn column = table.getColumn(columnName);\n                        if (column != null) {\n                            column.setType(rs.getString(\"column_type\"));\n                            column.setShortType(getOptionalString(rs, \"short_column_type\"));\n                        }\n                    }\n                }\n            } catch (SQLException sqlException) {\n                // don't die just because this failed\n                warning(\"Failed to retrieve column type details: \" + sqlException, sql);\n            } finally {\n                if (rs != null)\n                    rs.close();\n                if (stmt != null)\n                    stmt.close();\n            }\n        }\n    }\n\n    private void initTableIds() throws SQLException {\n        String sql = config.getDbProperties().getProperty(\"selectTableIdsSql\");\n        if (sql != null) {\n            PreparedStatement stmt = null;\n            ResultSet rs = null;\n            try {\n                stmt = prepareStatement(sql, null);\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    String tableName = rs.getString(\"table_name\");\n                    Table table = locals.get(tableName);\n                    if (table != null)\n                        table.setId(rs.getObject(\"table_id\"));\n                }\n            } catch (SQLException sqlException) {\n                System.err.println();\n                System.err.println(sql);\n                throw sqlException;\n            } finally {\n                if (rs != null)\n                    rs.close();\n                if (stmt != null)\n                    stmt.close();\n            }\n        }\n    }\n\n    private void initIndexIds() throws SQLException {\n        String sql = config.getDbProperties().getProperty(\"selectIndexIdsSql\");\n        if (sql != null) {\n            PreparedStatement stmt = null;\n            ResultSet rs = null;\n            try {\n                stmt = prepareStatement(sql, null);\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    String tableName = rs.getString(\"table_name\");\n                    Table table = locals.get(tableName);\n                    if (table != null) {\n                        TableIndex index = table.getIndex(rs.getString(\"index_name\"));\n                        if (index != null)\n                            index.setId(rs.getObject(\"index_id\"));\n                    }\n                }\n            } catch (SQLException sqlException) {\n                System.err.println();\n                System.err.println(sql);\n                throw sqlException;\n            } finally {\n                if (rs != null)\n                    rs.close();\n                if (stmt != null)\n                    stmt.close();\n            }\n        }\n    }\n\n    /**\n     * Initializes table comments.\n     * If the SQL also returns view comments then they're plugged into the\n     * appropriate views.\n     *\n     * @throws SQLException\n     */\n    private void initTableComments() throws SQLException {\n        String sql = config.getDbProperties().getProperty(\"selectTableCommentsSql\");\n        if (sql != null) {\n            PreparedStatement stmt = null;\n            ResultSet rs = null;\n            try {\n                stmt = prepareStatement(sql, null);\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    String tableName = rs.getString(\"table_name\");\n                    Table table = locals.get(tableName);\n                    if (table != null)\n                        table.setComments(rs.getString(\"comments\"));\n                }\n            } catch (SQLException sqlException) {\n                // don't die just because this failed\n                warning(\"Failed to retrieve table/view comments: \" + sqlException, sql);\n            } finally {\n                if (rs != null)\n                    rs.close();\n                if (stmt != null)\n                    stmt.close();\n            }\n        }\n    }\n\n    /**\n     * Initializes view comments.\n     *\n     * @throws SQLException\n     */\n    private void initViewComments() throws SQLException {\n        String sql = config.getDbProperties().getProperty(\"selectViewCommentsSql\");\n        if (sql != null) {\n            PreparedStatement stmt = null;\n            ResultSet rs = null;\n            try {\n                stmt = prepareStatement(sql, null);\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    String viewName = rs.getString(\"view_name\");\n                    if (viewName == null)\n                        viewName = rs.getString(\"table_name\");\n                    Table view = views.get(viewName);\n                    if (view != null)\n                        view.setComments(rs.getString(\"comments\"));\n                }\n            } catch (SQLException sqlException) {\n                // don't die just because this failed\n                warning(\"Failed to retrieve table/view comments: \" + sqlException, sql);\n            } finally {\n                if (rs != null)\n                    rs.close();\n                if (stmt != null)\n                    stmt.close();\n            }\n        }\n    }\n\n    /**\n     * Initializes table column comments.\n     * If the SQL also returns view column comments then they're plugged into the\n     * appropriate views.\n     *\n     * @throws SQLException\n     */\n    private void initTableColumnComments() throws SQLException {\n        String sql = config.getDbProperties().getProperty(\"selectColumnCommentsSql\");\n        if (sql != null) {\n            PreparedStatement stmt = null;\n            ResultSet rs = null;\n            try {\n                stmt = prepareStatement(sql, null);\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    String tableName = rs.getString(\"table_name\");\n                    Table table = locals.get(tableName);\n                    if (table != null) {\n                        TableColumn column = table.getColumn(rs.getString(\"column_name\"));\n                        if (column != null)\n                            column.setComments(rs.getString(\"comments\"));\n                    }\n                }\n            } catch (SQLException sqlException) {\n                // don't die just because this failed\n                warning(\"Failed to retrieve column comments: \" + sqlException, sql);\n            } finally {\n                if (rs != null)\n                    rs.close();\n                if (stmt != null)\n                    stmt.close();\n            }\n        }\n    }\n\n    /**\n     * Initializes view column comments.\n     *\n     * @throws SQLException\n     */\n    private void initViewColumnComments() throws SQLException {\n        String sql = config.getDbProperties().getProperty(\"selectViewColumnCommentsSql\");\n        if (sql != null) {\n            PreparedStatement stmt = null;\n            ResultSet rs = null;\n            try {\n                stmt = prepareStatement(sql, null);\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    String viewName = rs.getString(\"view_name\");\n                    if (viewName == null)\n                        viewName = rs.getString(\"table_name\");\n                    Table view = views.get(viewName);\n                    if (view != null) {\n                        TableColumn column = view.getColumn(rs.getString(\"column_name\"));\n                        if (column != null)\n                            column.setComments(rs.getString(\"comments\"));\n                    }\n                }\n            } catch (SQLException sqlException) {\n                // don't die just because this failed\n                warning(\"Failed to retrieve view column comments: \" + sqlException, sql);\n            } finally {\n                if (rs != null)\n                    rs.close();\n                if (stmt != null)\n                    stmt.close();\n            }\n        }\n    }\n\n    /**\n     * Initializes stored procedures / functions.\n     *\n     * @throws SQLException\n     */\n    private void initRoutines() throws SQLException {\n        String sql = config.getDbProperties().getProperty(\"selectRoutinesSql\");\n        if (sql != null) {\n            PreparedStatement stmt = null;\n            ResultSet rs = null;\n            try {\n                stmt = prepareStatement(sql, null);\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    String routineName = rs.getString(\"routine_name\");\n                    String routineType = rs.getString(\"routine_type\");\n                    String returnType = rs.getString(\"dtd_identifier\");\n                    String definitionLanguage = rs.getString(\"routine_body\");\n                    String definition = rs.getString(\"routine_definition\");\n                    String dataAccess = rs.getString(\"sql_data_access\");\n                    String securityType = rs.getString(\"security_type\");\n                    boolean deterministic = rs.getBoolean(\"is_deterministic\");\n                    String comment = getOptionalString(rs, \"routine_comment\");\n                    Routine routine = new Routine(routineName, routineType, returnType, definitionLanguage, definition, deterministic, dataAccess, securityType, comment);\n                    routines.put(routineName, routine);\n                }\n            } catch (SQLException sqlException) {\n                // don't die just because this failed\n                warning(\"Failed to retrieve stored procedure/function details: \" + sqlException, sql);\n            } finally {\n                if (rs != null)\n                    rs.close();\n                if (stmt != null)\n                    stmt.close();\n                rs = null;\n                stmt = null;\n            }\n        }\n        sql = config.getDbProperties().getProperty(\"selectRoutineParametersSql\");\n        if (sql != null) {\n            PreparedStatement stmt = null;\n            ResultSet rs = null;\n            try {\n                stmt = prepareStatement(sql, null);\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    String routineName = rs.getString(\"specific_name\");\n                    Routine routine = routines.get(routineName);\n                    if (routine != null) {\n                        String paramName = rs.getString(\"parameter_name\");\n                        String type = rs.getString(\"dtd_identifier\");\n                        String mode = rs.getString(\"parameter_mode\");\n                        RoutineParameter param = new RoutineParameter(paramName, type, mode);\n                        routine.addParameter(param);\n                    }\n                }\n            } catch (SQLException sqlException) {\n                // don't die just because this failed\n                warning(\"Failed to retrieve stored procedure/function details: \" + sqlException, sql);\n            } finally {\n                if (rs != null)\n                    rs.close();\n                if (stmt != null)\n                    stmt.close();\n            }\n        }\n    }\n\n    /**\n     * Dump a warning message out to a new line\n     *\n     * @param msg1\n     * @param msg2\n     */\n    private void warning(String msg1, String msg2) {\n        System.out.println();\n        System.out.flush();\n        logger.warning(msg1);\n        if (msg2 != null)\n            logger.warning(msg2);\n    }\n\n    /**\n     * Create a <code>PreparedStatement</code> from the specified SQL.\n     * The SQL can contain these named parameters (but <b>not</b> question marks).\n     * <ol>\n     * <li>:schema - replaced with the name of the schema\n     * <li>:owner - alias for :schema\n     * <li>:table - replaced with the name of the table\n     * </ol>\n     * @param sql String - SQL without question marks\n     * @param tableName String - <code>null</code> if the statement doesn't deal with <code>Table</code>-level details.\n     * @throws SQLException\n     * @return PreparedStatement\n     */\n    public PreparedStatement prepareStatement(String sql, String tableName) throws SQLException {\n        StringBuilder sqlBuf = new StringBuilder(sql);\n        // modifies sqlBuf\n        List<String> sqlParams = getSqlParams(sqlBuf, tableName);\n        if (fineEnabled)\n            logger.fine(sqlBuf + \" \" + sqlParams);\n        PreparedStatement stmt = getConnection().prepareStatement(sqlBuf.toString());\n        try {\n            for (int i = 0; i < sqlParams.size(); ++i) {\n                stmt.setString(i + 1, sqlParams.get(i).toString());\n            }\n        } catch (SQLException exc) {\n            stmt.close();\n            throw exc;\n        }\n        return stmt;\n    }\n\n    public Table addRemoteTable(String remoteCatalog, String remoteSchema, String remoteTableName, String baseContainer, boolean logical) throws SQLException {\n        String fullName = getRemoteTableKey(remoteCatalog, remoteSchema, remoteTableName);\n        Table remoteTable = remoteTables.get(fullName);\n        if (remoteTable == null) {\n            if (fineEnabled)\n                logger.fine(\"Creating remote table \" + fullName);\n            if (logical)\n                remoteTable = new LogicalRemoteTable(this, remoteCatalog, remoteSchema, remoteTableName, baseContainer);\n            else\n                remoteTable = new RemoteTable(this, remoteCatalog, remoteSchema, remoteTableName, baseContainer);\n            if (fineEnabled)\n                logger.fine(\"Adding remote table \" + fullName);\n            remoteTables.put(fullName, remoteTable);\n            remoteTable.connectForeignKeys(locals);\n        }\n        return remoteTable;\n    }\n\n    /**\n     * Return an uppercased <code>Set</code> of all SQL keywords used by a database\n     *\n     * @return\n     * @throws SQLException\n     */\n    public Set<String> getSqlKeywords() throws SQLException {\n        if (sqlKeywords == null) {\n            // from http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt:\n            String[] sql92Keywords = (\"ADA\" + \"| C | CATALOG_NAME | CHARACTER_SET_CATALOG | CHARACTER_SET_NAME\" + \"| CHARACTER_SET_SCHEMA | CLASS_ORIGIN | COBOL | COLLATION_CATALOG\" + \"| COLLATION_NAME | COLLATION_SCHEMA | COLUMN_NAME | COMMAND_FUNCTION | COMMITTED\" + \"| CONDITION_NUMBER | CONNECTION_NAME | CONSTRAINT_CATALOG | CONSTRAINT_NAME\" + \"| CONSTRAINT_SCHEMA | CURSOR_NAME\" + \"| DATA | DATETIME_INTERVAL_CODE | DATETIME_INTERVAL_PRECISION | DYNAMIC_FUNCTION\" + \"| FORTRAN\" + \"| LENGTH\" + \"| MESSAGE_LENGTH | MESSAGE_OCTET_LENGTH | MESSAGE_TEXT | MORE | MUMPS\" + \"| NAME | NULLABLE | NUMBER\" + \"| PASCAL | PLI\" + \"| REPEATABLE | RETURNED_LENGTH | RETURNED_OCTET_LENGTH | RETURNED_SQLSTATE\" + \"| ROW_COUNT\" + \"| SCALE | SCHEMA_NAME | SERIALIZABLE | SERVER_NAME | SUBCLASS_ORIGIN\" + \"| TABLE_NAME | TYPE\" + \"| UNCOMMITTED | UNNAMED\" + \"| ABSOLUTE | ACTION | ADD | ALL | ALLOCATE | ALTER | AND\" + \"| ANY | ARE | AS | ASC\" + \"| ASSERTION | AT | AUTHORIZATION | AVG\" + \"| BEGIN | BETWEEN | BIT | BIT_LENGTH | BOTH | BY\" + \"| CASCADE | CASCADED | CASE | CAST | CATALOG | CHAR | CHARACTER | CHAR_LENGTH\" + \"| CHARACTER_LENGTH | CHECK | CLOSE | COALESCE | COLLATE | COLLATION\" + \"| COLUMN | COMMIT | CONNECT | CONNECTION | CONSTRAINT\" + \"| CONSTRAINTS | CONTINUE\" + \"| CONVERT | CORRESPONDING | COUNT | CREATE | CROSS | CURRENT\" + \"| CURRENT_DATE | CURRENT_TIME | CURRENT_TIMESTAMP | CURRENT_USER | CURSOR\" + \"| DATE | DAY | DEALLOCATE | DEC | DECIMAL | DECLARE | DEFAULT | DEFERRABLE\" + \"| DEFERRED | DELETE | DESC | DESCRIBE | DESCRIPTOR | DIAGNOSTICS\" + \"| DISCONNECT | DISTINCT | DOMAIN | DOUBLE | DROP\" + \"| ELSE | END | END-EXEC | ESCAPE | EXCEPT | EXCEPTION\" + \"| EXEC | EXECUTE | EXISTS\" + \"| EXTERNAL | EXTRACT\" + \"| FALSE | FETCH | FIRST | FLOAT | FOR | FOREIGN | FOUND | FROM | FULL\" + \"| GET | GLOBAL | GO | GOTO | GRANT | GROUP\" + \"| HAVING | HOUR\" + \"| IDENTITY | IMMEDIATE | IN | INDICATOR | INITIALLY | INNER | INPUT\" + \"| INSENSITIVE | INSERT | INT | INTEGER | INTERSECT | INTERVAL | INTO | IS\" + \"| ISOLATION\" + \"| JOIN\" + \"| KEY\" + \"| LANGUAGE | LAST | LEADING | LEFT | LEVEL | LIKE | LOCAL | LOWER\" + \"| MATCH | MAX | MIN | MINUTE | MODULE | MONTH\" + \"| NAMES | NATIONAL | NATURAL | NCHAR | NEXT | NO | NOT | NULL\" + \"| NULLIF | NUMERIC\" + \"| OCTET_LENGTH | OF | ON | ONLY | OPEN | OPTION | OR\" + \"| ORDER | OUTER\" + \"| OUTPUT | OVERLAPS\" + \"| PAD | PARTIAL | POSITION | PRECISION | PREPARE | PRESERVE | PRIMARY\" + \"| PRIOR | PRIVILEGES | PROCEDURE | PUBLIC\" + \"| READ | REAL | REFERENCES | RELATIVE | RESTRICT | REVOKE | RIGHT\" + \"| ROLLBACK | ROWS\" + \"| SCHEMA | SCROLL | SECOND | SECTION | SELECT | SESSION | SESSION_USER | SET\" + \"| SIZE | SMALLINT | SOME | SPACE | SQL | SQLCODE | SQLERROR | SQLSTATE\" + \"| SUBSTRING | SUM | SYSTEM_USER\" + \"| TABLE | TEMPORARY | THEN | TIME | TIMESTAMP | TIMEZONE_HOUR | TIMEZONE_MINUTE\" + \"| TO | TRAILING | TRANSACTION | TRANSLATE | TRANSLATION | TRIM | TRUE\" + \"| UNION | UNIQUE | UNKNOWN | UPDATE | UPPER | USAGE | USER | USING\" + \"| VALUE | VALUES | VARCHAR | VARYING | VIEW\" + \"| WHEN | WHENEVER | WHERE | WITH | WORK | WRITE\" + \"| YEAR\" + \"| ZONE\").split(\"[| ]+\");\n            String[] nonSql92Keywords = getMetaData().getSQLKeywords().toUpperCase().split(\",\\\\s*\");\n            sqlKeywords = new HashSet<String>() {\n\n                private static final long serialVersionUID = 1L;\n\n                @Override\n                public boolean contains(Object key) {\n                    return super.contains(((String) key).toUpperCase());\n                }\n            };\n            sqlKeywords.addAll(Arrays.asList(sql92Keywords));\n            sqlKeywords.addAll(Arrays.asList(nonSql92Keywords));\n        }\n        return sqlKeywords;\n    }\n\n    /**\n     * Return <code>id</code> quoted if required, otherwise return <code>id</code>\n     *\n     * @param id\n     * @return\n     * @throws SQLException\n     */\n    public String getQuotedIdentifier(String id) throws SQLException {\n        // look for any character that isn't valid (then matcher.find() returns true)\n        Matcher matcher = getInvalidIdentifierPattern().matcher(id);\n        boolean quotesRequired = matcher.find() || getSqlKeywords().contains(id);\n        if (quotesRequired) {\n            // name contains something that must be quoted\n            String quote = getMetaData().getIdentifierQuoteString().trim();\n            return quote + id + quote;\n        }\n        // no quoting necessary\n        return id;\n    }\n\n    /**\n     * Return a <code>Pattern</code> whose matcher will return <code>true</code>\n     * when run against an identifier that contains a character that is not\n     * acceptable by the database without being quoted.\n     */\n    private Pattern getInvalidIdentifierPattern() throws SQLException {\n        if (invalidIdentifierPattern == null) {\n            String validChars = \"a-zA-Z0-9_\";\n            String reservedRegexChars = \"-&^\";\n            String extraValidChars = getMetaData().getExtraNameCharacters();\n            for (int i = 0; i < extraValidChars.length(); ++i) {\n                char ch = extraValidChars.charAt(i);\n                if (reservedRegexChars.indexOf(ch) >= 0)\n                    validChars += \"\\\\\";\n                validChars += ch;\n            }\n            invalidIdentifierPattern = Pattern.compile(\"[^\" + validChars + \"]\");\n        }\n        return invalidIdentifierPattern;\n    }\n\n    /**\n     * Replaces named parameters in <code>sql</code> with question marks and\n     * returns appropriate matching values in the returned <code>List</code> of <code>String</code>s.\n     *\n     * @param sql StringBuffer input SQL with named parameters, output named params are replaced with ?'s.\n     * @param tableName String\n     * @return List of Strings\n     *\n     * @see #prepareStatement(String, String)\n     */\n    private List<String> getSqlParams(StringBuilder sql, String tableName) {\n        Map<String, String> namedParams = new HashMap<String, String>();\n        @SuppressWarnings(\"hiding\")\n        String schema = getSchema();\n        if (schema == null)\n            // some 'schema-less' db's treat the db name like a schema (unusual case)\n            schema = getName();\n        namedParams.put(\":schema\", schema);\n        // alias for :schema\n        namedParams.put(\":owner\", schema);\n        if (tableName != null) {\n            namedParams.put(\":table\", tableName);\n            // alias for :table\n            namedParams.put(\":view\", tableName);\n        }\n        List<String> sqlParams = new ArrayList<String>();\n        int nextColon = sql.indexOf(\":\");\n        while (nextColon != -1) {\n            String paramName = new StringTokenizer(sql.substring(nextColon), \" ,\\\"')\").nextToken();\n            String paramValue = namedParams.get(paramName);\n            if (paramValue == null)\n                throw new InvalidConfigurationException(\"Unexpected named parameter '\" + paramName + \"' found in SQL '\" + sql + \"'\");\n            sqlParams.add(paramValue);\n            // replace with a ?\n            sql.replace(nextColon, nextColon + paramName.length(), \"?\");\n            nextColon = sql.indexOf(\":\", nextColon);\n        }\n        return sqlParams;\n    }\n\n    /**\n     * Take the supplied XML-based metadata and update our model of the schema with it\n     *\n     * @param schemaMeta\n     * @throws SQLException\n     */\n    private void updateFromXmlMetadata(SchemaMeta schemaMeta) throws SQLException {\n        if (schemaMeta != null) {\n            config.setDescription(schemaMeta.getComments());\n            // done in three passes:\n            // 1: create any new tables\n            // 2: add/mod columns\n            // 3: connect\n            // add the newly defined tables and columns first\n            for (TableMeta tableMeta : schemaMeta.getTables()) {\n                Table table;\n                if (tableMeta.getRemoteSchema() != null || tableMeta.getRemoteCatalog() != null) {\n                    // will add it if it doesn't already exist\n                    table = addRemoteTable(tableMeta.getRemoteCatalog(), tableMeta.getRemoteSchema(), tableMeta.getName(), getSchema(), true);\n                } else {\n                    table = locals.get(tableMeta.getName());\n                    if (table == null) {\n                        // new table defined only in XML metadata\n                        table = new LogicalTable(this, getCatalog(), getSchema(), tableMeta.getName(), tableMeta.getComments());\n                        tables.put(table.getName(), table);\n                    }\n                }\n                table.update(tableMeta);\n            }\n            // then tie the tables together\n            for (TableMeta tableMeta : schemaMeta.getTables()) {\n                Table table;\n                if (tableMeta.getRemoteCatalog() != null || tableMeta.getRemoteSchema() != null) {\n                    table = remoteTables.get(getRemoteTableKey(tableMeta.getRemoteCatalog(), tableMeta.getRemoteSchema(), tableMeta.getName()));\n                } else {\n                    table = locals.get(tableMeta.getName());\n                }\n                table.connect(tableMeta, locals);\n            }\n        }\n    }\n\n    private void connectTables() throws SQLException {\n        for (Table table : tables.values()) {\n            table.connectForeignKeys(locals);\n        }\n        for (Table view : views.values()) {\n            view.connectForeignKeys(locals);\n        }\n    }\n\n    /**\n     * Returns a 'key' that's used to identify a remote table\n     * in the remoteTables map.\n     *\n     * @param cat\n     * @param sch\n     * @param table\n     * @return\n     */\n    public String getRemoteTableKey(String cat, String sch, String table) {\n        return Table.getFullName(getName(), cat, sch, table);\n    }\n\n    /**\n     * Single-threaded implementation of a class that creates tables\n     */\n    private class TableCreator {\n\n        /**\n         * Create a table and put it into <code>tables</code>\n         */\n        void create(BasicTableMeta tableMeta) throws SQLException {\n            createImpl(tableMeta);\n        }\n\n        protected void createImpl(BasicTableMeta tableMeta) throws SQLException {\n            Table table = new Table(Database.this, tableMeta.catalog, tableMeta.schema, tableMeta.name, tableMeta.remarks);\n            if (tableMeta.numRows != -1) {\n                table.setNumRows(tableMeta.numRows);\n            }\n            synchronized (tables) {\n                tables.put(table.getName(), table);\n            }\n            if (logger.isLoggable(Level.FINE)) {\n                logger.fine(\"Retrieved details of \" + table.getFullName());\n            } else {\n                System.out.print('.');\n            }\n        }\n\n        /**\n         * Wait for all of the tables to be created.\n         * By default this does nothing since this implementation isn't threaded.\n         */\n        void join() {\n        }\n    }\n\n    /**\n     * Multi-threaded implementation of a class that creates tables\n     */\n    private class ThreadedTableCreator extends TableCreator {\n\n        private final Set<Thread> threads = new HashSet<Thread>();\n\n        private final int maxThreads;\n\n        ThreadedTableCreator(int maxThreads) {\n            this.maxThreads = maxThreads;\n        }\n\n        @Override\n        void create(final BasicTableMeta tableMeta) throws SQLException {\n            Thread runner = new Thread() {\n\n                @Override\n                public void run() {\n                    try {\n                        createImpl(tableMeta);\n                    } catch (SQLException exc) {\n                        // nobody above us in call stack...dump it here\n                        exc.printStackTrace();\n                    } finally {\n                        synchronized (threads) {\n                            threads.remove(this);\n                            threads.notify();\n                        }\n                    }\n                }\n            };\n            synchronized (threads) {\n                // wait for enough 'room'\n                while (threads.size() >= maxThreads) {\n                    try {\n                        threads.wait();\n                    } catch (InterruptedException interrupted) {\n                    }\n                }\n                threads.add(runner);\n            }\n            runner.start();\n        }\n\n        /**\n         * Wait for all of the started threads to complete\n         */\n        @Override\n        public void join() {\n            while (true) {\n                Thread thread;\n                synchronized (threads) {\n                    Iterator<Thread> iter = threads.iterator();\n                    if (!iter.hasNext())\n                        break;\n                    thread = iter.next();\n                }\n                try {\n                    thread.join();\n                } catch (InterruptedException exc) {\n                }\n            }\n        }\n    }\n\n    /**\n     * A read-only map that treats both collections of Tables and Views as one\n     * combined collection.\n     * This is a bit strange, but it simplifies logic that otherwise treats\n     * the two as if they were one collection.\n     */\n    private class CombinedMap implements Map<String, Table> {\n\n        private final Map<String, ? extends Table> map1;\n\n        private final Map<String, ? extends Table> map2;\n\n        public CombinedMap(Map<String, ? extends Table> map1, Map<String, ? extends Table> map2) {\n            this.map1 = map1;\n            this.map2 = map2;\n        }\n\n        public Table get(Object name) {\n            Table table = map1.get(name);\n            if (table == null)\n                table = map2.get(name);\n            return table;\n        }\n\n        public int size() {\n            return map1.size() + map2.size();\n        }\n\n        public boolean isEmpty() {\n            return map1.isEmpty() && map2.isEmpty();\n        }\n\n        public boolean containsKey(Object key) {\n            return map1.containsKey(key) || map2.containsKey(key);\n        }\n\n        public boolean containsValue(Object value) {\n            return map1.containsValue(value) || map2.containsValue(value);\n        }\n\n        public Table put(String name, Table table) {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * Warning: potentially expensive operation\n         */\n        public Set<String> keySet() {\n            return getCombined().keySet();\n        }\n\n        /**\n         * Warning: potentially expensive operation\n         */\n        public Set<Map.Entry<String, Table>> entrySet() {\n            return getCombined().entrySet();\n        }\n\n        /**\n         * Warning: potentially expensive operation\n         */\n        public Collection<Table> values() {\n            return getCombined().values();\n        }\n\n        private Map<String, Table> getCombined() {\n            Map<String, Table> all = new CaseInsensitiveMap<Table>(size());\n            all.putAll(map1);\n            all.putAll(map2);\n            return all;\n        }\n\n        public Table remove(Object key) {\n            throw new UnsupportedOperationException();\n        }\n\n        public void putAll(Map<? extends String, ? extends Table> table) {\n            throw new UnsupportedOperationException();\n        }\n\n        public void clear() {\n            throw new UnsupportedOperationException();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/DatabaseTest1.java",
		"test_prompt": "// DatabaseTest1.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.Connection;\nimport java.sql.DatabaseMetaData;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.MissingResourceException;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.xml.SchemaMeta;\nimport net.sourceforge.schemaspy.model.xml.TableMeta;\nimport net.sourceforge.schemaspy.util.CaseInsensitiveMap;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Database}.\n* It contains ten unit test cases for the {@link Database#addRemoteTable(String, String, String, String, boolean)} method.\n*/\nclass DatabaseTest1 {"
	},
	{
		"original_code": "// TableColumnMeta.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy.model.xml;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.logging.Logger;\r\nimport org.w3c.dom.Element;\r\nimport org.w3c.dom.NamedNodeMap;\r\nimport org.w3c.dom.Node;\r\nimport org.w3c.dom.NodeList;\r\n\r\n/**\r\n * Additional metadata about a column as expressed in XML instead of from\r\n * the database.\r\n *\r\n * @author John Currier\r\n */\r\npublic class TableColumnMeta {\r\n\r\n    private final String name;\r\n\r\n    private final String type;\r\n\r\n    private final boolean isPrimary;\r\n\r\n    private final String id;\r\n\r\n    private final int size;\r\n\r\n    private final int digits;\r\n\r\n    private final boolean isNullable;\r\n\r\n    private final String comments;\r\n\r\n    private final String defaultValue;\r\n\r\n    private final boolean isAutoUpdated;\r\n\r\n    private final List<ForeignKeyMeta> foreignKeys = new ArrayList<ForeignKeyMeta>();\r\n\r\n    private final boolean isExcluded;\r\n\r\n    private final boolean isAllExcluded;\r\n\r\n    private final boolean isImpliedParentsDisabled;\r\n\r\n    private final boolean isImpliedChildrenDisabled;\r\n\r\n    private static final Logger logger = Logger.getLogger(TableColumnMeta.class.getName());\r\n\r\n    TableColumnMeta(Node colNode) {\r\n        NamedNodeMap attribs = colNode.getAttributes();\r\n        String tmp;\r\n        name = attribs.getNamedItem(\"name\").getNodeValue();\r\n        Node node = attribs.getNamedItem(\"comments\");\r\n        if (node == null)\r\n            node = attribs.getNamedItem(\"remarks\");\r\n        if (node != null) {\r\n            tmp = node.getNodeValue().trim();\r\n            comments = tmp.length() == 0 ? null : tmp;\r\n        } else {\r\n            comments = null;\r\n        }\r\n        node = attribs.getNamedItem(\"type\");\r\n        type = node == null ? \"Unknown\" : node.getNodeValue();\r\n        node = attribs.getNamedItem(\"id\");\r\n        id = node == null ? null : node.getNodeValue();\r\n        node = attribs.getNamedItem(\"size\");\r\n        size = node == null ? 0 : Integer.parseInt(node.getNodeValue());\r\n        node = attribs.getNamedItem(\"digits\");\r\n        digits = node == null ? 0 : Integer.parseInt(node.getNodeValue());\r\n        node = attribs.getNamedItem(\"nullable\");\r\n        isNullable = node == null ? false : evalBoolean(node.getNodeValue());\r\n        node = attribs.getNamedItem(\"autoUpdated\");\r\n        isAutoUpdated = node == null ? false : evalBoolean(node.getNodeValue());\r\n        node = attribs.getNamedItem(\"primaryKey\");\r\n        isPrimary = node == null ? false : evalBoolean(node.getNodeValue());\r\n        node = attribs.getNamedItem(\"defaultValue\");\r\n        defaultValue = node == null ? null : node.getNodeValue();\r\n        node = attribs.getNamedItem(\"disableImpliedKeys\");\r\n        if (node != null) {\r\n            tmp = node.getNodeValue().trim().toLowerCase();\r\n            if (tmp.equals(\"to\")) {\r\n                isImpliedChildrenDisabled = true;\r\n                isImpliedParentsDisabled = false;\r\n            } else if (tmp.equals(\"from\")) {\r\n                isImpliedParentsDisabled = true;\r\n                isImpliedChildrenDisabled = false;\r\n            } else if (tmp.equals(\"all\")) {\r\n                isImpliedChildrenDisabled = isImpliedParentsDisabled = true;\r\n            } else {\r\n                isImpliedChildrenDisabled = isImpliedParentsDisabled = false;\r\n            }\r\n        } else {\r\n            isImpliedChildrenDisabled = isImpliedParentsDisabled = false;\r\n        }\r\n        node = attribs.getNamedItem(\"disableDiagramAssociations\");\r\n        if (node != null) {\r\n            tmp = node.getNodeValue().trim().toLowerCase();\r\n            if (tmp.equals(\"all\")) {\r\n                isAllExcluded = true;\r\n                isExcluded = true;\r\n            } else if (tmp.equals(\"exceptdirect\")) {\r\n                isAllExcluded = false;\r\n                isExcluded = true;\r\n            } else {\r\n                isAllExcluded = false;\r\n                isExcluded = false;\r\n            }\r\n        } else {\r\n            isAllExcluded = false;\r\n            isExcluded = false;\r\n        }\r\n        logger.finer(\"Found XML column metadata for \" + name + \" isPrimaryKey: \" + isPrimary + \" comments: \" + comments);\r\n        NodeList fkNodes = ((Element) colNode.getChildNodes()).getElementsByTagName(\"foreignKey\");\r\n        for (int i = 0; i < fkNodes.getLength(); ++i) {\r\n            Node fkNode = fkNodes.item(i);\r\n            foreignKeys.add(new ForeignKeyMeta(fkNode));\r\n        }\r\n    }\r\n\r\n    private boolean evalBoolean(String exp) {\r\n        if (exp == null)\r\n            return false;\r\n        exp = exp.trim().toLowerCase();\r\n        return exp.equals(\"true\") || exp.equals(\"yes\") || exp.equals(\"1\");\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public String getType() {\r\n        return type;\r\n    }\r\n\r\n    public String getId() {\r\n        return id;\r\n    }\r\n\r\n    public int getSize() {\r\n        return size;\r\n    }\r\n\r\n    public int getDigits() {\r\n        return digits;\r\n    }\r\n\r\n    public boolean isPrimary() {\r\n        return isPrimary;\r\n    }\r\n\r\n    public boolean isNullable() {\r\n        return isNullable;\r\n    }\r\n\r\n    public boolean isAutoUpdated() {\r\n        return isAutoUpdated;\r\n    }\r\n\r\n    public String getComments() {\r\n        return comments;\r\n    }\r\n\r\n    public String getDefaultValue() {\r\n        return defaultValue;\r\n    }\r\n\r\n    public List<ForeignKeyMeta> getForeignKeys() {\r\n        return foreignKeys;\r\n    }\r\n\r\n    public boolean isExcluded() {\r\n        return isExcluded;\r\n    }\r\n\r\n    public boolean isAllExcluded() {\r\n        return isAllExcluded;\r\n    }\r\n\r\n    public boolean isImpliedParentsDisabled() {\r\n        return isImpliedParentsDisabled;\r\n    }\r\n\r\n    public boolean isImpliedChildrenDisabled() {\r\n        return isImpliedChildrenDisabled;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/xml/TableColumnMetaTest0.java",
		"test_prompt": "// TableColumnMetaTest0.java\npackage net.sourceforge.schemaspy.model.xml;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Logger;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TableColumnMeta}.\n* It contains ten unit test cases for the {@link TableColumnMeta#isPrimary()} method.\n*/\nclass TableColumnMetaTest0 {"
	},
	{
		"original_code": "// TableColumnMeta.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy.model.xml;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.logging.Logger;\r\nimport org.w3c.dom.Element;\r\nimport org.w3c.dom.NamedNodeMap;\r\nimport org.w3c.dom.Node;\r\nimport org.w3c.dom.NodeList;\r\n\r\n/**\r\n * Additional metadata about a column as expressed in XML instead of from\r\n * the database.\r\n *\r\n * @author John Currier\r\n */\r\npublic class TableColumnMeta {\r\n\r\n    private final String name;\r\n\r\n    private final String type;\r\n\r\n    private final boolean isPrimary;\r\n\r\n    private final String id;\r\n\r\n    private final int size;\r\n\r\n    private final int digits;\r\n\r\n    private final boolean isNullable;\r\n\r\n    private final String comments;\r\n\r\n    private final String defaultValue;\r\n\r\n    private final boolean isAutoUpdated;\r\n\r\n    private final List<ForeignKeyMeta> foreignKeys = new ArrayList<ForeignKeyMeta>();\r\n\r\n    private final boolean isExcluded;\r\n\r\n    private final boolean isAllExcluded;\r\n\r\n    private final boolean isImpliedParentsDisabled;\r\n\r\n    private final boolean isImpliedChildrenDisabled;\r\n\r\n    private static final Logger logger = Logger.getLogger(TableColumnMeta.class.getName());\r\n\r\n    TableColumnMeta(Node colNode) {\r\n        NamedNodeMap attribs = colNode.getAttributes();\r\n        String tmp;\r\n        name = attribs.getNamedItem(\"name\").getNodeValue();\r\n        Node node = attribs.getNamedItem(\"comments\");\r\n        if (node == null)\r\n            node = attribs.getNamedItem(\"remarks\");\r\n        if (node != null) {\r\n            tmp = node.getNodeValue().trim();\r\n            comments = tmp.length() == 0 ? null : tmp;\r\n        } else {\r\n            comments = null;\r\n        }\r\n        node = attribs.getNamedItem(\"type\");\r\n        type = node == null ? \"Unknown\" : node.getNodeValue();\r\n        node = attribs.getNamedItem(\"id\");\r\n        id = node == null ? null : node.getNodeValue();\r\n        node = attribs.getNamedItem(\"size\");\r\n        size = node == null ? 0 : Integer.parseInt(node.getNodeValue());\r\n        node = attribs.getNamedItem(\"digits\");\r\n        digits = node == null ? 0 : Integer.parseInt(node.getNodeValue());\r\n        node = attribs.getNamedItem(\"nullable\");\r\n        isNullable = node == null ? false : evalBoolean(node.getNodeValue());\r\n        node = attribs.getNamedItem(\"autoUpdated\");\r\n        isAutoUpdated = node == null ? false : evalBoolean(node.getNodeValue());\r\n        node = attribs.getNamedItem(\"primaryKey\");\r\n        isPrimary = node == null ? false : evalBoolean(node.getNodeValue());\r\n        node = attribs.getNamedItem(\"defaultValue\");\r\n        defaultValue = node == null ? null : node.getNodeValue();\r\n        node = attribs.getNamedItem(\"disableImpliedKeys\");\r\n        if (node != null) {\r\n            tmp = node.getNodeValue().trim().toLowerCase();\r\n            if (tmp.equals(\"to\")) {\r\n                isImpliedChildrenDisabled = true;\r\n                isImpliedParentsDisabled = false;\r\n            } else if (tmp.equals(\"from\")) {\r\n                isImpliedParentsDisabled = true;\r\n                isImpliedChildrenDisabled = false;\r\n            } else if (tmp.equals(\"all\")) {\r\n                isImpliedChildrenDisabled = isImpliedParentsDisabled = true;\r\n            } else {\r\n                isImpliedChildrenDisabled = isImpliedParentsDisabled = false;\r\n            }\r\n        } else {\r\n            isImpliedChildrenDisabled = isImpliedParentsDisabled = false;\r\n        }\r\n        node = attribs.getNamedItem(\"disableDiagramAssociations\");\r\n        if (node != null) {\r\n            tmp = node.getNodeValue().trim().toLowerCase();\r\n            if (tmp.equals(\"all\")) {\r\n                isAllExcluded = true;\r\n                isExcluded = true;\r\n            } else if (tmp.equals(\"exceptdirect\")) {\r\n                isAllExcluded = false;\r\n                isExcluded = true;\r\n            } else {\r\n                isAllExcluded = false;\r\n                isExcluded = false;\r\n            }\r\n        } else {\r\n            isAllExcluded = false;\r\n            isExcluded = false;\r\n        }\r\n        logger.finer(\"Found XML column metadata for \" + name + \" isPrimaryKey: \" + isPrimary + \" comments: \" + comments);\r\n        NodeList fkNodes = ((Element) colNode.getChildNodes()).getElementsByTagName(\"foreignKey\");\r\n        for (int i = 0; i < fkNodes.getLength(); ++i) {\r\n            Node fkNode = fkNodes.item(i);\r\n            foreignKeys.add(new ForeignKeyMeta(fkNode));\r\n        }\r\n    }\r\n\r\n    private boolean evalBoolean(String exp) {\r\n        if (exp == null)\r\n            return false;\r\n        exp = exp.trim().toLowerCase();\r\n        return exp.equals(\"true\") || exp.equals(\"yes\") || exp.equals(\"1\");\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public String getType() {\r\n        return type;\r\n    }\r\n\r\n    public String getId() {\r\n        return id;\r\n    }\r\n\r\n    public int getSize() {\r\n        return size;\r\n    }\r\n\r\n    public int getDigits() {\r\n        return digits;\r\n    }\r\n\r\n    public boolean isPrimary() {\r\n        return isPrimary;\r\n    }\r\n\r\n    public boolean isNullable() {\r\n        return isNullable;\r\n    }\r\n\r\n    public boolean isAutoUpdated() {\r\n        return isAutoUpdated;\r\n    }\r\n\r\n    public String getComments() {\r\n        return comments;\r\n    }\r\n\r\n    public String getDefaultValue() {\r\n        return defaultValue;\r\n    }\r\n\r\n    public List<ForeignKeyMeta> getForeignKeys() {\r\n        return foreignKeys;\r\n    }\r\n\r\n    public boolean isExcluded() {\r\n        return isExcluded;\r\n    }\r\n\r\n    public boolean isAllExcluded() {\r\n        return isAllExcluded;\r\n    }\r\n\r\n    public boolean isImpliedParentsDisabled() {\r\n        return isImpliedParentsDisabled;\r\n    }\r\n\r\n    public boolean isImpliedChildrenDisabled() {\r\n        return isImpliedChildrenDisabled;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/xml/TableColumnMetaTest1.java",
		"test_prompt": "// TableColumnMetaTest1.java\npackage net.sourceforge.schemaspy.model.xml;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Logger;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TableColumnMeta}.\n* It contains ten unit test cases for the {@link TableColumnMeta#isNullable()} method.\n*/\nclass TableColumnMetaTest1 {"
	},
	{
		"original_code": "// TableColumnMeta.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy.model.xml;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.logging.Logger;\r\nimport org.w3c.dom.Element;\r\nimport org.w3c.dom.NamedNodeMap;\r\nimport org.w3c.dom.Node;\r\nimport org.w3c.dom.NodeList;\r\n\r\n/**\r\n * Additional metadata about a column as expressed in XML instead of from\r\n * the database.\r\n *\r\n * @author John Currier\r\n */\r\npublic class TableColumnMeta {\r\n\r\n    private final String name;\r\n\r\n    private final String type;\r\n\r\n    private final boolean isPrimary;\r\n\r\n    private final String id;\r\n\r\n    private final int size;\r\n\r\n    private final int digits;\r\n\r\n    private final boolean isNullable;\r\n\r\n    private final String comments;\r\n\r\n    private final String defaultValue;\r\n\r\n    private final boolean isAutoUpdated;\r\n\r\n    private final List<ForeignKeyMeta> foreignKeys = new ArrayList<ForeignKeyMeta>();\r\n\r\n    private final boolean isExcluded;\r\n\r\n    private final boolean isAllExcluded;\r\n\r\n    private final boolean isImpliedParentsDisabled;\r\n\r\n    private final boolean isImpliedChildrenDisabled;\r\n\r\n    private static final Logger logger = Logger.getLogger(TableColumnMeta.class.getName());\r\n\r\n    TableColumnMeta(Node colNode) {\r\n        NamedNodeMap attribs = colNode.getAttributes();\r\n        String tmp;\r\n        name = attribs.getNamedItem(\"name\").getNodeValue();\r\n        Node node = attribs.getNamedItem(\"comments\");\r\n        if (node == null)\r\n            node = attribs.getNamedItem(\"remarks\");\r\n        if (node != null) {\r\n            tmp = node.getNodeValue().trim();\r\n            comments = tmp.length() == 0 ? null : tmp;\r\n        } else {\r\n            comments = null;\r\n        }\r\n        node = attribs.getNamedItem(\"type\");\r\n        type = node == null ? \"Unknown\" : node.getNodeValue();\r\n        node = attribs.getNamedItem(\"id\");\r\n        id = node == null ? null : node.getNodeValue();\r\n        node = attribs.getNamedItem(\"size\");\r\n        size = node == null ? 0 : Integer.parseInt(node.getNodeValue());\r\n        node = attribs.getNamedItem(\"digits\");\r\n        digits = node == null ? 0 : Integer.parseInt(node.getNodeValue());\r\n        node = attribs.getNamedItem(\"nullable\");\r\n        isNullable = node == null ? false : evalBoolean(node.getNodeValue());\r\n        node = attribs.getNamedItem(\"autoUpdated\");\r\n        isAutoUpdated = node == null ? false : evalBoolean(node.getNodeValue());\r\n        node = attribs.getNamedItem(\"primaryKey\");\r\n        isPrimary = node == null ? false : evalBoolean(node.getNodeValue());\r\n        node = attribs.getNamedItem(\"defaultValue\");\r\n        defaultValue = node == null ? null : node.getNodeValue();\r\n        node = attribs.getNamedItem(\"disableImpliedKeys\");\r\n        if (node != null) {\r\n            tmp = node.getNodeValue().trim().toLowerCase();\r\n            if (tmp.equals(\"to\")) {\r\n                isImpliedChildrenDisabled = true;\r\n                isImpliedParentsDisabled = false;\r\n            } else if (tmp.equals(\"from\")) {\r\n                isImpliedParentsDisabled = true;\r\n                isImpliedChildrenDisabled = false;\r\n            } else if (tmp.equals(\"all\")) {\r\n                isImpliedChildrenDisabled = isImpliedParentsDisabled = true;\r\n            } else {\r\n                isImpliedChildrenDisabled = isImpliedParentsDisabled = false;\r\n            }\r\n        } else {\r\n            isImpliedChildrenDisabled = isImpliedParentsDisabled = false;\r\n        }\r\n        node = attribs.getNamedItem(\"disableDiagramAssociations\");\r\n        if (node != null) {\r\n            tmp = node.getNodeValue().trim().toLowerCase();\r\n            if (tmp.equals(\"all\")) {\r\n                isAllExcluded = true;\r\n                isExcluded = true;\r\n            } else if (tmp.equals(\"exceptdirect\")) {\r\n                isAllExcluded = false;\r\n                isExcluded = true;\r\n            } else {\r\n                isAllExcluded = false;\r\n                isExcluded = false;\r\n            }\r\n        } else {\r\n            isAllExcluded = false;\r\n            isExcluded = false;\r\n        }\r\n        logger.finer(\"Found XML column metadata for \" + name + \" isPrimaryKey: \" + isPrimary + \" comments: \" + comments);\r\n        NodeList fkNodes = ((Element) colNode.getChildNodes()).getElementsByTagName(\"foreignKey\");\r\n        for (int i = 0; i < fkNodes.getLength(); ++i) {\r\n            Node fkNode = fkNodes.item(i);\r\n            foreignKeys.add(new ForeignKeyMeta(fkNode));\r\n        }\r\n    }\r\n\r\n    private boolean evalBoolean(String exp) {\r\n        if (exp == null)\r\n            return false;\r\n        exp = exp.trim().toLowerCase();\r\n        return exp.equals(\"true\") || exp.equals(\"yes\") || exp.equals(\"1\");\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public String getType() {\r\n        return type;\r\n    }\r\n\r\n    public String getId() {\r\n        return id;\r\n    }\r\n\r\n    public int getSize() {\r\n        return size;\r\n    }\r\n\r\n    public int getDigits() {\r\n        return digits;\r\n    }\r\n\r\n    public boolean isPrimary() {\r\n        return isPrimary;\r\n    }\r\n\r\n    public boolean isNullable() {\r\n        return isNullable;\r\n    }\r\n\r\n    public boolean isAutoUpdated() {\r\n        return isAutoUpdated;\r\n    }\r\n\r\n    public String getComments() {\r\n        return comments;\r\n    }\r\n\r\n    public String getDefaultValue() {\r\n        return defaultValue;\r\n    }\r\n\r\n    public List<ForeignKeyMeta> getForeignKeys() {\r\n        return foreignKeys;\r\n    }\r\n\r\n    public boolean isExcluded() {\r\n        return isExcluded;\r\n    }\r\n\r\n    public boolean isAllExcluded() {\r\n        return isAllExcluded;\r\n    }\r\n\r\n    public boolean isImpliedParentsDisabled() {\r\n        return isImpliedParentsDisabled;\r\n    }\r\n\r\n    public boolean isImpliedChildrenDisabled() {\r\n        return isImpliedChildrenDisabled;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/xml/TableColumnMetaTest2.java",
		"test_prompt": "// TableColumnMetaTest2.java\npackage net.sourceforge.schemaspy.model.xml;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Logger;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TableColumnMeta}.\n* It contains ten unit test cases for the {@link TableColumnMeta#isAutoUpdated()} method.\n*/\nclass TableColumnMetaTest2 {"
	},
	{
		"original_code": "// TableColumnMeta.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy.model.xml;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.logging.Logger;\r\nimport org.w3c.dom.Element;\r\nimport org.w3c.dom.NamedNodeMap;\r\nimport org.w3c.dom.Node;\r\nimport org.w3c.dom.NodeList;\r\n\r\n/**\r\n * Additional metadata about a column as expressed in XML instead of from\r\n * the database.\r\n *\r\n * @author John Currier\r\n */\r\npublic class TableColumnMeta {\r\n\r\n    private final String name;\r\n\r\n    private final String type;\r\n\r\n    private final boolean isPrimary;\r\n\r\n    private final String id;\r\n\r\n    private final int size;\r\n\r\n    private final int digits;\r\n\r\n    private final boolean isNullable;\r\n\r\n    private final String comments;\r\n\r\n    private final String defaultValue;\r\n\r\n    private final boolean isAutoUpdated;\r\n\r\n    private final List<ForeignKeyMeta> foreignKeys = new ArrayList<ForeignKeyMeta>();\r\n\r\n    private final boolean isExcluded;\r\n\r\n    private final boolean isAllExcluded;\r\n\r\n    private final boolean isImpliedParentsDisabled;\r\n\r\n    private final boolean isImpliedChildrenDisabled;\r\n\r\n    private static final Logger logger = Logger.getLogger(TableColumnMeta.class.getName());\r\n\r\n    TableColumnMeta(Node colNode) {\r\n        NamedNodeMap attribs = colNode.getAttributes();\r\n        String tmp;\r\n        name = attribs.getNamedItem(\"name\").getNodeValue();\r\n        Node node = attribs.getNamedItem(\"comments\");\r\n        if (node == null)\r\n            node = attribs.getNamedItem(\"remarks\");\r\n        if (node != null) {\r\n            tmp = node.getNodeValue().trim();\r\n            comments = tmp.length() == 0 ? null : tmp;\r\n        } else {\r\n            comments = null;\r\n        }\r\n        node = attribs.getNamedItem(\"type\");\r\n        type = node == null ? \"Unknown\" : node.getNodeValue();\r\n        node = attribs.getNamedItem(\"id\");\r\n        id = node == null ? null : node.getNodeValue();\r\n        node = attribs.getNamedItem(\"size\");\r\n        size = node == null ? 0 : Integer.parseInt(node.getNodeValue());\r\n        node = attribs.getNamedItem(\"digits\");\r\n        digits = node == null ? 0 : Integer.parseInt(node.getNodeValue());\r\n        node = attribs.getNamedItem(\"nullable\");\r\n        isNullable = node == null ? false : evalBoolean(node.getNodeValue());\r\n        node = attribs.getNamedItem(\"autoUpdated\");\r\n        isAutoUpdated = node == null ? false : evalBoolean(node.getNodeValue());\r\n        node = attribs.getNamedItem(\"primaryKey\");\r\n        isPrimary = node == null ? false : evalBoolean(node.getNodeValue());\r\n        node = attribs.getNamedItem(\"defaultValue\");\r\n        defaultValue = node == null ? null : node.getNodeValue();\r\n        node = attribs.getNamedItem(\"disableImpliedKeys\");\r\n        if (node != null) {\r\n            tmp = node.getNodeValue().trim().toLowerCase();\r\n            if (tmp.equals(\"to\")) {\r\n                isImpliedChildrenDisabled = true;\r\n                isImpliedParentsDisabled = false;\r\n            } else if (tmp.equals(\"from\")) {\r\n                isImpliedParentsDisabled = true;\r\n                isImpliedChildrenDisabled = false;\r\n            } else if (tmp.equals(\"all\")) {\r\n                isImpliedChildrenDisabled = isImpliedParentsDisabled = true;\r\n            } else {\r\n                isImpliedChildrenDisabled = isImpliedParentsDisabled = false;\r\n            }\r\n        } else {\r\n            isImpliedChildrenDisabled = isImpliedParentsDisabled = false;\r\n        }\r\n        node = attribs.getNamedItem(\"disableDiagramAssociations\");\r\n        if (node != null) {\r\n            tmp = node.getNodeValue().trim().toLowerCase();\r\n            if (tmp.equals(\"all\")) {\r\n                isAllExcluded = true;\r\n                isExcluded = true;\r\n            } else if (tmp.equals(\"exceptdirect\")) {\r\n                isAllExcluded = false;\r\n                isExcluded = true;\r\n            } else {\r\n                isAllExcluded = false;\r\n                isExcluded = false;\r\n            }\r\n        } else {\r\n            isAllExcluded = false;\r\n            isExcluded = false;\r\n        }\r\n        logger.finer(\"Found XML column metadata for \" + name + \" isPrimaryKey: \" + isPrimary + \" comments: \" + comments);\r\n        NodeList fkNodes = ((Element) colNode.getChildNodes()).getElementsByTagName(\"foreignKey\");\r\n        for (int i = 0; i < fkNodes.getLength(); ++i) {\r\n            Node fkNode = fkNodes.item(i);\r\n            foreignKeys.add(new ForeignKeyMeta(fkNode));\r\n        }\r\n    }\r\n\r\n    private boolean evalBoolean(String exp) {\r\n        if (exp == null)\r\n            return false;\r\n        exp = exp.trim().toLowerCase();\r\n        return exp.equals(\"true\") || exp.equals(\"yes\") || exp.equals(\"1\");\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public String getType() {\r\n        return type;\r\n    }\r\n\r\n    public String getId() {\r\n        return id;\r\n    }\r\n\r\n    public int getSize() {\r\n        return size;\r\n    }\r\n\r\n    public int getDigits() {\r\n        return digits;\r\n    }\r\n\r\n    public boolean isPrimary() {\r\n        return isPrimary;\r\n    }\r\n\r\n    public boolean isNullable() {\r\n        return isNullable;\r\n    }\r\n\r\n    public boolean isAutoUpdated() {\r\n        return isAutoUpdated;\r\n    }\r\n\r\n    public String getComments() {\r\n        return comments;\r\n    }\r\n\r\n    public String getDefaultValue() {\r\n        return defaultValue;\r\n    }\r\n\r\n    public List<ForeignKeyMeta> getForeignKeys() {\r\n        return foreignKeys;\r\n    }\r\n\r\n    public boolean isExcluded() {\r\n        return isExcluded;\r\n    }\r\n\r\n    public boolean isAllExcluded() {\r\n        return isAllExcluded;\r\n    }\r\n\r\n    public boolean isImpliedParentsDisabled() {\r\n        return isImpliedParentsDisabled;\r\n    }\r\n\r\n    public boolean isImpliedChildrenDisabled() {\r\n        return isImpliedChildrenDisabled;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/xml/TableColumnMetaTest3.java",
		"test_prompt": "// TableColumnMetaTest3.java\npackage net.sourceforge.schemaspy.model.xml;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Logger;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TableColumnMeta}.\n* It contains ten unit test cases for the {@link TableColumnMeta#isExcluded()} method.\n*/\nclass TableColumnMetaTest3 {"
	},
	{
		"original_code": "// TableColumnMeta.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy.model.xml;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.logging.Logger;\r\nimport org.w3c.dom.Element;\r\nimport org.w3c.dom.NamedNodeMap;\r\nimport org.w3c.dom.Node;\r\nimport org.w3c.dom.NodeList;\r\n\r\n/**\r\n * Additional metadata about a column as expressed in XML instead of from\r\n * the database.\r\n *\r\n * @author John Currier\r\n */\r\npublic class TableColumnMeta {\r\n\r\n    private final String name;\r\n\r\n    private final String type;\r\n\r\n    private final boolean isPrimary;\r\n\r\n    private final String id;\r\n\r\n    private final int size;\r\n\r\n    private final int digits;\r\n\r\n    private final boolean isNullable;\r\n\r\n    private final String comments;\r\n\r\n    private final String defaultValue;\r\n\r\n    private final boolean isAutoUpdated;\r\n\r\n    private final List<ForeignKeyMeta> foreignKeys = new ArrayList<ForeignKeyMeta>();\r\n\r\n    private final boolean isExcluded;\r\n\r\n    private final boolean isAllExcluded;\r\n\r\n    private final boolean isImpliedParentsDisabled;\r\n\r\n    private final boolean isImpliedChildrenDisabled;\r\n\r\n    private static final Logger logger = Logger.getLogger(TableColumnMeta.class.getName());\r\n\r\n    TableColumnMeta(Node colNode) {\r\n        NamedNodeMap attribs = colNode.getAttributes();\r\n        String tmp;\r\n        name = attribs.getNamedItem(\"name\").getNodeValue();\r\n        Node node = attribs.getNamedItem(\"comments\");\r\n        if (node == null)\r\n            node = attribs.getNamedItem(\"remarks\");\r\n        if (node != null) {\r\n            tmp = node.getNodeValue().trim();\r\n            comments = tmp.length() == 0 ? null : tmp;\r\n        } else {\r\n            comments = null;\r\n        }\r\n        node = attribs.getNamedItem(\"type\");\r\n        type = node == null ? \"Unknown\" : node.getNodeValue();\r\n        node = attribs.getNamedItem(\"id\");\r\n        id = node == null ? null : node.getNodeValue();\r\n        node = attribs.getNamedItem(\"size\");\r\n        size = node == null ? 0 : Integer.parseInt(node.getNodeValue());\r\n        node = attribs.getNamedItem(\"digits\");\r\n        digits = node == null ? 0 : Integer.parseInt(node.getNodeValue());\r\n        node = attribs.getNamedItem(\"nullable\");\r\n        isNullable = node == null ? false : evalBoolean(node.getNodeValue());\r\n        node = attribs.getNamedItem(\"autoUpdated\");\r\n        isAutoUpdated = node == null ? false : evalBoolean(node.getNodeValue());\r\n        node = attribs.getNamedItem(\"primaryKey\");\r\n        isPrimary = node == null ? false : evalBoolean(node.getNodeValue());\r\n        node = attribs.getNamedItem(\"defaultValue\");\r\n        defaultValue = node == null ? null : node.getNodeValue();\r\n        node = attribs.getNamedItem(\"disableImpliedKeys\");\r\n        if (node != null) {\r\n            tmp = node.getNodeValue().trim().toLowerCase();\r\n            if (tmp.equals(\"to\")) {\r\n                isImpliedChildrenDisabled = true;\r\n                isImpliedParentsDisabled = false;\r\n            } else if (tmp.equals(\"from\")) {\r\n                isImpliedParentsDisabled = true;\r\n                isImpliedChildrenDisabled = false;\r\n            } else if (tmp.equals(\"all\")) {\r\n                isImpliedChildrenDisabled = isImpliedParentsDisabled = true;\r\n            } else {\r\n                isImpliedChildrenDisabled = isImpliedParentsDisabled = false;\r\n            }\r\n        } else {\r\n            isImpliedChildrenDisabled = isImpliedParentsDisabled = false;\r\n        }\r\n        node = attribs.getNamedItem(\"disableDiagramAssociations\");\r\n        if (node != null) {\r\n            tmp = node.getNodeValue().trim().toLowerCase();\r\n            if (tmp.equals(\"all\")) {\r\n                isAllExcluded = true;\r\n                isExcluded = true;\r\n            } else if (tmp.equals(\"exceptdirect\")) {\r\n                isAllExcluded = false;\r\n                isExcluded = true;\r\n            } else {\r\n                isAllExcluded = false;\r\n                isExcluded = false;\r\n            }\r\n        } else {\r\n            isAllExcluded = false;\r\n            isExcluded = false;\r\n        }\r\n        logger.finer(\"Found XML column metadata for \" + name + \" isPrimaryKey: \" + isPrimary + \" comments: \" + comments);\r\n        NodeList fkNodes = ((Element) colNode.getChildNodes()).getElementsByTagName(\"foreignKey\");\r\n        for (int i = 0; i < fkNodes.getLength(); ++i) {\r\n            Node fkNode = fkNodes.item(i);\r\n            foreignKeys.add(new ForeignKeyMeta(fkNode));\r\n        }\r\n    }\r\n\r\n    private boolean evalBoolean(String exp) {\r\n        if (exp == null)\r\n            return false;\r\n        exp = exp.trim().toLowerCase();\r\n        return exp.equals(\"true\") || exp.equals(\"yes\") || exp.equals(\"1\");\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public String getType() {\r\n        return type;\r\n    }\r\n\r\n    public String getId() {\r\n        return id;\r\n    }\r\n\r\n    public int getSize() {\r\n        return size;\r\n    }\r\n\r\n    public int getDigits() {\r\n        return digits;\r\n    }\r\n\r\n    public boolean isPrimary() {\r\n        return isPrimary;\r\n    }\r\n\r\n    public boolean isNullable() {\r\n        return isNullable;\r\n    }\r\n\r\n    public boolean isAutoUpdated() {\r\n        return isAutoUpdated;\r\n    }\r\n\r\n    public String getComments() {\r\n        return comments;\r\n    }\r\n\r\n    public String getDefaultValue() {\r\n        return defaultValue;\r\n    }\r\n\r\n    public List<ForeignKeyMeta> getForeignKeys() {\r\n        return foreignKeys;\r\n    }\r\n\r\n    public boolean isExcluded() {\r\n        return isExcluded;\r\n    }\r\n\r\n    public boolean isAllExcluded() {\r\n        return isAllExcluded;\r\n    }\r\n\r\n    public boolean isImpliedParentsDisabled() {\r\n        return isImpliedParentsDisabled;\r\n    }\r\n\r\n    public boolean isImpliedChildrenDisabled() {\r\n        return isImpliedChildrenDisabled;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/xml/TableColumnMetaTest4.java",
		"test_prompt": "// TableColumnMetaTest4.java\npackage net.sourceforge.schemaspy.model.xml;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Logger;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TableColumnMeta}.\n* It contains ten unit test cases for the {@link TableColumnMeta#isAllExcluded()} method.\n*/\nclass TableColumnMetaTest4 {"
	},
	{
		"original_code": "// TableColumnMeta.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy.model.xml;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.logging.Logger;\r\nimport org.w3c.dom.Element;\r\nimport org.w3c.dom.NamedNodeMap;\r\nimport org.w3c.dom.Node;\r\nimport org.w3c.dom.NodeList;\r\n\r\n/**\r\n * Additional metadata about a column as expressed in XML instead of from\r\n * the database.\r\n *\r\n * @author John Currier\r\n */\r\npublic class TableColumnMeta {\r\n\r\n    private final String name;\r\n\r\n    private final String type;\r\n\r\n    private final boolean isPrimary;\r\n\r\n    private final String id;\r\n\r\n    private final int size;\r\n\r\n    private final int digits;\r\n\r\n    private final boolean isNullable;\r\n\r\n    private final String comments;\r\n\r\n    private final String defaultValue;\r\n\r\n    private final boolean isAutoUpdated;\r\n\r\n    private final List<ForeignKeyMeta> foreignKeys = new ArrayList<ForeignKeyMeta>();\r\n\r\n    private final boolean isExcluded;\r\n\r\n    private final boolean isAllExcluded;\r\n\r\n    private final boolean isImpliedParentsDisabled;\r\n\r\n    private final boolean isImpliedChildrenDisabled;\r\n\r\n    private static final Logger logger = Logger.getLogger(TableColumnMeta.class.getName());\r\n\r\n    TableColumnMeta(Node colNode) {\r\n        NamedNodeMap attribs = colNode.getAttributes();\r\n        String tmp;\r\n        name = attribs.getNamedItem(\"name\").getNodeValue();\r\n        Node node = attribs.getNamedItem(\"comments\");\r\n        if (node == null)\r\n            node = attribs.getNamedItem(\"remarks\");\r\n        if (node != null) {\r\n            tmp = node.getNodeValue().trim();\r\n            comments = tmp.length() == 0 ? null : tmp;\r\n        } else {\r\n            comments = null;\r\n        }\r\n        node = attribs.getNamedItem(\"type\");\r\n        type = node == null ? \"Unknown\" : node.getNodeValue();\r\n        node = attribs.getNamedItem(\"id\");\r\n        id = node == null ? null : node.getNodeValue();\r\n        node = attribs.getNamedItem(\"size\");\r\n        size = node == null ? 0 : Integer.parseInt(node.getNodeValue());\r\n        node = attribs.getNamedItem(\"digits\");\r\n        digits = node == null ? 0 : Integer.parseInt(node.getNodeValue());\r\n        node = attribs.getNamedItem(\"nullable\");\r\n        isNullable = node == null ? false : evalBoolean(node.getNodeValue());\r\n        node = attribs.getNamedItem(\"autoUpdated\");\r\n        isAutoUpdated = node == null ? false : evalBoolean(node.getNodeValue());\r\n        node = attribs.getNamedItem(\"primaryKey\");\r\n        isPrimary = node == null ? false : evalBoolean(node.getNodeValue());\r\n        node = attribs.getNamedItem(\"defaultValue\");\r\n        defaultValue = node == null ? null : node.getNodeValue();\r\n        node = attribs.getNamedItem(\"disableImpliedKeys\");\r\n        if (node != null) {\r\n            tmp = node.getNodeValue().trim().toLowerCase();\r\n            if (tmp.equals(\"to\")) {\r\n                isImpliedChildrenDisabled = true;\r\n                isImpliedParentsDisabled = false;\r\n            } else if (tmp.equals(\"from\")) {\r\n                isImpliedParentsDisabled = true;\r\n                isImpliedChildrenDisabled = false;\r\n            } else if (tmp.equals(\"all\")) {\r\n                isImpliedChildrenDisabled = isImpliedParentsDisabled = true;\r\n            } else {\r\n                isImpliedChildrenDisabled = isImpliedParentsDisabled = false;\r\n            }\r\n        } else {\r\n            isImpliedChildrenDisabled = isImpliedParentsDisabled = false;\r\n        }\r\n        node = attribs.getNamedItem(\"disableDiagramAssociations\");\r\n        if (node != null) {\r\n            tmp = node.getNodeValue().trim().toLowerCase();\r\n            if (tmp.equals(\"all\")) {\r\n                isAllExcluded = true;\r\n                isExcluded = true;\r\n            } else if (tmp.equals(\"exceptdirect\")) {\r\n                isAllExcluded = false;\r\n                isExcluded = true;\r\n            } else {\r\n                isAllExcluded = false;\r\n                isExcluded = false;\r\n            }\r\n        } else {\r\n            isAllExcluded = false;\r\n            isExcluded = false;\r\n        }\r\n        logger.finer(\"Found XML column metadata for \" + name + \" isPrimaryKey: \" + isPrimary + \" comments: \" + comments);\r\n        NodeList fkNodes = ((Element) colNode.getChildNodes()).getElementsByTagName(\"foreignKey\");\r\n        for (int i = 0; i < fkNodes.getLength(); ++i) {\r\n            Node fkNode = fkNodes.item(i);\r\n            foreignKeys.add(new ForeignKeyMeta(fkNode));\r\n        }\r\n    }\r\n\r\n    private boolean evalBoolean(String exp) {\r\n        if (exp == null)\r\n            return false;\r\n        exp = exp.trim().toLowerCase();\r\n        return exp.equals(\"true\") || exp.equals(\"yes\") || exp.equals(\"1\");\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public String getType() {\r\n        return type;\r\n    }\r\n\r\n    public String getId() {\r\n        return id;\r\n    }\r\n\r\n    public int getSize() {\r\n        return size;\r\n    }\r\n\r\n    public int getDigits() {\r\n        return digits;\r\n    }\r\n\r\n    public boolean isPrimary() {\r\n        return isPrimary;\r\n    }\r\n\r\n    public boolean isNullable() {\r\n        return isNullable;\r\n    }\r\n\r\n    public boolean isAutoUpdated() {\r\n        return isAutoUpdated;\r\n    }\r\n\r\n    public String getComments() {\r\n        return comments;\r\n    }\r\n\r\n    public String getDefaultValue() {\r\n        return defaultValue;\r\n    }\r\n\r\n    public List<ForeignKeyMeta> getForeignKeys() {\r\n        return foreignKeys;\r\n    }\r\n\r\n    public boolean isExcluded() {\r\n        return isExcluded;\r\n    }\r\n\r\n    public boolean isAllExcluded() {\r\n        return isAllExcluded;\r\n    }\r\n\r\n    public boolean isImpliedParentsDisabled() {\r\n        return isImpliedParentsDisabled;\r\n    }\r\n\r\n    public boolean isImpliedChildrenDisabled() {\r\n        return isImpliedChildrenDisabled;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/xml/TableColumnMetaTest5.java",
		"test_prompt": "// TableColumnMetaTest5.java\npackage net.sourceforge.schemaspy.model.xml;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Logger;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TableColumnMeta}.\n* It contains ten unit test cases for the {@link TableColumnMeta#isImpliedParentsDisabled()} method.\n*/\nclass TableColumnMetaTest5 {"
	},
	{
		"original_code": "// TableColumnMeta.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy.model.xml;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.logging.Logger;\r\nimport org.w3c.dom.Element;\r\nimport org.w3c.dom.NamedNodeMap;\r\nimport org.w3c.dom.Node;\r\nimport org.w3c.dom.NodeList;\r\n\r\n/**\r\n * Additional metadata about a column as expressed in XML instead of from\r\n * the database.\r\n *\r\n * @author John Currier\r\n */\r\npublic class TableColumnMeta {\r\n\r\n    private final String name;\r\n\r\n    private final String type;\r\n\r\n    private final boolean isPrimary;\r\n\r\n    private final String id;\r\n\r\n    private final int size;\r\n\r\n    private final int digits;\r\n\r\n    private final boolean isNullable;\r\n\r\n    private final String comments;\r\n\r\n    private final String defaultValue;\r\n\r\n    private final boolean isAutoUpdated;\r\n\r\n    private final List<ForeignKeyMeta> foreignKeys = new ArrayList<ForeignKeyMeta>();\r\n\r\n    private final boolean isExcluded;\r\n\r\n    private final boolean isAllExcluded;\r\n\r\n    private final boolean isImpliedParentsDisabled;\r\n\r\n    private final boolean isImpliedChildrenDisabled;\r\n\r\n    private static final Logger logger = Logger.getLogger(TableColumnMeta.class.getName());\r\n\r\n    TableColumnMeta(Node colNode) {\r\n        NamedNodeMap attribs = colNode.getAttributes();\r\n        String tmp;\r\n        name = attribs.getNamedItem(\"name\").getNodeValue();\r\n        Node node = attribs.getNamedItem(\"comments\");\r\n        if (node == null)\r\n            node = attribs.getNamedItem(\"remarks\");\r\n        if (node != null) {\r\n            tmp = node.getNodeValue().trim();\r\n            comments = tmp.length() == 0 ? null : tmp;\r\n        } else {\r\n            comments = null;\r\n        }\r\n        node = attribs.getNamedItem(\"type\");\r\n        type = node == null ? \"Unknown\" : node.getNodeValue();\r\n        node = attribs.getNamedItem(\"id\");\r\n        id = node == null ? null : node.getNodeValue();\r\n        node = attribs.getNamedItem(\"size\");\r\n        size = node == null ? 0 : Integer.parseInt(node.getNodeValue());\r\n        node = attribs.getNamedItem(\"digits\");\r\n        digits = node == null ? 0 : Integer.parseInt(node.getNodeValue());\r\n        node = attribs.getNamedItem(\"nullable\");\r\n        isNullable = node == null ? false : evalBoolean(node.getNodeValue());\r\n        node = attribs.getNamedItem(\"autoUpdated\");\r\n        isAutoUpdated = node == null ? false : evalBoolean(node.getNodeValue());\r\n        node = attribs.getNamedItem(\"primaryKey\");\r\n        isPrimary = node == null ? false : evalBoolean(node.getNodeValue());\r\n        node = attribs.getNamedItem(\"defaultValue\");\r\n        defaultValue = node == null ? null : node.getNodeValue();\r\n        node = attribs.getNamedItem(\"disableImpliedKeys\");\r\n        if (node != null) {\r\n            tmp = node.getNodeValue().trim().toLowerCase();\r\n            if (tmp.equals(\"to\")) {\r\n                isImpliedChildrenDisabled = true;\r\n                isImpliedParentsDisabled = false;\r\n            } else if (tmp.equals(\"from\")) {\r\n                isImpliedParentsDisabled = true;\r\n                isImpliedChildrenDisabled = false;\r\n            } else if (tmp.equals(\"all\")) {\r\n                isImpliedChildrenDisabled = isImpliedParentsDisabled = true;\r\n            } else {\r\n                isImpliedChildrenDisabled = isImpliedParentsDisabled = false;\r\n            }\r\n        } else {\r\n            isImpliedChildrenDisabled = isImpliedParentsDisabled = false;\r\n        }\r\n        node = attribs.getNamedItem(\"disableDiagramAssociations\");\r\n        if (node != null) {\r\n            tmp = node.getNodeValue().trim().toLowerCase();\r\n            if (tmp.equals(\"all\")) {\r\n                isAllExcluded = true;\r\n                isExcluded = true;\r\n            } else if (tmp.equals(\"exceptdirect\")) {\r\n                isAllExcluded = false;\r\n                isExcluded = true;\r\n            } else {\r\n                isAllExcluded = false;\r\n                isExcluded = false;\r\n            }\r\n        } else {\r\n            isAllExcluded = false;\r\n            isExcluded = false;\r\n        }\r\n        logger.finer(\"Found XML column metadata for \" + name + \" isPrimaryKey: \" + isPrimary + \" comments: \" + comments);\r\n        NodeList fkNodes = ((Element) colNode.getChildNodes()).getElementsByTagName(\"foreignKey\");\r\n        for (int i = 0; i < fkNodes.getLength(); ++i) {\r\n            Node fkNode = fkNodes.item(i);\r\n            foreignKeys.add(new ForeignKeyMeta(fkNode));\r\n        }\r\n    }\r\n\r\n    private boolean evalBoolean(String exp) {\r\n        if (exp == null)\r\n            return false;\r\n        exp = exp.trim().toLowerCase();\r\n        return exp.equals(\"true\") || exp.equals(\"yes\") || exp.equals(\"1\");\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public String getType() {\r\n        return type;\r\n    }\r\n\r\n    public String getId() {\r\n        return id;\r\n    }\r\n\r\n    public int getSize() {\r\n        return size;\r\n    }\r\n\r\n    public int getDigits() {\r\n        return digits;\r\n    }\r\n\r\n    public boolean isPrimary() {\r\n        return isPrimary;\r\n    }\r\n\r\n    public boolean isNullable() {\r\n        return isNullable;\r\n    }\r\n\r\n    public boolean isAutoUpdated() {\r\n        return isAutoUpdated;\r\n    }\r\n\r\n    public String getComments() {\r\n        return comments;\r\n    }\r\n\r\n    public String getDefaultValue() {\r\n        return defaultValue;\r\n    }\r\n\r\n    public List<ForeignKeyMeta> getForeignKeys() {\r\n        return foreignKeys;\r\n    }\r\n\r\n    public boolean isExcluded() {\r\n        return isExcluded;\r\n    }\r\n\r\n    public boolean isAllExcluded() {\r\n        return isAllExcluded;\r\n    }\r\n\r\n    public boolean isImpliedParentsDisabled() {\r\n        return isImpliedParentsDisabled;\r\n    }\r\n\r\n    public boolean isImpliedChildrenDisabled() {\r\n        return isImpliedChildrenDisabled;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/xml/TableColumnMetaTest6.java",
		"test_prompt": "// TableColumnMetaTest6.java\npackage net.sourceforge.schemaspy.model.xml;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Logger;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TableColumnMeta}.\n* It contains ten unit test cases for the {@link TableColumnMeta#isImpliedChildrenDisabled()} method.\n*/\nclass TableColumnMetaTest6 {"
	},
	{
		"original_code": "// View.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport net.sourceforge.schemaspy.Config;\n\n/**\n * Treat views as tables that have no rows and are represented by the SQL that\n * defined them.\n */\npublic class View extends Table {\n\n    private String viewSql;\n\n    /**\n     * @param db\n     * @param catalog\n     * @param schema\n     * @param name\n     * @param remarks\n     * @param viewSql\n     * @throws SQLException\n     */\n    public View(Database db, String catalog, String schema, String name, String remarks, String viewSql) throws SQLException {\n        super(db, catalog, schema, name, remarks);\n        if (viewSql == null)\n            viewSql = fetchViewSql();\n        if (viewSql != null && viewSql.trim().length() > 0)\n            this.viewSql = viewSql;\n    }\n\n    /**\n     * @return\n     */\n    @Override\n    public boolean isView() {\n        return true;\n    }\n\n    @Override\n    public String getViewSql() {\n        return viewSql;\n    }\n\n    /**\n     * Extract the SQL that describes this view from the database\n     *\n     * @return\n     * @throws SQLException\n     */\n    private String fetchViewSql() throws SQLException {\n        String selectViewSql = Config.getInstance().getDbProperties().getProperty(\"selectViewSql\");\n        if (selectViewSql == null)\n            return null;\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = db.prepareStatement(selectViewSql, getName());\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                try {\n                    return rs.getString(\"view_definition\");\n                } catch (SQLException tryOldName) {\n                    return rs.getString(\"text\");\n                }\n            }\n            return null;\n        } catch (SQLException sqlException) {\n            System.err.println(selectViewSql);\n            throw sqlException;\n        } finally {\n            if (rs != null)\n                rs.close();\n            if (stmt != null)\n                stmt.close();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/ViewTest.java",
		"test_prompt": "// ViewTest.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport net.sourceforge.schemaspy.Config;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link View}.\n* It contains ten unit test cases for the {@link View#isView()} method.\n*/\nclass ViewTest {"
	},
	{
		"original_code": "// ForeignKeyConstraint.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport static java.sql.DatabaseMetaData.importedKeyCascade;\nimport static java.sql.DatabaseMetaData.importedKeyNoAction;\nimport static java.sql.DatabaseMetaData.importedKeyRestrict;\nimport static java.sql.DatabaseMetaData.importedKeySetNull;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Represents a <a href='http://en.wikipedia.org/wiki/Foreign_key'>\n * Foreign Key Constraint</a> that \"ties\" a child table to a parent table\n * via foreign and primary keys.\n */\npublic class ForeignKeyConstraint implements Comparable<ForeignKeyConstraint> {\n\n    private final String name;\n\n    private Table parentTable;\n\n    private final List<TableColumn> parentColumns = new ArrayList<TableColumn>();\n\n    private final Table childTable;\n\n    private final List<TableColumn> childColumns = new ArrayList<TableColumn>();\n\n    private final int deleteRule;\n\n    private final int updateRule;\n\n    private final static Logger logger = Logger.getLogger(ForeignKeyConstraint.class.getName());\n\n    private final static boolean finerEnabled = logger.isLoggable(Level.FINER);\n\n    /**\n     * Construct a foreign key for the specified child table.\n     * Relationship details will be added later.\n     *\n     * @param child\n     * @param name\n     * @param deleteRule\n     */\n    ForeignKeyConstraint(Table child, String name, int updateRule, int deleteRule) {\n        // implied constraints will have a null name and override getName()\n        this.name = name;\n        if (finerEnabled)\n            logger.finer(\"Adding foreign key constraint '\" + getName() + \"' to \" + child.getFullName());\n        childTable = child;\n        this.deleteRule = deleteRule;\n        this.updateRule = updateRule;\n    }\n\n    /**\n     * This constructor is intended for use <b>after</b> all of the tables have been\n     * found in the system.  One impact of using this constructor is that it will\n     * \"glue\" the two tables together through their columns.\n     *\n     * @param parentColumn\n     * @param childColumn\n     */\n    public ForeignKeyConstraint(TableColumn parentColumn, TableColumn childColumn, int updateRule, int deleteRule) {\n        this(childColumn.getTable(), null, updateRule, deleteRule);\n        addChildColumn(childColumn);\n        addParentColumn(parentColumn);\n        childColumn.addParent(parentColumn, this);\n        parentColumn.addChild(childColumn, this);\n    }\n\n    /**\n     * Same as {@link #ForeignKeyConstraint(TableColumn, TableColumn, int, int)},\n     * but defaults updateRule and deleteRule to\n     * {@link java.sql.DatabaseMetaData#importedKeyNoAction}.\n     *\n     * @param parentColumn\n     * @param childColumn\n     */\n    public ForeignKeyConstraint(TableColumn parentColumn, TableColumn childColumn) {\n        this(parentColumn, childColumn, importedKeyNoAction, importedKeyNoAction);\n    }\n\n    /**\n     * Add a \"parent\" side to the constraint.\n     *\n     * @param column\n     */\n    void addParentColumn(TableColumn column) {\n        if (column != null) {\n            parentColumns.add(column);\n            parentTable = column.getTable();\n        }\n    }\n\n    /**\n     * Add a \"child\" side to the constraint.\n     *\n     * @param column\n     */\n    void addChildColumn(TableColumn column) {\n        if (column != null) {\n            childColumns.add(column);\n        }\n    }\n\n    /**\n     * Returns the name of the constraint\n     *\n     * @return\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the parent table (the table that contains the referenced primary key\n     * column).\n     *\n     * @return\n     */\n    public Table getParentTable() {\n        return parentTable;\n    }\n\n    /**\n     * Returns all of the primary key columns that are referenced by this constraint.\n     *\n     * @return\n     */\n    public List<TableColumn> getParentColumns() {\n        return Collections.unmodifiableList(parentColumns);\n    }\n\n    /**\n     * Returns the table on the \"child\" end of the relationship (contains the foreign\n     * key that references the parent table's primary key).\n     *\n     * @return\n     */\n    public Table getChildTable() {\n        return childTable;\n    }\n\n    /**\n     * Returns all of the foreign key columns that are referenced by this constraint.\n     *\n     * @return\n     */\n    public List<TableColumn> getChildColumns() {\n        return Collections.unmodifiableList(childColumns);\n    }\n\n    /**\n     * Returns the delete rule for this constraint.\n     *\n     * @see {@link java.sql.DatabaseMetaData#importedKeyCascade}\n     */\n    public int getDeleteRule() {\n        return deleteRule;\n    }\n\n    /**\n     * Returns <code>true</code> if this constraint should\n     * <a href='http://en.wikipedia.org/wiki/Cascade_delete'>cascade deletions</code>.\n     *\n     * @return\n     */\n    public boolean isCascadeOnDelete() {\n        return getDeleteRule() == importedKeyCascade;\n    }\n\n    /**\n     * Returns <code>true</code> if the constraint prevents the parent table\n     * from being deleted if child tables exist.\n     *\n     * @return\n     */\n    public boolean isRestrictDelete() {\n        return getDeleteRule() == importedKeyNoAction || getDeleteRule() == importedKeyRestrict;\n    }\n\n    /**\n     * Returns <code>true</code> if the constraint indicates that the foreign key\n     * will be set to <code>null</code> when the parent key is deleted.\n     *\n     * @return\n     */\n    public boolean isNullOnDelete() {\n        return getDeleteRule() == importedKeySetNull;\n    }\n\n    public String getDeleteRuleName() {\n        switch(getDeleteRule()) {\n            case importedKeyCascade:\n                return \"Cascade on delete\";\n            case importedKeyRestrict:\n            case importedKeyNoAction:\n                return \"Restrict delete\";\n            case importedKeySetNull:\n                return \"Null on delete\";\n            default:\n                return \"\";\n        }\n    }\n\n    public String getDeleteRuleDescription() {\n        switch(getDeleteRule()) {\n            case importedKeyCascade:\n                return \"Cascade on delete:\\n Deletion of parent deletes child\";\n            case importedKeyRestrict:\n            case importedKeyNoAction:\n                return \"Restrict delete:\\n Parent cannot be deleted if children exist\";\n            case importedKeySetNull:\n                return \"Null on delete:\\n Foreign key to parent set to NULL when parent deleted\";\n            default:\n                return \"\";\n        }\n    }\n\n    public String getDeleteRuleAlias() {\n        switch(getDeleteRule()) {\n            case importedKeyCascade:\n                return \"C\";\n            case importedKeyRestrict:\n            case importedKeyNoAction:\n                return \"R\";\n            case importedKeySetNull:\n                return \"N\";\n            default:\n                return \"\";\n        }\n    }\n\n    /**\n     * Returns the update rule for this constraint.\n     *\n     * @see {@link java.sql.DatabaseMetaData#importedKeyCascade}\n     */\n    public int getUpdateRule() {\n        return updateRule;\n    }\n\n    /**\n     * Returns <code>true</code> if this is an implied constraint or\n     * <code>false</code> if it is \"real\".\n     *\n     * Subclasses that implement implied constraints should override this method.\n     *\n     * @return\n     */\n    public boolean isImplied() {\n        return false;\n    }\n\n    /**\n     * We have several types of constraints.\n     * This returns <code>true</code> if the constraint came from the database\n     * metadata and not inferred by something else.\n     * This is different than {@link #isImplied()} in that implied relationships\n     * are a specific type of non-real relationships.\n     *\n     * @return\n     */\n    public boolean isReal() {\n        return getClass() == ForeignKeyConstraint.class;\n    }\n\n    /**\n     * Custom comparison method to deal with foreign key names that aren't\n     * unique across all schemas being evaluated\n     *\n     * @param other ForeignKeyConstraint\n     *\n     * @return\n     */\n    public int compareTo(ForeignKeyConstraint other) {\n        if (other == this)\n            return 0;\n        int rc = getName().compareToIgnoreCase(other.getName());\n        if (rc == 0) {\n            // should only get here if we're dealing with cross-schema references (rare)\n            String ours = getChildColumns().get(0).getTable().getContainer();\n            String theirs = other.getChildColumns().get(0).getTable().getContainer();\n            if (ours != null && theirs != null)\n                rc = ours.compareToIgnoreCase(theirs);\n            else if (ours == null)\n                rc = -1;\n            else\n                rc = 1;\n        }\n        return rc;\n    }\n\n    /**\n     * Static method that returns a string representation of the specified\n     * list of {@link TableColumn columns}.\n     *\n     * @param columns\n     * @return\n     */\n    public static String toString(List<TableColumn> columns) {\n        if (columns.size() == 1)\n            return columns.iterator().next().toString();\n        return columns.toString();\n    }\n\n    /**\n     * Returns a string representation of this foreign key constraint.\n     *\n     * @return\n     */\n    @Override\n    public String toString() {\n        StringBuilder buf = new StringBuilder();\n        buf.append(childTable.getName());\n        buf.append('.');\n        buf.append(toString(childColumns));\n        buf.append(\" references \");\n        if (parentTable.isRemote()) {\n            buf.append(parentTable.getContainer());\n            buf.append('.');\n        }\n        buf.append(parentTable.getName());\n        buf.append('.');\n        buf.append(toString(parentColumns));\n        if (name != null) {\n            buf.append(\" via \");\n            buf.append(name);\n        }\n        return buf.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/ForeignKeyConstraintTest0.java",
		"test_prompt": "// ForeignKeyConstraintTest0.java\npackage net.sourceforge.schemaspy.model;\n\nimport static java.sql.DatabaseMetaData.importedKeyCascade;\nimport static java.sql.DatabaseMetaData.importedKeyNoAction;\nimport static java.sql.DatabaseMetaData.importedKeyRestrict;\nimport static java.sql.DatabaseMetaData.importedKeySetNull;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ForeignKeyConstraint}.\n* It contains ten unit test cases for the {@link ForeignKeyConstraint#isCascadeOnDelete()} method.\n*/\nclass ForeignKeyConstraintTest0 {"
	},
	{
		"original_code": "// ForeignKeyConstraint.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport static java.sql.DatabaseMetaData.importedKeyCascade;\nimport static java.sql.DatabaseMetaData.importedKeyNoAction;\nimport static java.sql.DatabaseMetaData.importedKeyRestrict;\nimport static java.sql.DatabaseMetaData.importedKeySetNull;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Represents a <a href='http://en.wikipedia.org/wiki/Foreign_key'>\n * Foreign Key Constraint</a> that \"ties\" a child table to a parent table\n * via foreign and primary keys.\n */\npublic class ForeignKeyConstraint implements Comparable<ForeignKeyConstraint> {\n\n    private final String name;\n\n    private Table parentTable;\n\n    private final List<TableColumn> parentColumns = new ArrayList<TableColumn>();\n\n    private final Table childTable;\n\n    private final List<TableColumn> childColumns = new ArrayList<TableColumn>();\n\n    private final int deleteRule;\n\n    private final int updateRule;\n\n    private final static Logger logger = Logger.getLogger(ForeignKeyConstraint.class.getName());\n\n    private final static boolean finerEnabled = logger.isLoggable(Level.FINER);\n\n    /**\n     * Construct a foreign key for the specified child table.\n     * Relationship details will be added later.\n     *\n     * @param child\n     * @param name\n     * @param deleteRule\n     */\n    ForeignKeyConstraint(Table child, String name, int updateRule, int deleteRule) {\n        // implied constraints will have a null name and override getName()\n        this.name = name;\n        if (finerEnabled)\n            logger.finer(\"Adding foreign key constraint '\" + getName() + \"' to \" + child.getFullName());\n        childTable = child;\n        this.deleteRule = deleteRule;\n        this.updateRule = updateRule;\n    }\n\n    /**\n     * This constructor is intended for use <b>after</b> all of the tables have been\n     * found in the system.  One impact of using this constructor is that it will\n     * \"glue\" the two tables together through their columns.\n     *\n     * @param parentColumn\n     * @param childColumn\n     */\n    public ForeignKeyConstraint(TableColumn parentColumn, TableColumn childColumn, int updateRule, int deleteRule) {\n        this(childColumn.getTable(), null, updateRule, deleteRule);\n        addChildColumn(childColumn);\n        addParentColumn(parentColumn);\n        childColumn.addParent(parentColumn, this);\n        parentColumn.addChild(childColumn, this);\n    }\n\n    /**\n     * Same as {@link #ForeignKeyConstraint(TableColumn, TableColumn, int, int)},\n     * but defaults updateRule and deleteRule to\n     * {@link java.sql.DatabaseMetaData#importedKeyNoAction}.\n     *\n     * @param parentColumn\n     * @param childColumn\n     */\n    public ForeignKeyConstraint(TableColumn parentColumn, TableColumn childColumn) {\n        this(parentColumn, childColumn, importedKeyNoAction, importedKeyNoAction);\n    }\n\n    /**\n     * Add a \"parent\" side to the constraint.\n     *\n     * @param column\n     */\n    void addParentColumn(TableColumn column) {\n        if (column != null) {\n            parentColumns.add(column);\n            parentTable = column.getTable();\n        }\n    }\n\n    /**\n     * Add a \"child\" side to the constraint.\n     *\n     * @param column\n     */\n    void addChildColumn(TableColumn column) {\n        if (column != null) {\n            childColumns.add(column);\n        }\n    }\n\n    /**\n     * Returns the name of the constraint\n     *\n     * @return\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the parent table (the table that contains the referenced primary key\n     * column).\n     *\n     * @return\n     */\n    public Table getParentTable() {\n        return parentTable;\n    }\n\n    /**\n     * Returns all of the primary key columns that are referenced by this constraint.\n     *\n     * @return\n     */\n    public List<TableColumn> getParentColumns() {\n        return Collections.unmodifiableList(parentColumns);\n    }\n\n    /**\n     * Returns the table on the \"child\" end of the relationship (contains the foreign\n     * key that references the parent table's primary key).\n     *\n     * @return\n     */\n    public Table getChildTable() {\n        return childTable;\n    }\n\n    /**\n     * Returns all of the foreign key columns that are referenced by this constraint.\n     *\n     * @return\n     */\n    public List<TableColumn> getChildColumns() {\n        return Collections.unmodifiableList(childColumns);\n    }\n\n    /**\n     * Returns the delete rule for this constraint.\n     *\n     * @see {@link java.sql.DatabaseMetaData#importedKeyCascade}\n     */\n    public int getDeleteRule() {\n        return deleteRule;\n    }\n\n    /**\n     * Returns <code>true</code> if this constraint should\n     * <a href='http://en.wikipedia.org/wiki/Cascade_delete'>cascade deletions</code>.\n     *\n     * @return\n     */\n    public boolean isCascadeOnDelete() {\n        return getDeleteRule() == importedKeyCascade;\n    }\n\n    /**\n     * Returns <code>true</code> if the constraint prevents the parent table\n     * from being deleted if child tables exist.\n     *\n     * @return\n     */\n    public boolean isRestrictDelete() {\n        return getDeleteRule() == importedKeyNoAction || getDeleteRule() == importedKeyRestrict;\n    }\n\n    /**\n     * Returns <code>true</code> if the constraint indicates that the foreign key\n     * will be set to <code>null</code> when the parent key is deleted.\n     *\n     * @return\n     */\n    public boolean isNullOnDelete() {\n        return getDeleteRule() == importedKeySetNull;\n    }\n\n    public String getDeleteRuleName() {\n        switch(getDeleteRule()) {\n            case importedKeyCascade:\n                return \"Cascade on delete\";\n            case importedKeyRestrict:\n            case importedKeyNoAction:\n                return \"Restrict delete\";\n            case importedKeySetNull:\n                return \"Null on delete\";\n            default:\n                return \"\";\n        }\n    }\n\n    public String getDeleteRuleDescription() {\n        switch(getDeleteRule()) {\n            case importedKeyCascade:\n                return \"Cascade on delete:\\n Deletion of parent deletes child\";\n            case importedKeyRestrict:\n            case importedKeyNoAction:\n                return \"Restrict delete:\\n Parent cannot be deleted if children exist\";\n            case importedKeySetNull:\n                return \"Null on delete:\\n Foreign key to parent set to NULL when parent deleted\";\n            default:\n                return \"\";\n        }\n    }\n\n    public String getDeleteRuleAlias() {\n        switch(getDeleteRule()) {\n            case importedKeyCascade:\n                return \"C\";\n            case importedKeyRestrict:\n            case importedKeyNoAction:\n                return \"R\";\n            case importedKeySetNull:\n                return \"N\";\n            default:\n                return \"\";\n        }\n    }\n\n    /**\n     * Returns the update rule for this constraint.\n     *\n     * @see {@link java.sql.DatabaseMetaData#importedKeyCascade}\n     */\n    public int getUpdateRule() {\n        return updateRule;\n    }\n\n    /**\n     * Returns <code>true</code> if this is an implied constraint or\n     * <code>false</code> if it is \"real\".\n     *\n     * Subclasses that implement implied constraints should override this method.\n     *\n     * @return\n     */\n    public boolean isImplied() {\n        return false;\n    }\n\n    /**\n     * We have several types of constraints.\n     * This returns <code>true</code> if the constraint came from the database\n     * metadata and not inferred by something else.\n     * This is different than {@link #isImplied()} in that implied relationships\n     * are a specific type of non-real relationships.\n     *\n     * @return\n     */\n    public boolean isReal() {\n        return getClass() == ForeignKeyConstraint.class;\n    }\n\n    /**\n     * Custom comparison method to deal with foreign key names that aren't\n     * unique across all schemas being evaluated\n     *\n     * @param other ForeignKeyConstraint\n     *\n     * @return\n     */\n    public int compareTo(ForeignKeyConstraint other) {\n        if (other == this)\n            return 0;\n        int rc = getName().compareToIgnoreCase(other.getName());\n        if (rc == 0) {\n            // should only get here if we're dealing with cross-schema references (rare)\n            String ours = getChildColumns().get(0).getTable().getContainer();\n            String theirs = other.getChildColumns().get(0).getTable().getContainer();\n            if (ours != null && theirs != null)\n                rc = ours.compareToIgnoreCase(theirs);\n            else if (ours == null)\n                rc = -1;\n            else\n                rc = 1;\n        }\n        return rc;\n    }\n\n    /**\n     * Static method that returns a string representation of the specified\n     * list of {@link TableColumn columns}.\n     *\n     * @param columns\n     * @return\n     */\n    public static String toString(List<TableColumn> columns) {\n        if (columns.size() == 1)\n            return columns.iterator().next().toString();\n        return columns.toString();\n    }\n\n    /**\n     * Returns a string representation of this foreign key constraint.\n     *\n     * @return\n     */\n    @Override\n    public String toString() {\n        StringBuilder buf = new StringBuilder();\n        buf.append(childTable.getName());\n        buf.append('.');\n        buf.append(toString(childColumns));\n        buf.append(\" references \");\n        if (parentTable.isRemote()) {\n            buf.append(parentTable.getContainer());\n            buf.append('.');\n        }\n        buf.append(parentTable.getName());\n        buf.append('.');\n        buf.append(toString(parentColumns));\n        if (name != null) {\n            buf.append(\" via \");\n            buf.append(name);\n        }\n        return buf.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/ForeignKeyConstraintTest1.java",
		"test_prompt": "// ForeignKeyConstraintTest1.java\npackage net.sourceforge.schemaspy.model;\n\nimport static java.sql.DatabaseMetaData.importedKeyCascade;\nimport static java.sql.DatabaseMetaData.importedKeyNoAction;\nimport static java.sql.DatabaseMetaData.importedKeyRestrict;\nimport static java.sql.DatabaseMetaData.importedKeySetNull;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ForeignKeyConstraint}.\n* It contains ten unit test cases for the {@link ForeignKeyConstraint#isRestrictDelete()} method.\n*/\nclass ForeignKeyConstraintTest1 {"
	},
	{
		"original_code": "// ForeignKeyConstraint.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport static java.sql.DatabaseMetaData.importedKeyCascade;\nimport static java.sql.DatabaseMetaData.importedKeyNoAction;\nimport static java.sql.DatabaseMetaData.importedKeyRestrict;\nimport static java.sql.DatabaseMetaData.importedKeySetNull;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Represents a <a href='http://en.wikipedia.org/wiki/Foreign_key'>\n * Foreign Key Constraint</a> that \"ties\" a child table to a parent table\n * via foreign and primary keys.\n */\npublic class ForeignKeyConstraint implements Comparable<ForeignKeyConstraint> {\n\n    private final String name;\n\n    private Table parentTable;\n\n    private final List<TableColumn> parentColumns = new ArrayList<TableColumn>();\n\n    private final Table childTable;\n\n    private final List<TableColumn> childColumns = new ArrayList<TableColumn>();\n\n    private final int deleteRule;\n\n    private final int updateRule;\n\n    private final static Logger logger = Logger.getLogger(ForeignKeyConstraint.class.getName());\n\n    private final static boolean finerEnabled = logger.isLoggable(Level.FINER);\n\n    /**\n     * Construct a foreign key for the specified child table.\n     * Relationship details will be added later.\n     *\n     * @param child\n     * @param name\n     * @param deleteRule\n     */\n    ForeignKeyConstraint(Table child, String name, int updateRule, int deleteRule) {\n        // implied constraints will have a null name and override getName()\n        this.name = name;\n        if (finerEnabled)\n            logger.finer(\"Adding foreign key constraint '\" + getName() + \"' to \" + child.getFullName());\n        childTable = child;\n        this.deleteRule = deleteRule;\n        this.updateRule = updateRule;\n    }\n\n    /**\n     * This constructor is intended for use <b>after</b> all of the tables have been\n     * found in the system.  One impact of using this constructor is that it will\n     * \"glue\" the two tables together through their columns.\n     *\n     * @param parentColumn\n     * @param childColumn\n     */\n    public ForeignKeyConstraint(TableColumn parentColumn, TableColumn childColumn, int updateRule, int deleteRule) {\n        this(childColumn.getTable(), null, updateRule, deleteRule);\n        addChildColumn(childColumn);\n        addParentColumn(parentColumn);\n        childColumn.addParent(parentColumn, this);\n        parentColumn.addChild(childColumn, this);\n    }\n\n    /**\n     * Same as {@link #ForeignKeyConstraint(TableColumn, TableColumn, int, int)},\n     * but defaults updateRule and deleteRule to\n     * {@link java.sql.DatabaseMetaData#importedKeyNoAction}.\n     *\n     * @param parentColumn\n     * @param childColumn\n     */\n    public ForeignKeyConstraint(TableColumn parentColumn, TableColumn childColumn) {\n        this(parentColumn, childColumn, importedKeyNoAction, importedKeyNoAction);\n    }\n\n    /**\n     * Add a \"parent\" side to the constraint.\n     *\n     * @param column\n     */\n    void addParentColumn(TableColumn column) {\n        if (column != null) {\n            parentColumns.add(column);\n            parentTable = column.getTable();\n        }\n    }\n\n    /**\n     * Add a \"child\" side to the constraint.\n     *\n     * @param column\n     */\n    void addChildColumn(TableColumn column) {\n        if (column != null) {\n            childColumns.add(column);\n        }\n    }\n\n    /**\n     * Returns the name of the constraint\n     *\n     * @return\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the parent table (the table that contains the referenced primary key\n     * column).\n     *\n     * @return\n     */\n    public Table getParentTable() {\n        return parentTable;\n    }\n\n    /**\n     * Returns all of the primary key columns that are referenced by this constraint.\n     *\n     * @return\n     */\n    public List<TableColumn> getParentColumns() {\n        return Collections.unmodifiableList(parentColumns);\n    }\n\n    /**\n     * Returns the table on the \"child\" end of the relationship (contains the foreign\n     * key that references the parent table's primary key).\n     *\n     * @return\n     */\n    public Table getChildTable() {\n        return childTable;\n    }\n\n    /**\n     * Returns all of the foreign key columns that are referenced by this constraint.\n     *\n     * @return\n     */\n    public List<TableColumn> getChildColumns() {\n        return Collections.unmodifiableList(childColumns);\n    }\n\n    /**\n     * Returns the delete rule for this constraint.\n     *\n     * @see {@link java.sql.DatabaseMetaData#importedKeyCascade}\n     */\n    public int getDeleteRule() {\n        return deleteRule;\n    }\n\n    /**\n     * Returns <code>true</code> if this constraint should\n     * <a href='http://en.wikipedia.org/wiki/Cascade_delete'>cascade deletions</code>.\n     *\n     * @return\n     */\n    public boolean isCascadeOnDelete() {\n        return getDeleteRule() == importedKeyCascade;\n    }\n\n    /**\n     * Returns <code>true</code> if the constraint prevents the parent table\n     * from being deleted if child tables exist.\n     *\n     * @return\n     */\n    public boolean isRestrictDelete() {\n        return getDeleteRule() == importedKeyNoAction || getDeleteRule() == importedKeyRestrict;\n    }\n\n    /**\n     * Returns <code>true</code> if the constraint indicates that the foreign key\n     * will be set to <code>null</code> when the parent key is deleted.\n     *\n     * @return\n     */\n    public boolean isNullOnDelete() {\n        return getDeleteRule() == importedKeySetNull;\n    }\n\n    public String getDeleteRuleName() {\n        switch(getDeleteRule()) {\n            case importedKeyCascade:\n                return \"Cascade on delete\";\n            case importedKeyRestrict:\n            case importedKeyNoAction:\n                return \"Restrict delete\";\n            case importedKeySetNull:\n                return \"Null on delete\";\n            default:\n                return \"\";\n        }\n    }\n\n    public String getDeleteRuleDescription() {\n        switch(getDeleteRule()) {\n            case importedKeyCascade:\n                return \"Cascade on delete:\\n Deletion of parent deletes child\";\n            case importedKeyRestrict:\n            case importedKeyNoAction:\n                return \"Restrict delete:\\n Parent cannot be deleted if children exist\";\n            case importedKeySetNull:\n                return \"Null on delete:\\n Foreign key to parent set to NULL when parent deleted\";\n            default:\n                return \"\";\n        }\n    }\n\n    public String getDeleteRuleAlias() {\n        switch(getDeleteRule()) {\n            case importedKeyCascade:\n                return \"C\";\n            case importedKeyRestrict:\n            case importedKeyNoAction:\n                return \"R\";\n            case importedKeySetNull:\n                return \"N\";\n            default:\n                return \"\";\n        }\n    }\n\n    /**\n     * Returns the update rule for this constraint.\n     *\n     * @see {@link java.sql.DatabaseMetaData#importedKeyCascade}\n     */\n    public int getUpdateRule() {\n        return updateRule;\n    }\n\n    /**\n     * Returns <code>true</code> if this is an implied constraint or\n     * <code>false</code> if it is \"real\".\n     *\n     * Subclasses that implement implied constraints should override this method.\n     *\n     * @return\n     */\n    public boolean isImplied() {\n        return false;\n    }\n\n    /**\n     * We have several types of constraints.\n     * This returns <code>true</code> if the constraint came from the database\n     * metadata and not inferred by something else.\n     * This is different than {@link #isImplied()} in that implied relationships\n     * are a specific type of non-real relationships.\n     *\n     * @return\n     */\n    public boolean isReal() {\n        return getClass() == ForeignKeyConstraint.class;\n    }\n\n    /**\n     * Custom comparison method to deal with foreign key names that aren't\n     * unique across all schemas being evaluated\n     *\n     * @param other ForeignKeyConstraint\n     *\n     * @return\n     */\n    public int compareTo(ForeignKeyConstraint other) {\n        if (other == this)\n            return 0;\n        int rc = getName().compareToIgnoreCase(other.getName());\n        if (rc == 0) {\n            // should only get here if we're dealing with cross-schema references (rare)\n            String ours = getChildColumns().get(0).getTable().getContainer();\n            String theirs = other.getChildColumns().get(0).getTable().getContainer();\n            if (ours != null && theirs != null)\n                rc = ours.compareToIgnoreCase(theirs);\n            else if (ours == null)\n                rc = -1;\n            else\n                rc = 1;\n        }\n        return rc;\n    }\n\n    /**\n     * Static method that returns a string representation of the specified\n     * list of {@link TableColumn columns}.\n     *\n     * @param columns\n     * @return\n     */\n    public static String toString(List<TableColumn> columns) {\n        if (columns.size() == 1)\n            return columns.iterator().next().toString();\n        return columns.toString();\n    }\n\n    /**\n     * Returns a string representation of this foreign key constraint.\n     *\n     * @return\n     */\n    @Override\n    public String toString() {\n        StringBuilder buf = new StringBuilder();\n        buf.append(childTable.getName());\n        buf.append('.');\n        buf.append(toString(childColumns));\n        buf.append(\" references \");\n        if (parentTable.isRemote()) {\n            buf.append(parentTable.getContainer());\n            buf.append('.');\n        }\n        buf.append(parentTable.getName());\n        buf.append('.');\n        buf.append(toString(parentColumns));\n        if (name != null) {\n            buf.append(\" via \");\n            buf.append(name);\n        }\n        return buf.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/ForeignKeyConstraintTest2.java",
		"test_prompt": "// ForeignKeyConstraintTest2.java\npackage net.sourceforge.schemaspy.model;\n\nimport static java.sql.DatabaseMetaData.importedKeyCascade;\nimport static java.sql.DatabaseMetaData.importedKeyNoAction;\nimport static java.sql.DatabaseMetaData.importedKeyRestrict;\nimport static java.sql.DatabaseMetaData.importedKeySetNull;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ForeignKeyConstraint}.\n* It contains ten unit test cases for the {@link ForeignKeyConstraint#isNullOnDelete()} method.\n*/\nclass ForeignKeyConstraintTest2 {"
	},
	{
		"original_code": "// ForeignKeyConstraint.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport static java.sql.DatabaseMetaData.importedKeyCascade;\nimport static java.sql.DatabaseMetaData.importedKeyNoAction;\nimport static java.sql.DatabaseMetaData.importedKeyRestrict;\nimport static java.sql.DatabaseMetaData.importedKeySetNull;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Represents a <a href='http://en.wikipedia.org/wiki/Foreign_key'>\n * Foreign Key Constraint</a> that \"ties\" a child table to a parent table\n * via foreign and primary keys.\n */\npublic class ForeignKeyConstraint implements Comparable<ForeignKeyConstraint> {\n\n    private final String name;\n\n    private Table parentTable;\n\n    private final List<TableColumn> parentColumns = new ArrayList<TableColumn>();\n\n    private final Table childTable;\n\n    private final List<TableColumn> childColumns = new ArrayList<TableColumn>();\n\n    private final int deleteRule;\n\n    private final int updateRule;\n\n    private final static Logger logger = Logger.getLogger(ForeignKeyConstraint.class.getName());\n\n    private final static boolean finerEnabled = logger.isLoggable(Level.FINER);\n\n    /**\n     * Construct a foreign key for the specified child table.\n     * Relationship details will be added later.\n     *\n     * @param child\n     * @param name\n     * @param deleteRule\n     */\n    ForeignKeyConstraint(Table child, String name, int updateRule, int deleteRule) {\n        // implied constraints will have a null name and override getName()\n        this.name = name;\n        if (finerEnabled)\n            logger.finer(\"Adding foreign key constraint '\" + getName() + \"' to \" + child.getFullName());\n        childTable = child;\n        this.deleteRule = deleteRule;\n        this.updateRule = updateRule;\n    }\n\n    /**\n     * This constructor is intended for use <b>after</b> all of the tables have been\n     * found in the system.  One impact of using this constructor is that it will\n     * \"glue\" the two tables together through their columns.\n     *\n     * @param parentColumn\n     * @param childColumn\n     */\n    public ForeignKeyConstraint(TableColumn parentColumn, TableColumn childColumn, int updateRule, int deleteRule) {\n        this(childColumn.getTable(), null, updateRule, deleteRule);\n        addChildColumn(childColumn);\n        addParentColumn(parentColumn);\n        childColumn.addParent(parentColumn, this);\n        parentColumn.addChild(childColumn, this);\n    }\n\n    /**\n     * Same as {@link #ForeignKeyConstraint(TableColumn, TableColumn, int, int)},\n     * but defaults updateRule and deleteRule to\n     * {@link java.sql.DatabaseMetaData#importedKeyNoAction}.\n     *\n     * @param parentColumn\n     * @param childColumn\n     */\n    public ForeignKeyConstraint(TableColumn parentColumn, TableColumn childColumn) {\n        this(parentColumn, childColumn, importedKeyNoAction, importedKeyNoAction);\n    }\n\n    /**\n     * Add a \"parent\" side to the constraint.\n     *\n     * @param column\n     */\n    void addParentColumn(TableColumn column) {\n        if (column != null) {\n            parentColumns.add(column);\n            parentTable = column.getTable();\n        }\n    }\n\n    /**\n     * Add a \"child\" side to the constraint.\n     *\n     * @param column\n     */\n    void addChildColumn(TableColumn column) {\n        if (column != null) {\n            childColumns.add(column);\n        }\n    }\n\n    /**\n     * Returns the name of the constraint\n     *\n     * @return\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the parent table (the table that contains the referenced primary key\n     * column).\n     *\n     * @return\n     */\n    public Table getParentTable() {\n        return parentTable;\n    }\n\n    /**\n     * Returns all of the primary key columns that are referenced by this constraint.\n     *\n     * @return\n     */\n    public List<TableColumn> getParentColumns() {\n        return Collections.unmodifiableList(parentColumns);\n    }\n\n    /**\n     * Returns the table on the \"child\" end of the relationship (contains the foreign\n     * key that references the parent table's primary key).\n     *\n     * @return\n     */\n    public Table getChildTable() {\n        return childTable;\n    }\n\n    /**\n     * Returns all of the foreign key columns that are referenced by this constraint.\n     *\n     * @return\n     */\n    public List<TableColumn> getChildColumns() {\n        return Collections.unmodifiableList(childColumns);\n    }\n\n    /**\n     * Returns the delete rule for this constraint.\n     *\n     * @see {@link java.sql.DatabaseMetaData#importedKeyCascade}\n     */\n    public int getDeleteRule() {\n        return deleteRule;\n    }\n\n    /**\n     * Returns <code>true</code> if this constraint should\n     * <a href='http://en.wikipedia.org/wiki/Cascade_delete'>cascade deletions</code>.\n     *\n     * @return\n     */\n    public boolean isCascadeOnDelete() {\n        return getDeleteRule() == importedKeyCascade;\n    }\n\n    /**\n     * Returns <code>true</code> if the constraint prevents the parent table\n     * from being deleted if child tables exist.\n     *\n     * @return\n     */\n    public boolean isRestrictDelete() {\n        return getDeleteRule() == importedKeyNoAction || getDeleteRule() == importedKeyRestrict;\n    }\n\n    /**\n     * Returns <code>true</code> if the constraint indicates that the foreign key\n     * will be set to <code>null</code> when the parent key is deleted.\n     *\n     * @return\n     */\n    public boolean isNullOnDelete() {\n        return getDeleteRule() == importedKeySetNull;\n    }\n\n    public String getDeleteRuleName() {\n        switch(getDeleteRule()) {\n            case importedKeyCascade:\n                return \"Cascade on delete\";\n            case importedKeyRestrict:\n            case importedKeyNoAction:\n                return \"Restrict delete\";\n            case importedKeySetNull:\n                return \"Null on delete\";\n            default:\n                return \"\";\n        }\n    }\n\n    public String getDeleteRuleDescription() {\n        switch(getDeleteRule()) {\n            case importedKeyCascade:\n                return \"Cascade on delete:\\n Deletion of parent deletes child\";\n            case importedKeyRestrict:\n            case importedKeyNoAction:\n                return \"Restrict delete:\\n Parent cannot be deleted if children exist\";\n            case importedKeySetNull:\n                return \"Null on delete:\\n Foreign key to parent set to NULL when parent deleted\";\n            default:\n                return \"\";\n        }\n    }\n\n    public String getDeleteRuleAlias() {\n        switch(getDeleteRule()) {\n            case importedKeyCascade:\n                return \"C\";\n            case importedKeyRestrict:\n            case importedKeyNoAction:\n                return \"R\";\n            case importedKeySetNull:\n                return \"N\";\n            default:\n                return \"\";\n        }\n    }\n\n    /**\n     * Returns the update rule for this constraint.\n     *\n     * @see {@link java.sql.DatabaseMetaData#importedKeyCascade}\n     */\n    public int getUpdateRule() {\n        return updateRule;\n    }\n\n    /**\n     * Returns <code>true</code> if this is an implied constraint or\n     * <code>false</code> if it is \"real\".\n     *\n     * Subclasses that implement implied constraints should override this method.\n     *\n     * @return\n     */\n    public boolean isImplied() {\n        return false;\n    }\n\n    /**\n     * We have several types of constraints.\n     * This returns <code>true</code> if the constraint came from the database\n     * metadata and not inferred by something else.\n     * This is different than {@link #isImplied()} in that implied relationships\n     * are a specific type of non-real relationships.\n     *\n     * @return\n     */\n    public boolean isReal() {\n        return getClass() == ForeignKeyConstraint.class;\n    }\n\n    /**\n     * Custom comparison method to deal with foreign key names that aren't\n     * unique across all schemas being evaluated\n     *\n     * @param other ForeignKeyConstraint\n     *\n     * @return\n     */\n    public int compareTo(ForeignKeyConstraint other) {\n        if (other == this)\n            return 0;\n        int rc = getName().compareToIgnoreCase(other.getName());\n        if (rc == 0) {\n            // should only get here if we're dealing with cross-schema references (rare)\n            String ours = getChildColumns().get(0).getTable().getContainer();\n            String theirs = other.getChildColumns().get(0).getTable().getContainer();\n            if (ours != null && theirs != null)\n                rc = ours.compareToIgnoreCase(theirs);\n            else if (ours == null)\n                rc = -1;\n            else\n                rc = 1;\n        }\n        return rc;\n    }\n\n    /**\n     * Static method that returns a string representation of the specified\n     * list of {@link TableColumn columns}.\n     *\n     * @param columns\n     * @return\n     */\n    public static String toString(List<TableColumn> columns) {\n        if (columns.size() == 1)\n            return columns.iterator().next().toString();\n        return columns.toString();\n    }\n\n    /**\n     * Returns a string representation of this foreign key constraint.\n     *\n     * @return\n     */\n    @Override\n    public String toString() {\n        StringBuilder buf = new StringBuilder();\n        buf.append(childTable.getName());\n        buf.append('.');\n        buf.append(toString(childColumns));\n        buf.append(\" references \");\n        if (parentTable.isRemote()) {\n            buf.append(parentTable.getContainer());\n            buf.append('.');\n        }\n        buf.append(parentTable.getName());\n        buf.append('.');\n        buf.append(toString(parentColumns));\n        if (name != null) {\n            buf.append(\" via \");\n            buf.append(name);\n        }\n        return buf.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/ForeignKeyConstraintTest3.java",
		"test_prompt": "// ForeignKeyConstraintTest3.java\npackage net.sourceforge.schemaspy.model;\n\nimport static java.sql.DatabaseMetaData.importedKeyCascade;\nimport static java.sql.DatabaseMetaData.importedKeyNoAction;\nimport static java.sql.DatabaseMetaData.importedKeyRestrict;\nimport static java.sql.DatabaseMetaData.importedKeySetNull;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ForeignKeyConstraint}.\n* It contains ten unit test cases for the {@link ForeignKeyConstraint#isImplied()} method.\n*/\nclass ForeignKeyConstraintTest3 {"
	},
	{
		"original_code": "// ForeignKeyConstraint.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport static java.sql.DatabaseMetaData.importedKeyCascade;\nimport static java.sql.DatabaseMetaData.importedKeyNoAction;\nimport static java.sql.DatabaseMetaData.importedKeyRestrict;\nimport static java.sql.DatabaseMetaData.importedKeySetNull;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Represents a <a href='http://en.wikipedia.org/wiki/Foreign_key'>\n * Foreign Key Constraint</a> that \"ties\" a child table to a parent table\n * via foreign and primary keys.\n */\npublic class ForeignKeyConstraint implements Comparable<ForeignKeyConstraint> {\n\n    private final String name;\n\n    private Table parentTable;\n\n    private final List<TableColumn> parentColumns = new ArrayList<TableColumn>();\n\n    private final Table childTable;\n\n    private final List<TableColumn> childColumns = new ArrayList<TableColumn>();\n\n    private final int deleteRule;\n\n    private final int updateRule;\n\n    private final static Logger logger = Logger.getLogger(ForeignKeyConstraint.class.getName());\n\n    private final static boolean finerEnabled = logger.isLoggable(Level.FINER);\n\n    /**\n     * Construct a foreign key for the specified child table.\n     * Relationship details will be added later.\n     *\n     * @param child\n     * @param name\n     * @param deleteRule\n     */\n    ForeignKeyConstraint(Table child, String name, int updateRule, int deleteRule) {\n        // implied constraints will have a null name and override getName()\n        this.name = name;\n        if (finerEnabled)\n            logger.finer(\"Adding foreign key constraint '\" + getName() + \"' to \" + child.getFullName());\n        childTable = child;\n        this.deleteRule = deleteRule;\n        this.updateRule = updateRule;\n    }\n\n    /**\n     * This constructor is intended for use <b>after</b> all of the tables have been\n     * found in the system.  One impact of using this constructor is that it will\n     * \"glue\" the two tables together through their columns.\n     *\n     * @param parentColumn\n     * @param childColumn\n     */\n    public ForeignKeyConstraint(TableColumn parentColumn, TableColumn childColumn, int updateRule, int deleteRule) {\n        this(childColumn.getTable(), null, updateRule, deleteRule);\n        addChildColumn(childColumn);\n        addParentColumn(parentColumn);\n        childColumn.addParent(parentColumn, this);\n        parentColumn.addChild(childColumn, this);\n    }\n\n    /**\n     * Same as {@link #ForeignKeyConstraint(TableColumn, TableColumn, int, int)},\n     * but defaults updateRule and deleteRule to\n     * {@link java.sql.DatabaseMetaData#importedKeyNoAction}.\n     *\n     * @param parentColumn\n     * @param childColumn\n     */\n    public ForeignKeyConstraint(TableColumn parentColumn, TableColumn childColumn) {\n        this(parentColumn, childColumn, importedKeyNoAction, importedKeyNoAction);\n    }\n\n    /**\n     * Add a \"parent\" side to the constraint.\n     *\n     * @param column\n     */\n    void addParentColumn(TableColumn column) {\n        if (column != null) {\n            parentColumns.add(column);\n            parentTable = column.getTable();\n        }\n    }\n\n    /**\n     * Add a \"child\" side to the constraint.\n     *\n     * @param column\n     */\n    void addChildColumn(TableColumn column) {\n        if (column != null) {\n            childColumns.add(column);\n        }\n    }\n\n    /**\n     * Returns the name of the constraint\n     *\n     * @return\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the parent table (the table that contains the referenced primary key\n     * column).\n     *\n     * @return\n     */\n    public Table getParentTable() {\n        return parentTable;\n    }\n\n    /**\n     * Returns all of the primary key columns that are referenced by this constraint.\n     *\n     * @return\n     */\n    public List<TableColumn> getParentColumns() {\n        return Collections.unmodifiableList(parentColumns);\n    }\n\n    /**\n     * Returns the table on the \"child\" end of the relationship (contains the foreign\n     * key that references the parent table's primary key).\n     *\n     * @return\n     */\n    public Table getChildTable() {\n        return childTable;\n    }\n\n    /**\n     * Returns all of the foreign key columns that are referenced by this constraint.\n     *\n     * @return\n     */\n    public List<TableColumn> getChildColumns() {\n        return Collections.unmodifiableList(childColumns);\n    }\n\n    /**\n     * Returns the delete rule for this constraint.\n     *\n     * @see {@link java.sql.DatabaseMetaData#importedKeyCascade}\n     */\n    public int getDeleteRule() {\n        return deleteRule;\n    }\n\n    /**\n     * Returns <code>true</code> if this constraint should\n     * <a href='http://en.wikipedia.org/wiki/Cascade_delete'>cascade deletions</code>.\n     *\n     * @return\n     */\n    public boolean isCascadeOnDelete() {\n        return getDeleteRule() == importedKeyCascade;\n    }\n\n    /**\n     * Returns <code>true</code> if the constraint prevents the parent table\n     * from being deleted if child tables exist.\n     *\n     * @return\n     */\n    public boolean isRestrictDelete() {\n        return getDeleteRule() == importedKeyNoAction || getDeleteRule() == importedKeyRestrict;\n    }\n\n    /**\n     * Returns <code>true</code> if the constraint indicates that the foreign key\n     * will be set to <code>null</code> when the parent key is deleted.\n     *\n     * @return\n     */\n    public boolean isNullOnDelete() {\n        return getDeleteRule() == importedKeySetNull;\n    }\n\n    public String getDeleteRuleName() {\n        switch(getDeleteRule()) {\n            case importedKeyCascade:\n                return \"Cascade on delete\";\n            case importedKeyRestrict:\n            case importedKeyNoAction:\n                return \"Restrict delete\";\n            case importedKeySetNull:\n                return \"Null on delete\";\n            default:\n                return \"\";\n        }\n    }\n\n    public String getDeleteRuleDescription() {\n        switch(getDeleteRule()) {\n            case importedKeyCascade:\n                return \"Cascade on delete:\\n Deletion of parent deletes child\";\n            case importedKeyRestrict:\n            case importedKeyNoAction:\n                return \"Restrict delete:\\n Parent cannot be deleted if children exist\";\n            case importedKeySetNull:\n                return \"Null on delete:\\n Foreign key to parent set to NULL when parent deleted\";\n            default:\n                return \"\";\n        }\n    }\n\n    public String getDeleteRuleAlias() {\n        switch(getDeleteRule()) {\n            case importedKeyCascade:\n                return \"C\";\n            case importedKeyRestrict:\n            case importedKeyNoAction:\n                return \"R\";\n            case importedKeySetNull:\n                return \"N\";\n            default:\n                return \"\";\n        }\n    }\n\n    /**\n     * Returns the update rule for this constraint.\n     *\n     * @see {@link java.sql.DatabaseMetaData#importedKeyCascade}\n     */\n    public int getUpdateRule() {\n        return updateRule;\n    }\n\n    /**\n     * Returns <code>true</code> if this is an implied constraint or\n     * <code>false</code> if it is \"real\".\n     *\n     * Subclasses that implement implied constraints should override this method.\n     *\n     * @return\n     */\n    public boolean isImplied() {\n        return false;\n    }\n\n    /**\n     * We have several types of constraints.\n     * This returns <code>true</code> if the constraint came from the database\n     * metadata and not inferred by something else.\n     * This is different than {@link #isImplied()} in that implied relationships\n     * are a specific type of non-real relationships.\n     *\n     * @return\n     */\n    public boolean isReal() {\n        return getClass() == ForeignKeyConstraint.class;\n    }\n\n    /**\n     * Custom comparison method to deal with foreign key names that aren't\n     * unique across all schemas being evaluated\n     *\n     * @param other ForeignKeyConstraint\n     *\n     * @return\n     */\n    public int compareTo(ForeignKeyConstraint other) {\n        if (other == this)\n            return 0;\n        int rc = getName().compareToIgnoreCase(other.getName());\n        if (rc == 0) {\n            // should only get here if we're dealing with cross-schema references (rare)\n            String ours = getChildColumns().get(0).getTable().getContainer();\n            String theirs = other.getChildColumns().get(0).getTable().getContainer();\n            if (ours != null && theirs != null)\n                rc = ours.compareToIgnoreCase(theirs);\n            else if (ours == null)\n                rc = -1;\n            else\n                rc = 1;\n        }\n        return rc;\n    }\n\n    /**\n     * Static method that returns a string representation of the specified\n     * list of {@link TableColumn columns}.\n     *\n     * @param columns\n     * @return\n     */\n    public static String toString(List<TableColumn> columns) {\n        if (columns.size() == 1)\n            return columns.iterator().next().toString();\n        return columns.toString();\n    }\n\n    /**\n     * Returns a string representation of this foreign key constraint.\n     *\n     * @return\n     */\n    @Override\n    public String toString() {\n        StringBuilder buf = new StringBuilder();\n        buf.append(childTable.getName());\n        buf.append('.');\n        buf.append(toString(childColumns));\n        buf.append(\" references \");\n        if (parentTable.isRemote()) {\n            buf.append(parentTable.getContainer());\n            buf.append('.');\n        }\n        buf.append(parentTable.getName());\n        buf.append('.');\n        buf.append(toString(parentColumns));\n        if (name != null) {\n            buf.append(\" via \");\n            buf.append(name);\n        }\n        return buf.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/ForeignKeyConstraintTest4.java",
		"test_prompt": "// ForeignKeyConstraintTest4.java\npackage net.sourceforge.schemaspy.model;\n\nimport static java.sql.DatabaseMetaData.importedKeyCascade;\nimport static java.sql.DatabaseMetaData.importedKeyNoAction;\nimport static java.sql.DatabaseMetaData.importedKeyRestrict;\nimport static java.sql.DatabaseMetaData.importedKeySetNull;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ForeignKeyConstraint}.\n* It contains ten unit test cases for the {@link ForeignKeyConstraint#isReal()} method.\n*/\nclass ForeignKeyConstraintTest4 {"
	},
	{
		"original_code": "// ForeignKeyConstraint.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport static java.sql.DatabaseMetaData.importedKeyCascade;\nimport static java.sql.DatabaseMetaData.importedKeyNoAction;\nimport static java.sql.DatabaseMetaData.importedKeyRestrict;\nimport static java.sql.DatabaseMetaData.importedKeySetNull;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Represents a <a href='http://en.wikipedia.org/wiki/Foreign_key'>\n * Foreign Key Constraint</a> that \"ties\" a child table to a parent table\n * via foreign and primary keys.\n */\npublic class ForeignKeyConstraint implements Comparable<ForeignKeyConstraint> {\n\n    private final String name;\n\n    private Table parentTable;\n\n    private final List<TableColumn> parentColumns = new ArrayList<TableColumn>();\n\n    private final Table childTable;\n\n    private final List<TableColumn> childColumns = new ArrayList<TableColumn>();\n\n    private final int deleteRule;\n\n    private final int updateRule;\n\n    private final static Logger logger = Logger.getLogger(ForeignKeyConstraint.class.getName());\n\n    private final static boolean finerEnabled = logger.isLoggable(Level.FINER);\n\n    /**\n     * Construct a foreign key for the specified child table.\n     * Relationship details will be added later.\n     *\n     * @param child\n     * @param name\n     * @param deleteRule\n     */\n    ForeignKeyConstraint(Table child, String name, int updateRule, int deleteRule) {\n        // implied constraints will have a null name and override getName()\n        this.name = name;\n        if (finerEnabled)\n            logger.finer(\"Adding foreign key constraint '\" + getName() + \"' to \" + child.getFullName());\n        childTable = child;\n        this.deleteRule = deleteRule;\n        this.updateRule = updateRule;\n    }\n\n    /**\n     * This constructor is intended for use <b>after</b> all of the tables have been\n     * found in the system.  One impact of using this constructor is that it will\n     * \"glue\" the two tables together through their columns.\n     *\n     * @param parentColumn\n     * @param childColumn\n     */\n    public ForeignKeyConstraint(TableColumn parentColumn, TableColumn childColumn, int updateRule, int deleteRule) {\n        this(childColumn.getTable(), null, updateRule, deleteRule);\n        addChildColumn(childColumn);\n        addParentColumn(parentColumn);\n        childColumn.addParent(parentColumn, this);\n        parentColumn.addChild(childColumn, this);\n    }\n\n    /**\n     * Same as {@link #ForeignKeyConstraint(TableColumn, TableColumn, int, int)},\n     * but defaults updateRule and deleteRule to\n     * {@link java.sql.DatabaseMetaData#importedKeyNoAction}.\n     *\n     * @param parentColumn\n     * @param childColumn\n     */\n    public ForeignKeyConstraint(TableColumn parentColumn, TableColumn childColumn) {\n        this(parentColumn, childColumn, importedKeyNoAction, importedKeyNoAction);\n    }\n\n    /**\n     * Add a \"parent\" side to the constraint.\n     *\n     * @param column\n     */\n    void addParentColumn(TableColumn column) {\n        if (column != null) {\n            parentColumns.add(column);\n            parentTable = column.getTable();\n        }\n    }\n\n    /**\n     * Add a \"child\" side to the constraint.\n     *\n     * @param column\n     */\n    void addChildColumn(TableColumn column) {\n        if (column != null) {\n            childColumns.add(column);\n        }\n    }\n\n    /**\n     * Returns the name of the constraint\n     *\n     * @return\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the parent table (the table that contains the referenced primary key\n     * column).\n     *\n     * @return\n     */\n    public Table getParentTable() {\n        return parentTable;\n    }\n\n    /**\n     * Returns all of the primary key columns that are referenced by this constraint.\n     *\n     * @return\n     */\n    public List<TableColumn> getParentColumns() {\n        return Collections.unmodifiableList(parentColumns);\n    }\n\n    /**\n     * Returns the table on the \"child\" end of the relationship (contains the foreign\n     * key that references the parent table's primary key).\n     *\n     * @return\n     */\n    public Table getChildTable() {\n        return childTable;\n    }\n\n    /**\n     * Returns all of the foreign key columns that are referenced by this constraint.\n     *\n     * @return\n     */\n    public List<TableColumn> getChildColumns() {\n        return Collections.unmodifiableList(childColumns);\n    }\n\n    /**\n     * Returns the delete rule for this constraint.\n     *\n     * @see {@link java.sql.DatabaseMetaData#importedKeyCascade}\n     */\n    public int getDeleteRule() {\n        return deleteRule;\n    }\n\n    /**\n     * Returns <code>true</code> if this constraint should\n     * <a href='http://en.wikipedia.org/wiki/Cascade_delete'>cascade deletions</code>.\n     *\n     * @return\n     */\n    public boolean isCascadeOnDelete() {\n        return getDeleteRule() == importedKeyCascade;\n    }\n\n    /**\n     * Returns <code>true</code> if the constraint prevents the parent table\n     * from being deleted if child tables exist.\n     *\n     * @return\n     */\n    public boolean isRestrictDelete() {\n        return getDeleteRule() == importedKeyNoAction || getDeleteRule() == importedKeyRestrict;\n    }\n\n    /**\n     * Returns <code>true</code> if the constraint indicates that the foreign key\n     * will be set to <code>null</code> when the parent key is deleted.\n     *\n     * @return\n     */\n    public boolean isNullOnDelete() {\n        return getDeleteRule() == importedKeySetNull;\n    }\n\n    public String getDeleteRuleName() {\n        switch(getDeleteRule()) {\n            case importedKeyCascade:\n                return \"Cascade on delete\";\n            case importedKeyRestrict:\n            case importedKeyNoAction:\n                return \"Restrict delete\";\n            case importedKeySetNull:\n                return \"Null on delete\";\n            default:\n                return \"\";\n        }\n    }\n\n    public String getDeleteRuleDescription() {\n        switch(getDeleteRule()) {\n            case importedKeyCascade:\n                return \"Cascade on delete:\\n Deletion of parent deletes child\";\n            case importedKeyRestrict:\n            case importedKeyNoAction:\n                return \"Restrict delete:\\n Parent cannot be deleted if children exist\";\n            case importedKeySetNull:\n                return \"Null on delete:\\n Foreign key to parent set to NULL when parent deleted\";\n            default:\n                return \"\";\n        }\n    }\n\n    public String getDeleteRuleAlias() {\n        switch(getDeleteRule()) {\n            case importedKeyCascade:\n                return \"C\";\n            case importedKeyRestrict:\n            case importedKeyNoAction:\n                return \"R\";\n            case importedKeySetNull:\n                return \"N\";\n            default:\n                return \"\";\n        }\n    }\n\n    /**\n     * Returns the update rule for this constraint.\n     *\n     * @see {@link java.sql.DatabaseMetaData#importedKeyCascade}\n     */\n    public int getUpdateRule() {\n        return updateRule;\n    }\n\n    /**\n     * Returns <code>true</code> if this is an implied constraint or\n     * <code>false</code> if it is \"real\".\n     *\n     * Subclasses that implement implied constraints should override this method.\n     *\n     * @return\n     */\n    public boolean isImplied() {\n        return false;\n    }\n\n    /**\n     * We have several types of constraints.\n     * This returns <code>true</code> if the constraint came from the database\n     * metadata and not inferred by something else.\n     * This is different than {@link #isImplied()} in that implied relationships\n     * are a specific type of non-real relationships.\n     *\n     * @return\n     */\n    public boolean isReal() {\n        return getClass() == ForeignKeyConstraint.class;\n    }\n\n    /**\n     * Custom comparison method to deal with foreign key names that aren't\n     * unique across all schemas being evaluated\n     *\n     * @param other ForeignKeyConstraint\n     *\n     * @return\n     */\n    public int compareTo(ForeignKeyConstraint other) {\n        if (other == this)\n            return 0;\n        int rc = getName().compareToIgnoreCase(other.getName());\n        if (rc == 0) {\n            // should only get here if we're dealing with cross-schema references (rare)\n            String ours = getChildColumns().get(0).getTable().getContainer();\n            String theirs = other.getChildColumns().get(0).getTable().getContainer();\n            if (ours != null && theirs != null)\n                rc = ours.compareToIgnoreCase(theirs);\n            else if (ours == null)\n                rc = -1;\n            else\n                rc = 1;\n        }\n        return rc;\n    }\n\n    /**\n     * Static method that returns a string representation of the specified\n     * list of {@link TableColumn columns}.\n     *\n     * @param columns\n     * @return\n     */\n    public static String toString(List<TableColumn> columns) {\n        if (columns.size() == 1)\n            return columns.iterator().next().toString();\n        return columns.toString();\n    }\n\n    /**\n     * Returns a string representation of this foreign key constraint.\n     *\n     * @return\n     */\n    @Override\n    public String toString() {\n        StringBuilder buf = new StringBuilder();\n        buf.append(childTable.getName());\n        buf.append('.');\n        buf.append(toString(childColumns));\n        buf.append(\" references \");\n        if (parentTable.isRemote()) {\n            buf.append(parentTable.getContainer());\n            buf.append('.');\n        }\n        buf.append(parentTable.getName());\n        buf.append('.');\n        buf.append(toString(parentColumns));\n        if (name != null) {\n            buf.append(\" via \");\n            buf.append(name);\n        }\n        return buf.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/ForeignKeyConstraintTest5.java",
		"test_prompt": "// ForeignKeyConstraintTest5.java\npackage net.sourceforge.schemaspy.model;\n\nimport static java.sql.DatabaseMetaData.importedKeyCascade;\nimport static java.sql.DatabaseMetaData.importedKeyNoAction;\nimport static java.sql.DatabaseMetaData.importedKeyRestrict;\nimport static java.sql.DatabaseMetaData.importedKeySetNull;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ForeignKeyConstraint}.\n* It contains ten unit test cases for the {@link ForeignKeyConstraint#compareTo(ForeignKeyConstraint)} method.\n*/\nclass ForeignKeyConstraintTest5 {"
	},
	{
		"original_code": "// TableIndex.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class TableIndex implements Comparable<TableIndex> {\n\n    private final String name;\n\n    private final boolean isUnique;\n\n    private Object id;\n\n    private boolean isPrimary;\n\n    private final List<TableColumn> columns = new ArrayList<TableColumn>();\n\n    // for whether colums are ascending order\n    private final List<Boolean> columnsAscending = new ArrayList<Boolean>();\n\n    /**\n     * @param rs\n     * @throws java.sql.SQLException\n     */\n    public TableIndex(ResultSet rs) throws SQLException {\n        name = rs.getString(\"INDEX_NAME\");\n        isUnique = !rs.getBoolean(\"NON_UNIQUE\");\n    }\n\n    public void setId(Object id) {\n        this.id = id;\n    }\n\n    public Object getId() {\n        return id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    void addColumn(TableColumn column, String sortOrder) {\n        if (column != null) {\n            columns.add(column);\n            columnsAscending.add(Boolean.valueOf(sortOrder == null || sortOrder.equals(\"A\")));\n        }\n    }\n\n    /**\n     * @return\n     */\n    public String getType() {\n        if (isPrimaryKey())\n            return \"Primary key\";\n        if (isUnique())\n            return \"Must be unique\";\n        return \"Performance\";\n    }\n\n    /**\n     * @return\n     */\n    public boolean isPrimaryKey() {\n        return isPrimary;\n    }\n\n    /**\n     * @param isPrimaryKey\n     */\n    public void setIsPrimaryKey(boolean isPrimaryKey) {\n        isPrimary = isPrimaryKey;\n    }\n\n    /**\n     * @return\n     */\n    public boolean isUnique() {\n        return isUnique;\n    }\n\n    /**\n     * @return\n     */\n    public String getColumnsAsString() {\n        StringBuilder buf = new StringBuilder();\n        for (TableColumn column : columns) {\n            if (buf.length() > 0)\n                buf.append(\" + \");\n            buf.append(column);\n        }\n        return buf.toString();\n    }\n\n    public List<TableColumn> getColumns() {\n        return Collections.unmodifiableList(columns);\n    }\n\n    /**\n     * Yes, we had a project that had columns defined as both 'nullable' and 'must be unique'.\n     *\n     * @return boolean\n     */\n    public boolean isUniqueNullable() {\n        if (!isUnique())\n            return false;\n        // if all of the columns specified by the Unique Index are nullable\n        // then return true, otherwise false\n        boolean allNullable = true;\n        for (TableColumn column : getColumns()) {\n            allNullable = column != null && column.isNullable();\n            if (!allNullable)\n                break;\n        }\n        return allNullable;\n    }\n\n    /**\n     * @param column\n     * @return\n     */\n    public boolean isAscending(TableColumn column) {\n        return columnsAscending.get(columns.indexOf(column)).booleanValue();\n    }\n\n    /**\n     * @param object\n     * @return\n     */\n    public int compareTo(TableIndex other) {\n        if (isPrimaryKey() && !other.isPrimaryKey())\n            return -1;\n        if (!isPrimaryKey() && other.isPrimaryKey())\n            return 1;\n        Object thisId = getId();\n        Object otherId = other.getId();\n        if (thisId == null || otherId == null)\n            return getName().compareToIgnoreCase(other.getName());\n        if (thisId instanceof Number)\n            return ((Number) thisId).intValue() - ((Number) otherId).intValue();\n        return thisId.toString().compareToIgnoreCase(otherId.toString());\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableIndexTest0.java",
		"test_prompt": "// TableIndexTest0.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TableIndex}.\n* It contains ten unit test cases for the {@link TableIndex#isPrimaryKey()} method.\n*/\nclass TableIndexTest0 {"
	},
	{
		"original_code": "// TableIndex.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class TableIndex implements Comparable<TableIndex> {\n\n    private final String name;\n\n    private final boolean isUnique;\n\n    private Object id;\n\n    private boolean isPrimary;\n\n    private final List<TableColumn> columns = new ArrayList<TableColumn>();\n\n    // for whether colums are ascending order\n    private final List<Boolean> columnsAscending = new ArrayList<Boolean>();\n\n    /**\n     * @param rs\n     * @throws java.sql.SQLException\n     */\n    public TableIndex(ResultSet rs) throws SQLException {\n        name = rs.getString(\"INDEX_NAME\");\n        isUnique = !rs.getBoolean(\"NON_UNIQUE\");\n    }\n\n    public void setId(Object id) {\n        this.id = id;\n    }\n\n    public Object getId() {\n        return id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    void addColumn(TableColumn column, String sortOrder) {\n        if (column != null) {\n            columns.add(column);\n            columnsAscending.add(Boolean.valueOf(sortOrder == null || sortOrder.equals(\"A\")));\n        }\n    }\n\n    /**\n     * @return\n     */\n    public String getType() {\n        if (isPrimaryKey())\n            return \"Primary key\";\n        if (isUnique())\n            return \"Must be unique\";\n        return \"Performance\";\n    }\n\n    /**\n     * @return\n     */\n    public boolean isPrimaryKey() {\n        return isPrimary;\n    }\n\n    /**\n     * @param isPrimaryKey\n     */\n    public void setIsPrimaryKey(boolean isPrimaryKey) {\n        isPrimary = isPrimaryKey;\n    }\n\n    /**\n     * @return\n     */\n    public boolean isUnique() {\n        return isUnique;\n    }\n\n    /**\n     * @return\n     */\n    public String getColumnsAsString() {\n        StringBuilder buf = new StringBuilder();\n        for (TableColumn column : columns) {\n            if (buf.length() > 0)\n                buf.append(\" + \");\n            buf.append(column);\n        }\n        return buf.toString();\n    }\n\n    public List<TableColumn> getColumns() {\n        return Collections.unmodifiableList(columns);\n    }\n\n    /**\n     * Yes, we had a project that had columns defined as both 'nullable' and 'must be unique'.\n     *\n     * @return boolean\n     */\n    public boolean isUniqueNullable() {\n        if (!isUnique())\n            return false;\n        // if all of the columns specified by the Unique Index are nullable\n        // then return true, otherwise false\n        boolean allNullable = true;\n        for (TableColumn column : getColumns()) {\n            allNullable = column != null && column.isNullable();\n            if (!allNullable)\n                break;\n        }\n        return allNullable;\n    }\n\n    /**\n     * @param column\n     * @return\n     */\n    public boolean isAscending(TableColumn column) {\n        return columnsAscending.get(columns.indexOf(column)).booleanValue();\n    }\n\n    /**\n     * @param object\n     * @return\n     */\n    public int compareTo(TableIndex other) {\n        if (isPrimaryKey() && !other.isPrimaryKey())\n            return -1;\n        if (!isPrimaryKey() && other.isPrimaryKey())\n            return 1;\n        Object thisId = getId();\n        Object otherId = other.getId();\n        if (thisId == null || otherId == null)\n            return getName().compareToIgnoreCase(other.getName());\n        if (thisId instanceof Number)\n            return ((Number) thisId).intValue() - ((Number) otherId).intValue();\n        return thisId.toString().compareToIgnoreCase(otherId.toString());\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableIndexTest1.java",
		"test_prompt": "// TableIndexTest1.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TableIndex}.\n* It contains ten unit test cases for the {@link TableIndex#isUnique()} method.\n*/\nclass TableIndexTest1 {"
	},
	{
		"original_code": "// TableIndex.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class TableIndex implements Comparable<TableIndex> {\n\n    private final String name;\n\n    private final boolean isUnique;\n\n    private Object id;\n\n    private boolean isPrimary;\n\n    private final List<TableColumn> columns = new ArrayList<TableColumn>();\n\n    // for whether colums are ascending order\n    private final List<Boolean> columnsAscending = new ArrayList<Boolean>();\n\n    /**\n     * @param rs\n     * @throws java.sql.SQLException\n     */\n    public TableIndex(ResultSet rs) throws SQLException {\n        name = rs.getString(\"INDEX_NAME\");\n        isUnique = !rs.getBoolean(\"NON_UNIQUE\");\n    }\n\n    public void setId(Object id) {\n        this.id = id;\n    }\n\n    public Object getId() {\n        return id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    void addColumn(TableColumn column, String sortOrder) {\n        if (column != null) {\n            columns.add(column);\n            columnsAscending.add(Boolean.valueOf(sortOrder == null || sortOrder.equals(\"A\")));\n        }\n    }\n\n    /**\n     * @return\n     */\n    public String getType() {\n        if (isPrimaryKey())\n            return \"Primary key\";\n        if (isUnique())\n            return \"Must be unique\";\n        return \"Performance\";\n    }\n\n    /**\n     * @return\n     */\n    public boolean isPrimaryKey() {\n        return isPrimary;\n    }\n\n    /**\n     * @param isPrimaryKey\n     */\n    public void setIsPrimaryKey(boolean isPrimaryKey) {\n        isPrimary = isPrimaryKey;\n    }\n\n    /**\n     * @return\n     */\n    public boolean isUnique() {\n        return isUnique;\n    }\n\n    /**\n     * @return\n     */\n    public String getColumnsAsString() {\n        StringBuilder buf = new StringBuilder();\n        for (TableColumn column : columns) {\n            if (buf.length() > 0)\n                buf.append(\" + \");\n            buf.append(column);\n        }\n        return buf.toString();\n    }\n\n    public List<TableColumn> getColumns() {\n        return Collections.unmodifiableList(columns);\n    }\n\n    /**\n     * Yes, we had a project that had columns defined as both 'nullable' and 'must be unique'.\n     *\n     * @return boolean\n     */\n    public boolean isUniqueNullable() {\n        if (!isUnique())\n            return false;\n        // if all of the columns specified by the Unique Index are nullable\n        // then return true, otherwise false\n        boolean allNullable = true;\n        for (TableColumn column : getColumns()) {\n            allNullable = column != null && column.isNullable();\n            if (!allNullable)\n                break;\n        }\n        return allNullable;\n    }\n\n    /**\n     * @param column\n     * @return\n     */\n    public boolean isAscending(TableColumn column) {\n        return columnsAscending.get(columns.indexOf(column)).booleanValue();\n    }\n\n    /**\n     * @param object\n     * @return\n     */\n    public int compareTo(TableIndex other) {\n        if (isPrimaryKey() && !other.isPrimaryKey())\n            return -1;\n        if (!isPrimaryKey() && other.isPrimaryKey())\n            return 1;\n        Object thisId = getId();\n        Object otherId = other.getId();\n        if (thisId == null || otherId == null)\n            return getName().compareToIgnoreCase(other.getName());\n        if (thisId instanceof Number)\n            return ((Number) thisId).intValue() - ((Number) otherId).intValue();\n        return thisId.toString().compareToIgnoreCase(otherId.toString());\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableIndexTest2.java",
		"test_prompt": "// TableIndexTest2.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TableIndex}.\n* It contains ten unit test cases for the {@link TableIndex#isUniqueNullable()} method.\n*/\nclass TableIndexTest2 {"
	},
	{
		"original_code": "// TableIndex.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class TableIndex implements Comparable<TableIndex> {\n\n    private final String name;\n\n    private final boolean isUnique;\n\n    private Object id;\n\n    private boolean isPrimary;\n\n    private final List<TableColumn> columns = new ArrayList<TableColumn>();\n\n    // for whether colums are ascending order\n    private final List<Boolean> columnsAscending = new ArrayList<Boolean>();\n\n    /**\n     * @param rs\n     * @throws java.sql.SQLException\n     */\n    public TableIndex(ResultSet rs) throws SQLException {\n        name = rs.getString(\"INDEX_NAME\");\n        isUnique = !rs.getBoolean(\"NON_UNIQUE\");\n    }\n\n    public void setId(Object id) {\n        this.id = id;\n    }\n\n    public Object getId() {\n        return id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    void addColumn(TableColumn column, String sortOrder) {\n        if (column != null) {\n            columns.add(column);\n            columnsAscending.add(Boolean.valueOf(sortOrder == null || sortOrder.equals(\"A\")));\n        }\n    }\n\n    /**\n     * @return\n     */\n    public String getType() {\n        if (isPrimaryKey())\n            return \"Primary key\";\n        if (isUnique())\n            return \"Must be unique\";\n        return \"Performance\";\n    }\n\n    /**\n     * @return\n     */\n    public boolean isPrimaryKey() {\n        return isPrimary;\n    }\n\n    /**\n     * @param isPrimaryKey\n     */\n    public void setIsPrimaryKey(boolean isPrimaryKey) {\n        isPrimary = isPrimaryKey;\n    }\n\n    /**\n     * @return\n     */\n    public boolean isUnique() {\n        return isUnique;\n    }\n\n    /**\n     * @return\n     */\n    public String getColumnsAsString() {\n        StringBuilder buf = new StringBuilder();\n        for (TableColumn column : columns) {\n            if (buf.length() > 0)\n                buf.append(\" + \");\n            buf.append(column);\n        }\n        return buf.toString();\n    }\n\n    public List<TableColumn> getColumns() {\n        return Collections.unmodifiableList(columns);\n    }\n\n    /**\n     * Yes, we had a project that had columns defined as both 'nullable' and 'must be unique'.\n     *\n     * @return boolean\n     */\n    public boolean isUniqueNullable() {\n        if (!isUnique())\n            return false;\n        // if all of the columns specified by the Unique Index are nullable\n        // then return true, otherwise false\n        boolean allNullable = true;\n        for (TableColumn column : getColumns()) {\n            allNullable = column != null && column.isNullable();\n            if (!allNullable)\n                break;\n        }\n        return allNullable;\n    }\n\n    /**\n     * @param column\n     * @return\n     */\n    public boolean isAscending(TableColumn column) {\n        return columnsAscending.get(columns.indexOf(column)).booleanValue();\n    }\n\n    /**\n     * @param object\n     * @return\n     */\n    public int compareTo(TableIndex other) {\n        if (isPrimaryKey() && !other.isPrimaryKey())\n            return -1;\n        if (!isPrimaryKey() && other.isPrimaryKey())\n            return 1;\n        Object thisId = getId();\n        Object otherId = other.getId();\n        if (thisId == null || otherId == null)\n            return getName().compareToIgnoreCase(other.getName());\n        if (thisId instanceof Number)\n            return ((Number) thisId).intValue() - ((Number) otherId).intValue();\n        return thisId.toString().compareToIgnoreCase(otherId.toString());\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableIndexTest3.java",
		"test_prompt": "// TableIndexTest3.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TableIndex}.\n* It contains ten unit test cases for the {@link TableIndex#isAscending(TableColumn)} method.\n*/\nclass TableIndexTest3 {"
	},
	{
		"original_code": "// TableIndex.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class TableIndex implements Comparable<TableIndex> {\n\n    private final String name;\n\n    private final boolean isUnique;\n\n    private Object id;\n\n    private boolean isPrimary;\n\n    private final List<TableColumn> columns = new ArrayList<TableColumn>();\n\n    // for whether colums are ascending order\n    private final List<Boolean> columnsAscending = new ArrayList<Boolean>();\n\n    /**\n     * @param rs\n     * @throws java.sql.SQLException\n     */\n    public TableIndex(ResultSet rs) throws SQLException {\n        name = rs.getString(\"INDEX_NAME\");\n        isUnique = !rs.getBoolean(\"NON_UNIQUE\");\n    }\n\n    public void setId(Object id) {\n        this.id = id;\n    }\n\n    public Object getId() {\n        return id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    void addColumn(TableColumn column, String sortOrder) {\n        if (column != null) {\n            columns.add(column);\n            columnsAscending.add(Boolean.valueOf(sortOrder == null || sortOrder.equals(\"A\")));\n        }\n    }\n\n    /**\n     * @return\n     */\n    public String getType() {\n        if (isPrimaryKey())\n            return \"Primary key\";\n        if (isUnique())\n            return \"Must be unique\";\n        return \"Performance\";\n    }\n\n    /**\n     * @return\n     */\n    public boolean isPrimaryKey() {\n        return isPrimary;\n    }\n\n    /**\n     * @param isPrimaryKey\n     */\n    public void setIsPrimaryKey(boolean isPrimaryKey) {\n        isPrimary = isPrimaryKey;\n    }\n\n    /**\n     * @return\n     */\n    public boolean isUnique() {\n        return isUnique;\n    }\n\n    /**\n     * @return\n     */\n    public String getColumnsAsString() {\n        StringBuilder buf = new StringBuilder();\n        for (TableColumn column : columns) {\n            if (buf.length() > 0)\n                buf.append(\" + \");\n            buf.append(column);\n        }\n        return buf.toString();\n    }\n\n    public List<TableColumn> getColumns() {\n        return Collections.unmodifiableList(columns);\n    }\n\n    /**\n     * Yes, we had a project that had columns defined as both 'nullable' and 'must be unique'.\n     *\n     * @return boolean\n     */\n    public boolean isUniqueNullable() {\n        if (!isUnique())\n            return false;\n        // if all of the columns specified by the Unique Index are nullable\n        // then return true, otherwise false\n        boolean allNullable = true;\n        for (TableColumn column : getColumns()) {\n            allNullable = column != null && column.isNullable();\n            if (!allNullable)\n                break;\n        }\n        return allNullable;\n    }\n\n    /**\n     * @param column\n     * @return\n     */\n    public boolean isAscending(TableColumn column) {\n        return columnsAscending.get(columns.indexOf(column)).booleanValue();\n    }\n\n    /**\n     * @param object\n     * @return\n     */\n    public int compareTo(TableIndex other) {\n        if (isPrimaryKey() && !other.isPrimaryKey())\n            return -1;\n        if (!isPrimaryKey() && other.isPrimaryKey())\n            return 1;\n        Object thisId = getId();\n        Object otherId = other.getId();\n        if (thisId == null || otherId == null)\n            return getName().compareToIgnoreCase(other.getName());\n        if (thisId instanceof Number)\n            return ((Number) thisId).intValue() - ((Number) otherId).intValue();\n        return thisId.toString().compareToIgnoreCase(otherId.toString());\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/TableIndexTest4.java",
		"test_prompt": "// TableIndexTest4.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TableIndex}.\n* It contains ten unit test cases for the {@link TableIndex#compareTo(TableIndex)} method.\n*/\nclass TableIndexTest4 {"
	},
	{
		"original_code": "// Routine.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2011 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy.model;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/**\r\n * Metadata about a stored procedure or function\r\n *\r\n * @author John Currier\r\n */\r\npublic class Routine implements Comparable<Routine> {\r\n\r\n    private final String name;\r\n\r\n    private final String type;\r\n\r\n    private final String definitionLanguage;\r\n\r\n    private final String definition;\r\n\r\n    private final boolean deterministic;\r\n\r\n    private final String dataAccess;\r\n\r\n    private final String securityType;\r\n\r\n    private final String comment;\r\n\r\n    private final String returnType;\r\n\r\n    private final List<RoutineParameter> params = new ArrayList<RoutineParameter>();\r\n\r\n    /**\r\n     * @param name\r\n     * @param type\r\n     * @param returnType\r\n     * @param definitionLanguage\r\n     * @param definition\r\n     * @param deterministic\r\n     * @param dataAccess\r\n     * @param securityType\r\n     * @param comment\r\n     */\r\n    public Routine(String name, // function or procedure\r\n    String type, String returnType, String definitionLanguage, String definition, boolean deterministic, String dataAccess, String securityType, String comment) {\r\n        this.name = name;\r\n        this.type = type;\r\n        this.returnType = returnType;\r\n        this.definitionLanguage = definitionLanguage;\r\n        this.definition = definition;\r\n        this.dataAccess = dataAccess;\r\n        this.securityType = securityType;\r\n        this.deterministic = deterministic;\r\n        this.comment = comment;\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String getType() {\r\n        return type;\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String getDefinitionLanguage() {\r\n        return definitionLanguage;\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String getDefinition() {\r\n        return definition;\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public boolean isDeterministic() {\r\n        return deterministic;\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String getDataAccess() {\r\n        return dataAccess;\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String getSecurityType() {\r\n        return securityType;\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String getComment() {\r\n        return comment;\r\n    }\r\n\r\n    /**\r\n     * Returns the return type for the routine or null if there is none\r\n     *\r\n     * @return\r\n     */\r\n    public String getReturnType() {\r\n        return returnType;\r\n    }\r\n\r\n    /**\r\n     * @param param\r\n     */\r\n    public void addParameter(RoutineParameter param) {\r\n        params.add(param);\r\n    }\r\n\r\n    /**\r\n     * Returns the types of the routine's parameters.\r\n     * @return\r\n     */\r\n    public List<RoutineParameter> getParameters() {\r\n        return params;\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.lang.Comparable#compareTo(java.lang.Object)\r\n     */\r\n    public int compareTo(Routine other) {\r\n        int rc = getName().compareTo(other.getName());\r\n        if (rc == 0)\r\n            rc = getType().compareTo(other.getType());\r\n        if (rc == 0)\r\n            rc = String.valueOf(getReturnType()).compareTo(String.valueOf(other.getReturnType()));\r\n        if (rc == 0)\r\n            rc = getDefinition().compareTo(other.getDefinition());\r\n        return rc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/RoutineTest0.java",
		"test_prompt": "// RoutineTest0.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Routine}.\n* It contains ten unit test cases for the {@link Routine#isDeterministic()} method.\n*/\nclass RoutineTest0 {"
	},
	{
		"original_code": "// Routine.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2011 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy.model;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/**\r\n * Metadata about a stored procedure or function\r\n *\r\n * @author John Currier\r\n */\r\npublic class Routine implements Comparable<Routine> {\r\n\r\n    private final String name;\r\n\r\n    private final String type;\r\n\r\n    private final String definitionLanguage;\r\n\r\n    private final String definition;\r\n\r\n    private final boolean deterministic;\r\n\r\n    private final String dataAccess;\r\n\r\n    private final String securityType;\r\n\r\n    private final String comment;\r\n\r\n    private final String returnType;\r\n\r\n    private final List<RoutineParameter> params = new ArrayList<RoutineParameter>();\r\n\r\n    /**\r\n     * @param name\r\n     * @param type\r\n     * @param returnType\r\n     * @param definitionLanguage\r\n     * @param definition\r\n     * @param deterministic\r\n     * @param dataAccess\r\n     * @param securityType\r\n     * @param comment\r\n     */\r\n    public Routine(String name, // function or procedure\r\n    String type, String returnType, String definitionLanguage, String definition, boolean deterministic, String dataAccess, String securityType, String comment) {\r\n        this.name = name;\r\n        this.type = type;\r\n        this.returnType = returnType;\r\n        this.definitionLanguage = definitionLanguage;\r\n        this.definition = definition;\r\n        this.dataAccess = dataAccess;\r\n        this.securityType = securityType;\r\n        this.deterministic = deterministic;\r\n        this.comment = comment;\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String getType() {\r\n        return type;\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String getDefinitionLanguage() {\r\n        return definitionLanguage;\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String getDefinition() {\r\n        return definition;\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public boolean isDeterministic() {\r\n        return deterministic;\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String getDataAccess() {\r\n        return dataAccess;\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String getSecurityType() {\r\n        return securityType;\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String getComment() {\r\n        return comment;\r\n    }\r\n\r\n    /**\r\n     * Returns the return type for the routine or null if there is none\r\n     *\r\n     * @return\r\n     */\r\n    public String getReturnType() {\r\n        return returnType;\r\n    }\r\n\r\n    /**\r\n     * @param param\r\n     */\r\n    public void addParameter(RoutineParameter param) {\r\n        params.add(param);\r\n    }\r\n\r\n    /**\r\n     * Returns the types of the routine's parameters.\r\n     * @return\r\n     */\r\n    public List<RoutineParameter> getParameters() {\r\n        return params;\r\n    }\r\n\r\n    /* (non-Javadoc)\r\n     * @see java.lang.Comparable#compareTo(java.lang.Object)\r\n     */\r\n    public int compareTo(Routine other) {\r\n        int rc = getName().compareTo(other.getName());\r\n        if (rc == 0)\r\n            rc = getType().compareTo(other.getType());\r\n        if (rc == 0)\r\n            rc = String.valueOf(getReturnType()).compareTo(String.valueOf(other.getReturnType()));\r\n        if (rc == 0)\r\n            rc = getDefinition().compareTo(other.getDefinition());\r\n        return rc;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/RoutineTest1.java",
		"test_prompt": "// RoutineTest1.java\npackage net.sourceforge.schemaspy.model;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Routine}.\n* It contains ten unit test cases for the {@link Routine#compareTo(Routine)} method.\n*/\nclass RoutineTest1 {"
	},
	{
		"original_code": "// ImpliedForeignKeyConstraint.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.model;\n\npublic class ImpliedForeignKeyConstraint extends ForeignKeyConstraint {\n\n    /**\n     * @param parentColumn\n     * @param childColumn\n     */\n    public ImpliedForeignKeyConstraint(TableColumn parentColumn, TableColumn childColumn) {\n        super(parentColumn, childColumn);\n    }\n\n    /**\n     * @return\n     */\n    @Override\n    public String getName() {\n        return \"Implied Constraint\";\n    }\n\n    /**\n     * @return\n     */\n    @Override\n    public boolean isImplied() {\n        return true;\n    }\n\n    /**\n     * @return\n     */\n    @Override\n    public String toString() {\n        StringBuilder buf = new StringBuilder();\n        buf.append(getChildTable());\n        buf.append(\".\");\n        buf.append(toString(getChildColumns()));\n        buf.append(\"'s name implies that it's a child of \");\n        buf.append(getParentTable());\n        buf.append(\".\");\n        buf.append(toString(getParentColumns()));\n        buf.append(\", but it doesn't reference that column.\");\n        return buf.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/model/ImpliedForeignKeyConstraintTest.java",
		"test_prompt": "// ImpliedForeignKeyConstraintTest.java\npackage net.sourceforge.schemaspy.model;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ImpliedForeignKeyConstraint}.\n* It contains ten unit test cases for the {@link ImpliedForeignKeyConstraint#isImplied()} method.\n*/\nclass ImpliedForeignKeyConstraintTest {"
	},
	{
		"original_code": "// HtmlOrphansPage.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.Database;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.LineWriter;\n\n/**\n * The page that contains the all tables that aren't related to others (orphans)\n *\n * @author John Currier\n */\npublic class HtmlOrphansPage extends HtmlDiagramFormatter {\n\n    private static HtmlOrphansPage instance = new HtmlOrphansPage();\n\n    /**\n     * Singleton: Don't allow instantiation\n     */\n    private HtmlOrphansPage() {\n    }\n\n    /**\n     * Singleton accessor\n     *\n     * @return the singleton instance\n     */\n    public static HtmlOrphansPage getInstance() {\n        return instance;\n    }\n\n    public boolean write(Database db, List<Table> orphanTables, File diagramDir, LineWriter html) throws IOException {\n        Dot dot = getDot();\n        if (dot == null)\n            return false;\n        Set<Table> orphansWithImpliedRelationships = new HashSet<Table>();\n        for (Table table : orphanTables) {\n            if (!table.isOrphan(true)) {\n                orphansWithImpliedRelationships.add(table);\n            }\n        }\n        writeHeader(db, \"Utility Tables\", !orphansWithImpliedRelationships.isEmpty(), html);\n        html.writeln(\"<a name='diagram'>\");\n        try {\n            StringBuilder maps = new StringBuilder(64 * 1024);\n            for (Table table : orphanTables) {\n                String dotBaseFilespec = table.getName();\n                File dotFile = new File(diagramDir, dotBaseFilespec + \".1degree.dot\");\n                File imgFile = new File(diagramDir, dotBaseFilespec + \".1degree.\" + dot.getFormat());\n                LineWriter dotOut = new LineWriter(dotFile, Config.DOT_CHARSET);\n                DotFormatter.getInstance().writeOrphan(table, dotOut);\n                dotOut.close();\n                try {\n                    maps.append(dot.generateDiagram(dotFile, imgFile));\n                } catch (Dot.DotFailure dotFailure) {\n                    System.err.println(dotFailure);\n                    return false;\n                }\n                html.write(\"  <img src='diagrams/orphans/\" + imgFile.getName() + \"' usemap='#\" + table + \"' border='0' alt='' align='top'\");\n                if (orphansWithImpliedRelationships.contains(table))\n                    html.write(\" class='impliedNotOrphan'\");\n                html.writeln(\">\");\n            }\n            html.write(maps.toString());\n            return true;\n        } finally {\n            html.writeln(\"</a>\");\n            writeFooter(html);\n        }\n    }\n\n    private void writeHeader(Database db, String title, boolean hasImpliedRelationships, LineWriter html) throws IOException {\n        writeHeader(db, null, title, html);\n        html.writeln(\"<table class='container' width='100%'>\");\n        html.writeln(\"<tr><td class='container'>\");\n        writeGeneratedOn(db.getConnectTime(), html);\n        html.writeln(\"</td>\");\n        html.writeln(\"<td class='container' align='right' valign='top' rowspan='2'>\");\n        writeLegend(false, html);\n        html.writeln(\"</td></tr>\");\n        html.writeln(\"<tr><td class='container' align='left' valign='top'>\");\n        if (hasImpliedRelationships) {\n            html.writeln(\"<form action=''>\");\n            html.writeln(\" <label for='removeImpliedOrphans'><input type=checkbox id='removeImpliedOrphans'>\");\n            html.writeln(\"  Hide tables with implied relationships</label>\");\n            html.writeln(\"</form>\");\n        }\n        html.writeln(\"</td></tr></table>\");\n    }\n\n    @Override\n    protected boolean isOrphansPage() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/HtmlOrphansPageTest0.java",
		"test_prompt": "// HtmlOrphansPageTest0.java\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.Database;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.LineWriter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HtmlOrphansPage}.\n* It contains ten unit test cases for the {@link HtmlOrphansPage#getInstance()} method.\n*/\nclass HtmlOrphansPageTest0 {"
	},
	{
		"original_code": "// HtmlOrphansPage.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.Database;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.LineWriter;\n\n/**\n * The page that contains the all tables that aren't related to others (orphans)\n *\n * @author John Currier\n */\npublic class HtmlOrphansPage extends HtmlDiagramFormatter {\n\n    private static HtmlOrphansPage instance = new HtmlOrphansPage();\n\n    /**\n     * Singleton: Don't allow instantiation\n     */\n    private HtmlOrphansPage() {\n    }\n\n    /**\n     * Singleton accessor\n     *\n     * @return the singleton instance\n     */\n    public static HtmlOrphansPage getInstance() {\n        return instance;\n    }\n\n    public boolean write(Database db, List<Table> orphanTables, File diagramDir, LineWriter html) throws IOException {\n        Dot dot = getDot();\n        if (dot == null)\n            return false;\n        Set<Table> orphansWithImpliedRelationships = new HashSet<Table>();\n        for (Table table : orphanTables) {\n            if (!table.isOrphan(true)) {\n                orphansWithImpliedRelationships.add(table);\n            }\n        }\n        writeHeader(db, \"Utility Tables\", !orphansWithImpliedRelationships.isEmpty(), html);\n        html.writeln(\"<a name='diagram'>\");\n        try {\n            StringBuilder maps = new StringBuilder(64 * 1024);\n            for (Table table : orphanTables) {\n                String dotBaseFilespec = table.getName();\n                File dotFile = new File(diagramDir, dotBaseFilespec + \".1degree.dot\");\n                File imgFile = new File(diagramDir, dotBaseFilespec + \".1degree.\" + dot.getFormat());\n                LineWriter dotOut = new LineWriter(dotFile, Config.DOT_CHARSET);\n                DotFormatter.getInstance().writeOrphan(table, dotOut);\n                dotOut.close();\n                try {\n                    maps.append(dot.generateDiagram(dotFile, imgFile));\n                } catch (Dot.DotFailure dotFailure) {\n                    System.err.println(dotFailure);\n                    return false;\n                }\n                html.write(\"  <img src='diagrams/orphans/\" + imgFile.getName() + \"' usemap='#\" + table + \"' border='0' alt='' align='top'\");\n                if (orphansWithImpliedRelationships.contains(table))\n                    html.write(\" class='impliedNotOrphan'\");\n                html.writeln(\">\");\n            }\n            html.write(maps.toString());\n            return true;\n        } finally {\n            html.writeln(\"</a>\");\n            writeFooter(html);\n        }\n    }\n\n    private void writeHeader(Database db, String title, boolean hasImpliedRelationships, LineWriter html) throws IOException {\n        writeHeader(db, null, title, html);\n        html.writeln(\"<table class='container' width='100%'>\");\n        html.writeln(\"<tr><td class='container'>\");\n        writeGeneratedOn(db.getConnectTime(), html);\n        html.writeln(\"</td>\");\n        html.writeln(\"<td class='container' align='right' valign='top' rowspan='2'>\");\n        writeLegend(false, html);\n        html.writeln(\"</td></tr>\");\n        html.writeln(\"<tr><td class='container' align='left' valign='top'>\");\n        if (hasImpliedRelationships) {\n            html.writeln(\"<form action=''>\");\n            html.writeln(\" <label for='removeImpliedOrphans'><input type=checkbox id='removeImpliedOrphans'>\");\n            html.writeln(\"  Hide tables with implied relationships</label>\");\n            html.writeln(\"</form>\");\n        }\n        html.writeln(\"</td></tr></table>\");\n    }\n\n    @Override\n    protected boolean isOrphansPage() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/HtmlOrphansPageTest1.java",
		"test_prompt": "// HtmlOrphansPageTest1.java\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.Database;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.LineWriter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HtmlOrphansPage}.\n* It contains ten unit test cases for the {@link HtmlOrphansPage#write(Database, List, File, LineWriter)} method.\n*/\nclass HtmlOrphansPageTest1 {"
	},
	{
		"original_code": "// HtmlMultipleSchemasIndexPage.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.IOException;\nimport java.sql.DatabaseMetaData;\nimport java.sql.SQLException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.List;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.util.LineWriter;\n\n/**\n * The page that contains links to the various schemas that were analyzed\n *\n * @author John Currier\n */\npublic class HtmlMultipleSchemasIndexPage extends HtmlFormatter {\n\n    private static HtmlMultipleSchemasIndexPage instance = new HtmlMultipleSchemasIndexPage();\n\n    /**\n     * Singleton: Don't allow instantiation\n     */\n    private HtmlMultipleSchemasIndexPage() {\n    }\n\n    /**\n     * Singleton accessor\n     *\n     * @return the singleton instance\n     */\n    public static HtmlMultipleSchemasIndexPage getInstance() {\n        return instance;\n    }\n\n    public void write(String dbName, List<String> populatedSchemas, DatabaseMetaData meta, LineWriter index) throws IOException {\n        writeHeader(dbName, meta, populatedSchemas.size(), false, populatedSchemas.get(0).toString(), index);\n        for (String schema : populatedSchemas) {\n            writeLineItem(schema, index);\n        }\n        writeFooter(index);\n    }\n\n    private void writeHeader(String databaseName, DatabaseMetaData meta, int numberOfSchemas, boolean showIds, String aSchema, LineWriter html) throws IOException {\n        String connectTime = new SimpleDateFormat(\"EEE MMM dd HH:mm z yyyy\").format(new Date());\n        html.writeln(\"<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.01 Transitional//EN' 'http://www.w3.org/TR/html4/loose.dtd'>\");\n        html.writeln(\"<html>\");\n        html.writeln(\"<head>\");\n        html.write(\"  <title>SchemaSpy Analysis\");\n        if (databaseName != null) {\n            html.write(\" of Database \");\n            html.write(databaseName);\n        }\n        html.writeln(\"</title>\");\n        html.write(\"  <link rel=stylesheet href='\");\n        html.write(aSchema);\n        html.writeln(\"/schemaSpy.css' type='text/css'>\");\n        html.writeln(\"  <meta HTTP-EQUIV='Content-Type' CONTENT='text/html; charset=\" + Config.getInstance().getCharset() + \"'>\");\n        html.writeln(\"</head>\");\n        html.writeln(\"<body>\");\n        writeTableOfContents(html);\n        html.writeln(\"<div class='content' style='clear:both;'>\");\n        html.writeln(\"<table width='100%' border='0' cellpadding='0'>\");\n        html.writeln(\" <tr>\");\n        html.write(\"  <td class='heading' valign='top'><h1>\");\n        html.write(\"SchemaSpy Analysis\");\n        if (databaseName != null) {\n            html.write(\" of Database \");\n            html.write(databaseName);\n        }\n        html.writeln(\"</h1></td>\");\n        html.writeln(\"  <td class='heading' align='right' valign='top' title='John Currier - Creator of Cool Tools'><span class='indent'>Generated by</span><br><span class='indent'><span class='signature'><a href='http://schemaspy.sourceforge.net' target='_blank'>SchemaSpy</a></span></span></td>\");\n        html.writeln(\" </tr>\");\n        html.writeln(\"</table>\");\n        html.writeln(\"<table width='100%'>\");\n        html.writeln(\" <tr><td class='container'>\");\n        writeGeneratedOn(connectTime, html);\n        html.writeln(\" </td></tr>\");\n        html.writeln(\" <tr>\");\n        html.write(\"  <td class='container'>\");\n        if (meta != null) {\n            html.write(\"Database Type: \");\n            html.write(getDatabaseProduct(meta));\n        }\n        html.writeln(\"  </td>\");\n        html.writeln(\"  <td class='container' align='right' valign='top' rowspan='3'>\");\n        if (sourceForgeLogoEnabled())\n            html.writeln(\"    <a href='http://sourceforge.net' target='_blank'><img src='http://sourceforge.net/sflogo.php?group_id=137197&amp;type=1' alt='SourceForge.net' border='0' height='31' width='88'></a><br>\");\n        html.write(\"    <br>\");\n        html.writeln(\"  </td>\");\n        html.writeln(\" </tr>\");\n        html.writeln(\"</table>\");\n        html.writeln(\"<div class='indent'>\");\n        html.write(\"<b>\");\n        html.write(String.valueOf(numberOfSchemas));\n        if (databaseName != null)\n            html.write(\" Schema\");\n        else\n            html.write(\" Database\");\n        html.write(numberOfSchemas == 1 ? \"\" : \"s\");\n        html.writeln(\":</b>\");\n        html.writeln(\"<TABLE class='dataTable' border='1' rules='groups'>\");\n        html.writeln(\"<colgroup>\");\n        html.writeln(\"<thead align='left'>\");\n        html.writeln(\"<tr>\");\n        html.write(\"  <th valign='bottom'>\");\n        if (databaseName != null)\n            html.write(\"Schema\");\n        else\n            html.write(\"Database\");\n        html.writeln(\"</th>\");\n        if (showIds)\n            html.writeln(\"  <th align='center' valign='bottom'>ID</th>\");\n        html.writeln(\"</tr>\");\n        html.writeln(\"</thead>\");\n        html.writeln(\"<tbody>\");\n    }\n\n    private void writeLineItem(String schema, LineWriter index) throws IOException {\n        index.writeln(\" <tr>\");\n        index.write(\"  <td class='detail'><a href='\");\n        index.write(schema);\n        index.write(\"/index.html'>\");\n        index.write(schema);\n        index.writeln(\"</a></td>\");\n        index.writeln(\" </tr>\");\n    }\n\n    @Override\n    protected void writeTableOfContents(LineWriter html) throws IOException {\n        // have to use a table to deal with a horizontal scrollbar showing up inappropriately\n        html.writeln(\"<table id='headerHolder' cellspacing='0' cellpadding='0'><tr><td>\");\n        html.writeln(\"<div id='header'>\");\n        html.writeln(\" <ul>\");\n        html.writeln(\"  <li id='current'><a href='index.html' title='All user schemas in the database'>Schemas</a></li>\");\n        html.writeln(\"  <li><a href='http://sourceforge.net/donate/index.php?group_id=137197' title='Please help keep SchemaSpy alive' target='_blank'>Donate</a></li>\");\n        html.writeln(\" </ul>\");\n        html.writeln(\"</div>\");\n        html.writeln(\"</td></tr></table>\");\n    }\n\n    @Override\n    protected void writeFooter(LineWriter html) throws IOException {\n        html.writeln(\"</tbody>\");\n        html.writeln(\"</table>\");\n        super.writeFooter(html);\n    }\n\n    /**\n     * Copy / paste from Database, but we can't use Database here...\n     *\n     * @param meta DatabaseMetaData\n     * @return String\n     */\n    private String getDatabaseProduct(DatabaseMetaData meta) {\n        try {\n            return meta.getDatabaseProductName() + \" - \" + meta.getDatabaseProductVersion();\n        } catch (SQLException exc) {\n            return \"\";\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/HtmlMultipleSchemasIndexPageTest.java",
		"test_prompt": "// HtmlMultipleSchemasIndexPageTest.java\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.IOException;\nimport java.sql.DatabaseMetaData;\nimport java.sql.SQLException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.List;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.util.LineWriter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HtmlMultipleSchemasIndexPage}.\n* It contains ten unit test cases for the {@link HtmlMultipleSchemasIndexPage#getInstance()} method.\n*/\nclass HtmlMultipleSchemasIndexPageTest {"
	},
	{
		"original_code": "// HtmlRoutinesPage.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2011 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy.view;\r\n\r\nimport java.io.IOException;\r\nimport java.util.Collection;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport java.util.TreeSet;\r\nimport net.sourceforge.schemaspy.model.Database;\r\nimport net.sourceforge.schemaspy.model.Routine;\r\nimport net.sourceforge.schemaspy.model.RoutineParameter;\r\nimport net.sourceforge.schemaspy.util.LineWriter;\r\n\r\n/**\r\n * The page that lists all of the routines (stored procedures and functions)\r\n * in the schema.\r\n *\r\n * @author John Currier\r\n */\r\npublic class HtmlRoutinesPage extends HtmlFormatter {\r\n\r\n    private static HtmlRoutinesPage instance = new HtmlRoutinesPage();\r\n\r\n    /**\r\n     * Singleton: Don't allow instantiation\r\n     */\r\n    private HtmlRoutinesPage() {\r\n    }\r\n\r\n    /**\r\n     * Singleton accessor\r\n     *\r\n     * @return the singleton instance\r\n     */\r\n    public static HtmlRoutinesPage getInstance() {\r\n        return instance;\r\n    }\r\n\r\n    public void write(Database db, LineWriter html) throws IOException {\r\n        Collection<Routine> routines = new TreeSet<Routine>(db.getRoutines());\r\n        writeHeader(db, routines, html);\r\n        for (Routine routine : routines) {\r\n            write(routine, html);\r\n        }\r\n        writeFooter(html);\r\n    }\r\n\r\n    private void writeHeader(Database db, Collection<Routine> routines, LineWriter html) throws IOException {\r\n        writeHeader(db, null, \"Procedures and Functions\", html);\r\n        html.writeln(\"<table width='100%'>\");\r\n        html.writeln(\" <tr>\");\r\n        html.write(\"  <td class='container'>\");\r\n        writeGeneratedOn(db.getConnectTime(), html);\r\n        html.writeln(\"  </td>\");\r\n        if (sourceForgeLogoEnabled())\r\n            html.writeln(\"  <td class='container' align='right' valign='top' colspan='2'><a href='http://sourceforge.net' target='_blank'><img src='http://sourceforge.net/sflogo.php?group_id=137197&amp;type=1' alt='SourceForge.net' border='0' height='31' width='88'></a></td>\");\r\n        html.writeln(\" </tr>\");\r\n        html.writeln(\" <tr>\");\r\n        html.writeln(\"  <td class='container'>\");\r\n        int numProcs = 0;\r\n        int numFuncs = 0;\r\n        for (Routine routine : routines) {\r\n            String type = routine.getType().toLowerCase();\r\n            if (type.startsWith(\"proc\"))\r\n                ++numProcs;\r\n            else if (type.startsWith(\"func\"))\r\n                ++numFuncs;\r\n        }\r\n        html.write(\"   <br><b>\");\r\n        html.write(db.getName());\r\n        if (db.getSchema() != null) {\r\n            html.write('.');\r\n            html.write(db.getSchema());\r\n        } else if (db.getCatalog() != null) {\r\n            html.write('.');\r\n            html.write(db.getCatalog());\r\n        }\r\n        html.write(\" contains \" + numProcs + \" procedures and \" + numFuncs + \" functions:\");\r\n        html.write(\"</b><br><div class='indent'>\");\r\n        for (Routine routine : routines) {\r\n            html.write(\"<a href='#\" + routine.getName() + \"'>\" + routine.getName() + \"</a>&nbsp;&nbsp;\");\r\n        }\r\n        html.writeln(\"</div>\");\r\n        html.writeln(\"  </td>\");\r\n        html.writeln(\" </tr>\");\r\n        html.writeln(\" <tr><td colspan='3'>\");\r\n    }\r\n\r\n    private void write(Routine routine, LineWriter html) throws IOException {\r\n        html.writeln(\"  <br><a id='\" + routine.getName() + \"'></a><hr>\");\r\n        html.write(\"  <br><code><b>\" + routine.getType() + \" \" + routine.getName());\r\n        html.write('(');\r\n        List<RoutineParameter> params = routine.getParameters();\r\n        Iterator<RoutineParameter> iter = params.iterator();\r\n        while (iter.hasNext()) {\r\n            RoutineParameter param = iter.next();\r\n            if (param.getMode() != null) {\r\n                html.write(param.getMode());\r\n                html.write(' ');\r\n            }\r\n            if (param.getName() != null) {\r\n                html.write(param.getName());\r\n                html.write(' ');\r\n            }\r\n            if (param.getType() != null) {\r\n                html.write(param.getType());\r\n            }\r\n            if (iter.hasNext())\r\n                html.write(\", \");\r\n        }\r\n        html.write(\") \");\r\n        if (routine.getReturnType() != null) {\r\n            html.write(\"RETURNS \");\r\n            html.writeln(routine.getReturnType());\r\n        }\r\n        html.writeln(\"</b><br>\");\r\n        String indent = \"   &nbsp;&nbsp;&nbsp;\";\r\n        if (routine.getDefinitionLanguage() != null && routine.getDefinitionLanguage().length() > 0)\r\n            html.writeln(indent + \"LANGUAGE \" + routine.getDefinitionLanguage() + \"<br>\");\r\n        if (routine.getType().toLowerCase().startsWith(\"func\")) {\r\n            // applies to return characteristics of functions only\r\n            html.write(indent);\r\n            if (!routine.isDeterministic())\r\n                html.write(\"NOT \");\r\n            html.writeln(\"DETERMINISTIC<br>\");\r\n        }\r\n        if (routine.getDataAccess() != null && routine.getDataAccess().length() > 0)\r\n            html.writeln(indent + routine.getDataAccess() + \"<br>\");\r\n        if (routine.getSecurityType() != null && routine.getSecurityType().length() > 0)\r\n            html.writeln(indent + \"SQL SECURITY \" + routine.getSecurityType() + \"<br>\");\r\n        if (routine.getComment() != null && routine.getComment().length() > 0)\r\n            html.writeln(indent + \"COMMENT '\" + routine.getComment() + \"'<br>\");\r\n        html.writeln(\"</code><pre>\");\r\n        html.writeln(routine.getDefinition());\r\n        html.writeln(\"</pre>\");\r\n    }\r\n\r\n    @Override\r\n    protected void writeFooter(LineWriter html) throws IOException {\r\n        html.writeln(\"</td></tr></table>\");\r\n        super.writeFooter(html);\r\n    }\r\n\r\n    @Override\r\n    protected boolean isRoutinesPage() {\r\n        return true;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/HtmlRoutinesPageTest.java",
		"test_prompt": "// HtmlRoutinesPageTest.java\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.IOException;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.TreeSet;\nimport net.sourceforge.schemaspy.model.Database;\nimport net.sourceforge.schemaspy.model.Routine;\nimport net.sourceforge.schemaspy.model.RoutineParameter;\nimport net.sourceforge.schemaspy.util.LineWriter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HtmlRoutinesPage}.\n* It contains ten unit test cases for the {@link HtmlRoutinesPage#getInstance()} method.\n*/\nclass HtmlRoutinesPageTest {"
	},
	{
		"original_code": "// DotConnector.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.view;\n\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.util.Dot;\n\n/**\n * Represents Graphvis dot's concept of an edge.  That is, a connector between two nodes.\n *\n * @author John Currier\n */\npublic class DotConnector implements Comparable<DotConnector> {\n\n    private final TableColumn parentColumn;\n\n    private final Table parentTable;\n\n    private final TableColumn childColumn;\n\n    private final Table childTable;\n\n    private final boolean implied;\n\n    private final boolean bottomJustify;\n\n    private String parentPort;\n\n    private String childPort;\n\n    /**\n     * Create an edge that logically connects a child column to a parent column.\n     *\n     * @param parentColumn TableColumn\n     * @param childColumn TableColumn\n     * @param implied boolean\n     */\n    public DotConnector(TableColumn parentColumn, TableColumn childColumn, boolean implied) {\n        this.parentColumn = parentColumn;\n        this.childColumn = childColumn;\n        this.implied = implied;\n        parentPort = parentColumn.getName();\n        parentTable = parentColumn.getTable();\n        childPort = childColumn.getName();\n        childTable = childColumn.getTable();\n        bottomJustify = !Dot.getInstance().supportsCenteredEastWestEdges();\n    }\n\n    /**\n     * Returns true if this edge logically \"points to\" the specified table\n     *\n     * @param possibleParentTable Table\n     * @return boolean\n     */\n    public boolean pointsTo(Table possibleParentTable) {\n        return possibleParentTable.equals(parentTable);\n    }\n\n    public boolean isImplied() {\n        return implied;\n    }\n\n    /**\n     * By default a parent edge connects to the column name...this lets you\n     * connect it the parent's type column instead (e.g. for detailed parents)\n     *\n     * Yes, I need to find a more appropriate name/metaphor for this method....\n     */\n    public void connectToParentDetails() {\n        parentPort = parentColumn.getName() + \".type\";\n    }\n\n    public void connectToParentTitle() {\n        //parentPort = parentColumn.getTable().getName() + \".heading\";\n        parentPort = \"elipses\";\n    }\n\n    public void connectToChildTitle() {\n        //childPort = childColumn.getTable().getName() + \".heading\";\n        childPort = \"elipses\";\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder edge = new StringBuilder();\n        edge.append(\"  \\\"\");\n        if (childTable.isRemote()) {\n            edge.append(childTable.getContainer());\n            edge.append('.');\n        }\n        edge.append(childTable.getName());\n        edge.append(\"\\\":\\\"\");\n        edge.append(childPort);\n        edge.append(\"\\\":\");\n        if (bottomJustify)\n            edge.append(\"s\");\n        edge.append(\"w -> \\\"\");\n        if (parentTable.isRemote()) {\n            edge.append(parentTable.getContainer());\n            edge.append('.');\n        }\n        edge.append(parentTable.getName());\n        edge.append(\"\\\":\\\"\");\n        edge.append(parentPort);\n        edge.append(\"\\\":\");\n        if (bottomJustify)\n            edge.append(\"s\");\n        edge.append(\"e \");\n        // if enabled makes the diagram unreadable\n        // have to figure out how to render these details in a readable manner\n        final boolean fullErNotation = false;\n        // Thanks to Dan Zingaro for figuring out how to correctly annotate\n        // these relationships\n        if (fullErNotation) {\n            // PK end of connector\n            edge.append(\"[arrowhead=\");\n            if (childColumn.isNullable())\n                // zero or one parents\n                edge.append(\"odottee\");\n            else\n                // one parent\n                edge.append(\"teetee\");\n            edge.append(\" dir=both\");\n        } else {\n            // PK end of connector\n            edge.append(\"[arrowhead=none\");\n            edge.append(\" dir=back\");\n        }\n        // FK end of connector\n        edge.append(\" arrowtail=\");\n        if (childColumn.isUnique())\n            // zero or one children\n            edge.append(\"teeodot\");\n        else\n            // zero or more children\n            edge.append(\"crowodot\");\n        if (implied)\n            edge.append(\" style=dashed\");\n        edge.append(\"];\");\n        return edge.toString();\n    }\n\n    public int compareTo(DotConnector other) {\n        int rc = childTable.compareTo(other.childTable);\n        if (rc == 0)\n            rc = childColumn.getName().compareToIgnoreCase(other.childColumn.getName());\n        if (rc == 0)\n            rc = parentTable.compareTo(other.parentTable);\n        if (rc == 0)\n            rc = parentColumn.getName().compareToIgnoreCase(other.parentColumn.getName());\n        if (rc == 0 && implied != other.implied)\n            rc = implied ? 1 : -1;\n        return rc;\n    }\n\n    @Override\n    public boolean equals(Object other) {\n        if (!(other instanceof DotConnector))\n            return false;\n        return compareTo((DotConnector) other) == 0;\n    }\n\n    @Override\n    public int hashCode() {\n        int p = parentTable == null ? 0 : parentTable.getName().hashCode();\n        int c = childTable == null ? 0 : childTable.getName().hashCode();\n        return (p << 16) & c;\n    }\n\n    public TableColumn getParentColumn() {\n        return parentColumn;\n    }\n\n    public Table getParentTable() {\n        return parentTable;\n    }\n\n    public TableColumn getChildColumn() {\n        return childColumn;\n    }\n\n    public Table getChildTable() {\n        return childTable;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/DotConnectorTest0.java",
		"test_prompt": "// DotConnectorTest0.java\npackage net.sourceforge.schemaspy.view;\n\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.util.Dot;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DotConnector}.\n* It contains ten unit test cases for the {@link DotConnector#pointsTo(Table)} method.\n*/\nclass DotConnectorTest0 {"
	},
	{
		"original_code": "// DotConnector.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.view;\n\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.util.Dot;\n\n/**\n * Represents Graphvis dot's concept of an edge.  That is, a connector between two nodes.\n *\n * @author John Currier\n */\npublic class DotConnector implements Comparable<DotConnector> {\n\n    private final TableColumn parentColumn;\n\n    private final Table parentTable;\n\n    private final TableColumn childColumn;\n\n    private final Table childTable;\n\n    private final boolean implied;\n\n    private final boolean bottomJustify;\n\n    private String parentPort;\n\n    private String childPort;\n\n    /**\n     * Create an edge that logically connects a child column to a parent column.\n     *\n     * @param parentColumn TableColumn\n     * @param childColumn TableColumn\n     * @param implied boolean\n     */\n    public DotConnector(TableColumn parentColumn, TableColumn childColumn, boolean implied) {\n        this.parentColumn = parentColumn;\n        this.childColumn = childColumn;\n        this.implied = implied;\n        parentPort = parentColumn.getName();\n        parentTable = parentColumn.getTable();\n        childPort = childColumn.getName();\n        childTable = childColumn.getTable();\n        bottomJustify = !Dot.getInstance().supportsCenteredEastWestEdges();\n    }\n\n    /**\n     * Returns true if this edge logically \"points to\" the specified table\n     *\n     * @param possibleParentTable Table\n     * @return boolean\n     */\n    public boolean pointsTo(Table possibleParentTable) {\n        return possibleParentTable.equals(parentTable);\n    }\n\n    public boolean isImplied() {\n        return implied;\n    }\n\n    /**\n     * By default a parent edge connects to the column name...this lets you\n     * connect it the parent's type column instead (e.g. for detailed parents)\n     *\n     * Yes, I need to find a more appropriate name/metaphor for this method....\n     */\n    public void connectToParentDetails() {\n        parentPort = parentColumn.getName() + \".type\";\n    }\n\n    public void connectToParentTitle() {\n        //parentPort = parentColumn.getTable().getName() + \".heading\";\n        parentPort = \"elipses\";\n    }\n\n    public void connectToChildTitle() {\n        //childPort = childColumn.getTable().getName() + \".heading\";\n        childPort = \"elipses\";\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder edge = new StringBuilder();\n        edge.append(\"  \\\"\");\n        if (childTable.isRemote()) {\n            edge.append(childTable.getContainer());\n            edge.append('.');\n        }\n        edge.append(childTable.getName());\n        edge.append(\"\\\":\\\"\");\n        edge.append(childPort);\n        edge.append(\"\\\":\");\n        if (bottomJustify)\n            edge.append(\"s\");\n        edge.append(\"w -> \\\"\");\n        if (parentTable.isRemote()) {\n            edge.append(parentTable.getContainer());\n            edge.append('.');\n        }\n        edge.append(parentTable.getName());\n        edge.append(\"\\\":\\\"\");\n        edge.append(parentPort);\n        edge.append(\"\\\":\");\n        if (bottomJustify)\n            edge.append(\"s\");\n        edge.append(\"e \");\n        // if enabled makes the diagram unreadable\n        // have to figure out how to render these details in a readable manner\n        final boolean fullErNotation = false;\n        // Thanks to Dan Zingaro for figuring out how to correctly annotate\n        // these relationships\n        if (fullErNotation) {\n            // PK end of connector\n            edge.append(\"[arrowhead=\");\n            if (childColumn.isNullable())\n                // zero or one parents\n                edge.append(\"odottee\");\n            else\n                // one parent\n                edge.append(\"teetee\");\n            edge.append(\" dir=both\");\n        } else {\n            // PK end of connector\n            edge.append(\"[arrowhead=none\");\n            edge.append(\" dir=back\");\n        }\n        // FK end of connector\n        edge.append(\" arrowtail=\");\n        if (childColumn.isUnique())\n            // zero or one children\n            edge.append(\"teeodot\");\n        else\n            // zero or more children\n            edge.append(\"crowodot\");\n        if (implied)\n            edge.append(\" style=dashed\");\n        edge.append(\"];\");\n        return edge.toString();\n    }\n\n    public int compareTo(DotConnector other) {\n        int rc = childTable.compareTo(other.childTable);\n        if (rc == 0)\n            rc = childColumn.getName().compareToIgnoreCase(other.childColumn.getName());\n        if (rc == 0)\n            rc = parentTable.compareTo(other.parentTable);\n        if (rc == 0)\n            rc = parentColumn.getName().compareToIgnoreCase(other.parentColumn.getName());\n        if (rc == 0 && implied != other.implied)\n            rc = implied ? 1 : -1;\n        return rc;\n    }\n\n    @Override\n    public boolean equals(Object other) {\n        if (!(other instanceof DotConnector))\n            return false;\n        return compareTo((DotConnector) other) == 0;\n    }\n\n    @Override\n    public int hashCode() {\n        int p = parentTable == null ? 0 : parentTable.getName().hashCode();\n        int c = childTable == null ? 0 : childTable.getName().hashCode();\n        return (p << 16) & c;\n    }\n\n    public TableColumn getParentColumn() {\n        return parentColumn;\n    }\n\n    public Table getParentTable() {\n        return parentTable;\n    }\n\n    public TableColumn getChildColumn() {\n        return childColumn;\n    }\n\n    public Table getChildTable() {\n        return childTable;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/DotConnectorTest1.java",
		"test_prompt": "// DotConnectorTest1.java\npackage net.sourceforge.schemaspy.view;\n\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.util.Dot;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DotConnector}.\n* It contains ten unit test cases for the {@link DotConnector#isImplied()} method.\n*/\nclass DotConnectorTest1 {"
	},
	{
		"original_code": "// DotConnector.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.view;\n\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.util.Dot;\n\n/**\n * Represents Graphvis dot's concept of an edge.  That is, a connector between two nodes.\n *\n * @author John Currier\n */\npublic class DotConnector implements Comparable<DotConnector> {\n\n    private final TableColumn parentColumn;\n\n    private final Table parentTable;\n\n    private final TableColumn childColumn;\n\n    private final Table childTable;\n\n    private final boolean implied;\n\n    private final boolean bottomJustify;\n\n    private String parentPort;\n\n    private String childPort;\n\n    /**\n     * Create an edge that logically connects a child column to a parent column.\n     *\n     * @param parentColumn TableColumn\n     * @param childColumn TableColumn\n     * @param implied boolean\n     */\n    public DotConnector(TableColumn parentColumn, TableColumn childColumn, boolean implied) {\n        this.parentColumn = parentColumn;\n        this.childColumn = childColumn;\n        this.implied = implied;\n        parentPort = parentColumn.getName();\n        parentTable = parentColumn.getTable();\n        childPort = childColumn.getName();\n        childTable = childColumn.getTable();\n        bottomJustify = !Dot.getInstance().supportsCenteredEastWestEdges();\n    }\n\n    /**\n     * Returns true if this edge logically \"points to\" the specified table\n     *\n     * @param possibleParentTable Table\n     * @return boolean\n     */\n    public boolean pointsTo(Table possibleParentTable) {\n        return possibleParentTable.equals(parentTable);\n    }\n\n    public boolean isImplied() {\n        return implied;\n    }\n\n    /**\n     * By default a parent edge connects to the column name...this lets you\n     * connect it the parent's type column instead (e.g. for detailed parents)\n     *\n     * Yes, I need to find a more appropriate name/metaphor for this method....\n     */\n    public void connectToParentDetails() {\n        parentPort = parentColumn.getName() + \".type\";\n    }\n\n    public void connectToParentTitle() {\n        //parentPort = parentColumn.getTable().getName() + \".heading\";\n        parentPort = \"elipses\";\n    }\n\n    public void connectToChildTitle() {\n        //childPort = childColumn.getTable().getName() + \".heading\";\n        childPort = \"elipses\";\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder edge = new StringBuilder();\n        edge.append(\"  \\\"\");\n        if (childTable.isRemote()) {\n            edge.append(childTable.getContainer());\n            edge.append('.');\n        }\n        edge.append(childTable.getName());\n        edge.append(\"\\\":\\\"\");\n        edge.append(childPort);\n        edge.append(\"\\\":\");\n        if (bottomJustify)\n            edge.append(\"s\");\n        edge.append(\"w -> \\\"\");\n        if (parentTable.isRemote()) {\n            edge.append(parentTable.getContainer());\n            edge.append('.');\n        }\n        edge.append(parentTable.getName());\n        edge.append(\"\\\":\\\"\");\n        edge.append(parentPort);\n        edge.append(\"\\\":\");\n        if (bottomJustify)\n            edge.append(\"s\");\n        edge.append(\"e \");\n        // if enabled makes the diagram unreadable\n        // have to figure out how to render these details in a readable manner\n        final boolean fullErNotation = false;\n        // Thanks to Dan Zingaro for figuring out how to correctly annotate\n        // these relationships\n        if (fullErNotation) {\n            // PK end of connector\n            edge.append(\"[arrowhead=\");\n            if (childColumn.isNullable())\n                // zero or one parents\n                edge.append(\"odottee\");\n            else\n                // one parent\n                edge.append(\"teetee\");\n            edge.append(\" dir=both\");\n        } else {\n            // PK end of connector\n            edge.append(\"[arrowhead=none\");\n            edge.append(\" dir=back\");\n        }\n        // FK end of connector\n        edge.append(\" arrowtail=\");\n        if (childColumn.isUnique())\n            // zero or one children\n            edge.append(\"teeodot\");\n        else\n            // zero or more children\n            edge.append(\"crowodot\");\n        if (implied)\n            edge.append(\" style=dashed\");\n        edge.append(\"];\");\n        return edge.toString();\n    }\n\n    public int compareTo(DotConnector other) {\n        int rc = childTable.compareTo(other.childTable);\n        if (rc == 0)\n            rc = childColumn.getName().compareToIgnoreCase(other.childColumn.getName());\n        if (rc == 0)\n            rc = parentTable.compareTo(other.parentTable);\n        if (rc == 0)\n            rc = parentColumn.getName().compareToIgnoreCase(other.parentColumn.getName());\n        if (rc == 0 && implied != other.implied)\n            rc = implied ? 1 : -1;\n        return rc;\n    }\n\n    @Override\n    public boolean equals(Object other) {\n        if (!(other instanceof DotConnector))\n            return false;\n        return compareTo((DotConnector) other) == 0;\n    }\n\n    @Override\n    public int hashCode() {\n        int p = parentTable == null ? 0 : parentTable.getName().hashCode();\n        int c = childTable == null ? 0 : childTable.getName().hashCode();\n        return (p << 16) & c;\n    }\n\n    public TableColumn getParentColumn() {\n        return parentColumn;\n    }\n\n    public Table getParentTable() {\n        return parentTable;\n    }\n\n    public TableColumn getChildColumn() {\n        return childColumn;\n    }\n\n    public Table getChildTable() {\n        return childTable;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/DotConnectorTest2.java",
		"test_prompt": "// DotConnectorTest2.java\npackage net.sourceforge.schemaspy.view;\n\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.util.Dot;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DotConnector}.\n* It contains ten unit test cases for the {@link DotConnector#compareTo(DotConnector)} method.\n*/\nclass DotConnectorTest2 {"
	},
	{
		"original_code": "// DotConnector.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.view;\n\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.util.Dot;\n\n/**\n * Represents Graphvis dot's concept of an edge.  That is, a connector between two nodes.\n *\n * @author John Currier\n */\npublic class DotConnector implements Comparable<DotConnector> {\n\n    private final TableColumn parentColumn;\n\n    private final Table parentTable;\n\n    private final TableColumn childColumn;\n\n    private final Table childTable;\n\n    private final boolean implied;\n\n    private final boolean bottomJustify;\n\n    private String parentPort;\n\n    private String childPort;\n\n    /**\n     * Create an edge that logically connects a child column to a parent column.\n     *\n     * @param parentColumn TableColumn\n     * @param childColumn TableColumn\n     * @param implied boolean\n     */\n    public DotConnector(TableColumn parentColumn, TableColumn childColumn, boolean implied) {\n        this.parentColumn = parentColumn;\n        this.childColumn = childColumn;\n        this.implied = implied;\n        parentPort = parentColumn.getName();\n        parentTable = parentColumn.getTable();\n        childPort = childColumn.getName();\n        childTable = childColumn.getTable();\n        bottomJustify = !Dot.getInstance().supportsCenteredEastWestEdges();\n    }\n\n    /**\n     * Returns true if this edge logically \"points to\" the specified table\n     *\n     * @param possibleParentTable Table\n     * @return boolean\n     */\n    public boolean pointsTo(Table possibleParentTable) {\n        return possibleParentTable.equals(parentTable);\n    }\n\n    public boolean isImplied() {\n        return implied;\n    }\n\n    /**\n     * By default a parent edge connects to the column name...this lets you\n     * connect it the parent's type column instead (e.g. for detailed parents)\n     *\n     * Yes, I need to find a more appropriate name/metaphor for this method....\n     */\n    public void connectToParentDetails() {\n        parentPort = parentColumn.getName() + \".type\";\n    }\n\n    public void connectToParentTitle() {\n        //parentPort = parentColumn.getTable().getName() + \".heading\";\n        parentPort = \"elipses\";\n    }\n\n    public void connectToChildTitle() {\n        //childPort = childColumn.getTable().getName() + \".heading\";\n        childPort = \"elipses\";\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder edge = new StringBuilder();\n        edge.append(\"  \\\"\");\n        if (childTable.isRemote()) {\n            edge.append(childTable.getContainer());\n            edge.append('.');\n        }\n        edge.append(childTable.getName());\n        edge.append(\"\\\":\\\"\");\n        edge.append(childPort);\n        edge.append(\"\\\":\");\n        if (bottomJustify)\n            edge.append(\"s\");\n        edge.append(\"w -> \\\"\");\n        if (parentTable.isRemote()) {\n            edge.append(parentTable.getContainer());\n            edge.append('.');\n        }\n        edge.append(parentTable.getName());\n        edge.append(\"\\\":\\\"\");\n        edge.append(parentPort);\n        edge.append(\"\\\":\");\n        if (bottomJustify)\n            edge.append(\"s\");\n        edge.append(\"e \");\n        // if enabled makes the diagram unreadable\n        // have to figure out how to render these details in a readable manner\n        final boolean fullErNotation = false;\n        // Thanks to Dan Zingaro for figuring out how to correctly annotate\n        // these relationships\n        if (fullErNotation) {\n            // PK end of connector\n            edge.append(\"[arrowhead=\");\n            if (childColumn.isNullable())\n                // zero or one parents\n                edge.append(\"odottee\");\n            else\n                // one parent\n                edge.append(\"teetee\");\n            edge.append(\" dir=both\");\n        } else {\n            // PK end of connector\n            edge.append(\"[arrowhead=none\");\n            edge.append(\" dir=back\");\n        }\n        // FK end of connector\n        edge.append(\" arrowtail=\");\n        if (childColumn.isUnique())\n            // zero or one children\n            edge.append(\"teeodot\");\n        else\n            // zero or more children\n            edge.append(\"crowodot\");\n        if (implied)\n            edge.append(\" style=dashed\");\n        edge.append(\"];\");\n        return edge.toString();\n    }\n\n    public int compareTo(DotConnector other) {\n        int rc = childTable.compareTo(other.childTable);\n        if (rc == 0)\n            rc = childColumn.getName().compareToIgnoreCase(other.childColumn.getName());\n        if (rc == 0)\n            rc = parentTable.compareTo(other.parentTable);\n        if (rc == 0)\n            rc = parentColumn.getName().compareToIgnoreCase(other.parentColumn.getName());\n        if (rc == 0 && implied != other.implied)\n            rc = implied ? 1 : -1;\n        return rc;\n    }\n\n    @Override\n    public boolean equals(Object other) {\n        if (!(other instanceof DotConnector))\n            return false;\n        return compareTo((DotConnector) other) == 0;\n    }\n\n    @Override\n    public int hashCode() {\n        int p = parentTable == null ? 0 : parentTable.getName().hashCode();\n        int c = childTable == null ? 0 : childTable.getName().hashCode();\n        return (p << 16) & c;\n    }\n\n    public TableColumn getParentColumn() {\n        return parentColumn;\n    }\n\n    public Table getParentTable() {\n        return parentTable;\n    }\n\n    public TableColumn getChildColumn() {\n        return childColumn;\n    }\n\n    public Table getChildTable() {\n        return childTable;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/DotConnectorTest3.java",
		"test_prompt": "// DotConnectorTest3.java\npackage net.sourceforge.schemaspy.view;\n\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.util.Dot;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DotConnector}.\n* It contains ten unit test cases for the {@link DotConnector#equals(Object)} method.\n*/\nclass DotConnectorTest3 {"
	},
	{
		"original_code": "// DotConnector.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.view;\n\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.util.Dot;\n\n/**\n * Represents Graphvis dot's concept of an edge.  That is, a connector between two nodes.\n *\n * @author John Currier\n */\npublic class DotConnector implements Comparable<DotConnector> {\n\n    private final TableColumn parentColumn;\n\n    private final Table parentTable;\n\n    private final TableColumn childColumn;\n\n    private final Table childTable;\n\n    private final boolean implied;\n\n    private final boolean bottomJustify;\n\n    private String parentPort;\n\n    private String childPort;\n\n    /**\n     * Create an edge that logically connects a child column to a parent column.\n     *\n     * @param parentColumn TableColumn\n     * @param childColumn TableColumn\n     * @param implied boolean\n     */\n    public DotConnector(TableColumn parentColumn, TableColumn childColumn, boolean implied) {\n        this.parentColumn = parentColumn;\n        this.childColumn = childColumn;\n        this.implied = implied;\n        parentPort = parentColumn.getName();\n        parentTable = parentColumn.getTable();\n        childPort = childColumn.getName();\n        childTable = childColumn.getTable();\n        bottomJustify = !Dot.getInstance().supportsCenteredEastWestEdges();\n    }\n\n    /**\n     * Returns true if this edge logically \"points to\" the specified table\n     *\n     * @param possibleParentTable Table\n     * @return boolean\n     */\n    public boolean pointsTo(Table possibleParentTable) {\n        return possibleParentTable.equals(parentTable);\n    }\n\n    public boolean isImplied() {\n        return implied;\n    }\n\n    /**\n     * By default a parent edge connects to the column name...this lets you\n     * connect it the parent's type column instead (e.g. for detailed parents)\n     *\n     * Yes, I need to find a more appropriate name/metaphor for this method....\n     */\n    public void connectToParentDetails() {\n        parentPort = parentColumn.getName() + \".type\";\n    }\n\n    public void connectToParentTitle() {\n        //parentPort = parentColumn.getTable().getName() + \".heading\";\n        parentPort = \"elipses\";\n    }\n\n    public void connectToChildTitle() {\n        //childPort = childColumn.getTable().getName() + \".heading\";\n        childPort = \"elipses\";\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder edge = new StringBuilder();\n        edge.append(\"  \\\"\");\n        if (childTable.isRemote()) {\n            edge.append(childTable.getContainer());\n            edge.append('.');\n        }\n        edge.append(childTable.getName());\n        edge.append(\"\\\":\\\"\");\n        edge.append(childPort);\n        edge.append(\"\\\":\");\n        if (bottomJustify)\n            edge.append(\"s\");\n        edge.append(\"w -> \\\"\");\n        if (parentTable.isRemote()) {\n            edge.append(parentTable.getContainer());\n            edge.append('.');\n        }\n        edge.append(parentTable.getName());\n        edge.append(\"\\\":\\\"\");\n        edge.append(parentPort);\n        edge.append(\"\\\":\");\n        if (bottomJustify)\n            edge.append(\"s\");\n        edge.append(\"e \");\n        // if enabled makes the diagram unreadable\n        // have to figure out how to render these details in a readable manner\n        final boolean fullErNotation = false;\n        // Thanks to Dan Zingaro for figuring out how to correctly annotate\n        // these relationships\n        if (fullErNotation) {\n            // PK end of connector\n            edge.append(\"[arrowhead=\");\n            if (childColumn.isNullable())\n                // zero or one parents\n                edge.append(\"odottee\");\n            else\n                // one parent\n                edge.append(\"teetee\");\n            edge.append(\" dir=both\");\n        } else {\n            // PK end of connector\n            edge.append(\"[arrowhead=none\");\n            edge.append(\" dir=back\");\n        }\n        // FK end of connector\n        edge.append(\" arrowtail=\");\n        if (childColumn.isUnique())\n            // zero or one children\n            edge.append(\"teeodot\");\n        else\n            // zero or more children\n            edge.append(\"crowodot\");\n        if (implied)\n            edge.append(\" style=dashed\");\n        edge.append(\"];\");\n        return edge.toString();\n    }\n\n    public int compareTo(DotConnector other) {\n        int rc = childTable.compareTo(other.childTable);\n        if (rc == 0)\n            rc = childColumn.getName().compareToIgnoreCase(other.childColumn.getName());\n        if (rc == 0)\n            rc = parentTable.compareTo(other.parentTable);\n        if (rc == 0)\n            rc = parentColumn.getName().compareToIgnoreCase(other.parentColumn.getName());\n        if (rc == 0 && implied != other.implied)\n            rc = implied ? 1 : -1;\n        return rc;\n    }\n\n    @Override\n    public boolean equals(Object other) {\n        if (!(other instanceof DotConnector))\n            return false;\n        return compareTo((DotConnector) other) == 0;\n    }\n\n    @Override\n    public int hashCode() {\n        int p = parentTable == null ? 0 : parentTable.getName().hashCode();\n        int c = childTable == null ? 0 : childTable.getName().hashCode();\n        return (p << 16) & c;\n    }\n\n    public TableColumn getParentColumn() {\n        return parentColumn;\n    }\n\n    public Table getParentTable() {\n        return parentTable;\n    }\n\n    public TableColumn getChildColumn() {\n        return childColumn;\n    }\n\n    public Table getChildTable() {\n        return childTable;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/DotConnectorTest4.java",
		"test_prompt": "// DotConnectorTest4.java\npackage net.sourceforge.schemaspy.view;\n\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.util.Dot;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DotConnector}.\n* It contains ten unit test cases for the {@link DotConnector#hashCode()} method.\n*/\nclass DotConnectorTest4 {"
	},
	{
		"original_code": "// HtmlConstraintsPage.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport net.sourceforge.schemaspy.DbAnalyzer;\nimport net.sourceforge.schemaspy.model.Database;\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.util.HtmlEncoder;\nimport net.sourceforge.schemaspy.util.LineWriter;\n\n/**\n * The page that lists all of the constraints in the schema\n *\n * @author John Currier\n */\npublic class HtmlConstraintsPage extends HtmlFormatter {\n\n    private static HtmlConstraintsPage instance = new HtmlConstraintsPage();\n\n    private int columnCounter;\n\n    /**\n     * Singleton: Don't allow instantiation\n     */\n    private HtmlConstraintsPage() {\n    }\n\n    /**\n     * Singleton accessor\n     *\n     * @return the singleton instance\n     */\n    public static HtmlConstraintsPage getInstance() {\n        return instance;\n    }\n\n    public void write(Database database, List<ForeignKeyConstraint> constraints, Collection<Table> tables, LineWriter html) throws IOException {\n        writeHeader(database, html);\n        writeForeignKeyConstraints(constraints, html);\n        writeCheckConstraints(tables, html);\n        writeFooter(html);\n    }\n\n    private void writeHeader(Database database, LineWriter html) throws IOException {\n        writeHeader(database, null, \"Constraints\", html);\n        html.writeln(\"<div class='indent'>\");\n    }\n\n    @Override\n    protected void writeFooter(LineWriter html) throws IOException {\n        html.writeln(\"</div>\");\n        super.writeFooter(html);\n    }\n\n    /**\n     * Write specified foreign key constraints\n     *\n     * @param constraints List\n     * @param html LineWriter\n     * @throws IOException\n     */\n    private void writeForeignKeyConstraints(List<ForeignKeyConstraint> constraints, LineWriter html) throws IOException {\n        Set<ForeignKeyConstraint> constraintsByName = new TreeSet<ForeignKeyConstraint>();\n        constraintsByName.addAll(constraints);\n        html.writeln(\"<table width='100%'>\");\n        html.writeln(\"<tr><td class='container' valign='bottom'><b>\");\n        html.write(String.valueOf(constraintsByName.size()));\n        html.writeln(\" Foreign Key Constraints:</b>\");\n        html.writeln(\"</td><td class='container' align='right'>\");\n        if (sourceForgeLogoEnabled())\n            html.writeln(\"  <a href='http://sourceforge.net' target='_blank'><img src='http://sourceforge.net/sflogo.php?group_id=137197&amp;type=1' alt='SourceForge.net' border='0' height='31' width='88'></a>\");\n        html.writeln(\"</td></tr>\");\n        html.writeln(\"</table><br>\");\n        html.writeln(\"<table class='dataTable' border='1' rules='groups'>\");\n        html.writeln(\"<colgroup>\");\n        html.writeln(\"<colgroup>\");\n        html.writeln(\"<colgroup>\");\n        html.writeln(\"<colgroup>\");\n        html.writeln(\"<thead align='left'>\");\n        html.writeln(\"<tr>\");\n        html.writeln(\"  <th>Constraint Name</th>\");\n        html.writeln(\"  <th>Child Column</th>\");\n        html.writeln(\"  <th>Parent Column</th>\");\n        html.writeln(\"  <th>Delete Rule</th>\");\n        html.writeln(\"</tr>\");\n        html.writeln(\"</thead>\");\n        html.writeln(\"<tbody>\");\n        for (ForeignKeyConstraint constraint : constraintsByName) {\n            writeForeignKeyConstraint(constraint, html);\n        }\n        if (constraints.size() == 0) {\n            html.writeln(\" <tr>\");\n            html.writeln(\"  <td class='detail' valign='top' colspan='4'>None detected</td>\");\n            html.writeln(\" </tr>\");\n        }\n        html.writeln(\"</tbody>\");\n        html.writeln(\"</table>\");\n    }\n\n    /**\n     * Write specified foreign key constraint\n     *\n     * @param constraint ForeignKeyConstraint\n     * @param html LineWriter\n     * @throws IOException\n     */\n    private void writeForeignKeyConstraint(ForeignKeyConstraint constraint, LineWriter html) throws IOException {\n        boolean even = columnCounter++ % 2 == 0;\n        if (even)\n            html.writeln(\"  <tr class='even'>\");\n        else\n            html.writeln(\"  <tr class='odd'>\");\n        html.write(\"  <td class='detail'>\");\n        html.write(constraint.getName());\n        html.writeln(\"</td>\");\n        html.write(\"  <td class='detail'>\");\n        for (Iterator<TableColumn> iter = constraint.getChildColumns().iterator(); iter.hasNext(); ) {\n            TableColumn column = iter.next();\n            html.write(\"<a href='tables/\");\n            html.write(urlEncode(column.getTable().getName()));\n            html.write(\".html'>\");\n            html.write(column.getTable().getName());\n            html.write(\"</a>\");\n            html.write(\".\");\n            html.write(column.getName());\n            if (iter.hasNext())\n                html.write(\"<br>\");\n        }\n        html.writeln(\"</td>\");\n        html.write(\"  <td class='detail'>\");\n        for (Iterator<TableColumn> iter = constraint.getParentColumns().iterator(); iter.hasNext(); ) {\n            TableColumn column = iter.next();\n            html.write(\"<a href='tables/\");\n            html.write(urlEncode(column.getTable().getName()));\n            html.write(\".html'>\");\n            html.write(column.getTable().getName());\n            html.write(\"</a>\");\n            html.write(\".\");\n            html.write(column.getName());\n            if (iter.hasNext())\n                html.write(\"<br>\");\n        }\n        html.writeln(\"</td>\");\n        html.write(\"  <td class='detail'>\");\n        String ruleText = constraint.getDeleteRuleDescription();\n        String ruleName = constraint.getDeleteRuleName();\n        html.write(\"<span title='\" + ruleText + \"'>\" + ruleName + \"&nbsp;</span>\");\n        html.writeln(\"</td>\");\n        html.writeln(\" </tr>\");\n    }\n\n    /**\n     * Write check constraints associated with the specified tables\n     *\n     * @param tables Collection\n     * @param html LineWriter\n     * @throws IOException\n     */\n    public void writeCheckConstraints(Collection<Table> tables, LineWriter html) throws IOException {\n        html.writeln(\"<a name='checkConstraints'></a><p>\");\n        html.writeln(\"<b>Check Constraints:</b>\");\n        html.writeln(\"<TABLE class='dataTable' border='1' rules='groups'>\");\n        html.writeln(\"<colgroup>\");\n        html.writeln(\"<colgroup>\");\n        html.writeln(\"<colgroup>\");\n        html.writeln(\"<thead align='left'>\");\n        html.writeln(\"<tr>\");\n        html.writeln(\"  <th>Table</th>\");\n        html.writeln(\"  <th>Constraint Name</th>\");\n        html.writeln(\"  <th>Constraint</th>\");\n        html.writeln(\"</tr>\");\n        html.writeln(\"</thead>\");\n        html.writeln(\"<tbody>\");\n        List<Table> tablesByName = DbAnalyzer.sortTablesByName(new ArrayList<Table>(tables));\n        int constraintsWritten = 0;\n        // iter over all tables...only ones with check constraints will write anything\n        for (Table table : tablesByName) {\n            constraintsWritten += writeCheckConstraints(table, html);\n        }\n        if (constraintsWritten == 0) {\n            html.writeln(\" <tr>\");\n            html.writeln(\"  <td class='detail' valign='top' colspan='3'>None detected</td>\");\n            html.writeln(\" </tr>\");\n        }\n        html.writeln(\"</tbody>\");\n        html.writeln(\"</table>\");\n    }\n\n    /**\n     * Write check constraints associated with the specified table (if any)\n     *\n     * @param table Table\n     * @param html LineWriter\n     * @throws IOException\n     * @return int\n     */\n    private int writeCheckConstraints(Table table, LineWriter html) throws IOException {\n        // constraint name -> text pairs\n        Map<String, String> constraints = table.getCheckConstraints();\n        int constraintsWritten = 0;\n        for (String name : constraints.keySet()) {\n            html.writeln(\" <tr>\");\n            html.write(\"  <td class='detail' valign='top'><a href='tables/\");\n            html.write(urlEncode(table.getName()));\n            html.write(\".html'>\");\n            html.write(table.getName());\n            html.write(\"</a></td>\");\n            html.write(\"  <td class='detail' valign='top'>\");\n            html.write(name);\n            html.writeln(\"</td>\");\n            html.write(\"  <td class='detail'>\");\n            html.write(HtmlEncoder.encodeString(constraints.get(name).toString()));\n            html.writeln(\"</td>\");\n            html.writeln(\" </tr>\");\n            ++constraintsWritten;\n        }\n        return constraintsWritten;\n    }\n\n    @Override\n    protected boolean isConstraintsPage() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/HtmlConstraintsPageTest.java",
		"test_prompt": "// HtmlConstraintsPageTest.java\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport net.sourceforge.schemaspy.DbAnalyzer;\nimport net.sourceforge.schemaspy.model.Database;\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.util.HtmlEncoder;\nimport net.sourceforge.schemaspy.util.LineWriter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HtmlConstraintsPage}.\n* It contains ten unit test cases for the {@link HtmlConstraintsPage#getInstance()} method.\n*/\nclass HtmlConstraintsPageTest {"
	},
	{
		"original_code": "// DotFormatter.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.Revision;\nimport net.sourceforge.schemaspy.model.Database;\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.LineWriter;\nimport net.sourceforge.schemaspy.view.DotNode.DotNodeConfig;\n\n/**\n * Format table data into .dot format to feed to Graphvis' dot program.\n *\n * @author John Currier\n */\npublic class DotFormatter {\n\n    private static DotFormatter instance = new DotFormatter();\n\n    private final int fontSize = Config.getInstance().getFontSize();\n\n    /**\n     * Singleton - prevent creation\n     */\n    private DotFormatter() {\n    }\n\n    public static DotFormatter getInstance() {\n        return instance;\n    }\n\n    /**\n     * Write real relationships (excluding implied) associated with the given table.<p>\n     * Returns a set of the implied constraints that could have been included but weren't.\n     */\n    public Set<ForeignKeyConstraint> writeRealRelationships(Table table, boolean twoDegreesOfSeparation, WriteStats stats, LineWriter dot) throws IOException {\n        return writeRelationships(table, twoDegreesOfSeparation, stats, false, dot);\n    }\n\n    /**\n     * Write implied relationships associated with the given table\n     */\n    public void writeAllRelationships(Table table, boolean twoDegreesOfSeparation, WriteStats stats, LineWriter dot) throws IOException {\n        writeRelationships(table, twoDegreesOfSeparation, stats, true, dot);\n    }\n\n    /**\n     * Write relationships associated with the given table.<p>\n     * Returns a set of the implied constraints that could have been included but weren't.\n     */\n    private Set<ForeignKeyConstraint> writeRelationships(Table table, boolean twoDegreesOfSeparation, WriteStats stats, boolean includeImplied, LineWriter dot) throws IOException {\n        Set<Table> tablesWritten = new HashSet<Table>();\n        Set<ForeignKeyConstraint> skippedImpliedConstraints = new HashSet<ForeignKeyConstraint>();\n        DotConnectorFinder finder = DotConnectorFinder.getInstance();\n        String diagramName = includeImplied ? \"impliedTwoDegreesRelationshipsDiagram\" : (twoDegreesOfSeparation ? \"twoDegreesRelationshipsDiagram\" : \"oneDegreeRelationshipsDiagram\");\n        writeHeader(diagramName, true, dot);\n        Set<Table> relatedTables = getImmediateRelatives(table, true, includeImplied, skippedImpliedConstraints);\n        Set<DotConnector> connectors = new TreeSet<DotConnector>(finder.getRelatedConnectors(table, includeImplied));\n        tablesWritten.add(table);\n        Map<Table, DotNode> nodes = new TreeMap<Table, DotNode>();\n        // write immediate relatives first\n        for (Table relatedTable : relatedTables) {\n            if (!tablesWritten.add(relatedTable))\n                // already written\n                continue;\n            nodes.put(relatedTable, new DotNode(relatedTable, \"\", new DotNodeConfig(false, false)));\n            connectors.addAll(finder.getRelatedConnectors(relatedTable, table, true, includeImplied));\n        }\n        // connect the edges that go directly to the target table\n        // so they go to the target table's type column instead\n        for (DotConnector connector : connectors) {\n            if (connector.pointsTo(table))\n                connector.connectToParentDetails();\n        }\n        Set<Table> allCousins = new HashSet<Table>();\n        Set<DotConnector> allCousinConnectors = new TreeSet<DotConnector>();\n        // next write 'cousins' (2nd degree of separation)\n        if (twoDegreesOfSeparation) {\n            for (Table relatedTable : relatedTables) {\n                Set<Table> cousins = getImmediateRelatives(relatedTable, false, includeImplied, skippedImpliedConstraints);\n                for (Table cousin : cousins) {\n                    if (!tablesWritten.add(cousin))\n                        // already written\n                        continue;\n                    allCousinConnectors.addAll(finder.getRelatedConnectors(cousin, relatedTable, false, includeImplied));\n                    nodes.put(cousin, new DotNode(cousin, false, \"\"));\n                }\n                allCousins.addAll(cousins);\n            }\n        }\n        // glue together any 'participants' that aren't yet connected\n        // note that this is the epitome of nested loops from hell\n        List<Table> participants = new ArrayList<Table>(nodes.keySet());\n        Iterator<Table> iter = participants.iterator();\n        while (iter.hasNext()) {\n            Table participantA = iter.next();\n            // cut down the combos as quickly as possible\n            iter.remove();\n            for (Table participantB : participants) {\n                for (DotConnector connector : finder.getRelatedConnectors(participantA, participantB, false, includeImplied)) {\n                    if (twoDegreesOfSeparation && (allCousins.contains(participantA) || allCousins.contains(participantB))) {\n                        allCousinConnectors.add(connector);\n                    } else {\n                        connectors.add(connector);\n                    }\n                }\n            }\n        }\n        markExcludedColumns(nodes, stats.getExcludedColumns());\n        // now directly connect the loose ends to the title of the\n        // 2nd degree of separation tables\n        for (DotConnector connector : allCousinConnectors) {\n            if (allCousins.contains(connector.getParentTable()) && !relatedTables.contains(connector.getParentTable()))\n                connector.connectToParentTitle();\n            if (allCousins.contains(connector.getChildTable()) && !relatedTables.contains(connector.getChildTable()))\n                connector.connectToChildTitle();\n        }\n        // include the table itself\n        nodes.put(table, new DotNode(table, \"\"));\n        connectors.addAll(allCousinConnectors);\n        for (DotConnector connector : connectors) {\n            if (connector.isImplied()) {\n                DotNode node = nodes.get(connector.getParentTable());\n                if (node != null)\n                    node.setShowImplied(true);\n                node = nodes.get(connector.getChildTable());\n                if (node != null)\n                    node.setShowImplied(true);\n            }\n            dot.writeln(connector.toString());\n        }\n        for (DotNode node : nodes.values()) {\n            dot.writeln(node.toString());\n            stats.wroteTable(node.getTable());\n        }\n        dot.writeln(\"}\");\n        return skippedImpliedConstraints;\n    }\n\n    private Set<Table> getImmediateRelatives(Table table, boolean includeExcluded, boolean includeImplied, Set<ForeignKeyConstraint> skippedImpliedConstraints) {\n        Set<TableColumn> relatedColumns = new HashSet<TableColumn>();\n        for (TableColumn column : table.getColumns()) {\n            if (column.isAllExcluded() || (!includeExcluded && column.isExcluded())) {\n                continue;\n            }\n            for (TableColumn childColumn : column.getChildren()) {\n                if (childColumn.isAllExcluded() || (!includeExcluded && childColumn.isExcluded())) {\n                    continue;\n                }\n                ForeignKeyConstraint constraint = column.getChildConstraint(childColumn);\n                if (includeImplied || !constraint.isImplied())\n                    relatedColumns.add(childColumn);\n                else\n                    skippedImpliedConstraints.add(constraint);\n            }\n            for (TableColumn parentColumn : column.getParents()) {\n                if (parentColumn.isAllExcluded() || (!includeExcluded && parentColumn.isExcluded())) {\n                    continue;\n                }\n                ForeignKeyConstraint constraint = column.getParentConstraint(parentColumn);\n                if (includeImplied || !constraint.isImplied())\n                    relatedColumns.add(parentColumn);\n                else\n                    skippedImpliedConstraints.add(constraint);\n            }\n        }\n        Set<Table> relatedTables = new HashSet<Table>();\n        for (TableColumn column : relatedColumns) relatedTables.add(column.getTable());\n        relatedTables.remove(table);\n        return relatedTables;\n    }\n\n    private void writeHeader(String diagramName, boolean showLabel, LineWriter dot) throws IOException {\n        dot.writeln(\"// dot \" + Dot.getInstance().getVersion() + \" on \" + System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\"));\n        dot.writeln(\"// SchemaSpy rev \" + new Revision());\n        dot.writeln(\"digraph \\\"\" + diagramName + \"\\\" {\");\n        dot.writeln(\"  graph [\");\n        boolean rankdirbug = Config.getInstance().isRankDirBugEnabled();\n        if (!rankdirbug)\n            dot.writeln(\"    rankdir=\\\"RL\\\"\");\n        dot.writeln(\"    bgcolor=\\\"\" + StyleSheet.getInstance().getBodyBackground() + \"\\\"\");\n        if (showLabel) {\n            if (rankdirbug)\n                dot.writeln(\"    label=\\\"\\\\nLayout is significantly better without '-rankdirbug' option\\\"\");\n            else\n                dot.writeln(\"    label=\\\"\\\\nGenerated by SchemaSpy\\\"\");\n            dot.writeln(\"    labeljust=\\\"l\\\"\");\n        }\n        dot.writeln(\"    nodesep=\\\"0.18\\\"\");\n        dot.writeln(\"    ranksep=\\\"0.46\\\"\");\n        dot.writeln(\"    fontname=\\\"\" + Config.getInstance().getFont() + \"\\\"\");\n        dot.writeln(\"    fontsize=\\\"\" + fontSize + \"\\\"\");\n        dot.writeln(\"  ];\");\n        dot.writeln(\"  node [\");\n        dot.writeln(\"    fontname=\\\"\" + Config.getInstance().getFont() + \"\\\"\");\n        dot.writeln(\"    fontsize=\\\"\" + fontSize + \"\\\"\");\n        dot.writeln(\"    shape=\\\"plaintext\\\"\");\n        dot.writeln(\"  ];\");\n        dot.writeln(\"  edge [\");\n        dot.writeln(\"    arrowsize=\\\"0.8\\\"\");\n        dot.writeln(\"  ];\");\n    }\n\n    public void writeRealRelationships(Database db, Collection<Table> tables, boolean compact, boolean showColumns, WriteStats stats, LineWriter dot) throws IOException {\n        writeRelationships(db, tables, compact, showColumns, false, stats, dot);\n    }\n\n    /**\n     * Returns <code>true</code> if it wrote any implied relationships\n     */\n    public boolean writeAllRelationships(Database db, Collection<Table> tables, boolean compact, boolean showColumns, WriteStats stats, LineWriter dot) throws IOException {\n        return writeRelationships(db, tables, compact, showColumns, true, stats, dot);\n    }\n\n    private boolean writeRelationships(Database db, Collection<Table> tables, boolean compact, boolean showColumns, boolean includeImplied, WriteStats stats, LineWriter dot) throws IOException {\n        DotConnectorFinder finder = DotConnectorFinder.getInstance();\n        DotNodeConfig nodeConfig = showColumns ? new DotNodeConfig(!compact, false) : new DotNodeConfig();\n        boolean wroteImplied = false;\n        String diagramName;\n        if (includeImplied) {\n            if (compact)\n                diagramName = \"compactImpliedRelationshipsDiagram\";\n            else\n                diagramName = \"largeImpliedRelationshipsDiagram\";\n        } else {\n            if (compact)\n                diagramName = \"compactRelationshipsDiagram\";\n            else\n                diagramName = \"largeRelationshipsDiagram\";\n        }\n        writeHeader(diagramName, true, dot);\n        Map<Table, DotNode> nodes = new TreeMap<Table, DotNode>();\n        for (Table table : tables) {\n            if (!table.isOrphan(includeImplied)) {\n                nodes.put(table, new DotNode(table, \"tables/\", nodeConfig));\n            }\n        }\n        for (Table table : db.getRemoteTables()) {\n            nodes.put(table, new DotNode(table, \"tables/\", nodeConfig));\n        }\n        Set<DotConnector> connectors = new TreeSet<DotConnector>();\n        for (DotNode node : nodes.values()) {\n            connectors.addAll(finder.getRelatedConnectors(node.getTable(), includeImplied));\n        }\n        markExcludedColumns(nodes, stats.getExcludedColumns());\n        for (DotNode node : nodes.values()) {\n            Table table = node.getTable();\n            dot.writeln(node.toString());\n            stats.wroteTable(table);\n            wroteImplied = wroteImplied || (includeImplied && table.isOrphan(false));\n        }\n        for (DotConnector connector : connectors) {\n            dot.writeln(connector.toString());\n        }\n        dot.writeln(\"}\");\n        return wroteImplied;\n    }\n\n    private void markExcludedColumns(Map<Table, DotNode> nodes, Set<TableColumn> excludedColumns) {\n        for (TableColumn column : excludedColumns) {\n            DotNode node = nodes.get(column.getTable());\n            if (node != null) {\n                node.excludeColumn(column);\n            }\n        }\n    }\n\n    public void writeOrphan(Table table, LineWriter dot) throws IOException {\n        writeHeader(table.getName(), false, dot);\n        dot.writeln(new DotNode(table, true, \"tables/\").toString());\n        dot.writeln(\"}\");\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/DotFormatterTest0.java",
		"test_prompt": "// DotFormatterTest0.java\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.Revision;\nimport net.sourceforge.schemaspy.model.Database;\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.LineWriter;\nimport net.sourceforge.schemaspy.view.DotNode.DotNodeConfig;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DotFormatter}.\n* It contains ten unit test cases for the {@link DotFormatter#getInstance()} method.\n*/\nclass DotFormatterTest0 {"
	},
	{
		"original_code": "// DotFormatter.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.Revision;\nimport net.sourceforge.schemaspy.model.Database;\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.LineWriter;\nimport net.sourceforge.schemaspy.view.DotNode.DotNodeConfig;\n\n/**\n * Format table data into .dot format to feed to Graphvis' dot program.\n *\n * @author John Currier\n */\npublic class DotFormatter {\n\n    private static DotFormatter instance = new DotFormatter();\n\n    private final int fontSize = Config.getInstance().getFontSize();\n\n    /**\n     * Singleton - prevent creation\n     */\n    private DotFormatter() {\n    }\n\n    public static DotFormatter getInstance() {\n        return instance;\n    }\n\n    /**\n     * Write real relationships (excluding implied) associated with the given table.<p>\n     * Returns a set of the implied constraints that could have been included but weren't.\n     */\n    public Set<ForeignKeyConstraint> writeRealRelationships(Table table, boolean twoDegreesOfSeparation, WriteStats stats, LineWriter dot) throws IOException {\n        return writeRelationships(table, twoDegreesOfSeparation, stats, false, dot);\n    }\n\n    /**\n     * Write implied relationships associated with the given table\n     */\n    public void writeAllRelationships(Table table, boolean twoDegreesOfSeparation, WriteStats stats, LineWriter dot) throws IOException {\n        writeRelationships(table, twoDegreesOfSeparation, stats, true, dot);\n    }\n\n    /**\n     * Write relationships associated with the given table.<p>\n     * Returns a set of the implied constraints that could have been included but weren't.\n     */\n    private Set<ForeignKeyConstraint> writeRelationships(Table table, boolean twoDegreesOfSeparation, WriteStats stats, boolean includeImplied, LineWriter dot) throws IOException {\n        Set<Table> tablesWritten = new HashSet<Table>();\n        Set<ForeignKeyConstraint> skippedImpliedConstraints = new HashSet<ForeignKeyConstraint>();\n        DotConnectorFinder finder = DotConnectorFinder.getInstance();\n        String diagramName = includeImplied ? \"impliedTwoDegreesRelationshipsDiagram\" : (twoDegreesOfSeparation ? \"twoDegreesRelationshipsDiagram\" : \"oneDegreeRelationshipsDiagram\");\n        writeHeader(diagramName, true, dot);\n        Set<Table> relatedTables = getImmediateRelatives(table, true, includeImplied, skippedImpliedConstraints);\n        Set<DotConnector> connectors = new TreeSet<DotConnector>(finder.getRelatedConnectors(table, includeImplied));\n        tablesWritten.add(table);\n        Map<Table, DotNode> nodes = new TreeMap<Table, DotNode>();\n        // write immediate relatives first\n        for (Table relatedTable : relatedTables) {\n            if (!tablesWritten.add(relatedTable))\n                // already written\n                continue;\n            nodes.put(relatedTable, new DotNode(relatedTable, \"\", new DotNodeConfig(false, false)));\n            connectors.addAll(finder.getRelatedConnectors(relatedTable, table, true, includeImplied));\n        }\n        // connect the edges that go directly to the target table\n        // so they go to the target table's type column instead\n        for (DotConnector connector : connectors) {\n            if (connector.pointsTo(table))\n                connector.connectToParentDetails();\n        }\n        Set<Table> allCousins = new HashSet<Table>();\n        Set<DotConnector> allCousinConnectors = new TreeSet<DotConnector>();\n        // next write 'cousins' (2nd degree of separation)\n        if (twoDegreesOfSeparation) {\n            for (Table relatedTable : relatedTables) {\n                Set<Table> cousins = getImmediateRelatives(relatedTable, false, includeImplied, skippedImpliedConstraints);\n                for (Table cousin : cousins) {\n                    if (!tablesWritten.add(cousin))\n                        // already written\n                        continue;\n                    allCousinConnectors.addAll(finder.getRelatedConnectors(cousin, relatedTable, false, includeImplied));\n                    nodes.put(cousin, new DotNode(cousin, false, \"\"));\n                }\n                allCousins.addAll(cousins);\n            }\n        }\n        // glue together any 'participants' that aren't yet connected\n        // note that this is the epitome of nested loops from hell\n        List<Table> participants = new ArrayList<Table>(nodes.keySet());\n        Iterator<Table> iter = participants.iterator();\n        while (iter.hasNext()) {\n            Table participantA = iter.next();\n            // cut down the combos as quickly as possible\n            iter.remove();\n            for (Table participantB : participants) {\n                for (DotConnector connector : finder.getRelatedConnectors(participantA, participantB, false, includeImplied)) {\n                    if (twoDegreesOfSeparation && (allCousins.contains(participantA) || allCousins.contains(participantB))) {\n                        allCousinConnectors.add(connector);\n                    } else {\n                        connectors.add(connector);\n                    }\n                }\n            }\n        }\n        markExcludedColumns(nodes, stats.getExcludedColumns());\n        // now directly connect the loose ends to the title of the\n        // 2nd degree of separation tables\n        for (DotConnector connector : allCousinConnectors) {\n            if (allCousins.contains(connector.getParentTable()) && !relatedTables.contains(connector.getParentTable()))\n                connector.connectToParentTitle();\n            if (allCousins.contains(connector.getChildTable()) && !relatedTables.contains(connector.getChildTable()))\n                connector.connectToChildTitle();\n        }\n        // include the table itself\n        nodes.put(table, new DotNode(table, \"\"));\n        connectors.addAll(allCousinConnectors);\n        for (DotConnector connector : connectors) {\n            if (connector.isImplied()) {\n                DotNode node = nodes.get(connector.getParentTable());\n                if (node != null)\n                    node.setShowImplied(true);\n                node = nodes.get(connector.getChildTable());\n                if (node != null)\n                    node.setShowImplied(true);\n            }\n            dot.writeln(connector.toString());\n        }\n        for (DotNode node : nodes.values()) {\n            dot.writeln(node.toString());\n            stats.wroteTable(node.getTable());\n        }\n        dot.writeln(\"}\");\n        return skippedImpliedConstraints;\n    }\n\n    private Set<Table> getImmediateRelatives(Table table, boolean includeExcluded, boolean includeImplied, Set<ForeignKeyConstraint> skippedImpliedConstraints) {\n        Set<TableColumn> relatedColumns = new HashSet<TableColumn>();\n        for (TableColumn column : table.getColumns()) {\n            if (column.isAllExcluded() || (!includeExcluded && column.isExcluded())) {\n                continue;\n            }\n            for (TableColumn childColumn : column.getChildren()) {\n                if (childColumn.isAllExcluded() || (!includeExcluded && childColumn.isExcluded())) {\n                    continue;\n                }\n                ForeignKeyConstraint constraint = column.getChildConstraint(childColumn);\n                if (includeImplied || !constraint.isImplied())\n                    relatedColumns.add(childColumn);\n                else\n                    skippedImpliedConstraints.add(constraint);\n            }\n            for (TableColumn parentColumn : column.getParents()) {\n                if (parentColumn.isAllExcluded() || (!includeExcluded && parentColumn.isExcluded())) {\n                    continue;\n                }\n                ForeignKeyConstraint constraint = column.getParentConstraint(parentColumn);\n                if (includeImplied || !constraint.isImplied())\n                    relatedColumns.add(parentColumn);\n                else\n                    skippedImpliedConstraints.add(constraint);\n            }\n        }\n        Set<Table> relatedTables = new HashSet<Table>();\n        for (TableColumn column : relatedColumns) relatedTables.add(column.getTable());\n        relatedTables.remove(table);\n        return relatedTables;\n    }\n\n    private void writeHeader(String diagramName, boolean showLabel, LineWriter dot) throws IOException {\n        dot.writeln(\"// dot \" + Dot.getInstance().getVersion() + \" on \" + System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\"));\n        dot.writeln(\"// SchemaSpy rev \" + new Revision());\n        dot.writeln(\"digraph \\\"\" + diagramName + \"\\\" {\");\n        dot.writeln(\"  graph [\");\n        boolean rankdirbug = Config.getInstance().isRankDirBugEnabled();\n        if (!rankdirbug)\n            dot.writeln(\"    rankdir=\\\"RL\\\"\");\n        dot.writeln(\"    bgcolor=\\\"\" + StyleSheet.getInstance().getBodyBackground() + \"\\\"\");\n        if (showLabel) {\n            if (rankdirbug)\n                dot.writeln(\"    label=\\\"\\\\nLayout is significantly better without '-rankdirbug' option\\\"\");\n            else\n                dot.writeln(\"    label=\\\"\\\\nGenerated by SchemaSpy\\\"\");\n            dot.writeln(\"    labeljust=\\\"l\\\"\");\n        }\n        dot.writeln(\"    nodesep=\\\"0.18\\\"\");\n        dot.writeln(\"    ranksep=\\\"0.46\\\"\");\n        dot.writeln(\"    fontname=\\\"\" + Config.getInstance().getFont() + \"\\\"\");\n        dot.writeln(\"    fontsize=\\\"\" + fontSize + \"\\\"\");\n        dot.writeln(\"  ];\");\n        dot.writeln(\"  node [\");\n        dot.writeln(\"    fontname=\\\"\" + Config.getInstance().getFont() + \"\\\"\");\n        dot.writeln(\"    fontsize=\\\"\" + fontSize + \"\\\"\");\n        dot.writeln(\"    shape=\\\"plaintext\\\"\");\n        dot.writeln(\"  ];\");\n        dot.writeln(\"  edge [\");\n        dot.writeln(\"    arrowsize=\\\"0.8\\\"\");\n        dot.writeln(\"  ];\");\n    }\n\n    public void writeRealRelationships(Database db, Collection<Table> tables, boolean compact, boolean showColumns, WriteStats stats, LineWriter dot) throws IOException {\n        writeRelationships(db, tables, compact, showColumns, false, stats, dot);\n    }\n\n    /**\n     * Returns <code>true</code> if it wrote any implied relationships\n     */\n    public boolean writeAllRelationships(Database db, Collection<Table> tables, boolean compact, boolean showColumns, WriteStats stats, LineWriter dot) throws IOException {\n        return writeRelationships(db, tables, compact, showColumns, true, stats, dot);\n    }\n\n    private boolean writeRelationships(Database db, Collection<Table> tables, boolean compact, boolean showColumns, boolean includeImplied, WriteStats stats, LineWriter dot) throws IOException {\n        DotConnectorFinder finder = DotConnectorFinder.getInstance();\n        DotNodeConfig nodeConfig = showColumns ? new DotNodeConfig(!compact, false) : new DotNodeConfig();\n        boolean wroteImplied = false;\n        String diagramName;\n        if (includeImplied) {\n            if (compact)\n                diagramName = \"compactImpliedRelationshipsDiagram\";\n            else\n                diagramName = \"largeImpliedRelationshipsDiagram\";\n        } else {\n            if (compact)\n                diagramName = \"compactRelationshipsDiagram\";\n            else\n                diagramName = \"largeRelationshipsDiagram\";\n        }\n        writeHeader(diagramName, true, dot);\n        Map<Table, DotNode> nodes = new TreeMap<Table, DotNode>();\n        for (Table table : tables) {\n            if (!table.isOrphan(includeImplied)) {\n                nodes.put(table, new DotNode(table, \"tables/\", nodeConfig));\n            }\n        }\n        for (Table table : db.getRemoteTables()) {\n            nodes.put(table, new DotNode(table, \"tables/\", nodeConfig));\n        }\n        Set<DotConnector> connectors = new TreeSet<DotConnector>();\n        for (DotNode node : nodes.values()) {\n            connectors.addAll(finder.getRelatedConnectors(node.getTable(), includeImplied));\n        }\n        markExcludedColumns(nodes, stats.getExcludedColumns());\n        for (DotNode node : nodes.values()) {\n            Table table = node.getTable();\n            dot.writeln(node.toString());\n            stats.wroteTable(table);\n            wroteImplied = wroteImplied || (includeImplied && table.isOrphan(false));\n        }\n        for (DotConnector connector : connectors) {\n            dot.writeln(connector.toString());\n        }\n        dot.writeln(\"}\");\n        return wroteImplied;\n    }\n\n    private void markExcludedColumns(Map<Table, DotNode> nodes, Set<TableColumn> excludedColumns) {\n        for (TableColumn column : excludedColumns) {\n            DotNode node = nodes.get(column.getTable());\n            if (node != null) {\n                node.excludeColumn(column);\n            }\n        }\n    }\n\n    public void writeOrphan(Table table, LineWriter dot) throws IOException {\n        writeHeader(table.getName(), false, dot);\n        dot.writeln(new DotNode(table, true, \"tables/\").toString());\n        dot.writeln(\"}\");\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/DotFormatterTest1.java",
		"test_prompt": "// DotFormatterTest1.java\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.Revision;\nimport net.sourceforge.schemaspy.model.Database;\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.LineWriter;\nimport net.sourceforge.schemaspy.view.DotNode.DotNodeConfig;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DotFormatter}.\n* It contains ten unit test cases for the {@link DotFormatter#writeRealRelationships(Table, boolean, WriteStats, LineWriter)} method.\n*/\nclass DotFormatterTest1 {"
	},
	{
		"original_code": "// DotFormatter.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.Revision;\nimport net.sourceforge.schemaspy.model.Database;\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.LineWriter;\nimport net.sourceforge.schemaspy.view.DotNode.DotNodeConfig;\n\n/**\n * Format table data into .dot format to feed to Graphvis' dot program.\n *\n * @author John Currier\n */\npublic class DotFormatter {\n\n    private static DotFormatter instance = new DotFormatter();\n\n    private final int fontSize = Config.getInstance().getFontSize();\n\n    /**\n     * Singleton - prevent creation\n     */\n    private DotFormatter() {\n    }\n\n    public static DotFormatter getInstance() {\n        return instance;\n    }\n\n    /**\n     * Write real relationships (excluding implied) associated with the given table.<p>\n     * Returns a set of the implied constraints that could have been included but weren't.\n     */\n    public Set<ForeignKeyConstraint> writeRealRelationships(Table table, boolean twoDegreesOfSeparation, WriteStats stats, LineWriter dot) throws IOException {\n        return writeRelationships(table, twoDegreesOfSeparation, stats, false, dot);\n    }\n\n    /**\n     * Write implied relationships associated with the given table\n     */\n    public void writeAllRelationships(Table table, boolean twoDegreesOfSeparation, WriteStats stats, LineWriter dot) throws IOException {\n        writeRelationships(table, twoDegreesOfSeparation, stats, true, dot);\n    }\n\n    /**\n     * Write relationships associated with the given table.<p>\n     * Returns a set of the implied constraints that could have been included but weren't.\n     */\n    private Set<ForeignKeyConstraint> writeRelationships(Table table, boolean twoDegreesOfSeparation, WriteStats stats, boolean includeImplied, LineWriter dot) throws IOException {\n        Set<Table> tablesWritten = new HashSet<Table>();\n        Set<ForeignKeyConstraint> skippedImpliedConstraints = new HashSet<ForeignKeyConstraint>();\n        DotConnectorFinder finder = DotConnectorFinder.getInstance();\n        String diagramName = includeImplied ? \"impliedTwoDegreesRelationshipsDiagram\" : (twoDegreesOfSeparation ? \"twoDegreesRelationshipsDiagram\" : \"oneDegreeRelationshipsDiagram\");\n        writeHeader(diagramName, true, dot);\n        Set<Table> relatedTables = getImmediateRelatives(table, true, includeImplied, skippedImpliedConstraints);\n        Set<DotConnector> connectors = new TreeSet<DotConnector>(finder.getRelatedConnectors(table, includeImplied));\n        tablesWritten.add(table);\n        Map<Table, DotNode> nodes = new TreeMap<Table, DotNode>();\n        // write immediate relatives first\n        for (Table relatedTable : relatedTables) {\n            if (!tablesWritten.add(relatedTable))\n                // already written\n                continue;\n            nodes.put(relatedTable, new DotNode(relatedTable, \"\", new DotNodeConfig(false, false)));\n            connectors.addAll(finder.getRelatedConnectors(relatedTable, table, true, includeImplied));\n        }\n        // connect the edges that go directly to the target table\n        // so they go to the target table's type column instead\n        for (DotConnector connector : connectors) {\n            if (connector.pointsTo(table))\n                connector.connectToParentDetails();\n        }\n        Set<Table> allCousins = new HashSet<Table>();\n        Set<DotConnector> allCousinConnectors = new TreeSet<DotConnector>();\n        // next write 'cousins' (2nd degree of separation)\n        if (twoDegreesOfSeparation) {\n            for (Table relatedTable : relatedTables) {\n                Set<Table> cousins = getImmediateRelatives(relatedTable, false, includeImplied, skippedImpliedConstraints);\n                for (Table cousin : cousins) {\n                    if (!tablesWritten.add(cousin))\n                        // already written\n                        continue;\n                    allCousinConnectors.addAll(finder.getRelatedConnectors(cousin, relatedTable, false, includeImplied));\n                    nodes.put(cousin, new DotNode(cousin, false, \"\"));\n                }\n                allCousins.addAll(cousins);\n            }\n        }\n        // glue together any 'participants' that aren't yet connected\n        // note that this is the epitome of nested loops from hell\n        List<Table> participants = new ArrayList<Table>(nodes.keySet());\n        Iterator<Table> iter = participants.iterator();\n        while (iter.hasNext()) {\n            Table participantA = iter.next();\n            // cut down the combos as quickly as possible\n            iter.remove();\n            for (Table participantB : participants) {\n                for (DotConnector connector : finder.getRelatedConnectors(participantA, participantB, false, includeImplied)) {\n                    if (twoDegreesOfSeparation && (allCousins.contains(participantA) || allCousins.contains(participantB))) {\n                        allCousinConnectors.add(connector);\n                    } else {\n                        connectors.add(connector);\n                    }\n                }\n            }\n        }\n        markExcludedColumns(nodes, stats.getExcludedColumns());\n        // now directly connect the loose ends to the title of the\n        // 2nd degree of separation tables\n        for (DotConnector connector : allCousinConnectors) {\n            if (allCousins.contains(connector.getParentTable()) && !relatedTables.contains(connector.getParentTable()))\n                connector.connectToParentTitle();\n            if (allCousins.contains(connector.getChildTable()) && !relatedTables.contains(connector.getChildTable()))\n                connector.connectToChildTitle();\n        }\n        // include the table itself\n        nodes.put(table, new DotNode(table, \"\"));\n        connectors.addAll(allCousinConnectors);\n        for (DotConnector connector : connectors) {\n            if (connector.isImplied()) {\n                DotNode node = nodes.get(connector.getParentTable());\n                if (node != null)\n                    node.setShowImplied(true);\n                node = nodes.get(connector.getChildTable());\n                if (node != null)\n                    node.setShowImplied(true);\n            }\n            dot.writeln(connector.toString());\n        }\n        for (DotNode node : nodes.values()) {\n            dot.writeln(node.toString());\n            stats.wroteTable(node.getTable());\n        }\n        dot.writeln(\"}\");\n        return skippedImpliedConstraints;\n    }\n\n    private Set<Table> getImmediateRelatives(Table table, boolean includeExcluded, boolean includeImplied, Set<ForeignKeyConstraint> skippedImpliedConstraints) {\n        Set<TableColumn> relatedColumns = new HashSet<TableColumn>();\n        for (TableColumn column : table.getColumns()) {\n            if (column.isAllExcluded() || (!includeExcluded && column.isExcluded())) {\n                continue;\n            }\n            for (TableColumn childColumn : column.getChildren()) {\n                if (childColumn.isAllExcluded() || (!includeExcluded && childColumn.isExcluded())) {\n                    continue;\n                }\n                ForeignKeyConstraint constraint = column.getChildConstraint(childColumn);\n                if (includeImplied || !constraint.isImplied())\n                    relatedColumns.add(childColumn);\n                else\n                    skippedImpliedConstraints.add(constraint);\n            }\n            for (TableColumn parentColumn : column.getParents()) {\n                if (parentColumn.isAllExcluded() || (!includeExcluded && parentColumn.isExcluded())) {\n                    continue;\n                }\n                ForeignKeyConstraint constraint = column.getParentConstraint(parentColumn);\n                if (includeImplied || !constraint.isImplied())\n                    relatedColumns.add(parentColumn);\n                else\n                    skippedImpliedConstraints.add(constraint);\n            }\n        }\n        Set<Table> relatedTables = new HashSet<Table>();\n        for (TableColumn column : relatedColumns) relatedTables.add(column.getTable());\n        relatedTables.remove(table);\n        return relatedTables;\n    }\n\n    private void writeHeader(String diagramName, boolean showLabel, LineWriter dot) throws IOException {\n        dot.writeln(\"// dot \" + Dot.getInstance().getVersion() + \" on \" + System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\"));\n        dot.writeln(\"// SchemaSpy rev \" + new Revision());\n        dot.writeln(\"digraph \\\"\" + diagramName + \"\\\" {\");\n        dot.writeln(\"  graph [\");\n        boolean rankdirbug = Config.getInstance().isRankDirBugEnabled();\n        if (!rankdirbug)\n            dot.writeln(\"    rankdir=\\\"RL\\\"\");\n        dot.writeln(\"    bgcolor=\\\"\" + StyleSheet.getInstance().getBodyBackground() + \"\\\"\");\n        if (showLabel) {\n            if (rankdirbug)\n                dot.writeln(\"    label=\\\"\\\\nLayout is significantly better without '-rankdirbug' option\\\"\");\n            else\n                dot.writeln(\"    label=\\\"\\\\nGenerated by SchemaSpy\\\"\");\n            dot.writeln(\"    labeljust=\\\"l\\\"\");\n        }\n        dot.writeln(\"    nodesep=\\\"0.18\\\"\");\n        dot.writeln(\"    ranksep=\\\"0.46\\\"\");\n        dot.writeln(\"    fontname=\\\"\" + Config.getInstance().getFont() + \"\\\"\");\n        dot.writeln(\"    fontsize=\\\"\" + fontSize + \"\\\"\");\n        dot.writeln(\"  ];\");\n        dot.writeln(\"  node [\");\n        dot.writeln(\"    fontname=\\\"\" + Config.getInstance().getFont() + \"\\\"\");\n        dot.writeln(\"    fontsize=\\\"\" + fontSize + \"\\\"\");\n        dot.writeln(\"    shape=\\\"plaintext\\\"\");\n        dot.writeln(\"  ];\");\n        dot.writeln(\"  edge [\");\n        dot.writeln(\"    arrowsize=\\\"0.8\\\"\");\n        dot.writeln(\"  ];\");\n    }\n\n    public void writeRealRelationships(Database db, Collection<Table> tables, boolean compact, boolean showColumns, WriteStats stats, LineWriter dot) throws IOException {\n        writeRelationships(db, tables, compact, showColumns, false, stats, dot);\n    }\n\n    /**\n     * Returns <code>true</code> if it wrote any implied relationships\n     */\n    public boolean writeAllRelationships(Database db, Collection<Table> tables, boolean compact, boolean showColumns, WriteStats stats, LineWriter dot) throws IOException {\n        return writeRelationships(db, tables, compact, showColumns, true, stats, dot);\n    }\n\n    private boolean writeRelationships(Database db, Collection<Table> tables, boolean compact, boolean showColumns, boolean includeImplied, WriteStats stats, LineWriter dot) throws IOException {\n        DotConnectorFinder finder = DotConnectorFinder.getInstance();\n        DotNodeConfig nodeConfig = showColumns ? new DotNodeConfig(!compact, false) : new DotNodeConfig();\n        boolean wroteImplied = false;\n        String diagramName;\n        if (includeImplied) {\n            if (compact)\n                diagramName = \"compactImpliedRelationshipsDiagram\";\n            else\n                diagramName = \"largeImpliedRelationshipsDiagram\";\n        } else {\n            if (compact)\n                diagramName = \"compactRelationshipsDiagram\";\n            else\n                diagramName = \"largeRelationshipsDiagram\";\n        }\n        writeHeader(diagramName, true, dot);\n        Map<Table, DotNode> nodes = new TreeMap<Table, DotNode>();\n        for (Table table : tables) {\n            if (!table.isOrphan(includeImplied)) {\n                nodes.put(table, new DotNode(table, \"tables/\", nodeConfig));\n            }\n        }\n        for (Table table : db.getRemoteTables()) {\n            nodes.put(table, new DotNode(table, \"tables/\", nodeConfig));\n        }\n        Set<DotConnector> connectors = new TreeSet<DotConnector>();\n        for (DotNode node : nodes.values()) {\n            connectors.addAll(finder.getRelatedConnectors(node.getTable(), includeImplied));\n        }\n        markExcludedColumns(nodes, stats.getExcludedColumns());\n        for (DotNode node : nodes.values()) {\n            Table table = node.getTable();\n            dot.writeln(node.toString());\n            stats.wroteTable(table);\n            wroteImplied = wroteImplied || (includeImplied && table.isOrphan(false));\n        }\n        for (DotConnector connector : connectors) {\n            dot.writeln(connector.toString());\n        }\n        dot.writeln(\"}\");\n        return wroteImplied;\n    }\n\n    private void markExcludedColumns(Map<Table, DotNode> nodes, Set<TableColumn> excludedColumns) {\n        for (TableColumn column : excludedColumns) {\n            DotNode node = nodes.get(column.getTable());\n            if (node != null) {\n                node.excludeColumn(column);\n            }\n        }\n    }\n\n    public void writeOrphan(Table table, LineWriter dot) throws IOException {\n        writeHeader(table.getName(), false, dot);\n        dot.writeln(new DotNode(table, true, \"tables/\").toString());\n        dot.writeln(\"}\");\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/DotFormatterTest2.java",
		"test_prompt": "// DotFormatterTest2.java\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.Revision;\nimport net.sourceforge.schemaspy.model.Database;\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.LineWriter;\nimport net.sourceforge.schemaspy.view.DotNode.DotNodeConfig;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DotFormatter}.\n* It contains ten unit test cases for the {@link DotFormatter#writeAllRelationships(Database, Collection, boolean, boolean, WriteStats, LineWriter)} method.\n*/\nclass DotFormatterTest2 {"
	},
	{
		"original_code": "// HtmlColumnsPage.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.Database;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.Table.ByColumnIdComparator;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.model.TableIndex;\nimport net.sourceforge.schemaspy.util.LineWriter;\n\n/**\n * The page that lists all of the columns in the schema,\n * allowing the end user to sort by column's attributes.\n *\n * @author John Currier\n */\npublic class HtmlColumnsPage extends HtmlFormatter {\n\n    private static HtmlColumnsPage instance = new HtmlColumnsPage();\n\n    /**\n     * Singleton: Don't allow instantiation\n     */\n    private HtmlColumnsPage() {\n    }\n\n    /**\n     * Singleton accessor\n     *\n     * @return the singleton instance\n     */\n    public static HtmlColumnsPage getInstance() {\n        return instance;\n    }\n\n    /**\n     * Returns details about the columns that are displayed on this page.\n     *\n     * @return\n     */\n    public Map<String, ColumnInfo> getColumnInfos() {\n        // build a collection of all possible column details\n        Map<String, ColumnInfo> avails = new HashMap<String, ColumnInfo>();\n        avails.put(\"id\", new ColumnInfo(\"Id\", new ByColumnIdComparator()));\n        avails.put(\"table\", new ColumnInfo(\"Table\", new ByTableComparator()));\n        avails.put(\"column\", new ColumnInfo(\"Column\", new ByColumnComparator()));\n        avails.put(\"type\", new ColumnInfo(\"Type\", new ByTypeComparator()));\n        avails.put(\"size\", new ColumnInfo(\"Size\", new BySizeComparator()));\n        avails.put(\"nulls\", new ColumnInfo(\"Nulls\", new ByNullableComparator()));\n        avails.put(\"auto\", new ColumnInfo(\"Auto\", new ByAutoUpdateComparator()));\n        avails.put(\"default\", new ColumnInfo(\"Default\", new ByDefaultValueComparator()));\n        avails.put(\"children\", new ColumnInfo(\"Children\", new ByChildrenComparator()));\n        avails.put(\"parents\", new ColumnInfo(\"Parents\", new ByParentsComparator()));\n        avails.put(\"comments\", new ColumnInfo(\"Comments\", new ByCommentsComparator()));\n        // now put the ones requested in the order requested\n        // LinkedHashMap maintains insertion order\n        Map<String, ColumnInfo> infos = new LinkedHashMap<String, ColumnInfo>();\n        for (String detail : Config.getInstance().getColumnDetails()) {\n            ColumnInfo info = avails.get(detail);\n            if (info == null)\n                throw new IllegalArgumentException(\"Undefined column detail requested: '\" + detail + \"'. Valid details: \" + avails.keySet());\n            infos.put(detail, info);\n        }\n        return infos;\n    }\n\n    public class ColumnInfo {\n\n        private final String columnName;\n\n        private final Comparator<TableColumn> comparator;\n\n        private ColumnInfo(String columnName, Comparator<TableColumn> comparator) {\n            this.columnName = columnName;\n            this.comparator = comparator;\n        }\n\n        public String getColumnName() {\n            return columnName;\n        }\n\n        public String getLocation() {\n            return getLocation(columnName);\n        }\n\n        public String getLocation(String colName) {\n            return \"columns.by\" + colName + \".html\";\n        }\n\n        private Comparator<TableColumn> getComparator() {\n            return comparator;\n        }\n\n        @Override\n        public String toString() {\n            return getLocation();\n        }\n    }\n\n    public void write(Database database, Collection<Table> tables, ColumnInfo columnInfo, LineWriter html) throws IOException {\n        Set<TableColumn> columns = new TreeSet<TableColumn>(columnInfo.getComparator());\n        Set<TableColumn> primaryColumns = new HashSet<TableColumn>();\n        Set<TableColumn> indexedColumns = new HashSet<TableColumn>();\n        for (Table table : tables) {\n            columns.addAll(table.getColumns());\n            primaryColumns.addAll(table.getPrimaryColumns());\n            for (TableIndex index : table.getIndexes()) {\n                indexedColumns.addAll(index.getColumns());\n            }\n        }\n        writeHeader(database, columns.size(), columnInfo, html);\n        HtmlTablePage formatter = HtmlTablePage.getInstance();\n        for (TableColumn column : columns) {\n            formatter.writeColumn(column, column.getTable().getName(), primaryColumns, indexedColumns, true, false, html);\n        }\n        writeFooter(html);\n    }\n\n    private void writeHeader(Database db, int numberOfColumns, ColumnInfo selectedColumn, LineWriter html) throws IOException {\n        writeHeader(db, null, \"Columns\", html);\n        html.writeln(\"<table width='100%' border='0'>\");\n        html.writeln(\"<tr><td class='container'>\");\n        writeGeneratedOn(db.getConnectTime(), html);\n        html.writeln(\"</td><td class='container' rowspan='2' align='right' valign='top'>\");\n        writeLegend(false, false, html);\n        html.writeln(\"</td></tr>\");\n        html.writeln(\"<tr valign='top'><td class='container' align='left' valign='top'>\");\n        html.writeln(\"<p>\");\n        html.writeln(\"<form name='options' action=''>\");\n        if (Config.getInstance().getColumnDetails().contains(\"comments\"))\n            html.writeln(\" <label for='showComments'><input type=checkbox id='showComments'>Comments</label>\");\n        html.writeln(\" <label for='showLegend'><input type=checkbox checked id='showLegend'>Legend</label>\");\n        html.writeln(\"</form>\");\n        html.writeln(\"</table>\");\n        html.writeln(\"<div class='indent'>\");\n        html.write(\"<b>\");\n        html.write(db.getName());\n        if (db.getSchema() != null) {\n            html.write('.');\n            html.write(db.getSchema());\n        } else if (db.getCatalog() != null) {\n            html.write('.');\n            html.write(db.getCatalog());\n        }\n        html.write(\" contains \");\n        html.write(String.valueOf(numberOfColumns));\n        html.write(\" columns</b> - click on heading to sort:\");\n        Collection<Table> tables = db.getTables();\n        boolean hasTableIds = tables.size() > 0 && tables.iterator().next().getId() != null;\n        writeMainTableHeader(hasTableIds, selectedColumn, html);\n        html.writeln(\"<tbody valign='top'>\");\n    }\n\n    public void writeMainTableHeader(boolean hasTableIds, ColumnInfo selectedColumn, LineWriter out) throws IOException {\n        boolean onColumnsPage = selectedColumn != null;\n        List<String> details = null;\n        out.writeln(\"<a name='columns'></a>\");\n        out.writeln(\"<table id='columns' class='dataTable' border='1' rules='groups'>\");\n        if (onColumnsPage) {\n            details = new ArrayList<String>(Config.getInstance().getColumnDetails());\n            if (!hasTableIds)\n                // simplify subsequent logic by yanking it now\n                details.remove(\"id\");\n            for (String detail : details) {\n                if (detail.equals(\"comments\"))\n                    out.writeln(\"<colgroup class='comment'>\");\n                else\n                    out.writeln(\"<colgroup>\");\n            }\n        } else {\n            int numCols = hasTableIds ? 9 : 8;\n            for (int i = 0; i < numCols; ++i) {\n                out.writeln(\"<colgroup>\");\n            }\n            out.writeln(\"<colgroup class='comment'>\");\n        }\n        out.writeln(\"<thead align='left'>\");\n        out.writeln(\"<tr>\");\n        if (onColumnsPage) {\n            Map<String, String> headings = new HashMap<String, String>();\n            headings.put(\"id\", getTH(selectedColumn, \"ID\", null, \"right\"));\n            headings.put(\"table\", getTH(selectedColumn, \"Table\", null, null));\n            headings.put(\"column\", getTH(selectedColumn, \"Column\", null, null));\n            headings.put(\"type\", getTH(selectedColumn, \"Type\", null, null));\n            headings.put(\"size\", getTH(selectedColumn, \"Size\", null, null));\n            headings.put(\"nulls\", getTH(selectedColumn, \"Nulls\", \"Are nulls allowed?\", null));\n            headings.put(\"auto\", getTH(selectedColumn, \"Auto\", \"Is column automatically updated?\", null));\n            headings.put(\"default\", getTH(selectedColumn, \"Default\", \"Default value\", null));\n            headings.put(\"children\", getTH(selectedColumn, \"Children\", \"Columns in tables that reference this column\", null));\n            headings.put(\"parents\", getTH(selectedColumn, \"Parents\", \"Columns in tables that are referenced by this column\", null));\n            headings.put(\"comments\", \"<th title='Comments' class='comment'><span class='notSortedByColumn'>Comments</span></th>\");\n            // output the headings in the order specified\n            if (details != null) {\n                // redundant, but keeps compiler happy\n                for (String detail : details) {\n                    out.writeln(headings.get(detail));\n                }\n            }\n        } else {\n            if (hasTableIds)\n                out.writeln(getTH(selectedColumn, \"ID\", null, \"right\"));\n            out.writeln(getTH(selectedColumn, \"Column\", null, null));\n            out.writeln(getTH(selectedColumn, \"Type\", null, null));\n            out.writeln(getTH(selectedColumn, \"Size\", null, null));\n            out.writeln(getTH(selectedColumn, \"Nulls\", \"Are nulls allowed?\", null));\n            out.writeln(getTH(selectedColumn, \"Auto\", \"Is column automatically updated?\", null));\n            out.writeln(getTH(selectedColumn, \"Default\", \"Default value\", null));\n            out.writeln(getTH(selectedColumn, \"Children\", \"Columns in tables that reference this column\", null));\n            out.writeln(getTH(selectedColumn, \"Parents\", \"Columns in tables that are referenced by this column\", null));\n            out.writeln(\"  <th title='Comments' class='comment'><span class='notSortedByColumn'>Comments</span></th>\");\n        }\n        out.writeln(\"</tr>\");\n        out.writeln(\"</thead>\");\n    }\n\n    private String getTH(ColumnInfo selectedColumn, String columnName, String title, String align) {\n        StringBuilder buf = new StringBuilder(\"  <th\");\n        if (align != null) {\n            buf.append(\" align='\");\n            buf.append(align);\n            buf.append(\"'\");\n        }\n        if (title != null) {\n            buf.append(\" title='\");\n            buf.append(title);\n            buf.append(\"'\");\n        }\n        if (selectedColumn != null) {\n            if (selectedColumn.getColumnName().equals(columnName)) {\n                buf.append(\" class='sortedByColumn'>\");\n                buf.append(columnName);\n            } else {\n                buf.append(\" class='notSortedByColumn'>\");\n                buf.append(\"<a href='\");\n                buf.append(selectedColumn.getLocation(columnName));\n                buf.append(\"#columns'><span class='notSortedByColumn'>\");\n                buf.append(columnName);\n                buf.append(\"</span></a>\");\n            }\n        } else {\n            buf.append('>');\n            buf.append(columnName);\n        }\n        buf.append(\"</th>\");\n        return buf.toString();\n    }\n\n    @Override\n    protected void writeFooter(LineWriter html) throws IOException {\n        html.writeln(\"</tbody>\");\n        html.writeln(\"</table>\");\n        html.writeln(\"</div>\");\n        super.writeFooter(html);\n    }\n\n    @Override\n    protected boolean isColumnsPage() {\n        return true;\n    }\n\n    private class ByColumnComparator implements Comparator<TableColumn> {\n\n        public int compare(TableColumn column1, TableColumn column2) {\n            int rc = column1.getName().compareToIgnoreCase(column2.getName());\n            if (rc == 0)\n                rc = column1.getTable().compareTo(column2.getTable());\n            return rc;\n        }\n    }\n\n    private class ByTableComparator implements Comparator<TableColumn> {\n\n        public int compare(TableColumn column1, TableColumn column2) {\n            int rc = column1.getTable().compareTo(column2.getTable());\n            if (rc == 0)\n                rc = column1.getName().compareToIgnoreCase(column2.getName());\n            return rc;\n        }\n    }\n\n    private class ByTypeComparator implements Comparator<TableColumn> {\n\n        private final Comparator<TableColumn> bySize = new BySizeComparator();\n\n        public int compare(TableColumn column1, TableColumn column2) {\n            int rc = column1.getType().compareToIgnoreCase(column2.getType());\n            if (rc == 0) {\n                rc = bySize.compare(column1, column2);\n            }\n            return rc;\n        }\n    }\n\n    private class ByCommentsComparator implements Comparator<TableColumn> {\n\n        private final Comparator<TableColumn> byType = new ByTypeComparator();\n\n        public int compare(TableColumn column1, TableColumn column2) {\n            String comment1 = column1.getComments();\n            if (comment1 == null)\n                comment1 = \"\";\n            String comment2 = column1.getComments();\n            if (comment2 == null)\n                comment2 = \"\";\n            int rc = comment1.compareToIgnoreCase(comment2);\n            if (rc == 0) {\n                rc = byType.compare(column1, column2);\n            }\n            return rc;\n        }\n    }\n\n    private class BySizeComparator implements Comparator<TableColumn> {\n\n        private final Comparator<TableColumn> byColumn = new ByColumnComparator();\n\n        public int compare(TableColumn column1, TableColumn column2) {\n            int rc = column1.getLength() - column2.getLength();\n            if (rc == 0) {\n                rc = column1.getDecimalDigits() - column2.getDecimalDigits();\n                if (rc == 0)\n                    rc = byColumn.compare(column1, column2);\n            }\n            return rc;\n        }\n    }\n\n    private class ByNullableComparator implements Comparator<TableColumn> {\n\n        private final Comparator<TableColumn> byColumn = new ByColumnComparator();\n\n        public int compare(TableColumn column1, TableColumn column2) {\n            int rc = column1.isNullable() == column2.isNullable() ? 0 : column1.isNullable() ? -1 : 1;\n            if (rc == 0)\n                rc = byColumn.compare(column1, column2);\n            return rc;\n        }\n    }\n\n    private class ByAutoUpdateComparator implements Comparator<TableColumn> {\n\n        private final Comparator<TableColumn> byColumn = new ByColumnComparator();\n\n        public int compare(TableColumn column1, TableColumn column2) {\n            int rc = column1.isAutoUpdated() == column2.isAutoUpdated() ? 0 : column1.isAutoUpdated() ? -1 : 1;\n            if (rc == 0)\n                rc = byColumn.compare(column1, column2);\n            return rc;\n        }\n    }\n\n    private class ByDefaultValueComparator implements Comparator<TableColumn> {\n\n        private final Comparator<TableColumn> byNullable = new ByNullableComparator();\n\n        public int compare(TableColumn column1, TableColumn column2) {\n            String value1 = String.valueOf(column1.getDefaultValue());\n            String value2 = String.valueOf(column2.getDefaultValue());\n            int rc = value1.compareToIgnoreCase(value2);\n            if (rc == 0)\n                rc = byNullable.compare(column1, column2);\n            return rc;\n        }\n    }\n\n    private class ByChildrenComparator implements Comparator<TableColumn> {\n\n        private final Comparator<TableColumn> byColumn = new ByColumnComparator();\n\n        public int compare(TableColumn column1, TableColumn column2) {\n            Set<String> childTables1 = new TreeSet<String>();\n            Set<String> childTables2 = new TreeSet<String>();\n            for (TableColumn column : column1.getChildren()) {\n                if (!column.getParentConstraint(column1).isImplied())\n                    childTables1.add(column.getTable().getName());\n            }\n            for (TableColumn column : column2.getChildren()) {\n                if (!column.getParentConstraint(column2).isImplied())\n                    childTables2.add(column.getTable().getName());\n            }\n            int rc = childTables1.toString().compareToIgnoreCase(childTables2.toString());\n            if (rc == 0)\n                rc = byColumn.compare(column1, column2);\n            return rc;\n        }\n    }\n\n    private class ByParentsComparator implements Comparator<TableColumn> {\n\n        private final Comparator<TableColumn> byColumn = new ByColumnComparator();\n\n        public int compare(TableColumn column1, TableColumn column2) {\n            Set<String> parentTables1 = new TreeSet<String>();\n            Set<String> parentTables2 = new TreeSet<String>();\n            for (TableColumn column : column1.getParents()) {\n                if (!column.getChildConstraint(column1).isImplied())\n                    parentTables1.add(column.getTable().getName() + '.' + column.getTable().getSchema());\n            }\n            for (TableColumn column : column2.getParents()) {\n                if (!column.getChildConstraint(column2).isImplied())\n                    parentTables2.add(column.getTable().getName() + '.' + column.getTable().getSchema());\n            }\n            int rc = parentTables1.toString().compareToIgnoreCase(parentTables2.toString());\n            if (rc == 0)\n                rc = byColumn.compare(column1, column2);\n            return rc;\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/HtmlColumnsPageTest.java",
		"test_prompt": "// HtmlColumnsPageTest.java\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.Database;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.Table.ByColumnIdComparator;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.model.TableIndex;\nimport net.sourceforge.schemaspy.util.LineWriter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HtmlColumnsPage}.\n* It contains ten unit test cases for the {@link HtmlColumnsPage#getInstance()} method.\n*/\nclass HtmlColumnsPageTest {"
	},
	{
		"original_code": "// TextFormatter.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.IOException;\nimport java.util.Collection;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.util.LineWriter;\n\npublic class TextFormatter {\n\n    private static TextFormatter instance = new TextFormatter();\n\n    /**\n     * Singleton - prevent creation\n     */\n    private TextFormatter() {\n    }\n\n    public static TextFormatter getInstance() {\n        return instance;\n    }\n\n    public void write(Collection<Table> tables, boolean includeViews, LineWriter out) throws IOException {\n        for (Table table : tables) {\n            if (!table.isView() || includeViews)\n                out.writeln(table.getName());\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/TextFormatterTest.java",
		"test_prompt": "// TextFormatterTest.java\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.IOException;\nimport java.util.Collection;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.util.LineWriter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TextFormatter}.\n* It contains ten unit test cases for the {@link TextFormatter#getInstance()} method.\n*/\nclass TextFormatterTest {"
	},
	{
		"original_code": "// HtmlAnomaliesPage.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.IOException;\nimport java.text.NumberFormat;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport net.sourceforge.schemaspy.DbAnalyzer;\nimport net.sourceforge.schemaspy.model.Database;\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.util.LineWriter;\n\n/**\n * This page lists all of the 'things that might not be quite right'\n * about the schema.\n *\n * @author John Currier\n */\npublic class HtmlAnomaliesPage extends HtmlFormatter {\n\n    private static HtmlAnomaliesPage instance = new HtmlAnomaliesPage();\n\n    /**\n     * Singleton: Don't allow instantiation\n     */\n    private HtmlAnomaliesPage() {\n    }\n\n    /**\n     * Singleton accessor\n     *\n     * @return the singleton instance\n     */\n    public static HtmlAnomaliesPage getInstance() {\n        return instance;\n    }\n\n    public void write(Database database, Collection<Table> tables, List<? extends ForeignKeyConstraint> impliedConstraints, LineWriter out) throws IOException {\n        writeHeader(database, out);\n        writeImpliedConstraints(impliedConstraints, out);\n        writeTablesWithoutIndexes(DbAnalyzer.getTablesWithoutIndexes(new HashSet<Table>(tables)), out);\n        writeUniqueNullables(DbAnalyzer.getMustBeUniqueNullableColumns(new HashSet<Table>(tables)), out);\n        writeTablesWithOneColumn(DbAnalyzer.getTablesWithOneColumn(tables), out);\n        writeTablesWithIncrementingColumnNames(DbAnalyzer.getTablesWithIncrementingColumnNames(tables), out);\n        writeDefaultNullStrings(DbAnalyzer.getDefaultNullStringColumns(new HashSet<Table>(tables)), out);\n        writeFooter(out);\n    }\n\n    private void writeHeader(Database database, LineWriter html) throws IOException {\n        writeHeader(database, null, \"Anomalies\", html);\n        html.writeln(\"<table width='100%'>\");\n        if (sourceForgeLogoEnabled())\n            html.writeln(\"  <tr><td class='container' align='right' valign='top' colspan='2'><a href='http://sourceforge.net' target='_blank'><img src='http://sourceforge.net/sflogo.php?group_id=137197&amp;type=1' alt='SourceForge.net' border='0' height='31' width='88'></a></td></tr>\");\n        html.writeln(\"  <tr><td class='container'><b>Things that might not be 'quite right' about your schema:</b></td></tr>\");\n        html.writeln(\"</table>\");\n        html.writeln(\"<ul>\");\n    }\n\n    private void writeImpliedConstraints(List<? extends ForeignKeyConstraint> impliedConstraints, LineWriter out) throws IOException {\n        out.writeln(\"<li>\");\n        out.writeln(\"<b>Columns whose name and type imply a relationship to another table's primary key:</b>\");\n        int numDetected = 0;\n        for (ForeignKeyConstraint impliedConstraint : impliedConstraints) {\n            Table childTable = impliedConstraint.getChildTable();\n            if (!childTable.isView()) {\n                ++numDetected;\n            }\n        }\n        if (numDetected > 0) {\n            out.writeln(\"<table class='dataTable' border='1' rules='groups'>\");\n            out.writeln(\"<colgroup>\");\n            out.writeln(\"<colgroup>\");\n            out.writeln(\"<thead align='left'>\");\n            out.writeln(\"<tr>\");\n            out.writeln(\"  <th>Child Column</th>\");\n            out.writeln(\"  <th>Implied Parent Column</th>\");\n            out.writeln(\"</tr>\");\n            out.writeln(\"</thead>\");\n            out.writeln(\"<tbody>\");\n            for (ForeignKeyConstraint impliedConstraint : impliedConstraints) {\n                Table childTable = impliedConstraint.getChildTable();\n                if (!childTable.isView()) {\n                    out.writeln(\" <tr>\");\n                    out.write(\"  <td class='detail'>\");\n                    String tableName = childTable.getName();\n                    out.write(\"<a href='tables/\");\n                    out.write(urlEncode(tableName));\n                    out.write(\".html'>\");\n                    out.write(tableName);\n                    out.write(\"</a>.\");\n                    out.write(ForeignKeyConstraint.toString(impliedConstraint.getChildColumns()));\n                    out.writeln(\"</td>\");\n                    out.write(\"  <td class='detail'>\");\n                    tableName = impliedConstraint.getParentTable().getName();\n                    out.write(\"<a href='tables/\");\n                    out.write(urlEncode(tableName));\n                    out.write(\".html'>\");\n                    out.write(tableName);\n                    out.write(\"</a>.\");\n                    out.write(ForeignKeyConstraint.toString(impliedConstraint.getParentColumns()));\n                    out.writeln(\"</td>\");\n                    out.writeln(\" </tr>\");\n                }\n            }\n            out.writeln(\"</tbody>\");\n            out.writeln(\"</table>\");\n        }\n        writeSummary(numDetected, out);\n        out.writeln(\"<p></li>\");\n    }\n\n    private void writeUniqueNullables(List<TableColumn> uniqueNullables, LineWriter out) throws IOException {\n        out.writeln(\"<li>\");\n        out.writeln(\"<b>Columns that are flagged as both 'nullable' and 'must be unique':</b>\");\n        writeColumnBasedAnomaly(uniqueNullables, out);\n        out.writeln(\"<p></li>\");\n    }\n\n    private void writeTablesWithoutIndexes(List<Table> unindexedTables, LineWriter out) throws IOException {\n        out.writeln(\"<li>\");\n        out.writeln(\"<b>Tables without indexes:</b>\");\n        if (!unindexedTables.isEmpty()) {\n            out.writeln(\"<table class='dataTable' border='1' rules='groups'>\");\n            out.writeln(\"<colgroup>\");\n            if (displayNumRows)\n                out.writeln(\"<colgroup>\");\n            out.writeln(\"<thead align='left'>\");\n            out.writeln(\"<tr>\");\n            out.write(\"  <th>Table</th>\");\n            if (displayNumRows)\n                out.write(\"<th>Rows</th>\");\n            out.writeln();\n            out.writeln(\"</tr>\");\n            out.writeln(\"</thead>\");\n            out.writeln(\"<tbody>\");\n            for (Table table : unindexedTables) {\n                out.writeln(\" <tr>\");\n                out.write(\"  <td class='detail'>\");\n                out.write(\"<a href='tables/\");\n                out.write(urlEncode(table.getName()));\n                out.write(\".html'>\");\n                out.write(table.getName());\n                out.write(\"</a>\");\n                out.writeln(\"</td>\");\n                if (displayNumRows) {\n                    out.write(\"  <td class='detail' align='right'>\");\n                    if (table.getNumRows() >= 0)\n                        out.write(String.valueOf(NumberFormat.getIntegerInstance().format(table.getNumRows())));\n                    else\n                        out.write(\"&nbsp;\");\n                    out.writeln(\"</td>\");\n                }\n                out.writeln(\" </tr>\");\n            }\n            out.writeln(\"</tbody>\");\n            out.writeln(\"</table>\");\n        }\n        writeSummary(unindexedTables.size(), out);\n        out.writeln(\"<p></li>\");\n    }\n\n    private void writeTablesWithIncrementingColumnNames(List<Table> tables, LineWriter out) throws IOException {\n        out.writeln(\"<li>\");\n        out.writeln(\"<b>Tables with incrementing column names, potentially indicating denormalization:</b>\");\n        if (!tables.isEmpty()) {\n            out.writeln(\"<table class='dataTable' border='1' rules='groups'>\");\n            out.writeln(\"<thead align='left'>\");\n            out.writeln(\"<tr>\");\n            out.writeln(\"  <th>Table</th>\");\n            out.writeln(\"</tr>\");\n            out.writeln(\"</thead>\");\n            out.writeln(\"<tbody>\");\n            for (Table table : tables) {\n                out.writeln(\" <tr>\");\n                out.write(\"  <td class='detail'>\");\n                out.write(\"<a href='tables/\");\n                out.write(urlEncode(table.getName()));\n                out.write(\".html'>\");\n                out.write(table.getName());\n                out.write(\"</a>\");\n                out.writeln(\"</td>\");\n                out.writeln(\" </tr>\");\n            }\n            out.writeln(\"</tbody>\");\n            out.writeln(\"</table>\");\n        }\n        writeSummary(tables.size(), out);\n        out.writeln(\"<p></li>\");\n    }\n\n    private void writeTablesWithOneColumn(List<Table> tables, LineWriter out) throws IOException {\n        out.writeln(\"<li>\");\n        out.write(\"<b>Tables that contain a single column:</b>\");\n        if (!tables.isEmpty()) {\n            out.writeln(\"<table class='dataTable' border='1' rules='groups'>\");\n            out.writeln(\"<colgroup>\");\n            out.writeln(\"<colgroup>\");\n            out.writeln(\"<thead align='left'>\");\n            out.writeln(\"<tr>\");\n            out.writeln(\"  <th>Table</th>\");\n            out.writeln(\"  <th>Column</th>\");\n            out.writeln(\"</tr>\");\n            out.writeln(\"</thead>\");\n            out.writeln(\"<tbody>\");\n            for (Table table : tables) {\n                out.writeln(\" <tr>\");\n                out.write(\"  <td class='detail'>\");\n                out.write(\"<a href='tables/\");\n                out.write(urlEncode(table.getName()));\n                out.write(\".html'>\");\n                out.write(table.getName());\n                out.write(\"</a></td><td class='detail'>\");\n                out.write(table.getColumns().get(0).toString());\n                out.writeln(\"</td>\");\n                out.writeln(\" </tr>\");\n            }\n            out.writeln(\"</tbody>\");\n            out.writeln(\"</table>\");\n        }\n        writeSummary(tables.size(), out);\n        out.writeln(\"<p></li>\");\n    }\n\n    private void writeDefaultNullStrings(List<TableColumn> uniqueNullables, LineWriter out) throws IOException {\n        out.writeln(\"<li>\");\n        out.writeln(\"<b>Columns whose default value is the word 'NULL' or 'null', but the SQL NULL value may have been intended:</b>\");\n        writeColumnBasedAnomaly(uniqueNullables, out);\n        out.writeln(\"<p></li>\");\n    }\n\n    private void writeColumnBasedAnomaly(List<TableColumn> columns, LineWriter out) throws IOException {\n        if (!columns.isEmpty()) {\n            out.writeln(\"<table class='dataTable' border='1' rules='groups'>\");\n            out.writeln(\"<thead align='left'>\");\n            out.writeln(\"<tr>\");\n            out.writeln(\"  <th>Column</th>\");\n            out.writeln(\"</tr>\");\n            out.writeln(\"</thead>\");\n            out.writeln(\"<tbody>\");\n            for (TableColumn column : columns) {\n                out.writeln(\" <tr>\");\n                out.write(\"  <td class='detail'>\");\n                String tableName = column.getTable().getName();\n                out.write(\"<a href='tables/\");\n                out.write(urlEncode(tableName));\n                out.write(\".html'>\");\n                out.write(tableName);\n                out.write(\"</a>.\");\n                out.write(column.getName());\n                out.writeln(\"</td>\");\n                out.writeln(\" </tr>\");\n            }\n            out.writeln(\"</tbody>\");\n            out.writeln(\"</table>\");\n        }\n        writeSummary(columns.size(), out);\n    }\n\n    private void writeSummary(int numAnomalies, LineWriter out) throws IOException {\n        switch(numAnomalies) {\n            case 0:\n                out.write(\"<br>Anomaly not detected\");\n                break;\n            case 1:\n                out.write(\"1 instance of anomaly detected\");\n                break;\n            default:\n                out.write(numAnomalies + \" instances of anomaly detected\");\n        }\n    }\n\n    @Override\n    protected void writeFooter(LineWriter out) throws IOException {\n        out.writeln(\"</ul>\");\n        super.writeFooter(out);\n    }\n\n    @Override\n    protected boolean isAnomaliesPage() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/HtmlAnomaliesPageTest.java",
		"test_prompt": "// HtmlAnomaliesPageTest.java\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.IOException;\nimport java.text.NumberFormat;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport net.sourceforge.schemaspy.DbAnalyzer;\nimport net.sourceforge.schemaspy.model.Database;\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.util.LineWriter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HtmlAnomaliesPage}.\n* It contains ten unit test cases for the {@link HtmlAnomaliesPage#getInstance()} method.\n*/\nclass HtmlAnomaliesPageTest {"
	},
	{
		"original_code": "// HtmlTableDiagrammer.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.File;\nimport java.io.IOException;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.LineWriter;\n\npublic class HtmlTableDiagrammer extends HtmlDiagramFormatter {\n\n    private static HtmlTableDiagrammer instance = new HtmlTableDiagrammer();\n\n    private HtmlTableDiagrammer() {\n    }\n\n    public static HtmlTableDiagrammer getInstance() {\n        return instance;\n    }\n\n    public boolean write(Table table, File diagramDir, LineWriter html) {\n        try {\n            Dot dot = getDot();\n            if (dot == null)\n                return false;\n            File oneDegreeDotFile = new File(diagramDir, table.getName() + \".1degree.dot\");\n            File oneDegreeDiagramFile = new File(diagramDir, table.getName() + \".1degree.\" + dot.getFormat());\n            File twoDegreesDotFile = new File(diagramDir, table.getName() + \".2degrees.dot\");\n            File twoDegreesDiagramFile = new File(diagramDir, table.getName() + \".2degrees.\" + dot.getFormat());\n            File impliedDotFile = new File(diagramDir, table.getName() + \".implied2degrees.dot\");\n            File impliedDiagramFile = new File(diagramDir, table.getName() + \".implied2degrees.\" + dot.getFormat());\n            String map = dot.generateDiagram(oneDegreeDotFile, oneDegreeDiagramFile);\n            html.write(\"<br><form action='get'><b>Close relationships\");\n            if (twoDegreesDotFile.exists()) {\n                html.writeln(\"</b><span class='degrees' id='degrees' title='Detail diminishes with increased separation from \" + table.getName() + \"'>\");\n                html.write(\"&nbsp;within <label for='oneDegree'><input type='radio' name='degrees' id='oneDegree' checked>one</label>\");\n                html.write(\"  <label for='twoDegrees'><input type='radio' name='degrees' id='twoDegrees'>two degrees</label> of separation\");\n                html.write(\"</span><b>:</b>\");\n                html.writeln(\"</form>\");\n            } else {\n                html.write(\":</b></form>\");\n            }\n            html.write(map);\n            map = null;\n            html.writeln(\"  <a name='diagram'><img id='oneDegreeImg' src='../diagrams/\" + urlEncode(oneDegreeDiagramFile.getName()) + \"' usemap='#oneDegreeRelationshipsDiagram' class='diagram' border='0' alt='' align='left'></a>\");\n            if (impliedDotFile.exists()) {\n                html.writeln(dot.generateDiagram(impliedDotFile, impliedDiagramFile));\n                html.writeln(\"  <a name='diagram'><img id='impliedTwoDegreesImg' src='../diagrams/\" + urlEncode(impliedDiagramFile.getName()) + \"' usemap='#impliedTwoDegreesRelationshipsDiagram' class='diagram' border='0' alt='' align='left'></a>\");\n            } else {\n                impliedDotFile.delete();\n                impliedDiagramFile.delete();\n            }\n            if (twoDegreesDotFile.exists()) {\n                html.writeln(dot.generateDiagram(twoDegreesDotFile, twoDegreesDiagramFile));\n                html.writeln(\"  <a name='diagram'><img id='twoDegreesImg' src='../diagrams/\" + urlEncode(twoDegreesDiagramFile.getName()) + \"' usemap='#twoDegreesRelationshipsDiagram' class='diagram' border='0' alt='' align='left'></a>\");\n            } else {\n                twoDegreesDotFile.delete();\n                twoDegreesDiagramFile.delete();\n            }\n        } catch (Dot.DotFailure dotFailure) {\n            System.err.println(dotFailure);\n            return false;\n        } catch (IOException ioExc) {\n            ioExc.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/HtmlTableDiagrammerTest0.java",
		"test_prompt": "// HtmlTableDiagrammerTest0.java\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.File;\nimport java.io.IOException;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.LineWriter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HtmlTableDiagrammer}.\n* It contains ten unit test cases for the {@link HtmlTableDiagrammer#getInstance()} method.\n*/\nclass HtmlTableDiagrammerTest0 {"
	},
	{
		"original_code": "// HtmlTableDiagrammer.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.File;\nimport java.io.IOException;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.LineWriter;\n\npublic class HtmlTableDiagrammer extends HtmlDiagramFormatter {\n\n    private static HtmlTableDiagrammer instance = new HtmlTableDiagrammer();\n\n    private HtmlTableDiagrammer() {\n    }\n\n    public static HtmlTableDiagrammer getInstance() {\n        return instance;\n    }\n\n    public boolean write(Table table, File diagramDir, LineWriter html) {\n        try {\n            Dot dot = getDot();\n            if (dot == null)\n                return false;\n            File oneDegreeDotFile = new File(diagramDir, table.getName() + \".1degree.dot\");\n            File oneDegreeDiagramFile = new File(diagramDir, table.getName() + \".1degree.\" + dot.getFormat());\n            File twoDegreesDotFile = new File(diagramDir, table.getName() + \".2degrees.dot\");\n            File twoDegreesDiagramFile = new File(diagramDir, table.getName() + \".2degrees.\" + dot.getFormat());\n            File impliedDotFile = new File(diagramDir, table.getName() + \".implied2degrees.dot\");\n            File impliedDiagramFile = new File(diagramDir, table.getName() + \".implied2degrees.\" + dot.getFormat());\n            String map = dot.generateDiagram(oneDegreeDotFile, oneDegreeDiagramFile);\n            html.write(\"<br><form action='get'><b>Close relationships\");\n            if (twoDegreesDotFile.exists()) {\n                html.writeln(\"</b><span class='degrees' id='degrees' title='Detail diminishes with increased separation from \" + table.getName() + \"'>\");\n                html.write(\"&nbsp;within <label for='oneDegree'><input type='radio' name='degrees' id='oneDegree' checked>one</label>\");\n                html.write(\"  <label for='twoDegrees'><input type='radio' name='degrees' id='twoDegrees'>two degrees</label> of separation\");\n                html.write(\"</span><b>:</b>\");\n                html.writeln(\"</form>\");\n            } else {\n                html.write(\":</b></form>\");\n            }\n            html.write(map);\n            map = null;\n            html.writeln(\"  <a name='diagram'><img id='oneDegreeImg' src='../diagrams/\" + urlEncode(oneDegreeDiagramFile.getName()) + \"' usemap='#oneDegreeRelationshipsDiagram' class='diagram' border='0' alt='' align='left'></a>\");\n            if (impliedDotFile.exists()) {\n                html.writeln(dot.generateDiagram(impliedDotFile, impliedDiagramFile));\n                html.writeln(\"  <a name='diagram'><img id='impliedTwoDegreesImg' src='../diagrams/\" + urlEncode(impliedDiagramFile.getName()) + \"' usemap='#impliedTwoDegreesRelationshipsDiagram' class='diagram' border='0' alt='' align='left'></a>\");\n            } else {\n                impliedDotFile.delete();\n                impliedDiagramFile.delete();\n            }\n            if (twoDegreesDotFile.exists()) {\n                html.writeln(dot.generateDiagram(twoDegreesDotFile, twoDegreesDiagramFile));\n                html.writeln(\"  <a name='diagram'><img id='twoDegreesImg' src='../diagrams/\" + urlEncode(twoDegreesDiagramFile.getName()) + \"' usemap='#twoDegreesRelationshipsDiagram' class='diagram' border='0' alt='' align='left'></a>\");\n            } else {\n                twoDegreesDotFile.delete();\n                twoDegreesDiagramFile.delete();\n            }\n        } catch (Dot.DotFailure dotFailure) {\n            System.err.println(dotFailure);\n            return false;\n        } catch (IOException ioExc) {\n            ioExc.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/HtmlTableDiagrammerTest1.java",
		"test_prompt": "// HtmlTableDiagrammerTest1.java\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.File;\nimport java.io.IOException;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.LineWriter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HtmlTableDiagrammer}.\n* It contains ten unit test cases for the {@link HtmlTableDiagrammer#write(Table, File, LineWriter)} method.\n*/\nclass HtmlTableDiagrammerTest1 {"
	},
	{
		"original_code": "// DefaultSqlFormatter.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy.view;\r\n\r\nimport java.sql.DatabaseMetaData;\r\nimport java.util.Arrays;\r\nimport java.util.Collection;\r\nimport java.util.HashSet;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\nimport java.util.StringTokenizer;\r\nimport net.sourceforge.schemaspy.model.Database;\r\nimport net.sourceforge.schemaspy.model.Table;\r\nimport net.sourceforge.schemaspy.util.CaseInsensitiveMap;\r\nimport net.sourceforge.schemaspy.util.HtmlEncoder;\r\n\r\n/**\r\n * Default implementation of {@link SqlFormatter}\r\n *\r\n * @author John Currier\r\n */\r\npublic class DefaultSqlFormatter implements SqlFormatter {\r\n\r\n    private Set<String> keywords;\r\n\r\n    private Map<String, Table> tablesByPossibleNames;\r\n\r\n    private static String TOKENS = \" \\t\\n\\r\\f()<>|,\";\r\n\r\n    /**\r\n     * Return a HTML-formatted representation of the specified SQL.\r\n     *\r\n     * @param sql SQL to be formatted\r\n     * @param db Database\r\n     * @return HTML-formatted representation of the specified SQL\r\n     */\r\n    public String format(String sql, Database db, Set<Table> references) {\r\n        StringBuilder formatted = new StringBuilder(sql.length() * 2);\r\n        boolean alreadyFormatted = sql.contains(\"\\n\") || sql.contains(\"\\r\");\r\n        if (alreadyFormatted) {\r\n            // apparently already formatted, so dump it as is\r\n            formatted.append(\"<div class='viewDefinition preFormatted'>\");\r\n            int len = sql.length();\r\n            for (int i = 0; i < len; i++) {\r\n                char ch = sql.charAt(i);\r\n                // encode everything except whitespace\r\n                if (Character.isWhitespace(ch)) {\r\n                    formatted.append(ch);\r\n                } else {\r\n                    formatted.append(HtmlEncoder.encodeToken(ch));\r\n                }\r\n            }\r\n        } else {\r\n            formatted.append(\"  <div class='viewDefinition'>\");\r\n            @SuppressWarnings(\"hiding\")\r\n            Set<String> keywords = getKeywords(db.getMetaData());\r\n            StringTokenizer tokenizer = new StringTokenizer(sql, TOKENS, true);\r\n            while (tokenizer.hasMoreTokens()) {\r\n                String token = tokenizer.nextToken();\r\n                if (keywords.contains(token.toUpperCase())) {\r\n                    formatted.append(\"<b>\");\r\n                    formatted.append(token);\r\n                    formatted.append(\"</b>\");\r\n                } else {\r\n                    formatted.append(HtmlEncoder.encodeToken(token));\r\n                }\r\n            }\r\n        }\r\n        formatted.append(\"</div>\");\r\n        references.addAll(getReferencedTables(sql, db));\r\n        return formatted.toString();\r\n    }\r\n\r\n    /**\r\n     * Returns a {@link Set} of tables/views that are possibly referenced\r\n     * by the specified SQL.\r\n     *\r\n     * @param sql\r\n     * @param db\r\n     * @return\r\n     */\r\n    protected Set<Table> getReferencedTables(String sql, Database db) {\r\n        Set<Table> referenced = new HashSet<Table>();\r\n        Map<String, Table> tables = getTableMap(db);\r\n        @SuppressWarnings(\"hiding\")\r\n        Set<String> keywords = getKeywords(db.getMetaData());\r\n        StringTokenizer tokenizer = new StringTokenizer(sql, TOKENS, true);\r\n        while (tokenizer.hasMoreTokens()) {\r\n            String token = tokenizer.nextToken();\r\n            if (!keywords.contains(token.toUpperCase())) {\r\n                Table t = tables.get(token);\r\n                if (t == null) {\r\n                    int lastDot = token.lastIndexOf('.');\r\n                    if (lastDot != -1) {\r\n                        t = tables.get(token.substring(0, lastDot));\r\n                    }\r\n                }\r\n                if (t != null) {\r\n                    referenced.add(t);\r\n                }\r\n            }\r\n        }\r\n        return referenced;\r\n    }\r\n\r\n    /**\r\n     * Returns a {@link Map} of all tables/views in the database\r\n     * keyed by several possible ways to refer to the table.\r\n     *\r\n     * @param db\r\n     * @return\r\n     */\r\n    protected Map<String, Table> getTableMap(Database db) {\r\n        if (tablesByPossibleNames == null) {\r\n            tablesByPossibleNames = new CaseInsensitiveMap<Table>();\r\n            tablesByPossibleNames.putAll(getTableMap(db.getTables()));\r\n            tablesByPossibleNames.putAll(getTableMap(db.getViews()));\r\n        }\r\n        return tablesByPossibleNames;\r\n    }\r\n\r\n    /**\r\n     * Returns a {@link Map} of the specified tables/views\r\n     * keyed by several possible ways to refer to the table.\r\n     *\r\n     * @param tables\r\n     * @param dbName\r\n     * @return\r\n     */\r\n    protected Map<String, Table> getTableMap(Collection<? extends Table> tables) {\r\n        Map<String, Table> map = new CaseInsensitiveMap<Table>();\r\n        for (Table t : tables) {\r\n            String name = t.getName();\r\n            String container = t.getContainer();\r\n            map.put(name, t);\r\n            map.put(\"`\" + name + \"`\", t);\r\n            map.put(\"'\" + name + \"'\", t);\r\n            map.put(\"\\\"\" + name + \"\\\"\", t);\r\n            map.put(container + \".\" + name, t);\r\n            map.put(\"`\" + container + \"`.`\" + name + \"`\", t);\r\n            map.put(\"'\" + container + \"'.'\" + name + \"'\", t);\r\n            map.put(\"\\\"\" + container + \"\\\".\\\"\" + name + \"\\\"\", t);\r\n            map.put(\"`\" + container + '.' + name + \"`\", t);\r\n            map.put(\"'\" + container + '.' + name + \"'\", t);\r\n            map.put(\"\\\"\" + container + '.' + name + \"\\\"\", t);\r\n        }\r\n        return map;\r\n    }\r\n\r\n    /**\r\n     * @param meta\r\n     * @return\r\n     */\r\n    public Set<String> getKeywords(DatabaseMetaData meta) {\r\n        if (keywords == null) {\r\n            keywords = new HashSet<String>(Arrays.asList(new String[] { \"ABSOLUTE\", \"ACTION\", \"ADD\", \"ALL\", \"ALLOCATE\", \"ALTER\", \"AND\", \"ANY\", \"ARE\", \"AS\", \"ASC\", \"ASSERTION\", \"AT\", \"AUTHORIZATION\", \"AVG\", \"BEGIN\", \"BETWEEN\", \"BIT\", \"BIT_LENGTH\", \"BOTH\", \"BY\", \"CASCADE\", \"CASCADED\", \"CASE\", \"CAST\", \"CATALOG\", \"CHAR\", \"CHARACTER\", \"CHAR_LENGTH\", \"CHARACTER_LENGTH\", \"CHECK\", \"CLOSE\", \"COALESCE\", \"COLLATE\", \"COLLATION\", \"COLUMN\", \"COMMIT\", \"CONNECT\", \"CONNECTION\", \"CONSTRAINT\", \"CONSTRAINTS\", \"CONTINUE\", \"CONVERT\", \"CORRESPONDING\", \"COUNT\", \"CREATE\", \"CROSS\", \"CURRENT\", \"CURRENT_DATE\", \"CURRENT_TIME\", \"CURRENT_TIMESTAMP\", \"CURRENT_USER\", \"CURSOR\", \"DATE\", \"DAY\", \"DEALLOCATE\", \"DEC\", \"DECIMAL\", \"DECLARE\", \"DEFAULT\", \"DEFERRABLE\", \"DEFERRED\", \"DELETE\", \"DESC\", \"DESCRIBE\", \"DESCRIPTOR\", \"DIAGNOSTICS\", \"DISCONNECT\", \"DISTINCT\", \"DOMAIN\", \"DOUBLE\", \"DROP\", \"ELSE\", \"END\", \"END - EXEC\", \"ESCAPE\", \"EXCEPT\", \"EXCEPTION\", \"EXEC\", \"EXECUTE\", \"EXISTS\", \"EXTERNAL\", \"EXTRACT\", \"FALSE\", \"FETCH\", \"FIRST\", \"FLOAT\", \"FOR\", \"FOREIGN\", \"FOUND\", \"FROM\", \"FULL\", \"GET\", \"GLOBAL\", \"GO\", \"GOTO\", \"GRANT\", \"GROUP\", \"HAVING\", \"HOUR\", \"IDENTITY\", \"IMMEDIATE\", \"IN\", \"INDICATOR\", \"INITIALLY\", \"INNER\", \"INPUT\", \"INSENSITIVE\", \"INSERT\", \"INT\", \"INTEGER\", \"INTERSECT\", \"INTERVAL\", \"INTO\", \"IS\", \"ISOLATION\", \"JOIN\", \"KEY\", \"LANGUAGE\", \"LAST\", \"LEADING\", \"LEFT\", \"LEVEL\", \"LIKE\", \"LOCAL\", \"LOWER\", \"MATCH\", \"MAX\", \"MIN\", \"MINUTE\", \"MODULE\", \"MONTH\", \"NAMES\", \"NATIONAL\", \"NATURAL\", \"NCHAR\", \"NEXT\", \"NO\", \"NOT\", \"NULL\", \"NULLIF\", \"NUMERIC\", \"OCTET_LENGTH\", \"OF\", \"ON\", \"ONLY\", \"OPEN\", \"OPTION\", \"OR\", \"ORDER\", \"OUTER\", \"OUTPUT\", \"OVERLAPS\", \"PAD\", \"PARTIAL\", \"POSITION\", \"PRECISION\", \"PREPARE\", \"PRESERVE\", \"PRIMARY\", \"PRIOR\", \"PRIVILEGES\", \"PROCEDURE\", \"PUBLIC\", \"READ\", \"REAL\", \"REFERENCES\", \"RELATIVE\", \"RESTRICT\", \"REVOKE\", \"RIGHT\", \"ROLLBACK\", \"ROWS\", \"SCHEMA\", \"SCROLL\", \"SECOND\", \"SECTION\", \"SELECT\", \"SESSION\", \"SESSION_USER\", \"SET\", \"SIZE\", \"SMALLINT\", \"SOME\", \"SPACE\", \"SQL\", \"SQLCODE\", \"SQLERROR\", \"SQLSTATE\", \"SUBSTRING\", \"SUM\", \"SYSTEM_USER\", \"TABLE\", \"TEMPORARY\", \"THEN\", \"TIME\", \"TIMESTAMP\", \"TIMEZONE_HOUR\", \"TIMEZONE_MINUTE\", \"TO\", \"TRAILING\", \"TRANSACTION\", \"TRANSLATE\", \"TRANSLATION\", \"TRIM\", \"TRUE\", \"UNION\", \"UNIQUE\", \"UNKNOWN\", \"UPDATE\", \"UPPER\", \"USAGE\", \"USER\", \"USING\", \"VALUE\", \"VALUES\", \"VARCHAR\", \"VARYING\", \"VIEW\", \"WHEN\", \"WHENEVER\", \"WHERE\", \"WITH\", \"WORK\", \"WRITE\", \"YEAR\", \"ZONE\" }));\r\n            try {\r\n                String[] keywordsArray = new String[] { meta.getSQLKeywords(), meta.getSystemFunctions(), meta.getNumericFunctions(), meta.getStringFunctions(), meta.getTimeDateFunctions() };\r\n                for (int i = 0; i < keywordsArray.length; ++i) {\r\n                    StringTokenizer tokenizer = new StringTokenizer(keywordsArray[i].toUpperCase(), \",\");\r\n                    while (tokenizer.hasMoreTokens()) {\r\n                        keywords.add(tokenizer.nextToken().trim());\r\n                    }\r\n                }\r\n            } catch (Exception exc) {\r\n                // don't totally fail just because we can't extract these details...\r\n                System.err.println(exc);\r\n            }\r\n        }\r\n        return keywords;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/DefaultSqlFormatterTest.java",
		"test_prompt": "// DefaultSqlFormatterTest.java\npackage net.sourceforge.schemaspy.view;\n\nimport java.sql.DatabaseMetaData;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport net.sourceforge.schemaspy.model.Database;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.util.CaseInsensitiveMap;\nimport net.sourceforge.schemaspy.util.HtmlEncoder;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DefaultSqlFormatter}.\n* It contains ten unit test cases for the {@link DefaultSqlFormatter#format(String, Database, Set)} method.\n*/\nclass DefaultSqlFormatterTest {"
	},
	{
		"original_code": "// StyleSheet.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.StringTokenizer;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.LineWriter;\n\n/**\n * Represents our CSS style sheet (CSS) with accessors for important\n * data from that style sheet.\n * The idea is that the CSS that will be used to render the HTML pages\n * also determines the colors used in the generated ER diagrams.\n *\n * @author John Currier\n */\npublic class StyleSheet {\n\n    private static StyleSheet instance;\n\n    private final String css;\n\n    private String bodyBackgroundColor;\n\n    private String tableHeadBackgroundColor;\n\n    private String tableBackgroundColor;\n\n    private String linkColor;\n\n    private String linkVisitedColor;\n\n    private String primaryKeyBackgroundColor;\n\n    private String indexedColumnBackgroundColor;\n\n    private String selectedTableBackgroundColor;\n\n    private String excludedColumnBackgroundColor;\n\n    private final List<String> ids = new ArrayList<String>();\n\n    private StyleSheet(BufferedReader cssReader) throws IOException {\n        String lineSeparator = System.getProperty(\"line.separator\");\n        StringBuilder data = new StringBuilder();\n        String line;\n        while ((line = cssReader.readLine()) != null) {\n            data.append(line);\n            data.append(lineSeparator);\n        }\n        css = data.toString();\n        int startComment = data.indexOf(\"/*\");\n        while (startComment != -1) {\n            int endComment = data.indexOf(\"*/\");\n            data.replace(startComment, endComment + 2, \"\");\n            startComment = data.indexOf(\"/*\");\n        }\n        StringTokenizer tokenizer = new StringTokenizer(data.toString(), \"{}\");\n        String id = null;\n        while (tokenizer.hasMoreTokens()) {\n            String token = tokenizer.nextToken().trim();\n            if (id == null) {\n                id = token.toLowerCase();\n                ids.add(id);\n            } else {\n                Map<String, String> attribs = parseAttributes(token);\n                if (id.equals(\".content\"))\n                    bodyBackgroundColor = attribs.get(\"background\");\n                else if (id.equals(\"th\"))\n                    tableHeadBackgroundColor = attribs.get(\"background-color\");\n                else if (id.equals(\"td\"))\n                    tableBackgroundColor = attribs.get(\"background-color\");\n                else if (id.equals(\".primarykey\"))\n                    primaryKeyBackgroundColor = attribs.get(\"background\");\n                else if (id.equals(\".indexedcolumn\"))\n                    indexedColumnBackgroundColor = attribs.get(\"background\");\n                else if (id.equals(\".selectedtable\"))\n                    selectedTableBackgroundColor = attribs.get(\"background\");\n                else if (id.equals(\".excludedcolumn\"))\n                    excludedColumnBackgroundColor = attribs.get(\"background\");\n                else if (id.equals(\"a:link\"))\n                    linkColor = attribs.get(\"color\");\n                else if (id.equals(\"a:visited\"))\n                    linkVisitedColor = attribs.get(\"color\");\n                id = null;\n            }\n        }\n    }\n\n    /**\n     * Singleton accessor\n     *\n     * @return the singleton\n     * @throws ParseException\n     */\n    public static StyleSheet getInstance() throws ParseException {\n        if (instance == null) {\n            try {\n                instance = new StyleSheet(new BufferedReader(getReader(Config.getInstance().getCss())));\n            } catch (IOException exc) {\n                throw new ParseException(exc);\n            }\n        }\n        return instance;\n    }\n\n    /**\n     * Returns a {@link Reader} that can be used to read the contents\n     * of the specified css.<p>\n     * Search order is\n     * <ol>\n     * <li><code>cssName</code> as an explicitly-defined file</li>\n     * <li><code>cssName</code> as a file in the user's home directory</li>\n     * <li><code>cssName</code> as a resource from the class path</li>\n     * </ol>\n     *\n     * @param cssName\n     * @return\n     * @throws IOException\n     */\n    private static Reader getReader(String cssName) throws IOException {\n        File cssFile = new File(cssName);\n        if (cssFile.exists())\n            return new FileReader(cssFile);\n        cssFile = new File(System.getProperty(\"user.dir\"), cssName);\n        if (cssFile.exists())\n            return new FileReader(cssFile);\n        InputStream cssStream = StyleSheet.class.getClassLoader().getResourceAsStream(cssName);\n        if (cssStream == null)\n            throw new ParseException(\"Unable to find requested style sheet: \" + cssName);\n        return new InputStreamReader(cssStream);\n    }\n\n    private Map<String, String> parseAttributes(String data) {\n        Map<String, String> attribs = new HashMap<String, String>();\n        try {\n            StringTokenizer attrTokenizer = new StringTokenizer(data, \";\");\n            while (attrTokenizer.hasMoreTokens()) {\n                StringTokenizer pairTokenizer = new StringTokenizer(attrTokenizer.nextToken(), \":\");\n                String attribute = pairTokenizer.nextToken().trim().toLowerCase();\n                String value = pairTokenizer.nextToken().trim().toLowerCase();\n                attribs.put(attribute, value);\n            }\n        } catch (NoSuchElementException badToken) {\n            System.err.println(\"Failed to extract attributes from '\" + data + \"'\");\n            throw badToken;\n        }\n        return attribs;\n    }\n\n    /**\n     * Write the contents of the original css to <code>out</code>.\n     *\n     * @param out\n     * @throws IOException\n     */\n    public void write(LineWriter out) throws IOException {\n        out.write(css);\n    }\n\n    public String getBodyBackground() {\n        if (bodyBackgroundColor == null)\n            throw new MissingCssPropertyException(\".content\", \"background\");\n        return bodyBackgroundColor;\n    }\n\n    public String getTableBackground() {\n        if (tableBackgroundColor == null)\n            throw new MissingCssPropertyException(\"td\", \"background-color\");\n        return tableBackgroundColor;\n    }\n\n    public String getTableHeadBackground() {\n        if (tableHeadBackgroundColor == null)\n            throw new MissingCssPropertyException(\"th\", \"background-color\");\n        return tableHeadBackgroundColor;\n    }\n\n    public String getPrimaryKeyBackground() {\n        if (primaryKeyBackgroundColor == null)\n            throw new MissingCssPropertyException(\".primaryKey\", \"background\");\n        return primaryKeyBackgroundColor;\n    }\n\n    public String getIndexedColumnBackground() {\n        if (indexedColumnBackgroundColor == null)\n            throw new MissingCssPropertyException(\".indexedColumn\", \"background\");\n        return indexedColumnBackgroundColor;\n    }\n\n    public String getSelectedTableBackground() {\n        if (selectedTableBackgroundColor == null)\n            throw new MissingCssPropertyException(\".selectedTable\", \"background\");\n        return selectedTableBackgroundColor;\n    }\n\n    public String getExcludedColumnBackgroundColor() {\n        if (excludedColumnBackgroundColor == null)\n            throw new MissingCssPropertyException(\".excludedColumn\", \"background\");\n        return excludedColumnBackgroundColor;\n    }\n\n    public String getLinkColor() {\n        if (linkColor == null)\n            throw new MissingCssPropertyException(\"a:link\", \"color\");\n        return linkColor;\n    }\n\n    public String getLinkVisitedColor() {\n        if (linkVisitedColor == null)\n            throw new MissingCssPropertyException(\"a:visited\", \"color\");\n        return linkVisitedColor;\n    }\n\n    /**\n     * Indicates that a css property was missing\n     */\n    public static class MissingCssPropertyException extends InvalidConfigurationException {\n\n        private static final long serialVersionUID = 1L;\n\n        /**\n         * @param cssSection name of the css section\n         * @param propName name of the missing property in that section\n         */\n        public MissingCssPropertyException(String cssSection, String propName) {\n            super(\"Required property '\" + propName + \"' was not found for the definition of '\" + cssSection + \"' in \" + Config.getInstance().getCss());\n        }\n    }\n\n    /**\n     * Indicates an exception in parsing the css\n     */\n    public static class ParseException extends InvalidConfigurationException {\n\n        private static final long serialVersionUID = 1L;\n\n        /**\n         * @param cause root exception that caused the failure\n         */\n        public ParseException(Exception cause) {\n            super(cause);\n        }\n\n        /**\n         * @param msg textual description of the failure\n         */\n        public ParseException(String msg) {\n            super(msg);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/StyleSheetTest.java",
		"test_prompt": "// StyleSheetTest.java\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.StringTokenizer;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.LineWriter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StyleSheet}.\n* It contains ten unit test cases for the {@link StyleSheet#getInstance()} method.\n*/\nclass StyleSheetTest {"
	},
	{
		"original_code": "// HtmlRelationshipsPage.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport net.sourceforge.schemaspy.model.Database;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.LineWriter;\n\n/**\n * The page that contains the overview entity relationship diagrams.\n *\n * @author John Currier\n */\npublic class HtmlRelationshipsPage extends HtmlDiagramFormatter {\n\n    private static final HtmlRelationshipsPage instance = new HtmlRelationshipsPage();\n\n    private static final boolean fineEnabled = Logger.getLogger(HtmlRelationshipsPage.class.getName()).isLoggable(Level.FINE);\n\n    /**\n     * Singleton: Don't allow instantiation\n     */\n    private HtmlRelationshipsPage() {\n    }\n\n    /**\n     * Singleton accessor\n     *\n     * @return the singleton instance\n     */\n    public static HtmlRelationshipsPage getInstance() {\n        return instance;\n    }\n\n    public boolean write(Database db, File diagramDir, String dotBaseFilespec, boolean hasRealRelationships, boolean hasImpliedRelationships, Set<TableColumn> excludedColumns, LineWriter html) {\n        try {\n            Dot dot = getDot();\n            if (dot == null) {\n                writeHeader(db, null, \"All Relationships\", html);\n                html.writeln(\"<div class='content'>\");\n                writeInvalidGraphvizInstallation(html);\n                html.writeln(\"</div>\");\n                writeFooter(html);\n                return false;\n            }\n            File compactRelationshipsDotFile = new File(diagramDir, dotBaseFilespec + \".real.compact.dot\");\n            File compactRelationshipsDiagramFile = new File(diagramDir, dotBaseFilespec + \".real.compact.\" + dot.getFormat());\n            File largeRelationshipsDotFile = new File(diagramDir, dotBaseFilespec + \".real.large.dot\");\n            File largeRelationshipsDiagramFile = new File(diagramDir, dotBaseFilespec + \".real.large.\" + dot.getFormat());\n            File compactImpliedDotFile = new File(diagramDir, dotBaseFilespec + \".implied.compact.dot\");\n            File compactImpliedDiagramFile = new File(diagramDir, dotBaseFilespec + \".implied.compact.\" + dot.getFormat());\n            File largeImpliedDotFile = new File(diagramDir, dotBaseFilespec + \".implied.large.dot\");\n            File largeImpliedDiagramFile = new File(diagramDir, dotBaseFilespec + \".implied.large.\" + dot.getFormat());\n            writeHeader(db, \"All Relationships\", hasRealRelationships, hasImpliedRelationships, html);\n            html.writeln(\"<table width=\\\"100%\\\"><tr><td class=\\\"container\\\">\");\n            if (hasRealRelationships) {\n                if (!fineEnabled)\n                    System.out.print(\".\");\n                html.writeln(dot.generateDiagram(compactRelationshipsDotFile, compactRelationshipsDiagramFile));\n                html.writeln(\"  <a name='diagram'><img id='realCompactImg' src='diagrams/summary/\" + compactRelationshipsDiagramFile.getName() + \"' usemap='#compactRelationshipsDiagram' class='diagram' border='0' alt=''></a>\");\n                // we've run into instances where the first diagrams get generated, but then\n                // dot fails on the second one...try to recover from that scenario 'somewhat'\n                // gracefully\n                try {\n                    if (!fineEnabled)\n                        System.out.print(\".\");\n                    html.writeln(dot.generateDiagram(largeRelationshipsDotFile, largeRelationshipsDiagramFile));\n                    html.writeln(\"  <a name='diagram'><img id='realLargeImg' src='diagrams/summary/\" + largeRelationshipsDiagramFile.getName() + \"' usemap='#largeRelationshipsDiagram' class='diagram' border='0' alt=''></a>\");\n                } catch (Dot.DotFailure dotFailure) {\n                    System.err.println(\"dot failed to generate all of the relationships diagrams:\");\n                    System.err.println(dotFailure);\n                    System.err.println(\"...but the relationships page may still be usable.\");\n                }\n            }\n            try {\n                if (hasImpliedRelationships) {\n                    if (!fineEnabled)\n                        System.out.print(\".\");\n                    html.writeln(dot.generateDiagram(compactImpliedDotFile, compactImpliedDiagramFile));\n                    html.writeln(\"  <a name='diagram'><img id='impliedCompactImg' src='diagrams/summary/\" + compactImpliedDiagramFile.getName() + \"' usemap='#compactImpliedRelationshipsDiagram' class='diagram' border='0' alt=''></a>\");\n                    if (!fineEnabled)\n                        System.out.print(\".\");\n                    html.writeln(dot.generateDiagram(largeImpliedDotFile, largeImpliedDiagramFile));\n                    html.writeln(\"  <a name='diagram'><img id='impliedLargeImg' src='diagrams/summary/\" + largeImpliedDiagramFile.getName() + \"' usemap='#largeImpliedRelationshipsDiagram' class='diagram' border='0' alt=''></a>\");\n                }\n            } catch (Dot.DotFailure dotFailure) {\n                System.err.println(\"dot failed to generate all of the relationships diagrams:\");\n                System.err.println(dotFailure);\n                System.err.println(\"...but the relationships page may still be usable.\");\n            }\n            if (!fineEnabled)\n                System.out.print(\".\");\n            html.writeln(\"</td></tr></table>\");\n            writeExcludedColumns(excludedColumns, null, html);\n            writeFooter(html);\n            return true;\n        } catch (Dot.DotFailure dotFailure) {\n            System.err.println(dotFailure);\n            return false;\n        } catch (IOException ioExc) {\n            ioExc.printStackTrace();\n            return false;\n        }\n    }\n\n    private void writeHeader(Database db, String title, boolean hasRealRelationships, boolean hasImpliedRelationships, LineWriter html) throws IOException {\n        writeHeader(db, null, title, html);\n        html.writeln(\"<table class='container' width='100%'>\");\n        html.writeln(\"<tr><td class='container'>\");\n        writeGeneratedOn(db.getConnectTime(), html);\n        html.writeln(\"</td>\");\n        html.writeln(\"<td class='container' align='right' valign='top' rowspan='2'>\");\n        writeLegend(false, html);\n        html.writeln(\"</td></tr>\");\n        if (!hasRealRelationships) {\n            html.writeln(\"<tr><td class='container' align='left' valign='top'>\");\n            if (hasImpliedRelationships) {\n                html.writeln(\"No 'real' Foreign Key relationships were detected in the schema.<br>\");\n                html.writeln(\"Displayed relationships are implied by a column's name/type/size matching another table's primary key.<p>\");\n            } else\n                html.writeln(\"No relationships were detected in the schema.\");\n            html.writeln(\"</td></tr>\");\n        }\n        html.writeln(\"<tr><td class='container' align='left' valign='top'>\");\n        html.writeln(\"<form name='options' action=''>\");\n        if (hasImpliedRelationships) {\n            html.write(\"  <span \");\n            // if no real relationships then hide the 'implied' checkbox and make it 'checked'\n            if (!hasRealRelationships)\n                html.write(\"style=\\\"display:none\\\" \");\n            html.writeln(\"title=\\\"Show relationships implied by column name/type/size matching another table's primary key\\\">\");\n            html.write(\"    <label for='implied'><input type='checkbox' id='implied'\" + (hasRealRelationships ? \"\" : \" checked\") + '>');\n            html.writeln(\"Implied relationships</label>\");\n            html.writeln(\"  </span>\");\n        }\n        if (hasRealRelationships || hasImpliedRelationships) {\n            html.writeln(\"  <span title=\\\"By default only columns that are primary keys, foreign keys or indexes are shown\\\">\");\n            html.write(\"    <label for='showNonKeys'><input type='checkbox' id='showNonKeys'>\");\n            html.writeln(\"All columns</label>\");\n            html.writeln(\"  </span>\");\n        }\n        html.writeln(\"</form>\");\n        html.writeln(\"</td></tr></table>\");\n    }\n\n    @Override\n    protected boolean isRelationshipsPage() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/HtmlRelationshipsPageTest0.java",
		"test_prompt": "// HtmlRelationshipsPageTest0.java\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport net.sourceforge.schemaspy.model.Database;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.LineWriter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HtmlRelationshipsPage}.\n* It contains ten unit test cases for the {@link HtmlRelationshipsPage#getInstance()} method.\n*/\nclass HtmlRelationshipsPageTest0 {"
	},
	{
		"original_code": "// HtmlRelationshipsPage.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport net.sourceforge.schemaspy.model.Database;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.LineWriter;\n\n/**\n * The page that contains the overview entity relationship diagrams.\n *\n * @author John Currier\n */\npublic class HtmlRelationshipsPage extends HtmlDiagramFormatter {\n\n    private static final HtmlRelationshipsPage instance = new HtmlRelationshipsPage();\n\n    private static final boolean fineEnabled = Logger.getLogger(HtmlRelationshipsPage.class.getName()).isLoggable(Level.FINE);\n\n    /**\n     * Singleton: Don't allow instantiation\n     */\n    private HtmlRelationshipsPage() {\n    }\n\n    /**\n     * Singleton accessor\n     *\n     * @return the singleton instance\n     */\n    public static HtmlRelationshipsPage getInstance() {\n        return instance;\n    }\n\n    public boolean write(Database db, File diagramDir, String dotBaseFilespec, boolean hasRealRelationships, boolean hasImpliedRelationships, Set<TableColumn> excludedColumns, LineWriter html) {\n        try {\n            Dot dot = getDot();\n            if (dot == null) {\n                writeHeader(db, null, \"All Relationships\", html);\n                html.writeln(\"<div class='content'>\");\n                writeInvalidGraphvizInstallation(html);\n                html.writeln(\"</div>\");\n                writeFooter(html);\n                return false;\n            }\n            File compactRelationshipsDotFile = new File(diagramDir, dotBaseFilespec + \".real.compact.dot\");\n            File compactRelationshipsDiagramFile = new File(diagramDir, dotBaseFilespec + \".real.compact.\" + dot.getFormat());\n            File largeRelationshipsDotFile = new File(diagramDir, dotBaseFilespec + \".real.large.dot\");\n            File largeRelationshipsDiagramFile = new File(diagramDir, dotBaseFilespec + \".real.large.\" + dot.getFormat());\n            File compactImpliedDotFile = new File(diagramDir, dotBaseFilespec + \".implied.compact.dot\");\n            File compactImpliedDiagramFile = new File(diagramDir, dotBaseFilespec + \".implied.compact.\" + dot.getFormat());\n            File largeImpliedDotFile = new File(diagramDir, dotBaseFilespec + \".implied.large.dot\");\n            File largeImpliedDiagramFile = new File(diagramDir, dotBaseFilespec + \".implied.large.\" + dot.getFormat());\n            writeHeader(db, \"All Relationships\", hasRealRelationships, hasImpliedRelationships, html);\n            html.writeln(\"<table width=\\\"100%\\\"><tr><td class=\\\"container\\\">\");\n            if (hasRealRelationships) {\n                if (!fineEnabled)\n                    System.out.print(\".\");\n                html.writeln(dot.generateDiagram(compactRelationshipsDotFile, compactRelationshipsDiagramFile));\n                html.writeln(\"  <a name='diagram'><img id='realCompactImg' src='diagrams/summary/\" + compactRelationshipsDiagramFile.getName() + \"' usemap='#compactRelationshipsDiagram' class='diagram' border='0' alt=''></a>\");\n                // we've run into instances where the first diagrams get generated, but then\n                // dot fails on the second one...try to recover from that scenario 'somewhat'\n                // gracefully\n                try {\n                    if (!fineEnabled)\n                        System.out.print(\".\");\n                    html.writeln(dot.generateDiagram(largeRelationshipsDotFile, largeRelationshipsDiagramFile));\n                    html.writeln(\"  <a name='diagram'><img id='realLargeImg' src='diagrams/summary/\" + largeRelationshipsDiagramFile.getName() + \"' usemap='#largeRelationshipsDiagram' class='diagram' border='0' alt=''></a>\");\n                } catch (Dot.DotFailure dotFailure) {\n                    System.err.println(\"dot failed to generate all of the relationships diagrams:\");\n                    System.err.println(dotFailure);\n                    System.err.println(\"...but the relationships page may still be usable.\");\n                }\n            }\n            try {\n                if (hasImpliedRelationships) {\n                    if (!fineEnabled)\n                        System.out.print(\".\");\n                    html.writeln(dot.generateDiagram(compactImpliedDotFile, compactImpliedDiagramFile));\n                    html.writeln(\"  <a name='diagram'><img id='impliedCompactImg' src='diagrams/summary/\" + compactImpliedDiagramFile.getName() + \"' usemap='#compactImpliedRelationshipsDiagram' class='diagram' border='0' alt=''></a>\");\n                    if (!fineEnabled)\n                        System.out.print(\".\");\n                    html.writeln(dot.generateDiagram(largeImpliedDotFile, largeImpliedDiagramFile));\n                    html.writeln(\"  <a name='diagram'><img id='impliedLargeImg' src='diagrams/summary/\" + largeImpliedDiagramFile.getName() + \"' usemap='#largeImpliedRelationshipsDiagram' class='diagram' border='0' alt=''></a>\");\n                }\n            } catch (Dot.DotFailure dotFailure) {\n                System.err.println(\"dot failed to generate all of the relationships diagrams:\");\n                System.err.println(dotFailure);\n                System.err.println(\"...but the relationships page may still be usable.\");\n            }\n            if (!fineEnabled)\n                System.out.print(\".\");\n            html.writeln(\"</td></tr></table>\");\n            writeExcludedColumns(excludedColumns, null, html);\n            writeFooter(html);\n            return true;\n        } catch (Dot.DotFailure dotFailure) {\n            System.err.println(dotFailure);\n            return false;\n        } catch (IOException ioExc) {\n            ioExc.printStackTrace();\n            return false;\n        }\n    }\n\n    private void writeHeader(Database db, String title, boolean hasRealRelationships, boolean hasImpliedRelationships, LineWriter html) throws IOException {\n        writeHeader(db, null, title, html);\n        html.writeln(\"<table class='container' width='100%'>\");\n        html.writeln(\"<tr><td class='container'>\");\n        writeGeneratedOn(db.getConnectTime(), html);\n        html.writeln(\"</td>\");\n        html.writeln(\"<td class='container' align='right' valign='top' rowspan='2'>\");\n        writeLegend(false, html);\n        html.writeln(\"</td></tr>\");\n        if (!hasRealRelationships) {\n            html.writeln(\"<tr><td class='container' align='left' valign='top'>\");\n            if (hasImpliedRelationships) {\n                html.writeln(\"No 'real' Foreign Key relationships were detected in the schema.<br>\");\n                html.writeln(\"Displayed relationships are implied by a column's name/type/size matching another table's primary key.<p>\");\n            } else\n                html.writeln(\"No relationships were detected in the schema.\");\n            html.writeln(\"</td></tr>\");\n        }\n        html.writeln(\"<tr><td class='container' align='left' valign='top'>\");\n        html.writeln(\"<form name='options' action=''>\");\n        if (hasImpliedRelationships) {\n            html.write(\"  <span \");\n            // if no real relationships then hide the 'implied' checkbox and make it 'checked'\n            if (!hasRealRelationships)\n                html.write(\"style=\\\"display:none\\\" \");\n            html.writeln(\"title=\\\"Show relationships implied by column name/type/size matching another table's primary key\\\">\");\n            html.write(\"    <label for='implied'><input type='checkbox' id='implied'\" + (hasRealRelationships ? \"\" : \" checked\") + '>');\n            html.writeln(\"Implied relationships</label>\");\n            html.writeln(\"  </span>\");\n        }\n        if (hasRealRelationships || hasImpliedRelationships) {\n            html.writeln(\"  <span title=\\\"By default only columns that are primary keys, foreign keys or indexes are shown\\\">\");\n            html.write(\"    <label for='showNonKeys'><input type='checkbox' id='showNonKeys'>\");\n            html.writeln(\"All columns</label>\");\n            html.writeln(\"  </span>\");\n        }\n        html.writeln(\"</form>\");\n        html.writeln(\"</td></tr></table>\");\n    }\n\n    @Override\n    protected boolean isRelationshipsPage() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/HtmlRelationshipsPageTest1.java",
		"test_prompt": "// HtmlRelationshipsPageTest1.java\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport net.sourceforge.schemaspy.model.Database;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.LineWriter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HtmlRelationshipsPage}.\n* It contains ten unit test cases for the {@link HtmlRelationshipsPage#write(Database, File, String, boolean, boolean, Set, LineWriter)} method.\n*/\nclass HtmlRelationshipsPageTest1 {"
	},
	{
		"original_code": "// HtmlTablePage.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.text.NumberFormat;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.Database;\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.model.TableIndex;\nimport net.sourceforge.schemaspy.model.View;\nimport net.sourceforge.schemaspy.util.CaseInsensitiveMap;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.HtmlEncoder;\nimport net.sourceforge.schemaspy.util.LineWriter;\n\n/**\n * The page that contains the details of a specific table or view\n *\n * @author John Currier\n */\npublic class HtmlTablePage extends HtmlFormatter {\n\n    private static final HtmlTablePage instance = new HtmlTablePage();\n\n    private int columnCounter = 0;\n\n    private final Map<String, String> defaultValueAliases = new HashMap<String, String>();\n\n    {\n        // DB2\n        defaultValueAliases.put(\"CURRENT TIMESTAMP\", \"now\");\n        // DB2\n        defaultValueAliases.put(\"CURRENT TIME\", \"now\");\n        // DB2\n        defaultValueAliases.put(\"CURRENT DATE\", \"now\");\n        // Oracle\n        defaultValueAliases.put(\"SYSDATE\", \"now\");\n        // Oracle\n        defaultValueAliases.put(\"CURRENT_DATE\", \"now\");\n    }\n\n    /**\n     * Singleton: Don't allow instantiation\n     */\n    private HtmlTablePage() {\n    }\n\n    /**\n     * Singleton accessor\n     *\n     * @return the singleton instance\n     */\n    public static HtmlTablePage getInstance() {\n        return instance;\n    }\n\n    public WriteStats write(Database db, Table table, File outputDir, WriteStats stats, LineWriter out) throws IOException {\n        File diagramsDir = new File(outputDir, \"diagrams\");\n        boolean hasImplied = generateDots(table, diagramsDir, stats);\n        writeHeader(db, table, null, out);\n        out.writeln(\"<table width='100%' border='0'>\");\n        out.writeln(\"<tr valign='top'><td class='container' align='left' valign='top'>\");\n        writeHeader(table, hasImplied, out);\n        out.writeln(\"</td><td class='container' rowspan='2' align='right' valign='top'>\");\n        writeLegend(true, out);\n        out.writeln(\"</td><tr valign='top'><td class='container' align='left' valign='top'>\");\n        writeMainTable(table, out);\n        writeNumRows(db, table, out);\n        out.writeln(\"</td></tr></table>\");\n        writeCheckConstraints(table, out);\n        writeIndexes(table, out);\n        writeView(table, db, out);\n        writeDiagram(table, stats, diagramsDir, out);\n        writeFooter(out);\n        return stats;\n    }\n\n    private void writeHeader(Table table, boolean hasImplied, LineWriter html) throws IOException {\n        html.writeln(\"<form name='options' action=''>\");\n        if (hasImplied) {\n            html.write(\" <label for='implied'><input type=checkbox id='implied'\");\n            if (table.isOrphan(false))\n                html.write(\" checked\");\n            html.writeln(\">Implied relationships</label>\");\n        }\n        // initially show comments if any of the columns contain comments\n        boolean showCommentsInitially = false;\n        for (TableColumn column : table.getColumns()) {\n            if (column.getComments() != null) {\n                showCommentsInitially = true;\n                break;\n            }\n        }\n        html.writeln(\" <label for='showRelatedCols'><input type=checkbox id='showRelatedCols'>Related columns</label>\");\n        html.writeln(\" <label for='showConstNames'><input type=checkbox id='showConstNames'>Constraints</label>\");\n        html.writeln(\" <label for='showComments'><input type=checkbox \" + (showCommentsInitially ? \"checked \" : \"\") + \"id='showComments'>Comments</label>\");\n        html.writeln(\" <label for='showLegend'><input type=checkbox checked id='showLegend'>Legend</label>\");\n        html.writeln(\"</form>\");\n    }\n\n    public void writeMainTable(Table table, LineWriter out) throws IOException {\n        HtmlColumnsPage.getInstance().writeMainTableHeader(table.getId() != null, null, out);\n        out.writeln(\"<tbody valign='top'>\");\n        Set<TableColumn> primaries = new HashSet<TableColumn>(table.getPrimaryColumns());\n        Set<TableColumn> indexedColumns = new HashSet<TableColumn>();\n        for (TableIndex index : table.getIndexes()) {\n            indexedColumns.addAll(index.getColumns());\n        }\n        boolean showIds = table.getId() != null;\n        for (TableColumn column : table.getColumns()) {\n            writeColumn(column, null, primaries, indexedColumns, false, showIds, out);\n        }\n        out.writeln(\"</tbody>\");\n        out.writeln(\"</table>\");\n    }\n\n    public void writeColumn(TableColumn column, String tableName, Set<TableColumn> primaries, Set<TableColumn> indexedColumns, boolean slim, boolean showIds, LineWriter out) throws IOException {\n        boolean even = columnCounter++ % 2 == 0;\n        if (even)\n            out.writeln(\"<tr class='even'>\");\n        else\n            out.writeln(\"<tr class='odd'>\");\n        if (showIds) {\n            out.write(\" <td class='detail' align='right'>\");\n            out.write(String.valueOf(column.getId()));\n            out.writeln(\"</td>\");\n        }\n        if (tableName != null) {\n            out.write(\" <td class='detail'><a href='tables/\");\n            out.write(urlEncode(tableName));\n            out.write(\".html'>\");\n            out.write(tableName);\n            out.writeln(\"</a></td>\");\n        }\n        if (primaries.contains(column))\n            out.write(\" <td class='primaryKey' title='Primary Key'>\");\n        else if (indexedColumns.contains(column))\n            out.write(\" <td class='indexedColumn' title='Indexed'>\");\n        else\n            out.write(\" <td class='detail'>\");\n        out.write(column.getName());\n        out.writeln(\"</td>\");\n        out.write(\" <td class='detail'>\");\n        out.write(column.getType().toLowerCase());\n        out.writeln(\"</td>\");\n        out.write(\" <td class='detail' align='right'>\");\n        out.write(column.getDetailedSize());\n        out.writeln(\"</td>\");\n        out.write(\" <td class='detail' align='center'\");\n        if (column.isNullable())\n            out.write(\" title='nullable'>&nbsp;&radic;&nbsp;\");\n        else\n            out.write(\">\");\n        out.writeln(\"</td>\");\n        out.write(\" <td class='detail' align='center'\");\n        if (column.isAutoUpdated()) {\n            out.write(\" title='Automatically updated by the database'>&nbsp;&radic;&nbsp;\");\n        } else {\n            out.write(\">\");\n        }\n        out.writeln(\"</td>\");\n        Object defaultValue = column.getDefaultValue();\n        if (defaultValue != null || column.isNullable()) {\n            Object alias = defaultValueAliases.get(String.valueOf(defaultValue).trim());\n            if (alias != null) {\n                out.write(\" <td class='detail' align='right' title='\");\n                out.write(String.valueOf(defaultValue));\n                out.write(\"'><i>\");\n                out.write(alias.toString());\n                out.writeln(\"</i></td>\");\n            } else {\n                out.write(\" <td class='detail' align='right'>\");\n                out.write(String.valueOf(defaultValue));\n                out.writeln(\"</td>\");\n            }\n        } else {\n            out.writeln(\" <td class='detail'></td>\");\n        }\n        if (!slim) {\n            out.write(\" <td class='detail'>\");\n            String path = tableName == null ? \"\" : \"tables/\";\n            writeRelatives(column, false, path, even, out);\n            out.writeln(\"</td>\");\n            out.write(\" <td class='detail'>\");\n            writeRelatives(column, true, path, even, out);\n            out.writeln(\" </td>\");\n        }\n        out.write(\" <td class='comment detail'>\");\n        String comments = column.getComments();\n        if (comments != null) {\n            if (encodeComments)\n                for (int i = 0; i < comments.length(); ++i) out.write(HtmlEncoder.encodeToken(comments.charAt(i)));\n            else\n                out.write(comments);\n        }\n        out.writeln(\"</td>\");\n        out.writeln(\"</tr>\");\n    }\n\n    /**\n     * Write our relatives\n     * @param tableName String\n     * @param baseRelative TableColumn\n     * @param dumpParents boolean\n     * @param out LineWriter\n     * @throws IOException\n     */\n    private void writeRelatives(TableColumn baseRelative, boolean dumpParents, String path, boolean even, LineWriter out) throws IOException {\n        Set<TableColumn> columns = dumpParents ? baseRelative.getParents() : baseRelative.getChildren();\n        final int numColumns = columns.size();\n        final String evenOdd = (even ? \"even\" : \"odd\");\n        if (numColumns > 0) {\n            out.newLine();\n            out.writeln(\"  <table border='0' width='100%' cellspacing='0' cellpadding='0'>\");\n        }\n        for (TableColumn column : columns) {\n            Table columnTable = column.getTable();\n            String columnTableName = columnTable.getName();\n            ForeignKeyConstraint constraint = dumpParents ? column.getChildConstraint(baseRelative) : column.getParentConstraint(baseRelative);\n            if (constraint.isImplied())\n                out.writeln(\"   <tr class='impliedRelationship relative \" + evenOdd + \"' valign='top'>\");\n            else\n                out.writeln(\"   <tr class='relative \" + evenOdd + \"' valign='top'>\");\n            out.write(\"    <td class='relatedTable detail' title=\\\"\");\n            out.write(constraint.toString());\n            out.write(\"\\\">\");\n            if (columnTable.isRemote() && !Config.getInstance().isOneOfMultipleSchemas()) {\n                out.write(columnTable.getContainer());\n                out.write('.');\n                out.write(columnTableName);\n            } else {\n                if (columnTable.isRemote()) {\n                    out.write(\"<a href='\");\n                    out.write(path);\n                    out.write(\"../../\" + urlEncode(columnTable.getContainer()) + \"/index.html'>\");\n                    out.write(columnTable.getContainer());\n                    out.write(\"</a>.\");\n                }\n                out.write(\"<a href='\");\n                out.write(path);\n                if (columnTable.isRemote()) {\n                    out.write(\"../../\" + urlEncode(columnTable.getContainer()) + \"/tables/\");\n                }\n                out.write(urlEncode(columnTableName));\n                out.write(\".html'>\");\n                out.write(columnTableName);\n                out.write(\"</a>\");\n            }\n            out.write(\"<span class='relatedKey'>.\");\n            out.write(column.getName());\n            out.writeln(\"</span>\");\n            out.writeln(\"    </td>\");\n            out.write(\"    <td class='constraint detail'>\");\n            out.write(constraint.getName());\n            String ruleText = constraint.getDeleteRuleDescription();\n            if (ruleText.length() > 0) {\n                String ruleAlias = constraint.getDeleteRuleAlias();\n                out.write(\"<span title='\" + ruleText + \"'>&nbsp;\" + ruleAlias + \"</span>\");\n            }\n            out.writeln(\"</td>\");\n            out.writeln(\"   </tr>\");\n        }\n        if (numColumns > 0) {\n            out.writeln(\"  </table>\");\n        }\n    }\n\n    private void writeNumRows(Database db, Table table, LineWriter out) throws IOException {\n        out.write(\"<p title='\" + table.getColumns().size() + \" columns'>\");\n        if (displayNumRows && table.getNumRows() >= 0) {\n            out.write(\"Table contained \" + NumberFormat.getIntegerInstance().format(table.getNumRows()) + \" rows at \");\n        } else {\n            out.write(\"Analyzed at \");\n        }\n        out.write(db.getConnectTime());\n        out.writeln(\"<p/>\");\n    }\n\n    private void writeCheckConstraints(Table table, LineWriter out) throws IOException {\n        Map<String, String> constraints = table.getCheckConstraints();\n        if (constraints != null && !constraints.isEmpty()) {\n            out.writeln(\"<div class='indent'>\");\n            out.writeln(\"<b>Requirements (check constraints):</b>\");\n            out.writeln(\"<table class='dataTable' border='1' rules='groups'><colgroup><colgroup>\");\n            out.writeln(\"<thead>\");\n            out.writeln(\" <tr>\");\n            out.writeln(\"  <th>Constraint</th>\");\n            out.writeln(\"  <th class='constraint' style='text-align:left;'>Constraint Name</th>\");\n            out.writeln(\" </tr>\");\n            out.writeln(\"</thead>\");\n            out.writeln(\"<tbody>\");\n            for (String name : constraints.keySet()) {\n                out.writeln(\" <tr>\");\n                out.write(\"  <td class='detail'>\");\n                out.write(HtmlEncoder.encodeString(constraints.get(name).toString()));\n                out.writeln(\"</td>\");\n                out.write(\"  <td class='constraint' style='text-align:left;'>\");\n                out.write(name);\n                out.writeln(\"</td>\");\n                out.writeln(\" </tr>\");\n            }\n            out.writeln(\"</tbody>\");\n            out.writeln(\"</table></div><p>\");\n        }\n    }\n\n    private void writeIndexes(Table table, LineWriter out) throws IOException {\n        boolean showId = table.getId() != null;\n        Set<TableIndex> indexes = table.getIndexes();\n        if (indexes != null && !indexes.isEmpty()) {\n            // see if we've got any strangeness so we can have the correct number of colgroups\n            boolean containsAnomalies = false;\n            for (TableIndex index : indexes) {\n                containsAnomalies = index.isUniqueNullable();\n                if (containsAnomalies)\n                    break;\n            }\n            out.writeln(\"<div class='indent'>\");\n            out.writeln(\"<b>Indexes:</b>\");\n            out.writeln(\"<table class='dataTable' border='1' rules='groups'><colgroup><colgroup><colgroup><colgroup>\" + (showId ? \"<colgroup>\" : \"\") + (containsAnomalies ? \"<colgroup>\" : \"\"));\n            out.writeln(\"<thead>\");\n            out.writeln(\" <tr>\");\n            if (showId)\n                out.writeln(\"  <th>ID</th>\");\n            out.writeln(\"  <th>Column(s)</th>\");\n            out.writeln(\"  <th>Type</th>\");\n            out.writeln(\"  <th>Sort</th>\");\n            out.writeln(\"  <th class='constraint' style='text-align:left;'>Constraint Name</th>\");\n            if (containsAnomalies)\n                out.writeln(\"  <th>Anomalies</th>\");\n            out.writeln(\" </tr>\");\n            out.writeln(\"</thead>\");\n            out.writeln(\"<tbody>\");\n            // sort primary keys first\n            indexes = new TreeSet<TableIndex>(indexes);\n            for (TableIndex index : indexes) {\n                out.writeln(\" <tr>\");\n                if (showId) {\n                    out.write(\"  <td class='detail' align='right'>\");\n                    out.write(String.valueOf(index.getId()));\n                    out.writeln(\"</td>\");\n                }\n                if (index.isPrimaryKey())\n                    out.write(\"  <td class='primaryKey'>\");\n                else\n                    out.write(\"  <td class='indexedColumn'>\");\n                String columns = index.getColumnsAsString();\n                if (columns.startsWith(\"+\"))\n                    columns = columns.substring(1);\n                out.write(columns);\n                out.writeln(\"</td>\");\n                out.write(\"  <td class='detail'>\");\n                out.write(index.getType());\n                out.writeln(\"</td>\");\n                out.write(\"  <td class='detail' style='text-align:left;'>\");\n                Iterator<TableColumn> columnsIter = index.getColumns().iterator();\n                while (columnsIter.hasNext()) {\n                    TableColumn column = columnsIter.next();\n                    if (index.isAscending(column))\n                        out.write(\"<span title='Ascending'>Asc</span>\");\n                    else\n                        out.write(\"<span title='Descending'>Desc</span>\");\n                    if (columnsIter.hasNext())\n                        out.write(\"/\");\n                }\n                out.writeln(\"</td>\");\n                out.write(\"  <td class='constraint' style='text-align:left;'>\");\n                out.write(index.getName());\n                out.writeln(\"</td>\");\n                if (index.isUniqueNullable()) {\n                    if (index.getColumns().size() == 1)\n                        out.writeln(\"  <td class='detail'>This unique column is also nullable</td>\");\n                    else\n                        out.writeln(\"  <td class='detail'>These unique columns are also nullable</td>\");\n                } else if (containsAnomalies) {\n                    out.writeln(\"  <td>&nbsp;</td>\");\n                }\n                out.writeln(\" </tr>\");\n            }\n            out.writeln(\"</tbody>\");\n            out.writeln(\"</table>\");\n            out.writeln(\"</div>\");\n        }\n    }\n\n    private void writeView(Table table, Database db, LineWriter out) throws IOException {\n        String sql;\n        if (table.isView() && (sql = table.getViewSql()) != null) {\n            Map<String, Table> tables = new CaseInsensitiveMap<Table>();\n            for (Table t : db.getTables()) tables.put(t.getName(), t);\n            for (View v : db.getViews()) tables.put(v.getName(), v);\n            Set<Table> references = new TreeSet<Table>();\n            String formatted = Config.getInstance().getSqlFormatter().format(sql, db, references);\n            out.writeln(\"<div class='indent spacer'>\");\n            out.writeln(\"  View Definition:\");\n            out.writeln(formatted);\n            out.writeln(\"</div>\");\n            out.writeln(\"<div class='spacer'>&nbsp;</div>\");\n            if (!references.isEmpty()) {\n                out.writeln(\"<div class='indent'>\");\n                out.writeln(\"  Possibly Referenced Tables/Views:\");\n                out.writeln(\"  <div class='viewReferences'>\");\n                out.write(\"  \");\n                for (Table t : references) {\n                    out.write(\"<a href='\");\n                    out.write(urlEncode(t.getName()));\n                    out.write(\".html'>\");\n                    out.write(t.getName());\n                    out.write(\"</a>&nbsp;\");\n                }\n                out.writeln(\"  </div>\");\n                out.writeln(\"</div><p/>\");\n            }\n        }\n    }\n\n    /**\n     * Generate the .dot file(s) to represent the specified table's relationships.\n     *\n     * Generates a <TABLENAME>.dot if the table has real relatives.\n     *\n     * Also generates a <TABLENAME>.implied2degrees.dot if the table has implied relatives within\n     * two degrees of separation.\n     *\n     * @param table Table\n     * @param diagramsDir File\n     * @throws IOException\n     * @return boolean <code>true</code> if the table has implied relatives within two\n     *                 degrees of separation.\n     */\n    private boolean generateDots(Table table, File diagramDir, WriteStats stats) throws IOException {\n        Dot dot = Dot.getInstance();\n        String extension = dot == null ? \"png\" : dot.getFormat();\n        File oneDegreeDotFile = new File(diagramDir, table.getName() + \".1degree.dot\");\n        File oneDegreeDiagramFile = new File(diagramDir, table.getName() + \".1degree.\" + extension);\n        File twoDegreesDotFile = new File(diagramDir, table.getName() + \".2degrees.dot\");\n        File twoDegreesDiagramFile = new File(diagramDir, table.getName() + \".2degrees.\" + extension);\n        File impliedDotFile = new File(diagramDir, table.getName() + \".implied2degrees.dot\");\n        File impliedDiagramFile = new File(diagramDir, table.getName() + \".implied2degrees.\" + extension);\n        // delete before we start because we'll use the existence of these files to determine\n        // if they should be turned into pngs & presented\n        oneDegreeDotFile.delete();\n        oneDegreeDiagramFile.delete();\n        twoDegreesDotFile.delete();\n        twoDegreesDiagramFile.delete();\n        impliedDotFile.delete();\n        impliedDiagramFile.delete();\n        if (table.getMaxChildren() + table.getMaxParents() > 0) {\n            Set<ForeignKeyConstraint> impliedConstraints;\n            DotFormatter formatter = DotFormatter.getInstance();\n            LineWriter dotOut = new LineWriter(oneDegreeDotFile, Config.DOT_CHARSET);\n            WriteStats oneStats = new WriteStats(stats);\n            formatter.writeRealRelationships(table, false, oneStats, dotOut);\n            dotOut.close();\n            dotOut = new LineWriter(twoDegreesDotFile, Config.DOT_CHARSET);\n            WriteStats twoStats = new WriteStats(stats);\n            impliedConstraints = formatter.writeRealRelationships(table, true, twoStats, dotOut);\n            dotOut.close();\n            if (oneStats.getNumTablesWritten() + oneStats.getNumViewsWritten() == twoStats.getNumTablesWritten() + twoStats.getNumViewsWritten()) {\n                // no different than before, so don't show it\n                twoDegreesDotFile.delete();\n            }\n            if (!impliedConstraints.isEmpty()) {\n                dotOut = new LineWriter(impliedDotFile, Config.DOT_CHARSET);\n                formatter.writeAllRelationships(table, true, stats, dotOut);\n                dotOut.close();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void writeDiagram(Table table, WriteStats stats, File diagramsDir, LineWriter html) throws IOException {\n        if (table.getMaxChildren() + table.getMaxParents() > 0) {\n            html.writeln(\"<table width='100%' border='0'><tr><td class='container'>\");\n            if (HtmlTableDiagrammer.getInstance().write(table, diagramsDir, html)) {\n                html.writeln(\"</td></tr></table>\");\n                writeExcludedColumns(stats.getExcludedColumns(), table, html);\n            } else {\n                html.writeln(\"</td></tr></table><p>\");\n                writeInvalidGraphvizInstallation(html);\n            }\n        }\n    }\n\n    @Override\n    protected String getPathToRoot() {\n        return \"../\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/HtmlTablePageTest0.java",
		"test_prompt": "// HtmlTablePageTest0.java\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.text.NumberFormat;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.Database;\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.model.TableIndex;\nimport net.sourceforge.schemaspy.model.View;\nimport net.sourceforge.schemaspy.util.CaseInsensitiveMap;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.HtmlEncoder;\nimport net.sourceforge.schemaspy.util.LineWriter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HtmlTablePage}.\n* It contains ten unit test cases for the {@link HtmlTablePage#getInstance()} method.\n*/\nclass HtmlTablePageTest0 {"
	},
	{
		"original_code": "// HtmlTablePage.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.text.NumberFormat;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.Database;\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.model.TableIndex;\nimport net.sourceforge.schemaspy.model.View;\nimport net.sourceforge.schemaspy.util.CaseInsensitiveMap;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.HtmlEncoder;\nimport net.sourceforge.schemaspy.util.LineWriter;\n\n/**\n * The page that contains the details of a specific table or view\n *\n * @author John Currier\n */\npublic class HtmlTablePage extends HtmlFormatter {\n\n    private static final HtmlTablePage instance = new HtmlTablePage();\n\n    private int columnCounter = 0;\n\n    private final Map<String, String> defaultValueAliases = new HashMap<String, String>();\n\n    {\n        // DB2\n        defaultValueAliases.put(\"CURRENT TIMESTAMP\", \"now\");\n        // DB2\n        defaultValueAliases.put(\"CURRENT TIME\", \"now\");\n        // DB2\n        defaultValueAliases.put(\"CURRENT DATE\", \"now\");\n        // Oracle\n        defaultValueAliases.put(\"SYSDATE\", \"now\");\n        // Oracle\n        defaultValueAliases.put(\"CURRENT_DATE\", \"now\");\n    }\n\n    /**\n     * Singleton: Don't allow instantiation\n     */\n    private HtmlTablePage() {\n    }\n\n    /**\n     * Singleton accessor\n     *\n     * @return the singleton instance\n     */\n    public static HtmlTablePage getInstance() {\n        return instance;\n    }\n\n    public WriteStats write(Database db, Table table, File outputDir, WriteStats stats, LineWriter out) throws IOException {\n        File diagramsDir = new File(outputDir, \"diagrams\");\n        boolean hasImplied = generateDots(table, diagramsDir, stats);\n        writeHeader(db, table, null, out);\n        out.writeln(\"<table width='100%' border='0'>\");\n        out.writeln(\"<tr valign='top'><td class='container' align='left' valign='top'>\");\n        writeHeader(table, hasImplied, out);\n        out.writeln(\"</td><td class='container' rowspan='2' align='right' valign='top'>\");\n        writeLegend(true, out);\n        out.writeln(\"</td><tr valign='top'><td class='container' align='left' valign='top'>\");\n        writeMainTable(table, out);\n        writeNumRows(db, table, out);\n        out.writeln(\"</td></tr></table>\");\n        writeCheckConstraints(table, out);\n        writeIndexes(table, out);\n        writeView(table, db, out);\n        writeDiagram(table, stats, diagramsDir, out);\n        writeFooter(out);\n        return stats;\n    }\n\n    private void writeHeader(Table table, boolean hasImplied, LineWriter html) throws IOException {\n        html.writeln(\"<form name='options' action=''>\");\n        if (hasImplied) {\n            html.write(\" <label for='implied'><input type=checkbox id='implied'\");\n            if (table.isOrphan(false))\n                html.write(\" checked\");\n            html.writeln(\">Implied relationships</label>\");\n        }\n        // initially show comments if any of the columns contain comments\n        boolean showCommentsInitially = false;\n        for (TableColumn column : table.getColumns()) {\n            if (column.getComments() != null) {\n                showCommentsInitially = true;\n                break;\n            }\n        }\n        html.writeln(\" <label for='showRelatedCols'><input type=checkbox id='showRelatedCols'>Related columns</label>\");\n        html.writeln(\" <label for='showConstNames'><input type=checkbox id='showConstNames'>Constraints</label>\");\n        html.writeln(\" <label for='showComments'><input type=checkbox \" + (showCommentsInitially ? \"checked \" : \"\") + \"id='showComments'>Comments</label>\");\n        html.writeln(\" <label for='showLegend'><input type=checkbox checked id='showLegend'>Legend</label>\");\n        html.writeln(\"</form>\");\n    }\n\n    public void writeMainTable(Table table, LineWriter out) throws IOException {\n        HtmlColumnsPage.getInstance().writeMainTableHeader(table.getId() != null, null, out);\n        out.writeln(\"<tbody valign='top'>\");\n        Set<TableColumn> primaries = new HashSet<TableColumn>(table.getPrimaryColumns());\n        Set<TableColumn> indexedColumns = new HashSet<TableColumn>();\n        for (TableIndex index : table.getIndexes()) {\n            indexedColumns.addAll(index.getColumns());\n        }\n        boolean showIds = table.getId() != null;\n        for (TableColumn column : table.getColumns()) {\n            writeColumn(column, null, primaries, indexedColumns, false, showIds, out);\n        }\n        out.writeln(\"</tbody>\");\n        out.writeln(\"</table>\");\n    }\n\n    public void writeColumn(TableColumn column, String tableName, Set<TableColumn> primaries, Set<TableColumn> indexedColumns, boolean slim, boolean showIds, LineWriter out) throws IOException {\n        boolean even = columnCounter++ % 2 == 0;\n        if (even)\n            out.writeln(\"<tr class='even'>\");\n        else\n            out.writeln(\"<tr class='odd'>\");\n        if (showIds) {\n            out.write(\" <td class='detail' align='right'>\");\n            out.write(String.valueOf(column.getId()));\n            out.writeln(\"</td>\");\n        }\n        if (tableName != null) {\n            out.write(\" <td class='detail'><a href='tables/\");\n            out.write(urlEncode(tableName));\n            out.write(\".html'>\");\n            out.write(tableName);\n            out.writeln(\"</a></td>\");\n        }\n        if (primaries.contains(column))\n            out.write(\" <td class='primaryKey' title='Primary Key'>\");\n        else if (indexedColumns.contains(column))\n            out.write(\" <td class='indexedColumn' title='Indexed'>\");\n        else\n            out.write(\" <td class='detail'>\");\n        out.write(column.getName());\n        out.writeln(\"</td>\");\n        out.write(\" <td class='detail'>\");\n        out.write(column.getType().toLowerCase());\n        out.writeln(\"</td>\");\n        out.write(\" <td class='detail' align='right'>\");\n        out.write(column.getDetailedSize());\n        out.writeln(\"</td>\");\n        out.write(\" <td class='detail' align='center'\");\n        if (column.isNullable())\n            out.write(\" title='nullable'>&nbsp;&radic;&nbsp;\");\n        else\n            out.write(\">\");\n        out.writeln(\"</td>\");\n        out.write(\" <td class='detail' align='center'\");\n        if (column.isAutoUpdated()) {\n            out.write(\" title='Automatically updated by the database'>&nbsp;&radic;&nbsp;\");\n        } else {\n            out.write(\">\");\n        }\n        out.writeln(\"</td>\");\n        Object defaultValue = column.getDefaultValue();\n        if (defaultValue != null || column.isNullable()) {\n            Object alias = defaultValueAliases.get(String.valueOf(defaultValue).trim());\n            if (alias != null) {\n                out.write(\" <td class='detail' align='right' title='\");\n                out.write(String.valueOf(defaultValue));\n                out.write(\"'><i>\");\n                out.write(alias.toString());\n                out.writeln(\"</i></td>\");\n            } else {\n                out.write(\" <td class='detail' align='right'>\");\n                out.write(String.valueOf(defaultValue));\n                out.writeln(\"</td>\");\n            }\n        } else {\n            out.writeln(\" <td class='detail'></td>\");\n        }\n        if (!slim) {\n            out.write(\" <td class='detail'>\");\n            String path = tableName == null ? \"\" : \"tables/\";\n            writeRelatives(column, false, path, even, out);\n            out.writeln(\"</td>\");\n            out.write(\" <td class='detail'>\");\n            writeRelatives(column, true, path, even, out);\n            out.writeln(\" </td>\");\n        }\n        out.write(\" <td class='comment detail'>\");\n        String comments = column.getComments();\n        if (comments != null) {\n            if (encodeComments)\n                for (int i = 0; i < comments.length(); ++i) out.write(HtmlEncoder.encodeToken(comments.charAt(i)));\n            else\n                out.write(comments);\n        }\n        out.writeln(\"</td>\");\n        out.writeln(\"</tr>\");\n    }\n\n    /**\n     * Write our relatives\n     * @param tableName String\n     * @param baseRelative TableColumn\n     * @param dumpParents boolean\n     * @param out LineWriter\n     * @throws IOException\n     */\n    private void writeRelatives(TableColumn baseRelative, boolean dumpParents, String path, boolean even, LineWriter out) throws IOException {\n        Set<TableColumn> columns = dumpParents ? baseRelative.getParents() : baseRelative.getChildren();\n        final int numColumns = columns.size();\n        final String evenOdd = (even ? \"even\" : \"odd\");\n        if (numColumns > 0) {\n            out.newLine();\n            out.writeln(\"  <table border='0' width='100%' cellspacing='0' cellpadding='0'>\");\n        }\n        for (TableColumn column : columns) {\n            Table columnTable = column.getTable();\n            String columnTableName = columnTable.getName();\n            ForeignKeyConstraint constraint = dumpParents ? column.getChildConstraint(baseRelative) : column.getParentConstraint(baseRelative);\n            if (constraint.isImplied())\n                out.writeln(\"   <tr class='impliedRelationship relative \" + evenOdd + \"' valign='top'>\");\n            else\n                out.writeln(\"   <tr class='relative \" + evenOdd + \"' valign='top'>\");\n            out.write(\"    <td class='relatedTable detail' title=\\\"\");\n            out.write(constraint.toString());\n            out.write(\"\\\">\");\n            if (columnTable.isRemote() && !Config.getInstance().isOneOfMultipleSchemas()) {\n                out.write(columnTable.getContainer());\n                out.write('.');\n                out.write(columnTableName);\n            } else {\n                if (columnTable.isRemote()) {\n                    out.write(\"<a href='\");\n                    out.write(path);\n                    out.write(\"../../\" + urlEncode(columnTable.getContainer()) + \"/index.html'>\");\n                    out.write(columnTable.getContainer());\n                    out.write(\"</a>.\");\n                }\n                out.write(\"<a href='\");\n                out.write(path);\n                if (columnTable.isRemote()) {\n                    out.write(\"../../\" + urlEncode(columnTable.getContainer()) + \"/tables/\");\n                }\n                out.write(urlEncode(columnTableName));\n                out.write(\".html'>\");\n                out.write(columnTableName);\n                out.write(\"</a>\");\n            }\n            out.write(\"<span class='relatedKey'>.\");\n            out.write(column.getName());\n            out.writeln(\"</span>\");\n            out.writeln(\"    </td>\");\n            out.write(\"    <td class='constraint detail'>\");\n            out.write(constraint.getName());\n            String ruleText = constraint.getDeleteRuleDescription();\n            if (ruleText.length() > 0) {\n                String ruleAlias = constraint.getDeleteRuleAlias();\n                out.write(\"<span title='\" + ruleText + \"'>&nbsp;\" + ruleAlias + \"</span>\");\n            }\n            out.writeln(\"</td>\");\n            out.writeln(\"   </tr>\");\n        }\n        if (numColumns > 0) {\n            out.writeln(\"  </table>\");\n        }\n    }\n\n    private void writeNumRows(Database db, Table table, LineWriter out) throws IOException {\n        out.write(\"<p title='\" + table.getColumns().size() + \" columns'>\");\n        if (displayNumRows && table.getNumRows() >= 0) {\n            out.write(\"Table contained \" + NumberFormat.getIntegerInstance().format(table.getNumRows()) + \" rows at \");\n        } else {\n            out.write(\"Analyzed at \");\n        }\n        out.write(db.getConnectTime());\n        out.writeln(\"<p/>\");\n    }\n\n    private void writeCheckConstraints(Table table, LineWriter out) throws IOException {\n        Map<String, String> constraints = table.getCheckConstraints();\n        if (constraints != null && !constraints.isEmpty()) {\n            out.writeln(\"<div class='indent'>\");\n            out.writeln(\"<b>Requirements (check constraints):</b>\");\n            out.writeln(\"<table class='dataTable' border='1' rules='groups'><colgroup><colgroup>\");\n            out.writeln(\"<thead>\");\n            out.writeln(\" <tr>\");\n            out.writeln(\"  <th>Constraint</th>\");\n            out.writeln(\"  <th class='constraint' style='text-align:left;'>Constraint Name</th>\");\n            out.writeln(\" </tr>\");\n            out.writeln(\"</thead>\");\n            out.writeln(\"<tbody>\");\n            for (String name : constraints.keySet()) {\n                out.writeln(\" <tr>\");\n                out.write(\"  <td class='detail'>\");\n                out.write(HtmlEncoder.encodeString(constraints.get(name).toString()));\n                out.writeln(\"</td>\");\n                out.write(\"  <td class='constraint' style='text-align:left;'>\");\n                out.write(name);\n                out.writeln(\"</td>\");\n                out.writeln(\" </tr>\");\n            }\n            out.writeln(\"</tbody>\");\n            out.writeln(\"</table></div><p>\");\n        }\n    }\n\n    private void writeIndexes(Table table, LineWriter out) throws IOException {\n        boolean showId = table.getId() != null;\n        Set<TableIndex> indexes = table.getIndexes();\n        if (indexes != null && !indexes.isEmpty()) {\n            // see if we've got any strangeness so we can have the correct number of colgroups\n            boolean containsAnomalies = false;\n            for (TableIndex index : indexes) {\n                containsAnomalies = index.isUniqueNullable();\n                if (containsAnomalies)\n                    break;\n            }\n            out.writeln(\"<div class='indent'>\");\n            out.writeln(\"<b>Indexes:</b>\");\n            out.writeln(\"<table class='dataTable' border='1' rules='groups'><colgroup><colgroup><colgroup><colgroup>\" + (showId ? \"<colgroup>\" : \"\") + (containsAnomalies ? \"<colgroup>\" : \"\"));\n            out.writeln(\"<thead>\");\n            out.writeln(\" <tr>\");\n            if (showId)\n                out.writeln(\"  <th>ID</th>\");\n            out.writeln(\"  <th>Column(s)</th>\");\n            out.writeln(\"  <th>Type</th>\");\n            out.writeln(\"  <th>Sort</th>\");\n            out.writeln(\"  <th class='constraint' style='text-align:left;'>Constraint Name</th>\");\n            if (containsAnomalies)\n                out.writeln(\"  <th>Anomalies</th>\");\n            out.writeln(\" </tr>\");\n            out.writeln(\"</thead>\");\n            out.writeln(\"<tbody>\");\n            // sort primary keys first\n            indexes = new TreeSet<TableIndex>(indexes);\n            for (TableIndex index : indexes) {\n                out.writeln(\" <tr>\");\n                if (showId) {\n                    out.write(\"  <td class='detail' align='right'>\");\n                    out.write(String.valueOf(index.getId()));\n                    out.writeln(\"</td>\");\n                }\n                if (index.isPrimaryKey())\n                    out.write(\"  <td class='primaryKey'>\");\n                else\n                    out.write(\"  <td class='indexedColumn'>\");\n                String columns = index.getColumnsAsString();\n                if (columns.startsWith(\"+\"))\n                    columns = columns.substring(1);\n                out.write(columns);\n                out.writeln(\"</td>\");\n                out.write(\"  <td class='detail'>\");\n                out.write(index.getType());\n                out.writeln(\"</td>\");\n                out.write(\"  <td class='detail' style='text-align:left;'>\");\n                Iterator<TableColumn> columnsIter = index.getColumns().iterator();\n                while (columnsIter.hasNext()) {\n                    TableColumn column = columnsIter.next();\n                    if (index.isAscending(column))\n                        out.write(\"<span title='Ascending'>Asc</span>\");\n                    else\n                        out.write(\"<span title='Descending'>Desc</span>\");\n                    if (columnsIter.hasNext())\n                        out.write(\"/\");\n                }\n                out.writeln(\"</td>\");\n                out.write(\"  <td class='constraint' style='text-align:left;'>\");\n                out.write(index.getName());\n                out.writeln(\"</td>\");\n                if (index.isUniqueNullable()) {\n                    if (index.getColumns().size() == 1)\n                        out.writeln(\"  <td class='detail'>This unique column is also nullable</td>\");\n                    else\n                        out.writeln(\"  <td class='detail'>These unique columns are also nullable</td>\");\n                } else if (containsAnomalies) {\n                    out.writeln(\"  <td>&nbsp;</td>\");\n                }\n                out.writeln(\" </tr>\");\n            }\n            out.writeln(\"</tbody>\");\n            out.writeln(\"</table>\");\n            out.writeln(\"</div>\");\n        }\n    }\n\n    private void writeView(Table table, Database db, LineWriter out) throws IOException {\n        String sql;\n        if (table.isView() && (sql = table.getViewSql()) != null) {\n            Map<String, Table> tables = new CaseInsensitiveMap<Table>();\n            for (Table t : db.getTables()) tables.put(t.getName(), t);\n            for (View v : db.getViews()) tables.put(v.getName(), v);\n            Set<Table> references = new TreeSet<Table>();\n            String formatted = Config.getInstance().getSqlFormatter().format(sql, db, references);\n            out.writeln(\"<div class='indent spacer'>\");\n            out.writeln(\"  View Definition:\");\n            out.writeln(formatted);\n            out.writeln(\"</div>\");\n            out.writeln(\"<div class='spacer'>&nbsp;</div>\");\n            if (!references.isEmpty()) {\n                out.writeln(\"<div class='indent'>\");\n                out.writeln(\"  Possibly Referenced Tables/Views:\");\n                out.writeln(\"  <div class='viewReferences'>\");\n                out.write(\"  \");\n                for (Table t : references) {\n                    out.write(\"<a href='\");\n                    out.write(urlEncode(t.getName()));\n                    out.write(\".html'>\");\n                    out.write(t.getName());\n                    out.write(\"</a>&nbsp;\");\n                }\n                out.writeln(\"  </div>\");\n                out.writeln(\"</div><p/>\");\n            }\n        }\n    }\n\n    /**\n     * Generate the .dot file(s) to represent the specified table's relationships.\n     *\n     * Generates a <TABLENAME>.dot if the table has real relatives.\n     *\n     * Also generates a <TABLENAME>.implied2degrees.dot if the table has implied relatives within\n     * two degrees of separation.\n     *\n     * @param table Table\n     * @param diagramsDir File\n     * @throws IOException\n     * @return boolean <code>true</code> if the table has implied relatives within two\n     *                 degrees of separation.\n     */\n    private boolean generateDots(Table table, File diagramDir, WriteStats stats) throws IOException {\n        Dot dot = Dot.getInstance();\n        String extension = dot == null ? \"png\" : dot.getFormat();\n        File oneDegreeDotFile = new File(diagramDir, table.getName() + \".1degree.dot\");\n        File oneDegreeDiagramFile = new File(diagramDir, table.getName() + \".1degree.\" + extension);\n        File twoDegreesDotFile = new File(diagramDir, table.getName() + \".2degrees.dot\");\n        File twoDegreesDiagramFile = new File(diagramDir, table.getName() + \".2degrees.\" + extension);\n        File impliedDotFile = new File(diagramDir, table.getName() + \".implied2degrees.dot\");\n        File impliedDiagramFile = new File(diagramDir, table.getName() + \".implied2degrees.\" + extension);\n        // delete before we start because we'll use the existence of these files to determine\n        // if they should be turned into pngs & presented\n        oneDegreeDotFile.delete();\n        oneDegreeDiagramFile.delete();\n        twoDegreesDotFile.delete();\n        twoDegreesDiagramFile.delete();\n        impliedDotFile.delete();\n        impliedDiagramFile.delete();\n        if (table.getMaxChildren() + table.getMaxParents() > 0) {\n            Set<ForeignKeyConstraint> impliedConstraints;\n            DotFormatter formatter = DotFormatter.getInstance();\n            LineWriter dotOut = new LineWriter(oneDegreeDotFile, Config.DOT_CHARSET);\n            WriteStats oneStats = new WriteStats(stats);\n            formatter.writeRealRelationships(table, false, oneStats, dotOut);\n            dotOut.close();\n            dotOut = new LineWriter(twoDegreesDotFile, Config.DOT_CHARSET);\n            WriteStats twoStats = new WriteStats(stats);\n            impliedConstraints = formatter.writeRealRelationships(table, true, twoStats, dotOut);\n            dotOut.close();\n            if (oneStats.getNumTablesWritten() + oneStats.getNumViewsWritten() == twoStats.getNumTablesWritten() + twoStats.getNumViewsWritten()) {\n                // no different than before, so don't show it\n                twoDegreesDotFile.delete();\n            }\n            if (!impliedConstraints.isEmpty()) {\n                dotOut = new LineWriter(impliedDotFile, Config.DOT_CHARSET);\n                formatter.writeAllRelationships(table, true, stats, dotOut);\n                dotOut.close();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void writeDiagram(Table table, WriteStats stats, File diagramsDir, LineWriter html) throws IOException {\n        if (table.getMaxChildren() + table.getMaxParents() > 0) {\n            html.writeln(\"<table width='100%' border='0'><tr><td class='container'>\");\n            if (HtmlTableDiagrammer.getInstance().write(table, diagramsDir, html)) {\n                html.writeln(\"</td></tr></table>\");\n                writeExcludedColumns(stats.getExcludedColumns(), table, html);\n            } else {\n                html.writeln(\"</td></tr></table><p>\");\n                writeInvalidGraphvizInstallation(html);\n            }\n        }\n    }\n\n    @Override\n    protected String getPathToRoot() {\n        return \"../\";\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/HtmlTablePageTest1.java",
		"test_prompt": "// HtmlTablePageTest1.java\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.text.NumberFormat;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.Database;\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.model.TableIndex;\nimport net.sourceforge.schemaspy.model.View;\nimport net.sourceforge.schemaspy.util.CaseInsensitiveMap;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.HtmlEncoder;\nimport net.sourceforge.schemaspy.util.LineWriter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HtmlTablePage}.\n* It contains ten unit test cases for the {@link HtmlTablePage#write(Database, Table, File, WriteStats, LineWriter)} method.\n*/\nclass HtmlTablePageTest1 {"
	},
	{
		"original_code": "// HtmlMainIndexPage.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.IOException;\nimport java.text.NumberFormat;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.TreeSet;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.Database;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.util.HtmlEncoder;\nimport net.sourceforge.schemaspy.util.LineWriter;\n\n/**\n * The main index that contains all tables and views that were evaluated\n *\n * @author John Currier\n */\npublic class HtmlMainIndexPage extends HtmlFormatter {\n\n    private static HtmlMainIndexPage instance = new HtmlMainIndexPage();\n\n    private final NumberFormat integerFormatter = NumberFormat.getIntegerInstance();\n\n    /**\n     * Singleton: Don't allow instantiation\n     */\n    private HtmlMainIndexPage() {\n    }\n\n    /**\n     * Singleton accessor\n     *\n     * @return the singleton instance\n     */\n    public static HtmlMainIndexPage getInstance() {\n        return instance;\n    }\n\n    public void write(Database database, Collection<Table> tables, Collection<Table> remotes, LineWriter html) throws IOException {\n        Comparator<Table> sorter = new Comparator<Table>() {\n\n            public int compare(Table table1, Table table2) {\n                return table1.compareTo(table2);\n            }\n        };\n        // sort tables and remotes by name\n        Collection<Table> tmp = new TreeSet<Table>(sorter);\n        tmp.addAll(tables);\n        tables = tmp;\n        tmp = new TreeSet<Table>(sorter);\n        tmp.addAll(remotes);\n        remotes = tmp;\n        tmp = null;\n        boolean showIds = false;\n        int numViews = 0;\n        boolean hasComments = false;\n        for (Table table : tables) {\n            if (table.isView())\n                ++numViews;\n            showIds |= table.getId() != null;\n            if (table.getComments() != null)\n                hasComments = true;\n        }\n        writeLocalsHeader(database, tables.size() - numViews, numViews, showIds, hasComments, html);\n        int numTableCols = 0;\n        int numViewCols = 0;\n        long numRows = 0;\n        for (Table table : tables) {\n            writeLineItem(table, showIds, html);\n            if (!table.isView())\n                numTableCols += table.getColumns().size();\n            else\n                numViewCols += table.getColumns().size();\n            numRows += table.getNumRows() > 0 ? table.getNumRows() : 0;\n        }\n        writeLocalsFooter(tables.size() - numViews, numTableCols, numViews, numViewCols, numRows, html);\n        if (!remotes.isEmpty()) {\n            writeRemotesHeader(database, showIds, hasComments, html);\n            for (Table table : remotes) {\n                writeLineItem(table, showIds, html);\n            }\n            writeRemotesFooter(html);\n        }\n        writeFooter(html);\n    }\n\n    private void writeLocalsHeader(Database db, int numberOfTables, int numberOfViews, boolean showIds, boolean hasComments, LineWriter html) throws IOException {\n        List<String> javascript = new ArrayList<String>();\n        // we can't use the hard-coded even odd technique that we use\n        // everywhere else because we're dynamically changing the visibility\n        // of tables/views within the list\n        javascript.add(\"$(function(){\");\n        javascript.add(\"  associate($('#showTables'), $('.tbl'));\");\n        javascript.add(\"  associate($('#showViews'),  $('.view'));\");\n        javascript.add(\"  jQuery.fn.alternateRowColors = function() {\");\n        javascript.add(\"    $('tbody tr:visible').each(function(i) {\");\n        javascript.add(\"      if (i % 2 == 0) {\");\n        javascript.add(\"        $(this).removeClass('even').addClass('odd');\");\n        javascript.add(\"      } else {\");\n        javascript.add(\"        $(this).removeClass('odd').addClass('even');\");\n        javascript.add(\"      }\");\n        javascript.add(\"    });\");\n        javascript.add(\"    return this;\");\n        javascript.add(\"  };\");\n        javascript.add(\"  $('#showTables, #showViews').click(function() {\");\n        javascript.add(\"    $('table.dataTable').alternateRowColors();\");\n        javascript.add(\"  });\");\n        javascript.add(\"  $('table.dataTable').alternateRowColors();\");\n        javascript.add(\"})\");\n        writeHeader(db, null, null, javascript, html);\n        html.writeln(\"<table width='100%'>\");\n        html.writeln(\" <tr><td class='container'>\");\n        writeGeneratedOn(db.getConnectTime(), html);\n        html.writeln(\" </td></tr>\");\n        html.writeln(\" <tr>\");\n        html.write(\"  <td class='container'>Database Type: \");\n        html.write(db.getDatabaseProduct());\n        html.writeln(\"  </td>\");\n        html.writeln(\"  <td class='container' align='right' valign='top' rowspan='3'>\");\n        if (sourceForgeLogoEnabled())\n            html.writeln(\"    <a href='http://sourceforge.net' target='_blank'><img src='http://sourceforge.net/sflogo.php?group_id=137197&amp;type=1' alt='SourceForge.net' border='0' height='31' width='88'></a><br>\");\n        html.writeln(\"    <br>\");\n        html.writeln(\"  </td>\");\n        html.writeln(\" </tr>\");\n        html.writeln(\" <tr>\");\n        html.write(\"  <td class='container'>\");\n        String xmlName = db.getName();\n        if (db.getSchema() != null)\n            xmlName += '.' + db.getSchema();\n        else if (db.getCatalog() != null)\n            xmlName += '.' + db.getCatalog();\n        html.write(\"<br><a href='\" + xmlName + \".xml' title='XML Representation'>XML Representation</a>\");\n        html.write(\"<br><a href='insertionOrder.txt' title='Useful for loading data into a database'>Insertion Order</a>&nbsp;\");\n        html.write(\"<a href='deletionOrder.txt' title='Useful for purging data from a database'>Deletion Order</a>\");\n        html.writeln(\"</td>\");\n        html.writeln(\" </tr>\");\n        html.writeln(\"</table>\");\n        html.writeln(\"<div class='indent'>\");\n        html.write(\"<p>\");\n        html.write(\"<b>\");\n        if (numberOfViews == 0) {\n            html.writeln(\"<label for='showTables' style='display:none;'><input type='checkbox' id='showTables' checked></label>\");\n        } else if (numberOfTables == 0) {\n            html.writeln(\"<label for='showViews' style='display:none;'><input type='checkbox' id='showViews' checked></label>\");\n        } else {\n            html.write(\"<label for='showTables'><input type='checkbox' id='showTables' checked>Tables</label>\");\n            html.write(\" <label for='showViews'><input type='checkbox' id='showViews' checked>Views</label>\");\n        }\n        html.writeln(\" <label for='showComments'><input type=checkbox \" + (hasComments ? \"checked \" : \"\") + \"id='showComments'>Comments</label>\");\n        html.writeln(\"</b>\");\n        html.writeln(\"<table class='dataTable' border='1' rules='groups'>\");\n        int numGroups = 4 + (showIds ? 1 : 0) + (displayNumRows ? 1 : 0);\n        for (int i = 0; i < numGroups; ++i) html.writeln(\"<colgroup>\");\n        html.writeln(\"<colgroup class='comment'>\");\n        html.writeln(\"<thead align='left'>\");\n        html.writeln(\"<tr>\");\n        String tableHeading;\n        if (numberOfViews == 0)\n            tableHeading = \"Table\";\n        else if (numberOfTables == 0)\n            tableHeading = \"View\";\n        else\n            tableHeading = \"Table / View\";\n        html.writeln(\"  <th valign='bottom'>\" + tableHeading + \"</th>\");\n        if (showIds)\n            html.writeln(\"  <th align='center' valign='bottom'>ID</th>\");\n        html.writeln(\"  <th align='right' valign='bottom'>Children</th>\");\n        html.writeln(\"  <th align='right' valign='bottom'>Parents</th>\");\n        html.writeln(\"  <th align='right' valign='bottom'>Columns</th>\");\n        if (displayNumRows)\n            html.writeln(\"  <th align='right' valign='bottom'>Rows</th>\");\n        html.writeln(\"  <th class='comment' align='left' valign='bottom'>Comments</th>\");\n        html.writeln(\"</tr>\");\n        html.writeln(\"</thead>\");\n        html.writeln(\"<tbody>\");\n    }\n\n    private void writeRemotesHeader(Database db, boolean showIds, boolean hasComments, LineWriter html) throws IOException {\n        html.writeln(\"<p><br><b>Related tables in other schemas</b>\");\n        html.writeln(\"<table class='dataTable' border='1' rules='groups'>\");\n        int numGroups = 3 + (showIds ? 1 : 0);\n        for (int i = 0; i < numGroups; ++i) html.writeln(\"<colgroup>\");\n        html.writeln(\"<colgroup class='comment'>\");\n        html.writeln(\"<thead align='left'>\");\n        html.writeln(\"<tr>\");\n        html.writeln(\"  <th rowspan='2'>Table</th>\");\n        if (showIds)\n            html.writeln(\"  <th align='center' valign='bottom' rowspan='2'>ID</th>\");\n        html.writeln(\"  <th valign='bottom' colspan='2' style='text-align: center;'>In this schema</th>\");\n        html.writeln(\"  <th class='comment' align='left' valign='bottom' rowspan='2'>Comments</th>\");\n        html.writeln(\"</tr>\");\n        html.writeln(\"<tr>\");\n        html.writeln(\"  <th align='right' valign='bottom'>Children</th>\");\n        html.writeln(\"  <th align='right' valign='bottom'>Parents</th>\");\n        html.writeln(\"</tr>\");\n        html.writeln(\"</thead>\");\n        html.writeln(\"<tbody>\");\n    }\n\n    private void writeLineItem(Table table, boolean showIds, LineWriter html) throws IOException {\n        html.write(\" <tr class='\" + (table.isView() ? \"view\" : \"tbl\") + \"' valign='top'>\");\n        html.write(\"  <td class='detail'>\");\n        String tableName = table.getName();\n        if (table.isRemote() && !Config.getInstance().isOneOfMultipleSchemas()) {\n            html.write(table.getContainer());\n            html.write('.');\n            html.write(tableName);\n        } else {\n            if (table.isRemote()) {\n                html.write(\"<a href='../\" + urlEncode(table.getContainer()) + \"/index.html'>\");\n                html.write(table.getContainer());\n                html.write(\"</a>.\");\n            }\n            html.write(\"<a href='tables/\");\n            if (table.isRemote()) {\n                html.write(\"../../\" + urlEncode(table.getContainer()) + \"/tables/\");\n            }\n            html.write(urlEncode(tableName));\n            html.write(\".html'>\");\n            html.write(tableName);\n            html.write(\"</a>\");\n        }\n        html.writeln(\"</td>\");\n        if (showIds) {\n            html.write(\"  <td class='detail' align='right'>\");\n            Object id = table.getId();\n            if (id != null)\n                html.write(String.valueOf(id));\n            else\n                html.writeln(\"&nbsp;\");\n            html.writeln(\"</td>\");\n        }\n        html.write(\"  <td class='detail' align='right'>\");\n        int numRelatives = table.getNumNonImpliedChildren();\n        if (numRelatives != 0)\n            html.write(String.valueOf(integerFormatter.format(numRelatives)));\n        html.writeln(\"</td>\");\n        html.write(\"  <td class='detail' align='right'>\");\n        numRelatives = table.getNumNonImpliedParents();\n        if (numRelatives != 0)\n            html.write(String.valueOf(integerFormatter.format(numRelatives)));\n        html.writeln(\"</td>\");\n        if (!table.isRemote()) {\n            html.write(\"  <td class='detail' align='right'>\");\n            html.write(String.valueOf(integerFormatter.format(table.getColumns().size())));\n            html.writeln(\"</td>\");\n            if (displayNumRows) {\n                html.write(\"  <td class='detail' align='right'>\");\n                if (!table.isView()) {\n                    if (table.getNumRows() >= 0)\n                        html.write(String.valueOf(integerFormatter.format(table.getNumRows())));\n                    else\n                        html.write(\"<span title='Row count not available'>&nbsp;</span>\");\n                } else\n                    html.write(\"<span title='Views contain no real rows'>view</span>\");\n                html.writeln(\"</td>\");\n            }\n        }\n        html.write(\"  <td class='comment detail'>\");\n        String comments = table.getComments();\n        if (comments != null) {\n            if (encodeComments)\n                for (int i = 0; i < comments.length(); ++i) html.write(HtmlEncoder.encodeToken(comments.charAt(i)));\n            else\n                html.write(comments);\n        }\n        html.writeln(\"</td>\");\n        html.writeln(\"  </tr>\");\n    }\n\n    protected void writeLocalsFooter(int numTables, int numTableCols, int numViews, int numViewCols, long numRows, LineWriter html) throws IOException {\n        html.writeln(\"  <tr>\");\n        html.writeln(\"    <td class='detail'>&nbsp;</td>\");\n        html.writeln(\"    <td class='detail'>&nbsp;</td>\");\n        html.writeln(\"    <td class='detail'>&nbsp;</td>\");\n        html.writeln(\"    <td class='detail'>&nbsp;</td>\");\n        if (displayNumRows)\n            html.writeln(\"    <td class='detail'>&nbsp;</td>\");\n        html.writeln(\"    <td class='comment detail'>&nbsp;</td>\");\n        html.writeln(\"  </tr>\");\n        String name = numTables == 1 ? \" Table\" : \" Tables\";\n        html.writeln(\"  <tr class='tbl'>\");\n        html.writeln(\"    <td class='detail'><b>\" + integerFormatter.format(numTables) + name + \"</b></td>\");\n        html.writeln(\"    <td class='detail'>&nbsp;</td>\");\n        html.writeln(\"    <td class='detail'>&nbsp;</td>\");\n        html.writeln(\"    <td class='detail' align='right'><b>\" + integerFormatter.format(numTableCols) + \"</b></td>\");\n        if (displayNumRows)\n            html.writeln(\"    <td class='detail' align='right'><b>\" + integerFormatter.format(numRows) + \"</b></td>\");\n        html.writeln(\"    <td class='comment detail'>&nbsp;</td>\");\n        html.writeln(\"  </tr>\");\n        name = numViews == 1 ? \" View\" : \" Views\";\n        html.writeln(\"  <tr class='view'>\");\n        html.writeln(\"    <td class='detail'><b>\" + integerFormatter.format(numViews) + name + \"</b></td>\");\n        html.writeln(\"    <td class='detail'>&nbsp;</td>\");\n        html.writeln(\"    <td class='detail'>&nbsp;</td>\");\n        html.writeln(\"    <td class='detail' align='right'><b>\" + integerFormatter.format(numViewCols) + \"</b></td>\");\n        if (displayNumRows)\n            html.writeln(\"    <td class='detail'>&nbsp;</td>\");\n        html.writeln(\"    <td class='comment detail'>&nbsp;</td>\");\n        html.writeln(\"  </tr>\");\n        html.writeln(\"</tbody>\");\n        html.writeln(\"</table>\");\n    }\n\n    protected void writeRemotesFooter(LineWriter html) throws IOException {\n        html.writeln(\"</tbody>\");\n        html.writeln(\"</table>\");\n    }\n\n    @Override\n    protected boolean isMainIndex() {\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/HtmlMainIndexPageTest.java",
		"test_prompt": "// HtmlMainIndexPageTest.java\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.IOException;\nimport java.text.NumberFormat;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.TreeSet;\nimport net.sourceforge.schemaspy.Config;\nimport net.sourceforge.schemaspy.model.Database;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.util.HtmlEncoder;\nimport net.sourceforge.schemaspy.util.LineWriter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HtmlMainIndexPage}.\n* It contains ten unit test cases for the {@link HtmlMainIndexPage#getInstance()} method.\n*/\nclass HtmlMainIndexPageTest {"
	},
	{
		"original_code": "// ImageWriter.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.File;\nimport java.io.IOException;\nimport net.sourceforge.schemaspy.util.ResourceWriter;\n\npublic class ImageWriter extends ResourceWriter {\n\n    private static ImageWriter instance = new ImageWriter();\n\n    private ImageWriter() {\n    }\n\n    public static ImageWriter getInstance() {\n        return instance;\n    }\n\n    public void writeImages(File outputDir) throws IOException {\n        new File(outputDir, \"images\").mkdir();\n        writeResource(\"/images/tabLeft.gif\", new File(outputDir, \"/images/tabLeft.gif\"));\n        writeResource(\"/images/tabRight.gif\", new File(outputDir, \"/images/tabRight.gif\"));\n        writeResource(\"/images/background.gif\", new File(outputDir, \"/images/background.gif\"));\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/ImageWriterTest.java",
		"test_prompt": "// ImageWriterTest.java\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.File;\nimport java.io.IOException;\nimport net.sourceforge.schemaspy.util.ResourceWriter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ImageWriter}.\n* It contains ten unit test cases for the {@link ImageWriter#getInstance()} method.\n*/\nclass ImageWriterTest {"
	},
	{
		"original_code": "// XmlTableFormatter.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.view;\n\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.model.TableIndex;\nimport net.sourceforge.schemaspy.util.DOMUtil;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\n\n/**\n * Formats {@link Table}s into an XML DOM tree.\n *\n * @author John Currier\n */\npublic class XmlTableFormatter {\n\n    private static final XmlTableFormatter instance = new XmlTableFormatter();\n\n    // valid chars came from http://www.w3.org/TR/REC-xml/#charsets\n    // and attempting to match 0x10000-0x10FFFF with the \\p Unicode escapes\n    // (from http://www.regular-expressions.info/unicode.html)\n    private static final Pattern validXmlChars = Pattern.compile(\"^[ -\\uD7FF\\uE000-\\uFFFD\\\\p{L}\\\\p{M}\\\\p{Z}\\\\p{S}\\\\p{N}\\\\p{P}]*$\");\n\n    /**\n     * Singleton...don't allow instantiation\n     */\n    private XmlTableFormatter() {\n    }\n\n    /**\n     * Singleton accessor\n     *\n     * @return\n     */\n    public static XmlTableFormatter getInstance() {\n        return instance;\n    }\n\n    /**\n     * Append the specified tables to the XML node\n     *\n     * @param schemaNode\n     * @param tables\n     */\n    public void appendTables(Element schemaNode, Collection<Table> tables) {\n        Set<Table> byName = new TreeSet<Table>(new Comparator<Table>() {\n\n            public int compare(Table table1, Table table2) {\n                return table1.getName().compareToIgnoreCase(table2.getName());\n            }\n        });\n        byName.addAll(tables);\n        Document document = schemaNode.getOwnerDocument();\n        Element tablesNode = document.createElement(\"tables\");\n        schemaNode.appendChild(tablesNode);\n        for (Table table : byName) appendTable(tablesNode, table);\n    }\n\n    /**\n     * Append table details to the XML node\n     *\n     * @param tablesNode\n     * @param table\n     */\n    private void appendTable(Element tablesNode, Table table) {\n        Document document = tablesNode.getOwnerDocument();\n        Element tableNode = document.createElement(\"table\");\n        tablesNode.appendChild(tableNode);\n        if (table.getId() != null)\n            DOMUtil.appendAttribute(tableNode, \"id\", String.valueOf(table.getId()));\n        DOMUtil.appendAttribute(tableNode, \"catalog\", table.getCatalog());\n        DOMUtil.appendAttribute(tableNode, \"schema\", table.getSchema());\n        DOMUtil.appendAttribute(tableNode, \"name\", table.getName());\n        if (table.getNumRows() >= 0)\n            DOMUtil.appendAttribute(tableNode, \"numRows\", String.valueOf(table.getNumRows()));\n        DOMUtil.appendAttribute(tableNode, \"type\", table.isView() ? \"VIEW\" : \"TABLE\");\n        DOMUtil.appendAttribute(tableNode, \"remarks\", table.getComments() == null ? \"\" : table.getComments());\n        appendColumns(tableNode, table);\n        appendPrimaryKeys(tableNode, table);\n        appendIndexes(tableNode, table);\n        appendCheckConstraints(tableNode, table);\n        appendView(tableNode, table);\n    }\n\n    /**\n     * Append all columns in the table to the XML node\n     *\n     * @param tableNode\n     * @param table\n     */\n    private void appendColumns(Element tableNode, Table table) {\n        for (TableColumn column : table.getColumns()) {\n            appendColumn(tableNode, column);\n        }\n    }\n\n    /**\n     * Append column details to the XML node\n     *\n     * @param tableNode\n     * @param column\n     * @return\n     */\n    private Node appendColumn(Node tableNode, TableColumn column) {\n        Document document = tableNode.getOwnerDocument();\n        Node columnNode = document.createElement(\"column\");\n        tableNode.appendChild(columnNode);\n        DOMUtil.appendAttribute(columnNode, \"id\", String.valueOf(column.getId()));\n        DOMUtil.appendAttribute(columnNode, \"name\", column.getName());\n        DOMUtil.appendAttribute(columnNode, \"type\", column.getType());\n        DOMUtil.appendAttribute(columnNode, \"size\", String.valueOf(column.getLength()));\n        DOMUtil.appendAttribute(columnNode, \"digits\", String.valueOf(column.getDecimalDigits()));\n        DOMUtil.appendAttribute(columnNode, \"nullable\", String.valueOf(column.isNullable()));\n        DOMUtil.appendAttribute(columnNode, \"autoUpdated\", String.valueOf(column.isAutoUpdated()));\n        if (column.getDefaultValue() != null) {\n            String defaultValue = column.getDefaultValue().toString();\n            if (isBinary(defaultValue)) {\n                // we're run into a binary default value, convert it to its hex equivalent\n                defaultValue = asBinary(defaultValue);\n                // and indicate that it's been converted\n                DOMUtil.appendAttribute(columnNode, \"defaultValueIsBinary\", \"true\");\n            }\n            DOMUtil.appendAttribute(columnNode, \"defaultValue\", defaultValue);\n        }\n        DOMUtil.appendAttribute(columnNode, \"remarks\", column.getComments() == null ? \"\" : column.getComments());\n        for (TableColumn childColumn : column.getChildren()) {\n            Node childNode = document.createElement(\"child\");\n            Table table = childColumn.getTable();\n            columnNode.appendChild(childNode);\n            ForeignKeyConstraint constraint = column.getChildConstraint(childColumn);\n            DOMUtil.appendAttribute(childNode, \"foreignKey\", constraint.getName());\n            DOMUtil.appendAttribute(childNode, \"catalog\", table.getCatalog());\n            DOMUtil.appendAttribute(childNode, \"schema\", table.getSchema());\n            DOMUtil.appendAttribute(childNode, \"table\", table.getName());\n            DOMUtil.appendAttribute(childNode, \"column\", childColumn.getName());\n            DOMUtil.appendAttribute(childNode, \"implied\", String.valueOf(constraint.isImplied()));\n            DOMUtil.appendAttribute(childNode, \"onDeleteCascade\", String.valueOf(constraint.isCascadeOnDelete()));\n        }\n        for (TableColumn parentColumn : column.getParents()) {\n            Node parentNode = document.createElement(\"parent\");\n            Table table = parentColumn.getTable();\n            columnNode.appendChild(parentNode);\n            ForeignKeyConstraint constraint = column.getParentConstraint(parentColumn);\n            DOMUtil.appendAttribute(parentNode, \"foreignKey\", constraint.getName());\n            DOMUtil.appendAttribute(parentNode, \"catalog\", table.getCatalog());\n            DOMUtil.appendAttribute(parentNode, \"schema\", table.getSchema());\n            DOMUtil.appendAttribute(parentNode, \"table\", table.getName());\n            DOMUtil.appendAttribute(parentNode, \"column\", parentColumn.getName());\n            DOMUtil.appendAttribute(parentNode, \"implied\", String.valueOf(constraint.isImplied()));\n            DOMUtil.appendAttribute(parentNode, \"onDeleteCascade\", String.valueOf(constraint.isCascadeOnDelete()));\n        }\n        return columnNode;\n    }\n\n    /**\n     * Append primary key details to the XML node\n     *\n     * @param tableNode\n     * @param table\n     */\n    private void appendPrimaryKeys(Element tableNode, Table table) {\n        Document document = tableNode.getOwnerDocument();\n        int index = 1;\n        for (TableColumn primaryKeyColumn : table.getPrimaryColumns()) {\n            Node primaryKeyNode = document.createElement(\"primaryKey\");\n            tableNode.appendChild(primaryKeyNode);\n            DOMUtil.appendAttribute(primaryKeyNode, \"column\", primaryKeyColumn.getName());\n            DOMUtil.appendAttribute(primaryKeyNode, \"sequenceNumberInPK\", String.valueOf(index++));\n        }\n    }\n\n    /**\n     * Append check constraint details to the XML node\n     *\n     * @param tableNode\n     * @param table\n     */\n    private void appendCheckConstraints(Element tableNode, Table table) {\n        Document document = tableNode.getOwnerDocument();\n        Map<String, String> constraints = table.getCheckConstraints();\n        if (constraints != null && !constraints.isEmpty()) {\n            for (String name : constraints.keySet()) {\n                Node constraintNode = document.createElement(\"checkConstraint\");\n                tableNode.appendChild(constraintNode);\n                DOMUtil.appendAttribute(constraintNode, \"name\", name);\n                DOMUtil.appendAttribute(constraintNode, \"constraint\", constraints.get(name).toString());\n            }\n        }\n    }\n\n    /**\n     * Append index details to the XML node\n     *\n     * @param tableNode\n     * @param table\n     */\n    private void appendIndexes(Node tableNode, Table table) {\n        boolean showId = table.getId() != null;\n        Set<TableIndex> indexes = table.getIndexes();\n        if (indexes != null && !indexes.isEmpty()) {\n            // sort primary keys first\n            indexes = new TreeSet<TableIndex>(indexes);\n            Document document = tableNode.getOwnerDocument();\n            for (TableIndex index : indexes) {\n                Node indexNode = document.createElement(\"index\");\n                if (showId)\n                    DOMUtil.appendAttribute(indexNode, \"id\", String.valueOf(index.getId()));\n                DOMUtil.appendAttribute(indexNode, \"name\", index.getName());\n                DOMUtil.appendAttribute(indexNode, \"unique\", String.valueOf(index.isUnique()));\n                for (TableColumn column : index.getColumns()) {\n                    Node columnNode = document.createElement(\"column\");\n                    DOMUtil.appendAttribute(columnNode, \"name\", column.getName());\n                    DOMUtil.appendAttribute(columnNode, \"ascending\", String.valueOf(index.isAscending(column)));\n                    indexNode.appendChild(columnNode);\n                }\n                tableNode.appendChild(indexNode);\n            }\n        }\n    }\n\n    /**\n     * Append view SQL to the XML node\n     *\n     * @param tableNode\n     * @param table\n     */\n    private void appendView(Element tableNode, Table table) {\n        String sql;\n        if (table.isView() && (sql = table.getViewSql()) != null) {\n            DOMUtil.appendAttribute(tableNode, \"viewSql\", sql);\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if the string contains binary data\n     * (chars that are invalid for XML) per http://www.w3.org/TR/REC-xml/#charsets\n     *\n     * @param str\n     * @return\n     */\n    private static boolean isBinary(String str) {\n        return !validXmlChars.matcher(str).matches();\n    }\n\n    /**\n     * Turns a string into its hex equivalent.\n     * Intended to be used when {@link #isBinary(String)} returns <code>true</code>.\n     *\n     * @param str\n     * @return\n     */\n    private String asBinary(String str) {\n        byte[] bytes = str.getBytes();\n        StringBuilder buf = new StringBuilder(bytes.length * 2);\n        for (int i = 0; i < bytes.length; ++i) {\n            buf.append(String.format(\"%02X\", bytes[i]));\n        }\n        return buf.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/XmlTableFormatterTest.java",
		"test_prompt": "// XmlTableFormatterTest.java\npackage net.sourceforge.schemaspy.view;\n\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.model.TableIndex;\nimport net.sourceforge.schemaspy.util.DOMUtil;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XmlTableFormatter}.\n* It contains ten unit test cases for the {@link XmlTableFormatter#getInstance()} method.\n*/\nclass XmlTableFormatterTest {"
	},
	{
		"original_code": "// DotConnectorFinder.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.IOException;\nimport java.util.HashSet;\nimport java.util.Set;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\n\n/**\n * Format table data into .dot format to feed to Graphvis' dot program.\n *\n * @author John Currier\n */\npublic class DotConnectorFinder {\n\n    private static DotConnectorFinder instance = new DotConnectorFinder();\n\n    /**\n     * Singleton - prevent creation\n     */\n    private DotConnectorFinder() {\n    }\n\n    public static DotConnectorFinder getInstance() {\n        return instance;\n    }\n\n    /**\n     * @param table Table\n     * @throws IOException\n     * @return Set of <code>dot</code> relationships (as {@link DotConnector}s)\n     */\n    public Set<DotConnector> getRelatedConnectors(Table table, boolean includeImplied) {\n        Set<DotConnector> relationships = new HashSet<DotConnector>();\n        for (TableColumn column : table.getColumns()) {\n            relationships.addAll(getRelatedConnectors(column, null, false, includeImplied));\n        }\n        return relationships;\n    }\n\n    /**\n     * Get all the relationships that exist between these two tables.\n     *\n     * @param table1 Table\n     * @param table2 Table\n     * @throws IOException\n     * @return Set of <code>dot</code> relationships (as {@link DotConnector}s)\n     */\n    public Set<DotConnector> getRelatedConnectors(Table table1, Table table2, boolean includeExcluded, boolean includeImplied) {\n        Set<DotConnector> relationships = new HashSet<DotConnector>();\n        for (TableColumn column : table1.getColumns()) {\n            relationships.addAll(getRelatedConnectors(column, table2, includeExcluded, includeImplied));\n        }\n        for (TableColumn column : table2.getColumns()) {\n            relationships.addAll(getRelatedConnectors(column, table1, includeExcluded, includeImplied));\n        }\n        return relationships;\n    }\n\n    /**\n     * @param column TableColumn\n     * @param targetTable Table\n     * @throws IOException\n     * @return Set of <code>dot</code> relationships (as {@link DotConnector}s)\n     */\n    private Set<DotConnector> getRelatedConnectors(TableColumn column, Table targetTable, boolean includeExcluded, boolean includeImplied) {\n        Set<DotConnector> relatedConnectors = new HashSet<DotConnector>();\n        if (!includeExcluded && column.isExcluded())\n            return relatedConnectors;\n        for (TableColumn parentColumn : column.getParents()) {\n            Table parentTable = parentColumn.getTable();\n            if (targetTable != null && parentTable != targetTable)\n                continue;\n            if (targetTable == null && !includeExcluded && parentColumn.isExcluded())\n                continue;\n            boolean implied = column.getParentConstraint(parentColumn).isImplied();\n            if (!implied || includeImplied) {\n                relatedConnectors.add(new DotConnector(parentColumn, column, implied));\n            }\n        }\n        for (TableColumn childColumn : column.getChildren()) {\n            Table childTable = childColumn.getTable();\n            if (targetTable != null && childTable != targetTable)\n                continue;\n            if (targetTable == null && !includeExcluded && childColumn.isExcluded())\n                continue;\n            boolean implied = column.getChildConstraint(childColumn).isImplied();\n            if (!implied || includeImplied) {\n                relatedConnectors.add(new DotConnector(column, childColumn, implied));\n            }\n        }\n        return relatedConnectors;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/view/DotConnectorFinderTest.java",
		"test_prompt": "// DotConnectorFinderTest.java\npackage net.sourceforge.schemaspy.view;\n\nimport java.io.IOException;\nimport java.util.HashSet;\nimport java.util.Set;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DotConnectorFinder}.\n* It contains ten unit test cases for the {@link DotConnectorFinder#getInstance()} method.\n*/\nclass DotConnectorFinderTest {"
	},
	{
		"original_code": "// Config.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\n\n/**\n * Configuration of a SchemaSpy run\n *\n * @author John Currier\n */\npublic class Config {\n\n    private static Config instance;\n\n    private final List<String> options;\n\n    private Map<String, String> dbSpecificOptions;\n\n    private Map<String, String> originalDbSpecificOptions;\n\n    private boolean helpRequired;\n\n    private boolean dbHelpRequired;\n\n    private File outputDir;\n\n    private File graphvizDir;\n\n    private String dbType;\n\n    private String catalog;\n\n    private String schema;\n\n    private List<String> schemas;\n\n    private String user;\n\n    private Boolean singleSignOn;\n\n    private Boolean noSchema;\n\n    private String password;\n\n    private Boolean promptForPassword;\n\n    private String db;\n\n    private String host;\n\n    private Integer port;\n\n    private String server;\n\n    private String meta;\n\n    private Pattern tableInclusions;\n\n    private Pattern tableExclusions;\n\n    private Pattern columnExclusions;\n\n    private Pattern indirectColumnExclusions;\n\n    private String userConnectionPropertiesFile;\n\n    private Properties userConnectionProperties;\n\n    private Integer maxDbThreads;\n\n    private Integer maxDetailedTables;\n\n    private String driverPath;\n\n    private String css;\n\n    private String charset;\n\n    private String font;\n\n    private Integer fontSize;\n\n    private String description;\n\n    private Properties dbProperties;\n\n    private String dbPropertiesLoadedFrom;\n\n    private Level logLevel;\n\n    private SqlFormatter sqlFormatter;\n\n    private String sqlFormatterClass;\n\n    private Boolean generateHtml;\n\n    private Boolean includeImpliedConstraints;\n\n    private Boolean logoEnabled;\n\n    private Boolean rankDirBugEnabled;\n\n    private Boolean encodeCommentsEnabled;\n\n    private Boolean numRowsEnabled;\n\n    private Boolean viewsEnabled;\n\n    private Boolean meterEnabled;\n\n    private Boolean railsEnabled;\n\n    private Boolean evaluteAll;\n\n    private Boolean highQuality;\n\n    private Boolean lowQuality;\n\n    // used in conjunction with evaluateAll\n    private String schemaSpec;\n\n    private boolean hasOrphans = false;\n\n    private boolean hasRoutines = false;\n\n    private boolean populating = false;\n\n    private List<String> columnDetails;\n\n    public static final String DOT_CHARSET = \"UTF-8\";\n\n    private static final String ESCAPED_EQUALS = \"\\\\=\";\n\n    // match everything\n    private static final String DEFAULT_TABLE_INCLUSION = \".*\";\n\n    // match nothing\n    private static final String DEFAULT_TABLE_EXCLUSION = \"\";\n\n    // match nothing\n    private static final String DEFAULT_COLUMN_EXCLUSION = \"[^.]\";\n\n    /**\n     * Default constructor. Intended for when you want to inject properties\n     * independently (i.e. not from a command line interface).\n     */\n    public Config() {\n        if (instance == null)\n            setInstance(this);\n        options = new ArrayList<String>();\n    }\n\n    /**\n     * Construct a configuration from an array of options (e.g. from a command\n     * line interface).\n     *\n     * @param options\n     */\n    public Config(String[] argv) {\n        setInstance(this);\n        options = fixupArgs(Arrays.asList(argv));\n        helpRequired = options.remove(\"-?\") || options.remove(\"/?\") || options.remove(\"?\") || options.remove(\"-h\") || options.remove(\"-help\") || options.remove(\"--help\");\n        dbHelpRequired = options.remove(\"-dbHelp\") || options.remove(\"-dbhelp\");\n    }\n\n    public static Config getInstance() {\n        if (instance == null)\n            instance = new Config();\n        return instance;\n    }\n\n    /**\n     * Sets the global instance.\n     *\n     * Useful for things like selecting a specific configuration in a UI.\n     *\n     * @param config\n     */\n    public static void setInstance(Config config) {\n        instance = config;\n    }\n\n    public void setHtmlGenerationEnabled(boolean generateHtml) {\n        this.generateHtml = generateHtml;\n    }\n\n    public boolean isHtmlGenerationEnabled() {\n        if (generateHtml == null)\n            generateHtml = !options.remove(\"-nohtml\");\n        return generateHtml;\n    }\n\n    public void setImpliedConstraintsEnabled(boolean includeImpliedConstraints) {\n        this.includeImpliedConstraints = includeImpliedConstraints;\n    }\n\n    public boolean isImpliedConstraintsEnabled() {\n        if (includeImpliedConstraints == null)\n            includeImpliedConstraints = !options.remove(\"-noimplied\");\n        return includeImpliedConstraints;\n    }\n\n    public void setOutputDir(String outputDirName) {\n        if (outputDirName.endsWith(\"\\\"\"))\n            outputDirName = outputDirName.substring(0, outputDirName.length() - 1);\n        setOutputDir(new File(outputDirName));\n    }\n\n    public void setOutputDir(File outputDir) {\n        this.outputDir = outputDir;\n    }\n\n    public File getOutputDir() {\n        if (outputDir == null) {\n            setOutputDir(pullRequiredParam(\"-o\"));\n        }\n        return outputDir;\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(String graphvizDir) {\n        if (graphvizDir.endsWith(\"\\\"\"))\n            graphvizDir = graphvizDir.substring(0, graphvizDir.length() - 1);\n        setGraphvizDir(new File(graphvizDir));\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(File graphvizDir) {\n        this.graphvizDir = graphvizDir;\n    }\n\n    /**\n     * Return the path to Graphviz (used to find the dot executable to run to\n     * generate ER diagrams).<p/>\n     *\n     * Returns {@link #getDefaultGraphvizPath()} if a specific Graphviz path\n     * was not specified.\n     *\n     * @return\n     */\n    public File getGraphvizDir() {\n        if (graphvizDir == null) {\n            String gv = pullParam(\"-gv\");\n            if (gv != null) {\n                setGraphvizDir(gv);\n            } else {\n                // expect to find Graphviz's bin directory on the PATH\n            }\n        }\n        return graphvizDir;\n    }\n\n    /**\n     * Meta files are XML-based files that provide additional metadata\n     * about the schema being evaluated.<p>\n     * <code>meta</code> is either the name of an individual XML file or\n     * the directory that contains meta files.<p>\n     * If a directory is specified then it is expected to contain files\n     * matching the pattern <code>[schema].meta.xml</code>.\n     * For databases that don't have schema substitute database for schema.\n     * @param meta\n     */\n    public void setMeta(String meta) {\n        this.meta = meta;\n    }\n\n    public String getMeta() {\n        if (meta == null)\n            meta = pullParam(\"-meta\");\n        return meta;\n    }\n\n    public void setDbType(String dbType) {\n        this.dbType = dbType;\n    }\n\n    public String getDbType() {\n        if (dbType == null) {\n            dbType = pullParam(\"-t\");\n            if (dbType == null)\n                dbType = \"ora\";\n        }\n        return dbType;\n    }\n\n    public void setDb(String db) {\n        this.db = db;\n    }\n\n    public String getDb() {\n        if (db == null)\n            db = pullParam(\"-db\");\n        return db;\n    }\n\n    public void setCatalog(String catalog) {\n        this.catalog = catalog;\n    }\n\n    public String getCatalog() {\n        if (catalog == null)\n            catalog = pullParam(\"-cat\");\n        return catalog;\n    }\n\n    public void setSchema(String schema) {\n        this.schema = schema;\n    }\n\n    public String getSchema() {\n        if (schema == null)\n            schema = pullParam(\"-s\");\n        return schema;\n    }\n\n    /**\n     * Some databases types (e.g. older versions of Informix) don't really\n     * have the concept of a schema but still return true from\n     * {@link DatabaseMetaData#supportsSchemasInTableDefinitions()}.\n     * This option lets you ignore that and treat all the tables\n     * as if they were in one flat namespace.\n     */\n    public boolean isSchemaDisabled() {\n        if (noSchema == null)\n            noSchema = options.remove(\"-noschema\");\n        return noSchema;\n    }\n\n    public void setHost(String host) {\n        this.host = host;\n    }\n\n    public String getHost() {\n        if (host == null)\n            host = pullParam(\"-host\");\n        return host;\n    }\n\n    public void setPort(Integer port) {\n        this.port = port;\n    }\n\n    public Integer getPort() {\n        if (port == null)\n            try {\n                port = Integer.valueOf(pullParam(\"-port\"));\n            } catch (Exception notSpecified) {\n            }\n        return port;\n    }\n\n    public void setServer(String server) {\n        this.server = server;\n    }\n\n    public String getServer() {\n        if (server == null) {\n            server = pullParam(\"-server\");\n        }\n        return server;\n    }\n\n    public void setUser(String user) {\n        this.user = user;\n    }\n\n    /**\n     * User used to connect to the database.\n     * Required unless single sign-on is enabled\n     * (see {@link #setSingleSignOn(boolean)}).\n     * @return\n     */\n    public String getUser() {\n        if (user == null) {\n            if (!isSingleSignOn())\n                user = pullRequiredParam(\"-u\");\n            else\n                user = pullParam(\"-u\");\n        }\n        return user;\n    }\n\n    /**\n     * By default a \"user\" (as specified with -u) is required.\n     * This option allows disabling of that requirement for\n     * single sign-on environments.\n     *\n     * @param enabled defaults to <code>false</code>\n     */\n    public void setSingleSignOn(boolean enabled) {\n        singleSignOn = enabled;\n    }\n\n    /**\n     * @see #setSingleSignOn(boolean)\n     */\n    public boolean isSingleSignOn() {\n        if (singleSignOn == null)\n            singleSignOn = options.remove(\"-sso\");\n        return singleSignOn;\n    }\n\n    /**\n     * Set the password used to connect to the database.\n     * @param password\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * @see #setPassword(String)\n     * @return\n     */\n    public String getPassword() {\n        if (password == null)\n            password = pullParam(\"-p\");\n        if (password == null && isPromptForPasswordEnabled())\n            password = new String(PasswordReader.getInstance().readPassword(\"Password: \"));\n        if (password == null) {\n            // if -pfp is enabled when analyzing multiple schemas then\n            // we don't want to send the password on the command line,\n            // so see if it was passed in the environment (not ideal, but safer)\n            password = System.getenv(\"schemaspy.pw\");\n        }\n        return password;\n    }\n\n    /**\n     * Set to <code>true</code> to prompt for the password\n     * @param promptForPassword\n     */\n    public void setPromptForPasswordEnabled(boolean promptForPassword) {\n        this.promptForPassword = promptForPassword;\n    }\n\n    /**\n     * @see #setPromptForPasswordEnabled(boolean)\n     * @return\n     */\n    public boolean isPromptForPasswordEnabled() {\n        if (promptForPassword == null) {\n            promptForPassword = options.remove(\"-pfp\");\n        }\n        return promptForPassword;\n    }\n\n    public void setMaxDetailedTabled(int maxDetailedTables) {\n        this.maxDetailedTables = new Integer(maxDetailedTables);\n    }\n\n    public int getMaxDetailedTables() {\n        if (maxDetailedTables == null) {\n            // default\n            int max = 300;\n            try {\n                max = Integer.parseInt(pullParam(\"-maxdet\"));\n            } catch (Exception notSpecified) {\n            }\n            maxDetailedTables = new Integer(max);\n        }\n        return maxDetailedTables.intValue();\n    }\n\n    public String getConnectionPropertiesFile() {\n        return userConnectionPropertiesFile;\n    }\n\n    /**\n     * Properties from this file (in key=value pair format) are passed to the\n     * database connection.<br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.\n     * @param propertiesFilename\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public void setConnectionPropertiesFile(String propertiesFilename) throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null)\n            userConnectionProperties = new Properties();\n        userConnectionProperties.load(new FileInputStream(propertiesFilename));\n        userConnectionPropertiesFile = propertiesFilename;\n    }\n\n    /**\n     * Returns a {@link Properties} populated either from the properties file specified\n     * by {@link #setConnectionPropertiesFile(String)}, the properties specified by\n     * {@link #setConnectionProperties(String)} or not populated.\n     * @return\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public Properties getConnectionProperties() throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null) {\n            String props = pullParam(\"-connprops\");\n            if (props != null) {\n                if (props.indexOf(ESCAPED_EQUALS) != -1) {\n                    setConnectionProperties(props);\n                } else {\n                    setConnectionPropertiesFile(props);\n                }\n            } else {\n                userConnectionProperties = new Properties();\n            }\n        }\n        return userConnectionProperties;\n    }\n\n    /**\n     * Specifies connection properties to use in the format:\n     * <code>key1\\=value1;key2\\=value2</code><br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.<p>\n     * This is an alternative form of passing connection properties than by file\n     * (see {@link #setConnectionPropertiesFile(String)})\n     *\n     * @param properties\n     */\n    public void setConnectionProperties(String properties) {\n        userConnectionProperties = new Properties();\n        StringTokenizer tokenizer = new StringTokenizer(properties, \";\");\n        while (tokenizer.hasMoreElements()) {\n            String pair = tokenizer.nextToken();\n            int index = pair.indexOf(ESCAPED_EQUALS);\n            if (index != -1) {\n                String key = pair.substring(0, index);\n                String value = pair.substring(index + ESCAPED_EQUALS.length());\n                userConnectionProperties.put(key, value);\n            }\n        }\n    }\n\n    public void setDriverPath(String driverPath) {\n        this.driverPath = driverPath;\n    }\n\n    public String getDriverPath() {\n        if (driverPath == null)\n            driverPath = pullParam(\"-dp\");\n        // was previously -cp:\n        if (driverPath == null)\n            driverPath = pullParam(\"-cp\");\n        return driverPath;\n    }\n\n    /**\n     * The filename of the cascading style sheet to use.\n     * Note that this file is parsed and used to determine characteristics\n     * of the generated diagrams, so it must contain specific settings that\n     * are documented within schemaSpy.css.<p>\n     *\n     * Defaults to <code>\"schemaSpy.css\"</code>.\n     *\n     * @param css\n     */\n    public void setCss(String css) {\n        this.css = css;\n    }\n\n    public String getCss() {\n        if (css == null) {\n            css = pullParam(\"-css\");\n            if (css == null)\n                css = \"schemaSpy.css\";\n        }\n        return css;\n    }\n\n    /**\n     * The font to use within diagrams.  Modify the .css to specify HTML fonts.\n     *\n     * @param font\n     */\n    public void setFont(String font) {\n        this.font = font;\n    }\n\n    /**\n     * @see #setFont(String)\n     */\n    public String getFont() {\n        if (font == null) {\n            font = pullParam(\"-font\");\n            if (font == null)\n                font = \"Helvetica\";\n        }\n        return font;\n    }\n\n    /**\n     * The font size to use within diagrams.  This is the size of the font used for\n     * 'large' (e.g. not 'compact') diagrams.<p>\n     *\n     * Modify the .css to specify HTML font sizes.<p>\n     *\n     * Defaults to 11.\n     *\n     * @param fontSize\n     */\n    public void setFontSize(int fontSize) {\n        this.fontSize = new Integer(fontSize);\n    }\n\n    /**\n     * @see #setFontSize(int)\n     * @return\n     */\n    public int getFontSize() {\n        if (fontSize == null) {\n            // default\n            int size = 11;\n            try {\n                size = Integer.parseInt(pullParam(\"-fontsize\"));\n            } catch (Exception notSpecified) {\n            }\n            fontSize = new Integer(size);\n        }\n        return fontSize.intValue();\n    }\n\n    /**\n     * The character set to use within HTML pages (defaults to <code>\"ISO-8859-1\"</code>).\n     *\n     * @param charset\n     */\n    public void setCharset(String charset) {\n        this.charset = charset;\n    }\n\n    /**\n     * @see #setCharset(String)\n     */\n    public String getCharset() {\n        if (charset == null) {\n            charset = pullParam(\"-charset\");\n            if (charset == null)\n                charset = \"ISO-8859-1\";\n        }\n        return charset;\n    }\n\n    /**\n     * Description of schema that gets display on main pages.\n     *\n     * @param description\n     */\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    /**\n     * @see #setDescription(String)\n     */\n    public String getDescription() {\n        if (description == null)\n            description = pullParam(\"-desc\");\n        return description;\n    }\n\n    /**\n     * Maximum number of threads to use when querying database metadata information.\n     *\n     * @param maxDbThreads\n     */\n    public void setMaxDbThreads(int maxDbThreads) {\n        this.maxDbThreads = new Integer(maxDbThreads);\n    }\n\n    /**\n     * @see #setMaxDbThreads(int)\n     * @throws InvalidConfigurationException if unable to load properties\n     */\n    public int getMaxDbThreads() throws InvalidConfigurationException {\n        if (maxDbThreads == null) {\n            Properties properties;\n            try {\n                properties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(\"Failed to load properties for \" + getDbType() + \": \" + exc).setParamName(\"-type\");\n            }\n            // not scientifically derived\n            final int defaultMax = 15;\n            int max = defaultMax;\n            String threads = properties.getProperty(\"dbThreads\");\n            if (threads == null)\n                threads = properties.getProperty(\"dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            threads = pullParam(\"-dbThreads\");\n            if (threads == null)\n                threads = pullParam(\"-dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            if (max < 0)\n                max = defaultMax;\n            else if (max == 0)\n                max = 1;\n            maxDbThreads = new Integer(max);\n        }\n        return maxDbThreads.intValue();\n    }\n\n    public boolean isLogoEnabled() {\n        if (logoEnabled == null)\n            logoEnabled = !options.remove(\"-nologo\");\n        return logoEnabled;\n    }\n\n    /**\n     * Don't use this unless absolutely necessary as it screws up the layout\n     *\n     * @param enabled\n     */\n    public void setRankDirBugEnabled(boolean enabled) {\n        rankDirBugEnabled = enabled;\n    }\n\n    /**\n     * @see #setRankDirBugEnabled(boolean)\n     */\n    public boolean isRankDirBugEnabled() {\n        if (rankDirBugEnabled == null)\n            rankDirBugEnabled = options.remove(\"-rankdirbug\");\n        return rankDirBugEnabled;\n    }\n\n    /**\n     * Look for Ruby on Rails-based naming conventions in\n     * relationships between logical foreign keys and primary keys.<p>\n     *\n     * Basically all tables have a primary key named <code>ID</code>.\n     * All tables are named plural names.\n     * The columns that logically reference that <code>ID</code> are the singular\n     * form of the table name suffixed with <code>_ID</code>.<p>\n     *\n     * @param enabled\n     */\n    public void setRailsEnabled(boolean enabled) {\n        railsEnabled = enabled;\n    }\n\n    /**\n     * @see #setRailsEnabled(boolean)\n     *\n     * @return\n     */\n    public boolean isRailsEnabled() {\n        if (railsEnabled == null)\n            railsEnabled = options.remove(\"-rails\");\n        return railsEnabled;\n    }\n\n    /**\n     * Allow Html In Comments - encode them unless otherwise specified\n     */\n    public void setEncodeCommentsEnabled(boolean enabled) {\n        encodeCommentsEnabled = enabled;\n    }\n\n    /**\n     * @see #setEncodeCommentsEnabled(boolean)\n     */\n    public boolean isEncodeCommentsEnabled() {\n        if (encodeCommentsEnabled == null)\n            encodeCommentsEnabled = !options.remove(\"-ahic\");\n        return encodeCommentsEnabled;\n    }\n\n    /**\n     * If enabled we'll attempt to query/render the number of rows that\n     * each table contains.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setNumRowsEnabled(boolean enabled) {\n        numRowsEnabled = enabled;\n    }\n\n    /**\n     * @see #setNumRowsEnabled(boolean)\n     * @return\n     */\n    public boolean isNumRowsEnabled() {\n        if (numRowsEnabled == null)\n            numRowsEnabled = !options.remove(\"-norows\");\n        return numRowsEnabled;\n    }\n\n    /**\n     * If enabled we'll include views in the analysis.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setViewsEnabled(boolean enabled) {\n        viewsEnabled = enabled;\n    }\n\n    /**\n     * @see #setViewsEnabled(boolean)\n     * @return\n     */\n    public boolean isViewsEnabled() {\n        if (viewsEnabled == null)\n            viewsEnabled = !options.remove(\"-noviews\");\n        return viewsEnabled;\n    }\n\n    /**\n     * Returns <code>true</code> if metering should be embedded in\n     * the generated pages.<p/>\n     * Defaults to <code>false</code> (disabled).\n     * @return\n     */\n    public boolean isMeterEnabled() {\n        if (meterEnabled == null)\n            meterEnabled = options.remove(\"-meter\");\n        return meterEnabled;\n    }\n\n    /**\n     * Set the columns to exclude from all relationship diagrams.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setColumnExclusions(String columnExclusions) {\n        this.columnExclusions = Pattern.compile(columnExclusions);\n    }\n\n    /**\n     * See {@link #setColumnExclusions(String)}\n     * @return\n     */\n    public Pattern getColumnExclusions() {\n        if (columnExclusions == null) {\n            String strExclusions = pullParam(\"-X\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.columnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            columnExclusions = Pattern.compile(strExclusions);\n        }\n        return columnExclusions;\n    }\n\n    /**\n     * Set the columns to exclude from relationship diagrams where the specified\n     * columns aren't directly referenced by the focal table.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setIndirectColumnExclusions(String fullColumnExclusions) {\n        indirectColumnExclusions = Pattern.compile(fullColumnExclusions);\n    }\n\n    /**\n     * @see #setIndirectColumnExclusions(String)\n     *\n     * @return\n     */\n    public Pattern getIndirectColumnExclusions() {\n        if (indirectColumnExclusions == null) {\n            String strExclusions = pullParam(\"-x\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.indirectColumnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            indirectColumnExclusions = Pattern.compile(strExclusions);\n        }\n        return indirectColumnExclusions;\n    }\n\n    /**\n     * Set the tables to include as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableInclusions(String tableInclusions) {\n        this.tableInclusions = Pattern.compile(tableInclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to include in the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableInclusions() {\n        if (tableInclusions == null) {\n            String strInclusions = pullParam(\"-i\");\n            if (strInclusions == null)\n                strInclusions = System.getenv(\"schemaspy.tableInclusions\");\n            if (strInclusions == null)\n                strInclusions = DEFAULT_TABLE_INCLUSION;\n            try {\n                tableInclusions = Pattern.compile(strInclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-i\");\n            }\n        }\n        return tableInclusions;\n    }\n\n    /**\n     * Set the tables to exclude as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableExclusions(String tableExclusions) {\n        this.tableExclusions = Pattern.compile(tableExclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to exclude from the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableExclusions() {\n        if (tableExclusions == null) {\n            String strExclusions = pullParam(\"-I\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.tableExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_TABLE_EXCLUSION;\n            try {\n                tableExclusions = Pattern.compile(strExclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-I\");\n            }\n        }\n        return tableExclusions;\n    }\n\n    /**\n     * @return\n     */\n    public List<String> getSchemas() {\n        if (schemas == null) {\n            String tmp = pullParam(\"-schemas\");\n            if (tmp == null)\n                tmp = pullParam(\"-schemata\");\n            if (tmp != null) {\n                schemas = new ArrayList<String>();\n                for (String name : tmp.split(\"[\\\\s,'\\\"]\")) {\n                    if (name.length() > 0)\n                        schemas.add(name);\n                }\n                if (schemas.isEmpty())\n                    schemas = null;\n            }\n        }\n        return schemas;\n    }\n\n    /**\n     * Set the name of the {@link SqlFormatter SQL formatter} class to use to\n     * format SQL into HTML.<p/>\n     * The implementation of the class must be made available to the class\n     * loader, typically by specifying the path to its jar with <em>-dp</em>\n     * ({@link #setDriverPath(String)}).\n     */\n    public void setSqlFormatter(String formatterClassName) {\n        sqlFormatterClass = formatterClassName;\n        sqlFormatter = null;\n    }\n\n    /**\n     * Set the {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.\n     */\n    public void setSqlFormatter(SqlFormatter sqlFormatter) {\n        this.sqlFormatter = sqlFormatter;\n        if (sqlFormatter != null)\n            sqlFormatterClass = sqlFormatter.getClass().getName();\n    }\n\n    /**\n     * Returns an implementation of {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.  The default implementation is {@link DefaultSqlFormatter}.\n     *\n     * @return\n     * @throws InvalidConfigurationException if unable to instantiate an instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SqlFormatter getSqlFormatter() throws InvalidConfigurationException {\n        if (sqlFormatter == null) {\n            if (sqlFormatterClass == null) {\n                sqlFormatterClass = pullParam(\"-sqlFormatter\");\n                if (sqlFormatterClass == null)\n                    sqlFormatterClass = DefaultSqlFormatter.class.getName();\n            }\n            try {\n                Class<SqlFormatter> clazz = (Class<SqlFormatter>) Class.forName(sqlFormatterClass);\n                sqlFormatter = clazz.newInstance();\n            } catch (Exception exc) {\n                throw new InvalidConfigurationException(\"Failed to initialize instance of SQL formatter: \", exc).setParamName(\"-sqlFormatter\");\n            }\n        }\n        return sqlFormatter;\n    }\n\n    /**\n     * Set the details to show on the columns page, where \"details\" are\n     * comma and/or space separated.\n     *\n     * Valid values:\n     * <ul>\n     * <li>id</li>\n     * <li>table</li>\n     * <li>column</li>\n     * <li>type</li>\n     * <li>size</li>\n     * <li>nulls</li>\n     * <li>auto</li>\n     * <li>default</li>\n     * <li>children</li>\n     * <li>parents</li>\n     * </ul>\n     *\n     * The default details are <code>\"table column type size nulls auto default\"</code>.\n     * Note that \"column\" is the initially displayed detail and must be included.\n     *\n     * @param columnDetails\n     */\n    public void setColumnDetails(String columnDetails) {\n        this.columnDetails = new ArrayList<String>();\n        if (columnDetails == null || columnDetails.length() == 0) {\n            // not specified, so use defaults\n            columnDetails = \"id table column type size nulls auto default\";\n        }\n        for (String detail : columnDetails.split(\"[\\\\s,'\\\"]\")) {\n            if (detail.length() > 0) {\n                this.columnDetails.add(detail.toLowerCase());\n            }\n        }\n        if (!this.columnDetails.contains(\"column\"))\n            throw new InvalidConfigurationException(\"'column' is a required column detail\");\n    }\n\n    public void setColumnDetails(List<String> columnDetails) {\n        String details = columnDetails == null ? \"[]\" : columnDetails.toString();\n        setColumnDetails(details.substring(1, details.length() - 1));\n    }\n\n    public List<String> getColumnDetails() {\n        if (columnDetails == null) {\n            setColumnDetails(pullParam(\"-columndetails\"));\n        }\n        return columnDetails;\n    }\n\n    public void setEvaluateAllEnabled(boolean enabled) {\n        evaluteAll = enabled;\n    }\n\n    public boolean isEvaluateAllEnabled() {\n        if (evaluteAll == null)\n            evaluteAll = options.remove(\"-all\");\n        return evaluteAll;\n    }\n\n    /**\n     * Returns true if we're evaluating a bunch of schemas in one go and\n     * at this point we're evaluating a specific schema.\n     *\n     * @return boolean\n     */\n    public boolean isOneOfMultipleSchemas() {\n        // set by MultipleSchemaAnalyzer\n        return Boolean.getBoolean(\"oneofmultipleschemas\");\n    }\n\n    /**\n     * When -all (evaluateAll) is specified then this is the regular\n     * expression that determines which schemas to evaluate.\n     *\n     * @param schemaSpec\n     */\n    public void setSchemaSpec(String schemaSpec) {\n        this.schemaSpec = schemaSpec;\n    }\n\n    public String getSchemaSpec() {\n        if (schemaSpec == null)\n            schemaSpec = pullParam(\"-schemaSpec\");\n        return schemaSpec;\n    }\n\n    /**\n     * Set the renderer to use for the -Tpng[:renderer[:formatter]] dot option as specified\n     * at <a href='http://www.graphviz.org/doc/info/command.html'>\n     * http://www.graphviz.org/doc/info/command.html</a>.<p>\n     * Note that the leading \":\" is required while :formatter is optional.<p>\n     * The default renderer is typically GD.<p>\n     * Note that using {@link #setHighQuality(boolean)} is the preferred approach\n     * over using this method.\n     */\n    public void setRenderer(String renderer) {\n        Dot.getInstance().setRenderer(renderer);\n    }\n\n    /**\n     * @see #setRenderer(String)\n     * @return\n     */\n    public String getRenderer() {\n        String renderer = pullParam(\"-renderer\");\n        if (renderer != null)\n            setRenderer(renderer);\n        return Dot.getInstance().getRenderer();\n    }\n\n    /**\n     * If <code>false</code> then generate output of \"lower quality\"\n     * than the default.\n     * Note that the default is intended to be \"higher quality\",\n     * but various installations of Graphviz may have have different abilities.\n     * That is, some might not have the \"lower quality\" libraries and others might\n     * not have the \"higher quality\" libraries.<p>\n     * Higher quality output takes longer to generate and results in significantly\n     * larger image files (which take longer to download / display), but it generally\n     * looks better.\n     */\n    public void setHighQuality(boolean highQuality) {\n        this.highQuality = highQuality;\n        lowQuality = !highQuality;\n        Dot.getInstance().setHighQuality(highQuality);\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isHighQuality() {\n        if (highQuality == null) {\n            highQuality = options.remove(\"-hq\");\n            if (highQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(highQuality);\n            }\n        }\n        highQuality = Dot.getInstance().isHighQuality();\n        return highQuality;\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isLowQuality() {\n        if (lowQuality == null) {\n            lowQuality = options.remove(\"-lq\");\n            if (lowQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(!lowQuality);\n            }\n        }\n        lowQuality = !Dot.getInstance().isHighQuality();\n        return lowQuality;\n    }\n\n    /**\n     * Set the level of logging to perform.<p/>\n     * The levels in descending order are:\n     * <ul>\n     *  <li><code>severe</code> (highest - least detail)\n     *  <li><code>warning</code> (default)\n     *  <li><code>info</code>\n     *  <li><code>config</code>\n     *  <li><code>fine</code>\n     *  <li><code>finer</code>\n     *  <li><code>finest</code>  (lowest - most detail)\n     * </ul>\n     *\n     * @param logLevel\n     */\n    public void setLogLevel(String logLevel) {\n        if (logLevel == null) {\n            this.logLevel = Level.WARNING;\n            return;\n        }\n        Map<String, Level> levels = new LinkedHashMap<String, Level>();\n        levels.put(\"severe\", Level.SEVERE);\n        levels.put(\"warning\", Level.WARNING);\n        levels.put(\"info\", Level.INFO);\n        levels.put(\"config\", Level.CONFIG);\n        levels.put(\"fine\", Level.FINE);\n        levels.put(\"finer\", Level.FINER);\n        levels.put(\"finest\", Level.FINEST);\n        this.logLevel = levels.get(logLevel.toLowerCase());\n        if (this.logLevel == null) {\n            throw new InvalidConfigurationException(\"Invalid logLevel: '\" + logLevel + \"'. Must be one of: \" + levels.keySet());\n        }\n    }\n\n    /**\n     * Returns the level of logging to perform.\n     * See {@link #setLogLevel(String)}.\n     *\n     * @return\n     */\n    public Level getLogLevel() {\n        if (logLevel == null) {\n            setLogLevel(pullParam(\"-loglevel\"));\n        }\n        return logLevel;\n    }\n\n    /**\n     * Returns <code>true</code> if the options indicate that the user wants\n     * to see some help information.\n     *\n     * @return\n     */\n    public boolean isHelpRequired() {\n        return helpRequired;\n    }\n\n    public boolean isDbHelpRequired() {\n        return dbHelpRequired;\n    }\n\n    /**\n     * Returns the jar that we were loaded from\n     *\n     * @return\n     */\n    public static String getLoadedFromJar() {\n        String classpath = System.getProperty(\"java.class.path\");\n        return new StringTokenizer(classpath, File.pathSeparator).nextToken();\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasOrphans(boolean hasOrphans) {\n        this.hasOrphans = hasOrphans;\n    }\n\n    /**\n     * @see #setHasOrphans()\n     *\n     * @return\n     */\n    public boolean hasOrphans() {\n        return hasOrphans;\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasRoutines(boolean hasRoutines) {\n        this.hasRoutines = hasRoutines;\n    }\n\n    /**\n     * @see #setHasRoutines()\n     *\n     * @return\n     */\n    public boolean hasRoutines() {\n        return hasRoutines;\n    }\n\n    /**\n     * Returns the database properties to use.\n     * These should be determined by calling {@link #determineDbProperties(String)}.\n     * @return\n     * @throws InvalidConfigurationException\n     */\n    public Properties getDbProperties() throws InvalidConfigurationException {\n        if (dbProperties == null) {\n            try {\n                dbProperties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(exc);\n            }\n        }\n        return dbProperties;\n    }\n\n    /**\n     * Determines the database properties associated with the specified type.\n     * A call to {@link #setDbProperties(Properties)} is expected after determining\n     * the complete set of properties.\n     *\n     * @param type\n     * @return\n     * @throws IOException\n     * @throws InvalidConfigurationException if db properties are incorrectly formed\n     */\n    public Properties determineDbProperties(String type) throws IOException, InvalidConfigurationException {\n        ResourceBundle bundle = null;\n        try {\n            File propertiesFile = new File(type);\n            bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n            dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n        } catch (FileNotFoundException notFoundOnFilesystemWithoutExtension) {\n            try {\n                File propertiesFile = new File(type + \".properties\");\n                bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n                dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n            } catch (FileNotFoundException notFoundOnFilesystemWithExtensionTackedOn) {\n                try {\n                    bundle = ResourceBundle.getBundle(type);\n                    dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]\" + File.separator + type + \".properties\";\n                } catch (Exception notInJarWithoutPath) {\n                    try {\n                        String path = TableOrderer.class.getPackage().getName() + \".dbTypes.\" + type;\n                        path = path.replace('.', '/');\n                        bundle = ResourceBundle.getBundle(path);\n                        dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]/\" + path + \".properties\";\n                    } catch (Exception notInJar) {\n                        notInJar.printStackTrace();\n                        notFoundOnFilesystemWithExtensionTackedOn.printStackTrace();\n                        throw notFoundOnFilesystemWithoutExtension;\n                    }\n                }\n            }\n        }\n        Properties props = asProperties(bundle);\n        bundle = null;\n        // keep original thru recursion\n        String saveLoadedFrom = dbPropertiesLoadedFrom;\n        // bring in key/values pointed to by the include directive\n        // example: include.1=mysql::selectRowCountSql\n        for (int i = 1; true; ++i) {\n            String include = (String) props.remove(\"include.\" + i);\n            if (include == null)\n                break;\n            int separator = include.indexOf(\"::\");\n            if (separator == -1)\n                throw new InvalidConfigurationException(\"include directive in \" + dbPropertiesLoadedFrom + \" must have '::' between dbType and key\");\n            String refdType = include.substring(0, separator).trim();\n            String refdKey = include.substring(separator + 2).trim();\n            // recursively resolve the ref'd properties file and the ref'd key\n            Properties refdProps = determineDbProperties(refdType);\n            props.put(refdKey, refdProps.getProperty(refdKey));\n        }\n        // bring in base properties files pointed to by the extends directive\n        String baseDbType = (String) props.remove(\"extends\");\n        if (baseDbType != null) {\n            baseDbType = baseDbType.trim();\n            Properties baseProps = determineDbProperties(baseDbType);\n            // overlay our properties on top of the base's\n            baseProps.putAll(props);\n            props = baseProps;\n        }\n        // done with this level of recursion...restore original\n        dbPropertiesLoadedFrom = saveLoadedFrom;\n        // this won't be correct until the final recursion exits\n        dbProperties = props;\n        return props;\n    }\n\n    protected String getDbPropertiesLoadedFrom() throws IOException {\n        if (dbPropertiesLoadedFrom == null)\n            determineDbProperties(getDbType());\n        return dbPropertiesLoadedFrom;\n    }\n\n    public List<String> getRemainingParameters() {\n        try {\n            populate();\n        } catch (IllegalArgumentException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (IllegalAccessException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (InvocationTargetException exc) {\n            if (exc.getCause() instanceof InvalidConfigurationException)\n                throw (InvalidConfigurationException) exc.getCause();\n            throw new InvalidConfigurationException(exc.getCause());\n        } catch (IntrospectionException exc) {\n            throw new InvalidConfigurationException(exc);\n        }\n        return options;\n    }\n\n    /**\n     * Options that are specific to a type of database.  E.g. things like <code>host</code>,\n     * <code>port</code> or <code>db</code>, but <b>don't</b> have a setter in this class.\n     *\n     * @param dbSpecificOptions\n     */\n    public void setDbSpecificOptions(Map<String, String> dbSpecificOptions) {\n        this.dbSpecificOptions = dbSpecificOptions;\n        originalDbSpecificOptions = new HashMap<String, String>(dbSpecificOptions);\n    }\n\n    public Map<String, String> getDbSpecificOptions() {\n        if (dbSpecificOptions == null)\n            dbSpecificOptions = new HashMap<String, String>();\n        return dbSpecificOptions;\n    }\n\n    /**\n     * Returns a {@link Properties} populated with the contents of <code>bundle</code>\n     *\n     * @param bundle ResourceBundle\n     * @return Properties\n     */\n    public static Properties asProperties(ResourceBundle bundle) {\n        Properties props = new Properties();\n        Enumeration<String> iter = bundle.getKeys();\n        while (iter.hasMoreElements()) {\n            String key = iter.nextElement();\n            props.put(key, bundle.getObject(key));\n        }\n        return props;\n    }\n\n    /**\n     * 'Pull' the specified parameter from the collection of options. Returns\n     * null if the parameter isn't in the list and removes it if it is.\n     *\n     * @param paramId\n     * @return\n     */\n    private String pullParam(String paramId) {\n        return pullParam(paramId, false, false);\n    }\n\n    private String pullRequiredParam(String paramId) {\n        return pullParam(paramId, true, false);\n    }\n\n    /**\n     * @param paramId\n     * @param required\n     * @param dbTypeSpecific\n     * @return\n     * @throws MissingRequiredParameterException\n     */\n    private String pullParam(String paramId, boolean required, boolean dbTypeSpecific) throws MissingRequiredParameterException {\n        int paramIndex = options.indexOf(paramId);\n        if (paramIndex < 0) {\n            if (required)\n                throw new MissingRequiredParameterException(paramId, dbTypeSpecific);\n            return null;\n        }\n        options.remove(paramIndex);\n        String param = options.get(paramIndex).toString();\n        options.remove(paramIndex);\n        return param;\n    }\n\n    /**\n     * Thrown to indicate that a required parameter is missing\n     */\n    public static class MissingRequiredParameterException extends RuntimeException {\n\n        private static final long serialVersionUID = 1L;\n\n        private final boolean dbTypeSpecific;\n\n        public MissingRequiredParameterException(String paramId, boolean dbTypeSpecific) {\n            this(paramId, null, dbTypeSpecific);\n        }\n\n        public MissingRequiredParameterException(String paramId, String description, boolean dbTypeSpecific) {\n            super(\"Required parameter '\" + paramId + \"' \" + (description == null ? \"\" : \"(\" + description + \") \") + \"was not specified.\" + (dbTypeSpecific ? \"  It is required for this database type.\" : \"\"));\n            this.dbTypeSpecific = dbTypeSpecific;\n        }\n\n        public boolean isDbTypeSpecific() {\n            return dbTypeSpecific;\n        }\n    }\n\n    /**\n     * Allow an equal sign in args...like \"-o=foo.bar\". Useful for things like\n     * Ant and Maven.\n     *\n     * @param args\n     *            List\n     * @return List\n     */\n    protected List<String> fixupArgs(List<String> args) {\n        List<String> expandedArgs = new ArrayList<String>();\n        for (String arg : args) {\n            int indexOfEquals = arg.indexOf('=');\n            if (indexOfEquals != -1 && indexOfEquals - 1 != arg.indexOf(ESCAPED_EQUALS)) {\n                expandedArgs.add(arg.substring(0, indexOfEquals));\n                expandedArgs.add(arg.substring(indexOfEquals + 1));\n            } else {\n                expandedArgs.add(arg);\n            }\n        }\n        // some OSes/JVMs do filename expansion with runtime.exec() and some don't,\n        // so MultipleSchemaAnalyzer has to surround params with double quotes...\n        // strip them here for the OSes/JVMs that don't do anything with the params\n        List<String> unquotedArgs = new ArrayList<String>();\n        for (String arg : expandedArgs) {\n            if (// \".*\" becomes .*\n            arg.startsWith(\"\\\"\") && arg.endsWith(\"\\\"\"))\n                arg = arg.substring(1, arg.length() - 1);\n            unquotedArgs.add(arg);\n        }\n        return unquotedArgs;\n    }\n\n    /**\n     * Call all the getters to populate all the lazy initialized stuff.\n     *\n     * @throws InvocationTargetException\n     * @throws IllegalAccessException\n     * @throws IllegalArgumentException\n     * @throws IntrospectionException\n     */\n    private void populate() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IntrospectionException {\n        if (!populating) {\n            // prevent recursion\n            populating = true;\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                Method readMethod = props[i].getReadMethod();\n                if (readMethod != null)\n                    readMethod.invoke(this, (Object[]) null);\n            }\n            populating = false;\n        }\n    }\n\n    public static Set<String> getBuiltInDatabaseTypes(String loadedFromJar) {\n        Set<String> databaseTypes = new TreeSet<String>();\n        JarInputStream jar = null;\n        try {\n            jar = new JarInputStream(new FileInputStream(loadedFromJar));\n            JarEntry entry;\n            while ((entry = jar.getNextJarEntry()) != null) {\n                String entryName = entry.getName();\n                int dotPropsIndex = entryName.indexOf(\".properties\");\n                if (dotPropsIndex != -1)\n                    databaseTypes.add(entryName.substring(0, dotPropsIndex));\n            }\n        } catch (IOException exc) {\n        } finally {\n            if (jar != null) {\n                try {\n                    jar.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n        return databaseTypes;\n    }\n\n    protected void dumpUsage(String errorMessage, boolean detailedDb) {\n        if (errorMessage != null) {\n            System.out.flush();\n            System.err.println(\"*** \" + errorMessage + \" ***\");\n        } else {\n            System.out.println(\"SchemaSpy generates an HTML representation of a database schema's relationships.\");\n        }\n        System.err.flush();\n        System.out.println();\n        if (!detailedDb) {\n            System.out.println(\"Usage:\");\n            System.out.println(\" java -jar \" + getLoadedFromJar() + \" [options]\");\n            System.out.println(\"   -t databaseType       type of database - defaults to ora\");\n            System.out.println(\"                           use -dbhelp for a list of built-in types\");\n            System.out.println(\"   -u user               connect to the database with this user id\");\n            System.out.println(\"   -s schema             defaults to the specified user\");\n            System.out.println(\"   -p password           defaults to no password\");\n            System.out.println(\"   -o outputDirectory    directory to place the generated output in\");\n            System.out.println(\"   -dp pathToDrivers     optional - looks for JDBC drivers here before looking\");\n            System.out.println(\"                           in driverPath in [databaseType].properties.\");\n            System.out.println(\"Go to http://schemaspy.sourceforge.net for a complete list/description\");\n            System.out.println(\" of additional parameters.\");\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"Built-in database types and their required connection parameters:\");\n            for (String type : getBuiltInDatabaseTypes(getLoadedFromJar())) {\n                new DbSpecificConfig(type).dumpUsage();\n            }\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"You can use your own database types by specifying the filespec of a .properties file with -t.\");\n            System.out.println(\"Grab one out of \" + getLoadedFromJar() + \" and modify it to suit your needs.\");\n            System.out.println();\n        }\n        System.out.println(\"Sample usage using the default database type (implied -t ora):\");\n        System.out.println(\" java -jar schemaSpy.jar -db mydb -s myschema -u devuser -p password -o output\");\n        System.out.println();\n        System.out.flush();\n    }\n\n    /**\n     * Get the value of the specified parameter.\n     * Used for properties that are common to most db's, but aren't required.\n     *\n     * @param paramName\n     * @return\n     */\n    public String getParam(String paramName) {\n        try {\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                PropertyDescriptor prop = props[i];\n                if (prop.getName().equalsIgnoreCase(paramName)) {\n                    Object result = prop.getReadMethod().invoke(this, (Object[]) null);\n                    return result == null ? null : result.toString();\n                }\n            }\n        } catch (Exception failed) {\n            failed.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * Return all of the configuration options as a List of Strings, with\n     * each parameter and its value as a separate element.\n     *\n     * @return\n     * @throws IOException\n     */\n    public List<String> asList() throws IOException {\n        List<String> params = new ArrayList<String>();\n        if (originalDbSpecificOptions != null) {\n            for (String key : originalDbSpecificOptions.keySet()) {\n                String value = originalDbSpecificOptions.get(key);\n                if (!key.startsWith(\"-\"))\n                    key = \"-\" + key;\n                params.add(key);\n                params.add(value);\n            }\n        }\n        if (isEncodeCommentsEnabled())\n            params.add(\"-ahic\");\n        if (isEvaluateAllEnabled())\n            params.add(\"-all\");\n        if (!isHtmlGenerationEnabled())\n            params.add(\"-nohtml\");\n        if (!isImpliedConstraintsEnabled())\n            params.add(\"-noimplied\");\n        if (!isLogoEnabled())\n            params.add(\"-nologo\");\n        if (isMeterEnabled())\n            params.add(\"-meter\");\n        if (!isNumRowsEnabled())\n            params.add(\"-norows\");\n        if (!isViewsEnabled())\n            params.add(\"-noviews\");\n        if (isRankDirBugEnabled())\n            params.add(\"-rankdirbug\");\n        if (isRailsEnabled())\n            params.add(\"-rails\");\n        if (isSingleSignOn())\n            params.add(\"-sso\");\n        if (isSchemaDisabled())\n            params.add(\"-noschema\");\n        String value = getDriverPath();\n        if (value != null) {\n            params.add(\"-dp\");\n            params.add(value);\n        }\n        params.add(\"-css\");\n        params.add(getCss());\n        params.add(\"-charset\");\n        params.add(getCharset());\n        params.add(\"-font\");\n        params.add(getFont());\n        params.add(\"-fontsize\");\n        params.add(String.valueOf(getFontSize()));\n        params.add(\"-t\");\n        params.add(getDbType());\n        // query to set renderer correctly\n        isHighQuality();\n        // query to set renderer correctly\n        isLowQuality();\n        // instead of -hq and/or -lq\n        params.add(\"-renderer\");\n        params.add(getRenderer());\n        value = getDescription();\n        if (value != null) {\n            params.add(\"-desc\");\n            params.add(value);\n        }\n        value = getPassword();\n        if (value != null && !isPromptForPasswordEnabled()) {\n            // note that we don't pass -pfp since child processes\n            // won't have a console\n            params.add(\"-p\");\n            params.add(value);\n        }\n        value = getCatalog();\n        if (value != null) {\n            params.add(\"-cat\");\n            params.add(value);\n        }\n        value = getSchema();\n        if (value != null) {\n            params.add(\"-s\");\n            params.add(value);\n        }\n        value = getUser();\n        if (value != null) {\n            params.add(\"-u\");\n            params.add(value);\n        }\n        value = getConnectionPropertiesFile();\n        if (value != null) {\n            params.add(\"-connprops\");\n            params.add(value);\n        } else {\n            Properties props = getConnectionProperties();\n            if (!props.isEmpty()) {\n                params.add(\"-connprops\");\n                StringBuilder buf = new StringBuilder();\n                for (Entry<Object, Object> entry : props.entrySet()) {\n                    buf.append(entry.getKey());\n                    buf.append(ESCAPED_EQUALS);\n                    buf.append(entry.getValue());\n                    buf.append(';');\n                }\n                params.add(buf.toString());\n            }\n        }\n        value = getDb();\n        if (value != null) {\n            params.add(\"-db\");\n            params.add(value);\n        }\n        value = getHost();\n        if (value != null) {\n            params.add(\"-host\");\n            params.add(value);\n        }\n        if (getPort() != null) {\n            params.add(\"-port\");\n            params.add(getPort().toString());\n        }\n        value = getServer();\n        if (value != null) {\n            params.add(\"-server\");\n            params.add(value);\n        }\n        value = getMeta();\n        if (value != null) {\n            params.add(\"-meta\");\n            params.add(value);\n        }\n        if (getGraphvizDir() != null) {\n            params.add(\"-gv\");\n            params.add(getGraphvizDir().toString());\n        }\n        params.add(\"-loglevel\");\n        params.add(getLogLevel().toString().toLowerCase());\n        params.add(\"-sqlFormatter\");\n        params.add(getSqlFormatter().getClass().getName());\n        params.add(\"-i\");\n        params.add(getTableInclusions().toString());\n        params.add(\"-I\");\n        params.add(getTableExclusions().toString());\n        params.add(\"-X\");\n        params.add(getColumnExclusions().toString());\n        params.add(\"-x\");\n        params.add(getIndirectColumnExclusions().toString());\n        params.add(\"-dbthreads\");\n        params.add(String.valueOf(getMaxDbThreads()));\n        params.add(\"-maxdet\");\n        params.add(String.valueOf(getMaxDetailedTables()));\n        params.add(\"-o\");\n        params.add(getOutputDir().toString());\n        return params;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/ConfigTest0.java",
		"test_prompt": "// ConfigTest0.java\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Config}.\n* It contains ten unit test cases for the {@link Config#getInstance()} method.\n*/\nclass ConfigTest0 {"
	},
	{
		"original_code": "// Config.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\n\n/**\n * Configuration of a SchemaSpy run\n *\n * @author John Currier\n */\npublic class Config {\n\n    private static Config instance;\n\n    private final List<String> options;\n\n    private Map<String, String> dbSpecificOptions;\n\n    private Map<String, String> originalDbSpecificOptions;\n\n    private boolean helpRequired;\n\n    private boolean dbHelpRequired;\n\n    private File outputDir;\n\n    private File graphvizDir;\n\n    private String dbType;\n\n    private String catalog;\n\n    private String schema;\n\n    private List<String> schemas;\n\n    private String user;\n\n    private Boolean singleSignOn;\n\n    private Boolean noSchema;\n\n    private String password;\n\n    private Boolean promptForPassword;\n\n    private String db;\n\n    private String host;\n\n    private Integer port;\n\n    private String server;\n\n    private String meta;\n\n    private Pattern tableInclusions;\n\n    private Pattern tableExclusions;\n\n    private Pattern columnExclusions;\n\n    private Pattern indirectColumnExclusions;\n\n    private String userConnectionPropertiesFile;\n\n    private Properties userConnectionProperties;\n\n    private Integer maxDbThreads;\n\n    private Integer maxDetailedTables;\n\n    private String driverPath;\n\n    private String css;\n\n    private String charset;\n\n    private String font;\n\n    private Integer fontSize;\n\n    private String description;\n\n    private Properties dbProperties;\n\n    private String dbPropertiesLoadedFrom;\n\n    private Level logLevel;\n\n    private SqlFormatter sqlFormatter;\n\n    private String sqlFormatterClass;\n\n    private Boolean generateHtml;\n\n    private Boolean includeImpliedConstraints;\n\n    private Boolean logoEnabled;\n\n    private Boolean rankDirBugEnabled;\n\n    private Boolean encodeCommentsEnabled;\n\n    private Boolean numRowsEnabled;\n\n    private Boolean viewsEnabled;\n\n    private Boolean meterEnabled;\n\n    private Boolean railsEnabled;\n\n    private Boolean evaluteAll;\n\n    private Boolean highQuality;\n\n    private Boolean lowQuality;\n\n    // used in conjunction with evaluateAll\n    private String schemaSpec;\n\n    private boolean hasOrphans = false;\n\n    private boolean hasRoutines = false;\n\n    private boolean populating = false;\n\n    private List<String> columnDetails;\n\n    public static final String DOT_CHARSET = \"UTF-8\";\n\n    private static final String ESCAPED_EQUALS = \"\\\\=\";\n\n    // match everything\n    private static final String DEFAULT_TABLE_INCLUSION = \".*\";\n\n    // match nothing\n    private static final String DEFAULT_TABLE_EXCLUSION = \"\";\n\n    // match nothing\n    private static final String DEFAULT_COLUMN_EXCLUSION = \"[^.]\";\n\n    /**\n     * Default constructor. Intended for when you want to inject properties\n     * independently (i.e. not from a command line interface).\n     */\n    public Config() {\n        if (instance == null)\n            setInstance(this);\n        options = new ArrayList<String>();\n    }\n\n    /**\n     * Construct a configuration from an array of options (e.g. from a command\n     * line interface).\n     *\n     * @param options\n     */\n    public Config(String[] argv) {\n        setInstance(this);\n        options = fixupArgs(Arrays.asList(argv));\n        helpRequired = options.remove(\"-?\") || options.remove(\"/?\") || options.remove(\"?\") || options.remove(\"-h\") || options.remove(\"-help\") || options.remove(\"--help\");\n        dbHelpRequired = options.remove(\"-dbHelp\") || options.remove(\"-dbhelp\");\n    }\n\n    public static Config getInstance() {\n        if (instance == null)\n            instance = new Config();\n        return instance;\n    }\n\n    /**\n     * Sets the global instance.\n     *\n     * Useful for things like selecting a specific configuration in a UI.\n     *\n     * @param config\n     */\n    public static void setInstance(Config config) {\n        instance = config;\n    }\n\n    public void setHtmlGenerationEnabled(boolean generateHtml) {\n        this.generateHtml = generateHtml;\n    }\n\n    public boolean isHtmlGenerationEnabled() {\n        if (generateHtml == null)\n            generateHtml = !options.remove(\"-nohtml\");\n        return generateHtml;\n    }\n\n    public void setImpliedConstraintsEnabled(boolean includeImpliedConstraints) {\n        this.includeImpliedConstraints = includeImpliedConstraints;\n    }\n\n    public boolean isImpliedConstraintsEnabled() {\n        if (includeImpliedConstraints == null)\n            includeImpliedConstraints = !options.remove(\"-noimplied\");\n        return includeImpliedConstraints;\n    }\n\n    public void setOutputDir(String outputDirName) {\n        if (outputDirName.endsWith(\"\\\"\"))\n            outputDirName = outputDirName.substring(0, outputDirName.length() - 1);\n        setOutputDir(new File(outputDirName));\n    }\n\n    public void setOutputDir(File outputDir) {\n        this.outputDir = outputDir;\n    }\n\n    public File getOutputDir() {\n        if (outputDir == null) {\n            setOutputDir(pullRequiredParam(\"-o\"));\n        }\n        return outputDir;\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(String graphvizDir) {\n        if (graphvizDir.endsWith(\"\\\"\"))\n            graphvizDir = graphvizDir.substring(0, graphvizDir.length() - 1);\n        setGraphvizDir(new File(graphvizDir));\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(File graphvizDir) {\n        this.graphvizDir = graphvizDir;\n    }\n\n    /**\n     * Return the path to Graphviz (used to find the dot executable to run to\n     * generate ER diagrams).<p/>\n     *\n     * Returns {@link #getDefaultGraphvizPath()} if a specific Graphviz path\n     * was not specified.\n     *\n     * @return\n     */\n    public File getGraphvizDir() {\n        if (graphvizDir == null) {\n            String gv = pullParam(\"-gv\");\n            if (gv != null) {\n                setGraphvizDir(gv);\n            } else {\n                // expect to find Graphviz's bin directory on the PATH\n            }\n        }\n        return graphvizDir;\n    }\n\n    /**\n     * Meta files are XML-based files that provide additional metadata\n     * about the schema being evaluated.<p>\n     * <code>meta</code> is either the name of an individual XML file or\n     * the directory that contains meta files.<p>\n     * If a directory is specified then it is expected to contain files\n     * matching the pattern <code>[schema].meta.xml</code>.\n     * For databases that don't have schema substitute database for schema.\n     * @param meta\n     */\n    public void setMeta(String meta) {\n        this.meta = meta;\n    }\n\n    public String getMeta() {\n        if (meta == null)\n            meta = pullParam(\"-meta\");\n        return meta;\n    }\n\n    public void setDbType(String dbType) {\n        this.dbType = dbType;\n    }\n\n    public String getDbType() {\n        if (dbType == null) {\n            dbType = pullParam(\"-t\");\n            if (dbType == null)\n                dbType = \"ora\";\n        }\n        return dbType;\n    }\n\n    public void setDb(String db) {\n        this.db = db;\n    }\n\n    public String getDb() {\n        if (db == null)\n            db = pullParam(\"-db\");\n        return db;\n    }\n\n    public void setCatalog(String catalog) {\n        this.catalog = catalog;\n    }\n\n    public String getCatalog() {\n        if (catalog == null)\n            catalog = pullParam(\"-cat\");\n        return catalog;\n    }\n\n    public void setSchema(String schema) {\n        this.schema = schema;\n    }\n\n    public String getSchema() {\n        if (schema == null)\n            schema = pullParam(\"-s\");\n        return schema;\n    }\n\n    /**\n     * Some databases types (e.g. older versions of Informix) don't really\n     * have the concept of a schema but still return true from\n     * {@link DatabaseMetaData#supportsSchemasInTableDefinitions()}.\n     * This option lets you ignore that and treat all the tables\n     * as if they were in one flat namespace.\n     */\n    public boolean isSchemaDisabled() {\n        if (noSchema == null)\n            noSchema = options.remove(\"-noschema\");\n        return noSchema;\n    }\n\n    public void setHost(String host) {\n        this.host = host;\n    }\n\n    public String getHost() {\n        if (host == null)\n            host = pullParam(\"-host\");\n        return host;\n    }\n\n    public void setPort(Integer port) {\n        this.port = port;\n    }\n\n    public Integer getPort() {\n        if (port == null)\n            try {\n                port = Integer.valueOf(pullParam(\"-port\"));\n            } catch (Exception notSpecified) {\n            }\n        return port;\n    }\n\n    public void setServer(String server) {\n        this.server = server;\n    }\n\n    public String getServer() {\n        if (server == null) {\n            server = pullParam(\"-server\");\n        }\n        return server;\n    }\n\n    public void setUser(String user) {\n        this.user = user;\n    }\n\n    /**\n     * User used to connect to the database.\n     * Required unless single sign-on is enabled\n     * (see {@link #setSingleSignOn(boolean)}).\n     * @return\n     */\n    public String getUser() {\n        if (user == null) {\n            if (!isSingleSignOn())\n                user = pullRequiredParam(\"-u\");\n            else\n                user = pullParam(\"-u\");\n        }\n        return user;\n    }\n\n    /**\n     * By default a \"user\" (as specified with -u) is required.\n     * This option allows disabling of that requirement for\n     * single sign-on environments.\n     *\n     * @param enabled defaults to <code>false</code>\n     */\n    public void setSingleSignOn(boolean enabled) {\n        singleSignOn = enabled;\n    }\n\n    /**\n     * @see #setSingleSignOn(boolean)\n     */\n    public boolean isSingleSignOn() {\n        if (singleSignOn == null)\n            singleSignOn = options.remove(\"-sso\");\n        return singleSignOn;\n    }\n\n    /**\n     * Set the password used to connect to the database.\n     * @param password\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * @see #setPassword(String)\n     * @return\n     */\n    public String getPassword() {\n        if (password == null)\n            password = pullParam(\"-p\");\n        if (password == null && isPromptForPasswordEnabled())\n            password = new String(PasswordReader.getInstance().readPassword(\"Password: \"));\n        if (password == null) {\n            // if -pfp is enabled when analyzing multiple schemas then\n            // we don't want to send the password on the command line,\n            // so see if it was passed in the environment (not ideal, but safer)\n            password = System.getenv(\"schemaspy.pw\");\n        }\n        return password;\n    }\n\n    /**\n     * Set to <code>true</code> to prompt for the password\n     * @param promptForPassword\n     */\n    public void setPromptForPasswordEnabled(boolean promptForPassword) {\n        this.promptForPassword = promptForPassword;\n    }\n\n    /**\n     * @see #setPromptForPasswordEnabled(boolean)\n     * @return\n     */\n    public boolean isPromptForPasswordEnabled() {\n        if (promptForPassword == null) {\n            promptForPassword = options.remove(\"-pfp\");\n        }\n        return promptForPassword;\n    }\n\n    public void setMaxDetailedTabled(int maxDetailedTables) {\n        this.maxDetailedTables = new Integer(maxDetailedTables);\n    }\n\n    public int getMaxDetailedTables() {\n        if (maxDetailedTables == null) {\n            // default\n            int max = 300;\n            try {\n                max = Integer.parseInt(pullParam(\"-maxdet\"));\n            } catch (Exception notSpecified) {\n            }\n            maxDetailedTables = new Integer(max);\n        }\n        return maxDetailedTables.intValue();\n    }\n\n    public String getConnectionPropertiesFile() {\n        return userConnectionPropertiesFile;\n    }\n\n    /**\n     * Properties from this file (in key=value pair format) are passed to the\n     * database connection.<br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.\n     * @param propertiesFilename\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public void setConnectionPropertiesFile(String propertiesFilename) throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null)\n            userConnectionProperties = new Properties();\n        userConnectionProperties.load(new FileInputStream(propertiesFilename));\n        userConnectionPropertiesFile = propertiesFilename;\n    }\n\n    /**\n     * Returns a {@link Properties} populated either from the properties file specified\n     * by {@link #setConnectionPropertiesFile(String)}, the properties specified by\n     * {@link #setConnectionProperties(String)} or not populated.\n     * @return\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public Properties getConnectionProperties() throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null) {\n            String props = pullParam(\"-connprops\");\n            if (props != null) {\n                if (props.indexOf(ESCAPED_EQUALS) != -1) {\n                    setConnectionProperties(props);\n                } else {\n                    setConnectionPropertiesFile(props);\n                }\n            } else {\n                userConnectionProperties = new Properties();\n            }\n        }\n        return userConnectionProperties;\n    }\n\n    /**\n     * Specifies connection properties to use in the format:\n     * <code>key1\\=value1;key2\\=value2</code><br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.<p>\n     * This is an alternative form of passing connection properties than by file\n     * (see {@link #setConnectionPropertiesFile(String)})\n     *\n     * @param properties\n     */\n    public void setConnectionProperties(String properties) {\n        userConnectionProperties = new Properties();\n        StringTokenizer tokenizer = new StringTokenizer(properties, \";\");\n        while (tokenizer.hasMoreElements()) {\n            String pair = tokenizer.nextToken();\n            int index = pair.indexOf(ESCAPED_EQUALS);\n            if (index != -1) {\n                String key = pair.substring(0, index);\n                String value = pair.substring(index + ESCAPED_EQUALS.length());\n                userConnectionProperties.put(key, value);\n            }\n        }\n    }\n\n    public void setDriverPath(String driverPath) {\n        this.driverPath = driverPath;\n    }\n\n    public String getDriverPath() {\n        if (driverPath == null)\n            driverPath = pullParam(\"-dp\");\n        // was previously -cp:\n        if (driverPath == null)\n            driverPath = pullParam(\"-cp\");\n        return driverPath;\n    }\n\n    /**\n     * The filename of the cascading style sheet to use.\n     * Note that this file is parsed and used to determine characteristics\n     * of the generated diagrams, so it must contain specific settings that\n     * are documented within schemaSpy.css.<p>\n     *\n     * Defaults to <code>\"schemaSpy.css\"</code>.\n     *\n     * @param css\n     */\n    public void setCss(String css) {\n        this.css = css;\n    }\n\n    public String getCss() {\n        if (css == null) {\n            css = pullParam(\"-css\");\n            if (css == null)\n                css = \"schemaSpy.css\";\n        }\n        return css;\n    }\n\n    /**\n     * The font to use within diagrams.  Modify the .css to specify HTML fonts.\n     *\n     * @param font\n     */\n    public void setFont(String font) {\n        this.font = font;\n    }\n\n    /**\n     * @see #setFont(String)\n     */\n    public String getFont() {\n        if (font == null) {\n            font = pullParam(\"-font\");\n            if (font == null)\n                font = \"Helvetica\";\n        }\n        return font;\n    }\n\n    /**\n     * The font size to use within diagrams.  This is the size of the font used for\n     * 'large' (e.g. not 'compact') diagrams.<p>\n     *\n     * Modify the .css to specify HTML font sizes.<p>\n     *\n     * Defaults to 11.\n     *\n     * @param fontSize\n     */\n    public void setFontSize(int fontSize) {\n        this.fontSize = new Integer(fontSize);\n    }\n\n    /**\n     * @see #setFontSize(int)\n     * @return\n     */\n    public int getFontSize() {\n        if (fontSize == null) {\n            // default\n            int size = 11;\n            try {\n                size = Integer.parseInt(pullParam(\"-fontsize\"));\n            } catch (Exception notSpecified) {\n            }\n            fontSize = new Integer(size);\n        }\n        return fontSize.intValue();\n    }\n\n    /**\n     * The character set to use within HTML pages (defaults to <code>\"ISO-8859-1\"</code>).\n     *\n     * @param charset\n     */\n    public void setCharset(String charset) {\n        this.charset = charset;\n    }\n\n    /**\n     * @see #setCharset(String)\n     */\n    public String getCharset() {\n        if (charset == null) {\n            charset = pullParam(\"-charset\");\n            if (charset == null)\n                charset = \"ISO-8859-1\";\n        }\n        return charset;\n    }\n\n    /**\n     * Description of schema that gets display on main pages.\n     *\n     * @param description\n     */\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    /**\n     * @see #setDescription(String)\n     */\n    public String getDescription() {\n        if (description == null)\n            description = pullParam(\"-desc\");\n        return description;\n    }\n\n    /**\n     * Maximum number of threads to use when querying database metadata information.\n     *\n     * @param maxDbThreads\n     */\n    public void setMaxDbThreads(int maxDbThreads) {\n        this.maxDbThreads = new Integer(maxDbThreads);\n    }\n\n    /**\n     * @see #setMaxDbThreads(int)\n     * @throws InvalidConfigurationException if unable to load properties\n     */\n    public int getMaxDbThreads() throws InvalidConfigurationException {\n        if (maxDbThreads == null) {\n            Properties properties;\n            try {\n                properties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(\"Failed to load properties for \" + getDbType() + \": \" + exc).setParamName(\"-type\");\n            }\n            // not scientifically derived\n            final int defaultMax = 15;\n            int max = defaultMax;\n            String threads = properties.getProperty(\"dbThreads\");\n            if (threads == null)\n                threads = properties.getProperty(\"dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            threads = pullParam(\"-dbThreads\");\n            if (threads == null)\n                threads = pullParam(\"-dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            if (max < 0)\n                max = defaultMax;\n            else if (max == 0)\n                max = 1;\n            maxDbThreads = new Integer(max);\n        }\n        return maxDbThreads.intValue();\n    }\n\n    public boolean isLogoEnabled() {\n        if (logoEnabled == null)\n            logoEnabled = !options.remove(\"-nologo\");\n        return logoEnabled;\n    }\n\n    /**\n     * Don't use this unless absolutely necessary as it screws up the layout\n     *\n     * @param enabled\n     */\n    public void setRankDirBugEnabled(boolean enabled) {\n        rankDirBugEnabled = enabled;\n    }\n\n    /**\n     * @see #setRankDirBugEnabled(boolean)\n     */\n    public boolean isRankDirBugEnabled() {\n        if (rankDirBugEnabled == null)\n            rankDirBugEnabled = options.remove(\"-rankdirbug\");\n        return rankDirBugEnabled;\n    }\n\n    /**\n     * Look for Ruby on Rails-based naming conventions in\n     * relationships between logical foreign keys and primary keys.<p>\n     *\n     * Basically all tables have a primary key named <code>ID</code>.\n     * All tables are named plural names.\n     * The columns that logically reference that <code>ID</code> are the singular\n     * form of the table name suffixed with <code>_ID</code>.<p>\n     *\n     * @param enabled\n     */\n    public void setRailsEnabled(boolean enabled) {\n        railsEnabled = enabled;\n    }\n\n    /**\n     * @see #setRailsEnabled(boolean)\n     *\n     * @return\n     */\n    public boolean isRailsEnabled() {\n        if (railsEnabled == null)\n            railsEnabled = options.remove(\"-rails\");\n        return railsEnabled;\n    }\n\n    /**\n     * Allow Html In Comments - encode them unless otherwise specified\n     */\n    public void setEncodeCommentsEnabled(boolean enabled) {\n        encodeCommentsEnabled = enabled;\n    }\n\n    /**\n     * @see #setEncodeCommentsEnabled(boolean)\n     */\n    public boolean isEncodeCommentsEnabled() {\n        if (encodeCommentsEnabled == null)\n            encodeCommentsEnabled = !options.remove(\"-ahic\");\n        return encodeCommentsEnabled;\n    }\n\n    /**\n     * If enabled we'll attempt to query/render the number of rows that\n     * each table contains.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setNumRowsEnabled(boolean enabled) {\n        numRowsEnabled = enabled;\n    }\n\n    /**\n     * @see #setNumRowsEnabled(boolean)\n     * @return\n     */\n    public boolean isNumRowsEnabled() {\n        if (numRowsEnabled == null)\n            numRowsEnabled = !options.remove(\"-norows\");\n        return numRowsEnabled;\n    }\n\n    /**\n     * If enabled we'll include views in the analysis.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setViewsEnabled(boolean enabled) {\n        viewsEnabled = enabled;\n    }\n\n    /**\n     * @see #setViewsEnabled(boolean)\n     * @return\n     */\n    public boolean isViewsEnabled() {\n        if (viewsEnabled == null)\n            viewsEnabled = !options.remove(\"-noviews\");\n        return viewsEnabled;\n    }\n\n    /**\n     * Returns <code>true</code> if metering should be embedded in\n     * the generated pages.<p/>\n     * Defaults to <code>false</code> (disabled).\n     * @return\n     */\n    public boolean isMeterEnabled() {\n        if (meterEnabled == null)\n            meterEnabled = options.remove(\"-meter\");\n        return meterEnabled;\n    }\n\n    /**\n     * Set the columns to exclude from all relationship diagrams.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setColumnExclusions(String columnExclusions) {\n        this.columnExclusions = Pattern.compile(columnExclusions);\n    }\n\n    /**\n     * See {@link #setColumnExclusions(String)}\n     * @return\n     */\n    public Pattern getColumnExclusions() {\n        if (columnExclusions == null) {\n            String strExclusions = pullParam(\"-X\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.columnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            columnExclusions = Pattern.compile(strExclusions);\n        }\n        return columnExclusions;\n    }\n\n    /**\n     * Set the columns to exclude from relationship diagrams where the specified\n     * columns aren't directly referenced by the focal table.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setIndirectColumnExclusions(String fullColumnExclusions) {\n        indirectColumnExclusions = Pattern.compile(fullColumnExclusions);\n    }\n\n    /**\n     * @see #setIndirectColumnExclusions(String)\n     *\n     * @return\n     */\n    public Pattern getIndirectColumnExclusions() {\n        if (indirectColumnExclusions == null) {\n            String strExclusions = pullParam(\"-x\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.indirectColumnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            indirectColumnExclusions = Pattern.compile(strExclusions);\n        }\n        return indirectColumnExclusions;\n    }\n\n    /**\n     * Set the tables to include as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableInclusions(String tableInclusions) {\n        this.tableInclusions = Pattern.compile(tableInclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to include in the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableInclusions() {\n        if (tableInclusions == null) {\n            String strInclusions = pullParam(\"-i\");\n            if (strInclusions == null)\n                strInclusions = System.getenv(\"schemaspy.tableInclusions\");\n            if (strInclusions == null)\n                strInclusions = DEFAULT_TABLE_INCLUSION;\n            try {\n                tableInclusions = Pattern.compile(strInclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-i\");\n            }\n        }\n        return tableInclusions;\n    }\n\n    /**\n     * Set the tables to exclude as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableExclusions(String tableExclusions) {\n        this.tableExclusions = Pattern.compile(tableExclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to exclude from the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableExclusions() {\n        if (tableExclusions == null) {\n            String strExclusions = pullParam(\"-I\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.tableExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_TABLE_EXCLUSION;\n            try {\n                tableExclusions = Pattern.compile(strExclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-I\");\n            }\n        }\n        return tableExclusions;\n    }\n\n    /**\n     * @return\n     */\n    public List<String> getSchemas() {\n        if (schemas == null) {\n            String tmp = pullParam(\"-schemas\");\n            if (tmp == null)\n                tmp = pullParam(\"-schemata\");\n            if (tmp != null) {\n                schemas = new ArrayList<String>();\n                for (String name : tmp.split(\"[\\\\s,'\\\"]\")) {\n                    if (name.length() > 0)\n                        schemas.add(name);\n                }\n                if (schemas.isEmpty())\n                    schemas = null;\n            }\n        }\n        return schemas;\n    }\n\n    /**\n     * Set the name of the {@link SqlFormatter SQL formatter} class to use to\n     * format SQL into HTML.<p/>\n     * The implementation of the class must be made available to the class\n     * loader, typically by specifying the path to its jar with <em>-dp</em>\n     * ({@link #setDriverPath(String)}).\n     */\n    public void setSqlFormatter(String formatterClassName) {\n        sqlFormatterClass = formatterClassName;\n        sqlFormatter = null;\n    }\n\n    /**\n     * Set the {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.\n     */\n    public void setSqlFormatter(SqlFormatter sqlFormatter) {\n        this.sqlFormatter = sqlFormatter;\n        if (sqlFormatter != null)\n            sqlFormatterClass = sqlFormatter.getClass().getName();\n    }\n\n    /**\n     * Returns an implementation of {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.  The default implementation is {@link DefaultSqlFormatter}.\n     *\n     * @return\n     * @throws InvalidConfigurationException if unable to instantiate an instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SqlFormatter getSqlFormatter() throws InvalidConfigurationException {\n        if (sqlFormatter == null) {\n            if (sqlFormatterClass == null) {\n                sqlFormatterClass = pullParam(\"-sqlFormatter\");\n                if (sqlFormatterClass == null)\n                    sqlFormatterClass = DefaultSqlFormatter.class.getName();\n            }\n            try {\n                Class<SqlFormatter> clazz = (Class<SqlFormatter>) Class.forName(sqlFormatterClass);\n                sqlFormatter = clazz.newInstance();\n            } catch (Exception exc) {\n                throw new InvalidConfigurationException(\"Failed to initialize instance of SQL formatter: \", exc).setParamName(\"-sqlFormatter\");\n            }\n        }\n        return sqlFormatter;\n    }\n\n    /**\n     * Set the details to show on the columns page, where \"details\" are\n     * comma and/or space separated.\n     *\n     * Valid values:\n     * <ul>\n     * <li>id</li>\n     * <li>table</li>\n     * <li>column</li>\n     * <li>type</li>\n     * <li>size</li>\n     * <li>nulls</li>\n     * <li>auto</li>\n     * <li>default</li>\n     * <li>children</li>\n     * <li>parents</li>\n     * </ul>\n     *\n     * The default details are <code>\"table column type size nulls auto default\"</code>.\n     * Note that \"column\" is the initially displayed detail and must be included.\n     *\n     * @param columnDetails\n     */\n    public void setColumnDetails(String columnDetails) {\n        this.columnDetails = new ArrayList<String>();\n        if (columnDetails == null || columnDetails.length() == 0) {\n            // not specified, so use defaults\n            columnDetails = \"id table column type size nulls auto default\";\n        }\n        for (String detail : columnDetails.split(\"[\\\\s,'\\\"]\")) {\n            if (detail.length() > 0) {\n                this.columnDetails.add(detail.toLowerCase());\n            }\n        }\n        if (!this.columnDetails.contains(\"column\"))\n            throw new InvalidConfigurationException(\"'column' is a required column detail\");\n    }\n\n    public void setColumnDetails(List<String> columnDetails) {\n        String details = columnDetails == null ? \"[]\" : columnDetails.toString();\n        setColumnDetails(details.substring(1, details.length() - 1));\n    }\n\n    public List<String> getColumnDetails() {\n        if (columnDetails == null) {\n            setColumnDetails(pullParam(\"-columndetails\"));\n        }\n        return columnDetails;\n    }\n\n    public void setEvaluateAllEnabled(boolean enabled) {\n        evaluteAll = enabled;\n    }\n\n    public boolean isEvaluateAllEnabled() {\n        if (evaluteAll == null)\n            evaluteAll = options.remove(\"-all\");\n        return evaluteAll;\n    }\n\n    /**\n     * Returns true if we're evaluating a bunch of schemas in one go and\n     * at this point we're evaluating a specific schema.\n     *\n     * @return boolean\n     */\n    public boolean isOneOfMultipleSchemas() {\n        // set by MultipleSchemaAnalyzer\n        return Boolean.getBoolean(\"oneofmultipleschemas\");\n    }\n\n    /**\n     * When -all (evaluateAll) is specified then this is the regular\n     * expression that determines which schemas to evaluate.\n     *\n     * @param schemaSpec\n     */\n    public void setSchemaSpec(String schemaSpec) {\n        this.schemaSpec = schemaSpec;\n    }\n\n    public String getSchemaSpec() {\n        if (schemaSpec == null)\n            schemaSpec = pullParam(\"-schemaSpec\");\n        return schemaSpec;\n    }\n\n    /**\n     * Set the renderer to use for the -Tpng[:renderer[:formatter]] dot option as specified\n     * at <a href='http://www.graphviz.org/doc/info/command.html'>\n     * http://www.graphviz.org/doc/info/command.html</a>.<p>\n     * Note that the leading \":\" is required while :formatter is optional.<p>\n     * The default renderer is typically GD.<p>\n     * Note that using {@link #setHighQuality(boolean)} is the preferred approach\n     * over using this method.\n     */\n    public void setRenderer(String renderer) {\n        Dot.getInstance().setRenderer(renderer);\n    }\n\n    /**\n     * @see #setRenderer(String)\n     * @return\n     */\n    public String getRenderer() {\n        String renderer = pullParam(\"-renderer\");\n        if (renderer != null)\n            setRenderer(renderer);\n        return Dot.getInstance().getRenderer();\n    }\n\n    /**\n     * If <code>false</code> then generate output of \"lower quality\"\n     * than the default.\n     * Note that the default is intended to be \"higher quality\",\n     * but various installations of Graphviz may have have different abilities.\n     * That is, some might not have the \"lower quality\" libraries and others might\n     * not have the \"higher quality\" libraries.<p>\n     * Higher quality output takes longer to generate and results in significantly\n     * larger image files (which take longer to download / display), but it generally\n     * looks better.\n     */\n    public void setHighQuality(boolean highQuality) {\n        this.highQuality = highQuality;\n        lowQuality = !highQuality;\n        Dot.getInstance().setHighQuality(highQuality);\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isHighQuality() {\n        if (highQuality == null) {\n            highQuality = options.remove(\"-hq\");\n            if (highQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(highQuality);\n            }\n        }\n        highQuality = Dot.getInstance().isHighQuality();\n        return highQuality;\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isLowQuality() {\n        if (lowQuality == null) {\n            lowQuality = options.remove(\"-lq\");\n            if (lowQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(!lowQuality);\n            }\n        }\n        lowQuality = !Dot.getInstance().isHighQuality();\n        return lowQuality;\n    }\n\n    /**\n     * Set the level of logging to perform.<p/>\n     * The levels in descending order are:\n     * <ul>\n     *  <li><code>severe</code> (highest - least detail)\n     *  <li><code>warning</code> (default)\n     *  <li><code>info</code>\n     *  <li><code>config</code>\n     *  <li><code>fine</code>\n     *  <li><code>finer</code>\n     *  <li><code>finest</code>  (lowest - most detail)\n     * </ul>\n     *\n     * @param logLevel\n     */\n    public void setLogLevel(String logLevel) {\n        if (logLevel == null) {\n            this.logLevel = Level.WARNING;\n            return;\n        }\n        Map<String, Level> levels = new LinkedHashMap<String, Level>();\n        levels.put(\"severe\", Level.SEVERE);\n        levels.put(\"warning\", Level.WARNING);\n        levels.put(\"info\", Level.INFO);\n        levels.put(\"config\", Level.CONFIG);\n        levels.put(\"fine\", Level.FINE);\n        levels.put(\"finer\", Level.FINER);\n        levels.put(\"finest\", Level.FINEST);\n        this.logLevel = levels.get(logLevel.toLowerCase());\n        if (this.logLevel == null) {\n            throw new InvalidConfigurationException(\"Invalid logLevel: '\" + logLevel + \"'. Must be one of: \" + levels.keySet());\n        }\n    }\n\n    /**\n     * Returns the level of logging to perform.\n     * See {@link #setLogLevel(String)}.\n     *\n     * @return\n     */\n    public Level getLogLevel() {\n        if (logLevel == null) {\n            setLogLevel(pullParam(\"-loglevel\"));\n        }\n        return logLevel;\n    }\n\n    /**\n     * Returns <code>true</code> if the options indicate that the user wants\n     * to see some help information.\n     *\n     * @return\n     */\n    public boolean isHelpRequired() {\n        return helpRequired;\n    }\n\n    public boolean isDbHelpRequired() {\n        return dbHelpRequired;\n    }\n\n    /**\n     * Returns the jar that we were loaded from\n     *\n     * @return\n     */\n    public static String getLoadedFromJar() {\n        String classpath = System.getProperty(\"java.class.path\");\n        return new StringTokenizer(classpath, File.pathSeparator).nextToken();\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasOrphans(boolean hasOrphans) {\n        this.hasOrphans = hasOrphans;\n    }\n\n    /**\n     * @see #setHasOrphans()\n     *\n     * @return\n     */\n    public boolean hasOrphans() {\n        return hasOrphans;\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasRoutines(boolean hasRoutines) {\n        this.hasRoutines = hasRoutines;\n    }\n\n    /**\n     * @see #setHasRoutines()\n     *\n     * @return\n     */\n    public boolean hasRoutines() {\n        return hasRoutines;\n    }\n\n    /**\n     * Returns the database properties to use.\n     * These should be determined by calling {@link #determineDbProperties(String)}.\n     * @return\n     * @throws InvalidConfigurationException\n     */\n    public Properties getDbProperties() throws InvalidConfigurationException {\n        if (dbProperties == null) {\n            try {\n                dbProperties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(exc);\n            }\n        }\n        return dbProperties;\n    }\n\n    /**\n     * Determines the database properties associated with the specified type.\n     * A call to {@link #setDbProperties(Properties)} is expected after determining\n     * the complete set of properties.\n     *\n     * @param type\n     * @return\n     * @throws IOException\n     * @throws InvalidConfigurationException if db properties are incorrectly formed\n     */\n    public Properties determineDbProperties(String type) throws IOException, InvalidConfigurationException {\n        ResourceBundle bundle = null;\n        try {\n            File propertiesFile = new File(type);\n            bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n            dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n        } catch (FileNotFoundException notFoundOnFilesystemWithoutExtension) {\n            try {\n                File propertiesFile = new File(type + \".properties\");\n                bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n                dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n            } catch (FileNotFoundException notFoundOnFilesystemWithExtensionTackedOn) {\n                try {\n                    bundle = ResourceBundle.getBundle(type);\n                    dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]\" + File.separator + type + \".properties\";\n                } catch (Exception notInJarWithoutPath) {\n                    try {\n                        String path = TableOrderer.class.getPackage().getName() + \".dbTypes.\" + type;\n                        path = path.replace('.', '/');\n                        bundle = ResourceBundle.getBundle(path);\n                        dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]/\" + path + \".properties\";\n                    } catch (Exception notInJar) {\n                        notInJar.printStackTrace();\n                        notFoundOnFilesystemWithExtensionTackedOn.printStackTrace();\n                        throw notFoundOnFilesystemWithoutExtension;\n                    }\n                }\n            }\n        }\n        Properties props = asProperties(bundle);\n        bundle = null;\n        // keep original thru recursion\n        String saveLoadedFrom = dbPropertiesLoadedFrom;\n        // bring in key/values pointed to by the include directive\n        // example: include.1=mysql::selectRowCountSql\n        for (int i = 1; true; ++i) {\n            String include = (String) props.remove(\"include.\" + i);\n            if (include == null)\n                break;\n            int separator = include.indexOf(\"::\");\n            if (separator == -1)\n                throw new InvalidConfigurationException(\"include directive in \" + dbPropertiesLoadedFrom + \" must have '::' between dbType and key\");\n            String refdType = include.substring(0, separator).trim();\n            String refdKey = include.substring(separator + 2).trim();\n            // recursively resolve the ref'd properties file and the ref'd key\n            Properties refdProps = determineDbProperties(refdType);\n            props.put(refdKey, refdProps.getProperty(refdKey));\n        }\n        // bring in base properties files pointed to by the extends directive\n        String baseDbType = (String) props.remove(\"extends\");\n        if (baseDbType != null) {\n            baseDbType = baseDbType.trim();\n            Properties baseProps = determineDbProperties(baseDbType);\n            // overlay our properties on top of the base's\n            baseProps.putAll(props);\n            props = baseProps;\n        }\n        // done with this level of recursion...restore original\n        dbPropertiesLoadedFrom = saveLoadedFrom;\n        // this won't be correct until the final recursion exits\n        dbProperties = props;\n        return props;\n    }\n\n    protected String getDbPropertiesLoadedFrom() throws IOException {\n        if (dbPropertiesLoadedFrom == null)\n            determineDbProperties(getDbType());\n        return dbPropertiesLoadedFrom;\n    }\n\n    public List<String> getRemainingParameters() {\n        try {\n            populate();\n        } catch (IllegalArgumentException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (IllegalAccessException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (InvocationTargetException exc) {\n            if (exc.getCause() instanceof InvalidConfigurationException)\n                throw (InvalidConfigurationException) exc.getCause();\n            throw new InvalidConfigurationException(exc.getCause());\n        } catch (IntrospectionException exc) {\n            throw new InvalidConfigurationException(exc);\n        }\n        return options;\n    }\n\n    /**\n     * Options that are specific to a type of database.  E.g. things like <code>host</code>,\n     * <code>port</code> or <code>db</code>, but <b>don't</b> have a setter in this class.\n     *\n     * @param dbSpecificOptions\n     */\n    public void setDbSpecificOptions(Map<String, String> dbSpecificOptions) {\n        this.dbSpecificOptions = dbSpecificOptions;\n        originalDbSpecificOptions = new HashMap<String, String>(dbSpecificOptions);\n    }\n\n    public Map<String, String> getDbSpecificOptions() {\n        if (dbSpecificOptions == null)\n            dbSpecificOptions = new HashMap<String, String>();\n        return dbSpecificOptions;\n    }\n\n    /**\n     * Returns a {@link Properties} populated with the contents of <code>bundle</code>\n     *\n     * @param bundle ResourceBundle\n     * @return Properties\n     */\n    public static Properties asProperties(ResourceBundle bundle) {\n        Properties props = new Properties();\n        Enumeration<String> iter = bundle.getKeys();\n        while (iter.hasMoreElements()) {\n            String key = iter.nextElement();\n            props.put(key, bundle.getObject(key));\n        }\n        return props;\n    }\n\n    /**\n     * 'Pull' the specified parameter from the collection of options. Returns\n     * null if the parameter isn't in the list and removes it if it is.\n     *\n     * @param paramId\n     * @return\n     */\n    private String pullParam(String paramId) {\n        return pullParam(paramId, false, false);\n    }\n\n    private String pullRequiredParam(String paramId) {\n        return pullParam(paramId, true, false);\n    }\n\n    /**\n     * @param paramId\n     * @param required\n     * @param dbTypeSpecific\n     * @return\n     * @throws MissingRequiredParameterException\n     */\n    private String pullParam(String paramId, boolean required, boolean dbTypeSpecific) throws MissingRequiredParameterException {\n        int paramIndex = options.indexOf(paramId);\n        if (paramIndex < 0) {\n            if (required)\n                throw new MissingRequiredParameterException(paramId, dbTypeSpecific);\n            return null;\n        }\n        options.remove(paramIndex);\n        String param = options.get(paramIndex).toString();\n        options.remove(paramIndex);\n        return param;\n    }\n\n    /**\n     * Thrown to indicate that a required parameter is missing\n     */\n    public static class MissingRequiredParameterException extends RuntimeException {\n\n        private static final long serialVersionUID = 1L;\n\n        private final boolean dbTypeSpecific;\n\n        public MissingRequiredParameterException(String paramId, boolean dbTypeSpecific) {\n            this(paramId, null, dbTypeSpecific);\n        }\n\n        public MissingRequiredParameterException(String paramId, String description, boolean dbTypeSpecific) {\n            super(\"Required parameter '\" + paramId + \"' \" + (description == null ? \"\" : \"(\" + description + \") \") + \"was not specified.\" + (dbTypeSpecific ? \"  It is required for this database type.\" : \"\"));\n            this.dbTypeSpecific = dbTypeSpecific;\n        }\n\n        public boolean isDbTypeSpecific() {\n            return dbTypeSpecific;\n        }\n    }\n\n    /**\n     * Allow an equal sign in args...like \"-o=foo.bar\". Useful for things like\n     * Ant and Maven.\n     *\n     * @param args\n     *            List\n     * @return List\n     */\n    protected List<String> fixupArgs(List<String> args) {\n        List<String> expandedArgs = new ArrayList<String>();\n        for (String arg : args) {\n            int indexOfEquals = arg.indexOf('=');\n            if (indexOfEquals != -1 && indexOfEquals - 1 != arg.indexOf(ESCAPED_EQUALS)) {\n                expandedArgs.add(arg.substring(0, indexOfEquals));\n                expandedArgs.add(arg.substring(indexOfEquals + 1));\n            } else {\n                expandedArgs.add(arg);\n            }\n        }\n        // some OSes/JVMs do filename expansion with runtime.exec() and some don't,\n        // so MultipleSchemaAnalyzer has to surround params with double quotes...\n        // strip them here for the OSes/JVMs that don't do anything with the params\n        List<String> unquotedArgs = new ArrayList<String>();\n        for (String arg : expandedArgs) {\n            if (// \".*\" becomes .*\n            arg.startsWith(\"\\\"\") && arg.endsWith(\"\\\"\"))\n                arg = arg.substring(1, arg.length() - 1);\n            unquotedArgs.add(arg);\n        }\n        return unquotedArgs;\n    }\n\n    /**\n     * Call all the getters to populate all the lazy initialized stuff.\n     *\n     * @throws InvocationTargetException\n     * @throws IllegalAccessException\n     * @throws IllegalArgumentException\n     * @throws IntrospectionException\n     */\n    private void populate() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IntrospectionException {\n        if (!populating) {\n            // prevent recursion\n            populating = true;\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                Method readMethod = props[i].getReadMethod();\n                if (readMethod != null)\n                    readMethod.invoke(this, (Object[]) null);\n            }\n            populating = false;\n        }\n    }\n\n    public static Set<String> getBuiltInDatabaseTypes(String loadedFromJar) {\n        Set<String> databaseTypes = new TreeSet<String>();\n        JarInputStream jar = null;\n        try {\n            jar = new JarInputStream(new FileInputStream(loadedFromJar));\n            JarEntry entry;\n            while ((entry = jar.getNextJarEntry()) != null) {\n                String entryName = entry.getName();\n                int dotPropsIndex = entryName.indexOf(\".properties\");\n                if (dotPropsIndex != -1)\n                    databaseTypes.add(entryName.substring(0, dotPropsIndex));\n            }\n        } catch (IOException exc) {\n        } finally {\n            if (jar != null) {\n                try {\n                    jar.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n        return databaseTypes;\n    }\n\n    protected void dumpUsage(String errorMessage, boolean detailedDb) {\n        if (errorMessage != null) {\n            System.out.flush();\n            System.err.println(\"*** \" + errorMessage + \" ***\");\n        } else {\n            System.out.println(\"SchemaSpy generates an HTML representation of a database schema's relationships.\");\n        }\n        System.err.flush();\n        System.out.println();\n        if (!detailedDb) {\n            System.out.println(\"Usage:\");\n            System.out.println(\" java -jar \" + getLoadedFromJar() + \" [options]\");\n            System.out.println(\"   -t databaseType       type of database - defaults to ora\");\n            System.out.println(\"                           use -dbhelp for a list of built-in types\");\n            System.out.println(\"   -u user               connect to the database with this user id\");\n            System.out.println(\"   -s schema             defaults to the specified user\");\n            System.out.println(\"   -p password           defaults to no password\");\n            System.out.println(\"   -o outputDirectory    directory to place the generated output in\");\n            System.out.println(\"   -dp pathToDrivers     optional - looks for JDBC drivers here before looking\");\n            System.out.println(\"                           in driverPath in [databaseType].properties.\");\n            System.out.println(\"Go to http://schemaspy.sourceforge.net for a complete list/description\");\n            System.out.println(\" of additional parameters.\");\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"Built-in database types and their required connection parameters:\");\n            for (String type : getBuiltInDatabaseTypes(getLoadedFromJar())) {\n                new DbSpecificConfig(type).dumpUsage();\n            }\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"You can use your own database types by specifying the filespec of a .properties file with -t.\");\n            System.out.println(\"Grab one out of \" + getLoadedFromJar() + \" and modify it to suit your needs.\");\n            System.out.println();\n        }\n        System.out.println(\"Sample usage using the default database type (implied -t ora):\");\n        System.out.println(\" java -jar schemaSpy.jar -db mydb -s myschema -u devuser -p password -o output\");\n        System.out.println();\n        System.out.flush();\n    }\n\n    /**\n     * Get the value of the specified parameter.\n     * Used for properties that are common to most db's, but aren't required.\n     *\n     * @param paramName\n     * @return\n     */\n    public String getParam(String paramName) {\n        try {\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                PropertyDescriptor prop = props[i];\n                if (prop.getName().equalsIgnoreCase(paramName)) {\n                    Object result = prop.getReadMethod().invoke(this, (Object[]) null);\n                    return result == null ? null : result.toString();\n                }\n            }\n        } catch (Exception failed) {\n            failed.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * Return all of the configuration options as a List of Strings, with\n     * each parameter and its value as a separate element.\n     *\n     * @return\n     * @throws IOException\n     */\n    public List<String> asList() throws IOException {\n        List<String> params = new ArrayList<String>();\n        if (originalDbSpecificOptions != null) {\n            for (String key : originalDbSpecificOptions.keySet()) {\n                String value = originalDbSpecificOptions.get(key);\n                if (!key.startsWith(\"-\"))\n                    key = \"-\" + key;\n                params.add(key);\n                params.add(value);\n            }\n        }\n        if (isEncodeCommentsEnabled())\n            params.add(\"-ahic\");\n        if (isEvaluateAllEnabled())\n            params.add(\"-all\");\n        if (!isHtmlGenerationEnabled())\n            params.add(\"-nohtml\");\n        if (!isImpliedConstraintsEnabled())\n            params.add(\"-noimplied\");\n        if (!isLogoEnabled())\n            params.add(\"-nologo\");\n        if (isMeterEnabled())\n            params.add(\"-meter\");\n        if (!isNumRowsEnabled())\n            params.add(\"-norows\");\n        if (!isViewsEnabled())\n            params.add(\"-noviews\");\n        if (isRankDirBugEnabled())\n            params.add(\"-rankdirbug\");\n        if (isRailsEnabled())\n            params.add(\"-rails\");\n        if (isSingleSignOn())\n            params.add(\"-sso\");\n        if (isSchemaDisabled())\n            params.add(\"-noschema\");\n        String value = getDriverPath();\n        if (value != null) {\n            params.add(\"-dp\");\n            params.add(value);\n        }\n        params.add(\"-css\");\n        params.add(getCss());\n        params.add(\"-charset\");\n        params.add(getCharset());\n        params.add(\"-font\");\n        params.add(getFont());\n        params.add(\"-fontsize\");\n        params.add(String.valueOf(getFontSize()));\n        params.add(\"-t\");\n        params.add(getDbType());\n        // query to set renderer correctly\n        isHighQuality();\n        // query to set renderer correctly\n        isLowQuality();\n        // instead of -hq and/or -lq\n        params.add(\"-renderer\");\n        params.add(getRenderer());\n        value = getDescription();\n        if (value != null) {\n            params.add(\"-desc\");\n            params.add(value);\n        }\n        value = getPassword();\n        if (value != null && !isPromptForPasswordEnabled()) {\n            // note that we don't pass -pfp since child processes\n            // won't have a console\n            params.add(\"-p\");\n            params.add(value);\n        }\n        value = getCatalog();\n        if (value != null) {\n            params.add(\"-cat\");\n            params.add(value);\n        }\n        value = getSchema();\n        if (value != null) {\n            params.add(\"-s\");\n            params.add(value);\n        }\n        value = getUser();\n        if (value != null) {\n            params.add(\"-u\");\n            params.add(value);\n        }\n        value = getConnectionPropertiesFile();\n        if (value != null) {\n            params.add(\"-connprops\");\n            params.add(value);\n        } else {\n            Properties props = getConnectionProperties();\n            if (!props.isEmpty()) {\n                params.add(\"-connprops\");\n                StringBuilder buf = new StringBuilder();\n                for (Entry<Object, Object> entry : props.entrySet()) {\n                    buf.append(entry.getKey());\n                    buf.append(ESCAPED_EQUALS);\n                    buf.append(entry.getValue());\n                    buf.append(';');\n                }\n                params.add(buf.toString());\n            }\n        }\n        value = getDb();\n        if (value != null) {\n            params.add(\"-db\");\n            params.add(value);\n        }\n        value = getHost();\n        if (value != null) {\n            params.add(\"-host\");\n            params.add(value);\n        }\n        if (getPort() != null) {\n            params.add(\"-port\");\n            params.add(getPort().toString());\n        }\n        value = getServer();\n        if (value != null) {\n            params.add(\"-server\");\n            params.add(value);\n        }\n        value = getMeta();\n        if (value != null) {\n            params.add(\"-meta\");\n            params.add(value);\n        }\n        if (getGraphvizDir() != null) {\n            params.add(\"-gv\");\n            params.add(getGraphvizDir().toString());\n        }\n        params.add(\"-loglevel\");\n        params.add(getLogLevel().toString().toLowerCase());\n        params.add(\"-sqlFormatter\");\n        params.add(getSqlFormatter().getClass().getName());\n        params.add(\"-i\");\n        params.add(getTableInclusions().toString());\n        params.add(\"-I\");\n        params.add(getTableExclusions().toString());\n        params.add(\"-X\");\n        params.add(getColumnExclusions().toString());\n        params.add(\"-x\");\n        params.add(getIndirectColumnExclusions().toString());\n        params.add(\"-dbthreads\");\n        params.add(String.valueOf(getMaxDbThreads()));\n        params.add(\"-maxdet\");\n        params.add(String.valueOf(getMaxDetailedTables()));\n        params.add(\"-o\");\n        params.add(getOutputDir().toString());\n        return params;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/ConfigTest1.java",
		"test_prompt": "// ConfigTest1.java\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Config}.\n* It contains ten unit test cases for the {@link Config#isHtmlGenerationEnabled()} method.\n*/\nclass ConfigTest1 {"
	},
	{
		"original_code": "// Config.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\n\n/**\n * Configuration of a SchemaSpy run\n *\n * @author John Currier\n */\npublic class Config {\n\n    private static Config instance;\n\n    private final List<String> options;\n\n    private Map<String, String> dbSpecificOptions;\n\n    private Map<String, String> originalDbSpecificOptions;\n\n    private boolean helpRequired;\n\n    private boolean dbHelpRequired;\n\n    private File outputDir;\n\n    private File graphvizDir;\n\n    private String dbType;\n\n    private String catalog;\n\n    private String schema;\n\n    private List<String> schemas;\n\n    private String user;\n\n    private Boolean singleSignOn;\n\n    private Boolean noSchema;\n\n    private String password;\n\n    private Boolean promptForPassword;\n\n    private String db;\n\n    private String host;\n\n    private Integer port;\n\n    private String server;\n\n    private String meta;\n\n    private Pattern tableInclusions;\n\n    private Pattern tableExclusions;\n\n    private Pattern columnExclusions;\n\n    private Pattern indirectColumnExclusions;\n\n    private String userConnectionPropertiesFile;\n\n    private Properties userConnectionProperties;\n\n    private Integer maxDbThreads;\n\n    private Integer maxDetailedTables;\n\n    private String driverPath;\n\n    private String css;\n\n    private String charset;\n\n    private String font;\n\n    private Integer fontSize;\n\n    private String description;\n\n    private Properties dbProperties;\n\n    private String dbPropertiesLoadedFrom;\n\n    private Level logLevel;\n\n    private SqlFormatter sqlFormatter;\n\n    private String sqlFormatterClass;\n\n    private Boolean generateHtml;\n\n    private Boolean includeImpliedConstraints;\n\n    private Boolean logoEnabled;\n\n    private Boolean rankDirBugEnabled;\n\n    private Boolean encodeCommentsEnabled;\n\n    private Boolean numRowsEnabled;\n\n    private Boolean viewsEnabled;\n\n    private Boolean meterEnabled;\n\n    private Boolean railsEnabled;\n\n    private Boolean evaluteAll;\n\n    private Boolean highQuality;\n\n    private Boolean lowQuality;\n\n    // used in conjunction with evaluateAll\n    private String schemaSpec;\n\n    private boolean hasOrphans = false;\n\n    private boolean hasRoutines = false;\n\n    private boolean populating = false;\n\n    private List<String> columnDetails;\n\n    public static final String DOT_CHARSET = \"UTF-8\";\n\n    private static final String ESCAPED_EQUALS = \"\\\\=\";\n\n    // match everything\n    private static final String DEFAULT_TABLE_INCLUSION = \".*\";\n\n    // match nothing\n    private static final String DEFAULT_TABLE_EXCLUSION = \"\";\n\n    // match nothing\n    private static final String DEFAULT_COLUMN_EXCLUSION = \"[^.]\";\n\n    /**\n     * Default constructor. Intended for when you want to inject properties\n     * independently (i.e. not from a command line interface).\n     */\n    public Config() {\n        if (instance == null)\n            setInstance(this);\n        options = new ArrayList<String>();\n    }\n\n    /**\n     * Construct a configuration from an array of options (e.g. from a command\n     * line interface).\n     *\n     * @param options\n     */\n    public Config(String[] argv) {\n        setInstance(this);\n        options = fixupArgs(Arrays.asList(argv));\n        helpRequired = options.remove(\"-?\") || options.remove(\"/?\") || options.remove(\"?\") || options.remove(\"-h\") || options.remove(\"-help\") || options.remove(\"--help\");\n        dbHelpRequired = options.remove(\"-dbHelp\") || options.remove(\"-dbhelp\");\n    }\n\n    public static Config getInstance() {\n        if (instance == null)\n            instance = new Config();\n        return instance;\n    }\n\n    /**\n     * Sets the global instance.\n     *\n     * Useful for things like selecting a specific configuration in a UI.\n     *\n     * @param config\n     */\n    public static void setInstance(Config config) {\n        instance = config;\n    }\n\n    public void setHtmlGenerationEnabled(boolean generateHtml) {\n        this.generateHtml = generateHtml;\n    }\n\n    public boolean isHtmlGenerationEnabled() {\n        if (generateHtml == null)\n            generateHtml = !options.remove(\"-nohtml\");\n        return generateHtml;\n    }\n\n    public void setImpliedConstraintsEnabled(boolean includeImpliedConstraints) {\n        this.includeImpliedConstraints = includeImpliedConstraints;\n    }\n\n    public boolean isImpliedConstraintsEnabled() {\n        if (includeImpliedConstraints == null)\n            includeImpliedConstraints = !options.remove(\"-noimplied\");\n        return includeImpliedConstraints;\n    }\n\n    public void setOutputDir(String outputDirName) {\n        if (outputDirName.endsWith(\"\\\"\"))\n            outputDirName = outputDirName.substring(0, outputDirName.length() - 1);\n        setOutputDir(new File(outputDirName));\n    }\n\n    public void setOutputDir(File outputDir) {\n        this.outputDir = outputDir;\n    }\n\n    public File getOutputDir() {\n        if (outputDir == null) {\n            setOutputDir(pullRequiredParam(\"-o\"));\n        }\n        return outputDir;\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(String graphvizDir) {\n        if (graphvizDir.endsWith(\"\\\"\"))\n            graphvizDir = graphvizDir.substring(0, graphvizDir.length() - 1);\n        setGraphvizDir(new File(graphvizDir));\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(File graphvizDir) {\n        this.graphvizDir = graphvizDir;\n    }\n\n    /**\n     * Return the path to Graphviz (used to find the dot executable to run to\n     * generate ER diagrams).<p/>\n     *\n     * Returns {@link #getDefaultGraphvizPath()} if a specific Graphviz path\n     * was not specified.\n     *\n     * @return\n     */\n    public File getGraphvizDir() {\n        if (graphvizDir == null) {\n            String gv = pullParam(\"-gv\");\n            if (gv != null) {\n                setGraphvizDir(gv);\n            } else {\n                // expect to find Graphviz's bin directory on the PATH\n            }\n        }\n        return graphvizDir;\n    }\n\n    /**\n     * Meta files are XML-based files that provide additional metadata\n     * about the schema being evaluated.<p>\n     * <code>meta</code> is either the name of an individual XML file or\n     * the directory that contains meta files.<p>\n     * If a directory is specified then it is expected to contain files\n     * matching the pattern <code>[schema].meta.xml</code>.\n     * For databases that don't have schema substitute database for schema.\n     * @param meta\n     */\n    public void setMeta(String meta) {\n        this.meta = meta;\n    }\n\n    public String getMeta() {\n        if (meta == null)\n            meta = pullParam(\"-meta\");\n        return meta;\n    }\n\n    public void setDbType(String dbType) {\n        this.dbType = dbType;\n    }\n\n    public String getDbType() {\n        if (dbType == null) {\n            dbType = pullParam(\"-t\");\n            if (dbType == null)\n                dbType = \"ora\";\n        }\n        return dbType;\n    }\n\n    public void setDb(String db) {\n        this.db = db;\n    }\n\n    public String getDb() {\n        if (db == null)\n            db = pullParam(\"-db\");\n        return db;\n    }\n\n    public void setCatalog(String catalog) {\n        this.catalog = catalog;\n    }\n\n    public String getCatalog() {\n        if (catalog == null)\n            catalog = pullParam(\"-cat\");\n        return catalog;\n    }\n\n    public void setSchema(String schema) {\n        this.schema = schema;\n    }\n\n    public String getSchema() {\n        if (schema == null)\n            schema = pullParam(\"-s\");\n        return schema;\n    }\n\n    /**\n     * Some databases types (e.g. older versions of Informix) don't really\n     * have the concept of a schema but still return true from\n     * {@link DatabaseMetaData#supportsSchemasInTableDefinitions()}.\n     * This option lets you ignore that and treat all the tables\n     * as if they were in one flat namespace.\n     */\n    public boolean isSchemaDisabled() {\n        if (noSchema == null)\n            noSchema = options.remove(\"-noschema\");\n        return noSchema;\n    }\n\n    public void setHost(String host) {\n        this.host = host;\n    }\n\n    public String getHost() {\n        if (host == null)\n            host = pullParam(\"-host\");\n        return host;\n    }\n\n    public void setPort(Integer port) {\n        this.port = port;\n    }\n\n    public Integer getPort() {\n        if (port == null)\n            try {\n                port = Integer.valueOf(pullParam(\"-port\"));\n            } catch (Exception notSpecified) {\n            }\n        return port;\n    }\n\n    public void setServer(String server) {\n        this.server = server;\n    }\n\n    public String getServer() {\n        if (server == null) {\n            server = pullParam(\"-server\");\n        }\n        return server;\n    }\n\n    public void setUser(String user) {\n        this.user = user;\n    }\n\n    /**\n     * User used to connect to the database.\n     * Required unless single sign-on is enabled\n     * (see {@link #setSingleSignOn(boolean)}).\n     * @return\n     */\n    public String getUser() {\n        if (user == null) {\n            if (!isSingleSignOn())\n                user = pullRequiredParam(\"-u\");\n            else\n                user = pullParam(\"-u\");\n        }\n        return user;\n    }\n\n    /**\n     * By default a \"user\" (as specified with -u) is required.\n     * This option allows disabling of that requirement for\n     * single sign-on environments.\n     *\n     * @param enabled defaults to <code>false</code>\n     */\n    public void setSingleSignOn(boolean enabled) {\n        singleSignOn = enabled;\n    }\n\n    /**\n     * @see #setSingleSignOn(boolean)\n     */\n    public boolean isSingleSignOn() {\n        if (singleSignOn == null)\n            singleSignOn = options.remove(\"-sso\");\n        return singleSignOn;\n    }\n\n    /**\n     * Set the password used to connect to the database.\n     * @param password\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * @see #setPassword(String)\n     * @return\n     */\n    public String getPassword() {\n        if (password == null)\n            password = pullParam(\"-p\");\n        if (password == null && isPromptForPasswordEnabled())\n            password = new String(PasswordReader.getInstance().readPassword(\"Password: \"));\n        if (password == null) {\n            // if -pfp is enabled when analyzing multiple schemas then\n            // we don't want to send the password on the command line,\n            // so see if it was passed in the environment (not ideal, but safer)\n            password = System.getenv(\"schemaspy.pw\");\n        }\n        return password;\n    }\n\n    /**\n     * Set to <code>true</code> to prompt for the password\n     * @param promptForPassword\n     */\n    public void setPromptForPasswordEnabled(boolean promptForPassword) {\n        this.promptForPassword = promptForPassword;\n    }\n\n    /**\n     * @see #setPromptForPasswordEnabled(boolean)\n     * @return\n     */\n    public boolean isPromptForPasswordEnabled() {\n        if (promptForPassword == null) {\n            promptForPassword = options.remove(\"-pfp\");\n        }\n        return promptForPassword;\n    }\n\n    public void setMaxDetailedTabled(int maxDetailedTables) {\n        this.maxDetailedTables = new Integer(maxDetailedTables);\n    }\n\n    public int getMaxDetailedTables() {\n        if (maxDetailedTables == null) {\n            // default\n            int max = 300;\n            try {\n                max = Integer.parseInt(pullParam(\"-maxdet\"));\n            } catch (Exception notSpecified) {\n            }\n            maxDetailedTables = new Integer(max);\n        }\n        return maxDetailedTables.intValue();\n    }\n\n    public String getConnectionPropertiesFile() {\n        return userConnectionPropertiesFile;\n    }\n\n    /**\n     * Properties from this file (in key=value pair format) are passed to the\n     * database connection.<br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.\n     * @param propertiesFilename\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public void setConnectionPropertiesFile(String propertiesFilename) throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null)\n            userConnectionProperties = new Properties();\n        userConnectionProperties.load(new FileInputStream(propertiesFilename));\n        userConnectionPropertiesFile = propertiesFilename;\n    }\n\n    /**\n     * Returns a {@link Properties} populated either from the properties file specified\n     * by {@link #setConnectionPropertiesFile(String)}, the properties specified by\n     * {@link #setConnectionProperties(String)} or not populated.\n     * @return\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public Properties getConnectionProperties() throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null) {\n            String props = pullParam(\"-connprops\");\n            if (props != null) {\n                if (props.indexOf(ESCAPED_EQUALS) != -1) {\n                    setConnectionProperties(props);\n                } else {\n                    setConnectionPropertiesFile(props);\n                }\n            } else {\n                userConnectionProperties = new Properties();\n            }\n        }\n        return userConnectionProperties;\n    }\n\n    /**\n     * Specifies connection properties to use in the format:\n     * <code>key1\\=value1;key2\\=value2</code><br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.<p>\n     * This is an alternative form of passing connection properties than by file\n     * (see {@link #setConnectionPropertiesFile(String)})\n     *\n     * @param properties\n     */\n    public void setConnectionProperties(String properties) {\n        userConnectionProperties = new Properties();\n        StringTokenizer tokenizer = new StringTokenizer(properties, \";\");\n        while (tokenizer.hasMoreElements()) {\n            String pair = tokenizer.nextToken();\n            int index = pair.indexOf(ESCAPED_EQUALS);\n            if (index != -1) {\n                String key = pair.substring(0, index);\n                String value = pair.substring(index + ESCAPED_EQUALS.length());\n                userConnectionProperties.put(key, value);\n            }\n        }\n    }\n\n    public void setDriverPath(String driverPath) {\n        this.driverPath = driverPath;\n    }\n\n    public String getDriverPath() {\n        if (driverPath == null)\n            driverPath = pullParam(\"-dp\");\n        // was previously -cp:\n        if (driverPath == null)\n            driverPath = pullParam(\"-cp\");\n        return driverPath;\n    }\n\n    /**\n     * The filename of the cascading style sheet to use.\n     * Note that this file is parsed and used to determine characteristics\n     * of the generated diagrams, so it must contain specific settings that\n     * are documented within schemaSpy.css.<p>\n     *\n     * Defaults to <code>\"schemaSpy.css\"</code>.\n     *\n     * @param css\n     */\n    public void setCss(String css) {\n        this.css = css;\n    }\n\n    public String getCss() {\n        if (css == null) {\n            css = pullParam(\"-css\");\n            if (css == null)\n                css = \"schemaSpy.css\";\n        }\n        return css;\n    }\n\n    /**\n     * The font to use within diagrams.  Modify the .css to specify HTML fonts.\n     *\n     * @param font\n     */\n    public void setFont(String font) {\n        this.font = font;\n    }\n\n    /**\n     * @see #setFont(String)\n     */\n    public String getFont() {\n        if (font == null) {\n            font = pullParam(\"-font\");\n            if (font == null)\n                font = \"Helvetica\";\n        }\n        return font;\n    }\n\n    /**\n     * The font size to use within diagrams.  This is the size of the font used for\n     * 'large' (e.g. not 'compact') diagrams.<p>\n     *\n     * Modify the .css to specify HTML font sizes.<p>\n     *\n     * Defaults to 11.\n     *\n     * @param fontSize\n     */\n    public void setFontSize(int fontSize) {\n        this.fontSize = new Integer(fontSize);\n    }\n\n    /**\n     * @see #setFontSize(int)\n     * @return\n     */\n    public int getFontSize() {\n        if (fontSize == null) {\n            // default\n            int size = 11;\n            try {\n                size = Integer.parseInt(pullParam(\"-fontsize\"));\n            } catch (Exception notSpecified) {\n            }\n            fontSize = new Integer(size);\n        }\n        return fontSize.intValue();\n    }\n\n    /**\n     * The character set to use within HTML pages (defaults to <code>\"ISO-8859-1\"</code>).\n     *\n     * @param charset\n     */\n    public void setCharset(String charset) {\n        this.charset = charset;\n    }\n\n    /**\n     * @see #setCharset(String)\n     */\n    public String getCharset() {\n        if (charset == null) {\n            charset = pullParam(\"-charset\");\n            if (charset == null)\n                charset = \"ISO-8859-1\";\n        }\n        return charset;\n    }\n\n    /**\n     * Description of schema that gets display on main pages.\n     *\n     * @param description\n     */\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    /**\n     * @see #setDescription(String)\n     */\n    public String getDescription() {\n        if (description == null)\n            description = pullParam(\"-desc\");\n        return description;\n    }\n\n    /**\n     * Maximum number of threads to use when querying database metadata information.\n     *\n     * @param maxDbThreads\n     */\n    public void setMaxDbThreads(int maxDbThreads) {\n        this.maxDbThreads = new Integer(maxDbThreads);\n    }\n\n    /**\n     * @see #setMaxDbThreads(int)\n     * @throws InvalidConfigurationException if unable to load properties\n     */\n    public int getMaxDbThreads() throws InvalidConfigurationException {\n        if (maxDbThreads == null) {\n            Properties properties;\n            try {\n                properties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(\"Failed to load properties for \" + getDbType() + \": \" + exc).setParamName(\"-type\");\n            }\n            // not scientifically derived\n            final int defaultMax = 15;\n            int max = defaultMax;\n            String threads = properties.getProperty(\"dbThreads\");\n            if (threads == null)\n                threads = properties.getProperty(\"dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            threads = pullParam(\"-dbThreads\");\n            if (threads == null)\n                threads = pullParam(\"-dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            if (max < 0)\n                max = defaultMax;\n            else if (max == 0)\n                max = 1;\n            maxDbThreads = new Integer(max);\n        }\n        return maxDbThreads.intValue();\n    }\n\n    public boolean isLogoEnabled() {\n        if (logoEnabled == null)\n            logoEnabled = !options.remove(\"-nologo\");\n        return logoEnabled;\n    }\n\n    /**\n     * Don't use this unless absolutely necessary as it screws up the layout\n     *\n     * @param enabled\n     */\n    public void setRankDirBugEnabled(boolean enabled) {\n        rankDirBugEnabled = enabled;\n    }\n\n    /**\n     * @see #setRankDirBugEnabled(boolean)\n     */\n    public boolean isRankDirBugEnabled() {\n        if (rankDirBugEnabled == null)\n            rankDirBugEnabled = options.remove(\"-rankdirbug\");\n        return rankDirBugEnabled;\n    }\n\n    /**\n     * Look for Ruby on Rails-based naming conventions in\n     * relationships between logical foreign keys and primary keys.<p>\n     *\n     * Basically all tables have a primary key named <code>ID</code>.\n     * All tables are named plural names.\n     * The columns that logically reference that <code>ID</code> are the singular\n     * form of the table name suffixed with <code>_ID</code>.<p>\n     *\n     * @param enabled\n     */\n    public void setRailsEnabled(boolean enabled) {\n        railsEnabled = enabled;\n    }\n\n    /**\n     * @see #setRailsEnabled(boolean)\n     *\n     * @return\n     */\n    public boolean isRailsEnabled() {\n        if (railsEnabled == null)\n            railsEnabled = options.remove(\"-rails\");\n        return railsEnabled;\n    }\n\n    /**\n     * Allow Html In Comments - encode them unless otherwise specified\n     */\n    public void setEncodeCommentsEnabled(boolean enabled) {\n        encodeCommentsEnabled = enabled;\n    }\n\n    /**\n     * @see #setEncodeCommentsEnabled(boolean)\n     */\n    public boolean isEncodeCommentsEnabled() {\n        if (encodeCommentsEnabled == null)\n            encodeCommentsEnabled = !options.remove(\"-ahic\");\n        return encodeCommentsEnabled;\n    }\n\n    /**\n     * If enabled we'll attempt to query/render the number of rows that\n     * each table contains.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setNumRowsEnabled(boolean enabled) {\n        numRowsEnabled = enabled;\n    }\n\n    /**\n     * @see #setNumRowsEnabled(boolean)\n     * @return\n     */\n    public boolean isNumRowsEnabled() {\n        if (numRowsEnabled == null)\n            numRowsEnabled = !options.remove(\"-norows\");\n        return numRowsEnabled;\n    }\n\n    /**\n     * If enabled we'll include views in the analysis.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setViewsEnabled(boolean enabled) {\n        viewsEnabled = enabled;\n    }\n\n    /**\n     * @see #setViewsEnabled(boolean)\n     * @return\n     */\n    public boolean isViewsEnabled() {\n        if (viewsEnabled == null)\n            viewsEnabled = !options.remove(\"-noviews\");\n        return viewsEnabled;\n    }\n\n    /**\n     * Returns <code>true</code> if metering should be embedded in\n     * the generated pages.<p/>\n     * Defaults to <code>false</code> (disabled).\n     * @return\n     */\n    public boolean isMeterEnabled() {\n        if (meterEnabled == null)\n            meterEnabled = options.remove(\"-meter\");\n        return meterEnabled;\n    }\n\n    /**\n     * Set the columns to exclude from all relationship diagrams.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setColumnExclusions(String columnExclusions) {\n        this.columnExclusions = Pattern.compile(columnExclusions);\n    }\n\n    /**\n     * See {@link #setColumnExclusions(String)}\n     * @return\n     */\n    public Pattern getColumnExclusions() {\n        if (columnExclusions == null) {\n            String strExclusions = pullParam(\"-X\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.columnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            columnExclusions = Pattern.compile(strExclusions);\n        }\n        return columnExclusions;\n    }\n\n    /**\n     * Set the columns to exclude from relationship diagrams where the specified\n     * columns aren't directly referenced by the focal table.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setIndirectColumnExclusions(String fullColumnExclusions) {\n        indirectColumnExclusions = Pattern.compile(fullColumnExclusions);\n    }\n\n    /**\n     * @see #setIndirectColumnExclusions(String)\n     *\n     * @return\n     */\n    public Pattern getIndirectColumnExclusions() {\n        if (indirectColumnExclusions == null) {\n            String strExclusions = pullParam(\"-x\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.indirectColumnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            indirectColumnExclusions = Pattern.compile(strExclusions);\n        }\n        return indirectColumnExclusions;\n    }\n\n    /**\n     * Set the tables to include as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableInclusions(String tableInclusions) {\n        this.tableInclusions = Pattern.compile(tableInclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to include in the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableInclusions() {\n        if (tableInclusions == null) {\n            String strInclusions = pullParam(\"-i\");\n            if (strInclusions == null)\n                strInclusions = System.getenv(\"schemaspy.tableInclusions\");\n            if (strInclusions == null)\n                strInclusions = DEFAULT_TABLE_INCLUSION;\n            try {\n                tableInclusions = Pattern.compile(strInclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-i\");\n            }\n        }\n        return tableInclusions;\n    }\n\n    /**\n     * Set the tables to exclude as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableExclusions(String tableExclusions) {\n        this.tableExclusions = Pattern.compile(tableExclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to exclude from the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableExclusions() {\n        if (tableExclusions == null) {\n            String strExclusions = pullParam(\"-I\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.tableExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_TABLE_EXCLUSION;\n            try {\n                tableExclusions = Pattern.compile(strExclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-I\");\n            }\n        }\n        return tableExclusions;\n    }\n\n    /**\n     * @return\n     */\n    public List<String> getSchemas() {\n        if (schemas == null) {\n            String tmp = pullParam(\"-schemas\");\n            if (tmp == null)\n                tmp = pullParam(\"-schemata\");\n            if (tmp != null) {\n                schemas = new ArrayList<String>();\n                for (String name : tmp.split(\"[\\\\s,'\\\"]\")) {\n                    if (name.length() > 0)\n                        schemas.add(name);\n                }\n                if (schemas.isEmpty())\n                    schemas = null;\n            }\n        }\n        return schemas;\n    }\n\n    /**\n     * Set the name of the {@link SqlFormatter SQL formatter} class to use to\n     * format SQL into HTML.<p/>\n     * The implementation of the class must be made available to the class\n     * loader, typically by specifying the path to its jar with <em>-dp</em>\n     * ({@link #setDriverPath(String)}).\n     */\n    public void setSqlFormatter(String formatterClassName) {\n        sqlFormatterClass = formatterClassName;\n        sqlFormatter = null;\n    }\n\n    /**\n     * Set the {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.\n     */\n    public void setSqlFormatter(SqlFormatter sqlFormatter) {\n        this.sqlFormatter = sqlFormatter;\n        if (sqlFormatter != null)\n            sqlFormatterClass = sqlFormatter.getClass().getName();\n    }\n\n    /**\n     * Returns an implementation of {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.  The default implementation is {@link DefaultSqlFormatter}.\n     *\n     * @return\n     * @throws InvalidConfigurationException if unable to instantiate an instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SqlFormatter getSqlFormatter() throws InvalidConfigurationException {\n        if (sqlFormatter == null) {\n            if (sqlFormatterClass == null) {\n                sqlFormatterClass = pullParam(\"-sqlFormatter\");\n                if (sqlFormatterClass == null)\n                    sqlFormatterClass = DefaultSqlFormatter.class.getName();\n            }\n            try {\n                Class<SqlFormatter> clazz = (Class<SqlFormatter>) Class.forName(sqlFormatterClass);\n                sqlFormatter = clazz.newInstance();\n            } catch (Exception exc) {\n                throw new InvalidConfigurationException(\"Failed to initialize instance of SQL formatter: \", exc).setParamName(\"-sqlFormatter\");\n            }\n        }\n        return sqlFormatter;\n    }\n\n    /**\n     * Set the details to show on the columns page, where \"details\" are\n     * comma and/or space separated.\n     *\n     * Valid values:\n     * <ul>\n     * <li>id</li>\n     * <li>table</li>\n     * <li>column</li>\n     * <li>type</li>\n     * <li>size</li>\n     * <li>nulls</li>\n     * <li>auto</li>\n     * <li>default</li>\n     * <li>children</li>\n     * <li>parents</li>\n     * </ul>\n     *\n     * The default details are <code>\"table column type size nulls auto default\"</code>.\n     * Note that \"column\" is the initially displayed detail and must be included.\n     *\n     * @param columnDetails\n     */\n    public void setColumnDetails(String columnDetails) {\n        this.columnDetails = new ArrayList<String>();\n        if (columnDetails == null || columnDetails.length() == 0) {\n            // not specified, so use defaults\n            columnDetails = \"id table column type size nulls auto default\";\n        }\n        for (String detail : columnDetails.split(\"[\\\\s,'\\\"]\")) {\n            if (detail.length() > 0) {\n                this.columnDetails.add(detail.toLowerCase());\n            }\n        }\n        if (!this.columnDetails.contains(\"column\"))\n            throw new InvalidConfigurationException(\"'column' is a required column detail\");\n    }\n\n    public void setColumnDetails(List<String> columnDetails) {\n        String details = columnDetails == null ? \"[]\" : columnDetails.toString();\n        setColumnDetails(details.substring(1, details.length() - 1));\n    }\n\n    public List<String> getColumnDetails() {\n        if (columnDetails == null) {\n            setColumnDetails(pullParam(\"-columndetails\"));\n        }\n        return columnDetails;\n    }\n\n    public void setEvaluateAllEnabled(boolean enabled) {\n        evaluteAll = enabled;\n    }\n\n    public boolean isEvaluateAllEnabled() {\n        if (evaluteAll == null)\n            evaluteAll = options.remove(\"-all\");\n        return evaluteAll;\n    }\n\n    /**\n     * Returns true if we're evaluating a bunch of schemas in one go and\n     * at this point we're evaluating a specific schema.\n     *\n     * @return boolean\n     */\n    public boolean isOneOfMultipleSchemas() {\n        // set by MultipleSchemaAnalyzer\n        return Boolean.getBoolean(\"oneofmultipleschemas\");\n    }\n\n    /**\n     * When -all (evaluateAll) is specified then this is the regular\n     * expression that determines which schemas to evaluate.\n     *\n     * @param schemaSpec\n     */\n    public void setSchemaSpec(String schemaSpec) {\n        this.schemaSpec = schemaSpec;\n    }\n\n    public String getSchemaSpec() {\n        if (schemaSpec == null)\n            schemaSpec = pullParam(\"-schemaSpec\");\n        return schemaSpec;\n    }\n\n    /**\n     * Set the renderer to use for the -Tpng[:renderer[:formatter]] dot option as specified\n     * at <a href='http://www.graphviz.org/doc/info/command.html'>\n     * http://www.graphviz.org/doc/info/command.html</a>.<p>\n     * Note that the leading \":\" is required while :formatter is optional.<p>\n     * The default renderer is typically GD.<p>\n     * Note that using {@link #setHighQuality(boolean)} is the preferred approach\n     * over using this method.\n     */\n    public void setRenderer(String renderer) {\n        Dot.getInstance().setRenderer(renderer);\n    }\n\n    /**\n     * @see #setRenderer(String)\n     * @return\n     */\n    public String getRenderer() {\n        String renderer = pullParam(\"-renderer\");\n        if (renderer != null)\n            setRenderer(renderer);\n        return Dot.getInstance().getRenderer();\n    }\n\n    /**\n     * If <code>false</code> then generate output of \"lower quality\"\n     * than the default.\n     * Note that the default is intended to be \"higher quality\",\n     * but various installations of Graphviz may have have different abilities.\n     * That is, some might not have the \"lower quality\" libraries and others might\n     * not have the \"higher quality\" libraries.<p>\n     * Higher quality output takes longer to generate and results in significantly\n     * larger image files (which take longer to download / display), but it generally\n     * looks better.\n     */\n    public void setHighQuality(boolean highQuality) {\n        this.highQuality = highQuality;\n        lowQuality = !highQuality;\n        Dot.getInstance().setHighQuality(highQuality);\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isHighQuality() {\n        if (highQuality == null) {\n            highQuality = options.remove(\"-hq\");\n            if (highQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(highQuality);\n            }\n        }\n        highQuality = Dot.getInstance().isHighQuality();\n        return highQuality;\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isLowQuality() {\n        if (lowQuality == null) {\n            lowQuality = options.remove(\"-lq\");\n            if (lowQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(!lowQuality);\n            }\n        }\n        lowQuality = !Dot.getInstance().isHighQuality();\n        return lowQuality;\n    }\n\n    /**\n     * Set the level of logging to perform.<p/>\n     * The levels in descending order are:\n     * <ul>\n     *  <li><code>severe</code> (highest - least detail)\n     *  <li><code>warning</code> (default)\n     *  <li><code>info</code>\n     *  <li><code>config</code>\n     *  <li><code>fine</code>\n     *  <li><code>finer</code>\n     *  <li><code>finest</code>  (lowest - most detail)\n     * </ul>\n     *\n     * @param logLevel\n     */\n    public void setLogLevel(String logLevel) {\n        if (logLevel == null) {\n            this.logLevel = Level.WARNING;\n            return;\n        }\n        Map<String, Level> levels = new LinkedHashMap<String, Level>();\n        levels.put(\"severe\", Level.SEVERE);\n        levels.put(\"warning\", Level.WARNING);\n        levels.put(\"info\", Level.INFO);\n        levels.put(\"config\", Level.CONFIG);\n        levels.put(\"fine\", Level.FINE);\n        levels.put(\"finer\", Level.FINER);\n        levels.put(\"finest\", Level.FINEST);\n        this.logLevel = levels.get(logLevel.toLowerCase());\n        if (this.logLevel == null) {\n            throw new InvalidConfigurationException(\"Invalid logLevel: '\" + logLevel + \"'. Must be one of: \" + levels.keySet());\n        }\n    }\n\n    /**\n     * Returns the level of logging to perform.\n     * See {@link #setLogLevel(String)}.\n     *\n     * @return\n     */\n    public Level getLogLevel() {\n        if (logLevel == null) {\n            setLogLevel(pullParam(\"-loglevel\"));\n        }\n        return logLevel;\n    }\n\n    /**\n     * Returns <code>true</code> if the options indicate that the user wants\n     * to see some help information.\n     *\n     * @return\n     */\n    public boolean isHelpRequired() {\n        return helpRequired;\n    }\n\n    public boolean isDbHelpRequired() {\n        return dbHelpRequired;\n    }\n\n    /**\n     * Returns the jar that we were loaded from\n     *\n     * @return\n     */\n    public static String getLoadedFromJar() {\n        String classpath = System.getProperty(\"java.class.path\");\n        return new StringTokenizer(classpath, File.pathSeparator).nextToken();\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasOrphans(boolean hasOrphans) {\n        this.hasOrphans = hasOrphans;\n    }\n\n    /**\n     * @see #setHasOrphans()\n     *\n     * @return\n     */\n    public boolean hasOrphans() {\n        return hasOrphans;\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasRoutines(boolean hasRoutines) {\n        this.hasRoutines = hasRoutines;\n    }\n\n    /**\n     * @see #setHasRoutines()\n     *\n     * @return\n     */\n    public boolean hasRoutines() {\n        return hasRoutines;\n    }\n\n    /**\n     * Returns the database properties to use.\n     * These should be determined by calling {@link #determineDbProperties(String)}.\n     * @return\n     * @throws InvalidConfigurationException\n     */\n    public Properties getDbProperties() throws InvalidConfigurationException {\n        if (dbProperties == null) {\n            try {\n                dbProperties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(exc);\n            }\n        }\n        return dbProperties;\n    }\n\n    /**\n     * Determines the database properties associated with the specified type.\n     * A call to {@link #setDbProperties(Properties)} is expected after determining\n     * the complete set of properties.\n     *\n     * @param type\n     * @return\n     * @throws IOException\n     * @throws InvalidConfigurationException if db properties are incorrectly formed\n     */\n    public Properties determineDbProperties(String type) throws IOException, InvalidConfigurationException {\n        ResourceBundle bundle = null;\n        try {\n            File propertiesFile = new File(type);\n            bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n            dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n        } catch (FileNotFoundException notFoundOnFilesystemWithoutExtension) {\n            try {\n                File propertiesFile = new File(type + \".properties\");\n                bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n                dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n            } catch (FileNotFoundException notFoundOnFilesystemWithExtensionTackedOn) {\n                try {\n                    bundle = ResourceBundle.getBundle(type);\n                    dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]\" + File.separator + type + \".properties\";\n                } catch (Exception notInJarWithoutPath) {\n                    try {\n                        String path = TableOrderer.class.getPackage().getName() + \".dbTypes.\" + type;\n                        path = path.replace('.', '/');\n                        bundle = ResourceBundle.getBundle(path);\n                        dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]/\" + path + \".properties\";\n                    } catch (Exception notInJar) {\n                        notInJar.printStackTrace();\n                        notFoundOnFilesystemWithExtensionTackedOn.printStackTrace();\n                        throw notFoundOnFilesystemWithoutExtension;\n                    }\n                }\n            }\n        }\n        Properties props = asProperties(bundle);\n        bundle = null;\n        // keep original thru recursion\n        String saveLoadedFrom = dbPropertiesLoadedFrom;\n        // bring in key/values pointed to by the include directive\n        // example: include.1=mysql::selectRowCountSql\n        for (int i = 1; true; ++i) {\n            String include = (String) props.remove(\"include.\" + i);\n            if (include == null)\n                break;\n            int separator = include.indexOf(\"::\");\n            if (separator == -1)\n                throw new InvalidConfigurationException(\"include directive in \" + dbPropertiesLoadedFrom + \" must have '::' between dbType and key\");\n            String refdType = include.substring(0, separator).trim();\n            String refdKey = include.substring(separator + 2).trim();\n            // recursively resolve the ref'd properties file and the ref'd key\n            Properties refdProps = determineDbProperties(refdType);\n            props.put(refdKey, refdProps.getProperty(refdKey));\n        }\n        // bring in base properties files pointed to by the extends directive\n        String baseDbType = (String) props.remove(\"extends\");\n        if (baseDbType != null) {\n            baseDbType = baseDbType.trim();\n            Properties baseProps = determineDbProperties(baseDbType);\n            // overlay our properties on top of the base's\n            baseProps.putAll(props);\n            props = baseProps;\n        }\n        // done with this level of recursion...restore original\n        dbPropertiesLoadedFrom = saveLoadedFrom;\n        // this won't be correct until the final recursion exits\n        dbProperties = props;\n        return props;\n    }\n\n    protected String getDbPropertiesLoadedFrom() throws IOException {\n        if (dbPropertiesLoadedFrom == null)\n            determineDbProperties(getDbType());\n        return dbPropertiesLoadedFrom;\n    }\n\n    public List<String> getRemainingParameters() {\n        try {\n            populate();\n        } catch (IllegalArgumentException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (IllegalAccessException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (InvocationTargetException exc) {\n            if (exc.getCause() instanceof InvalidConfigurationException)\n                throw (InvalidConfigurationException) exc.getCause();\n            throw new InvalidConfigurationException(exc.getCause());\n        } catch (IntrospectionException exc) {\n            throw new InvalidConfigurationException(exc);\n        }\n        return options;\n    }\n\n    /**\n     * Options that are specific to a type of database.  E.g. things like <code>host</code>,\n     * <code>port</code> or <code>db</code>, but <b>don't</b> have a setter in this class.\n     *\n     * @param dbSpecificOptions\n     */\n    public void setDbSpecificOptions(Map<String, String> dbSpecificOptions) {\n        this.dbSpecificOptions = dbSpecificOptions;\n        originalDbSpecificOptions = new HashMap<String, String>(dbSpecificOptions);\n    }\n\n    public Map<String, String> getDbSpecificOptions() {\n        if (dbSpecificOptions == null)\n            dbSpecificOptions = new HashMap<String, String>();\n        return dbSpecificOptions;\n    }\n\n    /**\n     * Returns a {@link Properties} populated with the contents of <code>bundle</code>\n     *\n     * @param bundle ResourceBundle\n     * @return Properties\n     */\n    public static Properties asProperties(ResourceBundle bundle) {\n        Properties props = new Properties();\n        Enumeration<String> iter = bundle.getKeys();\n        while (iter.hasMoreElements()) {\n            String key = iter.nextElement();\n            props.put(key, bundle.getObject(key));\n        }\n        return props;\n    }\n\n    /**\n     * 'Pull' the specified parameter from the collection of options. Returns\n     * null if the parameter isn't in the list and removes it if it is.\n     *\n     * @param paramId\n     * @return\n     */\n    private String pullParam(String paramId) {\n        return pullParam(paramId, false, false);\n    }\n\n    private String pullRequiredParam(String paramId) {\n        return pullParam(paramId, true, false);\n    }\n\n    /**\n     * @param paramId\n     * @param required\n     * @param dbTypeSpecific\n     * @return\n     * @throws MissingRequiredParameterException\n     */\n    private String pullParam(String paramId, boolean required, boolean dbTypeSpecific) throws MissingRequiredParameterException {\n        int paramIndex = options.indexOf(paramId);\n        if (paramIndex < 0) {\n            if (required)\n                throw new MissingRequiredParameterException(paramId, dbTypeSpecific);\n            return null;\n        }\n        options.remove(paramIndex);\n        String param = options.get(paramIndex).toString();\n        options.remove(paramIndex);\n        return param;\n    }\n\n    /**\n     * Thrown to indicate that a required parameter is missing\n     */\n    public static class MissingRequiredParameterException extends RuntimeException {\n\n        private static final long serialVersionUID = 1L;\n\n        private final boolean dbTypeSpecific;\n\n        public MissingRequiredParameterException(String paramId, boolean dbTypeSpecific) {\n            this(paramId, null, dbTypeSpecific);\n        }\n\n        public MissingRequiredParameterException(String paramId, String description, boolean dbTypeSpecific) {\n            super(\"Required parameter '\" + paramId + \"' \" + (description == null ? \"\" : \"(\" + description + \") \") + \"was not specified.\" + (dbTypeSpecific ? \"  It is required for this database type.\" : \"\"));\n            this.dbTypeSpecific = dbTypeSpecific;\n        }\n\n        public boolean isDbTypeSpecific() {\n            return dbTypeSpecific;\n        }\n    }\n\n    /**\n     * Allow an equal sign in args...like \"-o=foo.bar\". Useful for things like\n     * Ant and Maven.\n     *\n     * @param args\n     *            List\n     * @return List\n     */\n    protected List<String> fixupArgs(List<String> args) {\n        List<String> expandedArgs = new ArrayList<String>();\n        for (String arg : args) {\n            int indexOfEquals = arg.indexOf('=');\n            if (indexOfEquals != -1 && indexOfEquals - 1 != arg.indexOf(ESCAPED_EQUALS)) {\n                expandedArgs.add(arg.substring(0, indexOfEquals));\n                expandedArgs.add(arg.substring(indexOfEquals + 1));\n            } else {\n                expandedArgs.add(arg);\n            }\n        }\n        // some OSes/JVMs do filename expansion with runtime.exec() and some don't,\n        // so MultipleSchemaAnalyzer has to surround params with double quotes...\n        // strip them here for the OSes/JVMs that don't do anything with the params\n        List<String> unquotedArgs = new ArrayList<String>();\n        for (String arg : expandedArgs) {\n            if (// \".*\" becomes .*\n            arg.startsWith(\"\\\"\") && arg.endsWith(\"\\\"\"))\n                arg = arg.substring(1, arg.length() - 1);\n            unquotedArgs.add(arg);\n        }\n        return unquotedArgs;\n    }\n\n    /**\n     * Call all the getters to populate all the lazy initialized stuff.\n     *\n     * @throws InvocationTargetException\n     * @throws IllegalAccessException\n     * @throws IllegalArgumentException\n     * @throws IntrospectionException\n     */\n    private void populate() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IntrospectionException {\n        if (!populating) {\n            // prevent recursion\n            populating = true;\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                Method readMethod = props[i].getReadMethod();\n                if (readMethod != null)\n                    readMethod.invoke(this, (Object[]) null);\n            }\n            populating = false;\n        }\n    }\n\n    public static Set<String> getBuiltInDatabaseTypes(String loadedFromJar) {\n        Set<String> databaseTypes = new TreeSet<String>();\n        JarInputStream jar = null;\n        try {\n            jar = new JarInputStream(new FileInputStream(loadedFromJar));\n            JarEntry entry;\n            while ((entry = jar.getNextJarEntry()) != null) {\n                String entryName = entry.getName();\n                int dotPropsIndex = entryName.indexOf(\".properties\");\n                if (dotPropsIndex != -1)\n                    databaseTypes.add(entryName.substring(0, dotPropsIndex));\n            }\n        } catch (IOException exc) {\n        } finally {\n            if (jar != null) {\n                try {\n                    jar.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n        return databaseTypes;\n    }\n\n    protected void dumpUsage(String errorMessage, boolean detailedDb) {\n        if (errorMessage != null) {\n            System.out.flush();\n            System.err.println(\"*** \" + errorMessage + \" ***\");\n        } else {\n            System.out.println(\"SchemaSpy generates an HTML representation of a database schema's relationships.\");\n        }\n        System.err.flush();\n        System.out.println();\n        if (!detailedDb) {\n            System.out.println(\"Usage:\");\n            System.out.println(\" java -jar \" + getLoadedFromJar() + \" [options]\");\n            System.out.println(\"   -t databaseType       type of database - defaults to ora\");\n            System.out.println(\"                           use -dbhelp for a list of built-in types\");\n            System.out.println(\"   -u user               connect to the database with this user id\");\n            System.out.println(\"   -s schema             defaults to the specified user\");\n            System.out.println(\"   -p password           defaults to no password\");\n            System.out.println(\"   -o outputDirectory    directory to place the generated output in\");\n            System.out.println(\"   -dp pathToDrivers     optional - looks for JDBC drivers here before looking\");\n            System.out.println(\"                           in driverPath in [databaseType].properties.\");\n            System.out.println(\"Go to http://schemaspy.sourceforge.net for a complete list/description\");\n            System.out.println(\" of additional parameters.\");\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"Built-in database types and their required connection parameters:\");\n            for (String type : getBuiltInDatabaseTypes(getLoadedFromJar())) {\n                new DbSpecificConfig(type).dumpUsage();\n            }\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"You can use your own database types by specifying the filespec of a .properties file with -t.\");\n            System.out.println(\"Grab one out of \" + getLoadedFromJar() + \" and modify it to suit your needs.\");\n            System.out.println();\n        }\n        System.out.println(\"Sample usage using the default database type (implied -t ora):\");\n        System.out.println(\" java -jar schemaSpy.jar -db mydb -s myschema -u devuser -p password -o output\");\n        System.out.println();\n        System.out.flush();\n    }\n\n    /**\n     * Get the value of the specified parameter.\n     * Used for properties that are common to most db's, but aren't required.\n     *\n     * @param paramName\n     * @return\n     */\n    public String getParam(String paramName) {\n        try {\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                PropertyDescriptor prop = props[i];\n                if (prop.getName().equalsIgnoreCase(paramName)) {\n                    Object result = prop.getReadMethod().invoke(this, (Object[]) null);\n                    return result == null ? null : result.toString();\n                }\n            }\n        } catch (Exception failed) {\n            failed.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * Return all of the configuration options as a List of Strings, with\n     * each parameter and its value as a separate element.\n     *\n     * @return\n     * @throws IOException\n     */\n    public List<String> asList() throws IOException {\n        List<String> params = new ArrayList<String>();\n        if (originalDbSpecificOptions != null) {\n            for (String key : originalDbSpecificOptions.keySet()) {\n                String value = originalDbSpecificOptions.get(key);\n                if (!key.startsWith(\"-\"))\n                    key = \"-\" + key;\n                params.add(key);\n                params.add(value);\n            }\n        }\n        if (isEncodeCommentsEnabled())\n            params.add(\"-ahic\");\n        if (isEvaluateAllEnabled())\n            params.add(\"-all\");\n        if (!isHtmlGenerationEnabled())\n            params.add(\"-nohtml\");\n        if (!isImpliedConstraintsEnabled())\n            params.add(\"-noimplied\");\n        if (!isLogoEnabled())\n            params.add(\"-nologo\");\n        if (isMeterEnabled())\n            params.add(\"-meter\");\n        if (!isNumRowsEnabled())\n            params.add(\"-norows\");\n        if (!isViewsEnabled())\n            params.add(\"-noviews\");\n        if (isRankDirBugEnabled())\n            params.add(\"-rankdirbug\");\n        if (isRailsEnabled())\n            params.add(\"-rails\");\n        if (isSingleSignOn())\n            params.add(\"-sso\");\n        if (isSchemaDisabled())\n            params.add(\"-noschema\");\n        String value = getDriverPath();\n        if (value != null) {\n            params.add(\"-dp\");\n            params.add(value);\n        }\n        params.add(\"-css\");\n        params.add(getCss());\n        params.add(\"-charset\");\n        params.add(getCharset());\n        params.add(\"-font\");\n        params.add(getFont());\n        params.add(\"-fontsize\");\n        params.add(String.valueOf(getFontSize()));\n        params.add(\"-t\");\n        params.add(getDbType());\n        // query to set renderer correctly\n        isHighQuality();\n        // query to set renderer correctly\n        isLowQuality();\n        // instead of -hq and/or -lq\n        params.add(\"-renderer\");\n        params.add(getRenderer());\n        value = getDescription();\n        if (value != null) {\n            params.add(\"-desc\");\n            params.add(value);\n        }\n        value = getPassword();\n        if (value != null && !isPromptForPasswordEnabled()) {\n            // note that we don't pass -pfp since child processes\n            // won't have a console\n            params.add(\"-p\");\n            params.add(value);\n        }\n        value = getCatalog();\n        if (value != null) {\n            params.add(\"-cat\");\n            params.add(value);\n        }\n        value = getSchema();\n        if (value != null) {\n            params.add(\"-s\");\n            params.add(value);\n        }\n        value = getUser();\n        if (value != null) {\n            params.add(\"-u\");\n            params.add(value);\n        }\n        value = getConnectionPropertiesFile();\n        if (value != null) {\n            params.add(\"-connprops\");\n            params.add(value);\n        } else {\n            Properties props = getConnectionProperties();\n            if (!props.isEmpty()) {\n                params.add(\"-connprops\");\n                StringBuilder buf = new StringBuilder();\n                for (Entry<Object, Object> entry : props.entrySet()) {\n                    buf.append(entry.getKey());\n                    buf.append(ESCAPED_EQUALS);\n                    buf.append(entry.getValue());\n                    buf.append(';');\n                }\n                params.add(buf.toString());\n            }\n        }\n        value = getDb();\n        if (value != null) {\n            params.add(\"-db\");\n            params.add(value);\n        }\n        value = getHost();\n        if (value != null) {\n            params.add(\"-host\");\n            params.add(value);\n        }\n        if (getPort() != null) {\n            params.add(\"-port\");\n            params.add(getPort().toString());\n        }\n        value = getServer();\n        if (value != null) {\n            params.add(\"-server\");\n            params.add(value);\n        }\n        value = getMeta();\n        if (value != null) {\n            params.add(\"-meta\");\n            params.add(value);\n        }\n        if (getGraphvizDir() != null) {\n            params.add(\"-gv\");\n            params.add(getGraphvizDir().toString());\n        }\n        params.add(\"-loglevel\");\n        params.add(getLogLevel().toString().toLowerCase());\n        params.add(\"-sqlFormatter\");\n        params.add(getSqlFormatter().getClass().getName());\n        params.add(\"-i\");\n        params.add(getTableInclusions().toString());\n        params.add(\"-I\");\n        params.add(getTableExclusions().toString());\n        params.add(\"-X\");\n        params.add(getColumnExclusions().toString());\n        params.add(\"-x\");\n        params.add(getIndirectColumnExclusions().toString());\n        params.add(\"-dbthreads\");\n        params.add(String.valueOf(getMaxDbThreads()));\n        params.add(\"-maxdet\");\n        params.add(String.valueOf(getMaxDetailedTables()));\n        params.add(\"-o\");\n        params.add(getOutputDir().toString());\n        return params;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/ConfigTest2.java",
		"test_prompt": "// ConfigTest2.java\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Config}.\n* It contains ten unit test cases for the {@link Config#isImpliedConstraintsEnabled()} method.\n*/\nclass ConfigTest2 {"
	},
	{
		"original_code": "// Config.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\n\n/**\n * Configuration of a SchemaSpy run\n *\n * @author John Currier\n */\npublic class Config {\n\n    private static Config instance;\n\n    private final List<String> options;\n\n    private Map<String, String> dbSpecificOptions;\n\n    private Map<String, String> originalDbSpecificOptions;\n\n    private boolean helpRequired;\n\n    private boolean dbHelpRequired;\n\n    private File outputDir;\n\n    private File graphvizDir;\n\n    private String dbType;\n\n    private String catalog;\n\n    private String schema;\n\n    private List<String> schemas;\n\n    private String user;\n\n    private Boolean singleSignOn;\n\n    private Boolean noSchema;\n\n    private String password;\n\n    private Boolean promptForPassword;\n\n    private String db;\n\n    private String host;\n\n    private Integer port;\n\n    private String server;\n\n    private String meta;\n\n    private Pattern tableInclusions;\n\n    private Pattern tableExclusions;\n\n    private Pattern columnExclusions;\n\n    private Pattern indirectColumnExclusions;\n\n    private String userConnectionPropertiesFile;\n\n    private Properties userConnectionProperties;\n\n    private Integer maxDbThreads;\n\n    private Integer maxDetailedTables;\n\n    private String driverPath;\n\n    private String css;\n\n    private String charset;\n\n    private String font;\n\n    private Integer fontSize;\n\n    private String description;\n\n    private Properties dbProperties;\n\n    private String dbPropertiesLoadedFrom;\n\n    private Level logLevel;\n\n    private SqlFormatter sqlFormatter;\n\n    private String sqlFormatterClass;\n\n    private Boolean generateHtml;\n\n    private Boolean includeImpliedConstraints;\n\n    private Boolean logoEnabled;\n\n    private Boolean rankDirBugEnabled;\n\n    private Boolean encodeCommentsEnabled;\n\n    private Boolean numRowsEnabled;\n\n    private Boolean viewsEnabled;\n\n    private Boolean meterEnabled;\n\n    private Boolean railsEnabled;\n\n    private Boolean evaluteAll;\n\n    private Boolean highQuality;\n\n    private Boolean lowQuality;\n\n    // used in conjunction with evaluateAll\n    private String schemaSpec;\n\n    private boolean hasOrphans = false;\n\n    private boolean hasRoutines = false;\n\n    private boolean populating = false;\n\n    private List<String> columnDetails;\n\n    public static final String DOT_CHARSET = \"UTF-8\";\n\n    private static final String ESCAPED_EQUALS = \"\\\\=\";\n\n    // match everything\n    private static final String DEFAULT_TABLE_INCLUSION = \".*\";\n\n    // match nothing\n    private static final String DEFAULT_TABLE_EXCLUSION = \"\";\n\n    // match nothing\n    private static final String DEFAULT_COLUMN_EXCLUSION = \"[^.]\";\n\n    /**\n     * Default constructor. Intended for when you want to inject properties\n     * independently (i.e. not from a command line interface).\n     */\n    public Config() {\n        if (instance == null)\n            setInstance(this);\n        options = new ArrayList<String>();\n    }\n\n    /**\n     * Construct a configuration from an array of options (e.g. from a command\n     * line interface).\n     *\n     * @param options\n     */\n    public Config(String[] argv) {\n        setInstance(this);\n        options = fixupArgs(Arrays.asList(argv));\n        helpRequired = options.remove(\"-?\") || options.remove(\"/?\") || options.remove(\"?\") || options.remove(\"-h\") || options.remove(\"-help\") || options.remove(\"--help\");\n        dbHelpRequired = options.remove(\"-dbHelp\") || options.remove(\"-dbhelp\");\n    }\n\n    public static Config getInstance() {\n        if (instance == null)\n            instance = new Config();\n        return instance;\n    }\n\n    /**\n     * Sets the global instance.\n     *\n     * Useful for things like selecting a specific configuration in a UI.\n     *\n     * @param config\n     */\n    public static void setInstance(Config config) {\n        instance = config;\n    }\n\n    public void setHtmlGenerationEnabled(boolean generateHtml) {\n        this.generateHtml = generateHtml;\n    }\n\n    public boolean isHtmlGenerationEnabled() {\n        if (generateHtml == null)\n            generateHtml = !options.remove(\"-nohtml\");\n        return generateHtml;\n    }\n\n    public void setImpliedConstraintsEnabled(boolean includeImpliedConstraints) {\n        this.includeImpliedConstraints = includeImpliedConstraints;\n    }\n\n    public boolean isImpliedConstraintsEnabled() {\n        if (includeImpliedConstraints == null)\n            includeImpliedConstraints = !options.remove(\"-noimplied\");\n        return includeImpliedConstraints;\n    }\n\n    public void setOutputDir(String outputDirName) {\n        if (outputDirName.endsWith(\"\\\"\"))\n            outputDirName = outputDirName.substring(0, outputDirName.length() - 1);\n        setOutputDir(new File(outputDirName));\n    }\n\n    public void setOutputDir(File outputDir) {\n        this.outputDir = outputDir;\n    }\n\n    public File getOutputDir() {\n        if (outputDir == null) {\n            setOutputDir(pullRequiredParam(\"-o\"));\n        }\n        return outputDir;\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(String graphvizDir) {\n        if (graphvizDir.endsWith(\"\\\"\"))\n            graphvizDir = graphvizDir.substring(0, graphvizDir.length() - 1);\n        setGraphvizDir(new File(graphvizDir));\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(File graphvizDir) {\n        this.graphvizDir = graphvizDir;\n    }\n\n    /**\n     * Return the path to Graphviz (used to find the dot executable to run to\n     * generate ER diagrams).<p/>\n     *\n     * Returns {@link #getDefaultGraphvizPath()} if a specific Graphviz path\n     * was not specified.\n     *\n     * @return\n     */\n    public File getGraphvizDir() {\n        if (graphvizDir == null) {\n            String gv = pullParam(\"-gv\");\n            if (gv != null) {\n                setGraphvizDir(gv);\n            } else {\n                // expect to find Graphviz's bin directory on the PATH\n            }\n        }\n        return graphvizDir;\n    }\n\n    /**\n     * Meta files are XML-based files that provide additional metadata\n     * about the schema being evaluated.<p>\n     * <code>meta</code> is either the name of an individual XML file or\n     * the directory that contains meta files.<p>\n     * If a directory is specified then it is expected to contain files\n     * matching the pattern <code>[schema].meta.xml</code>.\n     * For databases that don't have schema substitute database for schema.\n     * @param meta\n     */\n    public void setMeta(String meta) {\n        this.meta = meta;\n    }\n\n    public String getMeta() {\n        if (meta == null)\n            meta = pullParam(\"-meta\");\n        return meta;\n    }\n\n    public void setDbType(String dbType) {\n        this.dbType = dbType;\n    }\n\n    public String getDbType() {\n        if (dbType == null) {\n            dbType = pullParam(\"-t\");\n            if (dbType == null)\n                dbType = \"ora\";\n        }\n        return dbType;\n    }\n\n    public void setDb(String db) {\n        this.db = db;\n    }\n\n    public String getDb() {\n        if (db == null)\n            db = pullParam(\"-db\");\n        return db;\n    }\n\n    public void setCatalog(String catalog) {\n        this.catalog = catalog;\n    }\n\n    public String getCatalog() {\n        if (catalog == null)\n            catalog = pullParam(\"-cat\");\n        return catalog;\n    }\n\n    public void setSchema(String schema) {\n        this.schema = schema;\n    }\n\n    public String getSchema() {\n        if (schema == null)\n            schema = pullParam(\"-s\");\n        return schema;\n    }\n\n    /**\n     * Some databases types (e.g. older versions of Informix) don't really\n     * have the concept of a schema but still return true from\n     * {@link DatabaseMetaData#supportsSchemasInTableDefinitions()}.\n     * This option lets you ignore that and treat all the tables\n     * as if they were in one flat namespace.\n     */\n    public boolean isSchemaDisabled() {\n        if (noSchema == null)\n            noSchema = options.remove(\"-noschema\");\n        return noSchema;\n    }\n\n    public void setHost(String host) {\n        this.host = host;\n    }\n\n    public String getHost() {\n        if (host == null)\n            host = pullParam(\"-host\");\n        return host;\n    }\n\n    public void setPort(Integer port) {\n        this.port = port;\n    }\n\n    public Integer getPort() {\n        if (port == null)\n            try {\n                port = Integer.valueOf(pullParam(\"-port\"));\n            } catch (Exception notSpecified) {\n            }\n        return port;\n    }\n\n    public void setServer(String server) {\n        this.server = server;\n    }\n\n    public String getServer() {\n        if (server == null) {\n            server = pullParam(\"-server\");\n        }\n        return server;\n    }\n\n    public void setUser(String user) {\n        this.user = user;\n    }\n\n    /**\n     * User used to connect to the database.\n     * Required unless single sign-on is enabled\n     * (see {@link #setSingleSignOn(boolean)}).\n     * @return\n     */\n    public String getUser() {\n        if (user == null) {\n            if (!isSingleSignOn())\n                user = pullRequiredParam(\"-u\");\n            else\n                user = pullParam(\"-u\");\n        }\n        return user;\n    }\n\n    /**\n     * By default a \"user\" (as specified with -u) is required.\n     * This option allows disabling of that requirement for\n     * single sign-on environments.\n     *\n     * @param enabled defaults to <code>false</code>\n     */\n    public void setSingleSignOn(boolean enabled) {\n        singleSignOn = enabled;\n    }\n\n    /**\n     * @see #setSingleSignOn(boolean)\n     */\n    public boolean isSingleSignOn() {\n        if (singleSignOn == null)\n            singleSignOn = options.remove(\"-sso\");\n        return singleSignOn;\n    }\n\n    /**\n     * Set the password used to connect to the database.\n     * @param password\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * @see #setPassword(String)\n     * @return\n     */\n    public String getPassword() {\n        if (password == null)\n            password = pullParam(\"-p\");\n        if (password == null && isPromptForPasswordEnabled())\n            password = new String(PasswordReader.getInstance().readPassword(\"Password: \"));\n        if (password == null) {\n            // if -pfp is enabled when analyzing multiple schemas then\n            // we don't want to send the password on the command line,\n            // so see if it was passed in the environment (not ideal, but safer)\n            password = System.getenv(\"schemaspy.pw\");\n        }\n        return password;\n    }\n\n    /**\n     * Set to <code>true</code> to prompt for the password\n     * @param promptForPassword\n     */\n    public void setPromptForPasswordEnabled(boolean promptForPassword) {\n        this.promptForPassword = promptForPassword;\n    }\n\n    /**\n     * @see #setPromptForPasswordEnabled(boolean)\n     * @return\n     */\n    public boolean isPromptForPasswordEnabled() {\n        if (promptForPassword == null) {\n            promptForPassword = options.remove(\"-pfp\");\n        }\n        return promptForPassword;\n    }\n\n    public void setMaxDetailedTabled(int maxDetailedTables) {\n        this.maxDetailedTables = new Integer(maxDetailedTables);\n    }\n\n    public int getMaxDetailedTables() {\n        if (maxDetailedTables == null) {\n            // default\n            int max = 300;\n            try {\n                max = Integer.parseInt(pullParam(\"-maxdet\"));\n            } catch (Exception notSpecified) {\n            }\n            maxDetailedTables = new Integer(max);\n        }\n        return maxDetailedTables.intValue();\n    }\n\n    public String getConnectionPropertiesFile() {\n        return userConnectionPropertiesFile;\n    }\n\n    /**\n     * Properties from this file (in key=value pair format) are passed to the\n     * database connection.<br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.\n     * @param propertiesFilename\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public void setConnectionPropertiesFile(String propertiesFilename) throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null)\n            userConnectionProperties = new Properties();\n        userConnectionProperties.load(new FileInputStream(propertiesFilename));\n        userConnectionPropertiesFile = propertiesFilename;\n    }\n\n    /**\n     * Returns a {@link Properties} populated either from the properties file specified\n     * by {@link #setConnectionPropertiesFile(String)}, the properties specified by\n     * {@link #setConnectionProperties(String)} or not populated.\n     * @return\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public Properties getConnectionProperties() throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null) {\n            String props = pullParam(\"-connprops\");\n            if (props != null) {\n                if (props.indexOf(ESCAPED_EQUALS) != -1) {\n                    setConnectionProperties(props);\n                } else {\n                    setConnectionPropertiesFile(props);\n                }\n            } else {\n                userConnectionProperties = new Properties();\n            }\n        }\n        return userConnectionProperties;\n    }\n\n    /**\n     * Specifies connection properties to use in the format:\n     * <code>key1\\=value1;key2\\=value2</code><br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.<p>\n     * This is an alternative form of passing connection properties than by file\n     * (see {@link #setConnectionPropertiesFile(String)})\n     *\n     * @param properties\n     */\n    public void setConnectionProperties(String properties) {\n        userConnectionProperties = new Properties();\n        StringTokenizer tokenizer = new StringTokenizer(properties, \";\");\n        while (tokenizer.hasMoreElements()) {\n            String pair = tokenizer.nextToken();\n            int index = pair.indexOf(ESCAPED_EQUALS);\n            if (index != -1) {\n                String key = pair.substring(0, index);\n                String value = pair.substring(index + ESCAPED_EQUALS.length());\n                userConnectionProperties.put(key, value);\n            }\n        }\n    }\n\n    public void setDriverPath(String driverPath) {\n        this.driverPath = driverPath;\n    }\n\n    public String getDriverPath() {\n        if (driverPath == null)\n            driverPath = pullParam(\"-dp\");\n        // was previously -cp:\n        if (driverPath == null)\n            driverPath = pullParam(\"-cp\");\n        return driverPath;\n    }\n\n    /**\n     * The filename of the cascading style sheet to use.\n     * Note that this file is parsed and used to determine characteristics\n     * of the generated diagrams, so it must contain specific settings that\n     * are documented within schemaSpy.css.<p>\n     *\n     * Defaults to <code>\"schemaSpy.css\"</code>.\n     *\n     * @param css\n     */\n    public void setCss(String css) {\n        this.css = css;\n    }\n\n    public String getCss() {\n        if (css == null) {\n            css = pullParam(\"-css\");\n            if (css == null)\n                css = \"schemaSpy.css\";\n        }\n        return css;\n    }\n\n    /**\n     * The font to use within diagrams.  Modify the .css to specify HTML fonts.\n     *\n     * @param font\n     */\n    public void setFont(String font) {\n        this.font = font;\n    }\n\n    /**\n     * @see #setFont(String)\n     */\n    public String getFont() {\n        if (font == null) {\n            font = pullParam(\"-font\");\n            if (font == null)\n                font = \"Helvetica\";\n        }\n        return font;\n    }\n\n    /**\n     * The font size to use within diagrams.  This is the size of the font used for\n     * 'large' (e.g. not 'compact') diagrams.<p>\n     *\n     * Modify the .css to specify HTML font sizes.<p>\n     *\n     * Defaults to 11.\n     *\n     * @param fontSize\n     */\n    public void setFontSize(int fontSize) {\n        this.fontSize = new Integer(fontSize);\n    }\n\n    /**\n     * @see #setFontSize(int)\n     * @return\n     */\n    public int getFontSize() {\n        if (fontSize == null) {\n            // default\n            int size = 11;\n            try {\n                size = Integer.parseInt(pullParam(\"-fontsize\"));\n            } catch (Exception notSpecified) {\n            }\n            fontSize = new Integer(size);\n        }\n        return fontSize.intValue();\n    }\n\n    /**\n     * The character set to use within HTML pages (defaults to <code>\"ISO-8859-1\"</code>).\n     *\n     * @param charset\n     */\n    public void setCharset(String charset) {\n        this.charset = charset;\n    }\n\n    /**\n     * @see #setCharset(String)\n     */\n    public String getCharset() {\n        if (charset == null) {\n            charset = pullParam(\"-charset\");\n            if (charset == null)\n                charset = \"ISO-8859-1\";\n        }\n        return charset;\n    }\n\n    /**\n     * Description of schema that gets display on main pages.\n     *\n     * @param description\n     */\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    /**\n     * @see #setDescription(String)\n     */\n    public String getDescription() {\n        if (description == null)\n            description = pullParam(\"-desc\");\n        return description;\n    }\n\n    /**\n     * Maximum number of threads to use when querying database metadata information.\n     *\n     * @param maxDbThreads\n     */\n    public void setMaxDbThreads(int maxDbThreads) {\n        this.maxDbThreads = new Integer(maxDbThreads);\n    }\n\n    /**\n     * @see #setMaxDbThreads(int)\n     * @throws InvalidConfigurationException if unable to load properties\n     */\n    public int getMaxDbThreads() throws InvalidConfigurationException {\n        if (maxDbThreads == null) {\n            Properties properties;\n            try {\n                properties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(\"Failed to load properties for \" + getDbType() + \": \" + exc).setParamName(\"-type\");\n            }\n            // not scientifically derived\n            final int defaultMax = 15;\n            int max = defaultMax;\n            String threads = properties.getProperty(\"dbThreads\");\n            if (threads == null)\n                threads = properties.getProperty(\"dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            threads = pullParam(\"-dbThreads\");\n            if (threads == null)\n                threads = pullParam(\"-dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            if (max < 0)\n                max = defaultMax;\n            else if (max == 0)\n                max = 1;\n            maxDbThreads = new Integer(max);\n        }\n        return maxDbThreads.intValue();\n    }\n\n    public boolean isLogoEnabled() {\n        if (logoEnabled == null)\n            logoEnabled = !options.remove(\"-nologo\");\n        return logoEnabled;\n    }\n\n    /**\n     * Don't use this unless absolutely necessary as it screws up the layout\n     *\n     * @param enabled\n     */\n    public void setRankDirBugEnabled(boolean enabled) {\n        rankDirBugEnabled = enabled;\n    }\n\n    /**\n     * @see #setRankDirBugEnabled(boolean)\n     */\n    public boolean isRankDirBugEnabled() {\n        if (rankDirBugEnabled == null)\n            rankDirBugEnabled = options.remove(\"-rankdirbug\");\n        return rankDirBugEnabled;\n    }\n\n    /**\n     * Look for Ruby on Rails-based naming conventions in\n     * relationships between logical foreign keys and primary keys.<p>\n     *\n     * Basically all tables have a primary key named <code>ID</code>.\n     * All tables are named plural names.\n     * The columns that logically reference that <code>ID</code> are the singular\n     * form of the table name suffixed with <code>_ID</code>.<p>\n     *\n     * @param enabled\n     */\n    public void setRailsEnabled(boolean enabled) {\n        railsEnabled = enabled;\n    }\n\n    /**\n     * @see #setRailsEnabled(boolean)\n     *\n     * @return\n     */\n    public boolean isRailsEnabled() {\n        if (railsEnabled == null)\n            railsEnabled = options.remove(\"-rails\");\n        return railsEnabled;\n    }\n\n    /**\n     * Allow Html In Comments - encode them unless otherwise specified\n     */\n    public void setEncodeCommentsEnabled(boolean enabled) {\n        encodeCommentsEnabled = enabled;\n    }\n\n    /**\n     * @see #setEncodeCommentsEnabled(boolean)\n     */\n    public boolean isEncodeCommentsEnabled() {\n        if (encodeCommentsEnabled == null)\n            encodeCommentsEnabled = !options.remove(\"-ahic\");\n        return encodeCommentsEnabled;\n    }\n\n    /**\n     * If enabled we'll attempt to query/render the number of rows that\n     * each table contains.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setNumRowsEnabled(boolean enabled) {\n        numRowsEnabled = enabled;\n    }\n\n    /**\n     * @see #setNumRowsEnabled(boolean)\n     * @return\n     */\n    public boolean isNumRowsEnabled() {\n        if (numRowsEnabled == null)\n            numRowsEnabled = !options.remove(\"-norows\");\n        return numRowsEnabled;\n    }\n\n    /**\n     * If enabled we'll include views in the analysis.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setViewsEnabled(boolean enabled) {\n        viewsEnabled = enabled;\n    }\n\n    /**\n     * @see #setViewsEnabled(boolean)\n     * @return\n     */\n    public boolean isViewsEnabled() {\n        if (viewsEnabled == null)\n            viewsEnabled = !options.remove(\"-noviews\");\n        return viewsEnabled;\n    }\n\n    /**\n     * Returns <code>true</code> if metering should be embedded in\n     * the generated pages.<p/>\n     * Defaults to <code>false</code> (disabled).\n     * @return\n     */\n    public boolean isMeterEnabled() {\n        if (meterEnabled == null)\n            meterEnabled = options.remove(\"-meter\");\n        return meterEnabled;\n    }\n\n    /**\n     * Set the columns to exclude from all relationship diagrams.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setColumnExclusions(String columnExclusions) {\n        this.columnExclusions = Pattern.compile(columnExclusions);\n    }\n\n    /**\n     * See {@link #setColumnExclusions(String)}\n     * @return\n     */\n    public Pattern getColumnExclusions() {\n        if (columnExclusions == null) {\n            String strExclusions = pullParam(\"-X\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.columnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            columnExclusions = Pattern.compile(strExclusions);\n        }\n        return columnExclusions;\n    }\n\n    /**\n     * Set the columns to exclude from relationship diagrams where the specified\n     * columns aren't directly referenced by the focal table.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setIndirectColumnExclusions(String fullColumnExclusions) {\n        indirectColumnExclusions = Pattern.compile(fullColumnExclusions);\n    }\n\n    /**\n     * @see #setIndirectColumnExclusions(String)\n     *\n     * @return\n     */\n    public Pattern getIndirectColumnExclusions() {\n        if (indirectColumnExclusions == null) {\n            String strExclusions = pullParam(\"-x\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.indirectColumnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            indirectColumnExclusions = Pattern.compile(strExclusions);\n        }\n        return indirectColumnExclusions;\n    }\n\n    /**\n     * Set the tables to include as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableInclusions(String tableInclusions) {\n        this.tableInclusions = Pattern.compile(tableInclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to include in the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableInclusions() {\n        if (tableInclusions == null) {\n            String strInclusions = pullParam(\"-i\");\n            if (strInclusions == null)\n                strInclusions = System.getenv(\"schemaspy.tableInclusions\");\n            if (strInclusions == null)\n                strInclusions = DEFAULT_TABLE_INCLUSION;\n            try {\n                tableInclusions = Pattern.compile(strInclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-i\");\n            }\n        }\n        return tableInclusions;\n    }\n\n    /**\n     * Set the tables to exclude as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableExclusions(String tableExclusions) {\n        this.tableExclusions = Pattern.compile(tableExclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to exclude from the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableExclusions() {\n        if (tableExclusions == null) {\n            String strExclusions = pullParam(\"-I\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.tableExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_TABLE_EXCLUSION;\n            try {\n                tableExclusions = Pattern.compile(strExclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-I\");\n            }\n        }\n        return tableExclusions;\n    }\n\n    /**\n     * @return\n     */\n    public List<String> getSchemas() {\n        if (schemas == null) {\n            String tmp = pullParam(\"-schemas\");\n            if (tmp == null)\n                tmp = pullParam(\"-schemata\");\n            if (tmp != null) {\n                schemas = new ArrayList<String>();\n                for (String name : tmp.split(\"[\\\\s,'\\\"]\")) {\n                    if (name.length() > 0)\n                        schemas.add(name);\n                }\n                if (schemas.isEmpty())\n                    schemas = null;\n            }\n        }\n        return schemas;\n    }\n\n    /**\n     * Set the name of the {@link SqlFormatter SQL formatter} class to use to\n     * format SQL into HTML.<p/>\n     * The implementation of the class must be made available to the class\n     * loader, typically by specifying the path to its jar with <em>-dp</em>\n     * ({@link #setDriverPath(String)}).\n     */\n    public void setSqlFormatter(String formatterClassName) {\n        sqlFormatterClass = formatterClassName;\n        sqlFormatter = null;\n    }\n\n    /**\n     * Set the {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.\n     */\n    public void setSqlFormatter(SqlFormatter sqlFormatter) {\n        this.sqlFormatter = sqlFormatter;\n        if (sqlFormatter != null)\n            sqlFormatterClass = sqlFormatter.getClass().getName();\n    }\n\n    /**\n     * Returns an implementation of {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.  The default implementation is {@link DefaultSqlFormatter}.\n     *\n     * @return\n     * @throws InvalidConfigurationException if unable to instantiate an instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SqlFormatter getSqlFormatter() throws InvalidConfigurationException {\n        if (sqlFormatter == null) {\n            if (sqlFormatterClass == null) {\n                sqlFormatterClass = pullParam(\"-sqlFormatter\");\n                if (sqlFormatterClass == null)\n                    sqlFormatterClass = DefaultSqlFormatter.class.getName();\n            }\n            try {\n                Class<SqlFormatter> clazz = (Class<SqlFormatter>) Class.forName(sqlFormatterClass);\n                sqlFormatter = clazz.newInstance();\n            } catch (Exception exc) {\n                throw new InvalidConfigurationException(\"Failed to initialize instance of SQL formatter: \", exc).setParamName(\"-sqlFormatter\");\n            }\n        }\n        return sqlFormatter;\n    }\n\n    /**\n     * Set the details to show on the columns page, where \"details\" are\n     * comma and/or space separated.\n     *\n     * Valid values:\n     * <ul>\n     * <li>id</li>\n     * <li>table</li>\n     * <li>column</li>\n     * <li>type</li>\n     * <li>size</li>\n     * <li>nulls</li>\n     * <li>auto</li>\n     * <li>default</li>\n     * <li>children</li>\n     * <li>parents</li>\n     * </ul>\n     *\n     * The default details are <code>\"table column type size nulls auto default\"</code>.\n     * Note that \"column\" is the initially displayed detail and must be included.\n     *\n     * @param columnDetails\n     */\n    public void setColumnDetails(String columnDetails) {\n        this.columnDetails = new ArrayList<String>();\n        if (columnDetails == null || columnDetails.length() == 0) {\n            // not specified, so use defaults\n            columnDetails = \"id table column type size nulls auto default\";\n        }\n        for (String detail : columnDetails.split(\"[\\\\s,'\\\"]\")) {\n            if (detail.length() > 0) {\n                this.columnDetails.add(detail.toLowerCase());\n            }\n        }\n        if (!this.columnDetails.contains(\"column\"))\n            throw new InvalidConfigurationException(\"'column' is a required column detail\");\n    }\n\n    public void setColumnDetails(List<String> columnDetails) {\n        String details = columnDetails == null ? \"[]\" : columnDetails.toString();\n        setColumnDetails(details.substring(1, details.length() - 1));\n    }\n\n    public List<String> getColumnDetails() {\n        if (columnDetails == null) {\n            setColumnDetails(pullParam(\"-columndetails\"));\n        }\n        return columnDetails;\n    }\n\n    public void setEvaluateAllEnabled(boolean enabled) {\n        evaluteAll = enabled;\n    }\n\n    public boolean isEvaluateAllEnabled() {\n        if (evaluteAll == null)\n            evaluteAll = options.remove(\"-all\");\n        return evaluteAll;\n    }\n\n    /**\n     * Returns true if we're evaluating a bunch of schemas in one go and\n     * at this point we're evaluating a specific schema.\n     *\n     * @return boolean\n     */\n    public boolean isOneOfMultipleSchemas() {\n        // set by MultipleSchemaAnalyzer\n        return Boolean.getBoolean(\"oneofmultipleschemas\");\n    }\n\n    /**\n     * When -all (evaluateAll) is specified then this is the regular\n     * expression that determines which schemas to evaluate.\n     *\n     * @param schemaSpec\n     */\n    public void setSchemaSpec(String schemaSpec) {\n        this.schemaSpec = schemaSpec;\n    }\n\n    public String getSchemaSpec() {\n        if (schemaSpec == null)\n            schemaSpec = pullParam(\"-schemaSpec\");\n        return schemaSpec;\n    }\n\n    /**\n     * Set the renderer to use for the -Tpng[:renderer[:formatter]] dot option as specified\n     * at <a href='http://www.graphviz.org/doc/info/command.html'>\n     * http://www.graphviz.org/doc/info/command.html</a>.<p>\n     * Note that the leading \":\" is required while :formatter is optional.<p>\n     * The default renderer is typically GD.<p>\n     * Note that using {@link #setHighQuality(boolean)} is the preferred approach\n     * over using this method.\n     */\n    public void setRenderer(String renderer) {\n        Dot.getInstance().setRenderer(renderer);\n    }\n\n    /**\n     * @see #setRenderer(String)\n     * @return\n     */\n    public String getRenderer() {\n        String renderer = pullParam(\"-renderer\");\n        if (renderer != null)\n            setRenderer(renderer);\n        return Dot.getInstance().getRenderer();\n    }\n\n    /**\n     * If <code>false</code> then generate output of \"lower quality\"\n     * than the default.\n     * Note that the default is intended to be \"higher quality\",\n     * but various installations of Graphviz may have have different abilities.\n     * That is, some might not have the \"lower quality\" libraries and others might\n     * not have the \"higher quality\" libraries.<p>\n     * Higher quality output takes longer to generate and results in significantly\n     * larger image files (which take longer to download / display), but it generally\n     * looks better.\n     */\n    public void setHighQuality(boolean highQuality) {\n        this.highQuality = highQuality;\n        lowQuality = !highQuality;\n        Dot.getInstance().setHighQuality(highQuality);\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isHighQuality() {\n        if (highQuality == null) {\n            highQuality = options.remove(\"-hq\");\n            if (highQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(highQuality);\n            }\n        }\n        highQuality = Dot.getInstance().isHighQuality();\n        return highQuality;\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isLowQuality() {\n        if (lowQuality == null) {\n            lowQuality = options.remove(\"-lq\");\n            if (lowQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(!lowQuality);\n            }\n        }\n        lowQuality = !Dot.getInstance().isHighQuality();\n        return lowQuality;\n    }\n\n    /**\n     * Set the level of logging to perform.<p/>\n     * The levels in descending order are:\n     * <ul>\n     *  <li><code>severe</code> (highest - least detail)\n     *  <li><code>warning</code> (default)\n     *  <li><code>info</code>\n     *  <li><code>config</code>\n     *  <li><code>fine</code>\n     *  <li><code>finer</code>\n     *  <li><code>finest</code>  (lowest - most detail)\n     * </ul>\n     *\n     * @param logLevel\n     */\n    public void setLogLevel(String logLevel) {\n        if (logLevel == null) {\n            this.logLevel = Level.WARNING;\n            return;\n        }\n        Map<String, Level> levels = new LinkedHashMap<String, Level>();\n        levels.put(\"severe\", Level.SEVERE);\n        levels.put(\"warning\", Level.WARNING);\n        levels.put(\"info\", Level.INFO);\n        levels.put(\"config\", Level.CONFIG);\n        levels.put(\"fine\", Level.FINE);\n        levels.put(\"finer\", Level.FINER);\n        levels.put(\"finest\", Level.FINEST);\n        this.logLevel = levels.get(logLevel.toLowerCase());\n        if (this.logLevel == null) {\n            throw new InvalidConfigurationException(\"Invalid logLevel: '\" + logLevel + \"'. Must be one of: \" + levels.keySet());\n        }\n    }\n\n    /**\n     * Returns the level of logging to perform.\n     * See {@link #setLogLevel(String)}.\n     *\n     * @return\n     */\n    public Level getLogLevel() {\n        if (logLevel == null) {\n            setLogLevel(pullParam(\"-loglevel\"));\n        }\n        return logLevel;\n    }\n\n    /**\n     * Returns <code>true</code> if the options indicate that the user wants\n     * to see some help information.\n     *\n     * @return\n     */\n    public boolean isHelpRequired() {\n        return helpRequired;\n    }\n\n    public boolean isDbHelpRequired() {\n        return dbHelpRequired;\n    }\n\n    /**\n     * Returns the jar that we were loaded from\n     *\n     * @return\n     */\n    public static String getLoadedFromJar() {\n        String classpath = System.getProperty(\"java.class.path\");\n        return new StringTokenizer(classpath, File.pathSeparator).nextToken();\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasOrphans(boolean hasOrphans) {\n        this.hasOrphans = hasOrphans;\n    }\n\n    /**\n     * @see #setHasOrphans()\n     *\n     * @return\n     */\n    public boolean hasOrphans() {\n        return hasOrphans;\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasRoutines(boolean hasRoutines) {\n        this.hasRoutines = hasRoutines;\n    }\n\n    /**\n     * @see #setHasRoutines()\n     *\n     * @return\n     */\n    public boolean hasRoutines() {\n        return hasRoutines;\n    }\n\n    /**\n     * Returns the database properties to use.\n     * These should be determined by calling {@link #determineDbProperties(String)}.\n     * @return\n     * @throws InvalidConfigurationException\n     */\n    public Properties getDbProperties() throws InvalidConfigurationException {\n        if (dbProperties == null) {\n            try {\n                dbProperties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(exc);\n            }\n        }\n        return dbProperties;\n    }\n\n    /**\n     * Determines the database properties associated with the specified type.\n     * A call to {@link #setDbProperties(Properties)} is expected after determining\n     * the complete set of properties.\n     *\n     * @param type\n     * @return\n     * @throws IOException\n     * @throws InvalidConfigurationException if db properties are incorrectly formed\n     */\n    public Properties determineDbProperties(String type) throws IOException, InvalidConfigurationException {\n        ResourceBundle bundle = null;\n        try {\n            File propertiesFile = new File(type);\n            bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n            dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n        } catch (FileNotFoundException notFoundOnFilesystemWithoutExtension) {\n            try {\n                File propertiesFile = new File(type + \".properties\");\n                bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n                dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n            } catch (FileNotFoundException notFoundOnFilesystemWithExtensionTackedOn) {\n                try {\n                    bundle = ResourceBundle.getBundle(type);\n                    dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]\" + File.separator + type + \".properties\";\n                } catch (Exception notInJarWithoutPath) {\n                    try {\n                        String path = TableOrderer.class.getPackage().getName() + \".dbTypes.\" + type;\n                        path = path.replace('.', '/');\n                        bundle = ResourceBundle.getBundle(path);\n                        dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]/\" + path + \".properties\";\n                    } catch (Exception notInJar) {\n                        notInJar.printStackTrace();\n                        notFoundOnFilesystemWithExtensionTackedOn.printStackTrace();\n                        throw notFoundOnFilesystemWithoutExtension;\n                    }\n                }\n            }\n        }\n        Properties props = asProperties(bundle);\n        bundle = null;\n        // keep original thru recursion\n        String saveLoadedFrom = dbPropertiesLoadedFrom;\n        // bring in key/values pointed to by the include directive\n        // example: include.1=mysql::selectRowCountSql\n        for (int i = 1; true; ++i) {\n            String include = (String) props.remove(\"include.\" + i);\n            if (include == null)\n                break;\n            int separator = include.indexOf(\"::\");\n            if (separator == -1)\n                throw new InvalidConfigurationException(\"include directive in \" + dbPropertiesLoadedFrom + \" must have '::' between dbType and key\");\n            String refdType = include.substring(0, separator).trim();\n            String refdKey = include.substring(separator + 2).trim();\n            // recursively resolve the ref'd properties file and the ref'd key\n            Properties refdProps = determineDbProperties(refdType);\n            props.put(refdKey, refdProps.getProperty(refdKey));\n        }\n        // bring in base properties files pointed to by the extends directive\n        String baseDbType = (String) props.remove(\"extends\");\n        if (baseDbType != null) {\n            baseDbType = baseDbType.trim();\n            Properties baseProps = determineDbProperties(baseDbType);\n            // overlay our properties on top of the base's\n            baseProps.putAll(props);\n            props = baseProps;\n        }\n        // done with this level of recursion...restore original\n        dbPropertiesLoadedFrom = saveLoadedFrom;\n        // this won't be correct until the final recursion exits\n        dbProperties = props;\n        return props;\n    }\n\n    protected String getDbPropertiesLoadedFrom() throws IOException {\n        if (dbPropertiesLoadedFrom == null)\n            determineDbProperties(getDbType());\n        return dbPropertiesLoadedFrom;\n    }\n\n    public List<String> getRemainingParameters() {\n        try {\n            populate();\n        } catch (IllegalArgumentException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (IllegalAccessException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (InvocationTargetException exc) {\n            if (exc.getCause() instanceof InvalidConfigurationException)\n                throw (InvalidConfigurationException) exc.getCause();\n            throw new InvalidConfigurationException(exc.getCause());\n        } catch (IntrospectionException exc) {\n            throw new InvalidConfigurationException(exc);\n        }\n        return options;\n    }\n\n    /**\n     * Options that are specific to a type of database.  E.g. things like <code>host</code>,\n     * <code>port</code> or <code>db</code>, but <b>don't</b> have a setter in this class.\n     *\n     * @param dbSpecificOptions\n     */\n    public void setDbSpecificOptions(Map<String, String> dbSpecificOptions) {\n        this.dbSpecificOptions = dbSpecificOptions;\n        originalDbSpecificOptions = new HashMap<String, String>(dbSpecificOptions);\n    }\n\n    public Map<String, String> getDbSpecificOptions() {\n        if (dbSpecificOptions == null)\n            dbSpecificOptions = new HashMap<String, String>();\n        return dbSpecificOptions;\n    }\n\n    /**\n     * Returns a {@link Properties} populated with the contents of <code>bundle</code>\n     *\n     * @param bundle ResourceBundle\n     * @return Properties\n     */\n    public static Properties asProperties(ResourceBundle bundle) {\n        Properties props = new Properties();\n        Enumeration<String> iter = bundle.getKeys();\n        while (iter.hasMoreElements()) {\n            String key = iter.nextElement();\n            props.put(key, bundle.getObject(key));\n        }\n        return props;\n    }\n\n    /**\n     * 'Pull' the specified parameter from the collection of options. Returns\n     * null if the parameter isn't in the list and removes it if it is.\n     *\n     * @param paramId\n     * @return\n     */\n    private String pullParam(String paramId) {\n        return pullParam(paramId, false, false);\n    }\n\n    private String pullRequiredParam(String paramId) {\n        return pullParam(paramId, true, false);\n    }\n\n    /**\n     * @param paramId\n     * @param required\n     * @param dbTypeSpecific\n     * @return\n     * @throws MissingRequiredParameterException\n     */\n    private String pullParam(String paramId, boolean required, boolean dbTypeSpecific) throws MissingRequiredParameterException {\n        int paramIndex = options.indexOf(paramId);\n        if (paramIndex < 0) {\n            if (required)\n                throw new MissingRequiredParameterException(paramId, dbTypeSpecific);\n            return null;\n        }\n        options.remove(paramIndex);\n        String param = options.get(paramIndex).toString();\n        options.remove(paramIndex);\n        return param;\n    }\n\n    /**\n     * Thrown to indicate that a required parameter is missing\n     */\n    public static class MissingRequiredParameterException extends RuntimeException {\n\n        private static final long serialVersionUID = 1L;\n\n        private final boolean dbTypeSpecific;\n\n        public MissingRequiredParameterException(String paramId, boolean dbTypeSpecific) {\n            this(paramId, null, dbTypeSpecific);\n        }\n\n        public MissingRequiredParameterException(String paramId, String description, boolean dbTypeSpecific) {\n            super(\"Required parameter '\" + paramId + \"' \" + (description == null ? \"\" : \"(\" + description + \") \") + \"was not specified.\" + (dbTypeSpecific ? \"  It is required for this database type.\" : \"\"));\n            this.dbTypeSpecific = dbTypeSpecific;\n        }\n\n        public boolean isDbTypeSpecific() {\n            return dbTypeSpecific;\n        }\n    }\n\n    /**\n     * Allow an equal sign in args...like \"-o=foo.bar\". Useful for things like\n     * Ant and Maven.\n     *\n     * @param args\n     *            List\n     * @return List\n     */\n    protected List<String> fixupArgs(List<String> args) {\n        List<String> expandedArgs = new ArrayList<String>();\n        for (String arg : args) {\n            int indexOfEquals = arg.indexOf('=');\n            if (indexOfEquals != -1 && indexOfEquals - 1 != arg.indexOf(ESCAPED_EQUALS)) {\n                expandedArgs.add(arg.substring(0, indexOfEquals));\n                expandedArgs.add(arg.substring(indexOfEquals + 1));\n            } else {\n                expandedArgs.add(arg);\n            }\n        }\n        // some OSes/JVMs do filename expansion with runtime.exec() and some don't,\n        // so MultipleSchemaAnalyzer has to surround params with double quotes...\n        // strip them here for the OSes/JVMs that don't do anything with the params\n        List<String> unquotedArgs = new ArrayList<String>();\n        for (String arg : expandedArgs) {\n            if (// \".*\" becomes .*\n            arg.startsWith(\"\\\"\") && arg.endsWith(\"\\\"\"))\n                arg = arg.substring(1, arg.length() - 1);\n            unquotedArgs.add(arg);\n        }\n        return unquotedArgs;\n    }\n\n    /**\n     * Call all the getters to populate all the lazy initialized stuff.\n     *\n     * @throws InvocationTargetException\n     * @throws IllegalAccessException\n     * @throws IllegalArgumentException\n     * @throws IntrospectionException\n     */\n    private void populate() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IntrospectionException {\n        if (!populating) {\n            // prevent recursion\n            populating = true;\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                Method readMethod = props[i].getReadMethod();\n                if (readMethod != null)\n                    readMethod.invoke(this, (Object[]) null);\n            }\n            populating = false;\n        }\n    }\n\n    public static Set<String> getBuiltInDatabaseTypes(String loadedFromJar) {\n        Set<String> databaseTypes = new TreeSet<String>();\n        JarInputStream jar = null;\n        try {\n            jar = new JarInputStream(new FileInputStream(loadedFromJar));\n            JarEntry entry;\n            while ((entry = jar.getNextJarEntry()) != null) {\n                String entryName = entry.getName();\n                int dotPropsIndex = entryName.indexOf(\".properties\");\n                if (dotPropsIndex != -1)\n                    databaseTypes.add(entryName.substring(0, dotPropsIndex));\n            }\n        } catch (IOException exc) {\n        } finally {\n            if (jar != null) {\n                try {\n                    jar.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n        return databaseTypes;\n    }\n\n    protected void dumpUsage(String errorMessage, boolean detailedDb) {\n        if (errorMessage != null) {\n            System.out.flush();\n            System.err.println(\"*** \" + errorMessage + \" ***\");\n        } else {\n            System.out.println(\"SchemaSpy generates an HTML representation of a database schema's relationships.\");\n        }\n        System.err.flush();\n        System.out.println();\n        if (!detailedDb) {\n            System.out.println(\"Usage:\");\n            System.out.println(\" java -jar \" + getLoadedFromJar() + \" [options]\");\n            System.out.println(\"   -t databaseType       type of database - defaults to ora\");\n            System.out.println(\"                           use -dbhelp for a list of built-in types\");\n            System.out.println(\"   -u user               connect to the database with this user id\");\n            System.out.println(\"   -s schema             defaults to the specified user\");\n            System.out.println(\"   -p password           defaults to no password\");\n            System.out.println(\"   -o outputDirectory    directory to place the generated output in\");\n            System.out.println(\"   -dp pathToDrivers     optional - looks for JDBC drivers here before looking\");\n            System.out.println(\"                           in driverPath in [databaseType].properties.\");\n            System.out.println(\"Go to http://schemaspy.sourceforge.net for a complete list/description\");\n            System.out.println(\" of additional parameters.\");\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"Built-in database types and their required connection parameters:\");\n            for (String type : getBuiltInDatabaseTypes(getLoadedFromJar())) {\n                new DbSpecificConfig(type).dumpUsage();\n            }\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"You can use your own database types by specifying the filespec of a .properties file with -t.\");\n            System.out.println(\"Grab one out of \" + getLoadedFromJar() + \" and modify it to suit your needs.\");\n            System.out.println();\n        }\n        System.out.println(\"Sample usage using the default database type (implied -t ora):\");\n        System.out.println(\" java -jar schemaSpy.jar -db mydb -s myschema -u devuser -p password -o output\");\n        System.out.println();\n        System.out.flush();\n    }\n\n    /**\n     * Get the value of the specified parameter.\n     * Used for properties that are common to most db's, but aren't required.\n     *\n     * @param paramName\n     * @return\n     */\n    public String getParam(String paramName) {\n        try {\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                PropertyDescriptor prop = props[i];\n                if (prop.getName().equalsIgnoreCase(paramName)) {\n                    Object result = prop.getReadMethod().invoke(this, (Object[]) null);\n                    return result == null ? null : result.toString();\n                }\n            }\n        } catch (Exception failed) {\n            failed.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * Return all of the configuration options as a List of Strings, with\n     * each parameter and its value as a separate element.\n     *\n     * @return\n     * @throws IOException\n     */\n    public List<String> asList() throws IOException {\n        List<String> params = new ArrayList<String>();\n        if (originalDbSpecificOptions != null) {\n            for (String key : originalDbSpecificOptions.keySet()) {\n                String value = originalDbSpecificOptions.get(key);\n                if (!key.startsWith(\"-\"))\n                    key = \"-\" + key;\n                params.add(key);\n                params.add(value);\n            }\n        }\n        if (isEncodeCommentsEnabled())\n            params.add(\"-ahic\");\n        if (isEvaluateAllEnabled())\n            params.add(\"-all\");\n        if (!isHtmlGenerationEnabled())\n            params.add(\"-nohtml\");\n        if (!isImpliedConstraintsEnabled())\n            params.add(\"-noimplied\");\n        if (!isLogoEnabled())\n            params.add(\"-nologo\");\n        if (isMeterEnabled())\n            params.add(\"-meter\");\n        if (!isNumRowsEnabled())\n            params.add(\"-norows\");\n        if (!isViewsEnabled())\n            params.add(\"-noviews\");\n        if (isRankDirBugEnabled())\n            params.add(\"-rankdirbug\");\n        if (isRailsEnabled())\n            params.add(\"-rails\");\n        if (isSingleSignOn())\n            params.add(\"-sso\");\n        if (isSchemaDisabled())\n            params.add(\"-noschema\");\n        String value = getDriverPath();\n        if (value != null) {\n            params.add(\"-dp\");\n            params.add(value);\n        }\n        params.add(\"-css\");\n        params.add(getCss());\n        params.add(\"-charset\");\n        params.add(getCharset());\n        params.add(\"-font\");\n        params.add(getFont());\n        params.add(\"-fontsize\");\n        params.add(String.valueOf(getFontSize()));\n        params.add(\"-t\");\n        params.add(getDbType());\n        // query to set renderer correctly\n        isHighQuality();\n        // query to set renderer correctly\n        isLowQuality();\n        // instead of -hq and/or -lq\n        params.add(\"-renderer\");\n        params.add(getRenderer());\n        value = getDescription();\n        if (value != null) {\n            params.add(\"-desc\");\n            params.add(value);\n        }\n        value = getPassword();\n        if (value != null && !isPromptForPasswordEnabled()) {\n            // note that we don't pass -pfp since child processes\n            // won't have a console\n            params.add(\"-p\");\n            params.add(value);\n        }\n        value = getCatalog();\n        if (value != null) {\n            params.add(\"-cat\");\n            params.add(value);\n        }\n        value = getSchema();\n        if (value != null) {\n            params.add(\"-s\");\n            params.add(value);\n        }\n        value = getUser();\n        if (value != null) {\n            params.add(\"-u\");\n            params.add(value);\n        }\n        value = getConnectionPropertiesFile();\n        if (value != null) {\n            params.add(\"-connprops\");\n            params.add(value);\n        } else {\n            Properties props = getConnectionProperties();\n            if (!props.isEmpty()) {\n                params.add(\"-connprops\");\n                StringBuilder buf = new StringBuilder();\n                for (Entry<Object, Object> entry : props.entrySet()) {\n                    buf.append(entry.getKey());\n                    buf.append(ESCAPED_EQUALS);\n                    buf.append(entry.getValue());\n                    buf.append(';');\n                }\n                params.add(buf.toString());\n            }\n        }\n        value = getDb();\n        if (value != null) {\n            params.add(\"-db\");\n            params.add(value);\n        }\n        value = getHost();\n        if (value != null) {\n            params.add(\"-host\");\n            params.add(value);\n        }\n        if (getPort() != null) {\n            params.add(\"-port\");\n            params.add(getPort().toString());\n        }\n        value = getServer();\n        if (value != null) {\n            params.add(\"-server\");\n            params.add(value);\n        }\n        value = getMeta();\n        if (value != null) {\n            params.add(\"-meta\");\n            params.add(value);\n        }\n        if (getGraphvizDir() != null) {\n            params.add(\"-gv\");\n            params.add(getGraphvizDir().toString());\n        }\n        params.add(\"-loglevel\");\n        params.add(getLogLevel().toString().toLowerCase());\n        params.add(\"-sqlFormatter\");\n        params.add(getSqlFormatter().getClass().getName());\n        params.add(\"-i\");\n        params.add(getTableInclusions().toString());\n        params.add(\"-I\");\n        params.add(getTableExclusions().toString());\n        params.add(\"-X\");\n        params.add(getColumnExclusions().toString());\n        params.add(\"-x\");\n        params.add(getIndirectColumnExclusions().toString());\n        params.add(\"-dbthreads\");\n        params.add(String.valueOf(getMaxDbThreads()));\n        params.add(\"-maxdet\");\n        params.add(String.valueOf(getMaxDetailedTables()));\n        params.add(\"-o\");\n        params.add(getOutputDir().toString());\n        return params;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/ConfigTest3.java",
		"test_prompt": "// ConfigTest3.java\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Config}.\n* It contains ten unit test cases for the {@link Config#isSchemaDisabled()} method.\n*/\nclass ConfigTest3 {"
	},
	{
		"original_code": "// Config.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\n\n/**\n * Configuration of a SchemaSpy run\n *\n * @author John Currier\n */\npublic class Config {\n\n    private static Config instance;\n\n    private final List<String> options;\n\n    private Map<String, String> dbSpecificOptions;\n\n    private Map<String, String> originalDbSpecificOptions;\n\n    private boolean helpRequired;\n\n    private boolean dbHelpRequired;\n\n    private File outputDir;\n\n    private File graphvizDir;\n\n    private String dbType;\n\n    private String catalog;\n\n    private String schema;\n\n    private List<String> schemas;\n\n    private String user;\n\n    private Boolean singleSignOn;\n\n    private Boolean noSchema;\n\n    private String password;\n\n    private Boolean promptForPassword;\n\n    private String db;\n\n    private String host;\n\n    private Integer port;\n\n    private String server;\n\n    private String meta;\n\n    private Pattern tableInclusions;\n\n    private Pattern tableExclusions;\n\n    private Pattern columnExclusions;\n\n    private Pattern indirectColumnExclusions;\n\n    private String userConnectionPropertiesFile;\n\n    private Properties userConnectionProperties;\n\n    private Integer maxDbThreads;\n\n    private Integer maxDetailedTables;\n\n    private String driverPath;\n\n    private String css;\n\n    private String charset;\n\n    private String font;\n\n    private Integer fontSize;\n\n    private String description;\n\n    private Properties dbProperties;\n\n    private String dbPropertiesLoadedFrom;\n\n    private Level logLevel;\n\n    private SqlFormatter sqlFormatter;\n\n    private String sqlFormatterClass;\n\n    private Boolean generateHtml;\n\n    private Boolean includeImpliedConstraints;\n\n    private Boolean logoEnabled;\n\n    private Boolean rankDirBugEnabled;\n\n    private Boolean encodeCommentsEnabled;\n\n    private Boolean numRowsEnabled;\n\n    private Boolean viewsEnabled;\n\n    private Boolean meterEnabled;\n\n    private Boolean railsEnabled;\n\n    private Boolean evaluteAll;\n\n    private Boolean highQuality;\n\n    private Boolean lowQuality;\n\n    // used in conjunction with evaluateAll\n    private String schemaSpec;\n\n    private boolean hasOrphans = false;\n\n    private boolean hasRoutines = false;\n\n    private boolean populating = false;\n\n    private List<String> columnDetails;\n\n    public static final String DOT_CHARSET = \"UTF-8\";\n\n    private static final String ESCAPED_EQUALS = \"\\\\=\";\n\n    // match everything\n    private static final String DEFAULT_TABLE_INCLUSION = \".*\";\n\n    // match nothing\n    private static final String DEFAULT_TABLE_EXCLUSION = \"\";\n\n    // match nothing\n    private static final String DEFAULT_COLUMN_EXCLUSION = \"[^.]\";\n\n    /**\n     * Default constructor. Intended for when you want to inject properties\n     * independently (i.e. not from a command line interface).\n     */\n    public Config() {\n        if (instance == null)\n            setInstance(this);\n        options = new ArrayList<String>();\n    }\n\n    /**\n     * Construct a configuration from an array of options (e.g. from a command\n     * line interface).\n     *\n     * @param options\n     */\n    public Config(String[] argv) {\n        setInstance(this);\n        options = fixupArgs(Arrays.asList(argv));\n        helpRequired = options.remove(\"-?\") || options.remove(\"/?\") || options.remove(\"?\") || options.remove(\"-h\") || options.remove(\"-help\") || options.remove(\"--help\");\n        dbHelpRequired = options.remove(\"-dbHelp\") || options.remove(\"-dbhelp\");\n    }\n\n    public static Config getInstance() {\n        if (instance == null)\n            instance = new Config();\n        return instance;\n    }\n\n    /**\n     * Sets the global instance.\n     *\n     * Useful for things like selecting a specific configuration in a UI.\n     *\n     * @param config\n     */\n    public static void setInstance(Config config) {\n        instance = config;\n    }\n\n    public void setHtmlGenerationEnabled(boolean generateHtml) {\n        this.generateHtml = generateHtml;\n    }\n\n    public boolean isHtmlGenerationEnabled() {\n        if (generateHtml == null)\n            generateHtml = !options.remove(\"-nohtml\");\n        return generateHtml;\n    }\n\n    public void setImpliedConstraintsEnabled(boolean includeImpliedConstraints) {\n        this.includeImpliedConstraints = includeImpliedConstraints;\n    }\n\n    public boolean isImpliedConstraintsEnabled() {\n        if (includeImpliedConstraints == null)\n            includeImpliedConstraints = !options.remove(\"-noimplied\");\n        return includeImpliedConstraints;\n    }\n\n    public void setOutputDir(String outputDirName) {\n        if (outputDirName.endsWith(\"\\\"\"))\n            outputDirName = outputDirName.substring(0, outputDirName.length() - 1);\n        setOutputDir(new File(outputDirName));\n    }\n\n    public void setOutputDir(File outputDir) {\n        this.outputDir = outputDir;\n    }\n\n    public File getOutputDir() {\n        if (outputDir == null) {\n            setOutputDir(pullRequiredParam(\"-o\"));\n        }\n        return outputDir;\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(String graphvizDir) {\n        if (graphvizDir.endsWith(\"\\\"\"))\n            graphvizDir = graphvizDir.substring(0, graphvizDir.length() - 1);\n        setGraphvizDir(new File(graphvizDir));\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(File graphvizDir) {\n        this.graphvizDir = graphvizDir;\n    }\n\n    /**\n     * Return the path to Graphviz (used to find the dot executable to run to\n     * generate ER diagrams).<p/>\n     *\n     * Returns {@link #getDefaultGraphvizPath()} if a specific Graphviz path\n     * was not specified.\n     *\n     * @return\n     */\n    public File getGraphvizDir() {\n        if (graphvizDir == null) {\n            String gv = pullParam(\"-gv\");\n            if (gv != null) {\n                setGraphvizDir(gv);\n            } else {\n                // expect to find Graphviz's bin directory on the PATH\n            }\n        }\n        return graphvizDir;\n    }\n\n    /**\n     * Meta files are XML-based files that provide additional metadata\n     * about the schema being evaluated.<p>\n     * <code>meta</code> is either the name of an individual XML file or\n     * the directory that contains meta files.<p>\n     * If a directory is specified then it is expected to contain files\n     * matching the pattern <code>[schema].meta.xml</code>.\n     * For databases that don't have schema substitute database for schema.\n     * @param meta\n     */\n    public void setMeta(String meta) {\n        this.meta = meta;\n    }\n\n    public String getMeta() {\n        if (meta == null)\n            meta = pullParam(\"-meta\");\n        return meta;\n    }\n\n    public void setDbType(String dbType) {\n        this.dbType = dbType;\n    }\n\n    public String getDbType() {\n        if (dbType == null) {\n            dbType = pullParam(\"-t\");\n            if (dbType == null)\n                dbType = \"ora\";\n        }\n        return dbType;\n    }\n\n    public void setDb(String db) {\n        this.db = db;\n    }\n\n    public String getDb() {\n        if (db == null)\n            db = pullParam(\"-db\");\n        return db;\n    }\n\n    public void setCatalog(String catalog) {\n        this.catalog = catalog;\n    }\n\n    public String getCatalog() {\n        if (catalog == null)\n            catalog = pullParam(\"-cat\");\n        return catalog;\n    }\n\n    public void setSchema(String schema) {\n        this.schema = schema;\n    }\n\n    public String getSchema() {\n        if (schema == null)\n            schema = pullParam(\"-s\");\n        return schema;\n    }\n\n    /**\n     * Some databases types (e.g. older versions of Informix) don't really\n     * have the concept of a schema but still return true from\n     * {@link DatabaseMetaData#supportsSchemasInTableDefinitions()}.\n     * This option lets you ignore that and treat all the tables\n     * as if they were in one flat namespace.\n     */\n    public boolean isSchemaDisabled() {\n        if (noSchema == null)\n            noSchema = options.remove(\"-noschema\");\n        return noSchema;\n    }\n\n    public void setHost(String host) {\n        this.host = host;\n    }\n\n    public String getHost() {\n        if (host == null)\n            host = pullParam(\"-host\");\n        return host;\n    }\n\n    public void setPort(Integer port) {\n        this.port = port;\n    }\n\n    public Integer getPort() {\n        if (port == null)\n            try {\n                port = Integer.valueOf(pullParam(\"-port\"));\n            } catch (Exception notSpecified) {\n            }\n        return port;\n    }\n\n    public void setServer(String server) {\n        this.server = server;\n    }\n\n    public String getServer() {\n        if (server == null) {\n            server = pullParam(\"-server\");\n        }\n        return server;\n    }\n\n    public void setUser(String user) {\n        this.user = user;\n    }\n\n    /**\n     * User used to connect to the database.\n     * Required unless single sign-on is enabled\n     * (see {@link #setSingleSignOn(boolean)}).\n     * @return\n     */\n    public String getUser() {\n        if (user == null) {\n            if (!isSingleSignOn())\n                user = pullRequiredParam(\"-u\");\n            else\n                user = pullParam(\"-u\");\n        }\n        return user;\n    }\n\n    /**\n     * By default a \"user\" (as specified with -u) is required.\n     * This option allows disabling of that requirement for\n     * single sign-on environments.\n     *\n     * @param enabled defaults to <code>false</code>\n     */\n    public void setSingleSignOn(boolean enabled) {\n        singleSignOn = enabled;\n    }\n\n    /**\n     * @see #setSingleSignOn(boolean)\n     */\n    public boolean isSingleSignOn() {\n        if (singleSignOn == null)\n            singleSignOn = options.remove(\"-sso\");\n        return singleSignOn;\n    }\n\n    /**\n     * Set the password used to connect to the database.\n     * @param password\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * @see #setPassword(String)\n     * @return\n     */\n    public String getPassword() {\n        if (password == null)\n            password = pullParam(\"-p\");\n        if (password == null && isPromptForPasswordEnabled())\n            password = new String(PasswordReader.getInstance().readPassword(\"Password: \"));\n        if (password == null) {\n            // if -pfp is enabled when analyzing multiple schemas then\n            // we don't want to send the password on the command line,\n            // so see if it was passed in the environment (not ideal, but safer)\n            password = System.getenv(\"schemaspy.pw\");\n        }\n        return password;\n    }\n\n    /**\n     * Set to <code>true</code> to prompt for the password\n     * @param promptForPassword\n     */\n    public void setPromptForPasswordEnabled(boolean promptForPassword) {\n        this.promptForPassword = promptForPassword;\n    }\n\n    /**\n     * @see #setPromptForPasswordEnabled(boolean)\n     * @return\n     */\n    public boolean isPromptForPasswordEnabled() {\n        if (promptForPassword == null) {\n            promptForPassword = options.remove(\"-pfp\");\n        }\n        return promptForPassword;\n    }\n\n    public void setMaxDetailedTabled(int maxDetailedTables) {\n        this.maxDetailedTables = new Integer(maxDetailedTables);\n    }\n\n    public int getMaxDetailedTables() {\n        if (maxDetailedTables == null) {\n            // default\n            int max = 300;\n            try {\n                max = Integer.parseInt(pullParam(\"-maxdet\"));\n            } catch (Exception notSpecified) {\n            }\n            maxDetailedTables = new Integer(max);\n        }\n        return maxDetailedTables.intValue();\n    }\n\n    public String getConnectionPropertiesFile() {\n        return userConnectionPropertiesFile;\n    }\n\n    /**\n     * Properties from this file (in key=value pair format) are passed to the\n     * database connection.<br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.\n     * @param propertiesFilename\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public void setConnectionPropertiesFile(String propertiesFilename) throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null)\n            userConnectionProperties = new Properties();\n        userConnectionProperties.load(new FileInputStream(propertiesFilename));\n        userConnectionPropertiesFile = propertiesFilename;\n    }\n\n    /**\n     * Returns a {@link Properties} populated either from the properties file specified\n     * by {@link #setConnectionPropertiesFile(String)}, the properties specified by\n     * {@link #setConnectionProperties(String)} or not populated.\n     * @return\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public Properties getConnectionProperties() throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null) {\n            String props = pullParam(\"-connprops\");\n            if (props != null) {\n                if (props.indexOf(ESCAPED_EQUALS) != -1) {\n                    setConnectionProperties(props);\n                } else {\n                    setConnectionPropertiesFile(props);\n                }\n            } else {\n                userConnectionProperties = new Properties();\n            }\n        }\n        return userConnectionProperties;\n    }\n\n    /**\n     * Specifies connection properties to use in the format:\n     * <code>key1\\=value1;key2\\=value2</code><br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.<p>\n     * This is an alternative form of passing connection properties than by file\n     * (see {@link #setConnectionPropertiesFile(String)})\n     *\n     * @param properties\n     */\n    public void setConnectionProperties(String properties) {\n        userConnectionProperties = new Properties();\n        StringTokenizer tokenizer = new StringTokenizer(properties, \";\");\n        while (tokenizer.hasMoreElements()) {\n            String pair = tokenizer.nextToken();\n            int index = pair.indexOf(ESCAPED_EQUALS);\n            if (index != -1) {\n                String key = pair.substring(0, index);\n                String value = pair.substring(index + ESCAPED_EQUALS.length());\n                userConnectionProperties.put(key, value);\n            }\n        }\n    }\n\n    public void setDriverPath(String driverPath) {\n        this.driverPath = driverPath;\n    }\n\n    public String getDriverPath() {\n        if (driverPath == null)\n            driverPath = pullParam(\"-dp\");\n        // was previously -cp:\n        if (driverPath == null)\n            driverPath = pullParam(\"-cp\");\n        return driverPath;\n    }\n\n    /**\n     * The filename of the cascading style sheet to use.\n     * Note that this file is parsed and used to determine characteristics\n     * of the generated diagrams, so it must contain specific settings that\n     * are documented within schemaSpy.css.<p>\n     *\n     * Defaults to <code>\"schemaSpy.css\"</code>.\n     *\n     * @param css\n     */\n    public void setCss(String css) {\n        this.css = css;\n    }\n\n    public String getCss() {\n        if (css == null) {\n            css = pullParam(\"-css\");\n            if (css == null)\n                css = \"schemaSpy.css\";\n        }\n        return css;\n    }\n\n    /**\n     * The font to use within diagrams.  Modify the .css to specify HTML fonts.\n     *\n     * @param font\n     */\n    public void setFont(String font) {\n        this.font = font;\n    }\n\n    /**\n     * @see #setFont(String)\n     */\n    public String getFont() {\n        if (font == null) {\n            font = pullParam(\"-font\");\n            if (font == null)\n                font = \"Helvetica\";\n        }\n        return font;\n    }\n\n    /**\n     * The font size to use within diagrams.  This is the size of the font used for\n     * 'large' (e.g. not 'compact') diagrams.<p>\n     *\n     * Modify the .css to specify HTML font sizes.<p>\n     *\n     * Defaults to 11.\n     *\n     * @param fontSize\n     */\n    public void setFontSize(int fontSize) {\n        this.fontSize = new Integer(fontSize);\n    }\n\n    /**\n     * @see #setFontSize(int)\n     * @return\n     */\n    public int getFontSize() {\n        if (fontSize == null) {\n            // default\n            int size = 11;\n            try {\n                size = Integer.parseInt(pullParam(\"-fontsize\"));\n            } catch (Exception notSpecified) {\n            }\n            fontSize = new Integer(size);\n        }\n        return fontSize.intValue();\n    }\n\n    /**\n     * The character set to use within HTML pages (defaults to <code>\"ISO-8859-1\"</code>).\n     *\n     * @param charset\n     */\n    public void setCharset(String charset) {\n        this.charset = charset;\n    }\n\n    /**\n     * @see #setCharset(String)\n     */\n    public String getCharset() {\n        if (charset == null) {\n            charset = pullParam(\"-charset\");\n            if (charset == null)\n                charset = \"ISO-8859-1\";\n        }\n        return charset;\n    }\n\n    /**\n     * Description of schema that gets display on main pages.\n     *\n     * @param description\n     */\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    /**\n     * @see #setDescription(String)\n     */\n    public String getDescription() {\n        if (description == null)\n            description = pullParam(\"-desc\");\n        return description;\n    }\n\n    /**\n     * Maximum number of threads to use when querying database metadata information.\n     *\n     * @param maxDbThreads\n     */\n    public void setMaxDbThreads(int maxDbThreads) {\n        this.maxDbThreads = new Integer(maxDbThreads);\n    }\n\n    /**\n     * @see #setMaxDbThreads(int)\n     * @throws InvalidConfigurationException if unable to load properties\n     */\n    public int getMaxDbThreads() throws InvalidConfigurationException {\n        if (maxDbThreads == null) {\n            Properties properties;\n            try {\n                properties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(\"Failed to load properties for \" + getDbType() + \": \" + exc).setParamName(\"-type\");\n            }\n            // not scientifically derived\n            final int defaultMax = 15;\n            int max = defaultMax;\n            String threads = properties.getProperty(\"dbThreads\");\n            if (threads == null)\n                threads = properties.getProperty(\"dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            threads = pullParam(\"-dbThreads\");\n            if (threads == null)\n                threads = pullParam(\"-dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            if (max < 0)\n                max = defaultMax;\n            else if (max == 0)\n                max = 1;\n            maxDbThreads = new Integer(max);\n        }\n        return maxDbThreads.intValue();\n    }\n\n    public boolean isLogoEnabled() {\n        if (logoEnabled == null)\n            logoEnabled = !options.remove(\"-nologo\");\n        return logoEnabled;\n    }\n\n    /**\n     * Don't use this unless absolutely necessary as it screws up the layout\n     *\n     * @param enabled\n     */\n    public void setRankDirBugEnabled(boolean enabled) {\n        rankDirBugEnabled = enabled;\n    }\n\n    /**\n     * @see #setRankDirBugEnabled(boolean)\n     */\n    public boolean isRankDirBugEnabled() {\n        if (rankDirBugEnabled == null)\n            rankDirBugEnabled = options.remove(\"-rankdirbug\");\n        return rankDirBugEnabled;\n    }\n\n    /**\n     * Look for Ruby on Rails-based naming conventions in\n     * relationships between logical foreign keys and primary keys.<p>\n     *\n     * Basically all tables have a primary key named <code>ID</code>.\n     * All tables are named plural names.\n     * The columns that logically reference that <code>ID</code> are the singular\n     * form of the table name suffixed with <code>_ID</code>.<p>\n     *\n     * @param enabled\n     */\n    public void setRailsEnabled(boolean enabled) {\n        railsEnabled = enabled;\n    }\n\n    /**\n     * @see #setRailsEnabled(boolean)\n     *\n     * @return\n     */\n    public boolean isRailsEnabled() {\n        if (railsEnabled == null)\n            railsEnabled = options.remove(\"-rails\");\n        return railsEnabled;\n    }\n\n    /**\n     * Allow Html In Comments - encode them unless otherwise specified\n     */\n    public void setEncodeCommentsEnabled(boolean enabled) {\n        encodeCommentsEnabled = enabled;\n    }\n\n    /**\n     * @see #setEncodeCommentsEnabled(boolean)\n     */\n    public boolean isEncodeCommentsEnabled() {\n        if (encodeCommentsEnabled == null)\n            encodeCommentsEnabled = !options.remove(\"-ahic\");\n        return encodeCommentsEnabled;\n    }\n\n    /**\n     * If enabled we'll attempt to query/render the number of rows that\n     * each table contains.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setNumRowsEnabled(boolean enabled) {\n        numRowsEnabled = enabled;\n    }\n\n    /**\n     * @see #setNumRowsEnabled(boolean)\n     * @return\n     */\n    public boolean isNumRowsEnabled() {\n        if (numRowsEnabled == null)\n            numRowsEnabled = !options.remove(\"-norows\");\n        return numRowsEnabled;\n    }\n\n    /**\n     * If enabled we'll include views in the analysis.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setViewsEnabled(boolean enabled) {\n        viewsEnabled = enabled;\n    }\n\n    /**\n     * @see #setViewsEnabled(boolean)\n     * @return\n     */\n    public boolean isViewsEnabled() {\n        if (viewsEnabled == null)\n            viewsEnabled = !options.remove(\"-noviews\");\n        return viewsEnabled;\n    }\n\n    /**\n     * Returns <code>true</code> if metering should be embedded in\n     * the generated pages.<p/>\n     * Defaults to <code>false</code> (disabled).\n     * @return\n     */\n    public boolean isMeterEnabled() {\n        if (meterEnabled == null)\n            meterEnabled = options.remove(\"-meter\");\n        return meterEnabled;\n    }\n\n    /**\n     * Set the columns to exclude from all relationship diagrams.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setColumnExclusions(String columnExclusions) {\n        this.columnExclusions = Pattern.compile(columnExclusions);\n    }\n\n    /**\n     * See {@link #setColumnExclusions(String)}\n     * @return\n     */\n    public Pattern getColumnExclusions() {\n        if (columnExclusions == null) {\n            String strExclusions = pullParam(\"-X\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.columnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            columnExclusions = Pattern.compile(strExclusions);\n        }\n        return columnExclusions;\n    }\n\n    /**\n     * Set the columns to exclude from relationship diagrams where the specified\n     * columns aren't directly referenced by the focal table.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setIndirectColumnExclusions(String fullColumnExclusions) {\n        indirectColumnExclusions = Pattern.compile(fullColumnExclusions);\n    }\n\n    /**\n     * @see #setIndirectColumnExclusions(String)\n     *\n     * @return\n     */\n    public Pattern getIndirectColumnExclusions() {\n        if (indirectColumnExclusions == null) {\n            String strExclusions = pullParam(\"-x\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.indirectColumnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            indirectColumnExclusions = Pattern.compile(strExclusions);\n        }\n        return indirectColumnExclusions;\n    }\n\n    /**\n     * Set the tables to include as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableInclusions(String tableInclusions) {\n        this.tableInclusions = Pattern.compile(tableInclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to include in the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableInclusions() {\n        if (tableInclusions == null) {\n            String strInclusions = pullParam(\"-i\");\n            if (strInclusions == null)\n                strInclusions = System.getenv(\"schemaspy.tableInclusions\");\n            if (strInclusions == null)\n                strInclusions = DEFAULT_TABLE_INCLUSION;\n            try {\n                tableInclusions = Pattern.compile(strInclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-i\");\n            }\n        }\n        return tableInclusions;\n    }\n\n    /**\n     * Set the tables to exclude as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableExclusions(String tableExclusions) {\n        this.tableExclusions = Pattern.compile(tableExclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to exclude from the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableExclusions() {\n        if (tableExclusions == null) {\n            String strExclusions = pullParam(\"-I\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.tableExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_TABLE_EXCLUSION;\n            try {\n                tableExclusions = Pattern.compile(strExclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-I\");\n            }\n        }\n        return tableExclusions;\n    }\n\n    /**\n     * @return\n     */\n    public List<String> getSchemas() {\n        if (schemas == null) {\n            String tmp = pullParam(\"-schemas\");\n            if (tmp == null)\n                tmp = pullParam(\"-schemata\");\n            if (tmp != null) {\n                schemas = new ArrayList<String>();\n                for (String name : tmp.split(\"[\\\\s,'\\\"]\")) {\n                    if (name.length() > 0)\n                        schemas.add(name);\n                }\n                if (schemas.isEmpty())\n                    schemas = null;\n            }\n        }\n        return schemas;\n    }\n\n    /**\n     * Set the name of the {@link SqlFormatter SQL formatter} class to use to\n     * format SQL into HTML.<p/>\n     * The implementation of the class must be made available to the class\n     * loader, typically by specifying the path to its jar with <em>-dp</em>\n     * ({@link #setDriverPath(String)}).\n     */\n    public void setSqlFormatter(String formatterClassName) {\n        sqlFormatterClass = formatterClassName;\n        sqlFormatter = null;\n    }\n\n    /**\n     * Set the {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.\n     */\n    public void setSqlFormatter(SqlFormatter sqlFormatter) {\n        this.sqlFormatter = sqlFormatter;\n        if (sqlFormatter != null)\n            sqlFormatterClass = sqlFormatter.getClass().getName();\n    }\n\n    /**\n     * Returns an implementation of {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.  The default implementation is {@link DefaultSqlFormatter}.\n     *\n     * @return\n     * @throws InvalidConfigurationException if unable to instantiate an instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SqlFormatter getSqlFormatter() throws InvalidConfigurationException {\n        if (sqlFormatter == null) {\n            if (sqlFormatterClass == null) {\n                sqlFormatterClass = pullParam(\"-sqlFormatter\");\n                if (sqlFormatterClass == null)\n                    sqlFormatterClass = DefaultSqlFormatter.class.getName();\n            }\n            try {\n                Class<SqlFormatter> clazz = (Class<SqlFormatter>) Class.forName(sqlFormatterClass);\n                sqlFormatter = clazz.newInstance();\n            } catch (Exception exc) {\n                throw new InvalidConfigurationException(\"Failed to initialize instance of SQL formatter: \", exc).setParamName(\"-sqlFormatter\");\n            }\n        }\n        return sqlFormatter;\n    }\n\n    /**\n     * Set the details to show on the columns page, where \"details\" are\n     * comma and/or space separated.\n     *\n     * Valid values:\n     * <ul>\n     * <li>id</li>\n     * <li>table</li>\n     * <li>column</li>\n     * <li>type</li>\n     * <li>size</li>\n     * <li>nulls</li>\n     * <li>auto</li>\n     * <li>default</li>\n     * <li>children</li>\n     * <li>parents</li>\n     * </ul>\n     *\n     * The default details are <code>\"table column type size nulls auto default\"</code>.\n     * Note that \"column\" is the initially displayed detail and must be included.\n     *\n     * @param columnDetails\n     */\n    public void setColumnDetails(String columnDetails) {\n        this.columnDetails = new ArrayList<String>();\n        if (columnDetails == null || columnDetails.length() == 0) {\n            // not specified, so use defaults\n            columnDetails = \"id table column type size nulls auto default\";\n        }\n        for (String detail : columnDetails.split(\"[\\\\s,'\\\"]\")) {\n            if (detail.length() > 0) {\n                this.columnDetails.add(detail.toLowerCase());\n            }\n        }\n        if (!this.columnDetails.contains(\"column\"))\n            throw new InvalidConfigurationException(\"'column' is a required column detail\");\n    }\n\n    public void setColumnDetails(List<String> columnDetails) {\n        String details = columnDetails == null ? \"[]\" : columnDetails.toString();\n        setColumnDetails(details.substring(1, details.length() - 1));\n    }\n\n    public List<String> getColumnDetails() {\n        if (columnDetails == null) {\n            setColumnDetails(pullParam(\"-columndetails\"));\n        }\n        return columnDetails;\n    }\n\n    public void setEvaluateAllEnabled(boolean enabled) {\n        evaluteAll = enabled;\n    }\n\n    public boolean isEvaluateAllEnabled() {\n        if (evaluteAll == null)\n            evaluteAll = options.remove(\"-all\");\n        return evaluteAll;\n    }\n\n    /**\n     * Returns true if we're evaluating a bunch of schemas in one go and\n     * at this point we're evaluating a specific schema.\n     *\n     * @return boolean\n     */\n    public boolean isOneOfMultipleSchemas() {\n        // set by MultipleSchemaAnalyzer\n        return Boolean.getBoolean(\"oneofmultipleschemas\");\n    }\n\n    /**\n     * When -all (evaluateAll) is specified then this is the regular\n     * expression that determines which schemas to evaluate.\n     *\n     * @param schemaSpec\n     */\n    public void setSchemaSpec(String schemaSpec) {\n        this.schemaSpec = schemaSpec;\n    }\n\n    public String getSchemaSpec() {\n        if (schemaSpec == null)\n            schemaSpec = pullParam(\"-schemaSpec\");\n        return schemaSpec;\n    }\n\n    /**\n     * Set the renderer to use for the -Tpng[:renderer[:formatter]] dot option as specified\n     * at <a href='http://www.graphviz.org/doc/info/command.html'>\n     * http://www.graphviz.org/doc/info/command.html</a>.<p>\n     * Note that the leading \":\" is required while :formatter is optional.<p>\n     * The default renderer is typically GD.<p>\n     * Note that using {@link #setHighQuality(boolean)} is the preferred approach\n     * over using this method.\n     */\n    public void setRenderer(String renderer) {\n        Dot.getInstance().setRenderer(renderer);\n    }\n\n    /**\n     * @see #setRenderer(String)\n     * @return\n     */\n    public String getRenderer() {\n        String renderer = pullParam(\"-renderer\");\n        if (renderer != null)\n            setRenderer(renderer);\n        return Dot.getInstance().getRenderer();\n    }\n\n    /**\n     * If <code>false</code> then generate output of \"lower quality\"\n     * than the default.\n     * Note that the default is intended to be \"higher quality\",\n     * but various installations of Graphviz may have have different abilities.\n     * That is, some might not have the \"lower quality\" libraries and others might\n     * not have the \"higher quality\" libraries.<p>\n     * Higher quality output takes longer to generate and results in significantly\n     * larger image files (which take longer to download / display), but it generally\n     * looks better.\n     */\n    public void setHighQuality(boolean highQuality) {\n        this.highQuality = highQuality;\n        lowQuality = !highQuality;\n        Dot.getInstance().setHighQuality(highQuality);\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isHighQuality() {\n        if (highQuality == null) {\n            highQuality = options.remove(\"-hq\");\n            if (highQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(highQuality);\n            }\n        }\n        highQuality = Dot.getInstance().isHighQuality();\n        return highQuality;\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isLowQuality() {\n        if (lowQuality == null) {\n            lowQuality = options.remove(\"-lq\");\n            if (lowQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(!lowQuality);\n            }\n        }\n        lowQuality = !Dot.getInstance().isHighQuality();\n        return lowQuality;\n    }\n\n    /**\n     * Set the level of logging to perform.<p/>\n     * The levels in descending order are:\n     * <ul>\n     *  <li><code>severe</code> (highest - least detail)\n     *  <li><code>warning</code> (default)\n     *  <li><code>info</code>\n     *  <li><code>config</code>\n     *  <li><code>fine</code>\n     *  <li><code>finer</code>\n     *  <li><code>finest</code>  (lowest - most detail)\n     * </ul>\n     *\n     * @param logLevel\n     */\n    public void setLogLevel(String logLevel) {\n        if (logLevel == null) {\n            this.logLevel = Level.WARNING;\n            return;\n        }\n        Map<String, Level> levels = new LinkedHashMap<String, Level>();\n        levels.put(\"severe\", Level.SEVERE);\n        levels.put(\"warning\", Level.WARNING);\n        levels.put(\"info\", Level.INFO);\n        levels.put(\"config\", Level.CONFIG);\n        levels.put(\"fine\", Level.FINE);\n        levels.put(\"finer\", Level.FINER);\n        levels.put(\"finest\", Level.FINEST);\n        this.logLevel = levels.get(logLevel.toLowerCase());\n        if (this.logLevel == null) {\n            throw new InvalidConfigurationException(\"Invalid logLevel: '\" + logLevel + \"'. Must be one of: \" + levels.keySet());\n        }\n    }\n\n    /**\n     * Returns the level of logging to perform.\n     * See {@link #setLogLevel(String)}.\n     *\n     * @return\n     */\n    public Level getLogLevel() {\n        if (logLevel == null) {\n            setLogLevel(pullParam(\"-loglevel\"));\n        }\n        return logLevel;\n    }\n\n    /**\n     * Returns <code>true</code> if the options indicate that the user wants\n     * to see some help information.\n     *\n     * @return\n     */\n    public boolean isHelpRequired() {\n        return helpRequired;\n    }\n\n    public boolean isDbHelpRequired() {\n        return dbHelpRequired;\n    }\n\n    /**\n     * Returns the jar that we were loaded from\n     *\n     * @return\n     */\n    public static String getLoadedFromJar() {\n        String classpath = System.getProperty(\"java.class.path\");\n        return new StringTokenizer(classpath, File.pathSeparator).nextToken();\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasOrphans(boolean hasOrphans) {\n        this.hasOrphans = hasOrphans;\n    }\n\n    /**\n     * @see #setHasOrphans()\n     *\n     * @return\n     */\n    public boolean hasOrphans() {\n        return hasOrphans;\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasRoutines(boolean hasRoutines) {\n        this.hasRoutines = hasRoutines;\n    }\n\n    /**\n     * @see #setHasRoutines()\n     *\n     * @return\n     */\n    public boolean hasRoutines() {\n        return hasRoutines;\n    }\n\n    /**\n     * Returns the database properties to use.\n     * These should be determined by calling {@link #determineDbProperties(String)}.\n     * @return\n     * @throws InvalidConfigurationException\n     */\n    public Properties getDbProperties() throws InvalidConfigurationException {\n        if (dbProperties == null) {\n            try {\n                dbProperties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(exc);\n            }\n        }\n        return dbProperties;\n    }\n\n    /**\n     * Determines the database properties associated with the specified type.\n     * A call to {@link #setDbProperties(Properties)} is expected after determining\n     * the complete set of properties.\n     *\n     * @param type\n     * @return\n     * @throws IOException\n     * @throws InvalidConfigurationException if db properties are incorrectly formed\n     */\n    public Properties determineDbProperties(String type) throws IOException, InvalidConfigurationException {\n        ResourceBundle bundle = null;\n        try {\n            File propertiesFile = new File(type);\n            bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n            dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n        } catch (FileNotFoundException notFoundOnFilesystemWithoutExtension) {\n            try {\n                File propertiesFile = new File(type + \".properties\");\n                bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n                dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n            } catch (FileNotFoundException notFoundOnFilesystemWithExtensionTackedOn) {\n                try {\n                    bundle = ResourceBundle.getBundle(type);\n                    dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]\" + File.separator + type + \".properties\";\n                } catch (Exception notInJarWithoutPath) {\n                    try {\n                        String path = TableOrderer.class.getPackage().getName() + \".dbTypes.\" + type;\n                        path = path.replace('.', '/');\n                        bundle = ResourceBundle.getBundle(path);\n                        dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]/\" + path + \".properties\";\n                    } catch (Exception notInJar) {\n                        notInJar.printStackTrace();\n                        notFoundOnFilesystemWithExtensionTackedOn.printStackTrace();\n                        throw notFoundOnFilesystemWithoutExtension;\n                    }\n                }\n            }\n        }\n        Properties props = asProperties(bundle);\n        bundle = null;\n        // keep original thru recursion\n        String saveLoadedFrom = dbPropertiesLoadedFrom;\n        // bring in key/values pointed to by the include directive\n        // example: include.1=mysql::selectRowCountSql\n        for (int i = 1; true; ++i) {\n            String include = (String) props.remove(\"include.\" + i);\n            if (include == null)\n                break;\n            int separator = include.indexOf(\"::\");\n            if (separator == -1)\n                throw new InvalidConfigurationException(\"include directive in \" + dbPropertiesLoadedFrom + \" must have '::' between dbType and key\");\n            String refdType = include.substring(0, separator).trim();\n            String refdKey = include.substring(separator + 2).trim();\n            // recursively resolve the ref'd properties file and the ref'd key\n            Properties refdProps = determineDbProperties(refdType);\n            props.put(refdKey, refdProps.getProperty(refdKey));\n        }\n        // bring in base properties files pointed to by the extends directive\n        String baseDbType = (String) props.remove(\"extends\");\n        if (baseDbType != null) {\n            baseDbType = baseDbType.trim();\n            Properties baseProps = determineDbProperties(baseDbType);\n            // overlay our properties on top of the base's\n            baseProps.putAll(props);\n            props = baseProps;\n        }\n        // done with this level of recursion...restore original\n        dbPropertiesLoadedFrom = saveLoadedFrom;\n        // this won't be correct until the final recursion exits\n        dbProperties = props;\n        return props;\n    }\n\n    protected String getDbPropertiesLoadedFrom() throws IOException {\n        if (dbPropertiesLoadedFrom == null)\n            determineDbProperties(getDbType());\n        return dbPropertiesLoadedFrom;\n    }\n\n    public List<String> getRemainingParameters() {\n        try {\n            populate();\n        } catch (IllegalArgumentException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (IllegalAccessException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (InvocationTargetException exc) {\n            if (exc.getCause() instanceof InvalidConfigurationException)\n                throw (InvalidConfigurationException) exc.getCause();\n            throw new InvalidConfigurationException(exc.getCause());\n        } catch (IntrospectionException exc) {\n            throw new InvalidConfigurationException(exc);\n        }\n        return options;\n    }\n\n    /**\n     * Options that are specific to a type of database.  E.g. things like <code>host</code>,\n     * <code>port</code> or <code>db</code>, but <b>don't</b> have a setter in this class.\n     *\n     * @param dbSpecificOptions\n     */\n    public void setDbSpecificOptions(Map<String, String> dbSpecificOptions) {\n        this.dbSpecificOptions = dbSpecificOptions;\n        originalDbSpecificOptions = new HashMap<String, String>(dbSpecificOptions);\n    }\n\n    public Map<String, String> getDbSpecificOptions() {\n        if (dbSpecificOptions == null)\n            dbSpecificOptions = new HashMap<String, String>();\n        return dbSpecificOptions;\n    }\n\n    /**\n     * Returns a {@link Properties} populated with the contents of <code>bundle</code>\n     *\n     * @param bundle ResourceBundle\n     * @return Properties\n     */\n    public static Properties asProperties(ResourceBundle bundle) {\n        Properties props = new Properties();\n        Enumeration<String> iter = bundle.getKeys();\n        while (iter.hasMoreElements()) {\n            String key = iter.nextElement();\n            props.put(key, bundle.getObject(key));\n        }\n        return props;\n    }\n\n    /**\n     * 'Pull' the specified parameter from the collection of options. Returns\n     * null if the parameter isn't in the list and removes it if it is.\n     *\n     * @param paramId\n     * @return\n     */\n    private String pullParam(String paramId) {\n        return pullParam(paramId, false, false);\n    }\n\n    private String pullRequiredParam(String paramId) {\n        return pullParam(paramId, true, false);\n    }\n\n    /**\n     * @param paramId\n     * @param required\n     * @param dbTypeSpecific\n     * @return\n     * @throws MissingRequiredParameterException\n     */\n    private String pullParam(String paramId, boolean required, boolean dbTypeSpecific) throws MissingRequiredParameterException {\n        int paramIndex = options.indexOf(paramId);\n        if (paramIndex < 0) {\n            if (required)\n                throw new MissingRequiredParameterException(paramId, dbTypeSpecific);\n            return null;\n        }\n        options.remove(paramIndex);\n        String param = options.get(paramIndex).toString();\n        options.remove(paramIndex);\n        return param;\n    }\n\n    /**\n     * Thrown to indicate that a required parameter is missing\n     */\n    public static class MissingRequiredParameterException extends RuntimeException {\n\n        private static final long serialVersionUID = 1L;\n\n        private final boolean dbTypeSpecific;\n\n        public MissingRequiredParameterException(String paramId, boolean dbTypeSpecific) {\n            this(paramId, null, dbTypeSpecific);\n        }\n\n        public MissingRequiredParameterException(String paramId, String description, boolean dbTypeSpecific) {\n            super(\"Required parameter '\" + paramId + \"' \" + (description == null ? \"\" : \"(\" + description + \") \") + \"was not specified.\" + (dbTypeSpecific ? \"  It is required for this database type.\" : \"\"));\n            this.dbTypeSpecific = dbTypeSpecific;\n        }\n\n        public boolean isDbTypeSpecific() {\n            return dbTypeSpecific;\n        }\n    }\n\n    /**\n     * Allow an equal sign in args...like \"-o=foo.bar\". Useful for things like\n     * Ant and Maven.\n     *\n     * @param args\n     *            List\n     * @return List\n     */\n    protected List<String> fixupArgs(List<String> args) {\n        List<String> expandedArgs = new ArrayList<String>();\n        for (String arg : args) {\n            int indexOfEquals = arg.indexOf('=');\n            if (indexOfEquals != -1 && indexOfEquals - 1 != arg.indexOf(ESCAPED_EQUALS)) {\n                expandedArgs.add(arg.substring(0, indexOfEquals));\n                expandedArgs.add(arg.substring(indexOfEquals + 1));\n            } else {\n                expandedArgs.add(arg);\n            }\n        }\n        // some OSes/JVMs do filename expansion with runtime.exec() and some don't,\n        // so MultipleSchemaAnalyzer has to surround params with double quotes...\n        // strip them here for the OSes/JVMs that don't do anything with the params\n        List<String> unquotedArgs = new ArrayList<String>();\n        for (String arg : expandedArgs) {\n            if (// \".*\" becomes .*\n            arg.startsWith(\"\\\"\") && arg.endsWith(\"\\\"\"))\n                arg = arg.substring(1, arg.length() - 1);\n            unquotedArgs.add(arg);\n        }\n        return unquotedArgs;\n    }\n\n    /**\n     * Call all the getters to populate all the lazy initialized stuff.\n     *\n     * @throws InvocationTargetException\n     * @throws IllegalAccessException\n     * @throws IllegalArgumentException\n     * @throws IntrospectionException\n     */\n    private void populate() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IntrospectionException {\n        if (!populating) {\n            // prevent recursion\n            populating = true;\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                Method readMethod = props[i].getReadMethod();\n                if (readMethod != null)\n                    readMethod.invoke(this, (Object[]) null);\n            }\n            populating = false;\n        }\n    }\n\n    public static Set<String> getBuiltInDatabaseTypes(String loadedFromJar) {\n        Set<String> databaseTypes = new TreeSet<String>();\n        JarInputStream jar = null;\n        try {\n            jar = new JarInputStream(new FileInputStream(loadedFromJar));\n            JarEntry entry;\n            while ((entry = jar.getNextJarEntry()) != null) {\n                String entryName = entry.getName();\n                int dotPropsIndex = entryName.indexOf(\".properties\");\n                if (dotPropsIndex != -1)\n                    databaseTypes.add(entryName.substring(0, dotPropsIndex));\n            }\n        } catch (IOException exc) {\n        } finally {\n            if (jar != null) {\n                try {\n                    jar.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n        return databaseTypes;\n    }\n\n    protected void dumpUsage(String errorMessage, boolean detailedDb) {\n        if (errorMessage != null) {\n            System.out.flush();\n            System.err.println(\"*** \" + errorMessage + \" ***\");\n        } else {\n            System.out.println(\"SchemaSpy generates an HTML representation of a database schema's relationships.\");\n        }\n        System.err.flush();\n        System.out.println();\n        if (!detailedDb) {\n            System.out.println(\"Usage:\");\n            System.out.println(\" java -jar \" + getLoadedFromJar() + \" [options]\");\n            System.out.println(\"   -t databaseType       type of database - defaults to ora\");\n            System.out.println(\"                           use -dbhelp for a list of built-in types\");\n            System.out.println(\"   -u user               connect to the database with this user id\");\n            System.out.println(\"   -s schema             defaults to the specified user\");\n            System.out.println(\"   -p password           defaults to no password\");\n            System.out.println(\"   -o outputDirectory    directory to place the generated output in\");\n            System.out.println(\"   -dp pathToDrivers     optional - looks for JDBC drivers here before looking\");\n            System.out.println(\"                           in driverPath in [databaseType].properties.\");\n            System.out.println(\"Go to http://schemaspy.sourceforge.net for a complete list/description\");\n            System.out.println(\" of additional parameters.\");\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"Built-in database types and their required connection parameters:\");\n            for (String type : getBuiltInDatabaseTypes(getLoadedFromJar())) {\n                new DbSpecificConfig(type).dumpUsage();\n            }\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"You can use your own database types by specifying the filespec of a .properties file with -t.\");\n            System.out.println(\"Grab one out of \" + getLoadedFromJar() + \" and modify it to suit your needs.\");\n            System.out.println();\n        }\n        System.out.println(\"Sample usage using the default database type (implied -t ora):\");\n        System.out.println(\" java -jar schemaSpy.jar -db mydb -s myschema -u devuser -p password -o output\");\n        System.out.println();\n        System.out.flush();\n    }\n\n    /**\n     * Get the value of the specified parameter.\n     * Used for properties that are common to most db's, but aren't required.\n     *\n     * @param paramName\n     * @return\n     */\n    public String getParam(String paramName) {\n        try {\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                PropertyDescriptor prop = props[i];\n                if (prop.getName().equalsIgnoreCase(paramName)) {\n                    Object result = prop.getReadMethod().invoke(this, (Object[]) null);\n                    return result == null ? null : result.toString();\n                }\n            }\n        } catch (Exception failed) {\n            failed.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * Return all of the configuration options as a List of Strings, with\n     * each parameter and its value as a separate element.\n     *\n     * @return\n     * @throws IOException\n     */\n    public List<String> asList() throws IOException {\n        List<String> params = new ArrayList<String>();\n        if (originalDbSpecificOptions != null) {\n            for (String key : originalDbSpecificOptions.keySet()) {\n                String value = originalDbSpecificOptions.get(key);\n                if (!key.startsWith(\"-\"))\n                    key = \"-\" + key;\n                params.add(key);\n                params.add(value);\n            }\n        }\n        if (isEncodeCommentsEnabled())\n            params.add(\"-ahic\");\n        if (isEvaluateAllEnabled())\n            params.add(\"-all\");\n        if (!isHtmlGenerationEnabled())\n            params.add(\"-nohtml\");\n        if (!isImpliedConstraintsEnabled())\n            params.add(\"-noimplied\");\n        if (!isLogoEnabled())\n            params.add(\"-nologo\");\n        if (isMeterEnabled())\n            params.add(\"-meter\");\n        if (!isNumRowsEnabled())\n            params.add(\"-norows\");\n        if (!isViewsEnabled())\n            params.add(\"-noviews\");\n        if (isRankDirBugEnabled())\n            params.add(\"-rankdirbug\");\n        if (isRailsEnabled())\n            params.add(\"-rails\");\n        if (isSingleSignOn())\n            params.add(\"-sso\");\n        if (isSchemaDisabled())\n            params.add(\"-noschema\");\n        String value = getDriverPath();\n        if (value != null) {\n            params.add(\"-dp\");\n            params.add(value);\n        }\n        params.add(\"-css\");\n        params.add(getCss());\n        params.add(\"-charset\");\n        params.add(getCharset());\n        params.add(\"-font\");\n        params.add(getFont());\n        params.add(\"-fontsize\");\n        params.add(String.valueOf(getFontSize()));\n        params.add(\"-t\");\n        params.add(getDbType());\n        // query to set renderer correctly\n        isHighQuality();\n        // query to set renderer correctly\n        isLowQuality();\n        // instead of -hq and/or -lq\n        params.add(\"-renderer\");\n        params.add(getRenderer());\n        value = getDescription();\n        if (value != null) {\n            params.add(\"-desc\");\n            params.add(value);\n        }\n        value = getPassword();\n        if (value != null && !isPromptForPasswordEnabled()) {\n            // note that we don't pass -pfp since child processes\n            // won't have a console\n            params.add(\"-p\");\n            params.add(value);\n        }\n        value = getCatalog();\n        if (value != null) {\n            params.add(\"-cat\");\n            params.add(value);\n        }\n        value = getSchema();\n        if (value != null) {\n            params.add(\"-s\");\n            params.add(value);\n        }\n        value = getUser();\n        if (value != null) {\n            params.add(\"-u\");\n            params.add(value);\n        }\n        value = getConnectionPropertiesFile();\n        if (value != null) {\n            params.add(\"-connprops\");\n            params.add(value);\n        } else {\n            Properties props = getConnectionProperties();\n            if (!props.isEmpty()) {\n                params.add(\"-connprops\");\n                StringBuilder buf = new StringBuilder();\n                for (Entry<Object, Object> entry : props.entrySet()) {\n                    buf.append(entry.getKey());\n                    buf.append(ESCAPED_EQUALS);\n                    buf.append(entry.getValue());\n                    buf.append(';');\n                }\n                params.add(buf.toString());\n            }\n        }\n        value = getDb();\n        if (value != null) {\n            params.add(\"-db\");\n            params.add(value);\n        }\n        value = getHost();\n        if (value != null) {\n            params.add(\"-host\");\n            params.add(value);\n        }\n        if (getPort() != null) {\n            params.add(\"-port\");\n            params.add(getPort().toString());\n        }\n        value = getServer();\n        if (value != null) {\n            params.add(\"-server\");\n            params.add(value);\n        }\n        value = getMeta();\n        if (value != null) {\n            params.add(\"-meta\");\n            params.add(value);\n        }\n        if (getGraphvizDir() != null) {\n            params.add(\"-gv\");\n            params.add(getGraphvizDir().toString());\n        }\n        params.add(\"-loglevel\");\n        params.add(getLogLevel().toString().toLowerCase());\n        params.add(\"-sqlFormatter\");\n        params.add(getSqlFormatter().getClass().getName());\n        params.add(\"-i\");\n        params.add(getTableInclusions().toString());\n        params.add(\"-I\");\n        params.add(getTableExclusions().toString());\n        params.add(\"-X\");\n        params.add(getColumnExclusions().toString());\n        params.add(\"-x\");\n        params.add(getIndirectColumnExclusions().toString());\n        params.add(\"-dbthreads\");\n        params.add(String.valueOf(getMaxDbThreads()));\n        params.add(\"-maxdet\");\n        params.add(String.valueOf(getMaxDetailedTables()));\n        params.add(\"-o\");\n        params.add(getOutputDir().toString());\n        return params;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/ConfigTest4.java",
		"test_prompt": "// ConfigTest4.java\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Config}.\n* It contains ten unit test cases for the {@link Config#isSingleSignOn()} method.\n*/\nclass ConfigTest4 {"
	},
	{
		"original_code": "// Config.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\n\n/**\n * Configuration of a SchemaSpy run\n *\n * @author John Currier\n */\npublic class Config {\n\n    private static Config instance;\n\n    private final List<String> options;\n\n    private Map<String, String> dbSpecificOptions;\n\n    private Map<String, String> originalDbSpecificOptions;\n\n    private boolean helpRequired;\n\n    private boolean dbHelpRequired;\n\n    private File outputDir;\n\n    private File graphvizDir;\n\n    private String dbType;\n\n    private String catalog;\n\n    private String schema;\n\n    private List<String> schemas;\n\n    private String user;\n\n    private Boolean singleSignOn;\n\n    private Boolean noSchema;\n\n    private String password;\n\n    private Boolean promptForPassword;\n\n    private String db;\n\n    private String host;\n\n    private Integer port;\n\n    private String server;\n\n    private String meta;\n\n    private Pattern tableInclusions;\n\n    private Pattern tableExclusions;\n\n    private Pattern columnExclusions;\n\n    private Pattern indirectColumnExclusions;\n\n    private String userConnectionPropertiesFile;\n\n    private Properties userConnectionProperties;\n\n    private Integer maxDbThreads;\n\n    private Integer maxDetailedTables;\n\n    private String driverPath;\n\n    private String css;\n\n    private String charset;\n\n    private String font;\n\n    private Integer fontSize;\n\n    private String description;\n\n    private Properties dbProperties;\n\n    private String dbPropertiesLoadedFrom;\n\n    private Level logLevel;\n\n    private SqlFormatter sqlFormatter;\n\n    private String sqlFormatterClass;\n\n    private Boolean generateHtml;\n\n    private Boolean includeImpliedConstraints;\n\n    private Boolean logoEnabled;\n\n    private Boolean rankDirBugEnabled;\n\n    private Boolean encodeCommentsEnabled;\n\n    private Boolean numRowsEnabled;\n\n    private Boolean viewsEnabled;\n\n    private Boolean meterEnabled;\n\n    private Boolean railsEnabled;\n\n    private Boolean evaluteAll;\n\n    private Boolean highQuality;\n\n    private Boolean lowQuality;\n\n    // used in conjunction with evaluateAll\n    private String schemaSpec;\n\n    private boolean hasOrphans = false;\n\n    private boolean hasRoutines = false;\n\n    private boolean populating = false;\n\n    private List<String> columnDetails;\n\n    public static final String DOT_CHARSET = \"UTF-8\";\n\n    private static final String ESCAPED_EQUALS = \"\\\\=\";\n\n    // match everything\n    private static final String DEFAULT_TABLE_INCLUSION = \".*\";\n\n    // match nothing\n    private static final String DEFAULT_TABLE_EXCLUSION = \"\";\n\n    // match nothing\n    private static final String DEFAULT_COLUMN_EXCLUSION = \"[^.]\";\n\n    /**\n     * Default constructor. Intended for when you want to inject properties\n     * independently (i.e. not from a command line interface).\n     */\n    public Config() {\n        if (instance == null)\n            setInstance(this);\n        options = new ArrayList<String>();\n    }\n\n    /**\n     * Construct a configuration from an array of options (e.g. from a command\n     * line interface).\n     *\n     * @param options\n     */\n    public Config(String[] argv) {\n        setInstance(this);\n        options = fixupArgs(Arrays.asList(argv));\n        helpRequired = options.remove(\"-?\") || options.remove(\"/?\") || options.remove(\"?\") || options.remove(\"-h\") || options.remove(\"-help\") || options.remove(\"--help\");\n        dbHelpRequired = options.remove(\"-dbHelp\") || options.remove(\"-dbhelp\");\n    }\n\n    public static Config getInstance() {\n        if (instance == null)\n            instance = new Config();\n        return instance;\n    }\n\n    /**\n     * Sets the global instance.\n     *\n     * Useful for things like selecting a specific configuration in a UI.\n     *\n     * @param config\n     */\n    public static void setInstance(Config config) {\n        instance = config;\n    }\n\n    public void setHtmlGenerationEnabled(boolean generateHtml) {\n        this.generateHtml = generateHtml;\n    }\n\n    public boolean isHtmlGenerationEnabled() {\n        if (generateHtml == null)\n            generateHtml = !options.remove(\"-nohtml\");\n        return generateHtml;\n    }\n\n    public void setImpliedConstraintsEnabled(boolean includeImpliedConstraints) {\n        this.includeImpliedConstraints = includeImpliedConstraints;\n    }\n\n    public boolean isImpliedConstraintsEnabled() {\n        if (includeImpliedConstraints == null)\n            includeImpliedConstraints = !options.remove(\"-noimplied\");\n        return includeImpliedConstraints;\n    }\n\n    public void setOutputDir(String outputDirName) {\n        if (outputDirName.endsWith(\"\\\"\"))\n            outputDirName = outputDirName.substring(0, outputDirName.length() - 1);\n        setOutputDir(new File(outputDirName));\n    }\n\n    public void setOutputDir(File outputDir) {\n        this.outputDir = outputDir;\n    }\n\n    public File getOutputDir() {\n        if (outputDir == null) {\n            setOutputDir(pullRequiredParam(\"-o\"));\n        }\n        return outputDir;\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(String graphvizDir) {\n        if (graphvizDir.endsWith(\"\\\"\"))\n            graphvizDir = graphvizDir.substring(0, graphvizDir.length() - 1);\n        setGraphvizDir(new File(graphvizDir));\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(File graphvizDir) {\n        this.graphvizDir = graphvizDir;\n    }\n\n    /**\n     * Return the path to Graphviz (used to find the dot executable to run to\n     * generate ER diagrams).<p/>\n     *\n     * Returns {@link #getDefaultGraphvizPath()} if a specific Graphviz path\n     * was not specified.\n     *\n     * @return\n     */\n    public File getGraphvizDir() {\n        if (graphvizDir == null) {\n            String gv = pullParam(\"-gv\");\n            if (gv != null) {\n                setGraphvizDir(gv);\n            } else {\n                // expect to find Graphviz's bin directory on the PATH\n            }\n        }\n        return graphvizDir;\n    }\n\n    /**\n     * Meta files are XML-based files that provide additional metadata\n     * about the schema being evaluated.<p>\n     * <code>meta</code> is either the name of an individual XML file or\n     * the directory that contains meta files.<p>\n     * If a directory is specified then it is expected to contain files\n     * matching the pattern <code>[schema].meta.xml</code>.\n     * For databases that don't have schema substitute database for schema.\n     * @param meta\n     */\n    public void setMeta(String meta) {\n        this.meta = meta;\n    }\n\n    public String getMeta() {\n        if (meta == null)\n            meta = pullParam(\"-meta\");\n        return meta;\n    }\n\n    public void setDbType(String dbType) {\n        this.dbType = dbType;\n    }\n\n    public String getDbType() {\n        if (dbType == null) {\n            dbType = pullParam(\"-t\");\n            if (dbType == null)\n                dbType = \"ora\";\n        }\n        return dbType;\n    }\n\n    public void setDb(String db) {\n        this.db = db;\n    }\n\n    public String getDb() {\n        if (db == null)\n            db = pullParam(\"-db\");\n        return db;\n    }\n\n    public void setCatalog(String catalog) {\n        this.catalog = catalog;\n    }\n\n    public String getCatalog() {\n        if (catalog == null)\n            catalog = pullParam(\"-cat\");\n        return catalog;\n    }\n\n    public void setSchema(String schema) {\n        this.schema = schema;\n    }\n\n    public String getSchema() {\n        if (schema == null)\n            schema = pullParam(\"-s\");\n        return schema;\n    }\n\n    /**\n     * Some databases types (e.g. older versions of Informix) don't really\n     * have the concept of a schema but still return true from\n     * {@link DatabaseMetaData#supportsSchemasInTableDefinitions()}.\n     * This option lets you ignore that and treat all the tables\n     * as if they were in one flat namespace.\n     */\n    public boolean isSchemaDisabled() {\n        if (noSchema == null)\n            noSchema = options.remove(\"-noschema\");\n        return noSchema;\n    }\n\n    public void setHost(String host) {\n        this.host = host;\n    }\n\n    public String getHost() {\n        if (host == null)\n            host = pullParam(\"-host\");\n        return host;\n    }\n\n    public void setPort(Integer port) {\n        this.port = port;\n    }\n\n    public Integer getPort() {\n        if (port == null)\n            try {\n                port = Integer.valueOf(pullParam(\"-port\"));\n            } catch (Exception notSpecified) {\n            }\n        return port;\n    }\n\n    public void setServer(String server) {\n        this.server = server;\n    }\n\n    public String getServer() {\n        if (server == null) {\n            server = pullParam(\"-server\");\n        }\n        return server;\n    }\n\n    public void setUser(String user) {\n        this.user = user;\n    }\n\n    /**\n     * User used to connect to the database.\n     * Required unless single sign-on is enabled\n     * (see {@link #setSingleSignOn(boolean)}).\n     * @return\n     */\n    public String getUser() {\n        if (user == null) {\n            if (!isSingleSignOn())\n                user = pullRequiredParam(\"-u\");\n            else\n                user = pullParam(\"-u\");\n        }\n        return user;\n    }\n\n    /**\n     * By default a \"user\" (as specified with -u) is required.\n     * This option allows disabling of that requirement for\n     * single sign-on environments.\n     *\n     * @param enabled defaults to <code>false</code>\n     */\n    public void setSingleSignOn(boolean enabled) {\n        singleSignOn = enabled;\n    }\n\n    /**\n     * @see #setSingleSignOn(boolean)\n     */\n    public boolean isSingleSignOn() {\n        if (singleSignOn == null)\n            singleSignOn = options.remove(\"-sso\");\n        return singleSignOn;\n    }\n\n    /**\n     * Set the password used to connect to the database.\n     * @param password\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * @see #setPassword(String)\n     * @return\n     */\n    public String getPassword() {\n        if (password == null)\n            password = pullParam(\"-p\");\n        if (password == null && isPromptForPasswordEnabled())\n            password = new String(PasswordReader.getInstance().readPassword(\"Password: \"));\n        if (password == null) {\n            // if -pfp is enabled when analyzing multiple schemas then\n            // we don't want to send the password on the command line,\n            // so see if it was passed in the environment (not ideal, but safer)\n            password = System.getenv(\"schemaspy.pw\");\n        }\n        return password;\n    }\n\n    /**\n     * Set to <code>true</code> to prompt for the password\n     * @param promptForPassword\n     */\n    public void setPromptForPasswordEnabled(boolean promptForPassword) {\n        this.promptForPassword = promptForPassword;\n    }\n\n    /**\n     * @see #setPromptForPasswordEnabled(boolean)\n     * @return\n     */\n    public boolean isPromptForPasswordEnabled() {\n        if (promptForPassword == null) {\n            promptForPassword = options.remove(\"-pfp\");\n        }\n        return promptForPassword;\n    }\n\n    public void setMaxDetailedTabled(int maxDetailedTables) {\n        this.maxDetailedTables = new Integer(maxDetailedTables);\n    }\n\n    public int getMaxDetailedTables() {\n        if (maxDetailedTables == null) {\n            // default\n            int max = 300;\n            try {\n                max = Integer.parseInt(pullParam(\"-maxdet\"));\n            } catch (Exception notSpecified) {\n            }\n            maxDetailedTables = new Integer(max);\n        }\n        return maxDetailedTables.intValue();\n    }\n\n    public String getConnectionPropertiesFile() {\n        return userConnectionPropertiesFile;\n    }\n\n    /**\n     * Properties from this file (in key=value pair format) are passed to the\n     * database connection.<br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.\n     * @param propertiesFilename\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public void setConnectionPropertiesFile(String propertiesFilename) throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null)\n            userConnectionProperties = new Properties();\n        userConnectionProperties.load(new FileInputStream(propertiesFilename));\n        userConnectionPropertiesFile = propertiesFilename;\n    }\n\n    /**\n     * Returns a {@link Properties} populated either from the properties file specified\n     * by {@link #setConnectionPropertiesFile(String)}, the properties specified by\n     * {@link #setConnectionProperties(String)} or not populated.\n     * @return\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public Properties getConnectionProperties() throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null) {\n            String props = pullParam(\"-connprops\");\n            if (props != null) {\n                if (props.indexOf(ESCAPED_EQUALS) != -1) {\n                    setConnectionProperties(props);\n                } else {\n                    setConnectionPropertiesFile(props);\n                }\n            } else {\n                userConnectionProperties = new Properties();\n            }\n        }\n        return userConnectionProperties;\n    }\n\n    /**\n     * Specifies connection properties to use in the format:\n     * <code>key1\\=value1;key2\\=value2</code><br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.<p>\n     * This is an alternative form of passing connection properties than by file\n     * (see {@link #setConnectionPropertiesFile(String)})\n     *\n     * @param properties\n     */\n    public void setConnectionProperties(String properties) {\n        userConnectionProperties = new Properties();\n        StringTokenizer tokenizer = new StringTokenizer(properties, \";\");\n        while (tokenizer.hasMoreElements()) {\n            String pair = tokenizer.nextToken();\n            int index = pair.indexOf(ESCAPED_EQUALS);\n            if (index != -1) {\n                String key = pair.substring(0, index);\n                String value = pair.substring(index + ESCAPED_EQUALS.length());\n                userConnectionProperties.put(key, value);\n            }\n        }\n    }\n\n    public void setDriverPath(String driverPath) {\n        this.driverPath = driverPath;\n    }\n\n    public String getDriverPath() {\n        if (driverPath == null)\n            driverPath = pullParam(\"-dp\");\n        // was previously -cp:\n        if (driverPath == null)\n            driverPath = pullParam(\"-cp\");\n        return driverPath;\n    }\n\n    /**\n     * The filename of the cascading style sheet to use.\n     * Note that this file is parsed and used to determine characteristics\n     * of the generated diagrams, so it must contain specific settings that\n     * are documented within schemaSpy.css.<p>\n     *\n     * Defaults to <code>\"schemaSpy.css\"</code>.\n     *\n     * @param css\n     */\n    public void setCss(String css) {\n        this.css = css;\n    }\n\n    public String getCss() {\n        if (css == null) {\n            css = pullParam(\"-css\");\n            if (css == null)\n                css = \"schemaSpy.css\";\n        }\n        return css;\n    }\n\n    /**\n     * The font to use within diagrams.  Modify the .css to specify HTML fonts.\n     *\n     * @param font\n     */\n    public void setFont(String font) {\n        this.font = font;\n    }\n\n    /**\n     * @see #setFont(String)\n     */\n    public String getFont() {\n        if (font == null) {\n            font = pullParam(\"-font\");\n            if (font == null)\n                font = \"Helvetica\";\n        }\n        return font;\n    }\n\n    /**\n     * The font size to use within diagrams.  This is the size of the font used for\n     * 'large' (e.g. not 'compact') diagrams.<p>\n     *\n     * Modify the .css to specify HTML font sizes.<p>\n     *\n     * Defaults to 11.\n     *\n     * @param fontSize\n     */\n    public void setFontSize(int fontSize) {\n        this.fontSize = new Integer(fontSize);\n    }\n\n    /**\n     * @see #setFontSize(int)\n     * @return\n     */\n    public int getFontSize() {\n        if (fontSize == null) {\n            // default\n            int size = 11;\n            try {\n                size = Integer.parseInt(pullParam(\"-fontsize\"));\n            } catch (Exception notSpecified) {\n            }\n            fontSize = new Integer(size);\n        }\n        return fontSize.intValue();\n    }\n\n    /**\n     * The character set to use within HTML pages (defaults to <code>\"ISO-8859-1\"</code>).\n     *\n     * @param charset\n     */\n    public void setCharset(String charset) {\n        this.charset = charset;\n    }\n\n    /**\n     * @see #setCharset(String)\n     */\n    public String getCharset() {\n        if (charset == null) {\n            charset = pullParam(\"-charset\");\n            if (charset == null)\n                charset = \"ISO-8859-1\";\n        }\n        return charset;\n    }\n\n    /**\n     * Description of schema that gets display on main pages.\n     *\n     * @param description\n     */\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    /**\n     * @see #setDescription(String)\n     */\n    public String getDescription() {\n        if (description == null)\n            description = pullParam(\"-desc\");\n        return description;\n    }\n\n    /**\n     * Maximum number of threads to use when querying database metadata information.\n     *\n     * @param maxDbThreads\n     */\n    public void setMaxDbThreads(int maxDbThreads) {\n        this.maxDbThreads = new Integer(maxDbThreads);\n    }\n\n    /**\n     * @see #setMaxDbThreads(int)\n     * @throws InvalidConfigurationException if unable to load properties\n     */\n    public int getMaxDbThreads() throws InvalidConfigurationException {\n        if (maxDbThreads == null) {\n            Properties properties;\n            try {\n                properties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(\"Failed to load properties for \" + getDbType() + \": \" + exc).setParamName(\"-type\");\n            }\n            // not scientifically derived\n            final int defaultMax = 15;\n            int max = defaultMax;\n            String threads = properties.getProperty(\"dbThreads\");\n            if (threads == null)\n                threads = properties.getProperty(\"dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            threads = pullParam(\"-dbThreads\");\n            if (threads == null)\n                threads = pullParam(\"-dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            if (max < 0)\n                max = defaultMax;\n            else if (max == 0)\n                max = 1;\n            maxDbThreads = new Integer(max);\n        }\n        return maxDbThreads.intValue();\n    }\n\n    public boolean isLogoEnabled() {\n        if (logoEnabled == null)\n            logoEnabled = !options.remove(\"-nologo\");\n        return logoEnabled;\n    }\n\n    /**\n     * Don't use this unless absolutely necessary as it screws up the layout\n     *\n     * @param enabled\n     */\n    public void setRankDirBugEnabled(boolean enabled) {\n        rankDirBugEnabled = enabled;\n    }\n\n    /**\n     * @see #setRankDirBugEnabled(boolean)\n     */\n    public boolean isRankDirBugEnabled() {\n        if (rankDirBugEnabled == null)\n            rankDirBugEnabled = options.remove(\"-rankdirbug\");\n        return rankDirBugEnabled;\n    }\n\n    /**\n     * Look for Ruby on Rails-based naming conventions in\n     * relationships between logical foreign keys and primary keys.<p>\n     *\n     * Basically all tables have a primary key named <code>ID</code>.\n     * All tables are named plural names.\n     * The columns that logically reference that <code>ID</code> are the singular\n     * form of the table name suffixed with <code>_ID</code>.<p>\n     *\n     * @param enabled\n     */\n    public void setRailsEnabled(boolean enabled) {\n        railsEnabled = enabled;\n    }\n\n    /**\n     * @see #setRailsEnabled(boolean)\n     *\n     * @return\n     */\n    public boolean isRailsEnabled() {\n        if (railsEnabled == null)\n            railsEnabled = options.remove(\"-rails\");\n        return railsEnabled;\n    }\n\n    /**\n     * Allow Html In Comments - encode them unless otherwise specified\n     */\n    public void setEncodeCommentsEnabled(boolean enabled) {\n        encodeCommentsEnabled = enabled;\n    }\n\n    /**\n     * @see #setEncodeCommentsEnabled(boolean)\n     */\n    public boolean isEncodeCommentsEnabled() {\n        if (encodeCommentsEnabled == null)\n            encodeCommentsEnabled = !options.remove(\"-ahic\");\n        return encodeCommentsEnabled;\n    }\n\n    /**\n     * If enabled we'll attempt to query/render the number of rows that\n     * each table contains.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setNumRowsEnabled(boolean enabled) {\n        numRowsEnabled = enabled;\n    }\n\n    /**\n     * @see #setNumRowsEnabled(boolean)\n     * @return\n     */\n    public boolean isNumRowsEnabled() {\n        if (numRowsEnabled == null)\n            numRowsEnabled = !options.remove(\"-norows\");\n        return numRowsEnabled;\n    }\n\n    /**\n     * If enabled we'll include views in the analysis.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setViewsEnabled(boolean enabled) {\n        viewsEnabled = enabled;\n    }\n\n    /**\n     * @see #setViewsEnabled(boolean)\n     * @return\n     */\n    public boolean isViewsEnabled() {\n        if (viewsEnabled == null)\n            viewsEnabled = !options.remove(\"-noviews\");\n        return viewsEnabled;\n    }\n\n    /**\n     * Returns <code>true</code> if metering should be embedded in\n     * the generated pages.<p/>\n     * Defaults to <code>false</code> (disabled).\n     * @return\n     */\n    public boolean isMeterEnabled() {\n        if (meterEnabled == null)\n            meterEnabled = options.remove(\"-meter\");\n        return meterEnabled;\n    }\n\n    /**\n     * Set the columns to exclude from all relationship diagrams.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setColumnExclusions(String columnExclusions) {\n        this.columnExclusions = Pattern.compile(columnExclusions);\n    }\n\n    /**\n     * See {@link #setColumnExclusions(String)}\n     * @return\n     */\n    public Pattern getColumnExclusions() {\n        if (columnExclusions == null) {\n            String strExclusions = pullParam(\"-X\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.columnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            columnExclusions = Pattern.compile(strExclusions);\n        }\n        return columnExclusions;\n    }\n\n    /**\n     * Set the columns to exclude from relationship diagrams where the specified\n     * columns aren't directly referenced by the focal table.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setIndirectColumnExclusions(String fullColumnExclusions) {\n        indirectColumnExclusions = Pattern.compile(fullColumnExclusions);\n    }\n\n    /**\n     * @see #setIndirectColumnExclusions(String)\n     *\n     * @return\n     */\n    public Pattern getIndirectColumnExclusions() {\n        if (indirectColumnExclusions == null) {\n            String strExclusions = pullParam(\"-x\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.indirectColumnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            indirectColumnExclusions = Pattern.compile(strExclusions);\n        }\n        return indirectColumnExclusions;\n    }\n\n    /**\n     * Set the tables to include as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableInclusions(String tableInclusions) {\n        this.tableInclusions = Pattern.compile(tableInclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to include in the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableInclusions() {\n        if (tableInclusions == null) {\n            String strInclusions = pullParam(\"-i\");\n            if (strInclusions == null)\n                strInclusions = System.getenv(\"schemaspy.tableInclusions\");\n            if (strInclusions == null)\n                strInclusions = DEFAULT_TABLE_INCLUSION;\n            try {\n                tableInclusions = Pattern.compile(strInclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-i\");\n            }\n        }\n        return tableInclusions;\n    }\n\n    /**\n     * Set the tables to exclude as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableExclusions(String tableExclusions) {\n        this.tableExclusions = Pattern.compile(tableExclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to exclude from the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableExclusions() {\n        if (tableExclusions == null) {\n            String strExclusions = pullParam(\"-I\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.tableExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_TABLE_EXCLUSION;\n            try {\n                tableExclusions = Pattern.compile(strExclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-I\");\n            }\n        }\n        return tableExclusions;\n    }\n\n    /**\n     * @return\n     */\n    public List<String> getSchemas() {\n        if (schemas == null) {\n            String tmp = pullParam(\"-schemas\");\n            if (tmp == null)\n                tmp = pullParam(\"-schemata\");\n            if (tmp != null) {\n                schemas = new ArrayList<String>();\n                for (String name : tmp.split(\"[\\\\s,'\\\"]\")) {\n                    if (name.length() > 0)\n                        schemas.add(name);\n                }\n                if (schemas.isEmpty())\n                    schemas = null;\n            }\n        }\n        return schemas;\n    }\n\n    /**\n     * Set the name of the {@link SqlFormatter SQL formatter} class to use to\n     * format SQL into HTML.<p/>\n     * The implementation of the class must be made available to the class\n     * loader, typically by specifying the path to its jar with <em>-dp</em>\n     * ({@link #setDriverPath(String)}).\n     */\n    public void setSqlFormatter(String formatterClassName) {\n        sqlFormatterClass = formatterClassName;\n        sqlFormatter = null;\n    }\n\n    /**\n     * Set the {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.\n     */\n    public void setSqlFormatter(SqlFormatter sqlFormatter) {\n        this.sqlFormatter = sqlFormatter;\n        if (sqlFormatter != null)\n            sqlFormatterClass = sqlFormatter.getClass().getName();\n    }\n\n    /**\n     * Returns an implementation of {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.  The default implementation is {@link DefaultSqlFormatter}.\n     *\n     * @return\n     * @throws InvalidConfigurationException if unable to instantiate an instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SqlFormatter getSqlFormatter() throws InvalidConfigurationException {\n        if (sqlFormatter == null) {\n            if (sqlFormatterClass == null) {\n                sqlFormatterClass = pullParam(\"-sqlFormatter\");\n                if (sqlFormatterClass == null)\n                    sqlFormatterClass = DefaultSqlFormatter.class.getName();\n            }\n            try {\n                Class<SqlFormatter> clazz = (Class<SqlFormatter>) Class.forName(sqlFormatterClass);\n                sqlFormatter = clazz.newInstance();\n            } catch (Exception exc) {\n                throw new InvalidConfigurationException(\"Failed to initialize instance of SQL formatter: \", exc).setParamName(\"-sqlFormatter\");\n            }\n        }\n        return sqlFormatter;\n    }\n\n    /**\n     * Set the details to show on the columns page, where \"details\" are\n     * comma and/or space separated.\n     *\n     * Valid values:\n     * <ul>\n     * <li>id</li>\n     * <li>table</li>\n     * <li>column</li>\n     * <li>type</li>\n     * <li>size</li>\n     * <li>nulls</li>\n     * <li>auto</li>\n     * <li>default</li>\n     * <li>children</li>\n     * <li>parents</li>\n     * </ul>\n     *\n     * The default details are <code>\"table column type size nulls auto default\"</code>.\n     * Note that \"column\" is the initially displayed detail and must be included.\n     *\n     * @param columnDetails\n     */\n    public void setColumnDetails(String columnDetails) {\n        this.columnDetails = new ArrayList<String>();\n        if (columnDetails == null || columnDetails.length() == 0) {\n            // not specified, so use defaults\n            columnDetails = \"id table column type size nulls auto default\";\n        }\n        for (String detail : columnDetails.split(\"[\\\\s,'\\\"]\")) {\n            if (detail.length() > 0) {\n                this.columnDetails.add(detail.toLowerCase());\n            }\n        }\n        if (!this.columnDetails.contains(\"column\"))\n            throw new InvalidConfigurationException(\"'column' is a required column detail\");\n    }\n\n    public void setColumnDetails(List<String> columnDetails) {\n        String details = columnDetails == null ? \"[]\" : columnDetails.toString();\n        setColumnDetails(details.substring(1, details.length() - 1));\n    }\n\n    public List<String> getColumnDetails() {\n        if (columnDetails == null) {\n            setColumnDetails(pullParam(\"-columndetails\"));\n        }\n        return columnDetails;\n    }\n\n    public void setEvaluateAllEnabled(boolean enabled) {\n        evaluteAll = enabled;\n    }\n\n    public boolean isEvaluateAllEnabled() {\n        if (evaluteAll == null)\n            evaluteAll = options.remove(\"-all\");\n        return evaluteAll;\n    }\n\n    /**\n     * Returns true if we're evaluating a bunch of schemas in one go and\n     * at this point we're evaluating a specific schema.\n     *\n     * @return boolean\n     */\n    public boolean isOneOfMultipleSchemas() {\n        // set by MultipleSchemaAnalyzer\n        return Boolean.getBoolean(\"oneofmultipleschemas\");\n    }\n\n    /**\n     * When -all (evaluateAll) is specified then this is the regular\n     * expression that determines which schemas to evaluate.\n     *\n     * @param schemaSpec\n     */\n    public void setSchemaSpec(String schemaSpec) {\n        this.schemaSpec = schemaSpec;\n    }\n\n    public String getSchemaSpec() {\n        if (schemaSpec == null)\n            schemaSpec = pullParam(\"-schemaSpec\");\n        return schemaSpec;\n    }\n\n    /**\n     * Set the renderer to use for the -Tpng[:renderer[:formatter]] dot option as specified\n     * at <a href='http://www.graphviz.org/doc/info/command.html'>\n     * http://www.graphviz.org/doc/info/command.html</a>.<p>\n     * Note that the leading \":\" is required while :formatter is optional.<p>\n     * The default renderer is typically GD.<p>\n     * Note that using {@link #setHighQuality(boolean)} is the preferred approach\n     * over using this method.\n     */\n    public void setRenderer(String renderer) {\n        Dot.getInstance().setRenderer(renderer);\n    }\n\n    /**\n     * @see #setRenderer(String)\n     * @return\n     */\n    public String getRenderer() {\n        String renderer = pullParam(\"-renderer\");\n        if (renderer != null)\n            setRenderer(renderer);\n        return Dot.getInstance().getRenderer();\n    }\n\n    /**\n     * If <code>false</code> then generate output of \"lower quality\"\n     * than the default.\n     * Note that the default is intended to be \"higher quality\",\n     * but various installations of Graphviz may have have different abilities.\n     * That is, some might not have the \"lower quality\" libraries and others might\n     * not have the \"higher quality\" libraries.<p>\n     * Higher quality output takes longer to generate and results in significantly\n     * larger image files (which take longer to download / display), but it generally\n     * looks better.\n     */\n    public void setHighQuality(boolean highQuality) {\n        this.highQuality = highQuality;\n        lowQuality = !highQuality;\n        Dot.getInstance().setHighQuality(highQuality);\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isHighQuality() {\n        if (highQuality == null) {\n            highQuality = options.remove(\"-hq\");\n            if (highQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(highQuality);\n            }\n        }\n        highQuality = Dot.getInstance().isHighQuality();\n        return highQuality;\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isLowQuality() {\n        if (lowQuality == null) {\n            lowQuality = options.remove(\"-lq\");\n            if (lowQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(!lowQuality);\n            }\n        }\n        lowQuality = !Dot.getInstance().isHighQuality();\n        return lowQuality;\n    }\n\n    /**\n     * Set the level of logging to perform.<p/>\n     * The levels in descending order are:\n     * <ul>\n     *  <li><code>severe</code> (highest - least detail)\n     *  <li><code>warning</code> (default)\n     *  <li><code>info</code>\n     *  <li><code>config</code>\n     *  <li><code>fine</code>\n     *  <li><code>finer</code>\n     *  <li><code>finest</code>  (lowest - most detail)\n     * </ul>\n     *\n     * @param logLevel\n     */\n    public void setLogLevel(String logLevel) {\n        if (logLevel == null) {\n            this.logLevel = Level.WARNING;\n            return;\n        }\n        Map<String, Level> levels = new LinkedHashMap<String, Level>();\n        levels.put(\"severe\", Level.SEVERE);\n        levels.put(\"warning\", Level.WARNING);\n        levels.put(\"info\", Level.INFO);\n        levels.put(\"config\", Level.CONFIG);\n        levels.put(\"fine\", Level.FINE);\n        levels.put(\"finer\", Level.FINER);\n        levels.put(\"finest\", Level.FINEST);\n        this.logLevel = levels.get(logLevel.toLowerCase());\n        if (this.logLevel == null) {\n            throw new InvalidConfigurationException(\"Invalid logLevel: '\" + logLevel + \"'. Must be one of: \" + levels.keySet());\n        }\n    }\n\n    /**\n     * Returns the level of logging to perform.\n     * See {@link #setLogLevel(String)}.\n     *\n     * @return\n     */\n    public Level getLogLevel() {\n        if (logLevel == null) {\n            setLogLevel(pullParam(\"-loglevel\"));\n        }\n        return logLevel;\n    }\n\n    /**\n     * Returns <code>true</code> if the options indicate that the user wants\n     * to see some help information.\n     *\n     * @return\n     */\n    public boolean isHelpRequired() {\n        return helpRequired;\n    }\n\n    public boolean isDbHelpRequired() {\n        return dbHelpRequired;\n    }\n\n    /**\n     * Returns the jar that we were loaded from\n     *\n     * @return\n     */\n    public static String getLoadedFromJar() {\n        String classpath = System.getProperty(\"java.class.path\");\n        return new StringTokenizer(classpath, File.pathSeparator).nextToken();\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasOrphans(boolean hasOrphans) {\n        this.hasOrphans = hasOrphans;\n    }\n\n    /**\n     * @see #setHasOrphans()\n     *\n     * @return\n     */\n    public boolean hasOrphans() {\n        return hasOrphans;\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasRoutines(boolean hasRoutines) {\n        this.hasRoutines = hasRoutines;\n    }\n\n    /**\n     * @see #setHasRoutines()\n     *\n     * @return\n     */\n    public boolean hasRoutines() {\n        return hasRoutines;\n    }\n\n    /**\n     * Returns the database properties to use.\n     * These should be determined by calling {@link #determineDbProperties(String)}.\n     * @return\n     * @throws InvalidConfigurationException\n     */\n    public Properties getDbProperties() throws InvalidConfigurationException {\n        if (dbProperties == null) {\n            try {\n                dbProperties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(exc);\n            }\n        }\n        return dbProperties;\n    }\n\n    /**\n     * Determines the database properties associated with the specified type.\n     * A call to {@link #setDbProperties(Properties)} is expected after determining\n     * the complete set of properties.\n     *\n     * @param type\n     * @return\n     * @throws IOException\n     * @throws InvalidConfigurationException if db properties are incorrectly formed\n     */\n    public Properties determineDbProperties(String type) throws IOException, InvalidConfigurationException {\n        ResourceBundle bundle = null;\n        try {\n            File propertiesFile = new File(type);\n            bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n            dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n        } catch (FileNotFoundException notFoundOnFilesystemWithoutExtension) {\n            try {\n                File propertiesFile = new File(type + \".properties\");\n                bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n                dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n            } catch (FileNotFoundException notFoundOnFilesystemWithExtensionTackedOn) {\n                try {\n                    bundle = ResourceBundle.getBundle(type);\n                    dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]\" + File.separator + type + \".properties\";\n                } catch (Exception notInJarWithoutPath) {\n                    try {\n                        String path = TableOrderer.class.getPackage().getName() + \".dbTypes.\" + type;\n                        path = path.replace('.', '/');\n                        bundle = ResourceBundle.getBundle(path);\n                        dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]/\" + path + \".properties\";\n                    } catch (Exception notInJar) {\n                        notInJar.printStackTrace();\n                        notFoundOnFilesystemWithExtensionTackedOn.printStackTrace();\n                        throw notFoundOnFilesystemWithoutExtension;\n                    }\n                }\n            }\n        }\n        Properties props = asProperties(bundle);\n        bundle = null;\n        // keep original thru recursion\n        String saveLoadedFrom = dbPropertiesLoadedFrom;\n        // bring in key/values pointed to by the include directive\n        // example: include.1=mysql::selectRowCountSql\n        for (int i = 1; true; ++i) {\n            String include = (String) props.remove(\"include.\" + i);\n            if (include == null)\n                break;\n            int separator = include.indexOf(\"::\");\n            if (separator == -1)\n                throw new InvalidConfigurationException(\"include directive in \" + dbPropertiesLoadedFrom + \" must have '::' between dbType and key\");\n            String refdType = include.substring(0, separator).trim();\n            String refdKey = include.substring(separator + 2).trim();\n            // recursively resolve the ref'd properties file and the ref'd key\n            Properties refdProps = determineDbProperties(refdType);\n            props.put(refdKey, refdProps.getProperty(refdKey));\n        }\n        // bring in base properties files pointed to by the extends directive\n        String baseDbType = (String) props.remove(\"extends\");\n        if (baseDbType != null) {\n            baseDbType = baseDbType.trim();\n            Properties baseProps = determineDbProperties(baseDbType);\n            // overlay our properties on top of the base's\n            baseProps.putAll(props);\n            props = baseProps;\n        }\n        // done with this level of recursion...restore original\n        dbPropertiesLoadedFrom = saveLoadedFrom;\n        // this won't be correct until the final recursion exits\n        dbProperties = props;\n        return props;\n    }\n\n    protected String getDbPropertiesLoadedFrom() throws IOException {\n        if (dbPropertiesLoadedFrom == null)\n            determineDbProperties(getDbType());\n        return dbPropertiesLoadedFrom;\n    }\n\n    public List<String> getRemainingParameters() {\n        try {\n            populate();\n        } catch (IllegalArgumentException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (IllegalAccessException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (InvocationTargetException exc) {\n            if (exc.getCause() instanceof InvalidConfigurationException)\n                throw (InvalidConfigurationException) exc.getCause();\n            throw new InvalidConfigurationException(exc.getCause());\n        } catch (IntrospectionException exc) {\n            throw new InvalidConfigurationException(exc);\n        }\n        return options;\n    }\n\n    /**\n     * Options that are specific to a type of database.  E.g. things like <code>host</code>,\n     * <code>port</code> or <code>db</code>, but <b>don't</b> have a setter in this class.\n     *\n     * @param dbSpecificOptions\n     */\n    public void setDbSpecificOptions(Map<String, String> dbSpecificOptions) {\n        this.dbSpecificOptions = dbSpecificOptions;\n        originalDbSpecificOptions = new HashMap<String, String>(dbSpecificOptions);\n    }\n\n    public Map<String, String> getDbSpecificOptions() {\n        if (dbSpecificOptions == null)\n            dbSpecificOptions = new HashMap<String, String>();\n        return dbSpecificOptions;\n    }\n\n    /**\n     * Returns a {@link Properties} populated with the contents of <code>bundle</code>\n     *\n     * @param bundle ResourceBundle\n     * @return Properties\n     */\n    public static Properties asProperties(ResourceBundle bundle) {\n        Properties props = new Properties();\n        Enumeration<String> iter = bundle.getKeys();\n        while (iter.hasMoreElements()) {\n            String key = iter.nextElement();\n            props.put(key, bundle.getObject(key));\n        }\n        return props;\n    }\n\n    /**\n     * 'Pull' the specified parameter from the collection of options. Returns\n     * null if the parameter isn't in the list and removes it if it is.\n     *\n     * @param paramId\n     * @return\n     */\n    private String pullParam(String paramId) {\n        return pullParam(paramId, false, false);\n    }\n\n    private String pullRequiredParam(String paramId) {\n        return pullParam(paramId, true, false);\n    }\n\n    /**\n     * @param paramId\n     * @param required\n     * @param dbTypeSpecific\n     * @return\n     * @throws MissingRequiredParameterException\n     */\n    private String pullParam(String paramId, boolean required, boolean dbTypeSpecific) throws MissingRequiredParameterException {\n        int paramIndex = options.indexOf(paramId);\n        if (paramIndex < 0) {\n            if (required)\n                throw new MissingRequiredParameterException(paramId, dbTypeSpecific);\n            return null;\n        }\n        options.remove(paramIndex);\n        String param = options.get(paramIndex).toString();\n        options.remove(paramIndex);\n        return param;\n    }\n\n    /**\n     * Thrown to indicate that a required parameter is missing\n     */\n    public static class MissingRequiredParameterException extends RuntimeException {\n\n        private static final long serialVersionUID = 1L;\n\n        private final boolean dbTypeSpecific;\n\n        public MissingRequiredParameterException(String paramId, boolean dbTypeSpecific) {\n            this(paramId, null, dbTypeSpecific);\n        }\n\n        public MissingRequiredParameterException(String paramId, String description, boolean dbTypeSpecific) {\n            super(\"Required parameter '\" + paramId + \"' \" + (description == null ? \"\" : \"(\" + description + \") \") + \"was not specified.\" + (dbTypeSpecific ? \"  It is required for this database type.\" : \"\"));\n            this.dbTypeSpecific = dbTypeSpecific;\n        }\n\n        public boolean isDbTypeSpecific() {\n            return dbTypeSpecific;\n        }\n    }\n\n    /**\n     * Allow an equal sign in args...like \"-o=foo.bar\". Useful for things like\n     * Ant and Maven.\n     *\n     * @param args\n     *            List\n     * @return List\n     */\n    protected List<String> fixupArgs(List<String> args) {\n        List<String> expandedArgs = new ArrayList<String>();\n        for (String arg : args) {\n            int indexOfEquals = arg.indexOf('=');\n            if (indexOfEquals != -1 && indexOfEquals - 1 != arg.indexOf(ESCAPED_EQUALS)) {\n                expandedArgs.add(arg.substring(0, indexOfEquals));\n                expandedArgs.add(arg.substring(indexOfEquals + 1));\n            } else {\n                expandedArgs.add(arg);\n            }\n        }\n        // some OSes/JVMs do filename expansion with runtime.exec() and some don't,\n        // so MultipleSchemaAnalyzer has to surround params with double quotes...\n        // strip them here for the OSes/JVMs that don't do anything with the params\n        List<String> unquotedArgs = new ArrayList<String>();\n        for (String arg : expandedArgs) {\n            if (// \".*\" becomes .*\n            arg.startsWith(\"\\\"\") && arg.endsWith(\"\\\"\"))\n                arg = arg.substring(1, arg.length() - 1);\n            unquotedArgs.add(arg);\n        }\n        return unquotedArgs;\n    }\n\n    /**\n     * Call all the getters to populate all the lazy initialized stuff.\n     *\n     * @throws InvocationTargetException\n     * @throws IllegalAccessException\n     * @throws IllegalArgumentException\n     * @throws IntrospectionException\n     */\n    private void populate() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IntrospectionException {\n        if (!populating) {\n            // prevent recursion\n            populating = true;\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                Method readMethod = props[i].getReadMethod();\n                if (readMethod != null)\n                    readMethod.invoke(this, (Object[]) null);\n            }\n            populating = false;\n        }\n    }\n\n    public static Set<String> getBuiltInDatabaseTypes(String loadedFromJar) {\n        Set<String> databaseTypes = new TreeSet<String>();\n        JarInputStream jar = null;\n        try {\n            jar = new JarInputStream(new FileInputStream(loadedFromJar));\n            JarEntry entry;\n            while ((entry = jar.getNextJarEntry()) != null) {\n                String entryName = entry.getName();\n                int dotPropsIndex = entryName.indexOf(\".properties\");\n                if (dotPropsIndex != -1)\n                    databaseTypes.add(entryName.substring(0, dotPropsIndex));\n            }\n        } catch (IOException exc) {\n        } finally {\n            if (jar != null) {\n                try {\n                    jar.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n        return databaseTypes;\n    }\n\n    protected void dumpUsage(String errorMessage, boolean detailedDb) {\n        if (errorMessage != null) {\n            System.out.flush();\n            System.err.println(\"*** \" + errorMessage + \" ***\");\n        } else {\n            System.out.println(\"SchemaSpy generates an HTML representation of a database schema's relationships.\");\n        }\n        System.err.flush();\n        System.out.println();\n        if (!detailedDb) {\n            System.out.println(\"Usage:\");\n            System.out.println(\" java -jar \" + getLoadedFromJar() + \" [options]\");\n            System.out.println(\"   -t databaseType       type of database - defaults to ora\");\n            System.out.println(\"                           use -dbhelp for a list of built-in types\");\n            System.out.println(\"   -u user               connect to the database with this user id\");\n            System.out.println(\"   -s schema             defaults to the specified user\");\n            System.out.println(\"   -p password           defaults to no password\");\n            System.out.println(\"   -o outputDirectory    directory to place the generated output in\");\n            System.out.println(\"   -dp pathToDrivers     optional - looks for JDBC drivers here before looking\");\n            System.out.println(\"                           in driverPath in [databaseType].properties.\");\n            System.out.println(\"Go to http://schemaspy.sourceforge.net for a complete list/description\");\n            System.out.println(\" of additional parameters.\");\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"Built-in database types and their required connection parameters:\");\n            for (String type : getBuiltInDatabaseTypes(getLoadedFromJar())) {\n                new DbSpecificConfig(type).dumpUsage();\n            }\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"You can use your own database types by specifying the filespec of a .properties file with -t.\");\n            System.out.println(\"Grab one out of \" + getLoadedFromJar() + \" and modify it to suit your needs.\");\n            System.out.println();\n        }\n        System.out.println(\"Sample usage using the default database type (implied -t ora):\");\n        System.out.println(\" java -jar schemaSpy.jar -db mydb -s myschema -u devuser -p password -o output\");\n        System.out.println();\n        System.out.flush();\n    }\n\n    /**\n     * Get the value of the specified parameter.\n     * Used for properties that are common to most db's, but aren't required.\n     *\n     * @param paramName\n     * @return\n     */\n    public String getParam(String paramName) {\n        try {\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                PropertyDescriptor prop = props[i];\n                if (prop.getName().equalsIgnoreCase(paramName)) {\n                    Object result = prop.getReadMethod().invoke(this, (Object[]) null);\n                    return result == null ? null : result.toString();\n                }\n            }\n        } catch (Exception failed) {\n            failed.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * Return all of the configuration options as a List of Strings, with\n     * each parameter and its value as a separate element.\n     *\n     * @return\n     * @throws IOException\n     */\n    public List<String> asList() throws IOException {\n        List<String> params = new ArrayList<String>();\n        if (originalDbSpecificOptions != null) {\n            for (String key : originalDbSpecificOptions.keySet()) {\n                String value = originalDbSpecificOptions.get(key);\n                if (!key.startsWith(\"-\"))\n                    key = \"-\" + key;\n                params.add(key);\n                params.add(value);\n            }\n        }\n        if (isEncodeCommentsEnabled())\n            params.add(\"-ahic\");\n        if (isEvaluateAllEnabled())\n            params.add(\"-all\");\n        if (!isHtmlGenerationEnabled())\n            params.add(\"-nohtml\");\n        if (!isImpliedConstraintsEnabled())\n            params.add(\"-noimplied\");\n        if (!isLogoEnabled())\n            params.add(\"-nologo\");\n        if (isMeterEnabled())\n            params.add(\"-meter\");\n        if (!isNumRowsEnabled())\n            params.add(\"-norows\");\n        if (!isViewsEnabled())\n            params.add(\"-noviews\");\n        if (isRankDirBugEnabled())\n            params.add(\"-rankdirbug\");\n        if (isRailsEnabled())\n            params.add(\"-rails\");\n        if (isSingleSignOn())\n            params.add(\"-sso\");\n        if (isSchemaDisabled())\n            params.add(\"-noschema\");\n        String value = getDriverPath();\n        if (value != null) {\n            params.add(\"-dp\");\n            params.add(value);\n        }\n        params.add(\"-css\");\n        params.add(getCss());\n        params.add(\"-charset\");\n        params.add(getCharset());\n        params.add(\"-font\");\n        params.add(getFont());\n        params.add(\"-fontsize\");\n        params.add(String.valueOf(getFontSize()));\n        params.add(\"-t\");\n        params.add(getDbType());\n        // query to set renderer correctly\n        isHighQuality();\n        // query to set renderer correctly\n        isLowQuality();\n        // instead of -hq and/or -lq\n        params.add(\"-renderer\");\n        params.add(getRenderer());\n        value = getDescription();\n        if (value != null) {\n            params.add(\"-desc\");\n            params.add(value);\n        }\n        value = getPassword();\n        if (value != null && !isPromptForPasswordEnabled()) {\n            // note that we don't pass -pfp since child processes\n            // won't have a console\n            params.add(\"-p\");\n            params.add(value);\n        }\n        value = getCatalog();\n        if (value != null) {\n            params.add(\"-cat\");\n            params.add(value);\n        }\n        value = getSchema();\n        if (value != null) {\n            params.add(\"-s\");\n            params.add(value);\n        }\n        value = getUser();\n        if (value != null) {\n            params.add(\"-u\");\n            params.add(value);\n        }\n        value = getConnectionPropertiesFile();\n        if (value != null) {\n            params.add(\"-connprops\");\n            params.add(value);\n        } else {\n            Properties props = getConnectionProperties();\n            if (!props.isEmpty()) {\n                params.add(\"-connprops\");\n                StringBuilder buf = new StringBuilder();\n                for (Entry<Object, Object> entry : props.entrySet()) {\n                    buf.append(entry.getKey());\n                    buf.append(ESCAPED_EQUALS);\n                    buf.append(entry.getValue());\n                    buf.append(';');\n                }\n                params.add(buf.toString());\n            }\n        }\n        value = getDb();\n        if (value != null) {\n            params.add(\"-db\");\n            params.add(value);\n        }\n        value = getHost();\n        if (value != null) {\n            params.add(\"-host\");\n            params.add(value);\n        }\n        if (getPort() != null) {\n            params.add(\"-port\");\n            params.add(getPort().toString());\n        }\n        value = getServer();\n        if (value != null) {\n            params.add(\"-server\");\n            params.add(value);\n        }\n        value = getMeta();\n        if (value != null) {\n            params.add(\"-meta\");\n            params.add(value);\n        }\n        if (getGraphvizDir() != null) {\n            params.add(\"-gv\");\n            params.add(getGraphvizDir().toString());\n        }\n        params.add(\"-loglevel\");\n        params.add(getLogLevel().toString().toLowerCase());\n        params.add(\"-sqlFormatter\");\n        params.add(getSqlFormatter().getClass().getName());\n        params.add(\"-i\");\n        params.add(getTableInclusions().toString());\n        params.add(\"-I\");\n        params.add(getTableExclusions().toString());\n        params.add(\"-X\");\n        params.add(getColumnExclusions().toString());\n        params.add(\"-x\");\n        params.add(getIndirectColumnExclusions().toString());\n        params.add(\"-dbthreads\");\n        params.add(String.valueOf(getMaxDbThreads()));\n        params.add(\"-maxdet\");\n        params.add(String.valueOf(getMaxDetailedTables()));\n        params.add(\"-o\");\n        params.add(getOutputDir().toString());\n        return params;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/ConfigTest5.java",
		"test_prompt": "// ConfigTest5.java\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Config}.\n* It contains ten unit test cases for the {@link Config#isPromptForPasswordEnabled()} method.\n*/\nclass ConfigTest5 {"
	},
	{
		"original_code": "// Config.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\n\n/**\n * Configuration of a SchemaSpy run\n *\n * @author John Currier\n */\npublic class Config {\n\n    private static Config instance;\n\n    private final List<String> options;\n\n    private Map<String, String> dbSpecificOptions;\n\n    private Map<String, String> originalDbSpecificOptions;\n\n    private boolean helpRequired;\n\n    private boolean dbHelpRequired;\n\n    private File outputDir;\n\n    private File graphvizDir;\n\n    private String dbType;\n\n    private String catalog;\n\n    private String schema;\n\n    private List<String> schemas;\n\n    private String user;\n\n    private Boolean singleSignOn;\n\n    private Boolean noSchema;\n\n    private String password;\n\n    private Boolean promptForPassword;\n\n    private String db;\n\n    private String host;\n\n    private Integer port;\n\n    private String server;\n\n    private String meta;\n\n    private Pattern tableInclusions;\n\n    private Pattern tableExclusions;\n\n    private Pattern columnExclusions;\n\n    private Pattern indirectColumnExclusions;\n\n    private String userConnectionPropertiesFile;\n\n    private Properties userConnectionProperties;\n\n    private Integer maxDbThreads;\n\n    private Integer maxDetailedTables;\n\n    private String driverPath;\n\n    private String css;\n\n    private String charset;\n\n    private String font;\n\n    private Integer fontSize;\n\n    private String description;\n\n    private Properties dbProperties;\n\n    private String dbPropertiesLoadedFrom;\n\n    private Level logLevel;\n\n    private SqlFormatter sqlFormatter;\n\n    private String sqlFormatterClass;\n\n    private Boolean generateHtml;\n\n    private Boolean includeImpliedConstraints;\n\n    private Boolean logoEnabled;\n\n    private Boolean rankDirBugEnabled;\n\n    private Boolean encodeCommentsEnabled;\n\n    private Boolean numRowsEnabled;\n\n    private Boolean viewsEnabled;\n\n    private Boolean meterEnabled;\n\n    private Boolean railsEnabled;\n\n    private Boolean evaluteAll;\n\n    private Boolean highQuality;\n\n    private Boolean lowQuality;\n\n    // used in conjunction with evaluateAll\n    private String schemaSpec;\n\n    private boolean hasOrphans = false;\n\n    private boolean hasRoutines = false;\n\n    private boolean populating = false;\n\n    private List<String> columnDetails;\n\n    public static final String DOT_CHARSET = \"UTF-8\";\n\n    private static final String ESCAPED_EQUALS = \"\\\\=\";\n\n    // match everything\n    private static final String DEFAULT_TABLE_INCLUSION = \".*\";\n\n    // match nothing\n    private static final String DEFAULT_TABLE_EXCLUSION = \"\";\n\n    // match nothing\n    private static final String DEFAULT_COLUMN_EXCLUSION = \"[^.]\";\n\n    /**\n     * Default constructor. Intended for when you want to inject properties\n     * independently (i.e. not from a command line interface).\n     */\n    public Config() {\n        if (instance == null)\n            setInstance(this);\n        options = new ArrayList<String>();\n    }\n\n    /**\n     * Construct a configuration from an array of options (e.g. from a command\n     * line interface).\n     *\n     * @param options\n     */\n    public Config(String[] argv) {\n        setInstance(this);\n        options = fixupArgs(Arrays.asList(argv));\n        helpRequired = options.remove(\"-?\") || options.remove(\"/?\") || options.remove(\"?\") || options.remove(\"-h\") || options.remove(\"-help\") || options.remove(\"--help\");\n        dbHelpRequired = options.remove(\"-dbHelp\") || options.remove(\"-dbhelp\");\n    }\n\n    public static Config getInstance() {\n        if (instance == null)\n            instance = new Config();\n        return instance;\n    }\n\n    /**\n     * Sets the global instance.\n     *\n     * Useful for things like selecting a specific configuration in a UI.\n     *\n     * @param config\n     */\n    public static void setInstance(Config config) {\n        instance = config;\n    }\n\n    public void setHtmlGenerationEnabled(boolean generateHtml) {\n        this.generateHtml = generateHtml;\n    }\n\n    public boolean isHtmlGenerationEnabled() {\n        if (generateHtml == null)\n            generateHtml = !options.remove(\"-nohtml\");\n        return generateHtml;\n    }\n\n    public void setImpliedConstraintsEnabled(boolean includeImpliedConstraints) {\n        this.includeImpliedConstraints = includeImpliedConstraints;\n    }\n\n    public boolean isImpliedConstraintsEnabled() {\n        if (includeImpliedConstraints == null)\n            includeImpliedConstraints = !options.remove(\"-noimplied\");\n        return includeImpliedConstraints;\n    }\n\n    public void setOutputDir(String outputDirName) {\n        if (outputDirName.endsWith(\"\\\"\"))\n            outputDirName = outputDirName.substring(0, outputDirName.length() - 1);\n        setOutputDir(new File(outputDirName));\n    }\n\n    public void setOutputDir(File outputDir) {\n        this.outputDir = outputDir;\n    }\n\n    public File getOutputDir() {\n        if (outputDir == null) {\n            setOutputDir(pullRequiredParam(\"-o\"));\n        }\n        return outputDir;\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(String graphvizDir) {\n        if (graphvizDir.endsWith(\"\\\"\"))\n            graphvizDir = graphvizDir.substring(0, graphvizDir.length() - 1);\n        setGraphvizDir(new File(graphvizDir));\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(File graphvizDir) {\n        this.graphvizDir = graphvizDir;\n    }\n\n    /**\n     * Return the path to Graphviz (used to find the dot executable to run to\n     * generate ER diagrams).<p/>\n     *\n     * Returns {@link #getDefaultGraphvizPath()} if a specific Graphviz path\n     * was not specified.\n     *\n     * @return\n     */\n    public File getGraphvizDir() {\n        if (graphvizDir == null) {\n            String gv = pullParam(\"-gv\");\n            if (gv != null) {\n                setGraphvizDir(gv);\n            } else {\n                // expect to find Graphviz's bin directory on the PATH\n            }\n        }\n        return graphvizDir;\n    }\n\n    /**\n     * Meta files are XML-based files that provide additional metadata\n     * about the schema being evaluated.<p>\n     * <code>meta</code> is either the name of an individual XML file or\n     * the directory that contains meta files.<p>\n     * If a directory is specified then it is expected to contain files\n     * matching the pattern <code>[schema].meta.xml</code>.\n     * For databases that don't have schema substitute database for schema.\n     * @param meta\n     */\n    public void setMeta(String meta) {\n        this.meta = meta;\n    }\n\n    public String getMeta() {\n        if (meta == null)\n            meta = pullParam(\"-meta\");\n        return meta;\n    }\n\n    public void setDbType(String dbType) {\n        this.dbType = dbType;\n    }\n\n    public String getDbType() {\n        if (dbType == null) {\n            dbType = pullParam(\"-t\");\n            if (dbType == null)\n                dbType = \"ora\";\n        }\n        return dbType;\n    }\n\n    public void setDb(String db) {\n        this.db = db;\n    }\n\n    public String getDb() {\n        if (db == null)\n            db = pullParam(\"-db\");\n        return db;\n    }\n\n    public void setCatalog(String catalog) {\n        this.catalog = catalog;\n    }\n\n    public String getCatalog() {\n        if (catalog == null)\n            catalog = pullParam(\"-cat\");\n        return catalog;\n    }\n\n    public void setSchema(String schema) {\n        this.schema = schema;\n    }\n\n    public String getSchema() {\n        if (schema == null)\n            schema = pullParam(\"-s\");\n        return schema;\n    }\n\n    /**\n     * Some databases types (e.g. older versions of Informix) don't really\n     * have the concept of a schema but still return true from\n     * {@link DatabaseMetaData#supportsSchemasInTableDefinitions()}.\n     * This option lets you ignore that and treat all the tables\n     * as if they were in one flat namespace.\n     */\n    public boolean isSchemaDisabled() {\n        if (noSchema == null)\n            noSchema = options.remove(\"-noschema\");\n        return noSchema;\n    }\n\n    public void setHost(String host) {\n        this.host = host;\n    }\n\n    public String getHost() {\n        if (host == null)\n            host = pullParam(\"-host\");\n        return host;\n    }\n\n    public void setPort(Integer port) {\n        this.port = port;\n    }\n\n    public Integer getPort() {\n        if (port == null)\n            try {\n                port = Integer.valueOf(pullParam(\"-port\"));\n            } catch (Exception notSpecified) {\n            }\n        return port;\n    }\n\n    public void setServer(String server) {\n        this.server = server;\n    }\n\n    public String getServer() {\n        if (server == null) {\n            server = pullParam(\"-server\");\n        }\n        return server;\n    }\n\n    public void setUser(String user) {\n        this.user = user;\n    }\n\n    /**\n     * User used to connect to the database.\n     * Required unless single sign-on is enabled\n     * (see {@link #setSingleSignOn(boolean)}).\n     * @return\n     */\n    public String getUser() {\n        if (user == null) {\n            if (!isSingleSignOn())\n                user = pullRequiredParam(\"-u\");\n            else\n                user = pullParam(\"-u\");\n        }\n        return user;\n    }\n\n    /**\n     * By default a \"user\" (as specified with -u) is required.\n     * This option allows disabling of that requirement for\n     * single sign-on environments.\n     *\n     * @param enabled defaults to <code>false</code>\n     */\n    public void setSingleSignOn(boolean enabled) {\n        singleSignOn = enabled;\n    }\n\n    /**\n     * @see #setSingleSignOn(boolean)\n     */\n    public boolean isSingleSignOn() {\n        if (singleSignOn == null)\n            singleSignOn = options.remove(\"-sso\");\n        return singleSignOn;\n    }\n\n    /**\n     * Set the password used to connect to the database.\n     * @param password\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * @see #setPassword(String)\n     * @return\n     */\n    public String getPassword() {\n        if (password == null)\n            password = pullParam(\"-p\");\n        if (password == null && isPromptForPasswordEnabled())\n            password = new String(PasswordReader.getInstance().readPassword(\"Password: \"));\n        if (password == null) {\n            // if -pfp is enabled when analyzing multiple schemas then\n            // we don't want to send the password on the command line,\n            // so see if it was passed in the environment (not ideal, but safer)\n            password = System.getenv(\"schemaspy.pw\");\n        }\n        return password;\n    }\n\n    /**\n     * Set to <code>true</code> to prompt for the password\n     * @param promptForPassword\n     */\n    public void setPromptForPasswordEnabled(boolean promptForPassword) {\n        this.promptForPassword = promptForPassword;\n    }\n\n    /**\n     * @see #setPromptForPasswordEnabled(boolean)\n     * @return\n     */\n    public boolean isPromptForPasswordEnabled() {\n        if (promptForPassword == null) {\n            promptForPassword = options.remove(\"-pfp\");\n        }\n        return promptForPassword;\n    }\n\n    public void setMaxDetailedTabled(int maxDetailedTables) {\n        this.maxDetailedTables = new Integer(maxDetailedTables);\n    }\n\n    public int getMaxDetailedTables() {\n        if (maxDetailedTables == null) {\n            // default\n            int max = 300;\n            try {\n                max = Integer.parseInt(pullParam(\"-maxdet\"));\n            } catch (Exception notSpecified) {\n            }\n            maxDetailedTables = new Integer(max);\n        }\n        return maxDetailedTables.intValue();\n    }\n\n    public String getConnectionPropertiesFile() {\n        return userConnectionPropertiesFile;\n    }\n\n    /**\n     * Properties from this file (in key=value pair format) are passed to the\n     * database connection.<br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.\n     * @param propertiesFilename\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public void setConnectionPropertiesFile(String propertiesFilename) throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null)\n            userConnectionProperties = new Properties();\n        userConnectionProperties.load(new FileInputStream(propertiesFilename));\n        userConnectionPropertiesFile = propertiesFilename;\n    }\n\n    /**\n     * Returns a {@link Properties} populated either from the properties file specified\n     * by {@link #setConnectionPropertiesFile(String)}, the properties specified by\n     * {@link #setConnectionProperties(String)} or not populated.\n     * @return\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public Properties getConnectionProperties() throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null) {\n            String props = pullParam(\"-connprops\");\n            if (props != null) {\n                if (props.indexOf(ESCAPED_EQUALS) != -1) {\n                    setConnectionProperties(props);\n                } else {\n                    setConnectionPropertiesFile(props);\n                }\n            } else {\n                userConnectionProperties = new Properties();\n            }\n        }\n        return userConnectionProperties;\n    }\n\n    /**\n     * Specifies connection properties to use in the format:\n     * <code>key1\\=value1;key2\\=value2</code><br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.<p>\n     * This is an alternative form of passing connection properties than by file\n     * (see {@link #setConnectionPropertiesFile(String)})\n     *\n     * @param properties\n     */\n    public void setConnectionProperties(String properties) {\n        userConnectionProperties = new Properties();\n        StringTokenizer tokenizer = new StringTokenizer(properties, \";\");\n        while (tokenizer.hasMoreElements()) {\n            String pair = tokenizer.nextToken();\n            int index = pair.indexOf(ESCAPED_EQUALS);\n            if (index != -1) {\n                String key = pair.substring(0, index);\n                String value = pair.substring(index + ESCAPED_EQUALS.length());\n                userConnectionProperties.put(key, value);\n            }\n        }\n    }\n\n    public void setDriverPath(String driverPath) {\n        this.driverPath = driverPath;\n    }\n\n    public String getDriverPath() {\n        if (driverPath == null)\n            driverPath = pullParam(\"-dp\");\n        // was previously -cp:\n        if (driverPath == null)\n            driverPath = pullParam(\"-cp\");\n        return driverPath;\n    }\n\n    /**\n     * The filename of the cascading style sheet to use.\n     * Note that this file is parsed and used to determine characteristics\n     * of the generated diagrams, so it must contain specific settings that\n     * are documented within schemaSpy.css.<p>\n     *\n     * Defaults to <code>\"schemaSpy.css\"</code>.\n     *\n     * @param css\n     */\n    public void setCss(String css) {\n        this.css = css;\n    }\n\n    public String getCss() {\n        if (css == null) {\n            css = pullParam(\"-css\");\n            if (css == null)\n                css = \"schemaSpy.css\";\n        }\n        return css;\n    }\n\n    /**\n     * The font to use within diagrams.  Modify the .css to specify HTML fonts.\n     *\n     * @param font\n     */\n    public void setFont(String font) {\n        this.font = font;\n    }\n\n    /**\n     * @see #setFont(String)\n     */\n    public String getFont() {\n        if (font == null) {\n            font = pullParam(\"-font\");\n            if (font == null)\n                font = \"Helvetica\";\n        }\n        return font;\n    }\n\n    /**\n     * The font size to use within diagrams.  This is the size of the font used for\n     * 'large' (e.g. not 'compact') diagrams.<p>\n     *\n     * Modify the .css to specify HTML font sizes.<p>\n     *\n     * Defaults to 11.\n     *\n     * @param fontSize\n     */\n    public void setFontSize(int fontSize) {\n        this.fontSize = new Integer(fontSize);\n    }\n\n    /**\n     * @see #setFontSize(int)\n     * @return\n     */\n    public int getFontSize() {\n        if (fontSize == null) {\n            // default\n            int size = 11;\n            try {\n                size = Integer.parseInt(pullParam(\"-fontsize\"));\n            } catch (Exception notSpecified) {\n            }\n            fontSize = new Integer(size);\n        }\n        return fontSize.intValue();\n    }\n\n    /**\n     * The character set to use within HTML pages (defaults to <code>\"ISO-8859-1\"</code>).\n     *\n     * @param charset\n     */\n    public void setCharset(String charset) {\n        this.charset = charset;\n    }\n\n    /**\n     * @see #setCharset(String)\n     */\n    public String getCharset() {\n        if (charset == null) {\n            charset = pullParam(\"-charset\");\n            if (charset == null)\n                charset = \"ISO-8859-1\";\n        }\n        return charset;\n    }\n\n    /**\n     * Description of schema that gets display on main pages.\n     *\n     * @param description\n     */\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    /**\n     * @see #setDescription(String)\n     */\n    public String getDescription() {\n        if (description == null)\n            description = pullParam(\"-desc\");\n        return description;\n    }\n\n    /**\n     * Maximum number of threads to use when querying database metadata information.\n     *\n     * @param maxDbThreads\n     */\n    public void setMaxDbThreads(int maxDbThreads) {\n        this.maxDbThreads = new Integer(maxDbThreads);\n    }\n\n    /**\n     * @see #setMaxDbThreads(int)\n     * @throws InvalidConfigurationException if unable to load properties\n     */\n    public int getMaxDbThreads() throws InvalidConfigurationException {\n        if (maxDbThreads == null) {\n            Properties properties;\n            try {\n                properties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(\"Failed to load properties for \" + getDbType() + \": \" + exc).setParamName(\"-type\");\n            }\n            // not scientifically derived\n            final int defaultMax = 15;\n            int max = defaultMax;\n            String threads = properties.getProperty(\"dbThreads\");\n            if (threads == null)\n                threads = properties.getProperty(\"dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            threads = pullParam(\"-dbThreads\");\n            if (threads == null)\n                threads = pullParam(\"-dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            if (max < 0)\n                max = defaultMax;\n            else if (max == 0)\n                max = 1;\n            maxDbThreads = new Integer(max);\n        }\n        return maxDbThreads.intValue();\n    }\n\n    public boolean isLogoEnabled() {\n        if (logoEnabled == null)\n            logoEnabled = !options.remove(\"-nologo\");\n        return logoEnabled;\n    }\n\n    /**\n     * Don't use this unless absolutely necessary as it screws up the layout\n     *\n     * @param enabled\n     */\n    public void setRankDirBugEnabled(boolean enabled) {\n        rankDirBugEnabled = enabled;\n    }\n\n    /**\n     * @see #setRankDirBugEnabled(boolean)\n     */\n    public boolean isRankDirBugEnabled() {\n        if (rankDirBugEnabled == null)\n            rankDirBugEnabled = options.remove(\"-rankdirbug\");\n        return rankDirBugEnabled;\n    }\n\n    /**\n     * Look for Ruby on Rails-based naming conventions in\n     * relationships between logical foreign keys and primary keys.<p>\n     *\n     * Basically all tables have a primary key named <code>ID</code>.\n     * All tables are named plural names.\n     * The columns that logically reference that <code>ID</code> are the singular\n     * form of the table name suffixed with <code>_ID</code>.<p>\n     *\n     * @param enabled\n     */\n    public void setRailsEnabled(boolean enabled) {\n        railsEnabled = enabled;\n    }\n\n    /**\n     * @see #setRailsEnabled(boolean)\n     *\n     * @return\n     */\n    public boolean isRailsEnabled() {\n        if (railsEnabled == null)\n            railsEnabled = options.remove(\"-rails\");\n        return railsEnabled;\n    }\n\n    /**\n     * Allow Html In Comments - encode them unless otherwise specified\n     */\n    public void setEncodeCommentsEnabled(boolean enabled) {\n        encodeCommentsEnabled = enabled;\n    }\n\n    /**\n     * @see #setEncodeCommentsEnabled(boolean)\n     */\n    public boolean isEncodeCommentsEnabled() {\n        if (encodeCommentsEnabled == null)\n            encodeCommentsEnabled = !options.remove(\"-ahic\");\n        return encodeCommentsEnabled;\n    }\n\n    /**\n     * If enabled we'll attempt to query/render the number of rows that\n     * each table contains.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setNumRowsEnabled(boolean enabled) {\n        numRowsEnabled = enabled;\n    }\n\n    /**\n     * @see #setNumRowsEnabled(boolean)\n     * @return\n     */\n    public boolean isNumRowsEnabled() {\n        if (numRowsEnabled == null)\n            numRowsEnabled = !options.remove(\"-norows\");\n        return numRowsEnabled;\n    }\n\n    /**\n     * If enabled we'll include views in the analysis.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setViewsEnabled(boolean enabled) {\n        viewsEnabled = enabled;\n    }\n\n    /**\n     * @see #setViewsEnabled(boolean)\n     * @return\n     */\n    public boolean isViewsEnabled() {\n        if (viewsEnabled == null)\n            viewsEnabled = !options.remove(\"-noviews\");\n        return viewsEnabled;\n    }\n\n    /**\n     * Returns <code>true</code> if metering should be embedded in\n     * the generated pages.<p/>\n     * Defaults to <code>false</code> (disabled).\n     * @return\n     */\n    public boolean isMeterEnabled() {\n        if (meterEnabled == null)\n            meterEnabled = options.remove(\"-meter\");\n        return meterEnabled;\n    }\n\n    /**\n     * Set the columns to exclude from all relationship diagrams.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setColumnExclusions(String columnExclusions) {\n        this.columnExclusions = Pattern.compile(columnExclusions);\n    }\n\n    /**\n     * See {@link #setColumnExclusions(String)}\n     * @return\n     */\n    public Pattern getColumnExclusions() {\n        if (columnExclusions == null) {\n            String strExclusions = pullParam(\"-X\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.columnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            columnExclusions = Pattern.compile(strExclusions);\n        }\n        return columnExclusions;\n    }\n\n    /**\n     * Set the columns to exclude from relationship diagrams where the specified\n     * columns aren't directly referenced by the focal table.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setIndirectColumnExclusions(String fullColumnExclusions) {\n        indirectColumnExclusions = Pattern.compile(fullColumnExclusions);\n    }\n\n    /**\n     * @see #setIndirectColumnExclusions(String)\n     *\n     * @return\n     */\n    public Pattern getIndirectColumnExclusions() {\n        if (indirectColumnExclusions == null) {\n            String strExclusions = pullParam(\"-x\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.indirectColumnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            indirectColumnExclusions = Pattern.compile(strExclusions);\n        }\n        return indirectColumnExclusions;\n    }\n\n    /**\n     * Set the tables to include as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableInclusions(String tableInclusions) {\n        this.tableInclusions = Pattern.compile(tableInclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to include in the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableInclusions() {\n        if (tableInclusions == null) {\n            String strInclusions = pullParam(\"-i\");\n            if (strInclusions == null)\n                strInclusions = System.getenv(\"schemaspy.tableInclusions\");\n            if (strInclusions == null)\n                strInclusions = DEFAULT_TABLE_INCLUSION;\n            try {\n                tableInclusions = Pattern.compile(strInclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-i\");\n            }\n        }\n        return tableInclusions;\n    }\n\n    /**\n     * Set the tables to exclude as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableExclusions(String tableExclusions) {\n        this.tableExclusions = Pattern.compile(tableExclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to exclude from the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableExclusions() {\n        if (tableExclusions == null) {\n            String strExclusions = pullParam(\"-I\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.tableExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_TABLE_EXCLUSION;\n            try {\n                tableExclusions = Pattern.compile(strExclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-I\");\n            }\n        }\n        return tableExclusions;\n    }\n\n    /**\n     * @return\n     */\n    public List<String> getSchemas() {\n        if (schemas == null) {\n            String tmp = pullParam(\"-schemas\");\n            if (tmp == null)\n                tmp = pullParam(\"-schemata\");\n            if (tmp != null) {\n                schemas = new ArrayList<String>();\n                for (String name : tmp.split(\"[\\\\s,'\\\"]\")) {\n                    if (name.length() > 0)\n                        schemas.add(name);\n                }\n                if (schemas.isEmpty())\n                    schemas = null;\n            }\n        }\n        return schemas;\n    }\n\n    /**\n     * Set the name of the {@link SqlFormatter SQL formatter} class to use to\n     * format SQL into HTML.<p/>\n     * The implementation of the class must be made available to the class\n     * loader, typically by specifying the path to its jar with <em>-dp</em>\n     * ({@link #setDriverPath(String)}).\n     */\n    public void setSqlFormatter(String formatterClassName) {\n        sqlFormatterClass = formatterClassName;\n        sqlFormatter = null;\n    }\n\n    /**\n     * Set the {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.\n     */\n    public void setSqlFormatter(SqlFormatter sqlFormatter) {\n        this.sqlFormatter = sqlFormatter;\n        if (sqlFormatter != null)\n            sqlFormatterClass = sqlFormatter.getClass().getName();\n    }\n\n    /**\n     * Returns an implementation of {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.  The default implementation is {@link DefaultSqlFormatter}.\n     *\n     * @return\n     * @throws InvalidConfigurationException if unable to instantiate an instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SqlFormatter getSqlFormatter() throws InvalidConfigurationException {\n        if (sqlFormatter == null) {\n            if (sqlFormatterClass == null) {\n                sqlFormatterClass = pullParam(\"-sqlFormatter\");\n                if (sqlFormatterClass == null)\n                    sqlFormatterClass = DefaultSqlFormatter.class.getName();\n            }\n            try {\n                Class<SqlFormatter> clazz = (Class<SqlFormatter>) Class.forName(sqlFormatterClass);\n                sqlFormatter = clazz.newInstance();\n            } catch (Exception exc) {\n                throw new InvalidConfigurationException(\"Failed to initialize instance of SQL formatter: \", exc).setParamName(\"-sqlFormatter\");\n            }\n        }\n        return sqlFormatter;\n    }\n\n    /**\n     * Set the details to show on the columns page, where \"details\" are\n     * comma and/or space separated.\n     *\n     * Valid values:\n     * <ul>\n     * <li>id</li>\n     * <li>table</li>\n     * <li>column</li>\n     * <li>type</li>\n     * <li>size</li>\n     * <li>nulls</li>\n     * <li>auto</li>\n     * <li>default</li>\n     * <li>children</li>\n     * <li>parents</li>\n     * </ul>\n     *\n     * The default details are <code>\"table column type size nulls auto default\"</code>.\n     * Note that \"column\" is the initially displayed detail and must be included.\n     *\n     * @param columnDetails\n     */\n    public void setColumnDetails(String columnDetails) {\n        this.columnDetails = new ArrayList<String>();\n        if (columnDetails == null || columnDetails.length() == 0) {\n            // not specified, so use defaults\n            columnDetails = \"id table column type size nulls auto default\";\n        }\n        for (String detail : columnDetails.split(\"[\\\\s,'\\\"]\")) {\n            if (detail.length() > 0) {\n                this.columnDetails.add(detail.toLowerCase());\n            }\n        }\n        if (!this.columnDetails.contains(\"column\"))\n            throw new InvalidConfigurationException(\"'column' is a required column detail\");\n    }\n\n    public void setColumnDetails(List<String> columnDetails) {\n        String details = columnDetails == null ? \"[]\" : columnDetails.toString();\n        setColumnDetails(details.substring(1, details.length() - 1));\n    }\n\n    public List<String> getColumnDetails() {\n        if (columnDetails == null) {\n            setColumnDetails(pullParam(\"-columndetails\"));\n        }\n        return columnDetails;\n    }\n\n    public void setEvaluateAllEnabled(boolean enabled) {\n        evaluteAll = enabled;\n    }\n\n    public boolean isEvaluateAllEnabled() {\n        if (evaluteAll == null)\n            evaluteAll = options.remove(\"-all\");\n        return evaluteAll;\n    }\n\n    /**\n     * Returns true if we're evaluating a bunch of schemas in one go and\n     * at this point we're evaluating a specific schema.\n     *\n     * @return boolean\n     */\n    public boolean isOneOfMultipleSchemas() {\n        // set by MultipleSchemaAnalyzer\n        return Boolean.getBoolean(\"oneofmultipleschemas\");\n    }\n\n    /**\n     * When -all (evaluateAll) is specified then this is the regular\n     * expression that determines which schemas to evaluate.\n     *\n     * @param schemaSpec\n     */\n    public void setSchemaSpec(String schemaSpec) {\n        this.schemaSpec = schemaSpec;\n    }\n\n    public String getSchemaSpec() {\n        if (schemaSpec == null)\n            schemaSpec = pullParam(\"-schemaSpec\");\n        return schemaSpec;\n    }\n\n    /**\n     * Set the renderer to use for the -Tpng[:renderer[:formatter]] dot option as specified\n     * at <a href='http://www.graphviz.org/doc/info/command.html'>\n     * http://www.graphviz.org/doc/info/command.html</a>.<p>\n     * Note that the leading \":\" is required while :formatter is optional.<p>\n     * The default renderer is typically GD.<p>\n     * Note that using {@link #setHighQuality(boolean)} is the preferred approach\n     * over using this method.\n     */\n    public void setRenderer(String renderer) {\n        Dot.getInstance().setRenderer(renderer);\n    }\n\n    /**\n     * @see #setRenderer(String)\n     * @return\n     */\n    public String getRenderer() {\n        String renderer = pullParam(\"-renderer\");\n        if (renderer != null)\n            setRenderer(renderer);\n        return Dot.getInstance().getRenderer();\n    }\n\n    /**\n     * If <code>false</code> then generate output of \"lower quality\"\n     * than the default.\n     * Note that the default is intended to be \"higher quality\",\n     * but various installations of Graphviz may have have different abilities.\n     * That is, some might not have the \"lower quality\" libraries and others might\n     * not have the \"higher quality\" libraries.<p>\n     * Higher quality output takes longer to generate and results in significantly\n     * larger image files (which take longer to download / display), but it generally\n     * looks better.\n     */\n    public void setHighQuality(boolean highQuality) {\n        this.highQuality = highQuality;\n        lowQuality = !highQuality;\n        Dot.getInstance().setHighQuality(highQuality);\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isHighQuality() {\n        if (highQuality == null) {\n            highQuality = options.remove(\"-hq\");\n            if (highQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(highQuality);\n            }\n        }\n        highQuality = Dot.getInstance().isHighQuality();\n        return highQuality;\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isLowQuality() {\n        if (lowQuality == null) {\n            lowQuality = options.remove(\"-lq\");\n            if (lowQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(!lowQuality);\n            }\n        }\n        lowQuality = !Dot.getInstance().isHighQuality();\n        return lowQuality;\n    }\n\n    /**\n     * Set the level of logging to perform.<p/>\n     * The levels in descending order are:\n     * <ul>\n     *  <li><code>severe</code> (highest - least detail)\n     *  <li><code>warning</code> (default)\n     *  <li><code>info</code>\n     *  <li><code>config</code>\n     *  <li><code>fine</code>\n     *  <li><code>finer</code>\n     *  <li><code>finest</code>  (lowest - most detail)\n     * </ul>\n     *\n     * @param logLevel\n     */\n    public void setLogLevel(String logLevel) {\n        if (logLevel == null) {\n            this.logLevel = Level.WARNING;\n            return;\n        }\n        Map<String, Level> levels = new LinkedHashMap<String, Level>();\n        levels.put(\"severe\", Level.SEVERE);\n        levels.put(\"warning\", Level.WARNING);\n        levels.put(\"info\", Level.INFO);\n        levels.put(\"config\", Level.CONFIG);\n        levels.put(\"fine\", Level.FINE);\n        levels.put(\"finer\", Level.FINER);\n        levels.put(\"finest\", Level.FINEST);\n        this.logLevel = levels.get(logLevel.toLowerCase());\n        if (this.logLevel == null) {\n            throw new InvalidConfigurationException(\"Invalid logLevel: '\" + logLevel + \"'. Must be one of: \" + levels.keySet());\n        }\n    }\n\n    /**\n     * Returns the level of logging to perform.\n     * See {@link #setLogLevel(String)}.\n     *\n     * @return\n     */\n    public Level getLogLevel() {\n        if (logLevel == null) {\n            setLogLevel(pullParam(\"-loglevel\"));\n        }\n        return logLevel;\n    }\n\n    /**\n     * Returns <code>true</code> if the options indicate that the user wants\n     * to see some help information.\n     *\n     * @return\n     */\n    public boolean isHelpRequired() {\n        return helpRequired;\n    }\n\n    public boolean isDbHelpRequired() {\n        return dbHelpRequired;\n    }\n\n    /**\n     * Returns the jar that we were loaded from\n     *\n     * @return\n     */\n    public static String getLoadedFromJar() {\n        String classpath = System.getProperty(\"java.class.path\");\n        return new StringTokenizer(classpath, File.pathSeparator).nextToken();\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasOrphans(boolean hasOrphans) {\n        this.hasOrphans = hasOrphans;\n    }\n\n    /**\n     * @see #setHasOrphans()\n     *\n     * @return\n     */\n    public boolean hasOrphans() {\n        return hasOrphans;\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasRoutines(boolean hasRoutines) {\n        this.hasRoutines = hasRoutines;\n    }\n\n    /**\n     * @see #setHasRoutines()\n     *\n     * @return\n     */\n    public boolean hasRoutines() {\n        return hasRoutines;\n    }\n\n    /**\n     * Returns the database properties to use.\n     * These should be determined by calling {@link #determineDbProperties(String)}.\n     * @return\n     * @throws InvalidConfigurationException\n     */\n    public Properties getDbProperties() throws InvalidConfigurationException {\n        if (dbProperties == null) {\n            try {\n                dbProperties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(exc);\n            }\n        }\n        return dbProperties;\n    }\n\n    /**\n     * Determines the database properties associated with the specified type.\n     * A call to {@link #setDbProperties(Properties)} is expected after determining\n     * the complete set of properties.\n     *\n     * @param type\n     * @return\n     * @throws IOException\n     * @throws InvalidConfigurationException if db properties are incorrectly formed\n     */\n    public Properties determineDbProperties(String type) throws IOException, InvalidConfigurationException {\n        ResourceBundle bundle = null;\n        try {\n            File propertiesFile = new File(type);\n            bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n            dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n        } catch (FileNotFoundException notFoundOnFilesystemWithoutExtension) {\n            try {\n                File propertiesFile = new File(type + \".properties\");\n                bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n                dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n            } catch (FileNotFoundException notFoundOnFilesystemWithExtensionTackedOn) {\n                try {\n                    bundle = ResourceBundle.getBundle(type);\n                    dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]\" + File.separator + type + \".properties\";\n                } catch (Exception notInJarWithoutPath) {\n                    try {\n                        String path = TableOrderer.class.getPackage().getName() + \".dbTypes.\" + type;\n                        path = path.replace('.', '/');\n                        bundle = ResourceBundle.getBundle(path);\n                        dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]/\" + path + \".properties\";\n                    } catch (Exception notInJar) {\n                        notInJar.printStackTrace();\n                        notFoundOnFilesystemWithExtensionTackedOn.printStackTrace();\n                        throw notFoundOnFilesystemWithoutExtension;\n                    }\n                }\n            }\n        }\n        Properties props = asProperties(bundle);\n        bundle = null;\n        // keep original thru recursion\n        String saveLoadedFrom = dbPropertiesLoadedFrom;\n        // bring in key/values pointed to by the include directive\n        // example: include.1=mysql::selectRowCountSql\n        for (int i = 1; true; ++i) {\n            String include = (String) props.remove(\"include.\" + i);\n            if (include == null)\n                break;\n            int separator = include.indexOf(\"::\");\n            if (separator == -1)\n                throw new InvalidConfigurationException(\"include directive in \" + dbPropertiesLoadedFrom + \" must have '::' between dbType and key\");\n            String refdType = include.substring(0, separator).trim();\n            String refdKey = include.substring(separator + 2).trim();\n            // recursively resolve the ref'd properties file and the ref'd key\n            Properties refdProps = determineDbProperties(refdType);\n            props.put(refdKey, refdProps.getProperty(refdKey));\n        }\n        // bring in base properties files pointed to by the extends directive\n        String baseDbType = (String) props.remove(\"extends\");\n        if (baseDbType != null) {\n            baseDbType = baseDbType.trim();\n            Properties baseProps = determineDbProperties(baseDbType);\n            // overlay our properties on top of the base's\n            baseProps.putAll(props);\n            props = baseProps;\n        }\n        // done with this level of recursion...restore original\n        dbPropertiesLoadedFrom = saveLoadedFrom;\n        // this won't be correct until the final recursion exits\n        dbProperties = props;\n        return props;\n    }\n\n    protected String getDbPropertiesLoadedFrom() throws IOException {\n        if (dbPropertiesLoadedFrom == null)\n            determineDbProperties(getDbType());\n        return dbPropertiesLoadedFrom;\n    }\n\n    public List<String> getRemainingParameters() {\n        try {\n            populate();\n        } catch (IllegalArgumentException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (IllegalAccessException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (InvocationTargetException exc) {\n            if (exc.getCause() instanceof InvalidConfigurationException)\n                throw (InvalidConfigurationException) exc.getCause();\n            throw new InvalidConfigurationException(exc.getCause());\n        } catch (IntrospectionException exc) {\n            throw new InvalidConfigurationException(exc);\n        }\n        return options;\n    }\n\n    /**\n     * Options that are specific to a type of database.  E.g. things like <code>host</code>,\n     * <code>port</code> or <code>db</code>, but <b>don't</b> have a setter in this class.\n     *\n     * @param dbSpecificOptions\n     */\n    public void setDbSpecificOptions(Map<String, String> dbSpecificOptions) {\n        this.dbSpecificOptions = dbSpecificOptions;\n        originalDbSpecificOptions = new HashMap<String, String>(dbSpecificOptions);\n    }\n\n    public Map<String, String> getDbSpecificOptions() {\n        if (dbSpecificOptions == null)\n            dbSpecificOptions = new HashMap<String, String>();\n        return dbSpecificOptions;\n    }\n\n    /**\n     * Returns a {@link Properties} populated with the contents of <code>bundle</code>\n     *\n     * @param bundle ResourceBundle\n     * @return Properties\n     */\n    public static Properties asProperties(ResourceBundle bundle) {\n        Properties props = new Properties();\n        Enumeration<String> iter = bundle.getKeys();\n        while (iter.hasMoreElements()) {\n            String key = iter.nextElement();\n            props.put(key, bundle.getObject(key));\n        }\n        return props;\n    }\n\n    /**\n     * 'Pull' the specified parameter from the collection of options. Returns\n     * null if the parameter isn't in the list and removes it if it is.\n     *\n     * @param paramId\n     * @return\n     */\n    private String pullParam(String paramId) {\n        return pullParam(paramId, false, false);\n    }\n\n    private String pullRequiredParam(String paramId) {\n        return pullParam(paramId, true, false);\n    }\n\n    /**\n     * @param paramId\n     * @param required\n     * @param dbTypeSpecific\n     * @return\n     * @throws MissingRequiredParameterException\n     */\n    private String pullParam(String paramId, boolean required, boolean dbTypeSpecific) throws MissingRequiredParameterException {\n        int paramIndex = options.indexOf(paramId);\n        if (paramIndex < 0) {\n            if (required)\n                throw new MissingRequiredParameterException(paramId, dbTypeSpecific);\n            return null;\n        }\n        options.remove(paramIndex);\n        String param = options.get(paramIndex).toString();\n        options.remove(paramIndex);\n        return param;\n    }\n\n    /**\n     * Thrown to indicate that a required parameter is missing\n     */\n    public static class MissingRequiredParameterException extends RuntimeException {\n\n        private static final long serialVersionUID = 1L;\n\n        private final boolean dbTypeSpecific;\n\n        public MissingRequiredParameterException(String paramId, boolean dbTypeSpecific) {\n            this(paramId, null, dbTypeSpecific);\n        }\n\n        public MissingRequiredParameterException(String paramId, String description, boolean dbTypeSpecific) {\n            super(\"Required parameter '\" + paramId + \"' \" + (description == null ? \"\" : \"(\" + description + \") \") + \"was not specified.\" + (dbTypeSpecific ? \"  It is required for this database type.\" : \"\"));\n            this.dbTypeSpecific = dbTypeSpecific;\n        }\n\n        public boolean isDbTypeSpecific() {\n            return dbTypeSpecific;\n        }\n    }\n\n    /**\n     * Allow an equal sign in args...like \"-o=foo.bar\". Useful for things like\n     * Ant and Maven.\n     *\n     * @param args\n     *            List\n     * @return List\n     */\n    protected List<String> fixupArgs(List<String> args) {\n        List<String> expandedArgs = new ArrayList<String>();\n        for (String arg : args) {\n            int indexOfEquals = arg.indexOf('=');\n            if (indexOfEquals != -1 && indexOfEquals - 1 != arg.indexOf(ESCAPED_EQUALS)) {\n                expandedArgs.add(arg.substring(0, indexOfEquals));\n                expandedArgs.add(arg.substring(indexOfEquals + 1));\n            } else {\n                expandedArgs.add(arg);\n            }\n        }\n        // some OSes/JVMs do filename expansion with runtime.exec() and some don't,\n        // so MultipleSchemaAnalyzer has to surround params with double quotes...\n        // strip them here for the OSes/JVMs that don't do anything with the params\n        List<String> unquotedArgs = new ArrayList<String>();\n        for (String arg : expandedArgs) {\n            if (// \".*\" becomes .*\n            arg.startsWith(\"\\\"\") && arg.endsWith(\"\\\"\"))\n                arg = arg.substring(1, arg.length() - 1);\n            unquotedArgs.add(arg);\n        }\n        return unquotedArgs;\n    }\n\n    /**\n     * Call all the getters to populate all the lazy initialized stuff.\n     *\n     * @throws InvocationTargetException\n     * @throws IllegalAccessException\n     * @throws IllegalArgumentException\n     * @throws IntrospectionException\n     */\n    private void populate() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IntrospectionException {\n        if (!populating) {\n            // prevent recursion\n            populating = true;\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                Method readMethod = props[i].getReadMethod();\n                if (readMethod != null)\n                    readMethod.invoke(this, (Object[]) null);\n            }\n            populating = false;\n        }\n    }\n\n    public static Set<String> getBuiltInDatabaseTypes(String loadedFromJar) {\n        Set<String> databaseTypes = new TreeSet<String>();\n        JarInputStream jar = null;\n        try {\n            jar = new JarInputStream(new FileInputStream(loadedFromJar));\n            JarEntry entry;\n            while ((entry = jar.getNextJarEntry()) != null) {\n                String entryName = entry.getName();\n                int dotPropsIndex = entryName.indexOf(\".properties\");\n                if (dotPropsIndex != -1)\n                    databaseTypes.add(entryName.substring(0, dotPropsIndex));\n            }\n        } catch (IOException exc) {\n        } finally {\n            if (jar != null) {\n                try {\n                    jar.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n        return databaseTypes;\n    }\n\n    protected void dumpUsage(String errorMessage, boolean detailedDb) {\n        if (errorMessage != null) {\n            System.out.flush();\n            System.err.println(\"*** \" + errorMessage + \" ***\");\n        } else {\n            System.out.println(\"SchemaSpy generates an HTML representation of a database schema's relationships.\");\n        }\n        System.err.flush();\n        System.out.println();\n        if (!detailedDb) {\n            System.out.println(\"Usage:\");\n            System.out.println(\" java -jar \" + getLoadedFromJar() + \" [options]\");\n            System.out.println(\"   -t databaseType       type of database - defaults to ora\");\n            System.out.println(\"                           use -dbhelp for a list of built-in types\");\n            System.out.println(\"   -u user               connect to the database with this user id\");\n            System.out.println(\"   -s schema             defaults to the specified user\");\n            System.out.println(\"   -p password           defaults to no password\");\n            System.out.println(\"   -o outputDirectory    directory to place the generated output in\");\n            System.out.println(\"   -dp pathToDrivers     optional - looks for JDBC drivers here before looking\");\n            System.out.println(\"                           in driverPath in [databaseType].properties.\");\n            System.out.println(\"Go to http://schemaspy.sourceforge.net for a complete list/description\");\n            System.out.println(\" of additional parameters.\");\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"Built-in database types and their required connection parameters:\");\n            for (String type : getBuiltInDatabaseTypes(getLoadedFromJar())) {\n                new DbSpecificConfig(type).dumpUsage();\n            }\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"You can use your own database types by specifying the filespec of a .properties file with -t.\");\n            System.out.println(\"Grab one out of \" + getLoadedFromJar() + \" and modify it to suit your needs.\");\n            System.out.println();\n        }\n        System.out.println(\"Sample usage using the default database type (implied -t ora):\");\n        System.out.println(\" java -jar schemaSpy.jar -db mydb -s myschema -u devuser -p password -o output\");\n        System.out.println();\n        System.out.flush();\n    }\n\n    /**\n     * Get the value of the specified parameter.\n     * Used for properties that are common to most db's, but aren't required.\n     *\n     * @param paramName\n     * @return\n     */\n    public String getParam(String paramName) {\n        try {\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                PropertyDescriptor prop = props[i];\n                if (prop.getName().equalsIgnoreCase(paramName)) {\n                    Object result = prop.getReadMethod().invoke(this, (Object[]) null);\n                    return result == null ? null : result.toString();\n                }\n            }\n        } catch (Exception failed) {\n            failed.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * Return all of the configuration options as a List of Strings, with\n     * each parameter and its value as a separate element.\n     *\n     * @return\n     * @throws IOException\n     */\n    public List<String> asList() throws IOException {\n        List<String> params = new ArrayList<String>();\n        if (originalDbSpecificOptions != null) {\n            for (String key : originalDbSpecificOptions.keySet()) {\n                String value = originalDbSpecificOptions.get(key);\n                if (!key.startsWith(\"-\"))\n                    key = \"-\" + key;\n                params.add(key);\n                params.add(value);\n            }\n        }\n        if (isEncodeCommentsEnabled())\n            params.add(\"-ahic\");\n        if (isEvaluateAllEnabled())\n            params.add(\"-all\");\n        if (!isHtmlGenerationEnabled())\n            params.add(\"-nohtml\");\n        if (!isImpliedConstraintsEnabled())\n            params.add(\"-noimplied\");\n        if (!isLogoEnabled())\n            params.add(\"-nologo\");\n        if (isMeterEnabled())\n            params.add(\"-meter\");\n        if (!isNumRowsEnabled())\n            params.add(\"-norows\");\n        if (!isViewsEnabled())\n            params.add(\"-noviews\");\n        if (isRankDirBugEnabled())\n            params.add(\"-rankdirbug\");\n        if (isRailsEnabled())\n            params.add(\"-rails\");\n        if (isSingleSignOn())\n            params.add(\"-sso\");\n        if (isSchemaDisabled())\n            params.add(\"-noschema\");\n        String value = getDriverPath();\n        if (value != null) {\n            params.add(\"-dp\");\n            params.add(value);\n        }\n        params.add(\"-css\");\n        params.add(getCss());\n        params.add(\"-charset\");\n        params.add(getCharset());\n        params.add(\"-font\");\n        params.add(getFont());\n        params.add(\"-fontsize\");\n        params.add(String.valueOf(getFontSize()));\n        params.add(\"-t\");\n        params.add(getDbType());\n        // query to set renderer correctly\n        isHighQuality();\n        // query to set renderer correctly\n        isLowQuality();\n        // instead of -hq and/or -lq\n        params.add(\"-renderer\");\n        params.add(getRenderer());\n        value = getDescription();\n        if (value != null) {\n            params.add(\"-desc\");\n            params.add(value);\n        }\n        value = getPassword();\n        if (value != null && !isPromptForPasswordEnabled()) {\n            // note that we don't pass -pfp since child processes\n            // won't have a console\n            params.add(\"-p\");\n            params.add(value);\n        }\n        value = getCatalog();\n        if (value != null) {\n            params.add(\"-cat\");\n            params.add(value);\n        }\n        value = getSchema();\n        if (value != null) {\n            params.add(\"-s\");\n            params.add(value);\n        }\n        value = getUser();\n        if (value != null) {\n            params.add(\"-u\");\n            params.add(value);\n        }\n        value = getConnectionPropertiesFile();\n        if (value != null) {\n            params.add(\"-connprops\");\n            params.add(value);\n        } else {\n            Properties props = getConnectionProperties();\n            if (!props.isEmpty()) {\n                params.add(\"-connprops\");\n                StringBuilder buf = new StringBuilder();\n                for (Entry<Object, Object> entry : props.entrySet()) {\n                    buf.append(entry.getKey());\n                    buf.append(ESCAPED_EQUALS);\n                    buf.append(entry.getValue());\n                    buf.append(';');\n                }\n                params.add(buf.toString());\n            }\n        }\n        value = getDb();\n        if (value != null) {\n            params.add(\"-db\");\n            params.add(value);\n        }\n        value = getHost();\n        if (value != null) {\n            params.add(\"-host\");\n            params.add(value);\n        }\n        if (getPort() != null) {\n            params.add(\"-port\");\n            params.add(getPort().toString());\n        }\n        value = getServer();\n        if (value != null) {\n            params.add(\"-server\");\n            params.add(value);\n        }\n        value = getMeta();\n        if (value != null) {\n            params.add(\"-meta\");\n            params.add(value);\n        }\n        if (getGraphvizDir() != null) {\n            params.add(\"-gv\");\n            params.add(getGraphvizDir().toString());\n        }\n        params.add(\"-loglevel\");\n        params.add(getLogLevel().toString().toLowerCase());\n        params.add(\"-sqlFormatter\");\n        params.add(getSqlFormatter().getClass().getName());\n        params.add(\"-i\");\n        params.add(getTableInclusions().toString());\n        params.add(\"-I\");\n        params.add(getTableExclusions().toString());\n        params.add(\"-X\");\n        params.add(getColumnExclusions().toString());\n        params.add(\"-x\");\n        params.add(getIndirectColumnExclusions().toString());\n        params.add(\"-dbthreads\");\n        params.add(String.valueOf(getMaxDbThreads()));\n        params.add(\"-maxdet\");\n        params.add(String.valueOf(getMaxDetailedTables()));\n        params.add(\"-o\");\n        params.add(getOutputDir().toString());\n        return params;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/ConfigTest6.java",
		"test_prompt": "// ConfigTest6.java\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Config}.\n* It contains ten unit test cases for the {@link Config#isLogoEnabled()} method.\n*/\nclass ConfigTest6 {"
	},
	{
		"original_code": "// Config.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\n\n/**\n * Configuration of a SchemaSpy run\n *\n * @author John Currier\n */\npublic class Config {\n\n    private static Config instance;\n\n    private final List<String> options;\n\n    private Map<String, String> dbSpecificOptions;\n\n    private Map<String, String> originalDbSpecificOptions;\n\n    private boolean helpRequired;\n\n    private boolean dbHelpRequired;\n\n    private File outputDir;\n\n    private File graphvizDir;\n\n    private String dbType;\n\n    private String catalog;\n\n    private String schema;\n\n    private List<String> schemas;\n\n    private String user;\n\n    private Boolean singleSignOn;\n\n    private Boolean noSchema;\n\n    private String password;\n\n    private Boolean promptForPassword;\n\n    private String db;\n\n    private String host;\n\n    private Integer port;\n\n    private String server;\n\n    private String meta;\n\n    private Pattern tableInclusions;\n\n    private Pattern tableExclusions;\n\n    private Pattern columnExclusions;\n\n    private Pattern indirectColumnExclusions;\n\n    private String userConnectionPropertiesFile;\n\n    private Properties userConnectionProperties;\n\n    private Integer maxDbThreads;\n\n    private Integer maxDetailedTables;\n\n    private String driverPath;\n\n    private String css;\n\n    private String charset;\n\n    private String font;\n\n    private Integer fontSize;\n\n    private String description;\n\n    private Properties dbProperties;\n\n    private String dbPropertiesLoadedFrom;\n\n    private Level logLevel;\n\n    private SqlFormatter sqlFormatter;\n\n    private String sqlFormatterClass;\n\n    private Boolean generateHtml;\n\n    private Boolean includeImpliedConstraints;\n\n    private Boolean logoEnabled;\n\n    private Boolean rankDirBugEnabled;\n\n    private Boolean encodeCommentsEnabled;\n\n    private Boolean numRowsEnabled;\n\n    private Boolean viewsEnabled;\n\n    private Boolean meterEnabled;\n\n    private Boolean railsEnabled;\n\n    private Boolean evaluteAll;\n\n    private Boolean highQuality;\n\n    private Boolean lowQuality;\n\n    // used in conjunction with evaluateAll\n    private String schemaSpec;\n\n    private boolean hasOrphans = false;\n\n    private boolean hasRoutines = false;\n\n    private boolean populating = false;\n\n    private List<String> columnDetails;\n\n    public static final String DOT_CHARSET = \"UTF-8\";\n\n    private static final String ESCAPED_EQUALS = \"\\\\=\";\n\n    // match everything\n    private static final String DEFAULT_TABLE_INCLUSION = \".*\";\n\n    // match nothing\n    private static final String DEFAULT_TABLE_EXCLUSION = \"\";\n\n    // match nothing\n    private static final String DEFAULT_COLUMN_EXCLUSION = \"[^.]\";\n\n    /**\n     * Default constructor. Intended for when you want to inject properties\n     * independently (i.e. not from a command line interface).\n     */\n    public Config() {\n        if (instance == null)\n            setInstance(this);\n        options = new ArrayList<String>();\n    }\n\n    /**\n     * Construct a configuration from an array of options (e.g. from a command\n     * line interface).\n     *\n     * @param options\n     */\n    public Config(String[] argv) {\n        setInstance(this);\n        options = fixupArgs(Arrays.asList(argv));\n        helpRequired = options.remove(\"-?\") || options.remove(\"/?\") || options.remove(\"?\") || options.remove(\"-h\") || options.remove(\"-help\") || options.remove(\"--help\");\n        dbHelpRequired = options.remove(\"-dbHelp\") || options.remove(\"-dbhelp\");\n    }\n\n    public static Config getInstance() {\n        if (instance == null)\n            instance = new Config();\n        return instance;\n    }\n\n    /**\n     * Sets the global instance.\n     *\n     * Useful for things like selecting a specific configuration in a UI.\n     *\n     * @param config\n     */\n    public static void setInstance(Config config) {\n        instance = config;\n    }\n\n    public void setHtmlGenerationEnabled(boolean generateHtml) {\n        this.generateHtml = generateHtml;\n    }\n\n    public boolean isHtmlGenerationEnabled() {\n        if (generateHtml == null)\n            generateHtml = !options.remove(\"-nohtml\");\n        return generateHtml;\n    }\n\n    public void setImpliedConstraintsEnabled(boolean includeImpliedConstraints) {\n        this.includeImpliedConstraints = includeImpliedConstraints;\n    }\n\n    public boolean isImpliedConstraintsEnabled() {\n        if (includeImpliedConstraints == null)\n            includeImpliedConstraints = !options.remove(\"-noimplied\");\n        return includeImpliedConstraints;\n    }\n\n    public void setOutputDir(String outputDirName) {\n        if (outputDirName.endsWith(\"\\\"\"))\n            outputDirName = outputDirName.substring(0, outputDirName.length() - 1);\n        setOutputDir(new File(outputDirName));\n    }\n\n    public void setOutputDir(File outputDir) {\n        this.outputDir = outputDir;\n    }\n\n    public File getOutputDir() {\n        if (outputDir == null) {\n            setOutputDir(pullRequiredParam(\"-o\"));\n        }\n        return outputDir;\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(String graphvizDir) {\n        if (graphvizDir.endsWith(\"\\\"\"))\n            graphvizDir = graphvizDir.substring(0, graphvizDir.length() - 1);\n        setGraphvizDir(new File(graphvizDir));\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(File graphvizDir) {\n        this.graphvizDir = graphvizDir;\n    }\n\n    /**\n     * Return the path to Graphviz (used to find the dot executable to run to\n     * generate ER diagrams).<p/>\n     *\n     * Returns {@link #getDefaultGraphvizPath()} if a specific Graphviz path\n     * was not specified.\n     *\n     * @return\n     */\n    public File getGraphvizDir() {\n        if (graphvizDir == null) {\n            String gv = pullParam(\"-gv\");\n            if (gv != null) {\n                setGraphvizDir(gv);\n            } else {\n                // expect to find Graphviz's bin directory on the PATH\n            }\n        }\n        return graphvizDir;\n    }\n\n    /**\n     * Meta files are XML-based files that provide additional metadata\n     * about the schema being evaluated.<p>\n     * <code>meta</code> is either the name of an individual XML file or\n     * the directory that contains meta files.<p>\n     * If a directory is specified then it is expected to contain files\n     * matching the pattern <code>[schema].meta.xml</code>.\n     * For databases that don't have schema substitute database for schema.\n     * @param meta\n     */\n    public void setMeta(String meta) {\n        this.meta = meta;\n    }\n\n    public String getMeta() {\n        if (meta == null)\n            meta = pullParam(\"-meta\");\n        return meta;\n    }\n\n    public void setDbType(String dbType) {\n        this.dbType = dbType;\n    }\n\n    public String getDbType() {\n        if (dbType == null) {\n            dbType = pullParam(\"-t\");\n            if (dbType == null)\n                dbType = \"ora\";\n        }\n        return dbType;\n    }\n\n    public void setDb(String db) {\n        this.db = db;\n    }\n\n    public String getDb() {\n        if (db == null)\n            db = pullParam(\"-db\");\n        return db;\n    }\n\n    public void setCatalog(String catalog) {\n        this.catalog = catalog;\n    }\n\n    public String getCatalog() {\n        if (catalog == null)\n            catalog = pullParam(\"-cat\");\n        return catalog;\n    }\n\n    public void setSchema(String schema) {\n        this.schema = schema;\n    }\n\n    public String getSchema() {\n        if (schema == null)\n            schema = pullParam(\"-s\");\n        return schema;\n    }\n\n    /**\n     * Some databases types (e.g. older versions of Informix) don't really\n     * have the concept of a schema but still return true from\n     * {@link DatabaseMetaData#supportsSchemasInTableDefinitions()}.\n     * This option lets you ignore that and treat all the tables\n     * as if they were in one flat namespace.\n     */\n    public boolean isSchemaDisabled() {\n        if (noSchema == null)\n            noSchema = options.remove(\"-noschema\");\n        return noSchema;\n    }\n\n    public void setHost(String host) {\n        this.host = host;\n    }\n\n    public String getHost() {\n        if (host == null)\n            host = pullParam(\"-host\");\n        return host;\n    }\n\n    public void setPort(Integer port) {\n        this.port = port;\n    }\n\n    public Integer getPort() {\n        if (port == null)\n            try {\n                port = Integer.valueOf(pullParam(\"-port\"));\n            } catch (Exception notSpecified) {\n            }\n        return port;\n    }\n\n    public void setServer(String server) {\n        this.server = server;\n    }\n\n    public String getServer() {\n        if (server == null) {\n            server = pullParam(\"-server\");\n        }\n        return server;\n    }\n\n    public void setUser(String user) {\n        this.user = user;\n    }\n\n    /**\n     * User used to connect to the database.\n     * Required unless single sign-on is enabled\n     * (see {@link #setSingleSignOn(boolean)}).\n     * @return\n     */\n    public String getUser() {\n        if (user == null) {\n            if (!isSingleSignOn())\n                user = pullRequiredParam(\"-u\");\n            else\n                user = pullParam(\"-u\");\n        }\n        return user;\n    }\n\n    /**\n     * By default a \"user\" (as specified with -u) is required.\n     * This option allows disabling of that requirement for\n     * single sign-on environments.\n     *\n     * @param enabled defaults to <code>false</code>\n     */\n    public void setSingleSignOn(boolean enabled) {\n        singleSignOn = enabled;\n    }\n\n    /**\n     * @see #setSingleSignOn(boolean)\n     */\n    public boolean isSingleSignOn() {\n        if (singleSignOn == null)\n            singleSignOn = options.remove(\"-sso\");\n        return singleSignOn;\n    }\n\n    /**\n     * Set the password used to connect to the database.\n     * @param password\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * @see #setPassword(String)\n     * @return\n     */\n    public String getPassword() {\n        if (password == null)\n            password = pullParam(\"-p\");\n        if (password == null && isPromptForPasswordEnabled())\n            password = new String(PasswordReader.getInstance().readPassword(\"Password: \"));\n        if (password == null) {\n            // if -pfp is enabled when analyzing multiple schemas then\n            // we don't want to send the password on the command line,\n            // so see if it was passed in the environment (not ideal, but safer)\n            password = System.getenv(\"schemaspy.pw\");\n        }\n        return password;\n    }\n\n    /**\n     * Set to <code>true</code> to prompt for the password\n     * @param promptForPassword\n     */\n    public void setPromptForPasswordEnabled(boolean promptForPassword) {\n        this.promptForPassword = promptForPassword;\n    }\n\n    /**\n     * @see #setPromptForPasswordEnabled(boolean)\n     * @return\n     */\n    public boolean isPromptForPasswordEnabled() {\n        if (promptForPassword == null) {\n            promptForPassword = options.remove(\"-pfp\");\n        }\n        return promptForPassword;\n    }\n\n    public void setMaxDetailedTabled(int maxDetailedTables) {\n        this.maxDetailedTables = new Integer(maxDetailedTables);\n    }\n\n    public int getMaxDetailedTables() {\n        if (maxDetailedTables == null) {\n            // default\n            int max = 300;\n            try {\n                max = Integer.parseInt(pullParam(\"-maxdet\"));\n            } catch (Exception notSpecified) {\n            }\n            maxDetailedTables = new Integer(max);\n        }\n        return maxDetailedTables.intValue();\n    }\n\n    public String getConnectionPropertiesFile() {\n        return userConnectionPropertiesFile;\n    }\n\n    /**\n     * Properties from this file (in key=value pair format) are passed to the\n     * database connection.<br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.\n     * @param propertiesFilename\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public void setConnectionPropertiesFile(String propertiesFilename) throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null)\n            userConnectionProperties = new Properties();\n        userConnectionProperties.load(new FileInputStream(propertiesFilename));\n        userConnectionPropertiesFile = propertiesFilename;\n    }\n\n    /**\n     * Returns a {@link Properties} populated either from the properties file specified\n     * by {@link #setConnectionPropertiesFile(String)}, the properties specified by\n     * {@link #setConnectionProperties(String)} or not populated.\n     * @return\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public Properties getConnectionProperties() throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null) {\n            String props = pullParam(\"-connprops\");\n            if (props != null) {\n                if (props.indexOf(ESCAPED_EQUALS) != -1) {\n                    setConnectionProperties(props);\n                } else {\n                    setConnectionPropertiesFile(props);\n                }\n            } else {\n                userConnectionProperties = new Properties();\n            }\n        }\n        return userConnectionProperties;\n    }\n\n    /**\n     * Specifies connection properties to use in the format:\n     * <code>key1\\=value1;key2\\=value2</code><br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.<p>\n     * This is an alternative form of passing connection properties than by file\n     * (see {@link #setConnectionPropertiesFile(String)})\n     *\n     * @param properties\n     */\n    public void setConnectionProperties(String properties) {\n        userConnectionProperties = new Properties();\n        StringTokenizer tokenizer = new StringTokenizer(properties, \";\");\n        while (tokenizer.hasMoreElements()) {\n            String pair = tokenizer.nextToken();\n            int index = pair.indexOf(ESCAPED_EQUALS);\n            if (index != -1) {\n                String key = pair.substring(0, index);\n                String value = pair.substring(index + ESCAPED_EQUALS.length());\n                userConnectionProperties.put(key, value);\n            }\n        }\n    }\n\n    public void setDriverPath(String driverPath) {\n        this.driverPath = driverPath;\n    }\n\n    public String getDriverPath() {\n        if (driverPath == null)\n            driverPath = pullParam(\"-dp\");\n        // was previously -cp:\n        if (driverPath == null)\n            driverPath = pullParam(\"-cp\");\n        return driverPath;\n    }\n\n    /**\n     * The filename of the cascading style sheet to use.\n     * Note that this file is parsed and used to determine characteristics\n     * of the generated diagrams, so it must contain specific settings that\n     * are documented within schemaSpy.css.<p>\n     *\n     * Defaults to <code>\"schemaSpy.css\"</code>.\n     *\n     * @param css\n     */\n    public void setCss(String css) {\n        this.css = css;\n    }\n\n    public String getCss() {\n        if (css == null) {\n            css = pullParam(\"-css\");\n            if (css == null)\n                css = \"schemaSpy.css\";\n        }\n        return css;\n    }\n\n    /**\n     * The font to use within diagrams.  Modify the .css to specify HTML fonts.\n     *\n     * @param font\n     */\n    public void setFont(String font) {\n        this.font = font;\n    }\n\n    /**\n     * @see #setFont(String)\n     */\n    public String getFont() {\n        if (font == null) {\n            font = pullParam(\"-font\");\n            if (font == null)\n                font = \"Helvetica\";\n        }\n        return font;\n    }\n\n    /**\n     * The font size to use within diagrams.  This is the size of the font used for\n     * 'large' (e.g. not 'compact') diagrams.<p>\n     *\n     * Modify the .css to specify HTML font sizes.<p>\n     *\n     * Defaults to 11.\n     *\n     * @param fontSize\n     */\n    public void setFontSize(int fontSize) {\n        this.fontSize = new Integer(fontSize);\n    }\n\n    /**\n     * @see #setFontSize(int)\n     * @return\n     */\n    public int getFontSize() {\n        if (fontSize == null) {\n            // default\n            int size = 11;\n            try {\n                size = Integer.parseInt(pullParam(\"-fontsize\"));\n            } catch (Exception notSpecified) {\n            }\n            fontSize = new Integer(size);\n        }\n        return fontSize.intValue();\n    }\n\n    /**\n     * The character set to use within HTML pages (defaults to <code>\"ISO-8859-1\"</code>).\n     *\n     * @param charset\n     */\n    public void setCharset(String charset) {\n        this.charset = charset;\n    }\n\n    /**\n     * @see #setCharset(String)\n     */\n    public String getCharset() {\n        if (charset == null) {\n            charset = pullParam(\"-charset\");\n            if (charset == null)\n                charset = \"ISO-8859-1\";\n        }\n        return charset;\n    }\n\n    /**\n     * Description of schema that gets display on main pages.\n     *\n     * @param description\n     */\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    /**\n     * @see #setDescription(String)\n     */\n    public String getDescription() {\n        if (description == null)\n            description = pullParam(\"-desc\");\n        return description;\n    }\n\n    /**\n     * Maximum number of threads to use when querying database metadata information.\n     *\n     * @param maxDbThreads\n     */\n    public void setMaxDbThreads(int maxDbThreads) {\n        this.maxDbThreads = new Integer(maxDbThreads);\n    }\n\n    /**\n     * @see #setMaxDbThreads(int)\n     * @throws InvalidConfigurationException if unable to load properties\n     */\n    public int getMaxDbThreads() throws InvalidConfigurationException {\n        if (maxDbThreads == null) {\n            Properties properties;\n            try {\n                properties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(\"Failed to load properties for \" + getDbType() + \": \" + exc).setParamName(\"-type\");\n            }\n            // not scientifically derived\n            final int defaultMax = 15;\n            int max = defaultMax;\n            String threads = properties.getProperty(\"dbThreads\");\n            if (threads == null)\n                threads = properties.getProperty(\"dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            threads = pullParam(\"-dbThreads\");\n            if (threads == null)\n                threads = pullParam(\"-dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            if (max < 0)\n                max = defaultMax;\n            else if (max == 0)\n                max = 1;\n            maxDbThreads = new Integer(max);\n        }\n        return maxDbThreads.intValue();\n    }\n\n    public boolean isLogoEnabled() {\n        if (logoEnabled == null)\n            logoEnabled = !options.remove(\"-nologo\");\n        return logoEnabled;\n    }\n\n    /**\n     * Don't use this unless absolutely necessary as it screws up the layout\n     *\n     * @param enabled\n     */\n    public void setRankDirBugEnabled(boolean enabled) {\n        rankDirBugEnabled = enabled;\n    }\n\n    /**\n     * @see #setRankDirBugEnabled(boolean)\n     */\n    public boolean isRankDirBugEnabled() {\n        if (rankDirBugEnabled == null)\n            rankDirBugEnabled = options.remove(\"-rankdirbug\");\n        return rankDirBugEnabled;\n    }\n\n    /**\n     * Look for Ruby on Rails-based naming conventions in\n     * relationships between logical foreign keys and primary keys.<p>\n     *\n     * Basically all tables have a primary key named <code>ID</code>.\n     * All tables are named plural names.\n     * The columns that logically reference that <code>ID</code> are the singular\n     * form of the table name suffixed with <code>_ID</code>.<p>\n     *\n     * @param enabled\n     */\n    public void setRailsEnabled(boolean enabled) {\n        railsEnabled = enabled;\n    }\n\n    /**\n     * @see #setRailsEnabled(boolean)\n     *\n     * @return\n     */\n    public boolean isRailsEnabled() {\n        if (railsEnabled == null)\n            railsEnabled = options.remove(\"-rails\");\n        return railsEnabled;\n    }\n\n    /**\n     * Allow Html In Comments - encode them unless otherwise specified\n     */\n    public void setEncodeCommentsEnabled(boolean enabled) {\n        encodeCommentsEnabled = enabled;\n    }\n\n    /**\n     * @see #setEncodeCommentsEnabled(boolean)\n     */\n    public boolean isEncodeCommentsEnabled() {\n        if (encodeCommentsEnabled == null)\n            encodeCommentsEnabled = !options.remove(\"-ahic\");\n        return encodeCommentsEnabled;\n    }\n\n    /**\n     * If enabled we'll attempt to query/render the number of rows that\n     * each table contains.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setNumRowsEnabled(boolean enabled) {\n        numRowsEnabled = enabled;\n    }\n\n    /**\n     * @see #setNumRowsEnabled(boolean)\n     * @return\n     */\n    public boolean isNumRowsEnabled() {\n        if (numRowsEnabled == null)\n            numRowsEnabled = !options.remove(\"-norows\");\n        return numRowsEnabled;\n    }\n\n    /**\n     * If enabled we'll include views in the analysis.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setViewsEnabled(boolean enabled) {\n        viewsEnabled = enabled;\n    }\n\n    /**\n     * @see #setViewsEnabled(boolean)\n     * @return\n     */\n    public boolean isViewsEnabled() {\n        if (viewsEnabled == null)\n            viewsEnabled = !options.remove(\"-noviews\");\n        return viewsEnabled;\n    }\n\n    /**\n     * Returns <code>true</code> if metering should be embedded in\n     * the generated pages.<p/>\n     * Defaults to <code>false</code> (disabled).\n     * @return\n     */\n    public boolean isMeterEnabled() {\n        if (meterEnabled == null)\n            meterEnabled = options.remove(\"-meter\");\n        return meterEnabled;\n    }\n\n    /**\n     * Set the columns to exclude from all relationship diagrams.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setColumnExclusions(String columnExclusions) {\n        this.columnExclusions = Pattern.compile(columnExclusions);\n    }\n\n    /**\n     * See {@link #setColumnExclusions(String)}\n     * @return\n     */\n    public Pattern getColumnExclusions() {\n        if (columnExclusions == null) {\n            String strExclusions = pullParam(\"-X\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.columnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            columnExclusions = Pattern.compile(strExclusions);\n        }\n        return columnExclusions;\n    }\n\n    /**\n     * Set the columns to exclude from relationship diagrams where the specified\n     * columns aren't directly referenced by the focal table.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setIndirectColumnExclusions(String fullColumnExclusions) {\n        indirectColumnExclusions = Pattern.compile(fullColumnExclusions);\n    }\n\n    /**\n     * @see #setIndirectColumnExclusions(String)\n     *\n     * @return\n     */\n    public Pattern getIndirectColumnExclusions() {\n        if (indirectColumnExclusions == null) {\n            String strExclusions = pullParam(\"-x\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.indirectColumnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            indirectColumnExclusions = Pattern.compile(strExclusions);\n        }\n        return indirectColumnExclusions;\n    }\n\n    /**\n     * Set the tables to include as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableInclusions(String tableInclusions) {\n        this.tableInclusions = Pattern.compile(tableInclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to include in the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableInclusions() {\n        if (tableInclusions == null) {\n            String strInclusions = pullParam(\"-i\");\n            if (strInclusions == null)\n                strInclusions = System.getenv(\"schemaspy.tableInclusions\");\n            if (strInclusions == null)\n                strInclusions = DEFAULT_TABLE_INCLUSION;\n            try {\n                tableInclusions = Pattern.compile(strInclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-i\");\n            }\n        }\n        return tableInclusions;\n    }\n\n    /**\n     * Set the tables to exclude as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableExclusions(String tableExclusions) {\n        this.tableExclusions = Pattern.compile(tableExclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to exclude from the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableExclusions() {\n        if (tableExclusions == null) {\n            String strExclusions = pullParam(\"-I\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.tableExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_TABLE_EXCLUSION;\n            try {\n                tableExclusions = Pattern.compile(strExclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-I\");\n            }\n        }\n        return tableExclusions;\n    }\n\n    /**\n     * @return\n     */\n    public List<String> getSchemas() {\n        if (schemas == null) {\n            String tmp = pullParam(\"-schemas\");\n            if (tmp == null)\n                tmp = pullParam(\"-schemata\");\n            if (tmp != null) {\n                schemas = new ArrayList<String>();\n                for (String name : tmp.split(\"[\\\\s,'\\\"]\")) {\n                    if (name.length() > 0)\n                        schemas.add(name);\n                }\n                if (schemas.isEmpty())\n                    schemas = null;\n            }\n        }\n        return schemas;\n    }\n\n    /**\n     * Set the name of the {@link SqlFormatter SQL formatter} class to use to\n     * format SQL into HTML.<p/>\n     * The implementation of the class must be made available to the class\n     * loader, typically by specifying the path to its jar with <em>-dp</em>\n     * ({@link #setDriverPath(String)}).\n     */\n    public void setSqlFormatter(String formatterClassName) {\n        sqlFormatterClass = formatterClassName;\n        sqlFormatter = null;\n    }\n\n    /**\n     * Set the {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.\n     */\n    public void setSqlFormatter(SqlFormatter sqlFormatter) {\n        this.sqlFormatter = sqlFormatter;\n        if (sqlFormatter != null)\n            sqlFormatterClass = sqlFormatter.getClass().getName();\n    }\n\n    /**\n     * Returns an implementation of {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.  The default implementation is {@link DefaultSqlFormatter}.\n     *\n     * @return\n     * @throws InvalidConfigurationException if unable to instantiate an instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SqlFormatter getSqlFormatter() throws InvalidConfigurationException {\n        if (sqlFormatter == null) {\n            if (sqlFormatterClass == null) {\n                sqlFormatterClass = pullParam(\"-sqlFormatter\");\n                if (sqlFormatterClass == null)\n                    sqlFormatterClass = DefaultSqlFormatter.class.getName();\n            }\n            try {\n                Class<SqlFormatter> clazz = (Class<SqlFormatter>) Class.forName(sqlFormatterClass);\n                sqlFormatter = clazz.newInstance();\n            } catch (Exception exc) {\n                throw new InvalidConfigurationException(\"Failed to initialize instance of SQL formatter: \", exc).setParamName(\"-sqlFormatter\");\n            }\n        }\n        return sqlFormatter;\n    }\n\n    /**\n     * Set the details to show on the columns page, where \"details\" are\n     * comma and/or space separated.\n     *\n     * Valid values:\n     * <ul>\n     * <li>id</li>\n     * <li>table</li>\n     * <li>column</li>\n     * <li>type</li>\n     * <li>size</li>\n     * <li>nulls</li>\n     * <li>auto</li>\n     * <li>default</li>\n     * <li>children</li>\n     * <li>parents</li>\n     * </ul>\n     *\n     * The default details are <code>\"table column type size nulls auto default\"</code>.\n     * Note that \"column\" is the initially displayed detail and must be included.\n     *\n     * @param columnDetails\n     */\n    public void setColumnDetails(String columnDetails) {\n        this.columnDetails = new ArrayList<String>();\n        if (columnDetails == null || columnDetails.length() == 0) {\n            // not specified, so use defaults\n            columnDetails = \"id table column type size nulls auto default\";\n        }\n        for (String detail : columnDetails.split(\"[\\\\s,'\\\"]\")) {\n            if (detail.length() > 0) {\n                this.columnDetails.add(detail.toLowerCase());\n            }\n        }\n        if (!this.columnDetails.contains(\"column\"))\n            throw new InvalidConfigurationException(\"'column' is a required column detail\");\n    }\n\n    public void setColumnDetails(List<String> columnDetails) {\n        String details = columnDetails == null ? \"[]\" : columnDetails.toString();\n        setColumnDetails(details.substring(1, details.length() - 1));\n    }\n\n    public List<String> getColumnDetails() {\n        if (columnDetails == null) {\n            setColumnDetails(pullParam(\"-columndetails\"));\n        }\n        return columnDetails;\n    }\n\n    public void setEvaluateAllEnabled(boolean enabled) {\n        evaluteAll = enabled;\n    }\n\n    public boolean isEvaluateAllEnabled() {\n        if (evaluteAll == null)\n            evaluteAll = options.remove(\"-all\");\n        return evaluteAll;\n    }\n\n    /**\n     * Returns true if we're evaluating a bunch of schemas in one go and\n     * at this point we're evaluating a specific schema.\n     *\n     * @return boolean\n     */\n    public boolean isOneOfMultipleSchemas() {\n        // set by MultipleSchemaAnalyzer\n        return Boolean.getBoolean(\"oneofmultipleschemas\");\n    }\n\n    /**\n     * When -all (evaluateAll) is specified then this is the regular\n     * expression that determines which schemas to evaluate.\n     *\n     * @param schemaSpec\n     */\n    public void setSchemaSpec(String schemaSpec) {\n        this.schemaSpec = schemaSpec;\n    }\n\n    public String getSchemaSpec() {\n        if (schemaSpec == null)\n            schemaSpec = pullParam(\"-schemaSpec\");\n        return schemaSpec;\n    }\n\n    /**\n     * Set the renderer to use for the -Tpng[:renderer[:formatter]] dot option as specified\n     * at <a href='http://www.graphviz.org/doc/info/command.html'>\n     * http://www.graphviz.org/doc/info/command.html</a>.<p>\n     * Note that the leading \":\" is required while :formatter is optional.<p>\n     * The default renderer is typically GD.<p>\n     * Note that using {@link #setHighQuality(boolean)} is the preferred approach\n     * over using this method.\n     */\n    public void setRenderer(String renderer) {\n        Dot.getInstance().setRenderer(renderer);\n    }\n\n    /**\n     * @see #setRenderer(String)\n     * @return\n     */\n    public String getRenderer() {\n        String renderer = pullParam(\"-renderer\");\n        if (renderer != null)\n            setRenderer(renderer);\n        return Dot.getInstance().getRenderer();\n    }\n\n    /**\n     * If <code>false</code> then generate output of \"lower quality\"\n     * than the default.\n     * Note that the default is intended to be \"higher quality\",\n     * but various installations of Graphviz may have have different abilities.\n     * That is, some might not have the \"lower quality\" libraries and others might\n     * not have the \"higher quality\" libraries.<p>\n     * Higher quality output takes longer to generate and results in significantly\n     * larger image files (which take longer to download / display), but it generally\n     * looks better.\n     */\n    public void setHighQuality(boolean highQuality) {\n        this.highQuality = highQuality;\n        lowQuality = !highQuality;\n        Dot.getInstance().setHighQuality(highQuality);\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isHighQuality() {\n        if (highQuality == null) {\n            highQuality = options.remove(\"-hq\");\n            if (highQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(highQuality);\n            }\n        }\n        highQuality = Dot.getInstance().isHighQuality();\n        return highQuality;\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isLowQuality() {\n        if (lowQuality == null) {\n            lowQuality = options.remove(\"-lq\");\n            if (lowQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(!lowQuality);\n            }\n        }\n        lowQuality = !Dot.getInstance().isHighQuality();\n        return lowQuality;\n    }\n\n    /**\n     * Set the level of logging to perform.<p/>\n     * The levels in descending order are:\n     * <ul>\n     *  <li><code>severe</code> (highest - least detail)\n     *  <li><code>warning</code> (default)\n     *  <li><code>info</code>\n     *  <li><code>config</code>\n     *  <li><code>fine</code>\n     *  <li><code>finer</code>\n     *  <li><code>finest</code>  (lowest - most detail)\n     * </ul>\n     *\n     * @param logLevel\n     */\n    public void setLogLevel(String logLevel) {\n        if (logLevel == null) {\n            this.logLevel = Level.WARNING;\n            return;\n        }\n        Map<String, Level> levels = new LinkedHashMap<String, Level>();\n        levels.put(\"severe\", Level.SEVERE);\n        levels.put(\"warning\", Level.WARNING);\n        levels.put(\"info\", Level.INFO);\n        levels.put(\"config\", Level.CONFIG);\n        levels.put(\"fine\", Level.FINE);\n        levels.put(\"finer\", Level.FINER);\n        levels.put(\"finest\", Level.FINEST);\n        this.logLevel = levels.get(logLevel.toLowerCase());\n        if (this.logLevel == null) {\n            throw new InvalidConfigurationException(\"Invalid logLevel: '\" + logLevel + \"'. Must be one of: \" + levels.keySet());\n        }\n    }\n\n    /**\n     * Returns the level of logging to perform.\n     * See {@link #setLogLevel(String)}.\n     *\n     * @return\n     */\n    public Level getLogLevel() {\n        if (logLevel == null) {\n            setLogLevel(pullParam(\"-loglevel\"));\n        }\n        return logLevel;\n    }\n\n    /**\n     * Returns <code>true</code> if the options indicate that the user wants\n     * to see some help information.\n     *\n     * @return\n     */\n    public boolean isHelpRequired() {\n        return helpRequired;\n    }\n\n    public boolean isDbHelpRequired() {\n        return dbHelpRequired;\n    }\n\n    /**\n     * Returns the jar that we were loaded from\n     *\n     * @return\n     */\n    public static String getLoadedFromJar() {\n        String classpath = System.getProperty(\"java.class.path\");\n        return new StringTokenizer(classpath, File.pathSeparator).nextToken();\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasOrphans(boolean hasOrphans) {\n        this.hasOrphans = hasOrphans;\n    }\n\n    /**\n     * @see #setHasOrphans()\n     *\n     * @return\n     */\n    public boolean hasOrphans() {\n        return hasOrphans;\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasRoutines(boolean hasRoutines) {\n        this.hasRoutines = hasRoutines;\n    }\n\n    /**\n     * @see #setHasRoutines()\n     *\n     * @return\n     */\n    public boolean hasRoutines() {\n        return hasRoutines;\n    }\n\n    /**\n     * Returns the database properties to use.\n     * These should be determined by calling {@link #determineDbProperties(String)}.\n     * @return\n     * @throws InvalidConfigurationException\n     */\n    public Properties getDbProperties() throws InvalidConfigurationException {\n        if (dbProperties == null) {\n            try {\n                dbProperties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(exc);\n            }\n        }\n        return dbProperties;\n    }\n\n    /**\n     * Determines the database properties associated with the specified type.\n     * A call to {@link #setDbProperties(Properties)} is expected after determining\n     * the complete set of properties.\n     *\n     * @param type\n     * @return\n     * @throws IOException\n     * @throws InvalidConfigurationException if db properties are incorrectly formed\n     */\n    public Properties determineDbProperties(String type) throws IOException, InvalidConfigurationException {\n        ResourceBundle bundle = null;\n        try {\n            File propertiesFile = new File(type);\n            bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n            dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n        } catch (FileNotFoundException notFoundOnFilesystemWithoutExtension) {\n            try {\n                File propertiesFile = new File(type + \".properties\");\n                bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n                dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n            } catch (FileNotFoundException notFoundOnFilesystemWithExtensionTackedOn) {\n                try {\n                    bundle = ResourceBundle.getBundle(type);\n                    dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]\" + File.separator + type + \".properties\";\n                } catch (Exception notInJarWithoutPath) {\n                    try {\n                        String path = TableOrderer.class.getPackage().getName() + \".dbTypes.\" + type;\n                        path = path.replace('.', '/');\n                        bundle = ResourceBundle.getBundle(path);\n                        dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]/\" + path + \".properties\";\n                    } catch (Exception notInJar) {\n                        notInJar.printStackTrace();\n                        notFoundOnFilesystemWithExtensionTackedOn.printStackTrace();\n                        throw notFoundOnFilesystemWithoutExtension;\n                    }\n                }\n            }\n        }\n        Properties props = asProperties(bundle);\n        bundle = null;\n        // keep original thru recursion\n        String saveLoadedFrom = dbPropertiesLoadedFrom;\n        // bring in key/values pointed to by the include directive\n        // example: include.1=mysql::selectRowCountSql\n        for (int i = 1; true; ++i) {\n            String include = (String) props.remove(\"include.\" + i);\n            if (include == null)\n                break;\n            int separator = include.indexOf(\"::\");\n            if (separator == -1)\n                throw new InvalidConfigurationException(\"include directive in \" + dbPropertiesLoadedFrom + \" must have '::' between dbType and key\");\n            String refdType = include.substring(0, separator).trim();\n            String refdKey = include.substring(separator + 2).trim();\n            // recursively resolve the ref'd properties file and the ref'd key\n            Properties refdProps = determineDbProperties(refdType);\n            props.put(refdKey, refdProps.getProperty(refdKey));\n        }\n        // bring in base properties files pointed to by the extends directive\n        String baseDbType = (String) props.remove(\"extends\");\n        if (baseDbType != null) {\n            baseDbType = baseDbType.trim();\n            Properties baseProps = determineDbProperties(baseDbType);\n            // overlay our properties on top of the base's\n            baseProps.putAll(props);\n            props = baseProps;\n        }\n        // done with this level of recursion...restore original\n        dbPropertiesLoadedFrom = saveLoadedFrom;\n        // this won't be correct until the final recursion exits\n        dbProperties = props;\n        return props;\n    }\n\n    protected String getDbPropertiesLoadedFrom() throws IOException {\n        if (dbPropertiesLoadedFrom == null)\n            determineDbProperties(getDbType());\n        return dbPropertiesLoadedFrom;\n    }\n\n    public List<String> getRemainingParameters() {\n        try {\n            populate();\n        } catch (IllegalArgumentException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (IllegalAccessException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (InvocationTargetException exc) {\n            if (exc.getCause() instanceof InvalidConfigurationException)\n                throw (InvalidConfigurationException) exc.getCause();\n            throw new InvalidConfigurationException(exc.getCause());\n        } catch (IntrospectionException exc) {\n            throw new InvalidConfigurationException(exc);\n        }\n        return options;\n    }\n\n    /**\n     * Options that are specific to a type of database.  E.g. things like <code>host</code>,\n     * <code>port</code> or <code>db</code>, but <b>don't</b> have a setter in this class.\n     *\n     * @param dbSpecificOptions\n     */\n    public void setDbSpecificOptions(Map<String, String> dbSpecificOptions) {\n        this.dbSpecificOptions = dbSpecificOptions;\n        originalDbSpecificOptions = new HashMap<String, String>(dbSpecificOptions);\n    }\n\n    public Map<String, String> getDbSpecificOptions() {\n        if (dbSpecificOptions == null)\n            dbSpecificOptions = new HashMap<String, String>();\n        return dbSpecificOptions;\n    }\n\n    /**\n     * Returns a {@link Properties} populated with the contents of <code>bundle</code>\n     *\n     * @param bundle ResourceBundle\n     * @return Properties\n     */\n    public static Properties asProperties(ResourceBundle bundle) {\n        Properties props = new Properties();\n        Enumeration<String> iter = bundle.getKeys();\n        while (iter.hasMoreElements()) {\n            String key = iter.nextElement();\n            props.put(key, bundle.getObject(key));\n        }\n        return props;\n    }\n\n    /**\n     * 'Pull' the specified parameter from the collection of options. Returns\n     * null if the parameter isn't in the list and removes it if it is.\n     *\n     * @param paramId\n     * @return\n     */\n    private String pullParam(String paramId) {\n        return pullParam(paramId, false, false);\n    }\n\n    private String pullRequiredParam(String paramId) {\n        return pullParam(paramId, true, false);\n    }\n\n    /**\n     * @param paramId\n     * @param required\n     * @param dbTypeSpecific\n     * @return\n     * @throws MissingRequiredParameterException\n     */\n    private String pullParam(String paramId, boolean required, boolean dbTypeSpecific) throws MissingRequiredParameterException {\n        int paramIndex = options.indexOf(paramId);\n        if (paramIndex < 0) {\n            if (required)\n                throw new MissingRequiredParameterException(paramId, dbTypeSpecific);\n            return null;\n        }\n        options.remove(paramIndex);\n        String param = options.get(paramIndex).toString();\n        options.remove(paramIndex);\n        return param;\n    }\n\n    /**\n     * Thrown to indicate that a required parameter is missing\n     */\n    public static class MissingRequiredParameterException extends RuntimeException {\n\n        private static final long serialVersionUID = 1L;\n\n        private final boolean dbTypeSpecific;\n\n        public MissingRequiredParameterException(String paramId, boolean dbTypeSpecific) {\n            this(paramId, null, dbTypeSpecific);\n        }\n\n        public MissingRequiredParameterException(String paramId, String description, boolean dbTypeSpecific) {\n            super(\"Required parameter '\" + paramId + \"' \" + (description == null ? \"\" : \"(\" + description + \") \") + \"was not specified.\" + (dbTypeSpecific ? \"  It is required for this database type.\" : \"\"));\n            this.dbTypeSpecific = dbTypeSpecific;\n        }\n\n        public boolean isDbTypeSpecific() {\n            return dbTypeSpecific;\n        }\n    }\n\n    /**\n     * Allow an equal sign in args...like \"-o=foo.bar\". Useful for things like\n     * Ant and Maven.\n     *\n     * @param args\n     *            List\n     * @return List\n     */\n    protected List<String> fixupArgs(List<String> args) {\n        List<String> expandedArgs = new ArrayList<String>();\n        for (String arg : args) {\n            int indexOfEquals = arg.indexOf('=');\n            if (indexOfEquals != -1 && indexOfEquals - 1 != arg.indexOf(ESCAPED_EQUALS)) {\n                expandedArgs.add(arg.substring(0, indexOfEquals));\n                expandedArgs.add(arg.substring(indexOfEquals + 1));\n            } else {\n                expandedArgs.add(arg);\n            }\n        }\n        // some OSes/JVMs do filename expansion with runtime.exec() and some don't,\n        // so MultipleSchemaAnalyzer has to surround params with double quotes...\n        // strip them here for the OSes/JVMs that don't do anything with the params\n        List<String> unquotedArgs = new ArrayList<String>();\n        for (String arg : expandedArgs) {\n            if (// \".*\" becomes .*\n            arg.startsWith(\"\\\"\") && arg.endsWith(\"\\\"\"))\n                arg = arg.substring(1, arg.length() - 1);\n            unquotedArgs.add(arg);\n        }\n        return unquotedArgs;\n    }\n\n    /**\n     * Call all the getters to populate all the lazy initialized stuff.\n     *\n     * @throws InvocationTargetException\n     * @throws IllegalAccessException\n     * @throws IllegalArgumentException\n     * @throws IntrospectionException\n     */\n    private void populate() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IntrospectionException {\n        if (!populating) {\n            // prevent recursion\n            populating = true;\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                Method readMethod = props[i].getReadMethod();\n                if (readMethod != null)\n                    readMethod.invoke(this, (Object[]) null);\n            }\n            populating = false;\n        }\n    }\n\n    public static Set<String> getBuiltInDatabaseTypes(String loadedFromJar) {\n        Set<String> databaseTypes = new TreeSet<String>();\n        JarInputStream jar = null;\n        try {\n            jar = new JarInputStream(new FileInputStream(loadedFromJar));\n            JarEntry entry;\n            while ((entry = jar.getNextJarEntry()) != null) {\n                String entryName = entry.getName();\n                int dotPropsIndex = entryName.indexOf(\".properties\");\n                if (dotPropsIndex != -1)\n                    databaseTypes.add(entryName.substring(0, dotPropsIndex));\n            }\n        } catch (IOException exc) {\n        } finally {\n            if (jar != null) {\n                try {\n                    jar.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n        return databaseTypes;\n    }\n\n    protected void dumpUsage(String errorMessage, boolean detailedDb) {\n        if (errorMessage != null) {\n            System.out.flush();\n            System.err.println(\"*** \" + errorMessage + \" ***\");\n        } else {\n            System.out.println(\"SchemaSpy generates an HTML representation of a database schema's relationships.\");\n        }\n        System.err.flush();\n        System.out.println();\n        if (!detailedDb) {\n            System.out.println(\"Usage:\");\n            System.out.println(\" java -jar \" + getLoadedFromJar() + \" [options]\");\n            System.out.println(\"   -t databaseType       type of database - defaults to ora\");\n            System.out.println(\"                           use -dbhelp for a list of built-in types\");\n            System.out.println(\"   -u user               connect to the database with this user id\");\n            System.out.println(\"   -s schema             defaults to the specified user\");\n            System.out.println(\"   -p password           defaults to no password\");\n            System.out.println(\"   -o outputDirectory    directory to place the generated output in\");\n            System.out.println(\"   -dp pathToDrivers     optional - looks for JDBC drivers here before looking\");\n            System.out.println(\"                           in driverPath in [databaseType].properties.\");\n            System.out.println(\"Go to http://schemaspy.sourceforge.net for a complete list/description\");\n            System.out.println(\" of additional parameters.\");\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"Built-in database types and their required connection parameters:\");\n            for (String type : getBuiltInDatabaseTypes(getLoadedFromJar())) {\n                new DbSpecificConfig(type).dumpUsage();\n            }\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"You can use your own database types by specifying the filespec of a .properties file with -t.\");\n            System.out.println(\"Grab one out of \" + getLoadedFromJar() + \" and modify it to suit your needs.\");\n            System.out.println();\n        }\n        System.out.println(\"Sample usage using the default database type (implied -t ora):\");\n        System.out.println(\" java -jar schemaSpy.jar -db mydb -s myschema -u devuser -p password -o output\");\n        System.out.println();\n        System.out.flush();\n    }\n\n    /**\n     * Get the value of the specified parameter.\n     * Used for properties that are common to most db's, but aren't required.\n     *\n     * @param paramName\n     * @return\n     */\n    public String getParam(String paramName) {\n        try {\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                PropertyDescriptor prop = props[i];\n                if (prop.getName().equalsIgnoreCase(paramName)) {\n                    Object result = prop.getReadMethod().invoke(this, (Object[]) null);\n                    return result == null ? null : result.toString();\n                }\n            }\n        } catch (Exception failed) {\n            failed.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * Return all of the configuration options as a List of Strings, with\n     * each parameter and its value as a separate element.\n     *\n     * @return\n     * @throws IOException\n     */\n    public List<String> asList() throws IOException {\n        List<String> params = new ArrayList<String>();\n        if (originalDbSpecificOptions != null) {\n            for (String key : originalDbSpecificOptions.keySet()) {\n                String value = originalDbSpecificOptions.get(key);\n                if (!key.startsWith(\"-\"))\n                    key = \"-\" + key;\n                params.add(key);\n                params.add(value);\n            }\n        }\n        if (isEncodeCommentsEnabled())\n            params.add(\"-ahic\");\n        if (isEvaluateAllEnabled())\n            params.add(\"-all\");\n        if (!isHtmlGenerationEnabled())\n            params.add(\"-nohtml\");\n        if (!isImpliedConstraintsEnabled())\n            params.add(\"-noimplied\");\n        if (!isLogoEnabled())\n            params.add(\"-nologo\");\n        if (isMeterEnabled())\n            params.add(\"-meter\");\n        if (!isNumRowsEnabled())\n            params.add(\"-norows\");\n        if (!isViewsEnabled())\n            params.add(\"-noviews\");\n        if (isRankDirBugEnabled())\n            params.add(\"-rankdirbug\");\n        if (isRailsEnabled())\n            params.add(\"-rails\");\n        if (isSingleSignOn())\n            params.add(\"-sso\");\n        if (isSchemaDisabled())\n            params.add(\"-noschema\");\n        String value = getDriverPath();\n        if (value != null) {\n            params.add(\"-dp\");\n            params.add(value);\n        }\n        params.add(\"-css\");\n        params.add(getCss());\n        params.add(\"-charset\");\n        params.add(getCharset());\n        params.add(\"-font\");\n        params.add(getFont());\n        params.add(\"-fontsize\");\n        params.add(String.valueOf(getFontSize()));\n        params.add(\"-t\");\n        params.add(getDbType());\n        // query to set renderer correctly\n        isHighQuality();\n        // query to set renderer correctly\n        isLowQuality();\n        // instead of -hq and/or -lq\n        params.add(\"-renderer\");\n        params.add(getRenderer());\n        value = getDescription();\n        if (value != null) {\n            params.add(\"-desc\");\n            params.add(value);\n        }\n        value = getPassword();\n        if (value != null && !isPromptForPasswordEnabled()) {\n            // note that we don't pass -pfp since child processes\n            // won't have a console\n            params.add(\"-p\");\n            params.add(value);\n        }\n        value = getCatalog();\n        if (value != null) {\n            params.add(\"-cat\");\n            params.add(value);\n        }\n        value = getSchema();\n        if (value != null) {\n            params.add(\"-s\");\n            params.add(value);\n        }\n        value = getUser();\n        if (value != null) {\n            params.add(\"-u\");\n            params.add(value);\n        }\n        value = getConnectionPropertiesFile();\n        if (value != null) {\n            params.add(\"-connprops\");\n            params.add(value);\n        } else {\n            Properties props = getConnectionProperties();\n            if (!props.isEmpty()) {\n                params.add(\"-connprops\");\n                StringBuilder buf = new StringBuilder();\n                for (Entry<Object, Object> entry : props.entrySet()) {\n                    buf.append(entry.getKey());\n                    buf.append(ESCAPED_EQUALS);\n                    buf.append(entry.getValue());\n                    buf.append(';');\n                }\n                params.add(buf.toString());\n            }\n        }\n        value = getDb();\n        if (value != null) {\n            params.add(\"-db\");\n            params.add(value);\n        }\n        value = getHost();\n        if (value != null) {\n            params.add(\"-host\");\n            params.add(value);\n        }\n        if (getPort() != null) {\n            params.add(\"-port\");\n            params.add(getPort().toString());\n        }\n        value = getServer();\n        if (value != null) {\n            params.add(\"-server\");\n            params.add(value);\n        }\n        value = getMeta();\n        if (value != null) {\n            params.add(\"-meta\");\n            params.add(value);\n        }\n        if (getGraphvizDir() != null) {\n            params.add(\"-gv\");\n            params.add(getGraphvizDir().toString());\n        }\n        params.add(\"-loglevel\");\n        params.add(getLogLevel().toString().toLowerCase());\n        params.add(\"-sqlFormatter\");\n        params.add(getSqlFormatter().getClass().getName());\n        params.add(\"-i\");\n        params.add(getTableInclusions().toString());\n        params.add(\"-I\");\n        params.add(getTableExclusions().toString());\n        params.add(\"-X\");\n        params.add(getColumnExclusions().toString());\n        params.add(\"-x\");\n        params.add(getIndirectColumnExclusions().toString());\n        params.add(\"-dbthreads\");\n        params.add(String.valueOf(getMaxDbThreads()));\n        params.add(\"-maxdet\");\n        params.add(String.valueOf(getMaxDetailedTables()));\n        params.add(\"-o\");\n        params.add(getOutputDir().toString());\n        return params;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/ConfigTest7.java",
		"test_prompt": "// ConfigTest7.java\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Config}.\n* It contains ten unit test cases for the {@link Config#isRankDirBugEnabled()} method.\n*/\nclass ConfigTest7 {"
	},
	{
		"original_code": "// Config.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\n\n/**\n * Configuration of a SchemaSpy run\n *\n * @author John Currier\n */\npublic class Config {\n\n    private static Config instance;\n\n    private final List<String> options;\n\n    private Map<String, String> dbSpecificOptions;\n\n    private Map<String, String> originalDbSpecificOptions;\n\n    private boolean helpRequired;\n\n    private boolean dbHelpRequired;\n\n    private File outputDir;\n\n    private File graphvizDir;\n\n    private String dbType;\n\n    private String catalog;\n\n    private String schema;\n\n    private List<String> schemas;\n\n    private String user;\n\n    private Boolean singleSignOn;\n\n    private Boolean noSchema;\n\n    private String password;\n\n    private Boolean promptForPassword;\n\n    private String db;\n\n    private String host;\n\n    private Integer port;\n\n    private String server;\n\n    private String meta;\n\n    private Pattern tableInclusions;\n\n    private Pattern tableExclusions;\n\n    private Pattern columnExclusions;\n\n    private Pattern indirectColumnExclusions;\n\n    private String userConnectionPropertiesFile;\n\n    private Properties userConnectionProperties;\n\n    private Integer maxDbThreads;\n\n    private Integer maxDetailedTables;\n\n    private String driverPath;\n\n    private String css;\n\n    private String charset;\n\n    private String font;\n\n    private Integer fontSize;\n\n    private String description;\n\n    private Properties dbProperties;\n\n    private String dbPropertiesLoadedFrom;\n\n    private Level logLevel;\n\n    private SqlFormatter sqlFormatter;\n\n    private String sqlFormatterClass;\n\n    private Boolean generateHtml;\n\n    private Boolean includeImpliedConstraints;\n\n    private Boolean logoEnabled;\n\n    private Boolean rankDirBugEnabled;\n\n    private Boolean encodeCommentsEnabled;\n\n    private Boolean numRowsEnabled;\n\n    private Boolean viewsEnabled;\n\n    private Boolean meterEnabled;\n\n    private Boolean railsEnabled;\n\n    private Boolean evaluteAll;\n\n    private Boolean highQuality;\n\n    private Boolean lowQuality;\n\n    // used in conjunction with evaluateAll\n    private String schemaSpec;\n\n    private boolean hasOrphans = false;\n\n    private boolean hasRoutines = false;\n\n    private boolean populating = false;\n\n    private List<String> columnDetails;\n\n    public static final String DOT_CHARSET = \"UTF-8\";\n\n    private static final String ESCAPED_EQUALS = \"\\\\=\";\n\n    // match everything\n    private static final String DEFAULT_TABLE_INCLUSION = \".*\";\n\n    // match nothing\n    private static final String DEFAULT_TABLE_EXCLUSION = \"\";\n\n    // match nothing\n    private static final String DEFAULT_COLUMN_EXCLUSION = \"[^.]\";\n\n    /**\n     * Default constructor. Intended for when you want to inject properties\n     * independently (i.e. not from a command line interface).\n     */\n    public Config() {\n        if (instance == null)\n            setInstance(this);\n        options = new ArrayList<String>();\n    }\n\n    /**\n     * Construct a configuration from an array of options (e.g. from a command\n     * line interface).\n     *\n     * @param options\n     */\n    public Config(String[] argv) {\n        setInstance(this);\n        options = fixupArgs(Arrays.asList(argv));\n        helpRequired = options.remove(\"-?\") || options.remove(\"/?\") || options.remove(\"?\") || options.remove(\"-h\") || options.remove(\"-help\") || options.remove(\"--help\");\n        dbHelpRequired = options.remove(\"-dbHelp\") || options.remove(\"-dbhelp\");\n    }\n\n    public static Config getInstance() {\n        if (instance == null)\n            instance = new Config();\n        return instance;\n    }\n\n    /**\n     * Sets the global instance.\n     *\n     * Useful for things like selecting a specific configuration in a UI.\n     *\n     * @param config\n     */\n    public static void setInstance(Config config) {\n        instance = config;\n    }\n\n    public void setHtmlGenerationEnabled(boolean generateHtml) {\n        this.generateHtml = generateHtml;\n    }\n\n    public boolean isHtmlGenerationEnabled() {\n        if (generateHtml == null)\n            generateHtml = !options.remove(\"-nohtml\");\n        return generateHtml;\n    }\n\n    public void setImpliedConstraintsEnabled(boolean includeImpliedConstraints) {\n        this.includeImpliedConstraints = includeImpliedConstraints;\n    }\n\n    public boolean isImpliedConstraintsEnabled() {\n        if (includeImpliedConstraints == null)\n            includeImpliedConstraints = !options.remove(\"-noimplied\");\n        return includeImpliedConstraints;\n    }\n\n    public void setOutputDir(String outputDirName) {\n        if (outputDirName.endsWith(\"\\\"\"))\n            outputDirName = outputDirName.substring(0, outputDirName.length() - 1);\n        setOutputDir(new File(outputDirName));\n    }\n\n    public void setOutputDir(File outputDir) {\n        this.outputDir = outputDir;\n    }\n\n    public File getOutputDir() {\n        if (outputDir == null) {\n            setOutputDir(pullRequiredParam(\"-o\"));\n        }\n        return outputDir;\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(String graphvizDir) {\n        if (graphvizDir.endsWith(\"\\\"\"))\n            graphvizDir = graphvizDir.substring(0, graphvizDir.length() - 1);\n        setGraphvizDir(new File(graphvizDir));\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(File graphvizDir) {\n        this.graphvizDir = graphvizDir;\n    }\n\n    /**\n     * Return the path to Graphviz (used to find the dot executable to run to\n     * generate ER diagrams).<p/>\n     *\n     * Returns {@link #getDefaultGraphvizPath()} if a specific Graphviz path\n     * was not specified.\n     *\n     * @return\n     */\n    public File getGraphvizDir() {\n        if (graphvizDir == null) {\n            String gv = pullParam(\"-gv\");\n            if (gv != null) {\n                setGraphvizDir(gv);\n            } else {\n                // expect to find Graphviz's bin directory on the PATH\n            }\n        }\n        return graphvizDir;\n    }\n\n    /**\n     * Meta files are XML-based files that provide additional metadata\n     * about the schema being evaluated.<p>\n     * <code>meta</code> is either the name of an individual XML file or\n     * the directory that contains meta files.<p>\n     * If a directory is specified then it is expected to contain files\n     * matching the pattern <code>[schema].meta.xml</code>.\n     * For databases that don't have schema substitute database for schema.\n     * @param meta\n     */\n    public void setMeta(String meta) {\n        this.meta = meta;\n    }\n\n    public String getMeta() {\n        if (meta == null)\n            meta = pullParam(\"-meta\");\n        return meta;\n    }\n\n    public void setDbType(String dbType) {\n        this.dbType = dbType;\n    }\n\n    public String getDbType() {\n        if (dbType == null) {\n            dbType = pullParam(\"-t\");\n            if (dbType == null)\n                dbType = \"ora\";\n        }\n        return dbType;\n    }\n\n    public void setDb(String db) {\n        this.db = db;\n    }\n\n    public String getDb() {\n        if (db == null)\n            db = pullParam(\"-db\");\n        return db;\n    }\n\n    public void setCatalog(String catalog) {\n        this.catalog = catalog;\n    }\n\n    public String getCatalog() {\n        if (catalog == null)\n            catalog = pullParam(\"-cat\");\n        return catalog;\n    }\n\n    public void setSchema(String schema) {\n        this.schema = schema;\n    }\n\n    public String getSchema() {\n        if (schema == null)\n            schema = pullParam(\"-s\");\n        return schema;\n    }\n\n    /**\n     * Some databases types (e.g. older versions of Informix) don't really\n     * have the concept of a schema but still return true from\n     * {@link DatabaseMetaData#supportsSchemasInTableDefinitions()}.\n     * This option lets you ignore that and treat all the tables\n     * as if they were in one flat namespace.\n     */\n    public boolean isSchemaDisabled() {\n        if (noSchema == null)\n            noSchema = options.remove(\"-noschema\");\n        return noSchema;\n    }\n\n    public void setHost(String host) {\n        this.host = host;\n    }\n\n    public String getHost() {\n        if (host == null)\n            host = pullParam(\"-host\");\n        return host;\n    }\n\n    public void setPort(Integer port) {\n        this.port = port;\n    }\n\n    public Integer getPort() {\n        if (port == null)\n            try {\n                port = Integer.valueOf(pullParam(\"-port\"));\n            } catch (Exception notSpecified) {\n            }\n        return port;\n    }\n\n    public void setServer(String server) {\n        this.server = server;\n    }\n\n    public String getServer() {\n        if (server == null) {\n            server = pullParam(\"-server\");\n        }\n        return server;\n    }\n\n    public void setUser(String user) {\n        this.user = user;\n    }\n\n    /**\n     * User used to connect to the database.\n     * Required unless single sign-on is enabled\n     * (see {@link #setSingleSignOn(boolean)}).\n     * @return\n     */\n    public String getUser() {\n        if (user == null) {\n            if (!isSingleSignOn())\n                user = pullRequiredParam(\"-u\");\n            else\n                user = pullParam(\"-u\");\n        }\n        return user;\n    }\n\n    /**\n     * By default a \"user\" (as specified with -u) is required.\n     * This option allows disabling of that requirement for\n     * single sign-on environments.\n     *\n     * @param enabled defaults to <code>false</code>\n     */\n    public void setSingleSignOn(boolean enabled) {\n        singleSignOn = enabled;\n    }\n\n    /**\n     * @see #setSingleSignOn(boolean)\n     */\n    public boolean isSingleSignOn() {\n        if (singleSignOn == null)\n            singleSignOn = options.remove(\"-sso\");\n        return singleSignOn;\n    }\n\n    /**\n     * Set the password used to connect to the database.\n     * @param password\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * @see #setPassword(String)\n     * @return\n     */\n    public String getPassword() {\n        if (password == null)\n            password = pullParam(\"-p\");\n        if (password == null && isPromptForPasswordEnabled())\n            password = new String(PasswordReader.getInstance().readPassword(\"Password: \"));\n        if (password == null) {\n            // if -pfp is enabled when analyzing multiple schemas then\n            // we don't want to send the password on the command line,\n            // so see if it was passed in the environment (not ideal, but safer)\n            password = System.getenv(\"schemaspy.pw\");\n        }\n        return password;\n    }\n\n    /**\n     * Set to <code>true</code> to prompt for the password\n     * @param promptForPassword\n     */\n    public void setPromptForPasswordEnabled(boolean promptForPassword) {\n        this.promptForPassword = promptForPassword;\n    }\n\n    /**\n     * @see #setPromptForPasswordEnabled(boolean)\n     * @return\n     */\n    public boolean isPromptForPasswordEnabled() {\n        if (promptForPassword == null) {\n            promptForPassword = options.remove(\"-pfp\");\n        }\n        return promptForPassword;\n    }\n\n    public void setMaxDetailedTabled(int maxDetailedTables) {\n        this.maxDetailedTables = new Integer(maxDetailedTables);\n    }\n\n    public int getMaxDetailedTables() {\n        if (maxDetailedTables == null) {\n            // default\n            int max = 300;\n            try {\n                max = Integer.parseInt(pullParam(\"-maxdet\"));\n            } catch (Exception notSpecified) {\n            }\n            maxDetailedTables = new Integer(max);\n        }\n        return maxDetailedTables.intValue();\n    }\n\n    public String getConnectionPropertiesFile() {\n        return userConnectionPropertiesFile;\n    }\n\n    /**\n     * Properties from this file (in key=value pair format) are passed to the\n     * database connection.<br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.\n     * @param propertiesFilename\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public void setConnectionPropertiesFile(String propertiesFilename) throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null)\n            userConnectionProperties = new Properties();\n        userConnectionProperties.load(new FileInputStream(propertiesFilename));\n        userConnectionPropertiesFile = propertiesFilename;\n    }\n\n    /**\n     * Returns a {@link Properties} populated either from the properties file specified\n     * by {@link #setConnectionPropertiesFile(String)}, the properties specified by\n     * {@link #setConnectionProperties(String)} or not populated.\n     * @return\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public Properties getConnectionProperties() throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null) {\n            String props = pullParam(\"-connprops\");\n            if (props != null) {\n                if (props.indexOf(ESCAPED_EQUALS) != -1) {\n                    setConnectionProperties(props);\n                } else {\n                    setConnectionPropertiesFile(props);\n                }\n            } else {\n                userConnectionProperties = new Properties();\n            }\n        }\n        return userConnectionProperties;\n    }\n\n    /**\n     * Specifies connection properties to use in the format:\n     * <code>key1\\=value1;key2\\=value2</code><br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.<p>\n     * This is an alternative form of passing connection properties than by file\n     * (see {@link #setConnectionPropertiesFile(String)})\n     *\n     * @param properties\n     */\n    public void setConnectionProperties(String properties) {\n        userConnectionProperties = new Properties();\n        StringTokenizer tokenizer = new StringTokenizer(properties, \";\");\n        while (tokenizer.hasMoreElements()) {\n            String pair = tokenizer.nextToken();\n            int index = pair.indexOf(ESCAPED_EQUALS);\n            if (index != -1) {\n                String key = pair.substring(0, index);\n                String value = pair.substring(index + ESCAPED_EQUALS.length());\n                userConnectionProperties.put(key, value);\n            }\n        }\n    }\n\n    public void setDriverPath(String driverPath) {\n        this.driverPath = driverPath;\n    }\n\n    public String getDriverPath() {\n        if (driverPath == null)\n            driverPath = pullParam(\"-dp\");\n        // was previously -cp:\n        if (driverPath == null)\n            driverPath = pullParam(\"-cp\");\n        return driverPath;\n    }\n\n    /**\n     * The filename of the cascading style sheet to use.\n     * Note that this file is parsed and used to determine characteristics\n     * of the generated diagrams, so it must contain specific settings that\n     * are documented within schemaSpy.css.<p>\n     *\n     * Defaults to <code>\"schemaSpy.css\"</code>.\n     *\n     * @param css\n     */\n    public void setCss(String css) {\n        this.css = css;\n    }\n\n    public String getCss() {\n        if (css == null) {\n            css = pullParam(\"-css\");\n            if (css == null)\n                css = \"schemaSpy.css\";\n        }\n        return css;\n    }\n\n    /**\n     * The font to use within diagrams.  Modify the .css to specify HTML fonts.\n     *\n     * @param font\n     */\n    public void setFont(String font) {\n        this.font = font;\n    }\n\n    /**\n     * @see #setFont(String)\n     */\n    public String getFont() {\n        if (font == null) {\n            font = pullParam(\"-font\");\n            if (font == null)\n                font = \"Helvetica\";\n        }\n        return font;\n    }\n\n    /**\n     * The font size to use within diagrams.  This is the size of the font used for\n     * 'large' (e.g. not 'compact') diagrams.<p>\n     *\n     * Modify the .css to specify HTML font sizes.<p>\n     *\n     * Defaults to 11.\n     *\n     * @param fontSize\n     */\n    public void setFontSize(int fontSize) {\n        this.fontSize = new Integer(fontSize);\n    }\n\n    /**\n     * @see #setFontSize(int)\n     * @return\n     */\n    public int getFontSize() {\n        if (fontSize == null) {\n            // default\n            int size = 11;\n            try {\n                size = Integer.parseInt(pullParam(\"-fontsize\"));\n            } catch (Exception notSpecified) {\n            }\n            fontSize = new Integer(size);\n        }\n        return fontSize.intValue();\n    }\n\n    /**\n     * The character set to use within HTML pages (defaults to <code>\"ISO-8859-1\"</code>).\n     *\n     * @param charset\n     */\n    public void setCharset(String charset) {\n        this.charset = charset;\n    }\n\n    /**\n     * @see #setCharset(String)\n     */\n    public String getCharset() {\n        if (charset == null) {\n            charset = pullParam(\"-charset\");\n            if (charset == null)\n                charset = \"ISO-8859-1\";\n        }\n        return charset;\n    }\n\n    /**\n     * Description of schema that gets display on main pages.\n     *\n     * @param description\n     */\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    /**\n     * @see #setDescription(String)\n     */\n    public String getDescription() {\n        if (description == null)\n            description = pullParam(\"-desc\");\n        return description;\n    }\n\n    /**\n     * Maximum number of threads to use when querying database metadata information.\n     *\n     * @param maxDbThreads\n     */\n    public void setMaxDbThreads(int maxDbThreads) {\n        this.maxDbThreads = new Integer(maxDbThreads);\n    }\n\n    /**\n     * @see #setMaxDbThreads(int)\n     * @throws InvalidConfigurationException if unable to load properties\n     */\n    public int getMaxDbThreads() throws InvalidConfigurationException {\n        if (maxDbThreads == null) {\n            Properties properties;\n            try {\n                properties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(\"Failed to load properties for \" + getDbType() + \": \" + exc).setParamName(\"-type\");\n            }\n            // not scientifically derived\n            final int defaultMax = 15;\n            int max = defaultMax;\n            String threads = properties.getProperty(\"dbThreads\");\n            if (threads == null)\n                threads = properties.getProperty(\"dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            threads = pullParam(\"-dbThreads\");\n            if (threads == null)\n                threads = pullParam(\"-dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            if (max < 0)\n                max = defaultMax;\n            else if (max == 0)\n                max = 1;\n            maxDbThreads = new Integer(max);\n        }\n        return maxDbThreads.intValue();\n    }\n\n    public boolean isLogoEnabled() {\n        if (logoEnabled == null)\n            logoEnabled = !options.remove(\"-nologo\");\n        return logoEnabled;\n    }\n\n    /**\n     * Don't use this unless absolutely necessary as it screws up the layout\n     *\n     * @param enabled\n     */\n    public void setRankDirBugEnabled(boolean enabled) {\n        rankDirBugEnabled = enabled;\n    }\n\n    /**\n     * @see #setRankDirBugEnabled(boolean)\n     */\n    public boolean isRankDirBugEnabled() {\n        if (rankDirBugEnabled == null)\n            rankDirBugEnabled = options.remove(\"-rankdirbug\");\n        return rankDirBugEnabled;\n    }\n\n    /**\n     * Look for Ruby on Rails-based naming conventions in\n     * relationships between logical foreign keys and primary keys.<p>\n     *\n     * Basically all tables have a primary key named <code>ID</code>.\n     * All tables are named plural names.\n     * The columns that logically reference that <code>ID</code> are the singular\n     * form of the table name suffixed with <code>_ID</code>.<p>\n     *\n     * @param enabled\n     */\n    public void setRailsEnabled(boolean enabled) {\n        railsEnabled = enabled;\n    }\n\n    /**\n     * @see #setRailsEnabled(boolean)\n     *\n     * @return\n     */\n    public boolean isRailsEnabled() {\n        if (railsEnabled == null)\n            railsEnabled = options.remove(\"-rails\");\n        return railsEnabled;\n    }\n\n    /**\n     * Allow Html In Comments - encode them unless otherwise specified\n     */\n    public void setEncodeCommentsEnabled(boolean enabled) {\n        encodeCommentsEnabled = enabled;\n    }\n\n    /**\n     * @see #setEncodeCommentsEnabled(boolean)\n     */\n    public boolean isEncodeCommentsEnabled() {\n        if (encodeCommentsEnabled == null)\n            encodeCommentsEnabled = !options.remove(\"-ahic\");\n        return encodeCommentsEnabled;\n    }\n\n    /**\n     * If enabled we'll attempt to query/render the number of rows that\n     * each table contains.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setNumRowsEnabled(boolean enabled) {\n        numRowsEnabled = enabled;\n    }\n\n    /**\n     * @see #setNumRowsEnabled(boolean)\n     * @return\n     */\n    public boolean isNumRowsEnabled() {\n        if (numRowsEnabled == null)\n            numRowsEnabled = !options.remove(\"-norows\");\n        return numRowsEnabled;\n    }\n\n    /**\n     * If enabled we'll include views in the analysis.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setViewsEnabled(boolean enabled) {\n        viewsEnabled = enabled;\n    }\n\n    /**\n     * @see #setViewsEnabled(boolean)\n     * @return\n     */\n    public boolean isViewsEnabled() {\n        if (viewsEnabled == null)\n            viewsEnabled = !options.remove(\"-noviews\");\n        return viewsEnabled;\n    }\n\n    /**\n     * Returns <code>true</code> if metering should be embedded in\n     * the generated pages.<p/>\n     * Defaults to <code>false</code> (disabled).\n     * @return\n     */\n    public boolean isMeterEnabled() {\n        if (meterEnabled == null)\n            meterEnabled = options.remove(\"-meter\");\n        return meterEnabled;\n    }\n\n    /**\n     * Set the columns to exclude from all relationship diagrams.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setColumnExclusions(String columnExclusions) {\n        this.columnExclusions = Pattern.compile(columnExclusions);\n    }\n\n    /**\n     * See {@link #setColumnExclusions(String)}\n     * @return\n     */\n    public Pattern getColumnExclusions() {\n        if (columnExclusions == null) {\n            String strExclusions = pullParam(\"-X\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.columnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            columnExclusions = Pattern.compile(strExclusions);\n        }\n        return columnExclusions;\n    }\n\n    /**\n     * Set the columns to exclude from relationship diagrams where the specified\n     * columns aren't directly referenced by the focal table.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setIndirectColumnExclusions(String fullColumnExclusions) {\n        indirectColumnExclusions = Pattern.compile(fullColumnExclusions);\n    }\n\n    /**\n     * @see #setIndirectColumnExclusions(String)\n     *\n     * @return\n     */\n    public Pattern getIndirectColumnExclusions() {\n        if (indirectColumnExclusions == null) {\n            String strExclusions = pullParam(\"-x\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.indirectColumnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            indirectColumnExclusions = Pattern.compile(strExclusions);\n        }\n        return indirectColumnExclusions;\n    }\n\n    /**\n     * Set the tables to include as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableInclusions(String tableInclusions) {\n        this.tableInclusions = Pattern.compile(tableInclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to include in the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableInclusions() {\n        if (tableInclusions == null) {\n            String strInclusions = pullParam(\"-i\");\n            if (strInclusions == null)\n                strInclusions = System.getenv(\"schemaspy.tableInclusions\");\n            if (strInclusions == null)\n                strInclusions = DEFAULT_TABLE_INCLUSION;\n            try {\n                tableInclusions = Pattern.compile(strInclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-i\");\n            }\n        }\n        return tableInclusions;\n    }\n\n    /**\n     * Set the tables to exclude as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableExclusions(String tableExclusions) {\n        this.tableExclusions = Pattern.compile(tableExclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to exclude from the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableExclusions() {\n        if (tableExclusions == null) {\n            String strExclusions = pullParam(\"-I\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.tableExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_TABLE_EXCLUSION;\n            try {\n                tableExclusions = Pattern.compile(strExclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-I\");\n            }\n        }\n        return tableExclusions;\n    }\n\n    /**\n     * @return\n     */\n    public List<String> getSchemas() {\n        if (schemas == null) {\n            String tmp = pullParam(\"-schemas\");\n            if (tmp == null)\n                tmp = pullParam(\"-schemata\");\n            if (tmp != null) {\n                schemas = new ArrayList<String>();\n                for (String name : tmp.split(\"[\\\\s,'\\\"]\")) {\n                    if (name.length() > 0)\n                        schemas.add(name);\n                }\n                if (schemas.isEmpty())\n                    schemas = null;\n            }\n        }\n        return schemas;\n    }\n\n    /**\n     * Set the name of the {@link SqlFormatter SQL formatter} class to use to\n     * format SQL into HTML.<p/>\n     * The implementation of the class must be made available to the class\n     * loader, typically by specifying the path to its jar with <em>-dp</em>\n     * ({@link #setDriverPath(String)}).\n     */\n    public void setSqlFormatter(String formatterClassName) {\n        sqlFormatterClass = formatterClassName;\n        sqlFormatter = null;\n    }\n\n    /**\n     * Set the {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.\n     */\n    public void setSqlFormatter(SqlFormatter sqlFormatter) {\n        this.sqlFormatter = sqlFormatter;\n        if (sqlFormatter != null)\n            sqlFormatterClass = sqlFormatter.getClass().getName();\n    }\n\n    /**\n     * Returns an implementation of {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.  The default implementation is {@link DefaultSqlFormatter}.\n     *\n     * @return\n     * @throws InvalidConfigurationException if unable to instantiate an instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SqlFormatter getSqlFormatter() throws InvalidConfigurationException {\n        if (sqlFormatter == null) {\n            if (sqlFormatterClass == null) {\n                sqlFormatterClass = pullParam(\"-sqlFormatter\");\n                if (sqlFormatterClass == null)\n                    sqlFormatterClass = DefaultSqlFormatter.class.getName();\n            }\n            try {\n                Class<SqlFormatter> clazz = (Class<SqlFormatter>) Class.forName(sqlFormatterClass);\n                sqlFormatter = clazz.newInstance();\n            } catch (Exception exc) {\n                throw new InvalidConfigurationException(\"Failed to initialize instance of SQL formatter: \", exc).setParamName(\"-sqlFormatter\");\n            }\n        }\n        return sqlFormatter;\n    }\n\n    /**\n     * Set the details to show on the columns page, where \"details\" are\n     * comma and/or space separated.\n     *\n     * Valid values:\n     * <ul>\n     * <li>id</li>\n     * <li>table</li>\n     * <li>column</li>\n     * <li>type</li>\n     * <li>size</li>\n     * <li>nulls</li>\n     * <li>auto</li>\n     * <li>default</li>\n     * <li>children</li>\n     * <li>parents</li>\n     * </ul>\n     *\n     * The default details are <code>\"table column type size nulls auto default\"</code>.\n     * Note that \"column\" is the initially displayed detail and must be included.\n     *\n     * @param columnDetails\n     */\n    public void setColumnDetails(String columnDetails) {\n        this.columnDetails = new ArrayList<String>();\n        if (columnDetails == null || columnDetails.length() == 0) {\n            // not specified, so use defaults\n            columnDetails = \"id table column type size nulls auto default\";\n        }\n        for (String detail : columnDetails.split(\"[\\\\s,'\\\"]\")) {\n            if (detail.length() > 0) {\n                this.columnDetails.add(detail.toLowerCase());\n            }\n        }\n        if (!this.columnDetails.contains(\"column\"))\n            throw new InvalidConfigurationException(\"'column' is a required column detail\");\n    }\n\n    public void setColumnDetails(List<String> columnDetails) {\n        String details = columnDetails == null ? \"[]\" : columnDetails.toString();\n        setColumnDetails(details.substring(1, details.length() - 1));\n    }\n\n    public List<String> getColumnDetails() {\n        if (columnDetails == null) {\n            setColumnDetails(pullParam(\"-columndetails\"));\n        }\n        return columnDetails;\n    }\n\n    public void setEvaluateAllEnabled(boolean enabled) {\n        evaluteAll = enabled;\n    }\n\n    public boolean isEvaluateAllEnabled() {\n        if (evaluteAll == null)\n            evaluteAll = options.remove(\"-all\");\n        return evaluteAll;\n    }\n\n    /**\n     * Returns true if we're evaluating a bunch of schemas in one go and\n     * at this point we're evaluating a specific schema.\n     *\n     * @return boolean\n     */\n    public boolean isOneOfMultipleSchemas() {\n        // set by MultipleSchemaAnalyzer\n        return Boolean.getBoolean(\"oneofmultipleschemas\");\n    }\n\n    /**\n     * When -all (evaluateAll) is specified then this is the regular\n     * expression that determines which schemas to evaluate.\n     *\n     * @param schemaSpec\n     */\n    public void setSchemaSpec(String schemaSpec) {\n        this.schemaSpec = schemaSpec;\n    }\n\n    public String getSchemaSpec() {\n        if (schemaSpec == null)\n            schemaSpec = pullParam(\"-schemaSpec\");\n        return schemaSpec;\n    }\n\n    /**\n     * Set the renderer to use for the -Tpng[:renderer[:formatter]] dot option as specified\n     * at <a href='http://www.graphviz.org/doc/info/command.html'>\n     * http://www.graphviz.org/doc/info/command.html</a>.<p>\n     * Note that the leading \":\" is required while :formatter is optional.<p>\n     * The default renderer is typically GD.<p>\n     * Note that using {@link #setHighQuality(boolean)} is the preferred approach\n     * over using this method.\n     */\n    public void setRenderer(String renderer) {\n        Dot.getInstance().setRenderer(renderer);\n    }\n\n    /**\n     * @see #setRenderer(String)\n     * @return\n     */\n    public String getRenderer() {\n        String renderer = pullParam(\"-renderer\");\n        if (renderer != null)\n            setRenderer(renderer);\n        return Dot.getInstance().getRenderer();\n    }\n\n    /**\n     * If <code>false</code> then generate output of \"lower quality\"\n     * than the default.\n     * Note that the default is intended to be \"higher quality\",\n     * but various installations of Graphviz may have have different abilities.\n     * That is, some might not have the \"lower quality\" libraries and others might\n     * not have the \"higher quality\" libraries.<p>\n     * Higher quality output takes longer to generate and results in significantly\n     * larger image files (which take longer to download / display), but it generally\n     * looks better.\n     */\n    public void setHighQuality(boolean highQuality) {\n        this.highQuality = highQuality;\n        lowQuality = !highQuality;\n        Dot.getInstance().setHighQuality(highQuality);\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isHighQuality() {\n        if (highQuality == null) {\n            highQuality = options.remove(\"-hq\");\n            if (highQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(highQuality);\n            }\n        }\n        highQuality = Dot.getInstance().isHighQuality();\n        return highQuality;\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isLowQuality() {\n        if (lowQuality == null) {\n            lowQuality = options.remove(\"-lq\");\n            if (lowQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(!lowQuality);\n            }\n        }\n        lowQuality = !Dot.getInstance().isHighQuality();\n        return lowQuality;\n    }\n\n    /**\n     * Set the level of logging to perform.<p/>\n     * The levels in descending order are:\n     * <ul>\n     *  <li><code>severe</code> (highest - least detail)\n     *  <li><code>warning</code> (default)\n     *  <li><code>info</code>\n     *  <li><code>config</code>\n     *  <li><code>fine</code>\n     *  <li><code>finer</code>\n     *  <li><code>finest</code>  (lowest - most detail)\n     * </ul>\n     *\n     * @param logLevel\n     */\n    public void setLogLevel(String logLevel) {\n        if (logLevel == null) {\n            this.logLevel = Level.WARNING;\n            return;\n        }\n        Map<String, Level> levels = new LinkedHashMap<String, Level>();\n        levels.put(\"severe\", Level.SEVERE);\n        levels.put(\"warning\", Level.WARNING);\n        levels.put(\"info\", Level.INFO);\n        levels.put(\"config\", Level.CONFIG);\n        levels.put(\"fine\", Level.FINE);\n        levels.put(\"finer\", Level.FINER);\n        levels.put(\"finest\", Level.FINEST);\n        this.logLevel = levels.get(logLevel.toLowerCase());\n        if (this.logLevel == null) {\n            throw new InvalidConfigurationException(\"Invalid logLevel: '\" + logLevel + \"'. Must be one of: \" + levels.keySet());\n        }\n    }\n\n    /**\n     * Returns the level of logging to perform.\n     * See {@link #setLogLevel(String)}.\n     *\n     * @return\n     */\n    public Level getLogLevel() {\n        if (logLevel == null) {\n            setLogLevel(pullParam(\"-loglevel\"));\n        }\n        return logLevel;\n    }\n\n    /**\n     * Returns <code>true</code> if the options indicate that the user wants\n     * to see some help information.\n     *\n     * @return\n     */\n    public boolean isHelpRequired() {\n        return helpRequired;\n    }\n\n    public boolean isDbHelpRequired() {\n        return dbHelpRequired;\n    }\n\n    /**\n     * Returns the jar that we were loaded from\n     *\n     * @return\n     */\n    public static String getLoadedFromJar() {\n        String classpath = System.getProperty(\"java.class.path\");\n        return new StringTokenizer(classpath, File.pathSeparator).nextToken();\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasOrphans(boolean hasOrphans) {\n        this.hasOrphans = hasOrphans;\n    }\n\n    /**\n     * @see #setHasOrphans()\n     *\n     * @return\n     */\n    public boolean hasOrphans() {\n        return hasOrphans;\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasRoutines(boolean hasRoutines) {\n        this.hasRoutines = hasRoutines;\n    }\n\n    /**\n     * @see #setHasRoutines()\n     *\n     * @return\n     */\n    public boolean hasRoutines() {\n        return hasRoutines;\n    }\n\n    /**\n     * Returns the database properties to use.\n     * These should be determined by calling {@link #determineDbProperties(String)}.\n     * @return\n     * @throws InvalidConfigurationException\n     */\n    public Properties getDbProperties() throws InvalidConfigurationException {\n        if (dbProperties == null) {\n            try {\n                dbProperties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(exc);\n            }\n        }\n        return dbProperties;\n    }\n\n    /**\n     * Determines the database properties associated with the specified type.\n     * A call to {@link #setDbProperties(Properties)} is expected after determining\n     * the complete set of properties.\n     *\n     * @param type\n     * @return\n     * @throws IOException\n     * @throws InvalidConfigurationException if db properties are incorrectly formed\n     */\n    public Properties determineDbProperties(String type) throws IOException, InvalidConfigurationException {\n        ResourceBundle bundle = null;\n        try {\n            File propertiesFile = new File(type);\n            bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n            dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n        } catch (FileNotFoundException notFoundOnFilesystemWithoutExtension) {\n            try {\n                File propertiesFile = new File(type + \".properties\");\n                bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n                dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n            } catch (FileNotFoundException notFoundOnFilesystemWithExtensionTackedOn) {\n                try {\n                    bundle = ResourceBundle.getBundle(type);\n                    dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]\" + File.separator + type + \".properties\";\n                } catch (Exception notInJarWithoutPath) {\n                    try {\n                        String path = TableOrderer.class.getPackage().getName() + \".dbTypes.\" + type;\n                        path = path.replace('.', '/');\n                        bundle = ResourceBundle.getBundle(path);\n                        dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]/\" + path + \".properties\";\n                    } catch (Exception notInJar) {\n                        notInJar.printStackTrace();\n                        notFoundOnFilesystemWithExtensionTackedOn.printStackTrace();\n                        throw notFoundOnFilesystemWithoutExtension;\n                    }\n                }\n            }\n        }\n        Properties props = asProperties(bundle);\n        bundle = null;\n        // keep original thru recursion\n        String saveLoadedFrom = dbPropertiesLoadedFrom;\n        // bring in key/values pointed to by the include directive\n        // example: include.1=mysql::selectRowCountSql\n        for (int i = 1; true; ++i) {\n            String include = (String) props.remove(\"include.\" + i);\n            if (include == null)\n                break;\n            int separator = include.indexOf(\"::\");\n            if (separator == -1)\n                throw new InvalidConfigurationException(\"include directive in \" + dbPropertiesLoadedFrom + \" must have '::' between dbType and key\");\n            String refdType = include.substring(0, separator).trim();\n            String refdKey = include.substring(separator + 2).trim();\n            // recursively resolve the ref'd properties file and the ref'd key\n            Properties refdProps = determineDbProperties(refdType);\n            props.put(refdKey, refdProps.getProperty(refdKey));\n        }\n        // bring in base properties files pointed to by the extends directive\n        String baseDbType = (String) props.remove(\"extends\");\n        if (baseDbType != null) {\n            baseDbType = baseDbType.trim();\n            Properties baseProps = determineDbProperties(baseDbType);\n            // overlay our properties on top of the base's\n            baseProps.putAll(props);\n            props = baseProps;\n        }\n        // done with this level of recursion...restore original\n        dbPropertiesLoadedFrom = saveLoadedFrom;\n        // this won't be correct until the final recursion exits\n        dbProperties = props;\n        return props;\n    }\n\n    protected String getDbPropertiesLoadedFrom() throws IOException {\n        if (dbPropertiesLoadedFrom == null)\n            determineDbProperties(getDbType());\n        return dbPropertiesLoadedFrom;\n    }\n\n    public List<String> getRemainingParameters() {\n        try {\n            populate();\n        } catch (IllegalArgumentException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (IllegalAccessException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (InvocationTargetException exc) {\n            if (exc.getCause() instanceof InvalidConfigurationException)\n                throw (InvalidConfigurationException) exc.getCause();\n            throw new InvalidConfigurationException(exc.getCause());\n        } catch (IntrospectionException exc) {\n            throw new InvalidConfigurationException(exc);\n        }\n        return options;\n    }\n\n    /**\n     * Options that are specific to a type of database.  E.g. things like <code>host</code>,\n     * <code>port</code> or <code>db</code>, but <b>don't</b> have a setter in this class.\n     *\n     * @param dbSpecificOptions\n     */\n    public void setDbSpecificOptions(Map<String, String> dbSpecificOptions) {\n        this.dbSpecificOptions = dbSpecificOptions;\n        originalDbSpecificOptions = new HashMap<String, String>(dbSpecificOptions);\n    }\n\n    public Map<String, String> getDbSpecificOptions() {\n        if (dbSpecificOptions == null)\n            dbSpecificOptions = new HashMap<String, String>();\n        return dbSpecificOptions;\n    }\n\n    /**\n     * Returns a {@link Properties} populated with the contents of <code>bundle</code>\n     *\n     * @param bundle ResourceBundle\n     * @return Properties\n     */\n    public static Properties asProperties(ResourceBundle bundle) {\n        Properties props = new Properties();\n        Enumeration<String> iter = bundle.getKeys();\n        while (iter.hasMoreElements()) {\n            String key = iter.nextElement();\n            props.put(key, bundle.getObject(key));\n        }\n        return props;\n    }\n\n    /**\n     * 'Pull' the specified parameter from the collection of options. Returns\n     * null if the parameter isn't in the list and removes it if it is.\n     *\n     * @param paramId\n     * @return\n     */\n    private String pullParam(String paramId) {\n        return pullParam(paramId, false, false);\n    }\n\n    private String pullRequiredParam(String paramId) {\n        return pullParam(paramId, true, false);\n    }\n\n    /**\n     * @param paramId\n     * @param required\n     * @param dbTypeSpecific\n     * @return\n     * @throws MissingRequiredParameterException\n     */\n    private String pullParam(String paramId, boolean required, boolean dbTypeSpecific) throws MissingRequiredParameterException {\n        int paramIndex = options.indexOf(paramId);\n        if (paramIndex < 0) {\n            if (required)\n                throw new MissingRequiredParameterException(paramId, dbTypeSpecific);\n            return null;\n        }\n        options.remove(paramIndex);\n        String param = options.get(paramIndex).toString();\n        options.remove(paramIndex);\n        return param;\n    }\n\n    /**\n     * Thrown to indicate that a required parameter is missing\n     */\n    public static class MissingRequiredParameterException extends RuntimeException {\n\n        private static final long serialVersionUID = 1L;\n\n        private final boolean dbTypeSpecific;\n\n        public MissingRequiredParameterException(String paramId, boolean dbTypeSpecific) {\n            this(paramId, null, dbTypeSpecific);\n        }\n\n        public MissingRequiredParameterException(String paramId, String description, boolean dbTypeSpecific) {\n            super(\"Required parameter '\" + paramId + \"' \" + (description == null ? \"\" : \"(\" + description + \") \") + \"was not specified.\" + (dbTypeSpecific ? \"  It is required for this database type.\" : \"\"));\n            this.dbTypeSpecific = dbTypeSpecific;\n        }\n\n        public boolean isDbTypeSpecific() {\n            return dbTypeSpecific;\n        }\n    }\n\n    /**\n     * Allow an equal sign in args...like \"-o=foo.bar\". Useful for things like\n     * Ant and Maven.\n     *\n     * @param args\n     *            List\n     * @return List\n     */\n    protected List<String> fixupArgs(List<String> args) {\n        List<String> expandedArgs = new ArrayList<String>();\n        for (String arg : args) {\n            int indexOfEquals = arg.indexOf('=');\n            if (indexOfEquals != -1 && indexOfEquals - 1 != arg.indexOf(ESCAPED_EQUALS)) {\n                expandedArgs.add(arg.substring(0, indexOfEquals));\n                expandedArgs.add(arg.substring(indexOfEquals + 1));\n            } else {\n                expandedArgs.add(arg);\n            }\n        }\n        // some OSes/JVMs do filename expansion with runtime.exec() and some don't,\n        // so MultipleSchemaAnalyzer has to surround params with double quotes...\n        // strip them here for the OSes/JVMs that don't do anything with the params\n        List<String> unquotedArgs = new ArrayList<String>();\n        for (String arg : expandedArgs) {\n            if (// \".*\" becomes .*\n            arg.startsWith(\"\\\"\") && arg.endsWith(\"\\\"\"))\n                arg = arg.substring(1, arg.length() - 1);\n            unquotedArgs.add(arg);\n        }\n        return unquotedArgs;\n    }\n\n    /**\n     * Call all the getters to populate all the lazy initialized stuff.\n     *\n     * @throws InvocationTargetException\n     * @throws IllegalAccessException\n     * @throws IllegalArgumentException\n     * @throws IntrospectionException\n     */\n    private void populate() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IntrospectionException {\n        if (!populating) {\n            // prevent recursion\n            populating = true;\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                Method readMethod = props[i].getReadMethod();\n                if (readMethod != null)\n                    readMethod.invoke(this, (Object[]) null);\n            }\n            populating = false;\n        }\n    }\n\n    public static Set<String> getBuiltInDatabaseTypes(String loadedFromJar) {\n        Set<String> databaseTypes = new TreeSet<String>();\n        JarInputStream jar = null;\n        try {\n            jar = new JarInputStream(new FileInputStream(loadedFromJar));\n            JarEntry entry;\n            while ((entry = jar.getNextJarEntry()) != null) {\n                String entryName = entry.getName();\n                int dotPropsIndex = entryName.indexOf(\".properties\");\n                if (dotPropsIndex != -1)\n                    databaseTypes.add(entryName.substring(0, dotPropsIndex));\n            }\n        } catch (IOException exc) {\n        } finally {\n            if (jar != null) {\n                try {\n                    jar.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n        return databaseTypes;\n    }\n\n    protected void dumpUsage(String errorMessage, boolean detailedDb) {\n        if (errorMessage != null) {\n            System.out.flush();\n            System.err.println(\"*** \" + errorMessage + \" ***\");\n        } else {\n            System.out.println(\"SchemaSpy generates an HTML representation of a database schema's relationships.\");\n        }\n        System.err.flush();\n        System.out.println();\n        if (!detailedDb) {\n            System.out.println(\"Usage:\");\n            System.out.println(\" java -jar \" + getLoadedFromJar() + \" [options]\");\n            System.out.println(\"   -t databaseType       type of database - defaults to ora\");\n            System.out.println(\"                           use -dbhelp for a list of built-in types\");\n            System.out.println(\"   -u user               connect to the database with this user id\");\n            System.out.println(\"   -s schema             defaults to the specified user\");\n            System.out.println(\"   -p password           defaults to no password\");\n            System.out.println(\"   -o outputDirectory    directory to place the generated output in\");\n            System.out.println(\"   -dp pathToDrivers     optional - looks for JDBC drivers here before looking\");\n            System.out.println(\"                           in driverPath in [databaseType].properties.\");\n            System.out.println(\"Go to http://schemaspy.sourceforge.net for a complete list/description\");\n            System.out.println(\" of additional parameters.\");\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"Built-in database types and their required connection parameters:\");\n            for (String type : getBuiltInDatabaseTypes(getLoadedFromJar())) {\n                new DbSpecificConfig(type).dumpUsage();\n            }\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"You can use your own database types by specifying the filespec of a .properties file with -t.\");\n            System.out.println(\"Grab one out of \" + getLoadedFromJar() + \" and modify it to suit your needs.\");\n            System.out.println();\n        }\n        System.out.println(\"Sample usage using the default database type (implied -t ora):\");\n        System.out.println(\" java -jar schemaSpy.jar -db mydb -s myschema -u devuser -p password -o output\");\n        System.out.println();\n        System.out.flush();\n    }\n\n    /**\n     * Get the value of the specified parameter.\n     * Used for properties that are common to most db's, but aren't required.\n     *\n     * @param paramName\n     * @return\n     */\n    public String getParam(String paramName) {\n        try {\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                PropertyDescriptor prop = props[i];\n                if (prop.getName().equalsIgnoreCase(paramName)) {\n                    Object result = prop.getReadMethod().invoke(this, (Object[]) null);\n                    return result == null ? null : result.toString();\n                }\n            }\n        } catch (Exception failed) {\n            failed.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * Return all of the configuration options as a List of Strings, with\n     * each parameter and its value as a separate element.\n     *\n     * @return\n     * @throws IOException\n     */\n    public List<String> asList() throws IOException {\n        List<String> params = new ArrayList<String>();\n        if (originalDbSpecificOptions != null) {\n            for (String key : originalDbSpecificOptions.keySet()) {\n                String value = originalDbSpecificOptions.get(key);\n                if (!key.startsWith(\"-\"))\n                    key = \"-\" + key;\n                params.add(key);\n                params.add(value);\n            }\n        }\n        if (isEncodeCommentsEnabled())\n            params.add(\"-ahic\");\n        if (isEvaluateAllEnabled())\n            params.add(\"-all\");\n        if (!isHtmlGenerationEnabled())\n            params.add(\"-nohtml\");\n        if (!isImpliedConstraintsEnabled())\n            params.add(\"-noimplied\");\n        if (!isLogoEnabled())\n            params.add(\"-nologo\");\n        if (isMeterEnabled())\n            params.add(\"-meter\");\n        if (!isNumRowsEnabled())\n            params.add(\"-norows\");\n        if (!isViewsEnabled())\n            params.add(\"-noviews\");\n        if (isRankDirBugEnabled())\n            params.add(\"-rankdirbug\");\n        if (isRailsEnabled())\n            params.add(\"-rails\");\n        if (isSingleSignOn())\n            params.add(\"-sso\");\n        if (isSchemaDisabled())\n            params.add(\"-noschema\");\n        String value = getDriverPath();\n        if (value != null) {\n            params.add(\"-dp\");\n            params.add(value);\n        }\n        params.add(\"-css\");\n        params.add(getCss());\n        params.add(\"-charset\");\n        params.add(getCharset());\n        params.add(\"-font\");\n        params.add(getFont());\n        params.add(\"-fontsize\");\n        params.add(String.valueOf(getFontSize()));\n        params.add(\"-t\");\n        params.add(getDbType());\n        // query to set renderer correctly\n        isHighQuality();\n        // query to set renderer correctly\n        isLowQuality();\n        // instead of -hq and/or -lq\n        params.add(\"-renderer\");\n        params.add(getRenderer());\n        value = getDescription();\n        if (value != null) {\n            params.add(\"-desc\");\n            params.add(value);\n        }\n        value = getPassword();\n        if (value != null && !isPromptForPasswordEnabled()) {\n            // note that we don't pass -pfp since child processes\n            // won't have a console\n            params.add(\"-p\");\n            params.add(value);\n        }\n        value = getCatalog();\n        if (value != null) {\n            params.add(\"-cat\");\n            params.add(value);\n        }\n        value = getSchema();\n        if (value != null) {\n            params.add(\"-s\");\n            params.add(value);\n        }\n        value = getUser();\n        if (value != null) {\n            params.add(\"-u\");\n            params.add(value);\n        }\n        value = getConnectionPropertiesFile();\n        if (value != null) {\n            params.add(\"-connprops\");\n            params.add(value);\n        } else {\n            Properties props = getConnectionProperties();\n            if (!props.isEmpty()) {\n                params.add(\"-connprops\");\n                StringBuilder buf = new StringBuilder();\n                for (Entry<Object, Object> entry : props.entrySet()) {\n                    buf.append(entry.getKey());\n                    buf.append(ESCAPED_EQUALS);\n                    buf.append(entry.getValue());\n                    buf.append(';');\n                }\n                params.add(buf.toString());\n            }\n        }\n        value = getDb();\n        if (value != null) {\n            params.add(\"-db\");\n            params.add(value);\n        }\n        value = getHost();\n        if (value != null) {\n            params.add(\"-host\");\n            params.add(value);\n        }\n        if (getPort() != null) {\n            params.add(\"-port\");\n            params.add(getPort().toString());\n        }\n        value = getServer();\n        if (value != null) {\n            params.add(\"-server\");\n            params.add(value);\n        }\n        value = getMeta();\n        if (value != null) {\n            params.add(\"-meta\");\n            params.add(value);\n        }\n        if (getGraphvizDir() != null) {\n            params.add(\"-gv\");\n            params.add(getGraphvizDir().toString());\n        }\n        params.add(\"-loglevel\");\n        params.add(getLogLevel().toString().toLowerCase());\n        params.add(\"-sqlFormatter\");\n        params.add(getSqlFormatter().getClass().getName());\n        params.add(\"-i\");\n        params.add(getTableInclusions().toString());\n        params.add(\"-I\");\n        params.add(getTableExclusions().toString());\n        params.add(\"-X\");\n        params.add(getColumnExclusions().toString());\n        params.add(\"-x\");\n        params.add(getIndirectColumnExclusions().toString());\n        params.add(\"-dbthreads\");\n        params.add(String.valueOf(getMaxDbThreads()));\n        params.add(\"-maxdet\");\n        params.add(String.valueOf(getMaxDetailedTables()));\n        params.add(\"-o\");\n        params.add(getOutputDir().toString());\n        return params;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/ConfigTest8.java",
		"test_prompt": "// ConfigTest8.java\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Config}.\n* It contains ten unit test cases for the {@link Config#isRailsEnabled()} method.\n*/\nclass ConfigTest8 {"
	},
	{
		"original_code": "// Config.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\n\n/**\n * Configuration of a SchemaSpy run\n *\n * @author John Currier\n */\npublic class Config {\n\n    private static Config instance;\n\n    private final List<String> options;\n\n    private Map<String, String> dbSpecificOptions;\n\n    private Map<String, String> originalDbSpecificOptions;\n\n    private boolean helpRequired;\n\n    private boolean dbHelpRequired;\n\n    private File outputDir;\n\n    private File graphvizDir;\n\n    private String dbType;\n\n    private String catalog;\n\n    private String schema;\n\n    private List<String> schemas;\n\n    private String user;\n\n    private Boolean singleSignOn;\n\n    private Boolean noSchema;\n\n    private String password;\n\n    private Boolean promptForPassword;\n\n    private String db;\n\n    private String host;\n\n    private Integer port;\n\n    private String server;\n\n    private String meta;\n\n    private Pattern tableInclusions;\n\n    private Pattern tableExclusions;\n\n    private Pattern columnExclusions;\n\n    private Pattern indirectColumnExclusions;\n\n    private String userConnectionPropertiesFile;\n\n    private Properties userConnectionProperties;\n\n    private Integer maxDbThreads;\n\n    private Integer maxDetailedTables;\n\n    private String driverPath;\n\n    private String css;\n\n    private String charset;\n\n    private String font;\n\n    private Integer fontSize;\n\n    private String description;\n\n    private Properties dbProperties;\n\n    private String dbPropertiesLoadedFrom;\n\n    private Level logLevel;\n\n    private SqlFormatter sqlFormatter;\n\n    private String sqlFormatterClass;\n\n    private Boolean generateHtml;\n\n    private Boolean includeImpliedConstraints;\n\n    private Boolean logoEnabled;\n\n    private Boolean rankDirBugEnabled;\n\n    private Boolean encodeCommentsEnabled;\n\n    private Boolean numRowsEnabled;\n\n    private Boolean viewsEnabled;\n\n    private Boolean meterEnabled;\n\n    private Boolean railsEnabled;\n\n    private Boolean evaluteAll;\n\n    private Boolean highQuality;\n\n    private Boolean lowQuality;\n\n    // used in conjunction with evaluateAll\n    private String schemaSpec;\n\n    private boolean hasOrphans = false;\n\n    private boolean hasRoutines = false;\n\n    private boolean populating = false;\n\n    private List<String> columnDetails;\n\n    public static final String DOT_CHARSET = \"UTF-8\";\n\n    private static final String ESCAPED_EQUALS = \"\\\\=\";\n\n    // match everything\n    private static final String DEFAULT_TABLE_INCLUSION = \".*\";\n\n    // match nothing\n    private static final String DEFAULT_TABLE_EXCLUSION = \"\";\n\n    // match nothing\n    private static final String DEFAULT_COLUMN_EXCLUSION = \"[^.]\";\n\n    /**\n     * Default constructor. Intended for when you want to inject properties\n     * independently (i.e. not from a command line interface).\n     */\n    public Config() {\n        if (instance == null)\n            setInstance(this);\n        options = new ArrayList<String>();\n    }\n\n    /**\n     * Construct a configuration from an array of options (e.g. from a command\n     * line interface).\n     *\n     * @param options\n     */\n    public Config(String[] argv) {\n        setInstance(this);\n        options = fixupArgs(Arrays.asList(argv));\n        helpRequired = options.remove(\"-?\") || options.remove(\"/?\") || options.remove(\"?\") || options.remove(\"-h\") || options.remove(\"-help\") || options.remove(\"--help\");\n        dbHelpRequired = options.remove(\"-dbHelp\") || options.remove(\"-dbhelp\");\n    }\n\n    public static Config getInstance() {\n        if (instance == null)\n            instance = new Config();\n        return instance;\n    }\n\n    /**\n     * Sets the global instance.\n     *\n     * Useful for things like selecting a specific configuration in a UI.\n     *\n     * @param config\n     */\n    public static void setInstance(Config config) {\n        instance = config;\n    }\n\n    public void setHtmlGenerationEnabled(boolean generateHtml) {\n        this.generateHtml = generateHtml;\n    }\n\n    public boolean isHtmlGenerationEnabled() {\n        if (generateHtml == null)\n            generateHtml = !options.remove(\"-nohtml\");\n        return generateHtml;\n    }\n\n    public void setImpliedConstraintsEnabled(boolean includeImpliedConstraints) {\n        this.includeImpliedConstraints = includeImpliedConstraints;\n    }\n\n    public boolean isImpliedConstraintsEnabled() {\n        if (includeImpliedConstraints == null)\n            includeImpliedConstraints = !options.remove(\"-noimplied\");\n        return includeImpliedConstraints;\n    }\n\n    public void setOutputDir(String outputDirName) {\n        if (outputDirName.endsWith(\"\\\"\"))\n            outputDirName = outputDirName.substring(0, outputDirName.length() - 1);\n        setOutputDir(new File(outputDirName));\n    }\n\n    public void setOutputDir(File outputDir) {\n        this.outputDir = outputDir;\n    }\n\n    public File getOutputDir() {\n        if (outputDir == null) {\n            setOutputDir(pullRequiredParam(\"-o\"));\n        }\n        return outputDir;\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(String graphvizDir) {\n        if (graphvizDir.endsWith(\"\\\"\"))\n            graphvizDir = graphvizDir.substring(0, graphvizDir.length() - 1);\n        setGraphvizDir(new File(graphvizDir));\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(File graphvizDir) {\n        this.graphvizDir = graphvizDir;\n    }\n\n    /**\n     * Return the path to Graphviz (used to find the dot executable to run to\n     * generate ER diagrams).<p/>\n     *\n     * Returns {@link #getDefaultGraphvizPath()} if a specific Graphviz path\n     * was not specified.\n     *\n     * @return\n     */\n    public File getGraphvizDir() {\n        if (graphvizDir == null) {\n            String gv = pullParam(\"-gv\");\n            if (gv != null) {\n                setGraphvizDir(gv);\n            } else {\n                // expect to find Graphviz's bin directory on the PATH\n            }\n        }\n        return graphvizDir;\n    }\n\n    /**\n     * Meta files are XML-based files that provide additional metadata\n     * about the schema being evaluated.<p>\n     * <code>meta</code> is either the name of an individual XML file or\n     * the directory that contains meta files.<p>\n     * If a directory is specified then it is expected to contain files\n     * matching the pattern <code>[schema].meta.xml</code>.\n     * For databases that don't have schema substitute database for schema.\n     * @param meta\n     */\n    public void setMeta(String meta) {\n        this.meta = meta;\n    }\n\n    public String getMeta() {\n        if (meta == null)\n            meta = pullParam(\"-meta\");\n        return meta;\n    }\n\n    public void setDbType(String dbType) {\n        this.dbType = dbType;\n    }\n\n    public String getDbType() {\n        if (dbType == null) {\n            dbType = pullParam(\"-t\");\n            if (dbType == null)\n                dbType = \"ora\";\n        }\n        return dbType;\n    }\n\n    public void setDb(String db) {\n        this.db = db;\n    }\n\n    public String getDb() {\n        if (db == null)\n            db = pullParam(\"-db\");\n        return db;\n    }\n\n    public void setCatalog(String catalog) {\n        this.catalog = catalog;\n    }\n\n    public String getCatalog() {\n        if (catalog == null)\n            catalog = pullParam(\"-cat\");\n        return catalog;\n    }\n\n    public void setSchema(String schema) {\n        this.schema = schema;\n    }\n\n    public String getSchema() {\n        if (schema == null)\n            schema = pullParam(\"-s\");\n        return schema;\n    }\n\n    /**\n     * Some databases types (e.g. older versions of Informix) don't really\n     * have the concept of a schema but still return true from\n     * {@link DatabaseMetaData#supportsSchemasInTableDefinitions()}.\n     * This option lets you ignore that and treat all the tables\n     * as if they were in one flat namespace.\n     */\n    public boolean isSchemaDisabled() {\n        if (noSchema == null)\n            noSchema = options.remove(\"-noschema\");\n        return noSchema;\n    }\n\n    public void setHost(String host) {\n        this.host = host;\n    }\n\n    public String getHost() {\n        if (host == null)\n            host = pullParam(\"-host\");\n        return host;\n    }\n\n    public void setPort(Integer port) {\n        this.port = port;\n    }\n\n    public Integer getPort() {\n        if (port == null)\n            try {\n                port = Integer.valueOf(pullParam(\"-port\"));\n            } catch (Exception notSpecified) {\n            }\n        return port;\n    }\n\n    public void setServer(String server) {\n        this.server = server;\n    }\n\n    public String getServer() {\n        if (server == null) {\n            server = pullParam(\"-server\");\n        }\n        return server;\n    }\n\n    public void setUser(String user) {\n        this.user = user;\n    }\n\n    /**\n     * User used to connect to the database.\n     * Required unless single sign-on is enabled\n     * (see {@link #setSingleSignOn(boolean)}).\n     * @return\n     */\n    public String getUser() {\n        if (user == null) {\n            if (!isSingleSignOn())\n                user = pullRequiredParam(\"-u\");\n            else\n                user = pullParam(\"-u\");\n        }\n        return user;\n    }\n\n    /**\n     * By default a \"user\" (as specified with -u) is required.\n     * This option allows disabling of that requirement for\n     * single sign-on environments.\n     *\n     * @param enabled defaults to <code>false</code>\n     */\n    public void setSingleSignOn(boolean enabled) {\n        singleSignOn = enabled;\n    }\n\n    /**\n     * @see #setSingleSignOn(boolean)\n     */\n    public boolean isSingleSignOn() {\n        if (singleSignOn == null)\n            singleSignOn = options.remove(\"-sso\");\n        return singleSignOn;\n    }\n\n    /**\n     * Set the password used to connect to the database.\n     * @param password\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * @see #setPassword(String)\n     * @return\n     */\n    public String getPassword() {\n        if (password == null)\n            password = pullParam(\"-p\");\n        if (password == null && isPromptForPasswordEnabled())\n            password = new String(PasswordReader.getInstance().readPassword(\"Password: \"));\n        if (password == null) {\n            // if -pfp is enabled when analyzing multiple schemas then\n            // we don't want to send the password on the command line,\n            // so see if it was passed in the environment (not ideal, but safer)\n            password = System.getenv(\"schemaspy.pw\");\n        }\n        return password;\n    }\n\n    /**\n     * Set to <code>true</code> to prompt for the password\n     * @param promptForPassword\n     */\n    public void setPromptForPasswordEnabled(boolean promptForPassword) {\n        this.promptForPassword = promptForPassword;\n    }\n\n    /**\n     * @see #setPromptForPasswordEnabled(boolean)\n     * @return\n     */\n    public boolean isPromptForPasswordEnabled() {\n        if (promptForPassword == null) {\n            promptForPassword = options.remove(\"-pfp\");\n        }\n        return promptForPassword;\n    }\n\n    public void setMaxDetailedTabled(int maxDetailedTables) {\n        this.maxDetailedTables = new Integer(maxDetailedTables);\n    }\n\n    public int getMaxDetailedTables() {\n        if (maxDetailedTables == null) {\n            // default\n            int max = 300;\n            try {\n                max = Integer.parseInt(pullParam(\"-maxdet\"));\n            } catch (Exception notSpecified) {\n            }\n            maxDetailedTables = new Integer(max);\n        }\n        return maxDetailedTables.intValue();\n    }\n\n    public String getConnectionPropertiesFile() {\n        return userConnectionPropertiesFile;\n    }\n\n    /**\n     * Properties from this file (in key=value pair format) are passed to the\n     * database connection.<br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.\n     * @param propertiesFilename\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public void setConnectionPropertiesFile(String propertiesFilename) throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null)\n            userConnectionProperties = new Properties();\n        userConnectionProperties.load(new FileInputStream(propertiesFilename));\n        userConnectionPropertiesFile = propertiesFilename;\n    }\n\n    /**\n     * Returns a {@link Properties} populated either from the properties file specified\n     * by {@link #setConnectionPropertiesFile(String)}, the properties specified by\n     * {@link #setConnectionProperties(String)} or not populated.\n     * @return\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public Properties getConnectionProperties() throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null) {\n            String props = pullParam(\"-connprops\");\n            if (props != null) {\n                if (props.indexOf(ESCAPED_EQUALS) != -1) {\n                    setConnectionProperties(props);\n                } else {\n                    setConnectionPropertiesFile(props);\n                }\n            } else {\n                userConnectionProperties = new Properties();\n            }\n        }\n        return userConnectionProperties;\n    }\n\n    /**\n     * Specifies connection properties to use in the format:\n     * <code>key1\\=value1;key2\\=value2</code><br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.<p>\n     * This is an alternative form of passing connection properties than by file\n     * (see {@link #setConnectionPropertiesFile(String)})\n     *\n     * @param properties\n     */\n    public void setConnectionProperties(String properties) {\n        userConnectionProperties = new Properties();\n        StringTokenizer tokenizer = new StringTokenizer(properties, \";\");\n        while (tokenizer.hasMoreElements()) {\n            String pair = tokenizer.nextToken();\n            int index = pair.indexOf(ESCAPED_EQUALS);\n            if (index != -1) {\n                String key = pair.substring(0, index);\n                String value = pair.substring(index + ESCAPED_EQUALS.length());\n                userConnectionProperties.put(key, value);\n            }\n        }\n    }\n\n    public void setDriverPath(String driverPath) {\n        this.driverPath = driverPath;\n    }\n\n    public String getDriverPath() {\n        if (driverPath == null)\n            driverPath = pullParam(\"-dp\");\n        // was previously -cp:\n        if (driverPath == null)\n            driverPath = pullParam(\"-cp\");\n        return driverPath;\n    }\n\n    /**\n     * The filename of the cascading style sheet to use.\n     * Note that this file is parsed and used to determine characteristics\n     * of the generated diagrams, so it must contain specific settings that\n     * are documented within schemaSpy.css.<p>\n     *\n     * Defaults to <code>\"schemaSpy.css\"</code>.\n     *\n     * @param css\n     */\n    public void setCss(String css) {\n        this.css = css;\n    }\n\n    public String getCss() {\n        if (css == null) {\n            css = pullParam(\"-css\");\n            if (css == null)\n                css = \"schemaSpy.css\";\n        }\n        return css;\n    }\n\n    /**\n     * The font to use within diagrams.  Modify the .css to specify HTML fonts.\n     *\n     * @param font\n     */\n    public void setFont(String font) {\n        this.font = font;\n    }\n\n    /**\n     * @see #setFont(String)\n     */\n    public String getFont() {\n        if (font == null) {\n            font = pullParam(\"-font\");\n            if (font == null)\n                font = \"Helvetica\";\n        }\n        return font;\n    }\n\n    /**\n     * The font size to use within diagrams.  This is the size of the font used for\n     * 'large' (e.g. not 'compact') diagrams.<p>\n     *\n     * Modify the .css to specify HTML font sizes.<p>\n     *\n     * Defaults to 11.\n     *\n     * @param fontSize\n     */\n    public void setFontSize(int fontSize) {\n        this.fontSize = new Integer(fontSize);\n    }\n\n    /**\n     * @see #setFontSize(int)\n     * @return\n     */\n    public int getFontSize() {\n        if (fontSize == null) {\n            // default\n            int size = 11;\n            try {\n                size = Integer.parseInt(pullParam(\"-fontsize\"));\n            } catch (Exception notSpecified) {\n            }\n            fontSize = new Integer(size);\n        }\n        return fontSize.intValue();\n    }\n\n    /**\n     * The character set to use within HTML pages (defaults to <code>\"ISO-8859-1\"</code>).\n     *\n     * @param charset\n     */\n    public void setCharset(String charset) {\n        this.charset = charset;\n    }\n\n    /**\n     * @see #setCharset(String)\n     */\n    public String getCharset() {\n        if (charset == null) {\n            charset = pullParam(\"-charset\");\n            if (charset == null)\n                charset = \"ISO-8859-1\";\n        }\n        return charset;\n    }\n\n    /**\n     * Description of schema that gets display on main pages.\n     *\n     * @param description\n     */\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    /**\n     * @see #setDescription(String)\n     */\n    public String getDescription() {\n        if (description == null)\n            description = pullParam(\"-desc\");\n        return description;\n    }\n\n    /**\n     * Maximum number of threads to use when querying database metadata information.\n     *\n     * @param maxDbThreads\n     */\n    public void setMaxDbThreads(int maxDbThreads) {\n        this.maxDbThreads = new Integer(maxDbThreads);\n    }\n\n    /**\n     * @see #setMaxDbThreads(int)\n     * @throws InvalidConfigurationException if unable to load properties\n     */\n    public int getMaxDbThreads() throws InvalidConfigurationException {\n        if (maxDbThreads == null) {\n            Properties properties;\n            try {\n                properties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(\"Failed to load properties for \" + getDbType() + \": \" + exc).setParamName(\"-type\");\n            }\n            // not scientifically derived\n            final int defaultMax = 15;\n            int max = defaultMax;\n            String threads = properties.getProperty(\"dbThreads\");\n            if (threads == null)\n                threads = properties.getProperty(\"dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            threads = pullParam(\"-dbThreads\");\n            if (threads == null)\n                threads = pullParam(\"-dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            if (max < 0)\n                max = defaultMax;\n            else if (max == 0)\n                max = 1;\n            maxDbThreads = new Integer(max);\n        }\n        return maxDbThreads.intValue();\n    }\n\n    public boolean isLogoEnabled() {\n        if (logoEnabled == null)\n            logoEnabled = !options.remove(\"-nologo\");\n        return logoEnabled;\n    }\n\n    /**\n     * Don't use this unless absolutely necessary as it screws up the layout\n     *\n     * @param enabled\n     */\n    public void setRankDirBugEnabled(boolean enabled) {\n        rankDirBugEnabled = enabled;\n    }\n\n    /**\n     * @see #setRankDirBugEnabled(boolean)\n     */\n    public boolean isRankDirBugEnabled() {\n        if (rankDirBugEnabled == null)\n            rankDirBugEnabled = options.remove(\"-rankdirbug\");\n        return rankDirBugEnabled;\n    }\n\n    /**\n     * Look for Ruby on Rails-based naming conventions in\n     * relationships between logical foreign keys and primary keys.<p>\n     *\n     * Basically all tables have a primary key named <code>ID</code>.\n     * All tables are named plural names.\n     * The columns that logically reference that <code>ID</code> are the singular\n     * form of the table name suffixed with <code>_ID</code>.<p>\n     *\n     * @param enabled\n     */\n    public void setRailsEnabled(boolean enabled) {\n        railsEnabled = enabled;\n    }\n\n    /**\n     * @see #setRailsEnabled(boolean)\n     *\n     * @return\n     */\n    public boolean isRailsEnabled() {\n        if (railsEnabled == null)\n            railsEnabled = options.remove(\"-rails\");\n        return railsEnabled;\n    }\n\n    /**\n     * Allow Html In Comments - encode them unless otherwise specified\n     */\n    public void setEncodeCommentsEnabled(boolean enabled) {\n        encodeCommentsEnabled = enabled;\n    }\n\n    /**\n     * @see #setEncodeCommentsEnabled(boolean)\n     */\n    public boolean isEncodeCommentsEnabled() {\n        if (encodeCommentsEnabled == null)\n            encodeCommentsEnabled = !options.remove(\"-ahic\");\n        return encodeCommentsEnabled;\n    }\n\n    /**\n     * If enabled we'll attempt to query/render the number of rows that\n     * each table contains.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setNumRowsEnabled(boolean enabled) {\n        numRowsEnabled = enabled;\n    }\n\n    /**\n     * @see #setNumRowsEnabled(boolean)\n     * @return\n     */\n    public boolean isNumRowsEnabled() {\n        if (numRowsEnabled == null)\n            numRowsEnabled = !options.remove(\"-norows\");\n        return numRowsEnabled;\n    }\n\n    /**\n     * If enabled we'll include views in the analysis.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setViewsEnabled(boolean enabled) {\n        viewsEnabled = enabled;\n    }\n\n    /**\n     * @see #setViewsEnabled(boolean)\n     * @return\n     */\n    public boolean isViewsEnabled() {\n        if (viewsEnabled == null)\n            viewsEnabled = !options.remove(\"-noviews\");\n        return viewsEnabled;\n    }\n\n    /**\n     * Returns <code>true</code> if metering should be embedded in\n     * the generated pages.<p/>\n     * Defaults to <code>false</code> (disabled).\n     * @return\n     */\n    public boolean isMeterEnabled() {\n        if (meterEnabled == null)\n            meterEnabled = options.remove(\"-meter\");\n        return meterEnabled;\n    }\n\n    /**\n     * Set the columns to exclude from all relationship diagrams.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setColumnExclusions(String columnExclusions) {\n        this.columnExclusions = Pattern.compile(columnExclusions);\n    }\n\n    /**\n     * See {@link #setColumnExclusions(String)}\n     * @return\n     */\n    public Pattern getColumnExclusions() {\n        if (columnExclusions == null) {\n            String strExclusions = pullParam(\"-X\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.columnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            columnExclusions = Pattern.compile(strExclusions);\n        }\n        return columnExclusions;\n    }\n\n    /**\n     * Set the columns to exclude from relationship diagrams where the specified\n     * columns aren't directly referenced by the focal table.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setIndirectColumnExclusions(String fullColumnExclusions) {\n        indirectColumnExclusions = Pattern.compile(fullColumnExclusions);\n    }\n\n    /**\n     * @see #setIndirectColumnExclusions(String)\n     *\n     * @return\n     */\n    public Pattern getIndirectColumnExclusions() {\n        if (indirectColumnExclusions == null) {\n            String strExclusions = pullParam(\"-x\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.indirectColumnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            indirectColumnExclusions = Pattern.compile(strExclusions);\n        }\n        return indirectColumnExclusions;\n    }\n\n    /**\n     * Set the tables to include as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableInclusions(String tableInclusions) {\n        this.tableInclusions = Pattern.compile(tableInclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to include in the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableInclusions() {\n        if (tableInclusions == null) {\n            String strInclusions = pullParam(\"-i\");\n            if (strInclusions == null)\n                strInclusions = System.getenv(\"schemaspy.tableInclusions\");\n            if (strInclusions == null)\n                strInclusions = DEFAULT_TABLE_INCLUSION;\n            try {\n                tableInclusions = Pattern.compile(strInclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-i\");\n            }\n        }\n        return tableInclusions;\n    }\n\n    /**\n     * Set the tables to exclude as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableExclusions(String tableExclusions) {\n        this.tableExclusions = Pattern.compile(tableExclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to exclude from the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableExclusions() {\n        if (tableExclusions == null) {\n            String strExclusions = pullParam(\"-I\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.tableExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_TABLE_EXCLUSION;\n            try {\n                tableExclusions = Pattern.compile(strExclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-I\");\n            }\n        }\n        return tableExclusions;\n    }\n\n    /**\n     * @return\n     */\n    public List<String> getSchemas() {\n        if (schemas == null) {\n            String tmp = pullParam(\"-schemas\");\n            if (tmp == null)\n                tmp = pullParam(\"-schemata\");\n            if (tmp != null) {\n                schemas = new ArrayList<String>();\n                for (String name : tmp.split(\"[\\\\s,'\\\"]\")) {\n                    if (name.length() > 0)\n                        schemas.add(name);\n                }\n                if (schemas.isEmpty())\n                    schemas = null;\n            }\n        }\n        return schemas;\n    }\n\n    /**\n     * Set the name of the {@link SqlFormatter SQL formatter} class to use to\n     * format SQL into HTML.<p/>\n     * The implementation of the class must be made available to the class\n     * loader, typically by specifying the path to its jar with <em>-dp</em>\n     * ({@link #setDriverPath(String)}).\n     */\n    public void setSqlFormatter(String formatterClassName) {\n        sqlFormatterClass = formatterClassName;\n        sqlFormatter = null;\n    }\n\n    /**\n     * Set the {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.\n     */\n    public void setSqlFormatter(SqlFormatter sqlFormatter) {\n        this.sqlFormatter = sqlFormatter;\n        if (sqlFormatter != null)\n            sqlFormatterClass = sqlFormatter.getClass().getName();\n    }\n\n    /**\n     * Returns an implementation of {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.  The default implementation is {@link DefaultSqlFormatter}.\n     *\n     * @return\n     * @throws InvalidConfigurationException if unable to instantiate an instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SqlFormatter getSqlFormatter() throws InvalidConfigurationException {\n        if (sqlFormatter == null) {\n            if (sqlFormatterClass == null) {\n                sqlFormatterClass = pullParam(\"-sqlFormatter\");\n                if (sqlFormatterClass == null)\n                    sqlFormatterClass = DefaultSqlFormatter.class.getName();\n            }\n            try {\n                Class<SqlFormatter> clazz = (Class<SqlFormatter>) Class.forName(sqlFormatterClass);\n                sqlFormatter = clazz.newInstance();\n            } catch (Exception exc) {\n                throw new InvalidConfigurationException(\"Failed to initialize instance of SQL formatter: \", exc).setParamName(\"-sqlFormatter\");\n            }\n        }\n        return sqlFormatter;\n    }\n\n    /**\n     * Set the details to show on the columns page, where \"details\" are\n     * comma and/or space separated.\n     *\n     * Valid values:\n     * <ul>\n     * <li>id</li>\n     * <li>table</li>\n     * <li>column</li>\n     * <li>type</li>\n     * <li>size</li>\n     * <li>nulls</li>\n     * <li>auto</li>\n     * <li>default</li>\n     * <li>children</li>\n     * <li>parents</li>\n     * </ul>\n     *\n     * The default details are <code>\"table column type size nulls auto default\"</code>.\n     * Note that \"column\" is the initially displayed detail and must be included.\n     *\n     * @param columnDetails\n     */\n    public void setColumnDetails(String columnDetails) {\n        this.columnDetails = new ArrayList<String>();\n        if (columnDetails == null || columnDetails.length() == 0) {\n            // not specified, so use defaults\n            columnDetails = \"id table column type size nulls auto default\";\n        }\n        for (String detail : columnDetails.split(\"[\\\\s,'\\\"]\")) {\n            if (detail.length() > 0) {\n                this.columnDetails.add(detail.toLowerCase());\n            }\n        }\n        if (!this.columnDetails.contains(\"column\"))\n            throw new InvalidConfigurationException(\"'column' is a required column detail\");\n    }\n\n    public void setColumnDetails(List<String> columnDetails) {\n        String details = columnDetails == null ? \"[]\" : columnDetails.toString();\n        setColumnDetails(details.substring(1, details.length() - 1));\n    }\n\n    public List<String> getColumnDetails() {\n        if (columnDetails == null) {\n            setColumnDetails(pullParam(\"-columndetails\"));\n        }\n        return columnDetails;\n    }\n\n    public void setEvaluateAllEnabled(boolean enabled) {\n        evaluteAll = enabled;\n    }\n\n    public boolean isEvaluateAllEnabled() {\n        if (evaluteAll == null)\n            evaluteAll = options.remove(\"-all\");\n        return evaluteAll;\n    }\n\n    /**\n     * Returns true if we're evaluating a bunch of schemas in one go and\n     * at this point we're evaluating a specific schema.\n     *\n     * @return boolean\n     */\n    public boolean isOneOfMultipleSchemas() {\n        // set by MultipleSchemaAnalyzer\n        return Boolean.getBoolean(\"oneofmultipleschemas\");\n    }\n\n    /**\n     * When -all (evaluateAll) is specified then this is the regular\n     * expression that determines which schemas to evaluate.\n     *\n     * @param schemaSpec\n     */\n    public void setSchemaSpec(String schemaSpec) {\n        this.schemaSpec = schemaSpec;\n    }\n\n    public String getSchemaSpec() {\n        if (schemaSpec == null)\n            schemaSpec = pullParam(\"-schemaSpec\");\n        return schemaSpec;\n    }\n\n    /**\n     * Set the renderer to use for the -Tpng[:renderer[:formatter]] dot option as specified\n     * at <a href='http://www.graphviz.org/doc/info/command.html'>\n     * http://www.graphviz.org/doc/info/command.html</a>.<p>\n     * Note that the leading \":\" is required while :formatter is optional.<p>\n     * The default renderer is typically GD.<p>\n     * Note that using {@link #setHighQuality(boolean)} is the preferred approach\n     * over using this method.\n     */\n    public void setRenderer(String renderer) {\n        Dot.getInstance().setRenderer(renderer);\n    }\n\n    /**\n     * @see #setRenderer(String)\n     * @return\n     */\n    public String getRenderer() {\n        String renderer = pullParam(\"-renderer\");\n        if (renderer != null)\n            setRenderer(renderer);\n        return Dot.getInstance().getRenderer();\n    }\n\n    /**\n     * If <code>false</code> then generate output of \"lower quality\"\n     * than the default.\n     * Note that the default is intended to be \"higher quality\",\n     * but various installations of Graphviz may have have different abilities.\n     * That is, some might not have the \"lower quality\" libraries and others might\n     * not have the \"higher quality\" libraries.<p>\n     * Higher quality output takes longer to generate and results in significantly\n     * larger image files (which take longer to download / display), but it generally\n     * looks better.\n     */\n    public void setHighQuality(boolean highQuality) {\n        this.highQuality = highQuality;\n        lowQuality = !highQuality;\n        Dot.getInstance().setHighQuality(highQuality);\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isHighQuality() {\n        if (highQuality == null) {\n            highQuality = options.remove(\"-hq\");\n            if (highQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(highQuality);\n            }\n        }\n        highQuality = Dot.getInstance().isHighQuality();\n        return highQuality;\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isLowQuality() {\n        if (lowQuality == null) {\n            lowQuality = options.remove(\"-lq\");\n            if (lowQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(!lowQuality);\n            }\n        }\n        lowQuality = !Dot.getInstance().isHighQuality();\n        return lowQuality;\n    }\n\n    /**\n     * Set the level of logging to perform.<p/>\n     * The levels in descending order are:\n     * <ul>\n     *  <li><code>severe</code> (highest - least detail)\n     *  <li><code>warning</code> (default)\n     *  <li><code>info</code>\n     *  <li><code>config</code>\n     *  <li><code>fine</code>\n     *  <li><code>finer</code>\n     *  <li><code>finest</code>  (lowest - most detail)\n     * </ul>\n     *\n     * @param logLevel\n     */\n    public void setLogLevel(String logLevel) {\n        if (logLevel == null) {\n            this.logLevel = Level.WARNING;\n            return;\n        }\n        Map<String, Level> levels = new LinkedHashMap<String, Level>();\n        levels.put(\"severe\", Level.SEVERE);\n        levels.put(\"warning\", Level.WARNING);\n        levels.put(\"info\", Level.INFO);\n        levels.put(\"config\", Level.CONFIG);\n        levels.put(\"fine\", Level.FINE);\n        levels.put(\"finer\", Level.FINER);\n        levels.put(\"finest\", Level.FINEST);\n        this.logLevel = levels.get(logLevel.toLowerCase());\n        if (this.logLevel == null) {\n            throw new InvalidConfigurationException(\"Invalid logLevel: '\" + logLevel + \"'. Must be one of: \" + levels.keySet());\n        }\n    }\n\n    /**\n     * Returns the level of logging to perform.\n     * See {@link #setLogLevel(String)}.\n     *\n     * @return\n     */\n    public Level getLogLevel() {\n        if (logLevel == null) {\n            setLogLevel(pullParam(\"-loglevel\"));\n        }\n        return logLevel;\n    }\n\n    /**\n     * Returns <code>true</code> if the options indicate that the user wants\n     * to see some help information.\n     *\n     * @return\n     */\n    public boolean isHelpRequired() {\n        return helpRequired;\n    }\n\n    public boolean isDbHelpRequired() {\n        return dbHelpRequired;\n    }\n\n    /**\n     * Returns the jar that we were loaded from\n     *\n     * @return\n     */\n    public static String getLoadedFromJar() {\n        String classpath = System.getProperty(\"java.class.path\");\n        return new StringTokenizer(classpath, File.pathSeparator).nextToken();\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasOrphans(boolean hasOrphans) {\n        this.hasOrphans = hasOrphans;\n    }\n\n    /**\n     * @see #setHasOrphans()\n     *\n     * @return\n     */\n    public boolean hasOrphans() {\n        return hasOrphans;\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasRoutines(boolean hasRoutines) {\n        this.hasRoutines = hasRoutines;\n    }\n\n    /**\n     * @see #setHasRoutines()\n     *\n     * @return\n     */\n    public boolean hasRoutines() {\n        return hasRoutines;\n    }\n\n    /**\n     * Returns the database properties to use.\n     * These should be determined by calling {@link #determineDbProperties(String)}.\n     * @return\n     * @throws InvalidConfigurationException\n     */\n    public Properties getDbProperties() throws InvalidConfigurationException {\n        if (dbProperties == null) {\n            try {\n                dbProperties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(exc);\n            }\n        }\n        return dbProperties;\n    }\n\n    /**\n     * Determines the database properties associated with the specified type.\n     * A call to {@link #setDbProperties(Properties)} is expected after determining\n     * the complete set of properties.\n     *\n     * @param type\n     * @return\n     * @throws IOException\n     * @throws InvalidConfigurationException if db properties are incorrectly formed\n     */\n    public Properties determineDbProperties(String type) throws IOException, InvalidConfigurationException {\n        ResourceBundle bundle = null;\n        try {\n            File propertiesFile = new File(type);\n            bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n            dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n        } catch (FileNotFoundException notFoundOnFilesystemWithoutExtension) {\n            try {\n                File propertiesFile = new File(type + \".properties\");\n                bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n                dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n            } catch (FileNotFoundException notFoundOnFilesystemWithExtensionTackedOn) {\n                try {\n                    bundle = ResourceBundle.getBundle(type);\n                    dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]\" + File.separator + type + \".properties\";\n                } catch (Exception notInJarWithoutPath) {\n                    try {\n                        String path = TableOrderer.class.getPackage().getName() + \".dbTypes.\" + type;\n                        path = path.replace('.', '/');\n                        bundle = ResourceBundle.getBundle(path);\n                        dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]/\" + path + \".properties\";\n                    } catch (Exception notInJar) {\n                        notInJar.printStackTrace();\n                        notFoundOnFilesystemWithExtensionTackedOn.printStackTrace();\n                        throw notFoundOnFilesystemWithoutExtension;\n                    }\n                }\n            }\n        }\n        Properties props = asProperties(bundle);\n        bundle = null;\n        // keep original thru recursion\n        String saveLoadedFrom = dbPropertiesLoadedFrom;\n        // bring in key/values pointed to by the include directive\n        // example: include.1=mysql::selectRowCountSql\n        for (int i = 1; true; ++i) {\n            String include = (String) props.remove(\"include.\" + i);\n            if (include == null)\n                break;\n            int separator = include.indexOf(\"::\");\n            if (separator == -1)\n                throw new InvalidConfigurationException(\"include directive in \" + dbPropertiesLoadedFrom + \" must have '::' between dbType and key\");\n            String refdType = include.substring(0, separator).trim();\n            String refdKey = include.substring(separator + 2).trim();\n            // recursively resolve the ref'd properties file and the ref'd key\n            Properties refdProps = determineDbProperties(refdType);\n            props.put(refdKey, refdProps.getProperty(refdKey));\n        }\n        // bring in base properties files pointed to by the extends directive\n        String baseDbType = (String) props.remove(\"extends\");\n        if (baseDbType != null) {\n            baseDbType = baseDbType.trim();\n            Properties baseProps = determineDbProperties(baseDbType);\n            // overlay our properties on top of the base's\n            baseProps.putAll(props);\n            props = baseProps;\n        }\n        // done with this level of recursion...restore original\n        dbPropertiesLoadedFrom = saveLoadedFrom;\n        // this won't be correct until the final recursion exits\n        dbProperties = props;\n        return props;\n    }\n\n    protected String getDbPropertiesLoadedFrom() throws IOException {\n        if (dbPropertiesLoadedFrom == null)\n            determineDbProperties(getDbType());\n        return dbPropertiesLoadedFrom;\n    }\n\n    public List<String> getRemainingParameters() {\n        try {\n            populate();\n        } catch (IllegalArgumentException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (IllegalAccessException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (InvocationTargetException exc) {\n            if (exc.getCause() instanceof InvalidConfigurationException)\n                throw (InvalidConfigurationException) exc.getCause();\n            throw new InvalidConfigurationException(exc.getCause());\n        } catch (IntrospectionException exc) {\n            throw new InvalidConfigurationException(exc);\n        }\n        return options;\n    }\n\n    /**\n     * Options that are specific to a type of database.  E.g. things like <code>host</code>,\n     * <code>port</code> or <code>db</code>, but <b>don't</b> have a setter in this class.\n     *\n     * @param dbSpecificOptions\n     */\n    public void setDbSpecificOptions(Map<String, String> dbSpecificOptions) {\n        this.dbSpecificOptions = dbSpecificOptions;\n        originalDbSpecificOptions = new HashMap<String, String>(dbSpecificOptions);\n    }\n\n    public Map<String, String> getDbSpecificOptions() {\n        if (dbSpecificOptions == null)\n            dbSpecificOptions = new HashMap<String, String>();\n        return dbSpecificOptions;\n    }\n\n    /**\n     * Returns a {@link Properties} populated with the contents of <code>bundle</code>\n     *\n     * @param bundle ResourceBundle\n     * @return Properties\n     */\n    public static Properties asProperties(ResourceBundle bundle) {\n        Properties props = new Properties();\n        Enumeration<String> iter = bundle.getKeys();\n        while (iter.hasMoreElements()) {\n            String key = iter.nextElement();\n            props.put(key, bundle.getObject(key));\n        }\n        return props;\n    }\n\n    /**\n     * 'Pull' the specified parameter from the collection of options. Returns\n     * null if the parameter isn't in the list and removes it if it is.\n     *\n     * @param paramId\n     * @return\n     */\n    private String pullParam(String paramId) {\n        return pullParam(paramId, false, false);\n    }\n\n    private String pullRequiredParam(String paramId) {\n        return pullParam(paramId, true, false);\n    }\n\n    /**\n     * @param paramId\n     * @param required\n     * @param dbTypeSpecific\n     * @return\n     * @throws MissingRequiredParameterException\n     */\n    private String pullParam(String paramId, boolean required, boolean dbTypeSpecific) throws MissingRequiredParameterException {\n        int paramIndex = options.indexOf(paramId);\n        if (paramIndex < 0) {\n            if (required)\n                throw new MissingRequiredParameterException(paramId, dbTypeSpecific);\n            return null;\n        }\n        options.remove(paramIndex);\n        String param = options.get(paramIndex).toString();\n        options.remove(paramIndex);\n        return param;\n    }\n\n    /**\n     * Thrown to indicate that a required parameter is missing\n     */\n    public static class MissingRequiredParameterException extends RuntimeException {\n\n        private static final long serialVersionUID = 1L;\n\n        private final boolean dbTypeSpecific;\n\n        public MissingRequiredParameterException(String paramId, boolean dbTypeSpecific) {\n            this(paramId, null, dbTypeSpecific);\n        }\n\n        public MissingRequiredParameterException(String paramId, String description, boolean dbTypeSpecific) {\n            super(\"Required parameter '\" + paramId + \"' \" + (description == null ? \"\" : \"(\" + description + \") \") + \"was not specified.\" + (dbTypeSpecific ? \"  It is required for this database type.\" : \"\"));\n            this.dbTypeSpecific = dbTypeSpecific;\n        }\n\n        public boolean isDbTypeSpecific() {\n            return dbTypeSpecific;\n        }\n    }\n\n    /**\n     * Allow an equal sign in args...like \"-o=foo.bar\". Useful for things like\n     * Ant and Maven.\n     *\n     * @param args\n     *            List\n     * @return List\n     */\n    protected List<String> fixupArgs(List<String> args) {\n        List<String> expandedArgs = new ArrayList<String>();\n        for (String arg : args) {\n            int indexOfEquals = arg.indexOf('=');\n            if (indexOfEquals != -1 && indexOfEquals - 1 != arg.indexOf(ESCAPED_EQUALS)) {\n                expandedArgs.add(arg.substring(0, indexOfEquals));\n                expandedArgs.add(arg.substring(indexOfEquals + 1));\n            } else {\n                expandedArgs.add(arg);\n            }\n        }\n        // some OSes/JVMs do filename expansion with runtime.exec() and some don't,\n        // so MultipleSchemaAnalyzer has to surround params with double quotes...\n        // strip them here for the OSes/JVMs that don't do anything with the params\n        List<String> unquotedArgs = new ArrayList<String>();\n        for (String arg : expandedArgs) {\n            if (// \".*\" becomes .*\n            arg.startsWith(\"\\\"\") && arg.endsWith(\"\\\"\"))\n                arg = arg.substring(1, arg.length() - 1);\n            unquotedArgs.add(arg);\n        }\n        return unquotedArgs;\n    }\n\n    /**\n     * Call all the getters to populate all the lazy initialized stuff.\n     *\n     * @throws InvocationTargetException\n     * @throws IllegalAccessException\n     * @throws IllegalArgumentException\n     * @throws IntrospectionException\n     */\n    private void populate() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IntrospectionException {\n        if (!populating) {\n            // prevent recursion\n            populating = true;\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                Method readMethod = props[i].getReadMethod();\n                if (readMethod != null)\n                    readMethod.invoke(this, (Object[]) null);\n            }\n            populating = false;\n        }\n    }\n\n    public static Set<String> getBuiltInDatabaseTypes(String loadedFromJar) {\n        Set<String> databaseTypes = new TreeSet<String>();\n        JarInputStream jar = null;\n        try {\n            jar = new JarInputStream(new FileInputStream(loadedFromJar));\n            JarEntry entry;\n            while ((entry = jar.getNextJarEntry()) != null) {\n                String entryName = entry.getName();\n                int dotPropsIndex = entryName.indexOf(\".properties\");\n                if (dotPropsIndex != -1)\n                    databaseTypes.add(entryName.substring(0, dotPropsIndex));\n            }\n        } catch (IOException exc) {\n        } finally {\n            if (jar != null) {\n                try {\n                    jar.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n        return databaseTypes;\n    }\n\n    protected void dumpUsage(String errorMessage, boolean detailedDb) {\n        if (errorMessage != null) {\n            System.out.flush();\n            System.err.println(\"*** \" + errorMessage + \" ***\");\n        } else {\n            System.out.println(\"SchemaSpy generates an HTML representation of a database schema's relationships.\");\n        }\n        System.err.flush();\n        System.out.println();\n        if (!detailedDb) {\n            System.out.println(\"Usage:\");\n            System.out.println(\" java -jar \" + getLoadedFromJar() + \" [options]\");\n            System.out.println(\"   -t databaseType       type of database - defaults to ora\");\n            System.out.println(\"                           use -dbhelp for a list of built-in types\");\n            System.out.println(\"   -u user               connect to the database with this user id\");\n            System.out.println(\"   -s schema             defaults to the specified user\");\n            System.out.println(\"   -p password           defaults to no password\");\n            System.out.println(\"   -o outputDirectory    directory to place the generated output in\");\n            System.out.println(\"   -dp pathToDrivers     optional - looks for JDBC drivers here before looking\");\n            System.out.println(\"                           in driverPath in [databaseType].properties.\");\n            System.out.println(\"Go to http://schemaspy.sourceforge.net for a complete list/description\");\n            System.out.println(\" of additional parameters.\");\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"Built-in database types and their required connection parameters:\");\n            for (String type : getBuiltInDatabaseTypes(getLoadedFromJar())) {\n                new DbSpecificConfig(type).dumpUsage();\n            }\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"You can use your own database types by specifying the filespec of a .properties file with -t.\");\n            System.out.println(\"Grab one out of \" + getLoadedFromJar() + \" and modify it to suit your needs.\");\n            System.out.println();\n        }\n        System.out.println(\"Sample usage using the default database type (implied -t ora):\");\n        System.out.println(\" java -jar schemaSpy.jar -db mydb -s myschema -u devuser -p password -o output\");\n        System.out.println();\n        System.out.flush();\n    }\n\n    /**\n     * Get the value of the specified parameter.\n     * Used for properties that are common to most db's, but aren't required.\n     *\n     * @param paramName\n     * @return\n     */\n    public String getParam(String paramName) {\n        try {\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                PropertyDescriptor prop = props[i];\n                if (prop.getName().equalsIgnoreCase(paramName)) {\n                    Object result = prop.getReadMethod().invoke(this, (Object[]) null);\n                    return result == null ? null : result.toString();\n                }\n            }\n        } catch (Exception failed) {\n            failed.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * Return all of the configuration options as a List of Strings, with\n     * each parameter and its value as a separate element.\n     *\n     * @return\n     * @throws IOException\n     */\n    public List<String> asList() throws IOException {\n        List<String> params = new ArrayList<String>();\n        if (originalDbSpecificOptions != null) {\n            for (String key : originalDbSpecificOptions.keySet()) {\n                String value = originalDbSpecificOptions.get(key);\n                if (!key.startsWith(\"-\"))\n                    key = \"-\" + key;\n                params.add(key);\n                params.add(value);\n            }\n        }\n        if (isEncodeCommentsEnabled())\n            params.add(\"-ahic\");\n        if (isEvaluateAllEnabled())\n            params.add(\"-all\");\n        if (!isHtmlGenerationEnabled())\n            params.add(\"-nohtml\");\n        if (!isImpliedConstraintsEnabled())\n            params.add(\"-noimplied\");\n        if (!isLogoEnabled())\n            params.add(\"-nologo\");\n        if (isMeterEnabled())\n            params.add(\"-meter\");\n        if (!isNumRowsEnabled())\n            params.add(\"-norows\");\n        if (!isViewsEnabled())\n            params.add(\"-noviews\");\n        if (isRankDirBugEnabled())\n            params.add(\"-rankdirbug\");\n        if (isRailsEnabled())\n            params.add(\"-rails\");\n        if (isSingleSignOn())\n            params.add(\"-sso\");\n        if (isSchemaDisabled())\n            params.add(\"-noschema\");\n        String value = getDriverPath();\n        if (value != null) {\n            params.add(\"-dp\");\n            params.add(value);\n        }\n        params.add(\"-css\");\n        params.add(getCss());\n        params.add(\"-charset\");\n        params.add(getCharset());\n        params.add(\"-font\");\n        params.add(getFont());\n        params.add(\"-fontsize\");\n        params.add(String.valueOf(getFontSize()));\n        params.add(\"-t\");\n        params.add(getDbType());\n        // query to set renderer correctly\n        isHighQuality();\n        // query to set renderer correctly\n        isLowQuality();\n        // instead of -hq and/or -lq\n        params.add(\"-renderer\");\n        params.add(getRenderer());\n        value = getDescription();\n        if (value != null) {\n            params.add(\"-desc\");\n            params.add(value);\n        }\n        value = getPassword();\n        if (value != null && !isPromptForPasswordEnabled()) {\n            // note that we don't pass -pfp since child processes\n            // won't have a console\n            params.add(\"-p\");\n            params.add(value);\n        }\n        value = getCatalog();\n        if (value != null) {\n            params.add(\"-cat\");\n            params.add(value);\n        }\n        value = getSchema();\n        if (value != null) {\n            params.add(\"-s\");\n            params.add(value);\n        }\n        value = getUser();\n        if (value != null) {\n            params.add(\"-u\");\n            params.add(value);\n        }\n        value = getConnectionPropertiesFile();\n        if (value != null) {\n            params.add(\"-connprops\");\n            params.add(value);\n        } else {\n            Properties props = getConnectionProperties();\n            if (!props.isEmpty()) {\n                params.add(\"-connprops\");\n                StringBuilder buf = new StringBuilder();\n                for (Entry<Object, Object> entry : props.entrySet()) {\n                    buf.append(entry.getKey());\n                    buf.append(ESCAPED_EQUALS);\n                    buf.append(entry.getValue());\n                    buf.append(';');\n                }\n                params.add(buf.toString());\n            }\n        }\n        value = getDb();\n        if (value != null) {\n            params.add(\"-db\");\n            params.add(value);\n        }\n        value = getHost();\n        if (value != null) {\n            params.add(\"-host\");\n            params.add(value);\n        }\n        if (getPort() != null) {\n            params.add(\"-port\");\n            params.add(getPort().toString());\n        }\n        value = getServer();\n        if (value != null) {\n            params.add(\"-server\");\n            params.add(value);\n        }\n        value = getMeta();\n        if (value != null) {\n            params.add(\"-meta\");\n            params.add(value);\n        }\n        if (getGraphvizDir() != null) {\n            params.add(\"-gv\");\n            params.add(getGraphvizDir().toString());\n        }\n        params.add(\"-loglevel\");\n        params.add(getLogLevel().toString().toLowerCase());\n        params.add(\"-sqlFormatter\");\n        params.add(getSqlFormatter().getClass().getName());\n        params.add(\"-i\");\n        params.add(getTableInclusions().toString());\n        params.add(\"-I\");\n        params.add(getTableExclusions().toString());\n        params.add(\"-X\");\n        params.add(getColumnExclusions().toString());\n        params.add(\"-x\");\n        params.add(getIndirectColumnExclusions().toString());\n        params.add(\"-dbthreads\");\n        params.add(String.valueOf(getMaxDbThreads()));\n        params.add(\"-maxdet\");\n        params.add(String.valueOf(getMaxDetailedTables()));\n        params.add(\"-o\");\n        params.add(getOutputDir().toString());\n        return params;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/ConfigTest9.java",
		"test_prompt": "// ConfigTest9.java\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Config}.\n* It contains ten unit test cases for the {@link Config#isEncodeCommentsEnabled()} method.\n*/\nclass ConfigTest9 {"
	},
	{
		"original_code": "// Config.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\n\n/**\n * Configuration of a SchemaSpy run\n *\n * @author John Currier\n */\npublic class Config {\n\n    private static Config instance;\n\n    private final List<String> options;\n\n    private Map<String, String> dbSpecificOptions;\n\n    private Map<String, String> originalDbSpecificOptions;\n\n    private boolean helpRequired;\n\n    private boolean dbHelpRequired;\n\n    private File outputDir;\n\n    private File graphvizDir;\n\n    private String dbType;\n\n    private String catalog;\n\n    private String schema;\n\n    private List<String> schemas;\n\n    private String user;\n\n    private Boolean singleSignOn;\n\n    private Boolean noSchema;\n\n    private String password;\n\n    private Boolean promptForPassword;\n\n    private String db;\n\n    private String host;\n\n    private Integer port;\n\n    private String server;\n\n    private String meta;\n\n    private Pattern tableInclusions;\n\n    private Pattern tableExclusions;\n\n    private Pattern columnExclusions;\n\n    private Pattern indirectColumnExclusions;\n\n    private String userConnectionPropertiesFile;\n\n    private Properties userConnectionProperties;\n\n    private Integer maxDbThreads;\n\n    private Integer maxDetailedTables;\n\n    private String driverPath;\n\n    private String css;\n\n    private String charset;\n\n    private String font;\n\n    private Integer fontSize;\n\n    private String description;\n\n    private Properties dbProperties;\n\n    private String dbPropertiesLoadedFrom;\n\n    private Level logLevel;\n\n    private SqlFormatter sqlFormatter;\n\n    private String sqlFormatterClass;\n\n    private Boolean generateHtml;\n\n    private Boolean includeImpliedConstraints;\n\n    private Boolean logoEnabled;\n\n    private Boolean rankDirBugEnabled;\n\n    private Boolean encodeCommentsEnabled;\n\n    private Boolean numRowsEnabled;\n\n    private Boolean viewsEnabled;\n\n    private Boolean meterEnabled;\n\n    private Boolean railsEnabled;\n\n    private Boolean evaluteAll;\n\n    private Boolean highQuality;\n\n    private Boolean lowQuality;\n\n    // used in conjunction with evaluateAll\n    private String schemaSpec;\n\n    private boolean hasOrphans = false;\n\n    private boolean hasRoutines = false;\n\n    private boolean populating = false;\n\n    private List<String> columnDetails;\n\n    public static final String DOT_CHARSET = \"UTF-8\";\n\n    private static final String ESCAPED_EQUALS = \"\\\\=\";\n\n    // match everything\n    private static final String DEFAULT_TABLE_INCLUSION = \".*\";\n\n    // match nothing\n    private static final String DEFAULT_TABLE_EXCLUSION = \"\";\n\n    // match nothing\n    private static final String DEFAULT_COLUMN_EXCLUSION = \"[^.]\";\n\n    /**\n     * Default constructor. Intended for when you want to inject properties\n     * independently (i.e. not from a command line interface).\n     */\n    public Config() {\n        if (instance == null)\n            setInstance(this);\n        options = new ArrayList<String>();\n    }\n\n    /**\n     * Construct a configuration from an array of options (e.g. from a command\n     * line interface).\n     *\n     * @param options\n     */\n    public Config(String[] argv) {\n        setInstance(this);\n        options = fixupArgs(Arrays.asList(argv));\n        helpRequired = options.remove(\"-?\") || options.remove(\"/?\") || options.remove(\"?\") || options.remove(\"-h\") || options.remove(\"-help\") || options.remove(\"--help\");\n        dbHelpRequired = options.remove(\"-dbHelp\") || options.remove(\"-dbhelp\");\n    }\n\n    public static Config getInstance() {\n        if (instance == null)\n            instance = new Config();\n        return instance;\n    }\n\n    /**\n     * Sets the global instance.\n     *\n     * Useful for things like selecting a specific configuration in a UI.\n     *\n     * @param config\n     */\n    public static void setInstance(Config config) {\n        instance = config;\n    }\n\n    public void setHtmlGenerationEnabled(boolean generateHtml) {\n        this.generateHtml = generateHtml;\n    }\n\n    public boolean isHtmlGenerationEnabled() {\n        if (generateHtml == null)\n            generateHtml = !options.remove(\"-nohtml\");\n        return generateHtml;\n    }\n\n    public void setImpliedConstraintsEnabled(boolean includeImpliedConstraints) {\n        this.includeImpliedConstraints = includeImpliedConstraints;\n    }\n\n    public boolean isImpliedConstraintsEnabled() {\n        if (includeImpliedConstraints == null)\n            includeImpliedConstraints = !options.remove(\"-noimplied\");\n        return includeImpliedConstraints;\n    }\n\n    public void setOutputDir(String outputDirName) {\n        if (outputDirName.endsWith(\"\\\"\"))\n            outputDirName = outputDirName.substring(0, outputDirName.length() - 1);\n        setOutputDir(new File(outputDirName));\n    }\n\n    public void setOutputDir(File outputDir) {\n        this.outputDir = outputDir;\n    }\n\n    public File getOutputDir() {\n        if (outputDir == null) {\n            setOutputDir(pullRequiredParam(\"-o\"));\n        }\n        return outputDir;\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(String graphvizDir) {\n        if (graphvizDir.endsWith(\"\\\"\"))\n            graphvizDir = graphvizDir.substring(0, graphvizDir.length() - 1);\n        setGraphvizDir(new File(graphvizDir));\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(File graphvizDir) {\n        this.graphvizDir = graphvizDir;\n    }\n\n    /**\n     * Return the path to Graphviz (used to find the dot executable to run to\n     * generate ER diagrams).<p/>\n     *\n     * Returns {@link #getDefaultGraphvizPath()} if a specific Graphviz path\n     * was not specified.\n     *\n     * @return\n     */\n    public File getGraphvizDir() {\n        if (graphvizDir == null) {\n            String gv = pullParam(\"-gv\");\n            if (gv != null) {\n                setGraphvizDir(gv);\n            } else {\n                // expect to find Graphviz's bin directory on the PATH\n            }\n        }\n        return graphvizDir;\n    }\n\n    /**\n     * Meta files are XML-based files that provide additional metadata\n     * about the schema being evaluated.<p>\n     * <code>meta</code> is either the name of an individual XML file or\n     * the directory that contains meta files.<p>\n     * If a directory is specified then it is expected to contain files\n     * matching the pattern <code>[schema].meta.xml</code>.\n     * For databases that don't have schema substitute database for schema.\n     * @param meta\n     */\n    public void setMeta(String meta) {\n        this.meta = meta;\n    }\n\n    public String getMeta() {\n        if (meta == null)\n            meta = pullParam(\"-meta\");\n        return meta;\n    }\n\n    public void setDbType(String dbType) {\n        this.dbType = dbType;\n    }\n\n    public String getDbType() {\n        if (dbType == null) {\n            dbType = pullParam(\"-t\");\n            if (dbType == null)\n                dbType = \"ora\";\n        }\n        return dbType;\n    }\n\n    public void setDb(String db) {\n        this.db = db;\n    }\n\n    public String getDb() {\n        if (db == null)\n            db = pullParam(\"-db\");\n        return db;\n    }\n\n    public void setCatalog(String catalog) {\n        this.catalog = catalog;\n    }\n\n    public String getCatalog() {\n        if (catalog == null)\n            catalog = pullParam(\"-cat\");\n        return catalog;\n    }\n\n    public void setSchema(String schema) {\n        this.schema = schema;\n    }\n\n    public String getSchema() {\n        if (schema == null)\n            schema = pullParam(\"-s\");\n        return schema;\n    }\n\n    /**\n     * Some databases types (e.g. older versions of Informix) don't really\n     * have the concept of a schema but still return true from\n     * {@link DatabaseMetaData#supportsSchemasInTableDefinitions()}.\n     * This option lets you ignore that and treat all the tables\n     * as if they were in one flat namespace.\n     */\n    public boolean isSchemaDisabled() {\n        if (noSchema == null)\n            noSchema = options.remove(\"-noschema\");\n        return noSchema;\n    }\n\n    public void setHost(String host) {\n        this.host = host;\n    }\n\n    public String getHost() {\n        if (host == null)\n            host = pullParam(\"-host\");\n        return host;\n    }\n\n    public void setPort(Integer port) {\n        this.port = port;\n    }\n\n    public Integer getPort() {\n        if (port == null)\n            try {\n                port = Integer.valueOf(pullParam(\"-port\"));\n            } catch (Exception notSpecified) {\n            }\n        return port;\n    }\n\n    public void setServer(String server) {\n        this.server = server;\n    }\n\n    public String getServer() {\n        if (server == null) {\n            server = pullParam(\"-server\");\n        }\n        return server;\n    }\n\n    public void setUser(String user) {\n        this.user = user;\n    }\n\n    /**\n     * User used to connect to the database.\n     * Required unless single sign-on is enabled\n     * (see {@link #setSingleSignOn(boolean)}).\n     * @return\n     */\n    public String getUser() {\n        if (user == null) {\n            if (!isSingleSignOn())\n                user = pullRequiredParam(\"-u\");\n            else\n                user = pullParam(\"-u\");\n        }\n        return user;\n    }\n\n    /**\n     * By default a \"user\" (as specified with -u) is required.\n     * This option allows disabling of that requirement for\n     * single sign-on environments.\n     *\n     * @param enabled defaults to <code>false</code>\n     */\n    public void setSingleSignOn(boolean enabled) {\n        singleSignOn = enabled;\n    }\n\n    /**\n     * @see #setSingleSignOn(boolean)\n     */\n    public boolean isSingleSignOn() {\n        if (singleSignOn == null)\n            singleSignOn = options.remove(\"-sso\");\n        return singleSignOn;\n    }\n\n    /**\n     * Set the password used to connect to the database.\n     * @param password\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * @see #setPassword(String)\n     * @return\n     */\n    public String getPassword() {\n        if (password == null)\n            password = pullParam(\"-p\");\n        if (password == null && isPromptForPasswordEnabled())\n            password = new String(PasswordReader.getInstance().readPassword(\"Password: \"));\n        if (password == null) {\n            // if -pfp is enabled when analyzing multiple schemas then\n            // we don't want to send the password on the command line,\n            // so see if it was passed in the environment (not ideal, but safer)\n            password = System.getenv(\"schemaspy.pw\");\n        }\n        return password;\n    }\n\n    /**\n     * Set to <code>true</code> to prompt for the password\n     * @param promptForPassword\n     */\n    public void setPromptForPasswordEnabled(boolean promptForPassword) {\n        this.promptForPassword = promptForPassword;\n    }\n\n    /**\n     * @see #setPromptForPasswordEnabled(boolean)\n     * @return\n     */\n    public boolean isPromptForPasswordEnabled() {\n        if (promptForPassword == null) {\n            promptForPassword = options.remove(\"-pfp\");\n        }\n        return promptForPassword;\n    }\n\n    public void setMaxDetailedTabled(int maxDetailedTables) {\n        this.maxDetailedTables = new Integer(maxDetailedTables);\n    }\n\n    public int getMaxDetailedTables() {\n        if (maxDetailedTables == null) {\n            // default\n            int max = 300;\n            try {\n                max = Integer.parseInt(pullParam(\"-maxdet\"));\n            } catch (Exception notSpecified) {\n            }\n            maxDetailedTables = new Integer(max);\n        }\n        return maxDetailedTables.intValue();\n    }\n\n    public String getConnectionPropertiesFile() {\n        return userConnectionPropertiesFile;\n    }\n\n    /**\n     * Properties from this file (in key=value pair format) are passed to the\n     * database connection.<br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.\n     * @param propertiesFilename\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public void setConnectionPropertiesFile(String propertiesFilename) throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null)\n            userConnectionProperties = new Properties();\n        userConnectionProperties.load(new FileInputStream(propertiesFilename));\n        userConnectionPropertiesFile = propertiesFilename;\n    }\n\n    /**\n     * Returns a {@link Properties} populated either from the properties file specified\n     * by {@link #setConnectionPropertiesFile(String)}, the properties specified by\n     * {@link #setConnectionProperties(String)} or not populated.\n     * @return\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public Properties getConnectionProperties() throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null) {\n            String props = pullParam(\"-connprops\");\n            if (props != null) {\n                if (props.indexOf(ESCAPED_EQUALS) != -1) {\n                    setConnectionProperties(props);\n                } else {\n                    setConnectionPropertiesFile(props);\n                }\n            } else {\n                userConnectionProperties = new Properties();\n            }\n        }\n        return userConnectionProperties;\n    }\n\n    /**\n     * Specifies connection properties to use in the format:\n     * <code>key1\\=value1;key2\\=value2</code><br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.<p>\n     * This is an alternative form of passing connection properties than by file\n     * (see {@link #setConnectionPropertiesFile(String)})\n     *\n     * @param properties\n     */\n    public void setConnectionProperties(String properties) {\n        userConnectionProperties = new Properties();\n        StringTokenizer tokenizer = new StringTokenizer(properties, \";\");\n        while (tokenizer.hasMoreElements()) {\n            String pair = tokenizer.nextToken();\n            int index = pair.indexOf(ESCAPED_EQUALS);\n            if (index != -1) {\n                String key = pair.substring(0, index);\n                String value = pair.substring(index + ESCAPED_EQUALS.length());\n                userConnectionProperties.put(key, value);\n            }\n        }\n    }\n\n    public void setDriverPath(String driverPath) {\n        this.driverPath = driverPath;\n    }\n\n    public String getDriverPath() {\n        if (driverPath == null)\n            driverPath = pullParam(\"-dp\");\n        // was previously -cp:\n        if (driverPath == null)\n            driverPath = pullParam(\"-cp\");\n        return driverPath;\n    }\n\n    /**\n     * The filename of the cascading style sheet to use.\n     * Note that this file is parsed and used to determine characteristics\n     * of the generated diagrams, so it must contain specific settings that\n     * are documented within schemaSpy.css.<p>\n     *\n     * Defaults to <code>\"schemaSpy.css\"</code>.\n     *\n     * @param css\n     */\n    public void setCss(String css) {\n        this.css = css;\n    }\n\n    public String getCss() {\n        if (css == null) {\n            css = pullParam(\"-css\");\n            if (css == null)\n                css = \"schemaSpy.css\";\n        }\n        return css;\n    }\n\n    /**\n     * The font to use within diagrams.  Modify the .css to specify HTML fonts.\n     *\n     * @param font\n     */\n    public void setFont(String font) {\n        this.font = font;\n    }\n\n    /**\n     * @see #setFont(String)\n     */\n    public String getFont() {\n        if (font == null) {\n            font = pullParam(\"-font\");\n            if (font == null)\n                font = \"Helvetica\";\n        }\n        return font;\n    }\n\n    /**\n     * The font size to use within diagrams.  This is the size of the font used for\n     * 'large' (e.g. not 'compact') diagrams.<p>\n     *\n     * Modify the .css to specify HTML font sizes.<p>\n     *\n     * Defaults to 11.\n     *\n     * @param fontSize\n     */\n    public void setFontSize(int fontSize) {\n        this.fontSize = new Integer(fontSize);\n    }\n\n    /**\n     * @see #setFontSize(int)\n     * @return\n     */\n    public int getFontSize() {\n        if (fontSize == null) {\n            // default\n            int size = 11;\n            try {\n                size = Integer.parseInt(pullParam(\"-fontsize\"));\n            } catch (Exception notSpecified) {\n            }\n            fontSize = new Integer(size);\n        }\n        return fontSize.intValue();\n    }\n\n    /**\n     * The character set to use within HTML pages (defaults to <code>\"ISO-8859-1\"</code>).\n     *\n     * @param charset\n     */\n    public void setCharset(String charset) {\n        this.charset = charset;\n    }\n\n    /**\n     * @see #setCharset(String)\n     */\n    public String getCharset() {\n        if (charset == null) {\n            charset = pullParam(\"-charset\");\n            if (charset == null)\n                charset = \"ISO-8859-1\";\n        }\n        return charset;\n    }\n\n    /**\n     * Description of schema that gets display on main pages.\n     *\n     * @param description\n     */\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    /**\n     * @see #setDescription(String)\n     */\n    public String getDescription() {\n        if (description == null)\n            description = pullParam(\"-desc\");\n        return description;\n    }\n\n    /**\n     * Maximum number of threads to use when querying database metadata information.\n     *\n     * @param maxDbThreads\n     */\n    public void setMaxDbThreads(int maxDbThreads) {\n        this.maxDbThreads = new Integer(maxDbThreads);\n    }\n\n    /**\n     * @see #setMaxDbThreads(int)\n     * @throws InvalidConfigurationException if unable to load properties\n     */\n    public int getMaxDbThreads() throws InvalidConfigurationException {\n        if (maxDbThreads == null) {\n            Properties properties;\n            try {\n                properties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(\"Failed to load properties for \" + getDbType() + \": \" + exc).setParamName(\"-type\");\n            }\n            // not scientifically derived\n            final int defaultMax = 15;\n            int max = defaultMax;\n            String threads = properties.getProperty(\"dbThreads\");\n            if (threads == null)\n                threads = properties.getProperty(\"dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            threads = pullParam(\"-dbThreads\");\n            if (threads == null)\n                threads = pullParam(\"-dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            if (max < 0)\n                max = defaultMax;\n            else if (max == 0)\n                max = 1;\n            maxDbThreads = new Integer(max);\n        }\n        return maxDbThreads.intValue();\n    }\n\n    public boolean isLogoEnabled() {\n        if (logoEnabled == null)\n            logoEnabled = !options.remove(\"-nologo\");\n        return logoEnabled;\n    }\n\n    /**\n     * Don't use this unless absolutely necessary as it screws up the layout\n     *\n     * @param enabled\n     */\n    public void setRankDirBugEnabled(boolean enabled) {\n        rankDirBugEnabled = enabled;\n    }\n\n    /**\n     * @see #setRankDirBugEnabled(boolean)\n     */\n    public boolean isRankDirBugEnabled() {\n        if (rankDirBugEnabled == null)\n            rankDirBugEnabled = options.remove(\"-rankdirbug\");\n        return rankDirBugEnabled;\n    }\n\n    /**\n     * Look for Ruby on Rails-based naming conventions in\n     * relationships between logical foreign keys and primary keys.<p>\n     *\n     * Basically all tables have a primary key named <code>ID</code>.\n     * All tables are named plural names.\n     * The columns that logically reference that <code>ID</code> are the singular\n     * form of the table name suffixed with <code>_ID</code>.<p>\n     *\n     * @param enabled\n     */\n    public void setRailsEnabled(boolean enabled) {\n        railsEnabled = enabled;\n    }\n\n    /**\n     * @see #setRailsEnabled(boolean)\n     *\n     * @return\n     */\n    public boolean isRailsEnabled() {\n        if (railsEnabled == null)\n            railsEnabled = options.remove(\"-rails\");\n        return railsEnabled;\n    }\n\n    /**\n     * Allow Html In Comments - encode them unless otherwise specified\n     */\n    public void setEncodeCommentsEnabled(boolean enabled) {\n        encodeCommentsEnabled = enabled;\n    }\n\n    /**\n     * @see #setEncodeCommentsEnabled(boolean)\n     */\n    public boolean isEncodeCommentsEnabled() {\n        if (encodeCommentsEnabled == null)\n            encodeCommentsEnabled = !options.remove(\"-ahic\");\n        return encodeCommentsEnabled;\n    }\n\n    /**\n     * If enabled we'll attempt to query/render the number of rows that\n     * each table contains.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setNumRowsEnabled(boolean enabled) {\n        numRowsEnabled = enabled;\n    }\n\n    /**\n     * @see #setNumRowsEnabled(boolean)\n     * @return\n     */\n    public boolean isNumRowsEnabled() {\n        if (numRowsEnabled == null)\n            numRowsEnabled = !options.remove(\"-norows\");\n        return numRowsEnabled;\n    }\n\n    /**\n     * If enabled we'll include views in the analysis.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setViewsEnabled(boolean enabled) {\n        viewsEnabled = enabled;\n    }\n\n    /**\n     * @see #setViewsEnabled(boolean)\n     * @return\n     */\n    public boolean isViewsEnabled() {\n        if (viewsEnabled == null)\n            viewsEnabled = !options.remove(\"-noviews\");\n        return viewsEnabled;\n    }\n\n    /**\n     * Returns <code>true</code> if metering should be embedded in\n     * the generated pages.<p/>\n     * Defaults to <code>false</code> (disabled).\n     * @return\n     */\n    public boolean isMeterEnabled() {\n        if (meterEnabled == null)\n            meterEnabled = options.remove(\"-meter\");\n        return meterEnabled;\n    }\n\n    /**\n     * Set the columns to exclude from all relationship diagrams.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setColumnExclusions(String columnExclusions) {\n        this.columnExclusions = Pattern.compile(columnExclusions);\n    }\n\n    /**\n     * See {@link #setColumnExclusions(String)}\n     * @return\n     */\n    public Pattern getColumnExclusions() {\n        if (columnExclusions == null) {\n            String strExclusions = pullParam(\"-X\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.columnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            columnExclusions = Pattern.compile(strExclusions);\n        }\n        return columnExclusions;\n    }\n\n    /**\n     * Set the columns to exclude from relationship diagrams where the specified\n     * columns aren't directly referenced by the focal table.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setIndirectColumnExclusions(String fullColumnExclusions) {\n        indirectColumnExclusions = Pattern.compile(fullColumnExclusions);\n    }\n\n    /**\n     * @see #setIndirectColumnExclusions(String)\n     *\n     * @return\n     */\n    public Pattern getIndirectColumnExclusions() {\n        if (indirectColumnExclusions == null) {\n            String strExclusions = pullParam(\"-x\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.indirectColumnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            indirectColumnExclusions = Pattern.compile(strExclusions);\n        }\n        return indirectColumnExclusions;\n    }\n\n    /**\n     * Set the tables to include as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableInclusions(String tableInclusions) {\n        this.tableInclusions = Pattern.compile(tableInclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to include in the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableInclusions() {\n        if (tableInclusions == null) {\n            String strInclusions = pullParam(\"-i\");\n            if (strInclusions == null)\n                strInclusions = System.getenv(\"schemaspy.tableInclusions\");\n            if (strInclusions == null)\n                strInclusions = DEFAULT_TABLE_INCLUSION;\n            try {\n                tableInclusions = Pattern.compile(strInclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-i\");\n            }\n        }\n        return tableInclusions;\n    }\n\n    /**\n     * Set the tables to exclude as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableExclusions(String tableExclusions) {\n        this.tableExclusions = Pattern.compile(tableExclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to exclude from the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableExclusions() {\n        if (tableExclusions == null) {\n            String strExclusions = pullParam(\"-I\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.tableExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_TABLE_EXCLUSION;\n            try {\n                tableExclusions = Pattern.compile(strExclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-I\");\n            }\n        }\n        return tableExclusions;\n    }\n\n    /**\n     * @return\n     */\n    public List<String> getSchemas() {\n        if (schemas == null) {\n            String tmp = pullParam(\"-schemas\");\n            if (tmp == null)\n                tmp = pullParam(\"-schemata\");\n            if (tmp != null) {\n                schemas = new ArrayList<String>();\n                for (String name : tmp.split(\"[\\\\s,'\\\"]\")) {\n                    if (name.length() > 0)\n                        schemas.add(name);\n                }\n                if (schemas.isEmpty())\n                    schemas = null;\n            }\n        }\n        return schemas;\n    }\n\n    /**\n     * Set the name of the {@link SqlFormatter SQL formatter} class to use to\n     * format SQL into HTML.<p/>\n     * The implementation of the class must be made available to the class\n     * loader, typically by specifying the path to its jar with <em>-dp</em>\n     * ({@link #setDriverPath(String)}).\n     */\n    public void setSqlFormatter(String formatterClassName) {\n        sqlFormatterClass = formatterClassName;\n        sqlFormatter = null;\n    }\n\n    /**\n     * Set the {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.\n     */\n    public void setSqlFormatter(SqlFormatter sqlFormatter) {\n        this.sqlFormatter = sqlFormatter;\n        if (sqlFormatter != null)\n            sqlFormatterClass = sqlFormatter.getClass().getName();\n    }\n\n    /**\n     * Returns an implementation of {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.  The default implementation is {@link DefaultSqlFormatter}.\n     *\n     * @return\n     * @throws InvalidConfigurationException if unable to instantiate an instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SqlFormatter getSqlFormatter() throws InvalidConfigurationException {\n        if (sqlFormatter == null) {\n            if (sqlFormatterClass == null) {\n                sqlFormatterClass = pullParam(\"-sqlFormatter\");\n                if (sqlFormatterClass == null)\n                    sqlFormatterClass = DefaultSqlFormatter.class.getName();\n            }\n            try {\n                Class<SqlFormatter> clazz = (Class<SqlFormatter>) Class.forName(sqlFormatterClass);\n                sqlFormatter = clazz.newInstance();\n            } catch (Exception exc) {\n                throw new InvalidConfigurationException(\"Failed to initialize instance of SQL formatter: \", exc).setParamName(\"-sqlFormatter\");\n            }\n        }\n        return sqlFormatter;\n    }\n\n    /**\n     * Set the details to show on the columns page, where \"details\" are\n     * comma and/or space separated.\n     *\n     * Valid values:\n     * <ul>\n     * <li>id</li>\n     * <li>table</li>\n     * <li>column</li>\n     * <li>type</li>\n     * <li>size</li>\n     * <li>nulls</li>\n     * <li>auto</li>\n     * <li>default</li>\n     * <li>children</li>\n     * <li>parents</li>\n     * </ul>\n     *\n     * The default details are <code>\"table column type size nulls auto default\"</code>.\n     * Note that \"column\" is the initially displayed detail and must be included.\n     *\n     * @param columnDetails\n     */\n    public void setColumnDetails(String columnDetails) {\n        this.columnDetails = new ArrayList<String>();\n        if (columnDetails == null || columnDetails.length() == 0) {\n            // not specified, so use defaults\n            columnDetails = \"id table column type size nulls auto default\";\n        }\n        for (String detail : columnDetails.split(\"[\\\\s,'\\\"]\")) {\n            if (detail.length() > 0) {\n                this.columnDetails.add(detail.toLowerCase());\n            }\n        }\n        if (!this.columnDetails.contains(\"column\"))\n            throw new InvalidConfigurationException(\"'column' is a required column detail\");\n    }\n\n    public void setColumnDetails(List<String> columnDetails) {\n        String details = columnDetails == null ? \"[]\" : columnDetails.toString();\n        setColumnDetails(details.substring(1, details.length() - 1));\n    }\n\n    public List<String> getColumnDetails() {\n        if (columnDetails == null) {\n            setColumnDetails(pullParam(\"-columndetails\"));\n        }\n        return columnDetails;\n    }\n\n    public void setEvaluateAllEnabled(boolean enabled) {\n        evaluteAll = enabled;\n    }\n\n    public boolean isEvaluateAllEnabled() {\n        if (evaluteAll == null)\n            evaluteAll = options.remove(\"-all\");\n        return evaluteAll;\n    }\n\n    /**\n     * Returns true if we're evaluating a bunch of schemas in one go and\n     * at this point we're evaluating a specific schema.\n     *\n     * @return boolean\n     */\n    public boolean isOneOfMultipleSchemas() {\n        // set by MultipleSchemaAnalyzer\n        return Boolean.getBoolean(\"oneofmultipleschemas\");\n    }\n\n    /**\n     * When -all (evaluateAll) is specified then this is the regular\n     * expression that determines which schemas to evaluate.\n     *\n     * @param schemaSpec\n     */\n    public void setSchemaSpec(String schemaSpec) {\n        this.schemaSpec = schemaSpec;\n    }\n\n    public String getSchemaSpec() {\n        if (schemaSpec == null)\n            schemaSpec = pullParam(\"-schemaSpec\");\n        return schemaSpec;\n    }\n\n    /**\n     * Set the renderer to use for the -Tpng[:renderer[:formatter]] dot option as specified\n     * at <a href='http://www.graphviz.org/doc/info/command.html'>\n     * http://www.graphviz.org/doc/info/command.html</a>.<p>\n     * Note that the leading \":\" is required while :formatter is optional.<p>\n     * The default renderer is typically GD.<p>\n     * Note that using {@link #setHighQuality(boolean)} is the preferred approach\n     * over using this method.\n     */\n    public void setRenderer(String renderer) {\n        Dot.getInstance().setRenderer(renderer);\n    }\n\n    /**\n     * @see #setRenderer(String)\n     * @return\n     */\n    public String getRenderer() {\n        String renderer = pullParam(\"-renderer\");\n        if (renderer != null)\n            setRenderer(renderer);\n        return Dot.getInstance().getRenderer();\n    }\n\n    /**\n     * If <code>false</code> then generate output of \"lower quality\"\n     * than the default.\n     * Note that the default is intended to be \"higher quality\",\n     * but various installations of Graphviz may have have different abilities.\n     * That is, some might not have the \"lower quality\" libraries and others might\n     * not have the \"higher quality\" libraries.<p>\n     * Higher quality output takes longer to generate and results in significantly\n     * larger image files (which take longer to download / display), but it generally\n     * looks better.\n     */\n    public void setHighQuality(boolean highQuality) {\n        this.highQuality = highQuality;\n        lowQuality = !highQuality;\n        Dot.getInstance().setHighQuality(highQuality);\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isHighQuality() {\n        if (highQuality == null) {\n            highQuality = options.remove(\"-hq\");\n            if (highQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(highQuality);\n            }\n        }\n        highQuality = Dot.getInstance().isHighQuality();\n        return highQuality;\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isLowQuality() {\n        if (lowQuality == null) {\n            lowQuality = options.remove(\"-lq\");\n            if (lowQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(!lowQuality);\n            }\n        }\n        lowQuality = !Dot.getInstance().isHighQuality();\n        return lowQuality;\n    }\n\n    /**\n     * Set the level of logging to perform.<p/>\n     * The levels in descending order are:\n     * <ul>\n     *  <li><code>severe</code> (highest - least detail)\n     *  <li><code>warning</code> (default)\n     *  <li><code>info</code>\n     *  <li><code>config</code>\n     *  <li><code>fine</code>\n     *  <li><code>finer</code>\n     *  <li><code>finest</code>  (lowest - most detail)\n     * </ul>\n     *\n     * @param logLevel\n     */\n    public void setLogLevel(String logLevel) {\n        if (logLevel == null) {\n            this.logLevel = Level.WARNING;\n            return;\n        }\n        Map<String, Level> levels = new LinkedHashMap<String, Level>();\n        levels.put(\"severe\", Level.SEVERE);\n        levels.put(\"warning\", Level.WARNING);\n        levels.put(\"info\", Level.INFO);\n        levels.put(\"config\", Level.CONFIG);\n        levels.put(\"fine\", Level.FINE);\n        levels.put(\"finer\", Level.FINER);\n        levels.put(\"finest\", Level.FINEST);\n        this.logLevel = levels.get(logLevel.toLowerCase());\n        if (this.logLevel == null) {\n            throw new InvalidConfigurationException(\"Invalid logLevel: '\" + logLevel + \"'. Must be one of: \" + levels.keySet());\n        }\n    }\n\n    /**\n     * Returns the level of logging to perform.\n     * See {@link #setLogLevel(String)}.\n     *\n     * @return\n     */\n    public Level getLogLevel() {\n        if (logLevel == null) {\n            setLogLevel(pullParam(\"-loglevel\"));\n        }\n        return logLevel;\n    }\n\n    /**\n     * Returns <code>true</code> if the options indicate that the user wants\n     * to see some help information.\n     *\n     * @return\n     */\n    public boolean isHelpRequired() {\n        return helpRequired;\n    }\n\n    public boolean isDbHelpRequired() {\n        return dbHelpRequired;\n    }\n\n    /**\n     * Returns the jar that we were loaded from\n     *\n     * @return\n     */\n    public static String getLoadedFromJar() {\n        String classpath = System.getProperty(\"java.class.path\");\n        return new StringTokenizer(classpath, File.pathSeparator).nextToken();\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasOrphans(boolean hasOrphans) {\n        this.hasOrphans = hasOrphans;\n    }\n\n    /**\n     * @see #setHasOrphans()\n     *\n     * @return\n     */\n    public boolean hasOrphans() {\n        return hasOrphans;\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasRoutines(boolean hasRoutines) {\n        this.hasRoutines = hasRoutines;\n    }\n\n    /**\n     * @see #setHasRoutines()\n     *\n     * @return\n     */\n    public boolean hasRoutines() {\n        return hasRoutines;\n    }\n\n    /**\n     * Returns the database properties to use.\n     * These should be determined by calling {@link #determineDbProperties(String)}.\n     * @return\n     * @throws InvalidConfigurationException\n     */\n    public Properties getDbProperties() throws InvalidConfigurationException {\n        if (dbProperties == null) {\n            try {\n                dbProperties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(exc);\n            }\n        }\n        return dbProperties;\n    }\n\n    /**\n     * Determines the database properties associated with the specified type.\n     * A call to {@link #setDbProperties(Properties)} is expected after determining\n     * the complete set of properties.\n     *\n     * @param type\n     * @return\n     * @throws IOException\n     * @throws InvalidConfigurationException if db properties are incorrectly formed\n     */\n    public Properties determineDbProperties(String type) throws IOException, InvalidConfigurationException {\n        ResourceBundle bundle = null;\n        try {\n            File propertiesFile = new File(type);\n            bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n            dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n        } catch (FileNotFoundException notFoundOnFilesystemWithoutExtension) {\n            try {\n                File propertiesFile = new File(type + \".properties\");\n                bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n                dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n            } catch (FileNotFoundException notFoundOnFilesystemWithExtensionTackedOn) {\n                try {\n                    bundle = ResourceBundle.getBundle(type);\n                    dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]\" + File.separator + type + \".properties\";\n                } catch (Exception notInJarWithoutPath) {\n                    try {\n                        String path = TableOrderer.class.getPackage().getName() + \".dbTypes.\" + type;\n                        path = path.replace('.', '/');\n                        bundle = ResourceBundle.getBundle(path);\n                        dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]/\" + path + \".properties\";\n                    } catch (Exception notInJar) {\n                        notInJar.printStackTrace();\n                        notFoundOnFilesystemWithExtensionTackedOn.printStackTrace();\n                        throw notFoundOnFilesystemWithoutExtension;\n                    }\n                }\n            }\n        }\n        Properties props = asProperties(bundle);\n        bundle = null;\n        // keep original thru recursion\n        String saveLoadedFrom = dbPropertiesLoadedFrom;\n        // bring in key/values pointed to by the include directive\n        // example: include.1=mysql::selectRowCountSql\n        for (int i = 1; true; ++i) {\n            String include = (String) props.remove(\"include.\" + i);\n            if (include == null)\n                break;\n            int separator = include.indexOf(\"::\");\n            if (separator == -1)\n                throw new InvalidConfigurationException(\"include directive in \" + dbPropertiesLoadedFrom + \" must have '::' between dbType and key\");\n            String refdType = include.substring(0, separator).trim();\n            String refdKey = include.substring(separator + 2).trim();\n            // recursively resolve the ref'd properties file and the ref'd key\n            Properties refdProps = determineDbProperties(refdType);\n            props.put(refdKey, refdProps.getProperty(refdKey));\n        }\n        // bring in base properties files pointed to by the extends directive\n        String baseDbType = (String) props.remove(\"extends\");\n        if (baseDbType != null) {\n            baseDbType = baseDbType.trim();\n            Properties baseProps = determineDbProperties(baseDbType);\n            // overlay our properties on top of the base's\n            baseProps.putAll(props);\n            props = baseProps;\n        }\n        // done with this level of recursion...restore original\n        dbPropertiesLoadedFrom = saveLoadedFrom;\n        // this won't be correct until the final recursion exits\n        dbProperties = props;\n        return props;\n    }\n\n    protected String getDbPropertiesLoadedFrom() throws IOException {\n        if (dbPropertiesLoadedFrom == null)\n            determineDbProperties(getDbType());\n        return dbPropertiesLoadedFrom;\n    }\n\n    public List<String> getRemainingParameters() {\n        try {\n            populate();\n        } catch (IllegalArgumentException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (IllegalAccessException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (InvocationTargetException exc) {\n            if (exc.getCause() instanceof InvalidConfigurationException)\n                throw (InvalidConfigurationException) exc.getCause();\n            throw new InvalidConfigurationException(exc.getCause());\n        } catch (IntrospectionException exc) {\n            throw new InvalidConfigurationException(exc);\n        }\n        return options;\n    }\n\n    /**\n     * Options that are specific to a type of database.  E.g. things like <code>host</code>,\n     * <code>port</code> or <code>db</code>, but <b>don't</b> have a setter in this class.\n     *\n     * @param dbSpecificOptions\n     */\n    public void setDbSpecificOptions(Map<String, String> dbSpecificOptions) {\n        this.dbSpecificOptions = dbSpecificOptions;\n        originalDbSpecificOptions = new HashMap<String, String>(dbSpecificOptions);\n    }\n\n    public Map<String, String> getDbSpecificOptions() {\n        if (dbSpecificOptions == null)\n            dbSpecificOptions = new HashMap<String, String>();\n        return dbSpecificOptions;\n    }\n\n    /**\n     * Returns a {@link Properties} populated with the contents of <code>bundle</code>\n     *\n     * @param bundle ResourceBundle\n     * @return Properties\n     */\n    public static Properties asProperties(ResourceBundle bundle) {\n        Properties props = new Properties();\n        Enumeration<String> iter = bundle.getKeys();\n        while (iter.hasMoreElements()) {\n            String key = iter.nextElement();\n            props.put(key, bundle.getObject(key));\n        }\n        return props;\n    }\n\n    /**\n     * 'Pull' the specified parameter from the collection of options. Returns\n     * null if the parameter isn't in the list and removes it if it is.\n     *\n     * @param paramId\n     * @return\n     */\n    private String pullParam(String paramId) {\n        return pullParam(paramId, false, false);\n    }\n\n    private String pullRequiredParam(String paramId) {\n        return pullParam(paramId, true, false);\n    }\n\n    /**\n     * @param paramId\n     * @param required\n     * @param dbTypeSpecific\n     * @return\n     * @throws MissingRequiredParameterException\n     */\n    private String pullParam(String paramId, boolean required, boolean dbTypeSpecific) throws MissingRequiredParameterException {\n        int paramIndex = options.indexOf(paramId);\n        if (paramIndex < 0) {\n            if (required)\n                throw new MissingRequiredParameterException(paramId, dbTypeSpecific);\n            return null;\n        }\n        options.remove(paramIndex);\n        String param = options.get(paramIndex).toString();\n        options.remove(paramIndex);\n        return param;\n    }\n\n    /**\n     * Thrown to indicate that a required parameter is missing\n     */\n    public static class MissingRequiredParameterException extends RuntimeException {\n\n        private static final long serialVersionUID = 1L;\n\n        private final boolean dbTypeSpecific;\n\n        public MissingRequiredParameterException(String paramId, boolean dbTypeSpecific) {\n            this(paramId, null, dbTypeSpecific);\n        }\n\n        public MissingRequiredParameterException(String paramId, String description, boolean dbTypeSpecific) {\n            super(\"Required parameter '\" + paramId + \"' \" + (description == null ? \"\" : \"(\" + description + \") \") + \"was not specified.\" + (dbTypeSpecific ? \"  It is required for this database type.\" : \"\"));\n            this.dbTypeSpecific = dbTypeSpecific;\n        }\n\n        public boolean isDbTypeSpecific() {\n            return dbTypeSpecific;\n        }\n    }\n\n    /**\n     * Allow an equal sign in args...like \"-o=foo.bar\". Useful for things like\n     * Ant and Maven.\n     *\n     * @param args\n     *            List\n     * @return List\n     */\n    protected List<String> fixupArgs(List<String> args) {\n        List<String> expandedArgs = new ArrayList<String>();\n        for (String arg : args) {\n            int indexOfEquals = arg.indexOf('=');\n            if (indexOfEquals != -1 && indexOfEquals - 1 != arg.indexOf(ESCAPED_EQUALS)) {\n                expandedArgs.add(arg.substring(0, indexOfEquals));\n                expandedArgs.add(arg.substring(indexOfEquals + 1));\n            } else {\n                expandedArgs.add(arg);\n            }\n        }\n        // some OSes/JVMs do filename expansion with runtime.exec() and some don't,\n        // so MultipleSchemaAnalyzer has to surround params with double quotes...\n        // strip them here for the OSes/JVMs that don't do anything with the params\n        List<String> unquotedArgs = new ArrayList<String>();\n        for (String arg : expandedArgs) {\n            if (// \".*\" becomes .*\n            arg.startsWith(\"\\\"\") && arg.endsWith(\"\\\"\"))\n                arg = arg.substring(1, arg.length() - 1);\n            unquotedArgs.add(arg);\n        }\n        return unquotedArgs;\n    }\n\n    /**\n     * Call all the getters to populate all the lazy initialized stuff.\n     *\n     * @throws InvocationTargetException\n     * @throws IllegalAccessException\n     * @throws IllegalArgumentException\n     * @throws IntrospectionException\n     */\n    private void populate() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IntrospectionException {\n        if (!populating) {\n            // prevent recursion\n            populating = true;\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                Method readMethod = props[i].getReadMethod();\n                if (readMethod != null)\n                    readMethod.invoke(this, (Object[]) null);\n            }\n            populating = false;\n        }\n    }\n\n    public static Set<String> getBuiltInDatabaseTypes(String loadedFromJar) {\n        Set<String> databaseTypes = new TreeSet<String>();\n        JarInputStream jar = null;\n        try {\n            jar = new JarInputStream(new FileInputStream(loadedFromJar));\n            JarEntry entry;\n            while ((entry = jar.getNextJarEntry()) != null) {\n                String entryName = entry.getName();\n                int dotPropsIndex = entryName.indexOf(\".properties\");\n                if (dotPropsIndex != -1)\n                    databaseTypes.add(entryName.substring(0, dotPropsIndex));\n            }\n        } catch (IOException exc) {\n        } finally {\n            if (jar != null) {\n                try {\n                    jar.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n        return databaseTypes;\n    }\n\n    protected void dumpUsage(String errorMessage, boolean detailedDb) {\n        if (errorMessage != null) {\n            System.out.flush();\n            System.err.println(\"*** \" + errorMessage + \" ***\");\n        } else {\n            System.out.println(\"SchemaSpy generates an HTML representation of a database schema's relationships.\");\n        }\n        System.err.flush();\n        System.out.println();\n        if (!detailedDb) {\n            System.out.println(\"Usage:\");\n            System.out.println(\" java -jar \" + getLoadedFromJar() + \" [options]\");\n            System.out.println(\"   -t databaseType       type of database - defaults to ora\");\n            System.out.println(\"                           use -dbhelp for a list of built-in types\");\n            System.out.println(\"   -u user               connect to the database with this user id\");\n            System.out.println(\"   -s schema             defaults to the specified user\");\n            System.out.println(\"   -p password           defaults to no password\");\n            System.out.println(\"   -o outputDirectory    directory to place the generated output in\");\n            System.out.println(\"   -dp pathToDrivers     optional - looks for JDBC drivers here before looking\");\n            System.out.println(\"                           in driverPath in [databaseType].properties.\");\n            System.out.println(\"Go to http://schemaspy.sourceforge.net for a complete list/description\");\n            System.out.println(\" of additional parameters.\");\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"Built-in database types and their required connection parameters:\");\n            for (String type : getBuiltInDatabaseTypes(getLoadedFromJar())) {\n                new DbSpecificConfig(type).dumpUsage();\n            }\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"You can use your own database types by specifying the filespec of a .properties file with -t.\");\n            System.out.println(\"Grab one out of \" + getLoadedFromJar() + \" and modify it to suit your needs.\");\n            System.out.println();\n        }\n        System.out.println(\"Sample usage using the default database type (implied -t ora):\");\n        System.out.println(\" java -jar schemaSpy.jar -db mydb -s myschema -u devuser -p password -o output\");\n        System.out.println();\n        System.out.flush();\n    }\n\n    /**\n     * Get the value of the specified parameter.\n     * Used for properties that are common to most db's, but aren't required.\n     *\n     * @param paramName\n     * @return\n     */\n    public String getParam(String paramName) {\n        try {\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                PropertyDescriptor prop = props[i];\n                if (prop.getName().equalsIgnoreCase(paramName)) {\n                    Object result = prop.getReadMethod().invoke(this, (Object[]) null);\n                    return result == null ? null : result.toString();\n                }\n            }\n        } catch (Exception failed) {\n            failed.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * Return all of the configuration options as a List of Strings, with\n     * each parameter and its value as a separate element.\n     *\n     * @return\n     * @throws IOException\n     */\n    public List<String> asList() throws IOException {\n        List<String> params = new ArrayList<String>();\n        if (originalDbSpecificOptions != null) {\n            for (String key : originalDbSpecificOptions.keySet()) {\n                String value = originalDbSpecificOptions.get(key);\n                if (!key.startsWith(\"-\"))\n                    key = \"-\" + key;\n                params.add(key);\n                params.add(value);\n            }\n        }\n        if (isEncodeCommentsEnabled())\n            params.add(\"-ahic\");\n        if (isEvaluateAllEnabled())\n            params.add(\"-all\");\n        if (!isHtmlGenerationEnabled())\n            params.add(\"-nohtml\");\n        if (!isImpliedConstraintsEnabled())\n            params.add(\"-noimplied\");\n        if (!isLogoEnabled())\n            params.add(\"-nologo\");\n        if (isMeterEnabled())\n            params.add(\"-meter\");\n        if (!isNumRowsEnabled())\n            params.add(\"-norows\");\n        if (!isViewsEnabled())\n            params.add(\"-noviews\");\n        if (isRankDirBugEnabled())\n            params.add(\"-rankdirbug\");\n        if (isRailsEnabled())\n            params.add(\"-rails\");\n        if (isSingleSignOn())\n            params.add(\"-sso\");\n        if (isSchemaDisabled())\n            params.add(\"-noschema\");\n        String value = getDriverPath();\n        if (value != null) {\n            params.add(\"-dp\");\n            params.add(value);\n        }\n        params.add(\"-css\");\n        params.add(getCss());\n        params.add(\"-charset\");\n        params.add(getCharset());\n        params.add(\"-font\");\n        params.add(getFont());\n        params.add(\"-fontsize\");\n        params.add(String.valueOf(getFontSize()));\n        params.add(\"-t\");\n        params.add(getDbType());\n        // query to set renderer correctly\n        isHighQuality();\n        // query to set renderer correctly\n        isLowQuality();\n        // instead of -hq and/or -lq\n        params.add(\"-renderer\");\n        params.add(getRenderer());\n        value = getDescription();\n        if (value != null) {\n            params.add(\"-desc\");\n            params.add(value);\n        }\n        value = getPassword();\n        if (value != null && !isPromptForPasswordEnabled()) {\n            // note that we don't pass -pfp since child processes\n            // won't have a console\n            params.add(\"-p\");\n            params.add(value);\n        }\n        value = getCatalog();\n        if (value != null) {\n            params.add(\"-cat\");\n            params.add(value);\n        }\n        value = getSchema();\n        if (value != null) {\n            params.add(\"-s\");\n            params.add(value);\n        }\n        value = getUser();\n        if (value != null) {\n            params.add(\"-u\");\n            params.add(value);\n        }\n        value = getConnectionPropertiesFile();\n        if (value != null) {\n            params.add(\"-connprops\");\n            params.add(value);\n        } else {\n            Properties props = getConnectionProperties();\n            if (!props.isEmpty()) {\n                params.add(\"-connprops\");\n                StringBuilder buf = new StringBuilder();\n                for (Entry<Object, Object> entry : props.entrySet()) {\n                    buf.append(entry.getKey());\n                    buf.append(ESCAPED_EQUALS);\n                    buf.append(entry.getValue());\n                    buf.append(';');\n                }\n                params.add(buf.toString());\n            }\n        }\n        value = getDb();\n        if (value != null) {\n            params.add(\"-db\");\n            params.add(value);\n        }\n        value = getHost();\n        if (value != null) {\n            params.add(\"-host\");\n            params.add(value);\n        }\n        if (getPort() != null) {\n            params.add(\"-port\");\n            params.add(getPort().toString());\n        }\n        value = getServer();\n        if (value != null) {\n            params.add(\"-server\");\n            params.add(value);\n        }\n        value = getMeta();\n        if (value != null) {\n            params.add(\"-meta\");\n            params.add(value);\n        }\n        if (getGraphvizDir() != null) {\n            params.add(\"-gv\");\n            params.add(getGraphvizDir().toString());\n        }\n        params.add(\"-loglevel\");\n        params.add(getLogLevel().toString().toLowerCase());\n        params.add(\"-sqlFormatter\");\n        params.add(getSqlFormatter().getClass().getName());\n        params.add(\"-i\");\n        params.add(getTableInclusions().toString());\n        params.add(\"-I\");\n        params.add(getTableExclusions().toString());\n        params.add(\"-X\");\n        params.add(getColumnExclusions().toString());\n        params.add(\"-x\");\n        params.add(getIndirectColumnExclusions().toString());\n        params.add(\"-dbthreads\");\n        params.add(String.valueOf(getMaxDbThreads()));\n        params.add(\"-maxdet\");\n        params.add(String.valueOf(getMaxDetailedTables()));\n        params.add(\"-o\");\n        params.add(getOutputDir().toString());\n        return params;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/ConfigTest10.java",
		"test_prompt": "// ConfigTest10.java\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Config}.\n* It contains ten unit test cases for the {@link Config#isNumRowsEnabled()} method.\n*/\nclass ConfigTest10 {"
	},
	{
		"original_code": "// Config.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\n\n/**\n * Configuration of a SchemaSpy run\n *\n * @author John Currier\n */\npublic class Config {\n\n    private static Config instance;\n\n    private final List<String> options;\n\n    private Map<String, String> dbSpecificOptions;\n\n    private Map<String, String> originalDbSpecificOptions;\n\n    private boolean helpRequired;\n\n    private boolean dbHelpRequired;\n\n    private File outputDir;\n\n    private File graphvizDir;\n\n    private String dbType;\n\n    private String catalog;\n\n    private String schema;\n\n    private List<String> schemas;\n\n    private String user;\n\n    private Boolean singleSignOn;\n\n    private Boolean noSchema;\n\n    private String password;\n\n    private Boolean promptForPassword;\n\n    private String db;\n\n    private String host;\n\n    private Integer port;\n\n    private String server;\n\n    private String meta;\n\n    private Pattern tableInclusions;\n\n    private Pattern tableExclusions;\n\n    private Pattern columnExclusions;\n\n    private Pattern indirectColumnExclusions;\n\n    private String userConnectionPropertiesFile;\n\n    private Properties userConnectionProperties;\n\n    private Integer maxDbThreads;\n\n    private Integer maxDetailedTables;\n\n    private String driverPath;\n\n    private String css;\n\n    private String charset;\n\n    private String font;\n\n    private Integer fontSize;\n\n    private String description;\n\n    private Properties dbProperties;\n\n    private String dbPropertiesLoadedFrom;\n\n    private Level logLevel;\n\n    private SqlFormatter sqlFormatter;\n\n    private String sqlFormatterClass;\n\n    private Boolean generateHtml;\n\n    private Boolean includeImpliedConstraints;\n\n    private Boolean logoEnabled;\n\n    private Boolean rankDirBugEnabled;\n\n    private Boolean encodeCommentsEnabled;\n\n    private Boolean numRowsEnabled;\n\n    private Boolean viewsEnabled;\n\n    private Boolean meterEnabled;\n\n    private Boolean railsEnabled;\n\n    private Boolean evaluteAll;\n\n    private Boolean highQuality;\n\n    private Boolean lowQuality;\n\n    // used in conjunction with evaluateAll\n    private String schemaSpec;\n\n    private boolean hasOrphans = false;\n\n    private boolean hasRoutines = false;\n\n    private boolean populating = false;\n\n    private List<String> columnDetails;\n\n    public static final String DOT_CHARSET = \"UTF-8\";\n\n    private static final String ESCAPED_EQUALS = \"\\\\=\";\n\n    // match everything\n    private static final String DEFAULT_TABLE_INCLUSION = \".*\";\n\n    // match nothing\n    private static final String DEFAULT_TABLE_EXCLUSION = \"\";\n\n    // match nothing\n    private static final String DEFAULT_COLUMN_EXCLUSION = \"[^.]\";\n\n    /**\n     * Default constructor. Intended for when you want to inject properties\n     * independently (i.e. not from a command line interface).\n     */\n    public Config() {\n        if (instance == null)\n            setInstance(this);\n        options = new ArrayList<String>();\n    }\n\n    /**\n     * Construct a configuration from an array of options (e.g. from a command\n     * line interface).\n     *\n     * @param options\n     */\n    public Config(String[] argv) {\n        setInstance(this);\n        options = fixupArgs(Arrays.asList(argv));\n        helpRequired = options.remove(\"-?\") || options.remove(\"/?\") || options.remove(\"?\") || options.remove(\"-h\") || options.remove(\"-help\") || options.remove(\"--help\");\n        dbHelpRequired = options.remove(\"-dbHelp\") || options.remove(\"-dbhelp\");\n    }\n\n    public static Config getInstance() {\n        if (instance == null)\n            instance = new Config();\n        return instance;\n    }\n\n    /**\n     * Sets the global instance.\n     *\n     * Useful for things like selecting a specific configuration in a UI.\n     *\n     * @param config\n     */\n    public static void setInstance(Config config) {\n        instance = config;\n    }\n\n    public void setHtmlGenerationEnabled(boolean generateHtml) {\n        this.generateHtml = generateHtml;\n    }\n\n    public boolean isHtmlGenerationEnabled() {\n        if (generateHtml == null)\n            generateHtml = !options.remove(\"-nohtml\");\n        return generateHtml;\n    }\n\n    public void setImpliedConstraintsEnabled(boolean includeImpliedConstraints) {\n        this.includeImpliedConstraints = includeImpliedConstraints;\n    }\n\n    public boolean isImpliedConstraintsEnabled() {\n        if (includeImpliedConstraints == null)\n            includeImpliedConstraints = !options.remove(\"-noimplied\");\n        return includeImpliedConstraints;\n    }\n\n    public void setOutputDir(String outputDirName) {\n        if (outputDirName.endsWith(\"\\\"\"))\n            outputDirName = outputDirName.substring(0, outputDirName.length() - 1);\n        setOutputDir(new File(outputDirName));\n    }\n\n    public void setOutputDir(File outputDir) {\n        this.outputDir = outputDir;\n    }\n\n    public File getOutputDir() {\n        if (outputDir == null) {\n            setOutputDir(pullRequiredParam(\"-o\"));\n        }\n        return outputDir;\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(String graphvizDir) {\n        if (graphvizDir.endsWith(\"\\\"\"))\n            graphvizDir = graphvizDir.substring(0, graphvizDir.length() - 1);\n        setGraphvizDir(new File(graphvizDir));\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(File graphvizDir) {\n        this.graphvizDir = graphvizDir;\n    }\n\n    /**\n     * Return the path to Graphviz (used to find the dot executable to run to\n     * generate ER diagrams).<p/>\n     *\n     * Returns {@link #getDefaultGraphvizPath()} if a specific Graphviz path\n     * was not specified.\n     *\n     * @return\n     */\n    public File getGraphvizDir() {\n        if (graphvizDir == null) {\n            String gv = pullParam(\"-gv\");\n            if (gv != null) {\n                setGraphvizDir(gv);\n            } else {\n                // expect to find Graphviz's bin directory on the PATH\n            }\n        }\n        return graphvizDir;\n    }\n\n    /**\n     * Meta files are XML-based files that provide additional metadata\n     * about the schema being evaluated.<p>\n     * <code>meta</code> is either the name of an individual XML file or\n     * the directory that contains meta files.<p>\n     * If a directory is specified then it is expected to contain files\n     * matching the pattern <code>[schema].meta.xml</code>.\n     * For databases that don't have schema substitute database for schema.\n     * @param meta\n     */\n    public void setMeta(String meta) {\n        this.meta = meta;\n    }\n\n    public String getMeta() {\n        if (meta == null)\n            meta = pullParam(\"-meta\");\n        return meta;\n    }\n\n    public void setDbType(String dbType) {\n        this.dbType = dbType;\n    }\n\n    public String getDbType() {\n        if (dbType == null) {\n            dbType = pullParam(\"-t\");\n            if (dbType == null)\n                dbType = \"ora\";\n        }\n        return dbType;\n    }\n\n    public void setDb(String db) {\n        this.db = db;\n    }\n\n    public String getDb() {\n        if (db == null)\n            db = pullParam(\"-db\");\n        return db;\n    }\n\n    public void setCatalog(String catalog) {\n        this.catalog = catalog;\n    }\n\n    public String getCatalog() {\n        if (catalog == null)\n            catalog = pullParam(\"-cat\");\n        return catalog;\n    }\n\n    public void setSchema(String schema) {\n        this.schema = schema;\n    }\n\n    public String getSchema() {\n        if (schema == null)\n            schema = pullParam(\"-s\");\n        return schema;\n    }\n\n    /**\n     * Some databases types (e.g. older versions of Informix) don't really\n     * have the concept of a schema but still return true from\n     * {@link DatabaseMetaData#supportsSchemasInTableDefinitions()}.\n     * This option lets you ignore that and treat all the tables\n     * as if they were in one flat namespace.\n     */\n    public boolean isSchemaDisabled() {\n        if (noSchema == null)\n            noSchema = options.remove(\"-noschema\");\n        return noSchema;\n    }\n\n    public void setHost(String host) {\n        this.host = host;\n    }\n\n    public String getHost() {\n        if (host == null)\n            host = pullParam(\"-host\");\n        return host;\n    }\n\n    public void setPort(Integer port) {\n        this.port = port;\n    }\n\n    public Integer getPort() {\n        if (port == null)\n            try {\n                port = Integer.valueOf(pullParam(\"-port\"));\n            } catch (Exception notSpecified) {\n            }\n        return port;\n    }\n\n    public void setServer(String server) {\n        this.server = server;\n    }\n\n    public String getServer() {\n        if (server == null) {\n            server = pullParam(\"-server\");\n        }\n        return server;\n    }\n\n    public void setUser(String user) {\n        this.user = user;\n    }\n\n    /**\n     * User used to connect to the database.\n     * Required unless single sign-on is enabled\n     * (see {@link #setSingleSignOn(boolean)}).\n     * @return\n     */\n    public String getUser() {\n        if (user == null) {\n            if (!isSingleSignOn())\n                user = pullRequiredParam(\"-u\");\n            else\n                user = pullParam(\"-u\");\n        }\n        return user;\n    }\n\n    /**\n     * By default a \"user\" (as specified with -u) is required.\n     * This option allows disabling of that requirement for\n     * single sign-on environments.\n     *\n     * @param enabled defaults to <code>false</code>\n     */\n    public void setSingleSignOn(boolean enabled) {\n        singleSignOn = enabled;\n    }\n\n    /**\n     * @see #setSingleSignOn(boolean)\n     */\n    public boolean isSingleSignOn() {\n        if (singleSignOn == null)\n            singleSignOn = options.remove(\"-sso\");\n        return singleSignOn;\n    }\n\n    /**\n     * Set the password used to connect to the database.\n     * @param password\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * @see #setPassword(String)\n     * @return\n     */\n    public String getPassword() {\n        if (password == null)\n            password = pullParam(\"-p\");\n        if (password == null && isPromptForPasswordEnabled())\n            password = new String(PasswordReader.getInstance().readPassword(\"Password: \"));\n        if (password == null) {\n            // if -pfp is enabled when analyzing multiple schemas then\n            // we don't want to send the password on the command line,\n            // so see if it was passed in the environment (not ideal, but safer)\n            password = System.getenv(\"schemaspy.pw\");\n        }\n        return password;\n    }\n\n    /**\n     * Set to <code>true</code> to prompt for the password\n     * @param promptForPassword\n     */\n    public void setPromptForPasswordEnabled(boolean promptForPassword) {\n        this.promptForPassword = promptForPassword;\n    }\n\n    /**\n     * @see #setPromptForPasswordEnabled(boolean)\n     * @return\n     */\n    public boolean isPromptForPasswordEnabled() {\n        if (promptForPassword == null) {\n            promptForPassword = options.remove(\"-pfp\");\n        }\n        return promptForPassword;\n    }\n\n    public void setMaxDetailedTabled(int maxDetailedTables) {\n        this.maxDetailedTables = new Integer(maxDetailedTables);\n    }\n\n    public int getMaxDetailedTables() {\n        if (maxDetailedTables == null) {\n            // default\n            int max = 300;\n            try {\n                max = Integer.parseInt(pullParam(\"-maxdet\"));\n            } catch (Exception notSpecified) {\n            }\n            maxDetailedTables = new Integer(max);\n        }\n        return maxDetailedTables.intValue();\n    }\n\n    public String getConnectionPropertiesFile() {\n        return userConnectionPropertiesFile;\n    }\n\n    /**\n     * Properties from this file (in key=value pair format) are passed to the\n     * database connection.<br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.\n     * @param propertiesFilename\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public void setConnectionPropertiesFile(String propertiesFilename) throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null)\n            userConnectionProperties = new Properties();\n        userConnectionProperties.load(new FileInputStream(propertiesFilename));\n        userConnectionPropertiesFile = propertiesFilename;\n    }\n\n    /**\n     * Returns a {@link Properties} populated either from the properties file specified\n     * by {@link #setConnectionPropertiesFile(String)}, the properties specified by\n     * {@link #setConnectionProperties(String)} or not populated.\n     * @return\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public Properties getConnectionProperties() throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null) {\n            String props = pullParam(\"-connprops\");\n            if (props != null) {\n                if (props.indexOf(ESCAPED_EQUALS) != -1) {\n                    setConnectionProperties(props);\n                } else {\n                    setConnectionPropertiesFile(props);\n                }\n            } else {\n                userConnectionProperties = new Properties();\n            }\n        }\n        return userConnectionProperties;\n    }\n\n    /**\n     * Specifies connection properties to use in the format:\n     * <code>key1\\=value1;key2\\=value2</code><br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.<p>\n     * This is an alternative form of passing connection properties than by file\n     * (see {@link #setConnectionPropertiesFile(String)})\n     *\n     * @param properties\n     */\n    public void setConnectionProperties(String properties) {\n        userConnectionProperties = new Properties();\n        StringTokenizer tokenizer = new StringTokenizer(properties, \";\");\n        while (tokenizer.hasMoreElements()) {\n            String pair = tokenizer.nextToken();\n            int index = pair.indexOf(ESCAPED_EQUALS);\n            if (index != -1) {\n                String key = pair.substring(0, index);\n                String value = pair.substring(index + ESCAPED_EQUALS.length());\n                userConnectionProperties.put(key, value);\n            }\n        }\n    }\n\n    public void setDriverPath(String driverPath) {\n        this.driverPath = driverPath;\n    }\n\n    public String getDriverPath() {\n        if (driverPath == null)\n            driverPath = pullParam(\"-dp\");\n        // was previously -cp:\n        if (driverPath == null)\n            driverPath = pullParam(\"-cp\");\n        return driverPath;\n    }\n\n    /**\n     * The filename of the cascading style sheet to use.\n     * Note that this file is parsed and used to determine characteristics\n     * of the generated diagrams, so it must contain specific settings that\n     * are documented within schemaSpy.css.<p>\n     *\n     * Defaults to <code>\"schemaSpy.css\"</code>.\n     *\n     * @param css\n     */\n    public void setCss(String css) {\n        this.css = css;\n    }\n\n    public String getCss() {\n        if (css == null) {\n            css = pullParam(\"-css\");\n            if (css == null)\n                css = \"schemaSpy.css\";\n        }\n        return css;\n    }\n\n    /**\n     * The font to use within diagrams.  Modify the .css to specify HTML fonts.\n     *\n     * @param font\n     */\n    public void setFont(String font) {\n        this.font = font;\n    }\n\n    /**\n     * @see #setFont(String)\n     */\n    public String getFont() {\n        if (font == null) {\n            font = pullParam(\"-font\");\n            if (font == null)\n                font = \"Helvetica\";\n        }\n        return font;\n    }\n\n    /**\n     * The font size to use within diagrams.  This is the size of the font used for\n     * 'large' (e.g. not 'compact') diagrams.<p>\n     *\n     * Modify the .css to specify HTML font sizes.<p>\n     *\n     * Defaults to 11.\n     *\n     * @param fontSize\n     */\n    public void setFontSize(int fontSize) {\n        this.fontSize = new Integer(fontSize);\n    }\n\n    /**\n     * @see #setFontSize(int)\n     * @return\n     */\n    public int getFontSize() {\n        if (fontSize == null) {\n            // default\n            int size = 11;\n            try {\n                size = Integer.parseInt(pullParam(\"-fontsize\"));\n            } catch (Exception notSpecified) {\n            }\n            fontSize = new Integer(size);\n        }\n        return fontSize.intValue();\n    }\n\n    /**\n     * The character set to use within HTML pages (defaults to <code>\"ISO-8859-1\"</code>).\n     *\n     * @param charset\n     */\n    public void setCharset(String charset) {\n        this.charset = charset;\n    }\n\n    /**\n     * @see #setCharset(String)\n     */\n    public String getCharset() {\n        if (charset == null) {\n            charset = pullParam(\"-charset\");\n            if (charset == null)\n                charset = \"ISO-8859-1\";\n        }\n        return charset;\n    }\n\n    /**\n     * Description of schema that gets display on main pages.\n     *\n     * @param description\n     */\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    /**\n     * @see #setDescription(String)\n     */\n    public String getDescription() {\n        if (description == null)\n            description = pullParam(\"-desc\");\n        return description;\n    }\n\n    /**\n     * Maximum number of threads to use when querying database metadata information.\n     *\n     * @param maxDbThreads\n     */\n    public void setMaxDbThreads(int maxDbThreads) {\n        this.maxDbThreads = new Integer(maxDbThreads);\n    }\n\n    /**\n     * @see #setMaxDbThreads(int)\n     * @throws InvalidConfigurationException if unable to load properties\n     */\n    public int getMaxDbThreads() throws InvalidConfigurationException {\n        if (maxDbThreads == null) {\n            Properties properties;\n            try {\n                properties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(\"Failed to load properties for \" + getDbType() + \": \" + exc).setParamName(\"-type\");\n            }\n            // not scientifically derived\n            final int defaultMax = 15;\n            int max = defaultMax;\n            String threads = properties.getProperty(\"dbThreads\");\n            if (threads == null)\n                threads = properties.getProperty(\"dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            threads = pullParam(\"-dbThreads\");\n            if (threads == null)\n                threads = pullParam(\"-dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            if (max < 0)\n                max = defaultMax;\n            else if (max == 0)\n                max = 1;\n            maxDbThreads = new Integer(max);\n        }\n        return maxDbThreads.intValue();\n    }\n\n    public boolean isLogoEnabled() {\n        if (logoEnabled == null)\n            logoEnabled = !options.remove(\"-nologo\");\n        return logoEnabled;\n    }\n\n    /**\n     * Don't use this unless absolutely necessary as it screws up the layout\n     *\n     * @param enabled\n     */\n    public void setRankDirBugEnabled(boolean enabled) {\n        rankDirBugEnabled = enabled;\n    }\n\n    /**\n     * @see #setRankDirBugEnabled(boolean)\n     */\n    public boolean isRankDirBugEnabled() {\n        if (rankDirBugEnabled == null)\n            rankDirBugEnabled = options.remove(\"-rankdirbug\");\n        return rankDirBugEnabled;\n    }\n\n    /**\n     * Look for Ruby on Rails-based naming conventions in\n     * relationships between logical foreign keys and primary keys.<p>\n     *\n     * Basically all tables have a primary key named <code>ID</code>.\n     * All tables are named plural names.\n     * The columns that logically reference that <code>ID</code> are the singular\n     * form of the table name suffixed with <code>_ID</code>.<p>\n     *\n     * @param enabled\n     */\n    public void setRailsEnabled(boolean enabled) {\n        railsEnabled = enabled;\n    }\n\n    /**\n     * @see #setRailsEnabled(boolean)\n     *\n     * @return\n     */\n    public boolean isRailsEnabled() {\n        if (railsEnabled == null)\n            railsEnabled = options.remove(\"-rails\");\n        return railsEnabled;\n    }\n\n    /**\n     * Allow Html In Comments - encode them unless otherwise specified\n     */\n    public void setEncodeCommentsEnabled(boolean enabled) {\n        encodeCommentsEnabled = enabled;\n    }\n\n    /**\n     * @see #setEncodeCommentsEnabled(boolean)\n     */\n    public boolean isEncodeCommentsEnabled() {\n        if (encodeCommentsEnabled == null)\n            encodeCommentsEnabled = !options.remove(\"-ahic\");\n        return encodeCommentsEnabled;\n    }\n\n    /**\n     * If enabled we'll attempt to query/render the number of rows that\n     * each table contains.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setNumRowsEnabled(boolean enabled) {\n        numRowsEnabled = enabled;\n    }\n\n    /**\n     * @see #setNumRowsEnabled(boolean)\n     * @return\n     */\n    public boolean isNumRowsEnabled() {\n        if (numRowsEnabled == null)\n            numRowsEnabled = !options.remove(\"-norows\");\n        return numRowsEnabled;\n    }\n\n    /**\n     * If enabled we'll include views in the analysis.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setViewsEnabled(boolean enabled) {\n        viewsEnabled = enabled;\n    }\n\n    /**\n     * @see #setViewsEnabled(boolean)\n     * @return\n     */\n    public boolean isViewsEnabled() {\n        if (viewsEnabled == null)\n            viewsEnabled = !options.remove(\"-noviews\");\n        return viewsEnabled;\n    }\n\n    /**\n     * Returns <code>true</code> if metering should be embedded in\n     * the generated pages.<p/>\n     * Defaults to <code>false</code> (disabled).\n     * @return\n     */\n    public boolean isMeterEnabled() {\n        if (meterEnabled == null)\n            meterEnabled = options.remove(\"-meter\");\n        return meterEnabled;\n    }\n\n    /**\n     * Set the columns to exclude from all relationship diagrams.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setColumnExclusions(String columnExclusions) {\n        this.columnExclusions = Pattern.compile(columnExclusions);\n    }\n\n    /**\n     * See {@link #setColumnExclusions(String)}\n     * @return\n     */\n    public Pattern getColumnExclusions() {\n        if (columnExclusions == null) {\n            String strExclusions = pullParam(\"-X\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.columnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            columnExclusions = Pattern.compile(strExclusions);\n        }\n        return columnExclusions;\n    }\n\n    /**\n     * Set the columns to exclude from relationship diagrams where the specified\n     * columns aren't directly referenced by the focal table.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setIndirectColumnExclusions(String fullColumnExclusions) {\n        indirectColumnExclusions = Pattern.compile(fullColumnExclusions);\n    }\n\n    /**\n     * @see #setIndirectColumnExclusions(String)\n     *\n     * @return\n     */\n    public Pattern getIndirectColumnExclusions() {\n        if (indirectColumnExclusions == null) {\n            String strExclusions = pullParam(\"-x\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.indirectColumnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            indirectColumnExclusions = Pattern.compile(strExclusions);\n        }\n        return indirectColumnExclusions;\n    }\n\n    /**\n     * Set the tables to include as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableInclusions(String tableInclusions) {\n        this.tableInclusions = Pattern.compile(tableInclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to include in the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableInclusions() {\n        if (tableInclusions == null) {\n            String strInclusions = pullParam(\"-i\");\n            if (strInclusions == null)\n                strInclusions = System.getenv(\"schemaspy.tableInclusions\");\n            if (strInclusions == null)\n                strInclusions = DEFAULT_TABLE_INCLUSION;\n            try {\n                tableInclusions = Pattern.compile(strInclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-i\");\n            }\n        }\n        return tableInclusions;\n    }\n\n    /**\n     * Set the tables to exclude as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableExclusions(String tableExclusions) {\n        this.tableExclusions = Pattern.compile(tableExclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to exclude from the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableExclusions() {\n        if (tableExclusions == null) {\n            String strExclusions = pullParam(\"-I\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.tableExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_TABLE_EXCLUSION;\n            try {\n                tableExclusions = Pattern.compile(strExclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-I\");\n            }\n        }\n        return tableExclusions;\n    }\n\n    /**\n     * @return\n     */\n    public List<String> getSchemas() {\n        if (schemas == null) {\n            String tmp = pullParam(\"-schemas\");\n            if (tmp == null)\n                tmp = pullParam(\"-schemata\");\n            if (tmp != null) {\n                schemas = new ArrayList<String>();\n                for (String name : tmp.split(\"[\\\\s,'\\\"]\")) {\n                    if (name.length() > 0)\n                        schemas.add(name);\n                }\n                if (schemas.isEmpty())\n                    schemas = null;\n            }\n        }\n        return schemas;\n    }\n\n    /**\n     * Set the name of the {@link SqlFormatter SQL formatter} class to use to\n     * format SQL into HTML.<p/>\n     * The implementation of the class must be made available to the class\n     * loader, typically by specifying the path to its jar with <em>-dp</em>\n     * ({@link #setDriverPath(String)}).\n     */\n    public void setSqlFormatter(String formatterClassName) {\n        sqlFormatterClass = formatterClassName;\n        sqlFormatter = null;\n    }\n\n    /**\n     * Set the {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.\n     */\n    public void setSqlFormatter(SqlFormatter sqlFormatter) {\n        this.sqlFormatter = sqlFormatter;\n        if (sqlFormatter != null)\n            sqlFormatterClass = sqlFormatter.getClass().getName();\n    }\n\n    /**\n     * Returns an implementation of {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.  The default implementation is {@link DefaultSqlFormatter}.\n     *\n     * @return\n     * @throws InvalidConfigurationException if unable to instantiate an instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SqlFormatter getSqlFormatter() throws InvalidConfigurationException {\n        if (sqlFormatter == null) {\n            if (sqlFormatterClass == null) {\n                sqlFormatterClass = pullParam(\"-sqlFormatter\");\n                if (sqlFormatterClass == null)\n                    sqlFormatterClass = DefaultSqlFormatter.class.getName();\n            }\n            try {\n                Class<SqlFormatter> clazz = (Class<SqlFormatter>) Class.forName(sqlFormatterClass);\n                sqlFormatter = clazz.newInstance();\n            } catch (Exception exc) {\n                throw new InvalidConfigurationException(\"Failed to initialize instance of SQL formatter: \", exc).setParamName(\"-sqlFormatter\");\n            }\n        }\n        return sqlFormatter;\n    }\n\n    /**\n     * Set the details to show on the columns page, where \"details\" are\n     * comma and/or space separated.\n     *\n     * Valid values:\n     * <ul>\n     * <li>id</li>\n     * <li>table</li>\n     * <li>column</li>\n     * <li>type</li>\n     * <li>size</li>\n     * <li>nulls</li>\n     * <li>auto</li>\n     * <li>default</li>\n     * <li>children</li>\n     * <li>parents</li>\n     * </ul>\n     *\n     * The default details are <code>\"table column type size nulls auto default\"</code>.\n     * Note that \"column\" is the initially displayed detail and must be included.\n     *\n     * @param columnDetails\n     */\n    public void setColumnDetails(String columnDetails) {\n        this.columnDetails = new ArrayList<String>();\n        if (columnDetails == null || columnDetails.length() == 0) {\n            // not specified, so use defaults\n            columnDetails = \"id table column type size nulls auto default\";\n        }\n        for (String detail : columnDetails.split(\"[\\\\s,'\\\"]\")) {\n            if (detail.length() > 0) {\n                this.columnDetails.add(detail.toLowerCase());\n            }\n        }\n        if (!this.columnDetails.contains(\"column\"))\n            throw new InvalidConfigurationException(\"'column' is a required column detail\");\n    }\n\n    public void setColumnDetails(List<String> columnDetails) {\n        String details = columnDetails == null ? \"[]\" : columnDetails.toString();\n        setColumnDetails(details.substring(1, details.length() - 1));\n    }\n\n    public List<String> getColumnDetails() {\n        if (columnDetails == null) {\n            setColumnDetails(pullParam(\"-columndetails\"));\n        }\n        return columnDetails;\n    }\n\n    public void setEvaluateAllEnabled(boolean enabled) {\n        evaluteAll = enabled;\n    }\n\n    public boolean isEvaluateAllEnabled() {\n        if (evaluteAll == null)\n            evaluteAll = options.remove(\"-all\");\n        return evaluteAll;\n    }\n\n    /**\n     * Returns true if we're evaluating a bunch of schemas in one go and\n     * at this point we're evaluating a specific schema.\n     *\n     * @return boolean\n     */\n    public boolean isOneOfMultipleSchemas() {\n        // set by MultipleSchemaAnalyzer\n        return Boolean.getBoolean(\"oneofmultipleschemas\");\n    }\n\n    /**\n     * When -all (evaluateAll) is specified then this is the regular\n     * expression that determines which schemas to evaluate.\n     *\n     * @param schemaSpec\n     */\n    public void setSchemaSpec(String schemaSpec) {\n        this.schemaSpec = schemaSpec;\n    }\n\n    public String getSchemaSpec() {\n        if (schemaSpec == null)\n            schemaSpec = pullParam(\"-schemaSpec\");\n        return schemaSpec;\n    }\n\n    /**\n     * Set the renderer to use for the -Tpng[:renderer[:formatter]] dot option as specified\n     * at <a href='http://www.graphviz.org/doc/info/command.html'>\n     * http://www.graphviz.org/doc/info/command.html</a>.<p>\n     * Note that the leading \":\" is required while :formatter is optional.<p>\n     * The default renderer is typically GD.<p>\n     * Note that using {@link #setHighQuality(boolean)} is the preferred approach\n     * over using this method.\n     */\n    public void setRenderer(String renderer) {\n        Dot.getInstance().setRenderer(renderer);\n    }\n\n    /**\n     * @see #setRenderer(String)\n     * @return\n     */\n    public String getRenderer() {\n        String renderer = pullParam(\"-renderer\");\n        if (renderer != null)\n            setRenderer(renderer);\n        return Dot.getInstance().getRenderer();\n    }\n\n    /**\n     * If <code>false</code> then generate output of \"lower quality\"\n     * than the default.\n     * Note that the default is intended to be \"higher quality\",\n     * but various installations of Graphviz may have have different abilities.\n     * That is, some might not have the \"lower quality\" libraries and others might\n     * not have the \"higher quality\" libraries.<p>\n     * Higher quality output takes longer to generate and results in significantly\n     * larger image files (which take longer to download / display), but it generally\n     * looks better.\n     */\n    public void setHighQuality(boolean highQuality) {\n        this.highQuality = highQuality;\n        lowQuality = !highQuality;\n        Dot.getInstance().setHighQuality(highQuality);\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isHighQuality() {\n        if (highQuality == null) {\n            highQuality = options.remove(\"-hq\");\n            if (highQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(highQuality);\n            }\n        }\n        highQuality = Dot.getInstance().isHighQuality();\n        return highQuality;\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isLowQuality() {\n        if (lowQuality == null) {\n            lowQuality = options.remove(\"-lq\");\n            if (lowQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(!lowQuality);\n            }\n        }\n        lowQuality = !Dot.getInstance().isHighQuality();\n        return lowQuality;\n    }\n\n    /**\n     * Set the level of logging to perform.<p/>\n     * The levels in descending order are:\n     * <ul>\n     *  <li><code>severe</code> (highest - least detail)\n     *  <li><code>warning</code> (default)\n     *  <li><code>info</code>\n     *  <li><code>config</code>\n     *  <li><code>fine</code>\n     *  <li><code>finer</code>\n     *  <li><code>finest</code>  (lowest - most detail)\n     * </ul>\n     *\n     * @param logLevel\n     */\n    public void setLogLevel(String logLevel) {\n        if (logLevel == null) {\n            this.logLevel = Level.WARNING;\n            return;\n        }\n        Map<String, Level> levels = new LinkedHashMap<String, Level>();\n        levels.put(\"severe\", Level.SEVERE);\n        levels.put(\"warning\", Level.WARNING);\n        levels.put(\"info\", Level.INFO);\n        levels.put(\"config\", Level.CONFIG);\n        levels.put(\"fine\", Level.FINE);\n        levels.put(\"finer\", Level.FINER);\n        levels.put(\"finest\", Level.FINEST);\n        this.logLevel = levels.get(logLevel.toLowerCase());\n        if (this.logLevel == null) {\n            throw new InvalidConfigurationException(\"Invalid logLevel: '\" + logLevel + \"'. Must be one of: \" + levels.keySet());\n        }\n    }\n\n    /**\n     * Returns the level of logging to perform.\n     * See {@link #setLogLevel(String)}.\n     *\n     * @return\n     */\n    public Level getLogLevel() {\n        if (logLevel == null) {\n            setLogLevel(pullParam(\"-loglevel\"));\n        }\n        return logLevel;\n    }\n\n    /**\n     * Returns <code>true</code> if the options indicate that the user wants\n     * to see some help information.\n     *\n     * @return\n     */\n    public boolean isHelpRequired() {\n        return helpRequired;\n    }\n\n    public boolean isDbHelpRequired() {\n        return dbHelpRequired;\n    }\n\n    /**\n     * Returns the jar that we were loaded from\n     *\n     * @return\n     */\n    public static String getLoadedFromJar() {\n        String classpath = System.getProperty(\"java.class.path\");\n        return new StringTokenizer(classpath, File.pathSeparator).nextToken();\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasOrphans(boolean hasOrphans) {\n        this.hasOrphans = hasOrphans;\n    }\n\n    /**\n     * @see #setHasOrphans()\n     *\n     * @return\n     */\n    public boolean hasOrphans() {\n        return hasOrphans;\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasRoutines(boolean hasRoutines) {\n        this.hasRoutines = hasRoutines;\n    }\n\n    /**\n     * @see #setHasRoutines()\n     *\n     * @return\n     */\n    public boolean hasRoutines() {\n        return hasRoutines;\n    }\n\n    /**\n     * Returns the database properties to use.\n     * These should be determined by calling {@link #determineDbProperties(String)}.\n     * @return\n     * @throws InvalidConfigurationException\n     */\n    public Properties getDbProperties() throws InvalidConfigurationException {\n        if (dbProperties == null) {\n            try {\n                dbProperties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(exc);\n            }\n        }\n        return dbProperties;\n    }\n\n    /**\n     * Determines the database properties associated with the specified type.\n     * A call to {@link #setDbProperties(Properties)} is expected after determining\n     * the complete set of properties.\n     *\n     * @param type\n     * @return\n     * @throws IOException\n     * @throws InvalidConfigurationException if db properties are incorrectly formed\n     */\n    public Properties determineDbProperties(String type) throws IOException, InvalidConfigurationException {\n        ResourceBundle bundle = null;\n        try {\n            File propertiesFile = new File(type);\n            bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n            dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n        } catch (FileNotFoundException notFoundOnFilesystemWithoutExtension) {\n            try {\n                File propertiesFile = new File(type + \".properties\");\n                bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n                dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n            } catch (FileNotFoundException notFoundOnFilesystemWithExtensionTackedOn) {\n                try {\n                    bundle = ResourceBundle.getBundle(type);\n                    dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]\" + File.separator + type + \".properties\";\n                } catch (Exception notInJarWithoutPath) {\n                    try {\n                        String path = TableOrderer.class.getPackage().getName() + \".dbTypes.\" + type;\n                        path = path.replace('.', '/');\n                        bundle = ResourceBundle.getBundle(path);\n                        dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]/\" + path + \".properties\";\n                    } catch (Exception notInJar) {\n                        notInJar.printStackTrace();\n                        notFoundOnFilesystemWithExtensionTackedOn.printStackTrace();\n                        throw notFoundOnFilesystemWithoutExtension;\n                    }\n                }\n            }\n        }\n        Properties props = asProperties(bundle);\n        bundle = null;\n        // keep original thru recursion\n        String saveLoadedFrom = dbPropertiesLoadedFrom;\n        // bring in key/values pointed to by the include directive\n        // example: include.1=mysql::selectRowCountSql\n        for (int i = 1; true; ++i) {\n            String include = (String) props.remove(\"include.\" + i);\n            if (include == null)\n                break;\n            int separator = include.indexOf(\"::\");\n            if (separator == -1)\n                throw new InvalidConfigurationException(\"include directive in \" + dbPropertiesLoadedFrom + \" must have '::' between dbType and key\");\n            String refdType = include.substring(0, separator).trim();\n            String refdKey = include.substring(separator + 2).trim();\n            // recursively resolve the ref'd properties file and the ref'd key\n            Properties refdProps = determineDbProperties(refdType);\n            props.put(refdKey, refdProps.getProperty(refdKey));\n        }\n        // bring in base properties files pointed to by the extends directive\n        String baseDbType = (String) props.remove(\"extends\");\n        if (baseDbType != null) {\n            baseDbType = baseDbType.trim();\n            Properties baseProps = determineDbProperties(baseDbType);\n            // overlay our properties on top of the base's\n            baseProps.putAll(props);\n            props = baseProps;\n        }\n        // done with this level of recursion...restore original\n        dbPropertiesLoadedFrom = saveLoadedFrom;\n        // this won't be correct until the final recursion exits\n        dbProperties = props;\n        return props;\n    }\n\n    protected String getDbPropertiesLoadedFrom() throws IOException {\n        if (dbPropertiesLoadedFrom == null)\n            determineDbProperties(getDbType());\n        return dbPropertiesLoadedFrom;\n    }\n\n    public List<String> getRemainingParameters() {\n        try {\n            populate();\n        } catch (IllegalArgumentException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (IllegalAccessException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (InvocationTargetException exc) {\n            if (exc.getCause() instanceof InvalidConfigurationException)\n                throw (InvalidConfigurationException) exc.getCause();\n            throw new InvalidConfigurationException(exc.getCause());\n        } catch (IntrospectionException exc) {\n            throw new InvalidConfigurationException(exc);\n        }\n        return options;\n    }\n\n    /**\n     * Options that are specific to a type of database.  E.g. things like <code>host</code>,\n     * <code>port</code> or <code>db</code>, but <b>don't</b> have a setter in this class.\n     *\n     * @param dbSpecificOptions\n     */\n    public void setDbSpecificOptions(Map<String, String> dbSpecificOptions) {\n        this.dbSpecificOptions = dbSpecificOptions;\n        originalDbSpecificOptions = new HashMap<String, String>(dbSpecificOptions);\n    }\n\n    public Map<String, String> getDbSpecificOptions() {\n        if (dbSpecificOptions == null)\n            dbSpecificOptions = new HashMap<String, String>();\n        return dbSpecificOptions;\n    }\n\n    /**\n     * Returns a {@link Properties} populated with the contents of <code>bundle</code>\n     *\n     * @param bundle ResourceBundle\n     * @return Properties\n     */\n    public static Properties asProperties(ResourceBundle bundle) {\n        Properties props = new Properties();\n        Enumeration<String> iter = bundle.getKeys();\n        while (iter.hasMoreElements()) {\n            String key = iter.nextElement();\n            props.put(key, bundle.getObject(key));\n        }\n        return props;\n    }\n\n    /**\n     * 'Pull' the specified parameter from the collection of options. Returns\n     * null if the parameter isn't in the list and removes it if it is.\n     *\n     * @param paramId\n     * @return\n     */\n    private String pullParam(String paramId) {\n        return pullParam(paramId, false, false);\n    }\n\n    private String pullRequiredParam(String paramId) {\n        return pullParam(paramId, true, false);\n    }\n\n    /**\n     * @param paramId\n     * @param required\n     * @param dbTypeSpecific\n     * @return\n     * @throws MissingRequiredParameterException\n     */\n    private String pullParam(String paramId, boolean required, boolean dbTypeSpecific) throws MissingRequiredParameterException {\n        int paramIndex = options.indexOf(paramId);\n        if (paramIndex < 0) {\n            if (required)\n                throw new MissingRequiredParameterException(paramId, dbTypeSpecific);\n            return null;\n        }\n        options.remove(paramIndex);\n        String param = options.get(paramIndex).toString();\n        options.remove(paramIndex);\n        return param;\n    }\n\n    /**\n     * Thrown to indicate that a required parameter is missing\n     */\n    public static class MissingRequiredParameterException extends RuntimeException {\n\n        private static final long serialVersionUID = 1L;\n\n        private final boolean dbTypeSpecific;\n\n        public MissingRequiredParameterException(String paramId, boolean dbTypeSpecific) {\n            this(paramId, null, dbTypeSpecific);\n        }\n\n        public MissingRequiredParameterException(String paramId, String description, boolean dbTypeSpecific) {\n            super(\"Required parameter '\" + paramId + \"' \" + (description == null ? \"\" : \"(\" + description + \") \") + \"was not specified.\" + (dbTypeSpecific ? \"  It is required for this database type.\" : \"\"));\n            this.dbTypeSpecific = dbTypeSpecific;\n        }\n\n        public boolean isDbTypeSpecific() {\n            return dbTypeSpecific;\n        }\n    }\n\n    /**\n     * Allow an equal sign in args...like \"-o=foo.bar\". Useful for things like\n     * Ant and Maven.\n     *\n     * @param args\n     *            List\n     * @return List\n     */\n    protected List<String> fixupArgs(List<String> args) {\n        List<String> expandedArgs = new ArrayList<String>();\n        for (String arg : args) {\n            int indexOfEquals = arg.indexOf('=');\n            if (indexOfEquals != -1 && indexOfEquals - 1 != arg.indexOf(ESCAPED_EQUALS)) {\n                expandedArgs.add(arg.substring(0, indexOfEquals));\n                expandedArgs.add(arg.substring(indexOfEquals + 1));\n            } else {\n                expandedArgs.add(arg);\n            }\n        }\n        // some OSes/JVMs do filename expansion with runtime.exec() and some don't,\n        // so MultipleSchemaAnalyzer has to surround params with double quotes...\n        // strip them here for the OSes/JVMs that don't do anything with the params\n        List<String> unquotedArgs = new ArrayList<String>();\n        for (String arg : expandedArgs) {\n            if (// \".*\" becomes .*\n            arg.startsWith(\"\\\"\") && arg.endsWith(\"\\\"\"))\n                arg = arg.substring(1, arg.length() - 1);\n            unquotedArgs.add(arg);\n        }\n        return unquotedArgs;\n    }\n\n    /**\n     * Call all the getters to populate all the lazy initialized stuff.\n     *\n     * @throws InvocationTargetException\n     * @throws IllegalAccessException\n     * @throws IllegalArgumentException\n     * @throws IntrospectionException\n     */\n    private void populate() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IntrospectionException {\n        if (!populating) {\n            // prevent recursion\n            populating = true;\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                Method readMethod = props[i].getReadMethod();\n                if (readMethod != null)\n                    readMethod.invoke(this, (Object[]) null);\n            }\n            populating = false;\n        }\n    }\n\n    public static Set<String> getBuiltInDatabaseTypes(String loadedFromJar) {\n        Set<String> databaseTypes = new TreeSet<String>();\n        JarInputStream jar = null;\n        try {\n            jar = new JarInputStream(new FileInputStream(loadedFromJar));\n            JarEntry entry;\n            while ((entry = jar.getNextJarEntry()) != null) {\n                String entryName = entry.getName();\n                int dotPropsIndex = entryName.indexOf(\".properties\");\n                if (dotPropsIndex != -1)\n                    databaseTypes.add(entryName.substring(0, dotPropsIndex));\n            }\n        } catch (IOException exc) {\n        } finally {\n            if (jar != null) {\n                try {\n                    jar.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n        return databaseTypes;\n    }\n\n    protected void dumpUsage(String errorMessage, boolean detailedDb) {\n        if (errorMessage != null) {\n            System.out.flush();\n            System.err.println(\"*** \" + errorMessage + \" ***\");\n        } else {\n            System.out.println(\"SchemaSpy generates an HTML representation of a database schema's relationships.\");\n        }\n        System.err.flush();\n        System.out.println();\n        if (!detailedDb) {\n            System.out.println(\"Usage:\");\n            System.out.println(\" java -jar \" + getLoadedFromJar() + \" [options]\");\n            System.out.println(\"   -t databaseType       type of database - defaults to ora\");\n            System.out.println(\"                           use -dbhelp for a list of built-in types\");\n            System.out.println(\"   -u user               connect to the database with this user id\");\n            System.out.println(\"   -s schema             defaults to the specified user\");\n            System.out.println(\"   -p password           defaults to no password\");\n            System.out.println(\"   -o outputDirectory    directory to place the generated output in\");\n            System.out.println(\"   -dp pathToDrivers     optional - looks for JDBC drivers here before looking\");\n            System.out.println(\"                           in driverPath in [databaseType].properties.\");\n            System.out.println(\"Go to http://schemaspy.sourceforge.net for a complete list/description\");\n            System.out.println(\" of additional parameters.\");\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"Built-in database types and their required connection parameters:\");\n            for (String type : getBuiltInDatabaseTypes(getLoadedFromJar())) {\n                new DbSpecificConfig(type).dumpUsage();\n            }\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"You can use your own database types by specifying the filespec of a .properties file with -t.\");\n            System.out.println(\"Grab one out of \" + getLoadedFromJar() + \" and modify it to suit your needs.\");\n            System.out.println();\n        }\n        System.out.println(\"Sample usage using the default database type (implied -t ora):\");\n        System.out.println(\" java -jar schemaSpy.jar -db mydb -s myschema -u devuser -p password -o output\");\n        System.out.println();\n        System.out.flush();\n    }\n\n    /**\n     * Get the value of the specified parameter.\n     * Used for properties that are common to most db's, but aren't required.\n     *\n     * @param paramName\n     * @return\n     */\n    public String getParam(String paramName) {\n        try {\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                PropertyDescriptor prop = props[i];\n                if (prop.getName().equalsIgnoreCase(paramName)) {\n                    Object result = prop.getReadMethod().invoke(this, (Object[]) null);\n                    return result == null ? null : result.toString();\n                }\n            }\n        } catch (Exception failed) {\n            failed.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * Return all of the configuration options as a List of Strings, with\n     * each parameter and its value as a separate element.\n     *\n     * @return\n     * @throws IOException\n     */\n    public List<String> asList() throws IOException {\n        List<String> params = new ArrayList<String>();\n        if (originalDbSpecificOptions != null) {\n            for (String key : originalDbSpecificOptions.keySet()) {\n                String value = originalDbSpecificOptions.get(key);\n                if (!key.startsWith(\"-\"))\n                    key = \"-\" + key;\n                params.add(key);\n                params.add(value);\n            }\n        }\n        if (isEncodeCommentsEnabled())\n            params.add(\"-ahic\");\n        if (isEvaluateAllEnabled())\n            params.add(\"-all\");\n        if (!isHtmlGenerationEnabled())\n            params.add(\"-nohtml\");\n        if (!isImpliedConstraintsEnabled())\n            params.add(\"-noimplied\");\n        if (!isLogoEnabled())\n            params.add(\"-nologo\");\n        if (isMeterEnabled())\n            params.add(\"-meter\");\n        if (!isNumRowsEnabled())\n            params.add(\"-norows\");\n        if (!isViewsEnabled())\n            params.add(\"-noviews\");\n        if (isRankDirBugEnabled())\n            params.add(\"-rankdirbug\");\n        if (isRailsEnabled())\n            params.add(\"-rails\");\n        if (isSingleSignOn())\n            params.add(\"-sso\");\n        if (isSchemaDisabled())\n            params.add(\"-noschema\");\n        String value = getDriverPath();\n        if (value != null) {\n            params.add(\"-dp\");\n            params.add(value);\n        }\n        params.add(\"-css\");\n        params.add(getCss());\n        params.add(\"-charset\");\n        params.add(getCharset());\n        params.add(\"-font\");\n        params.add(getFont());\n        params.add(\"-fontsize\");\n        params.add(String.valueOf(getFontSize()));\n        params.add(\"-t\");\n        params.add(getDbType());\n        // query to set renderer correctly\n        isHighQuality();\n        // query to set renderer correctly\n        isLowQuality();\n        // instead of -hq and/or -lq\n        params.add(\"-renderer\");\n        params.add(getRenderer());\n        value = getDescription();\n        if (value != null) {\n            params.add(\"-desc\");\n            params.add(value);\n        }\n        value = getPassword();\n        if (value != null && !isPromptForPasswordEnabled()) {\n            // note that we don't pass -pfp since child processes\n            // won't have a console\n            params.add(\"-p\");\n            params.add(value);\n        }\n        value = getCatalog();\n        if (value != null) {\n            params.add(\"-cat\");\n            params.add(value);\n        }\n        value = getSchema();\n        if (value != null) {\n            params.add(\"-s\");\n            params.add(value);\n        }\n        value = getUser();\n        if (value != null) {\n            params.add(\"-u\");\n            params.add(value);\n        }\n        value = getConnectionPropertiesFile();\n        if (value != null) {\n            params.add(\"-connprops\");\n            params.add(value);\n        } else {\n            Properties props = getConnectionProperties();\n            if (!props.isEmpty()) {\n                params.add(\"-connprops\");\n                StringBuilder buf = new StringBuilder();\n                for (Entry<Object, Object> entry : props.entrySet()) {\n                    buf.append(entry.getKey());\n                    buf.append(ESCAPED_EQUALS);\n                    buf.append(entry.getValue());\n                    buf.append(';');\n                }\n                params.add(buf.toString());\n            }\n        }\n        value = getDb();\n        if (value != null) {\n            params.add(\"-db\");\n            params.add(value);\n        }\n        value = getHost();\n        if (value != null) {\n            params.add(\"-host\");\n            params.add(value);\n        }\n        if (getPort() != null) {\n            params.add(\"-port\");\n            params.add(getPort().toString());\n        }\n        value = getServer();\n        if (value != null) {\n            params.add(\"-server\");\n            params.add(value);\n        }\n        value = getMeta();\n        if (value != null) {\n            params.add(\"-meta\");\n            params.add(value);\n        }\n        if (getGraphvizDir() != null) {\n            params.add(\"-gv\");\n            params.add(getGraphvizDir().toString());\n        }\n        params.add(\"-loglevel\");\n        params.add(getLogLevel().toString().toLowerCase());\n        params.add(\"-sqlFormatter\");\n        params.add(getSqlFormatter().getClass().getName());\n        params.add(\"-i\");\n        params.add(getTableInclusions().toString());\n        params.add(\"-I\");\n        params.add(getTableExclusions().toString());\n        params.add(\"-X\");\n        params.add(getColumnExclusions().toString());\n        params.add(\"-x\");\n        params.add(getIndirectColumnExclusions().toString());\n        params.add(\"-dbthreads\");\n        params.add(String.valueOf(getMaxDbThreads()));\n        params.add(\"-maxdet\");\n        params.add(String.valueOf(getMaxDetailedTables()));\n        params.add(\"-o\");\n        params.add(getOutputDir().toString());\n        return params;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/ConfigTest11.java",
		"test_prompt": "// ConfigTest11.java\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Config}.\n* It contains ten unit test cases for the {@link Config#isViewsEnabled()} method.\n*/\nclass ConfigTest11 {"
	},
	{
		"original_code": "// Config.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\n\n/**\n * Configuration of a SchemaSpy run\n *\n * @author John Currier\n */\npublic class Config {\n\n    private static Config instance;\n\n    private final List<String> options;\n\n    private Map<String, String> dbSpecificOptions;\n\n    private Map<String, String> originalDbSpecificOptions;\n\n    private boolean helpRequired;\n\n    private boolean dbHelpRequired;\n\n    private File outputDir;\n\n    private File graphvizDir;\n\n    private String dbType;\n\n    private String catalog;\n\n    private String schema;\n\n    private List<String> schemas;\n\n    private String user;\n\n    private Boolean singleSignOn;\n\n    private Boolean noSchema;\n\n    private String password;\n\n    private Boolean promptForPassword;\n\n    private String db;\n\n    private String host;\n\n    private Integer port;\n\n    private String server;\n\n    private String meta;\n\n    private Pattern tableInclusions;\n\n    private Pattern tableExclusions;\n\n    private Pattern columnExclusions;\n\n    private Pattern indirectColumnExclusions;\n\n    private String userConnectionPropertiesFile;\n\n    private Properties userConnectionProperties;\n\n    private Integer maxDbThreads;\n\n    private Integer maxDetailedTables;\n\n    private String driverPath;\n\n    private String css;\n\n    private String charset;\n\n    private String font;\n\n    private Integer fontSize;\n\n    private String description;\n\n    private Properties dbProperties;\n\n    private String dbPropertiesLoadedFrom;\n\n    private Level logLevel;\n\n    private SqlFormatter sqlFormatter;\n\n    private String sqlFormatterClass;\n\n    private Boolean generateHtml;\n\n    private Boolean includeImpliedConstraints;\n\n    private Boolean logoEnabled;\n\n    private Boolean rankDirBugEnabled;\n\n    private Boolean encodeCommentsEnabled;\n\n    private Boolean numRowsEnabled;\n\n    private Boolean viewsEnabled;\n\n    private Boolean meterEnabled;\n\n    private Boolean railsEnabled;\n\n    private Boolean evaluteAll;\n\n    private Boolean highQuality;\n\n    private Boolean lowQuality;\n\n    // used in conjunction with evaluateAll\n    private String schemaSpec;\n\n    private boolean hasOrphans = false;\n\n    private boolean hasRoutines = false;\n\n    private boolean populating = false;\n\n    private List<String> columnDetails;\n\n    public static final String DOT_CHARSET = \"UTF-8\";\n\n    private static final String ESCAPED_EQUALS = \"\\\\=\";\n\n    // match everything\n    private static final String DEFAULT_TABLE_INCLUSION = \".*\";\n\n    // match nothing\n    private static final String DEFAULT_TABLE_EXCLUSION = \"\";\n\n    // match nothing\n    private static final String DEFAULT_COLUMN_EXCLUSION = \"[^.]\";\n\n    /**\n     * Default constructor. Intended for when you want to inject properties\n     * independently (i.e. not from a command line interface).\n     */\n    public Config() {\n        if (instance == null)\n            setInstance(this);\n        options = new ArrayList<String>();\n    }\n\n    /**\n     * Construct a configuration from an array of options (e.g. from a command\n     * line interface).\n     *\n     * @param options\n     */\n    public Config(String[] argv) {\n        setInstance(this);\n        options = fixupArgs(Arrays.asList(argv));\n        helpRequired = options.remove(\"-?\") || options.remove(\"/?\") || options.remove(\"?\") || options.remove(\"-h\") || options.remove(\"-help\") || options.remove(\"--help\");\n        dbHelpRequired = options.remove(\"-dbHelp\") || options.remove(\"-dbhelp\");\n    }\n\n    public static Config getInstance() {\n        if (instance == null)\n            instance = new Config();\n        return instance;\n    }\n\n    /**\n     * Sets the global instance.\n     *\n     * Useful for things like selecting a specific configuration in a UI.\n     *\n     * @param config\n     */\n    public static void setInstance(Config config) {\n        instance = config;\n    }\n\n    public void setHtmlGenerationEnabled(boolean generateHtml) {\n        this.generateHtml = generateHtml;\n    }\n\n    public boolean isHtmlGenerationEnabled() {\n        if (generateHtml == null)\n            generateHtml = !options.remove(\"-nohtml\");\n        return generateHtml;\n    }\n\n    public void setImpliedConstraintsEnabled(boolean includeImpliedConstraints) {\n        this.includeImpliedConstraints = includeImpliedConstraints;\n    }\n\n    public boolean isImpliedConstraintsEnabled() {\n        if (includeImpliedConstraints == null)\n            includeImpliedConstraints = !options.remove(\"-noimplied\");\n        return includeImpliedConstraints;\n    }\n\n    public void setOutputDir(String outputDirName) {\n        if (outputDirName.endsWith(\"\\\"\"))\n            outputDirName = outputDirName.substring(0, outputDirName.length() - 1);\n        setOutputDir(new File(outputDirName));\n    }\n\n    public void setOutputDir(File outputDir) {\n        this.outputDir = outputDir;\n    }\n\n    public File getOutputDir() {\n        if (outputDir == null) {\n            setOutputDir(pullRequiredParam(\"-o\"));\n        }\n        return outputDir;\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(String graphvizDir) {\n        if (graphvizDir.endsWith(\"\\\"\"))\n            graphvizDir = graphvizDir.substring(0, graphvizDir.length() - 1);\n        setGraphvizDir(new File(graphvizDir));\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(File graphvizDir) {\n        this.graphvizDir = graphvizDir;\n    }\n\n    /**\n     * Return the path to Graphviz (used to find the dot executable to run to\n     * generate ER diagrams).<p/>\n     *\n     * Returns {@link #getDefaultGraphvizPath()} if a specific Graphviz path\n     * was not specified.\n     *\n     * @return\n     */\n    public File getGraphvizDir() {\n        if (graphvizDir == null) {\n            String gv = pullParam(\"-gv\");\n            if (gv != null) {\n                setGraphvizDir(gv);\n            } else {\n                // expect to find Graphviz's bin directory on the PATH\n            }\n        }\n        return graphvizDir;\n    }\n\n    /**\n     * Meta files are XML-based files that provide additional metadata\n     * about the schema being evaluated.<p>\n     * <code>meta</code> is either the name of an individual XML file or\n     * the directory that contains meta files.<p>\n     * If a directory is specified then it is expected to contain files\n     * matching the pattern <code>[schema].meta.xml</code>.\n     * For databases that don't have schema substitute database for schema.\n     * @param meta\n     */\n    public void setMeta(String meta) {\n        this.meta = meta;\n    }\n\n    public String getMeta() {\n        if (meta == null)\n            meta = pullParam(\"-meta\");\n        return meta;\n    }\n\n    public void setDbType(String dbType) {\n        this.dbType = dbType;\n    }\n\n    public String getDbType() {\n        if (dbType == null) {\n            dbType = pullParam(\"-t\");\n            if (dbType == null)\n                dbType = \"ora\";\n        }\n        return dbType;\n    }\n\n    public void setDb(String db) {\n        this.db = db;\n    }\n\n    public String getDb() {\n        if (db == null)\n            db = pullParam(\"-db\");\n        return db;\n    }\n\n    public void setCatalog(String catalog) {\n        this.catalog = catalog;\n    }\n\n    public String getCatalog() {\n        if (catalog == null)\n            catalog = pullParam(\"-cat\");\n        return catalog;\n    }\n\n    public void setSchema(String schema) {\n        this.schema = schema;\n    }\n\n    public String getSchema() {\n        if (schema == null)\n            schema = pullParam(\"-s\");\n        return schema;\n    }\n\n    /**\n     * Some databases types (e.g. older versions of Informix) don't really\n     * have the concept of a schema but still return true from\n     * {@link DatabaseMetaData#supportsSchemasInTableDefinitions()}.\n     * This option lets you ignore that and treat all the tables\n     * as if they were in one flat namespace.\n     */\n    public boolean isSchemaDisabled() {\n        if (noSchema == null)\n            noSchema = options.remove(\"-noschema\");\n        return noSchema;\n    }\n\n    public void setHost(String host) {\n        this.host = host;\n    }\n\n    public String getHost() {\n        if (host == null)\n            host = pullParam(\"-host\");\n        return host;\n    }\n\n    public void setPort(Integer port) {\n        this.port = port;\n    }\n\n    public Integer getPort() {\n        if (port == null)\n            try {\n                port = Integer.valueOf(pullParam(\"-port\"));\n            } catch (Exception notSpecified) {\n            }\n        return port;\n    }\n\n    public void setServer(String server) {\n        this.server = server;\n    }\n\n    public String getServer() {\n        if (server == null) {\n            server = pullParam(\"-server\");\n        }\n        return server;\n    }\n\n    public void setUser(String user) {\n        this.user = user;\n    }\n\n    /**\n     * User used to connect to the database.\n     * Required unless single sign-on is enabled\n     * (see {@link #setSingleSignOn(boolean)}).\n     * @return\n     */\n    public String getUser() {\n        if (user == null) {\n            if (!isSingleSignOn())\n                user = pullRequiredParam(\"-u\");\n            else\n                user = pullParam(\"-u\");\n        }\n        return user;\n    }\n\n    /**\n     * By default a \"user\" (as specified with -u) is required.\n     * This option allows disabling of that requirement for\n     * single sign-on environments.\n     *\n     * @param enabled defaults to <code>false</code>\n     */\n    public void setSingleSignOn(boolean enabled) {\n        singleSignOn = enabled;\n    }\n\n    /**\n     * @see #setSingleSignOn(boolean)\n     */\n    public boolean isSingleSignOn() {\n        if (singleSignOn == null)\n            singleSignOn = options.remove(\"-sso\");\n        return singleSignOn;\n    }\n\n    /**\n     * Set the password used to connect to the database.\n     * @param password\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * @see #setPassword(String)\n     * @return\n     */\n    public String getPassword() {\n        if (password == null)\n            password = pullParam(\"-p\");\n        if (password == null && isPromptForPasswordEnabled())\n            password = new String(PasswordReader.getInstance().readPassword(\"Password: \"));\n        if (password == null) {\n            // if -pfp is enabled when analyzing multiple schemas then\n            // we don't want to send the password on the command line,\n            // so see if it was passed in the environment (not ideal, but safer)\n            password = System.getenv(\"schemaspy.pw\");\n        }\n        return password;\n    }\n\n    /**\n     * Set to <code>true</code> to prompt for the password\n     * @param promptForPassword\n     */\n    public void setPromptForPasswordEnabled(boolean promptForPassword) {\n        this.promptForPassword = promptForPassword;\n    }\n\n    /**\n     * @see #setPromptForPasswordEnabled(boolean)\n     * @return\n     */\n    public boolean isPromptForPasswordEnabled() {\n        if (promptForPassword == null) {\n            promptForPassword = options.remove(\"-pfp\");\n        }\n        return promptForPassword;\n    }\n\n    public void setMaxDetailedTabled(int maxDetailedTables) {\n        this.maxDetailedTables = new Integer(maxDetailedTables);\n    }\n\n    public int getMaxDetailedTables() {\n        if (maxDetailedTables == null) {\n            // default\n            int max = 300;\n            try {\n                max = Integer.parseInt(pullParam(\"-maxdet\"));\n            } catch (Exception notSpecified) {\n            }\n            maxDetailedTables = new Integer(max);\n        }\n        return maxDetailedTables.intValue();\n    }\n\n    public String getConnectionPropertiesFile() {\n        return userConnectionPropertiesFile;\n    }\n\n    /**\n     * Properties from this file (in key=value pair format) are passed to the\n     * database connection.<br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.\n     * @param propertiesFilename\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public void setConnectionPropertiesFile(String propertiesFilename) throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null)\n            userConnectionProperties = new Properties();\n        userConnectionProperties.load(new FileInputStream(propertiesFilename));\n        userConnectionPropertiesFile = propertiesFilename;\n    }\n\n    /**\n     * Returns a {@link Properties} populated either from the properties file specified\n     * by {@link #setConnectionPropertiesFile(String)}, the properties specified by\n     * {@link #setConnectionProperties(String)} or not populated.\n     * @return\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public Properties getConnectionProperties() throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null) {\n            String props = pullParam(\"-connprops\");\n            if (props != null) {\n                if (props.indexOf(ESCAPED_EQUALS) != -1) {\n                    setConnectionProperties(props);\n                } else {\n                    setConnectionPropertiesFile(props);\n                }\n            } else {\n                userConnectionProperties = new Properties();\n            }\n        }\n        return userConnectionProperties;\n    }\n\n    /**\n     * Specifies connection properties to use in the format:\n     * <code>key1\\=value1;key2\\=value2</code><br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.<p>\n     * This is an alternative form of passing connection properties than by file\n     * (see {@link #setConnectionPropertiesFile(String)})\n     *\n     * @param properties\n     */\n    public void setConnectionProperties(String properties) {\n        userConnectionProperties = new Properties();\n        StringTokenizer tokenizer = new StringTokenizer(properties, \";\");\n        while (tokenizer.hasMoreElements()) {\n            String pair = tokenizer.nextToken();\n            int index = pair.indexOf(ESCAPED_EQUALS);\n            if (index != -1) {\n                String key = pair.substring(0, index);\n                String value = pair.substring(index + ESCAPED_EQUALS.length());\n                userConnectionProperties.put(key, value);\n            }\n        }\n    }\n\n    public void setDriverPath(String driverPath) {\n        this.driverPath = driverPath;\n    }\n\n    public String getDriverPath() {\n        if (driverPath == null)\n            driverPath = pullParam(\"-dp\");\n        // was previously -cp:\n        if (driverPath == null)\n            driverPath = pullParam(\"-cp\");\n        return driverPath;\n    }\n\n    /**\n     * The filename of the cascading style sheet to use.\n     * Note that this file is parsed and used to determine characteristics\n     * of the generated diagrams, so it must contain specific settings that\n     * are documented within schemaSpy.css.<p>\n     *\n     * Defaults to <code>\"schemaSpy.css\"</code>.\n     *\n     * @param css\n     */\n    public void setCss(String css) {\n        this.css = css;\n    }\n\n    public String getCss() {\n        if (css == null) {\n            css = pullParam(\"-css\");\n            if (css == null)\n                css = \"schemaSpy.css\";\n        }\n        return css;\n    }\n\n    /**\n     * The font to use within diagrams.  Modify the .css to specify HTML fonts.\n     *\n     * @param font\n     */\n    public void setFont(String font) {\n        this.font = font;\n    }\n\n    /**\n     * @see #setFont(String)\n     */\n    public String getFont() {\n        if (font == null) {\n            font = pullParam(\"-font\");\n            if (font == null)\n                font = \"Helvetica\";\n        }\n        return font;\n    }\n\n    /**\n     * The font size to use within diagrams.  This is the size of the font used for\n     * 'large' (e.g. not 'compact') diagrams.<p>\n     *\n     * Modify the .css to specify HTML font sizes.<p>\n     *\n     * Defaults to 11.\n     *\n     * @param fontSize\n     */\n    public void setFontSize(int fontSize) {\n        this.fontSize = new Integer(fontSize);\n    }\n\n    /**\n     * @see #setFontSize(int)\n     * @return\n     */\n    public int getFontSize() {\n        if (fontSize == null) {\n            // default\n            int size = 11;\n            try {\n                size = Integer.parseInt(pullParam(\"-fontsize\"));\n            } catch (Exception notSpecified) {\n            }\n            fontSize = new Integer(size);\n        }\n        return fontSize.intValue();\n    }\n\n    /**\n     * The character set to use within HTML pages (defaults to <code>\"ISO-8859-1\"</code>).\n     *\n     * @param charset\n     */\n    public void setCharset(String charset) {\n        this.charset = charset;\n    }\n\n    /**\n     * @see #setCharset(String)\n     */\n    public String getCharset() {\n        if (charset == null) {\n            charset = pullParam(\"-charset\");\n            if (charset == null)\n                charset = \"ISO-8859-1\";\n        }\n        return charset;\n    }\n\n    /**\n     * Description of schema that gets display on main pages.\n     *\n     * @param description\n     */\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    /**\n     * @see #setDescription(String)\n     */\n    public String getDescription() {\n        if (description == null)\n            description = pullParam(\"-desc\");\n        return description;\n    }\n\n    /**\n     * Maximum number of threads to use when querying database metadata information.\n     *\n     * @param maxDbThreads\n     */\n    public void setMaxDbThreads(int maxDbThreads) {\n        this.maxDbThreads = new Integer(maxDbThreads);\n    }\n\n    /**\n     * @see #setMaxDbThreads(int)\n     * @throws InvalidConfigurationException if unable to load properties\n     */\n    public int getMaxDbThreads() throws InvalidConfigurationException {\n        if (maxDbThreads == null) {\n            Properties properties;\n            try {\n                properties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(\"Failed to load properties for \" + getDbType() + \": \" + exc).setParamName(\"-type\");\n            }\n            // not scientifically derived\n            final int defaultMax = 15;\n            int max = defaultMax;\n            String threads = properties.getProperty(\"dbThreads\");\n            if (threads == null)\n                threads = properties.getProperty(\"dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            threads = pullParam(\"-dbThreads\");\n            if (threads == null)\n                threads = pullParam(\"-dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            if (max < 0)\n                max = defaultMax;\n            else if (max == 0)\n                max = 1;\n            maxDbThreads = new Integer(max);\n        }\n        return maxDbThreads.intValue();\n    }\n\n    public boolean isLogoEnabled() {\n        if (logoEnabled == null)\n            logoEnabled = !options.remove(\"-nologo\");\n        return logoEnabled;\n    }\n\n    /**\n     * Don't use this unless absolutely necessary as it screws up the layout\n     *\n     * @param enabled\n     */\n    public void setRankDirBugEnabled(boolean enabled) {\n        rankDirBugEnabled = enabled;\n    }\n\n    /**\n     * @see #setRankDirBugEnabled(boolean)\n     */\n    public boolean isRankDirBugEnabled() {\n        if (rankDirBugEnabled == null)\n            rankDirBugEnabled = options.remove(\"-rankdirbug\");\n        return rankDirBugEnabled;\n    }\n\n    /**\n     * Look for Ruby on Rails-based naming conventions in\n     * relationships between logical foreign keys and primary keys.<p>\n     *\n     * Basically all tables have a primary key named <code>ID</code>.\n     * All tables are named plural names.\n     * The columns that logically reference that <code>ID</code> are the singular\n     * form of the table name suffixed with <code>_ID</code>.<p>\n     *\n     * @param enabled\n     */\n    public void setRailsEnabled(boolean enabled) {\n        railsEnabled = enabled;\n    }\n\n    /**\n     * @see #setRailsEnabled(boolean)\n     *\n     * @return\n     */\n    public boolean isRailsEnabled() {\n        if (railsEnabled == null)\n            railsEnabled = options.remove(\"-rails\");\n        return railsEnabled;\n    }\n\n    /**\n     * Allow Html In Comments - encode them unless otherwise specified\n     */\n    public void setEncodeCommentsEnabled(boolean enabled) {\n        encodeCommentsEnabled = enabled;\n    }\n\n    /**\n     * @see #setEncodeCommentsEnabled(boolean)\n     */\n    public boolean isEncodeCommentsEnabled() {\n        if (encodeCommentsEnabled == null)\n            encodeCommentsEnabled = !options.remove(\"-ahic\");\n        return encodeCommentsEnabled;\n    }\n\n    /**\n     * If enabled we'll attempt to query/render the number of rows that\n     * each table contains.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setNumRowsEnabled(boolean enabled) {\n        numRowsEnabled = enabled;\n    }\n\n    /**\n     * @see #setNumRowsEnabled(boolean)\n     * @return\n     */\n    public boolean isNumRowsEnabled() {\n        if (numRowsEnabled == null)\n            numRowsEnabled = !options.remove(\"-norows\");\n        return numRowsEnabled;\n    }\n\n    /**\n     * If enabled we'll include views in the analysis.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setViewsEnabled(boolean enabled) {\n        viewsEnabled = enabled;\n    }\n\n    /**\n     * @see #setViewsEnabled(boolean)\n     * @return\n     */\n    public boolean isViewsEnabled() {\n        if (viewsEnabled == null)\n            viewsEnabled = !options.remove(\"-noviews\");\n        return viewsEnabled;\n    }\n\n    /**\n     * Returns <code>true</code> if metering should be embedded in\n     * the generated pages.<p/>\n     * Defaults to <code>false</code> (disabled).\n     * @return\n     */\n    public boolean isMeterEnabled() {\n        if (meterEnabled == null)\n            meterEnabled = options.remove(\"-meter\");\n        return meterEnabled;\n    }\n\n    /**\n     * Set the columns to exclude from all relationship diagrams.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setColumnExclusions(String columnExclusions) {\n        this.columnExclusions = Pattern.compile(columnExclusions);\n    }\n\n    /**\n     * See {@link #setColumnExclusions(String)}\n     * @return\n     */\n    public Pattern getColumnExclusions() {\n        if (columnExclusions == null) {\n            String strExclusions = pullParam(\"-X\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.columnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            columnExclusions = Pattern.compile(strExclusions);\n        }\n        return columnExclusions;\n    }\n\n    /**\n     * Set the columns to exclude from relationship diagrams where the specified\n     * columns aren't directly referenced by the focal table.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setIndirectColumnExclusions(String fullColumnExclusions) {\n        indirectColumnExclusions = Pattern.compile(fullColumnExclusions);\n    }\n\n    /**\n     * @see #setIndirectColumnExclusions(String)\n     *\n     * @return\n     */\n    public Pattern getIndirectColumnExclusions() {\n        if (indirectColumnExclusions == null) {\n            String strExclusions = pullParam(\"-x\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.indirectColumnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            indirectColumnExclusions = Pattern.compile(strExclusions);\n        }\n        return indirectColumnExclusions;\n    }\n\n    /**\n     * Set the tables to include as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableInclusions(String tableInclusions) {\n        this.tableInclusions = Pattern.compile(tableInclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to include in the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableInclusions() {\n        if (tableInclusions == null) {\n            String strInclusions = pullParam(\"-i\");\n            if (strInclusions == null)\n                strInclusions = System.getenv(\"schemaspy.tableInclusions\");\n            if (strInclusions == null)\n                strInclusions = DEFAULT_TABLE_INCLUSION;\n            try {\n                tableInclusions = Pattern.compile(strInclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-i\");\n            }\n        }\n        return tableInclusions;\n    }\n\n    /**\n     * Set the tables to exclude as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableExclusions(String tableExclusions) {\n        this.tableExclusions = Pattern.compile(tableExclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to exclude from the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableExclusions() {\n        if (tableExclusions == null) {\n            String strExclusions = pullParam(\"-I\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.tableExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_TABLE_EXCLUSION;\n            try {\n                tableExclusions = Pattern.compile(strExclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-I\");\n            }\n        }\n        return tableExclusions;\n    }\n\n    /**\n     * @return\n     */\n    public List<String> getSchemas() {\n        if (schemas == null) {\n            String tmp = pullParam(\"-schemas\");\n            if (tmp == null)\n                tmp = pullParam(\"-schemata\");\n            if (tmp != null) {\n                schemas = new ArrayList<String>();\n                for (String name : tmp.split(\"[\\\\s,'\\\"]\")) {\n                    if (name.length() > 0)\n                        schemas.add(name);\n                }\n                if (schemas.isEmpty())\n                    schemas = null;\n            }\n        }\n        return schemas;\n    }\n\n    /**\n     * Set the name of the {@link SqlFormatter SQL formatter} class to use to\n     * format SQL into HTML.<p/>\n     * The implementation of the class must be made available to the class\n     * loader, typically by specifying the path to its jar with <em>-dp</em>\n     * ({@link #setDriverPath(String)}).\n     */\n    public void setSqlFormatter(String formatterClassName) {\n        sqlFormatterClass = formatterClassName;\n        sqlFormatter = null;\n    }\n\n    /**\n     * Set the {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.\n     */\n    public void setSqlFormatter(SqlFormatter sqlFormatter) {\n        this.sqlFormatter = sqlFormatter;\n        if (sqlFormatter != null)\n            sqlFormatterClass = sqlFormatter.getClass().getName();\n    }\n\n    /**\n     * Returns an implementation of {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.  The default implementation is {@link DefaultSqlFormatter}.\n     *\n     * @return\n     * @throws InvalidConfigurationException if unable to instantiate an instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SqlFormatter getSqlFormatter() throws InvalidConfigurationException {\n        if (sqlFormatter == null) {\n            if (sqlFormatterClass == null) {\n                sqlFormatterClass = pullParam(\"-sqlFormatter\");\n                if (sqlFormatterClass == null)\n                    sqlFormatterClass = DefaultSqlFormatter.class.getName();\n            }\n            try {\n                Class<SqlFormatter> clazz = (Class<SqlFormatter>) Class.forName(sqlFormatterClass);\n                sqlFormatter = clazz.newInstance();\n            } catch (Exception exc) {\n                throw new InvalidConfigurationException(\"Failed to initialize instance of SQL formatter: \", exc).setParamName(\"-sqlFormatter\");\n            }\n        }\n        return sqlFormatter;\n    }\n\n    /**\n     * Set the details to show on the columns page, where \"details\" are\n     * comma and/or space separated.\n     *\n     * Valid values:\n     * <ul>\n     * <li>id</li>\n     * <li>table</li>\n     * <li>column</li>\n     * <li>type</li>\n     * <li>size</li>\n     * <li>nulls</li>\n     * <li>auto</li>\n     * <li>default</li>\n     * <li>children</li>\n     * <li>parents</li>\n     * </ul>\n     *\n     * The default details are <code>\"table column type size nulls auto default\"</code>.\n     * Note that \"column\" is the initially displayed detail and must be included.\n     *\n     * @param columnDetails\n     */\n    public void setColumnDetails(String columnDetails) {\n        this.columnDetails = new ArrayList<String>();\n        if (columnDetails == null || columnDetails.length() == 0) {\n            // not specified, so use defaults\n            columnDetails = \"id table column type size nulls auto default\";\n        }\n        for (String detail : columnDetails.split(\"[\\\\s,'\\\"]\")) {\n            if (detail.length() > 0) {\n                this.columnDetails.add(detail.toLowerCase());\n            }\n        }\n        if (!this.columnDetails.contains(\"column\"))\n            throw new InvalidConfigurationException(\"'column' is a required column detail\");\n    }\n\n    public void setColumnDetails(List<String> columnDetails) {\n        String details = columnDetails == null ? \"[]\" : columnDetails.toString();\n        setColumnDetails(details.substring(1, details.length() - 1));\n    }\n\n    public List<String> getColumnDetails() {\n        if (columnDetails == null) {\n            setColumnDetails(pullParam(\"-columndetails\"));\n        }\n        return columnDetails;\n    }\n\n    public void setEvaluateAllEnabled(boolean enabled) {\n        evaluteAll = enabled;\n    }\n\n    public boolean isEvaluateAllEnabled() {\n        if (evaluteAll == null)\n            evaluteAll = options.remove(\"-all\");\n        return evaluteAll;\n    }\n\n    /**\n     * Returns true if we're evaluating a bunch of schemas in one go and\n     * at this point we're evaluating a specific schema.\n     *\n     * @return boolean\n     */\n    public boolean isOneOfMultipleSchemas() {\n        // set by MultipleSchemaAnalyzer\n        return Boolean.getBoolean(\"oneofmultipleschemas\");\n    }\n\n    /**\n     * When -all (evaluateAll) is specified then this is the regular\n     * expression that determines which schemas to evaluate.\n     *\n     * @param schemaSpec\n     */\n    public void setSchemaSpec(String schemaSpec) {\n        this.schemaSpec = schemaSpec;\n    }\n\n    public String getSchemaSpec() {\n        if (schemaSpec == null)\n            schemaSpec = pullParam(\"-schemaSpec\");\n        return schemaSpec;\n    }\n\n    /**\n     * Set the renderer to use for the -Tpng[:renderer[:formatter]] dot option as specified\n     * at <a href='http://www.graphviz.org/doc/info/command.html'>\n     * http://www.graphviz.org/doc/info/command.html</a>.<p>\n     * Note that the leading \":\" is required while :formatter is optional.<p>\n     * The default renderer is typically GD.<p>\n     * Note that using {@link #setHighQuality(boolean)} is the preferred approach\n     * over using this method.\n     */\n    public void setRenderer(String renderer) {\n        Dot.getInstance().setRenderer(renderer);\n    }\n\n    /**\n     * @see #setRenderer(String)\n     * @return\n     */\n    public String getRenderer() {\n        String renderer = pullParam(\"-renderer\");\n        if (renderer != null)\n            setRenderer(renderer);\n        return Dot.getInstance().getRenderer();\n    }\n\n    /**\n     * If <code>false</code> then generate output of \"lower quality\"\n     * than the default.\n     * Note that the default is intended to be \"higher quality\",\n     * but various installations of Graphviz may have have different abilities.\n     * That is, some might not have the \"lower quality\" libraries and others might\n     * not have the \"higher quality\" libraries.<p>\n     * Higher quality output takes longer to generate and results in significantly\n     * larger image files (which take longer to download / display), but it generally\n     * looks better.\n     */\n    public void setHighQuality(boolean highQuality) {\n        this.highQuality = highQuality;\n        lowQuality = !highQuality;\n        Dot.getInstance().setHighQuality(highQuality);\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isHighQuality() {\n        if (highQuality == null) {\n            highQuality = options.remove(\"-hq\");\n            if (highQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(highQuality);\n            }\n        }\n        highQuality = Dot.getInstance().isHighQuality();\n        return highQuality;\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isLowQuality() {\n        if (lowQuality == null) {\n            lowQuality = options.remove(\"-lq\");\n            if (lowQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(!lowQuality);\n            }\n        }\n        lowQuality = !Dot.getInstance().isHighQuality();\n        return lowQuality;\n    }\n\n    /**\n     * Set the level of logging to perform.<p/>\n     * The levels in descending order are:\n     * <ul>\n     *  <li><code>severe</code> (highest - least detail)\n     *  <li><code>warning</code> (default)\n     *  <li><code>info</code>\n     *  <li><code>config</code>\n     *  <li><code>fine</code>\n     *  <li><code>finer</code>\n     *  <li><code>finest</code>  (lowest - most detail)\n     * </ul>\n     *\n     * @param logLevel\n     */\n    public void setLogLevel(String logLevel) {\n        if (logLevel == null) {\n            this.logLevel = Level.WARNING;\n            return;\n        }\n        Map<String, Level> levels = new LinkedHashMap<String, Level>();\n        levels.put(\"severe\", Level.SEVERE);\n        levels.put(\"warning\", Level.WARNING);\n        levels.put(\"info\", Level.INFO);\n        levels.put(\"config\", Level.CONFIG);\n        levels.put(\"fine\", Level.FINE);\n        levels.put(\"finer\", Level.FINER);\n        levels.put(\"finest\", Level.FINEST);\n        this.logLevel = levels.get(logLevel.toLowerCase());\n        if (this.logLevel == null) {\n            throw new InvalidConfigurationException(\"Invalid logLevel: '\" + logLevel + \"'. Must be one of: \" + levels.keySet());\n        }\n    }\n\n    /**\n     * Returns the level of logging to perform.\n     * See {@link #setLogLevel(String)}.\n     *\n     * @return\n     */\n    public Level getLogLevel() {\n        if (logLevel == null) {\n            setLogLevel(pullParam(\"-loglevel\"));\n        }\n        return logLevel;\n    }\n\n    /**\n     * Returns <code>true</code> if the options indicate that the user wants\n     * to see some help information.\n     *\n     * @return\n     */\n    public boolean isHelpRequired() {\n        return helpRequired;\n    }\n\n    public boolean isDbHelpRequired() {\n        return dbHelpRequired;\n    }\n\n    /**\n     * Returns the jar that we were loaded from\n     *\n     * @return\n     */\n    public static String getLoadedFromJar() {\n        String classpath = System.getProperty(\"java.class.path\");\n        return new StringTokenizer(classpath, File.pathSeparator).nextToken();\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasOrphans(boolean hasOrphans) {\n        this.hasOrphans = hasOrphans;\n    }\n\n    /**\n     * @see #setHasOrphans()\n     *\n     * @return\n     */\n    public boolean hasOrphans() {\n        return hasOrphans;\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasRoutines(boolean hasRoutines) {\n        this.hasRoutines = hasRoutines;\n    }\n\n    /**\n     * @see #setHasRoutines()\n     *\n     * @return\n     */\n    public boolean hasRoutines() {\n        return hasRoutines;\n    }\n\n    /**\n     * Returns the database properties to use.\n     * These should be determined by calling {@link #determineDbProperties(String)}.\n     * @return\n     * @throws InvalidConfigurationException\n     */\n    public Properties getDbProperties() throws InvalidConfigurationException {\n        if (dbProperties == null) {\n            try {\n                dbProperties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(exc);\n            }\n        }\n        return dbProperties;\n    }\n\n    /**\n     * Determines the database properties associated with the specified type.\n     * A call to {@link #setDbProperties(Properties)} is expected after determining\n     * the complete set of properties.\n     *\n     * @param type\n     * @return\n     * @throws IOException\n     * @throws InvalidConfigurationException if db properties are incorrectly formed\n     */\n    public Properties determineDbProperties(String type) throws IOException, InvalidConfigurationException {\n        ResourceBundle bundle = null;\n        try {\n            File propertiesFile = new File(type);\n            bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n            dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n        } catch (FileNotFoundException notFoundOnFilesystemWithoutExtension) {\n            try {\n                File propertiesFile = new File(type + \".properties\");\n                bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n                dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n            } catch (FileNotFoundException notFoundOnFilesystemWithExtensionTackedOn) {\n                try {\n                    bundle = ResourceBundle.getBundle(type);\n                    dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]\" + File.separator + type + \".properties\";\n                } catch (Exception notInJarWithoutPath) {\n                    try {\n                        String path = TableOrderer.class.getPackage().getName() + \".dbTypes.\" + type;\n                        path = path.replace('.', '/');\n                        bundle = ResourceBundle.getBundle(path);\n                        dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]/\" + path + \".properties\";\n                    } catch (Exception notInJar) {\n                        notInJar.printStackTrace();\n                        notFoundOnFilesystemWithExtensionTackedOn.printStackTrace();\n                        throw notFoundOnFilesystemWithoutExtension;\n                    }\n                }\n            }\n        }\n        Properties props = asProperties(bundle);\n        bundle = null;\n        // keep original thru recursion\n        String saveLoadedFrom = dbPropertiesLoadedFrom;\n        // bring in key/values pointed to by the include directive\n        // example: include.1=mysql::selectRowCountSql\n        for (int i = 1; true; ++i) {\n            String include = (String) props.remove(\"include.\" + i);\n            if (include == null)\n                break;\n            int separator = include.indexOf(\"::\");\n            if (separator == -1)\n                throw new InvalidConfigurationException(\"include directive in \" + dbPropertiesLoadedFrom + \" must have '::' between dbType and key\");\n            String refdType = include.substring(0, separator).trim();\n            String refdKey = include.substring(separator + 2).trim();\n            // recursively resolve the ref'd properties file and the ref'd key\n            Properties refdProps = determineDbProperties(refdType);\n            props.put(refdKey, refdProps.getProperty(refdKey));\n        }\n        // bring in base properties files pointed to by the extends directive\n        String baseDbType = (String) props.remove(\"extends\");\n        if (baseDbType != null) {\n            baseDbType = baseDbType.trim();\n            Properties baseProps = determineDbProperties(baseDbType);\n            // overlay our properties on top of the base's\n            baseProps.putAll(props);\n            props = baseProps;\n        }\n        // done with this level of recursion...restore original\n        dbPropertiesLoadedFrom = saveLoadedFrom;\n        // this won't be correct until the final recursion exits\n        dbProperties = props;\n        return props;\n    }\n\n    protected String getDbPropertiesLoadedFrom() throws IOException {\n        if (dbPropertiesLoadedFrom == null)\n            determineDbProperties(getDbType());\n        return dbPropertiesLoadedFrom;\n    }\n\n    public List<String> getRemainingParameters() {\n        try {\n            populate();\n        } catch (IllegalArgumentException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (IllegalAccessException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (InvocationTargetException exc) {\n            if (exc.getCause() instanceof InvalidConfigurationException)\n                throw (InvalidConfigurationException) exc.getCause();\n            throw new InvalidConfigurationException(exc.getCause());\n        } catch (IntrospectionException exc) {\n            throw new InvalidConfigurationException(exc);\n        }\n        return options;\n    }\n\n    /**\n     * Options that are specific to a type of database.  E.g. things like <code>host</code>,\n     * <code>port</code> or <code>db</code>, but <b>don't</b> have a setter in this class.\n     *\n     * @param dbSpecificOptions\n     */\n    public void setDbSpecificOptions(Map<String, String> dbSpecificOptions) {\n        this.dbSpecificOptions = dbSpecificOptions;\n        originalDbSpecificOptions = new HashMap<String, String>(dbSpecificOptions);\n    }\n\n    public Map<String, String> getDbSpecificOptions() {\n        if (dbSpecificOptions == null)\n            dbSpecificOptions = new HashMap<String, String>();\n        return dbSpecificOptions;\n    }\n\n    /**\n     * Returns a {@link Properties} populated with the contents of <code>bundle</code>\n     *\n     * @param bundle ResourceBundle\n     * @return Properties\n     */\n    public static Properties asProperties(ResourceBundle bundle) {\n        Properties props = new Properties();\n        Enumeration<String> iter = bundle.getKeys();\n        while (iter.hasMoreElements()) {\n            String key = iter.nextElement();\n            props.put(key, bundle.getObject(key));\n        }\n        return props;\n    }\n\n    /**\n     * 'Pull' the specified parameter from the collection of options. Returns\n     * null if the parameter isn't in the list and removes it if it is.\n     *\n     * @param paramId\n     * @return\n     */\n    private String pullParam(String paramId) {\n        return pullParam(paramId, false, false);\n    }\n\n    private String pullRequiredParam(String paramId) {\n        return pullParam(paramId, true, false);\n    }\n\n    /**\n     * @param paramId\n     * @param required\n     * @param dbTypeSpecific\n     * @return\n     * @throws MissingRequiredParameterException\n     */\n    private String pullParam(String paramId, boolean required, boolean dbTypeSpecific) throws MissingRequiredParameterException {\n        int paramIndex = options.indexOf(paramId);\n        if (paramIndex < 0) {\n            if (required)\n                throw new MissingRequiredParameterException(paramId, dbTypeSpecific);\n            return null;\n        }\n        options.remove(paramIndex);\n        String param = options.get(paramIndex).toString();\n        options.remove(paramIndex);\n        return param;\n    }\n\n    /**\n     * Thrown to indicate that a required parameter is missing\n     */\n    public static class MissingRequiredParameterException extends RuntimeException {\n\n        private static final long serialVersionUID = 1L;\n\n        private final boolean dbTypeSpecific;\n\n        public MissingRequiredParameterException(String paramId, boolean dbTypeSpecific) {\n            this(paramId, null, dbTypeSpecific);\n        }\n\n        public MissingRequiredParameterException(String paramId, String description, boolean dbTypeSpecific) {\n            super(\"Required parameter '\" + paramId + \"' \" + (description == null ? \"\" : \"(\" + description + \") \") + \"was not specified.\" + (dbTypeSpecific ? \"  It is required for this database type.\" : \"\"));\n            this.dbTypeSpecific = dbTypeSpecific;\n        }\n\n        public boolean isDbTypeSpecific() {\n            return dbTypeSpecific;\n        }\n    }\n\n    /**\n     * Allow an equal sign in args...like \"-o=foo.bar\". Useful for things like\n     * Ant and Maven.\n     *\n     * @param args\n     *            List\n     * @return List\n     */\n    protected List<String> fixupArgs(List<String> args) {\n        List<String> expandedArgs = new ArrayList<String>();\n        for (String arg : args) {\n            int indexOfEquals = arg.indexOf('=');\n            if (indexOfEquals != -1 && indexOfEquals - 1 != arg.indexOf(ESCAPED_EQUALS)) {\n                expandedArgs.add(arg.substring(0, indexOfEquals));\n                expandedArgs.add(arg.substring(indexOfEquals + 1));\n            } else {\n                expandedArgs.add(arg);\n            }\n        }\n        // some OSes/JVMs do filename expansion with runtime.exec() and some don't,\n        // so MultipleSchemaAnalyzer has to surround params with double quotes...\n        // strip them here for the OSes/JVMs that don't do anything with the params\n        List<String> unquotedArgs = new ArrayList<String>();\n        for (String arg : expandedArgs) {\n            if (// \".*\" becomes .*\n            arg.startsWith(\"\\\"\") && arg.endsWith(\"\\\"\"))\n                arg = arg.substring(1, arg.length() - 1);\n            unquotedArgs.add(arg);\n        }\n        return unquotedArgs;\n    }\n\n    /**\n     * Call all the getters to populate all the lazy initialized stuff.\n     *\n     * @throws InvocationTargetException\n     * @throws IllegalAccessException\n     * @throws IllegalArgumentException\n     * @throws IntrospectionException\n     */\n    private void populate() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IntrospectionException {\n        if (!populating) {\n            // prevent recursion\n            populating = true;\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                Method readMethod = props[i].getReadMethod();\n                if (readMethod != null)\n                    readMethod.invoke(this, (Object[]) null);\n            }\n            populating = false;\n        }\n    }\n\n    public static Set<String> getBuiltInDatabaseTypes(String loadedFromJar) {\n        Set<String> databaseTypes = new TreeSet<String>();\n        JarInputStream jar = null;\n        try {\n            jar = new JarInputStream(new FileInputStream(loadedFromJar));\n            JarEntry entry;\n            while ((entry = jar.getNextJarEntry()) != null) {\n                String entryName = entry.getName();\n                int dotPropsIndex = entryName.indexOf(\".properties\");\n                if (dotPropsIndex != -1)\n                    databaseTypes.add(entryName.substring(0, dotPropsIndex));\n            }\n        } catch (IOException exc) {\n        } finally {\n            if (jar != null) {\n                try {\n                    jar.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n        return databaseTypes;\n    }\n\n    protected void dumpUsage(String errorMessage, boolean detailedDb) {\n        if (errorMessage != null) {\n            System.out.flush();\n            System.err.println(\"*** \" + errorMessage + \" ***\");\n        } else {\n            System.out.println(\"SchemaSpy generates an HTML representation of a database schema's relationships.\");\n        }\n        System.err.flush();\n        System.out.println();\n        if (!detailedDb) {\n            System.out.println(\"Usage:\");\n            System.out.println(\" java -jar \" + getLoadedFromJar() + \" [options]\");\n            System.out.println(\"   -t databaseType       type of database - defaults to ora\");\n            System.out.println(\"                           use -dbhelp for a list of built-in types\");\n            System.out.println(\"   -u user               connect to the database with this user id\");\n            System.out.println(\"   -s schema             defaults to the specified user\");\n            System.out.println(\"   -p password           defaults to no password\");\n            System.out.println(\"   -o outputDirectory    directory to place the generated output in\");\n            System.out.println(\"   -dp pathToDrivers     optional - looks for JDBC drivers here before looking\");\n            System.out.println(\"                           in driverPath in [databaseType].properties.\");\n            System.out.println(\"Go to http://schemaspy.sourceforge.net for a complete list/description\");\n            System.out.println(\" of additional parameters.\");\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"Built-in database types and their required connection parameters:\");\n            for (String type : getBuiltInDatabaseTypes(getLoadedFromJar())) {\n                new DbSpecificConfig(type).dumpUsage();\n            }\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"You can use your own database types by specifying the filespec of a .properties file with -t.\");\n            System.out.println(\"Grab one out of \" + getLoadedFromJar() + \" and modify it to suit your needs.\");\n            System.out.println();\n        }\n        System.out.println(\"Sample usage using the default database type (implied -t ora):\");\n        System.out.println(\" java -jar schemaSpy.jar -db mydb -s myschema -u devuser -p password -o output\");\n        System.out.println();\n        System.out.flush();\n    }\n\n    /**\n     * Get the value of the specified parameter.\n     * Used for properties that are common to most db's, but aren't required.\n     *\n     * @param paramName\n     * @return\n     */\n    public String getParam(String paramName) {\n        try {\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                PropertyDescriptor prop = props[i];\n                if (prop.getName().equalsIgnoreCase(paramName)) {\n                    Object result = prop.getReadMethod().invoke(this, (Object[]) null);\n                    return result == null ? null : result.toString();\n                }\n            }\n        } catch (Exception failed) {\n            failed.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * Return all of the configuration options as a List of Strings, with\n     * each parameter and its value as a separate element.\n     *\n     * @return\n     * @throws IOException\n     */\n    public List<String> asList() throws IOException {\n        List<String> params = new ArrayList<String>();\n        if (originalDbSpecificOptions != null) {\n            for (String key : originalDbSpecificOptions.keySet()) {\n                String value = originalDbSpecificOptions.get(key);\n                if (!key.startsWith(\"-\"))\n                    key = \"-\" + key;\n                params.add(key);\n                params.add(value);\n            }\n        }\n        if (isEncodeCommentsEnabled())\n            params.add(\"-ahic\");\n        if (isEvaluateAllEnabled())\n            params.add(\"-all\");\n        if (!isHtmlGenerationEnabled())\n            params.add(\"-nohtml\");\n        if (!isImpliedConstraintsEnabled())\n            params.add(\"-noimplied\");\n        if (!isLogoEnabled())\n            params.add(\"-nologo\");\n        if (isMeterEnabled())\n            params.add(\"-meter\");\n        if (!isNumRowsEnabled())\n            params.add(\"-norows\");\n        if (!isViewsEnabled())\n            params.add(\"-noviews\");\n        if (isRankDirBugEnabled())\n            params.add(\"-rankdirbug\");\n        if (isRailsEnabled())\n            params.add(\"-rails\");\n        if (isSingleSignOn())\n            params.add(\"-sso\");\n        if (isSchemaDisabled())\n            params.add(\"-noschema\");\n        String value = getDriverPath();\n        if (value != null) {\n            params.add(\"-dp\");\n            params.add(value);\n        }\n        params.add(\"-css\");\n        params.add(getCss());\n        params.add(\"-charset\");\n        params.add(getCharset());\n        params.add(\"-font\");\n        params.add(getFont());\n        params.add(\"-fontsize\");\n        params.add(String.valueOf(getFontSize()));\n        params.add(\"-t\");\n        params.add(getDbType());\n        // query to set renderer correctly\n        isHighQuality();\n        // query to set renderer correctly\n        isLowQuality();\n        // instead of -hq and/or -lq\n        params.add(\"-renderer\");\n        params.add(getRenderer());\n        value = getDescription();\n        if (value != null) {\n            params.add(\"-desc\");\n            params.add(value);\n        }\n        value = getPassword();\n        if (value != null && !isPromptForPasswordEnabled()) {\n            // note that we don't pass -pfp since child processes\n            // won't have a console\n            params.add(\"-p\");\n            params.add(value);\n        }\n        value = getCatalog();\n        if (value != null) {\n            params.add(\"-cat\");\n            params.add(value);\n        }\n        value = getSchema();\n        if (value != null) {\n            params.add(\"-s\");\n            params.add(value);\n        }\n        value = getUser();\n        if (value != null) {\n            params.add(\"-u\");\n            params.add(value);\n        }\n        value = getConnectionPropertiesFile();\n        if (value != null) {\n            params.add(\"-connprops\");\n            params.add(value);\n        } else {\n            Properties props = getConnectionProperties();\n            if (!props.isEmpty()) {\n                params.add(\"-connprops\");\n                StringBuilder buf = new StringBuilder();\n                for (Entry<Object, Object> entry : props.entrySet()) {\n                    buf.append(entry.getKey());\n                    buf.append(ESCAPED_EQUALS);\n                    buf.append(entry.getValue());\n                    buf.append(';');\n                }\n                params.add(buf.toString());\n            }\n        }\n        value = getDb();\n        if (value != null) {\n            params.add(\"-db\");\n            params.add(value);\n        }\n        value = getHost();\n        if (value != null) {\n            params.add(\"-host\");\n            params.add(value);\n        }\n        if (getPort() != null) {\n            params.add(\"-port\");\n            params.add(getPort().toString());\n        }\n        value = getServer();\n        if (value != null) {\n            params.add(\"-server\");\n            params.add(value);\n        }\n        value = getMeta();\n        if (value != null) {\n            params.add(\"-meta\");\n            params.add(value);\n        }\n        if (getGraphvizDir() != null) {\n            params.add(\"-gv\");\n            params.add(getGraphvizDir().toString());\n        }\n        params.add(\"-loglevel\");\n        params.add(getLogLevel().toString().toLowerCase());\n        params.add(\"-sqlFormatter\");\n        params.add(getSqlFormatter().getClass().getName());\n        params.add(\"-i\");\n        params.add(getTableInclusions().toString());\n        params.add(\"-I\");\n        params.add(getTableExclusions().toString());\n        params.add(\"-X\");\n        params.add(getColumnExclusions().toString());\n        params.add(\"-x\");\n        params.add(getIndirectColumnExclusions().toString());\n        params.add(\"-dbthreads\");\n        params.add(String.valueOf(getMaxDbThreads()));\n        params.add(\"-maxdet\");\n        params.add(String.valueOf(getMaxDetailedTables()));\n        params.add(\"-o\");\n        params.add(getOutputDir().toString());\n        return params;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/ConfigTest12.java",
		"test_prompt": "// ConfigTest12.java\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Config}.\n* It contains ten unit test cases for the {@link Config#isMeterEnabled()} method.\n*/\nclass ConfigTest12 {"
	},
	{
		"original_code": "// Config.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\n\n/**\n * Configuration of a SchemaSpy run\n *\n * @author John Currier\n */\npublic class Config {\n\n    private static Config instance;\n\n    private final List<String> options;\n\n    private Map<String, String> dbSpecificOptions;\n\n    private Map<String, String> originalDbSpecificOptions;\n\n    private boolean helpRequired;\n\n    private boolean dbHelpRequired;\n\n    private File outputDir;\n\n    private File graphvizDir;\n\n    private String dbType;\n\n    private String catalog;\n\n    private String schema;\n\n    private List<String> schemas;\n\n    private String user;\n\n    private Boolean singleSignOn;\n\n    private Boolean noSchema;\n\n    private String password;\n\n    private Boolean promptForPassword;\n\n    private String db;\n\n    private String host;\n\n    private Integer port;\n\n    private String server;\n\n    private String meta;\n\n    private Pattern tableInclusions;\n\n    private Pattern tableExclusions;\n\n    private Pattern columnExclusions;\n\n    private Pattern indirectColumnExclusions;\n\n    private String userConnectionPropertiesFile;\n\n    private Properties userConnectionProperties;\n\n    private Integer maxDbThreads;\n\n    private Integer maxDetailedTables;\n\n    private String driverPath;\n\n    private String css;\n\n    private String charset;\n\n    private String font;\n\n    private Integer fontSize;\n\n    private String description;\n\n    private Properties dbProperties;\n\n    private String dbPropertiesLoadedFrom;\n\n    private Level logLevel;\n\n    private SqlFormatter sqlFormatter;\n\n    private String sqlFormatterClass;\n\n    private Boolean generateHtml;\n\n    private Boolean includeImpliedConstraints;\n\n    private Boolean logoEnabled;\n\n    private Boolean rankDirBugEnabled;\n\n    private Boolean encodeCommentsEnabled;\n\n    private Boolean numRowsEnabled;\n\n    private Boolean viewsEnabled;\n\n    private Boolean meterEnabled;\n\n    private Boolean railsEnabled;\n\n    private Boolean evaluteAll;\n\n    private Boolean highQuality;\n\n    private Boolean lowQuality;\n\n    // used in conjunction with evaluateAll\n    private String schemaSpec;\n\n    private boolean hasOrphans = false;\n\n    private boolean hasRoutines = false;\n\n    private boolean populating = false;\n\n    private List<String> columnDetails;\n\n    public static final String DOT_CHARSET = \"UTF-8\";\n\n    private static final String ESCAPED_EQUALS = \"\\\\=\";\n\n    // match everything\n    private static final String DEFAULT_TABLE_INCLUSION = \".*\";\n\n    // match nothing\n    private static final String DEFAULT_TABLE_EXCLUSION = \"\";\n\n    // match nothing\n    private static final String DEFAULT_COLUMN_EXCLUSION = \"[^.]\";\n\n    /**\n     * Default constructor. Intended for when you want to inject properties\n     * independently (i.e. not from a command line interface).\n     */\n    public Config() {\n        if (instance == null)\n            setInstance(this);\n        options = new ArrayList<String>();\n    }\n\n    /**\n     * Construct a configuration from an array of options (e.g. from a command\n     * line interface).\n     *\n     * @param options\n     */\n    public Config(String[] argv) {\n        setInstance(this);\n        options = fixupArgs(Arrays.asList(argv));\n        helpRequired = options.remove(\"-?\") || options.remove(\"/?\") || options.remove(\"?\") || options.remove(\"-h\") || options.remove(\"-help\") || options.remove(\"--help\");\n        dbHelpRequired = options.remove(\"-dbHelp\") || options.remove(\"-dbhelp\");\n    }\n\n    public static Config getInstance() {\n        if (instance == null)\n            instance = new Config();\n        return instance;\n    }\n\n    /**\n     * Sets the global instance.\n     *\n     * Useful for things like selecting a specific configuration in a UI.\n     *\n     * @param config\n     */\n    public static void setInstance(Config config) {\n        instance = config;\n    }\n\n    public void setHtmlGenerationEnabled(boolean generateHtml) {\n        this.generateHtml = generateHtml;\n    }\n\n    public boolean isHtmlGenerationEnabled() {\n        if (generateHtml == null)\n            generateHtml = !options.remove(\"-nohtml\");\n        return generateHtml;\n    }\n\n    public void setImpliedConstraintsEnabled(boolean includeImpliedConstraints) {\n        this.includeImpliedConstraints = includeImpliedConstraints;\n    }\n\n    public boolean isImpliedConstraintsEnabled() {\n        if (includeImpliedConstraints == null)\n            includeImpliedConstraints = !options.remove(\"-noimplied\");\n        return includeImpliedConstraints;\n    }\n\n    public void setOutputDir(String outputDirName) {\n        if (outputDirName.endsWith(\"\\\"\"))\n            outputDirName = outputDirName.substring(0, outputDirName.length() - 1);\n        setOutputDir(new File(outputDirName));\n    }\n\n    public void setOutputDir(File outputDir) {\n        this.outputDir = outputDir;\n    }\n\n    public File getOutputDir() {\n        if (outputDir == null) {\n            setOutputDir(pullRequiredParam(\"-o\"));\n        }\n        return outputDir;\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(String graphvizDir) {\n        if (graphvizDir.endsWith(\"\\\"\"))\n            graphvizDir = graphvizDir.substring(0, graphvizDir.length() - 1);\n        setGraphvizDir(new File(graphvizDir));\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(File graphvizDir) {\n        this.graphvizDir = graphvizDir;\n    }\n\n    /**\n     * Return the path to Graphviz (used to find the dot executable to run to\n     * generate ER diagrams).<p/>\n     *\n     * Returns {@link #getDefaultGraphvizPath()} if a specific Graphviz path\n     * was not specified.\n     *\n     * @return\n     */\n    public File getGraphvizDir() {\n        if (graphvizDir == null) {\n            String gv = pullParam(\"-gv\");\n            if (gv != null) {\n                setGraphvizDir(gv);\n            } else {\n                // expect to find Graphviz's bin directory on the PATH\n            }\n        }\n        return graphvizDir;\n    }\n\n    /**\n     * Meta files are XML-based files that provide additional metadata\n     * about the schema being evaluated.<p>\n     * <code>meta</code> is either the name of an individual XML file or\n     * the directory that contains meta files.<p>\n     * If a directory is specified then it is expected to contain files\n     * matching the pattern <code>[schema].meta.xml</code>.\n     * For databases that don't have schema substitute database for schema.\n     * @param meta\n     */\n    public void setMeta(String meta) {\n        this.meta = meta;\n    }\n\n    public String getMeta() {\n        if (meta == null)\n            meta = pullParam(\"-meta\");\n        return meta;\n    }\n\n    public void setDbType(String dbType) {\n        this.dbType = dbType;\n    }\n\n    public String getDbType() {\n        if (dbType == null) {\n            dbType = pullParam(\"-t\");\n            if (dbType == null)\n                dbType = \"ora\";\n        }\n        return dbType;\n    }\n\n    public void setDb(String db) {\n        this.db = db;\n    }\n\n    public String getDb() {\n        if (db == null)\n            db = pullParam(\"-db\");\n        return db;\n    }\n\n    public void setCatalog(String catalog) {\n        this.catalog = catalog;\n    }\n\n    public String getCatalog() {\n        if (catalog == null)\n            catalog = pullParam(\"-cat\");\n        return catalog;\n    }\n\n    public void setSchema(String schema) {\n        this.schema = schema;\n    }\n\n    public String getSchema() {\n        if (schema == null)\n            schema = pullParam(\"-s\");\n        return schema;\n    }\n\n    /**\n     * Some databases types (e.g. older versions of Informix) don't really\n     * have the concept of a schema but still return true from\n     * {@link DatabaseMetaData#supportsSchemasInTableDefinitions()}.\n     * This option lets you ignore that and treat all the tables\n     * as if they were in one flat namespace.\n     */\n    public boolean isSchemaDisabled() {\n        if (noSchema == null)\n            noSchema = options.remove(\"-noschema\");\n        return noSchema;\n    }\n\n    public void setHost(String host) {\n        this.host = host;\n    }\n\n    public String getHost() {\n        if (host == null)\n            host = pullParam(\"-host\");\n        return host;\n    }\n\n    public void setPort(Integer port) {\n        this.port = port;\n    }\n\n    public Integer getPort() {\n        if (port == null)\n            try {\n                port = Integer.valueOf(pullParam(\"-port\"));\n            } catch (Exception notSpecified) {\n            }\n        return port;\n    }\n\n    public void setServer(String server) {\n        this.server = server;\n    }\n\n    public String getServer() {\n        if (server == null) {\n            server = pullParam(\"-server\");\n        }\n        return server;\n    }\n\n    public void setUser(String user) {\n        this.user = user;\n    }\n\n    /**\n     * User used to connect to the database.\n     * Required unless single sign-on is enabled\n     * (see {@link #setSingleSignOn(boolean)}).\n     * @return\n     */\n    public String getUser() {\n        if (user == null) {\n            if (!isSingleSignOn())\n                user = pullRequiredParam(\"-u\");\n            else\n                user = pullParam(\"-u\");\n        }\n        return user;\n    }\n\n    /**\n     * By default a \"user\" (as specified with -u) is required.\n     * This option allows disabling of that requirement for\n     * single sign-on environments.\n     *\n     * @param enabled defaults to <code>false</code>\n     */\n    public void setSingleSignOn(boolean enabled) {\n        singleSignOn = enabled;\n    }\n\n    /**\n     * @see #setSingleSignOn(boolean)\n     */\n    public boolean isSingleSignOn() {\n        if (singleSignOn == null)\n            singleSignOn = options.remove(\"-sso\");\n        return singleSignOn;\n    }\n\n    /**\n     * Set the password used to connect to the database.\n     * @param password\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * @see #setPassword(String)\n     * @return\n     */\n    public String getPassword() {\n        if (password == null)\n            password = pullParam(\"-p\");\n        if (password == null && isPromptForPasswordEnabled())\n            password = new String(PasswordReader.getInstance().readPassword(\"Password: \"));\n        if (password == null) {\n            // if -pfp is enabled when analyzing multiple schemas then\n            // we don't want to send the password on the command line,\n            // so see if it was passed in the environment (not ideal, but safer)\n            password = System.getenv(\"schemaspy.pw\");\n        }\n        return password;\n    }\n\n    /**\n     * Set to <code>true</code> to prompt for the password\n     * @param promptForPassword\n     */\n    public void setPromptForPasswordEnabled(boolean promptForPassword) {\n        this.promptForPassword = promptForPassword;\n    }\n\n    /**\n     * @see #setPromptForPasswordEnabled(boolean)\n     * @return\n     */\n    public boolean isPromptForPasswordEnabled() {\n        if (promptForPassword == null) {\n            promptForPassword = options.remove(\"-pfp\");\n        }\n        return promptForPassword;\n    }\n\n    public void setMaxDetailedTabled(int maxDetailedTables) {\n        this.maxDetailedTables = new Integer(maxDetailedTables);\n    }\n\n    public int getMaxDetailedTables() {\n        if (maxDetailedTables == null) {\n            // default\n            int max = 300;\n            try {\n                max = Integer.parseInt(pullParam(\"-maxdet\"));\n            } catch (Exception notSpecified) {\n            }\n            maxDetailedTables = new Integer(max);\n        }\n        return maxDetailedTables.intValue();\n    }\n\n    public String getConnectionPropertiesFile() {\n        return userConnectionPropertiesFile;\n    }\n\n    /**\n     * Properties from this file (in key=value pair format) are passed to the\n     * database connection.<br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.\n     * @param propertiesFilename\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public void setConnectionPropertiesFile(String propertiesFilename) throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null)\n            userConnectionProperties = new Properties();\n        userConnectionProperties.load(new FileInputStream(propertiesFilename));\n        userConnectionPropertiesFile = propertiesFilename;\n    }\n\n    /**\n     * Returns a {@link Properties} populated either from the properties file specified\n     * by {@link #setConnectionPropertiesFile(String)}, the properties specified by\n     * {@link #setConnectionProperties(String)} or not populated.\n     * @return\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public Properties getConnectionProperties() throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null) {\n            String props = pullParam(\"-connprops\");\n            if (props != null) {\n                if (props.indexOf(ESCAPED_EQUALS) != -1) {\n                    setConnectionProperties(props);\n                } else {\n                    setConnectionPropertiesFile(props);\n                }\n            } else {\n                userConnectionProperties = new Properties();\n            }\n        }\n        return userConnectionProperties;\n    }\n\n    /**\n     * Specifies connection properties to use in the format:\n     * <code>key1\\=value1;key2\\=value2</code><br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.<p>\n     * This is an alternative form of passing connection properties than by file\n     * (see {@link #setConnectionPropertiesFile(String)})\n     *\n     * @param properties\n     */\n    public void setConnectionProperties(String properties) {\n        userConnectionProperties = new Properties();\n        StringTokenizer tokenizer = new StringTokenizer(properties, \";\");\n        while (tokenizer.hasMoreElements()) {\n            String pair = tokenizer.nextToken();\n            int index = pair.indexOf(ESCAPED_EQUALS);\n            if (index != -1) {\n                String key = pair.substring(0, index);\n                String value = pair.substring(index + ESCAPED_EQUALS.length());\n                userConnectionProperties.put(key, value);\n            }\n        }\n    }\n\n    public void setDriverPath(String driverPath) {\n        this.driverPath = driverPath;\n    }\n\n    public String getDriverPath() {\n        if (driverPath == null)\n            driverPath = pullParam(\"-dp\");\n        // was previously -cp:\n        if (driverPath == null)\n            driverPath = pullParam(\"-cp\");\n        return driverPath;\n    }\n\n    /**\n     * The filename of the cascading style sheet to use.\n     * Note that this file is parsed and used to determine characteristics\n     * of the generated diagrams, so it must contain specific settings that\n     * are documented within schemaSpy.css.<p>\n     *\n     * Defaults to <code>\"schemaSpy.css\"</code>.\n     *\n     * @param css\n     */\n    public void setCss(String css) {\n        this.css = css;\n    }\n\n    public String getCss() {\n        if (css == null) {\n            css = pullParam(\"-css\");\n            if (css == null)\n                css = \"schemaSpy.css\";\n        }\n        return css;\n    }\n\n    /**\n     * The font to use within diagrams.  Modify the .css to specify HTML fonts.\n     *\n     * @param font\n     */\n    public void setFont(String font) {\n        this.font = font;\n    }\n\n    /**\n     * @see #setFont(String)\n     */\n    public String getFont() {\n        if (font == null) {\n            font = pullParam(\"-font\");\n            if (font == null)\n                font = \"Helvetica\";\n        }\n        return font;\n    }\n\n    /**\n     * The font size to use within diagrams.  This is the size of the font used for\n     * 'large' (e.g. not 'compact') diagrams.<p>\n     *\n     * Modify the .css to specify HTML font sizes.<p>\n     *\n     * Defaults to 11.\n     *\n     * @param fontSize\n     */\n    public void setFontSize(int fontSize) {\n        this.fontSize = new Integer(fontSize);\n    }\n\n    /**\n     * @see #setFontSize(int)\n     * @return\n     */\n    public int getFontSize() {\n        if (fontSize == null) {\n            // default\n            int size = 11;\n            try {\n                size = Integer.parseInt(pullParam(\"-fontsize\"));\n            } catch (Exception notSpecified) {\n            }\n            fontSize = new Integer(size);\n        }\n        return fontSize.intValue();\n    }\n\n    /**\n     * The character set to use within HTML pages (defaults to <code>\"ISO-8859-1\"</code>).\n     *\n     * @param charset\n     */\n    public void setCharset(String charset) {\n        this.charset = charset;\n    }\n\n    /**\n     * @see #setCharset(String)\n     */\n    public String getCharset() {\n        if (charset == null) {\n            charset = pullParam(\"-charset\");\n            if (charset == null)\n                charset = \"ISO-8859-1\";\n        }\n        return charset;\n    }\n\n    /**\n     * Description of schema that gets display on main pages.\n     *\n     * @param description\n     */\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    /**\n     * @see #setDescription(String)\n     */\n    public String getDescription() {\n        if (description == null)\n            description = pullParam(\"-desc\");\n        return description;\n    }\n\n    /**\n     * Maximum number of threads to use when querying database metadata information.\n     *\n     * @param maxDbThreads\n     */\n    public void setMaxDbThreads(int maxDbThreads) {\n        this.maxDbThreads = new Integer(maxDbThreads);\n    }\n\n    /**\n     * @see #setMaxDbThreads(int)\n     * @throws InvalidConfigurationException if unable to load properties\n     */\n    public int getMaxDbThreads() throws InvalidConfigurationException {\n        if (maxDbThreads == null) {\n            Properties properties;\n            try {\n                properties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(\"Failed to load properties for \" + getDbType() + \": \" + exc).setParamName(\"-type\");\n            }\n            // not scientifically derived\n            final int defaultMax = 15;\n            int max = defaultMax;\n            String threads = properties.getProperty(\"dbThreads\");\n            if (threads == null)\n                threads = properties.getProperty(\"dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            threads = pullParam(\"-dbThreads\");\n            if (threads == null)\n                threads = pullParam(\"-dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            if (max < 0)\n                max = defaultMax;\n            else if (max == 0)\n                max = 1;\n            maxDbThreads = new Integer(max);\n        }\n        return maxDbThreads.intValue();\n    }\n\n    public boolean isLogoEnabled() {\n        if (logoEnabled == null)\n            logoEnabled = !options.remove(\"-nologo\");\n        return logoEnabled;\n    }\n\n    /**\n     * Don't use this unless absolutely necessary as it screws up the layout\n     *\n     * @param enabled\n     */\n    public void setRankDirBugEnabled(boolean enabled) {\n        rankDirBugEnabled = enabled;\n    }\n\n    /**\n     * @see #setRankDirBugEnabled(boolean)\n     */\n    public boolean isRankDirBugEnabled() {\n        if (rankDirBugEnabled == null)\n            rankDirBugEnabled = options.remove(\"-rankdirbug\");\n        return rankDirBugEnabled;\n    }\n\n    /**\n     * Look for Ruby on Rails-based naming conventions in\n     * relationships between logical foreign keys and primary keys.<p>\n     *\n     * Basically all tables have a primary key named <code>ID</code>.\n     * All tables are named plural names.\n     * The columns that logically reference that <code>ID</code> are the singular\n     * form of the table name suffixed with <code>_ID</code>.<p>\n     *\n     * @param enabled\n     */\n    public void setRailsEnabled(boolean enabled) {\n        railsEnabled = enabled;\n    }\n\n    /**\n     * @see #setRailsEnabled(boolean)\n     *\n     * @return\n     */\n    public boolean isRailsEnabled() {\n        if (railsEnabled == null)\n            railsEnabled = options.remove(\"-rails\");\n        return railsEnabled;\n    }\n\n    /**\n     * Allow Html In Comments - encode them unless otherwise specified\n     */\n    public void setEncodeCommentsEnabled(boolean enabled) {\n        encodeCommentsEnabled = enabled;\n    }\n\n    /**\n     * @see #setEncodeCommentsEnabled(boolean)\n     */\n    public boolean isEncodeCommentsEnabled() {\n        if (encodeCommentsEnabled == null)\n            encodeCommentsEnabled = !options.remove(\"-ahic\");\n        return encodeCommentsEnabled;\n    }\n\n    /**\n     * If enabled we'll attempt to query/render the number of rows that\n     * each table contains.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setNumRowsEnabled(boolean enabled) {\n        numRowsEnabled = enabled;\n    }\n\n    /**\n     * @see #setNumRowsEnabled(boolean)\n     * @return\n     */\n    public boolean isNumRowsEnabled() {\n        if (numRowsEnabled == null)\n            numRowsEnabled = !options.remove(\"-norows\");\n        return numRowsEnabled;\n    }\n\n    /**\n     * If enabled we'll include views in the analysis.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setViewsEnabled(boolean enabled) {\n        viewsEnabled = enabled;\n    }\n\n    /**\n     * @see #setViewsEnabled(boolean)\n     * @return\n     */\n    public boolean isViewsEnabled() {\n        if (viewsEnabled == null)\n            viewsEnabled = !options.remove(\"-noviews\");\n        return viewsEnabled;\n    }\n\n    /**\n     * Returns <code>true</code> if metering should be embedded in\n     * the generated pages.<p/>\n     * Defaults to <code>false</code> (disabled).\n     * @return\n     */\n    public boolean isMeterEnabled() {\n        if (meterEnabled == null)\n            meterEnabled = options.remove(\"-meter\");\n        return meterEnabled;\n    }\n\n    /**\n     * Set the columns to exclude from all relationship diagrams.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setColumnExclusions(String columnExclusions) {\n        this.columnExclusions = Pattern.compile(columnExclusions);\n    }\n\n    /**\n     * See {@link #setColumnExclusions(String)}\n     * @return\n     */\n    public Pattern getColumnExclusions() {\n        if (columnExclusions == null) {\n            String strExclusions = pullParam(\"-X\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.columnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            columnExclusions = Pattern.compile(strExclusions);\n        }\n        return columnExclusions;\n    }\n\n    /**\n     * Set the columns to exclude from relationship diagrams where the specified\n     * columns aren't directly referenced by the focal table.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setIndirectColumnExclusions(String fullColumnExclusions) {\n        indirectColumnExclusions = Pattern.compile(fullColumnExclusions);\n    }\n\n    /**\n     * @see #setIndirectColumnExclusions(String)\n     *\n     * @return\n     */\n    public Pattern getIndirectColumnExclusions() {\n        if (indirectColumnExclusions == null) {\n            String strExclusions = pullParam(\"-x\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.indirectColumnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            indirectColumnExclusions = Pattern.compile(strExclusions);\n        }\n        return indirectColumnExclusions;\n    }\n\n    /**\n     * Set the tables to include as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableInclusions(String tableInclusions) {\n        this.tableInclusions = Pattern.compile(tableInclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to include in the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableInclusions() {\n        if (tableInclusions == null) {\n            String strInclusions = pullParam(\"-i\");\n            if (strInclusions == null)\n                strInclusions = System.getenv(\"schemaspy.tableInclusions\");\n            if (strInclusions == null)\n                strInclusions = DEFAULT_TABLE_INCLUSION;\n            try {\n                tableInclusions = Pattern.compile(strInclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-i\");\n            }\n        }\n        return tableInclusions;\n    }\n\n    /**\n     * Set the tables to exclude as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableExclusions(String tableExclusions) {\n        this.tableExclusions = Pattern.compile(tableExclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to exclude from the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableExclusions() {\n        if (tableExclusions == null) {\n            String strExclusions = pullParam(\"-I\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.tableExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_TABLE_EXCLUSION;\n            try {\n                tableExclusions = Pattern.compile(strExclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-I\");\n            }\n        }\n        return tableExclusions;\n    }\n\n    /**\n     * @return\n     */\n    public List<String> getSchemas() {\n        if (schemas == null) {\n            String tmp = pullParam(\"-schemas\");\n            if (tmp == null)\n                tmp = pullParam(\"-schemata\");\n            if (tmp != null) {\n                schemas = new ArrayList<String>();\n                for (String name : tmp.split(\"[\\\\s,'\\\"]\")) {\n                    if (name.length() > 0)\n                        schemas.add(name);\n                }\n                if (schemas.isEmpty())\n                    schemas = null;\n            }\n        }\n        return schemas;\n    }\n\n    /**\n     * Set the name of the {@link SqlFormatter SQL formatter} class to use to\n     * format SQL into HTML.<p/>\n     * The implementation of the class must be made available to the class\n     * loader, typically by specifying the path to its jar with <em>-dp</em>\n     * ({@link #setDriverPath(String)}).\n     */\n    public void setSqlFormatter(String formatterClassName) {\n        sqlFormatterClass = formatterClassName;\n        sqlFormatter = null;\n    }\n\n    /**\n     * Set the {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.\n     */\n    public void setSqlFormatter(SqlFormatter sqlFormatter) {\n        this.sqlFormatter = sqlFormatter;\n        if (sqlFormatter != null)\n            sqlFormatterClass = sqlFormatter.getClass().getName();\n    }\n\n    /**\n     * Returns an implementation of {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.  The default implementation is {@link DefaultSqlFormatter}.\n     *\n     * @return\n     * @throws InvalidConfigurationException if unable to instantiate an instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SqlFormatter getSqlFormatter() throws InvalidConfigurationException {\n        if (sqlFormatter == null) {\n            if (sqlFormatterClass == null) {\n                sqlFormatterClass = pullParam(\"-sqlFormatter\");\n                if (sqlFormatterClass == null)\n                    sqlFormatterClass = DefaultSqlFormatter.class.getName();\n            }\n            try {\n                Class<SqlFormatter> clazz = (Class<SqlFormatter>) Class.forName(sqlFormatterClass);\n                sqlFormatter = clazz.newInstance();\n            } catch (Exception exc) {\n                throw new InvalidConfigurationException(\"Failed to initialize instance of SQL formatter: \", exc).setParamName(\"-sqlFormatter\");\n            }\n        }\n        return sqlFormatter;\n    }\n\n    /**\n     * Set the details to show on the columns page, where \"details\" are\n     * comma and/or space separated.\n     *\n     * Valid values:\n     * <ul>\n     * <li>id</li>\n     * <li>table</li>\n     * <li>column</li>\n     * <li>type</li>\n     * <li>size</li>\n     * <li>nulls</li>\n     * <li>auto</li>\n     * <li>default</li>\n     * <li>children</li>\n     * <li>parents</li>\n     * </ul>\n     *\n     * The default details are <code>\"table column type size nulls auto default\"</code>.\n     * Note that \"column\" is the initially displayed detail and must be included.\n     *\n     * @param columnDetails\n     */\n    public void setColumnDetails(String columnDetails) {\n        this.columnDetails = new ArrayList<String>();\n        if (columnDetails == null || columnDetails.length() == 0) {\n            // not specified, so use defaults\n            columnDetails = \"id table column type size nulls auto default\";\n        }\n        for (String detail : columnDetails.split(\"[\\\\s,'\\\"]\")) {\n            if (detail.length() > 0) {\n                this.columnDetails.add(detail.toLowerCase());\n            }\n        }\n        if (!this.columnDetails.contains(\"column\"))\n            throw new InvalidConfigurationException(\"'column' is a required column detail\");\n    }\n\n    public void setColumnDetails(List<String> columnDetails) {\n        String details = columnDetails == null ? \"[]\" : columnDetails.toString();\n        setColumnDetails(details.substring(1, details.length() - 1));\n    }\n\n    public List<String> getColumnDetails() {\n        if (columnDetails == null) {\n            setColumnDetails(pullParam(\"-columndetails\"));\n        }\n        return columnDetails;\n    }\n\n    public void setEvaluateAllEnabled(boolean enabled) {\n        evaluteAll = enabled;\n    }\n\n    public boolean isEvaluateAllEnabled() {\n        if (evaluteAll == null)\n            evaluteAll = options.remove(\"-all\");\n        return evaluteAll;\n    }\n\n    /**\n     * Returns true if we're evaluating a bunch of schemas in one go and\n     * at this point we're evaluating a specific schema.\n     *\n     * @return boolean\n     */\n    public boolean isOneOfMultipleSchemas() {\n        // set by MultipleSchemaAnalyzer\n        return Boolean.getBoolean(\"oneofmultipleschemas\");\n    }\n\n    /**\n     * When -all (evaluateAll) is specified then this is the regular\n     * expression that determines which schemas to evaluate.\n     *\n     * @param schemaSpec\n     */\n    public void setSchemaSpec(String schemaSpec) {\n        this.schemaSpec = schemaSpec;\n    }\n\n    public String getSchemaSpec() {\n        if (schemaSpec == null)\n            schemaSpec = pullParam(\"-schemaSpec\");\n        return schemaSpec;\n    }\n\n    /**\n     * Set the renderer to use for the -Tpng[:renderer[:formatter]] dot option as specified\n     * at <a href='http://www.graphviz.org/doc/info/command.html'>\n     * http://www.graphviz.org/doc/info/command.html</a>.<p>\n     * Note that the leading \":\" is required while :formatter is optional.<p>\n     * The default renderer is typically GD.<p>\n     * Note that using {@link #setHighQuality(boolean)} is the preferred approach\n     * over using this method.\n     */\n    public void setRenderer(String renderer) {\n        Dot.getInstance().setRenderer(renderer);\n    }\n\n    /**\n     * @see #setRenderer(String)\n     * @return\n     */\n    public String getRenderer() {\n        String renderer = pullParam(\"-renderer\");\n        if (renderer != null)\n            setRenderer(renderer);\n        return Dot.getInstance().getRenderer();\n    }\n\n    /**\n     * If <code>false</code> then generate output of \"lower quality\"\n     * than the default.\n     * Note that the default is intended to be \"higher quality\",\n     * but various installations of Graphviz may have have different abilities.\n     * That is, some might not have the \"lower quality\" libraries and others might\n     * not have the \"higher quality\" libraries.<p>\n     * Higher quality output takes longer to generate and results in significantly\n     * larger image files (which take longer to download / display), but it generally\n     * looks better.\n     */\n    public void setHighQuality(boolean highQuality) {\n        this.highQuality = highQuality;\n        lowQuality = !highQuality;\n        Dot.getInstance().setHighQuality(highQuality);\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isHighQuality() {\n        if (highQuality == null) {\n            highQuality = options.remove(\"-hq\");\n            if (highQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(highQuality);\n            }\n        }\n        highQuality = Dot.getInstance().isHighQuality();\n        return highQuality;\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isLowQuality() {\n        if (lowQuality == null) {\n            lowQuality = options.remove(\"-lq\");\n            if (lowQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(!lowQuality);\n            }\n        }\n        lowQuality = !Dot.getInstance().isHighQuality();\n        return lowQuality;\n    }\n\n    /**\n     * Set the level of logging to perform.<p/>\n     * The levels in descending order are:\n     * <ul>\n     *  <li><code>severe</code> (highest - least detail)\n     *  <li><code>warning</code> (default)\n     *  <li><code>info</code>\n     *  <li><code>config</code>\n     *  <li><code>fine</code>\n     *  <li><code>finer</code>\n     *  <li><code>finest</code>  (lowest - most detail)\n     * </ul>\n     *\n     * @param logLevel\n     */\n    public void setLogLevel(String logLevel) {\n        if (logLevel == null) {\n            this.logLevel = Level.WARNING;\n            return;\n        }\n        Map<String, Level> levels = new LinkedHashMap<String, Level>();\n        levels.put(\"severe\", Level.SEVERE);\n        levels.put(\"warning\", Level.WARNING);\n        levels.put(\"info\", Level.INFO);\n        levels.put(\"config\", Level.CONFIG);\n        levels.put(\"fine\", Level.FINE);\n        levels.put(\"finer\", Level.FINER);\n        levels.put(\"finest\", Level.FINEST);\n        this.logLevel = levels.get(logLevel.toLowerCase());\n        if (this.logLevel == null) {\n            throw new InvalidConfigurationException(\"Invalid logLevel: '\" + logLevel + \"'. Must be one of: \" + levels.keySet());\n        }\n    }\n\n    /**\n     * Returns the level of logging to perform.\n     * See {@link #setLogLevel(String)}.\n     *\n     * @return\n     */\n    public Level getLogLevel() {\n        if (logLevel == null) {\n            setLogLevel(pullParam(\"-loglevel\"));\n        }\n        return logLevel;\n    }\n\n    /**\n     * Returns <code>true</code> if the options indicate that the user wants\n     * to see some help information.\n     *\n     * @return\n     */\n    public boolean isHelpRequired() {\n        return helpRequired;\n    }\n\n    public boolean isDbHelpRequired() {\n        return dbHelpRequired;\n    }\n\n    /**\n     * Returns the jar that we were loaded from\n     *\n     * @return\n     */\n    public static String getLoadedFromJar() {\n        String classpath = System.getProperty(\"java.class.path\");\n        return new StringTokenizer(classpath, File.pathSeparator).nextToken();\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasOrphans(boolean hasOrphans) {\n        this.hasOrphans = hasOrphans;\n    }\n\n    /**\n     * @see #setHasOrphans()\n     *\n     * @return\n     */\n    public boolean hasOrphans() {\n        return hasOrphans;\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasRoutines(boolean hasRoutines) {\n        this.hasRoutines = hasRoutines;\n    }\n\n    /**\n     * @see #setHasRoutines()\n     *\n     * @return\n     */\n    public boolean hasRoutines() {\n        return hasRoutines;\n    }\n\n    /**\n     * Returns the database properties to use.\n     * These should be determined by calling {@link #determineDbProperties(String)}.\n     * @return\n     * @throws InvalidConfigurationException\n     */\n    public Properties getDbProperties() throws InvalidConfigurationException {\n        if (dbProperties == null) {\n            try {\n                dbProperties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(exc);\n            }\n        }\n        return dbProperties;\n    }\n\n    /**\n     * Determines the database properties associated with the specified type.\n     * A call to {@link #setDbProperties(Properties)} is expected after determining\n     * the complete set of properties.\n     *\n     * @param type\n     * @return\n     * @throws IOException\n     * @throws InvalidConfigurationException if db properties are incorrectly formed\n     */\n    public Properties determineDbProperties(String type) throws IOException, InvalidConfigurationException {\n        ResourceBundle bundle = null;\n        try {\n            File propertiesFile = new File(type);\n            bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n            dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n        } catch (FileNotFoundException notFoundOnFilesystemWithoutExtension) {\n            try {\n                File propertiesFile = new File(type + \".properties\");\n                bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n                dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n            } catch (FileNotFoundException notFoundOnFilesystemWithExtensionTackedOn) {\n                try {\n                    bundle = ResourceBundle.getBundle(type);\n                    dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]\" + File.separator + type + \".properties\";\n                } catch (Exception notInJarWithoutPath) {\n                    try {\n                        String path = TableOrderer.class.getPackage().getName() + \".dbTypes.\" + type;\n                        path = path.replace('.', '/');\n                        bundle = ResourceBundle.getBundle(path);\n                        dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]/\" + path + \".properties\";\n                    } catch (Exception notInJar) {\n                        notInJar.printStackTrace();\n                        notFoundOnFilesystemWithExtensionTackedOn.printStackTrace();\n                        throw notFoundOnFilesystemWithoutExtension;\n                    }\n                }\n            }\n        }\n        Properties props = asProperties(bundle);\n        bundle = null;\n        // keep original thru recursion\n        String saveLoadedFrom = dbPropertiesLoadedFrom;\n        // bring in key/values pointed to by the include directive\n        // example: include.1=mysql::selectRowCountSql\n        for (int i = 1; true; ++i) {\n            String include = (String) props.remove(\"include.\" + i);\n            if (include == null)\n                break;\n            int separator = include.indexOf(\"::\");\n            if (separator == -1)\n                throw new InvalidConfigurationException(\"include directive in \" + dbPropertiesLoadedFrom + \" must have '::' between dbType and key\");\n            String refdType = include.substring(0, separator).trim();\n            String refdKey = include.substring(separator + 2).trim();\n            // recursively resolve the ref'd properties file and the ref'd key\n            Properties refdProps = determineDbProperties(refdType);\n            props.put(refdKey, refdProps.getProperty(refdKey));\n        }\n        // bring in base properties files pointed to by the extends directive\n        String baseDbType = (String) props.remove(\"extends\");\n        if (baseDbType != null) {\n            baseDbType = baseDbType.trim();\n            Properties baseProps = determineDbProperties(baseDbType);\n            // overlay our properties on top of the base's\n            baseProps.putAll(props);\n            props = baseProps;\n        }\n        // done with this level of recursion...restore original\n        dbPropertiesLoadedFrom = saveLoadedFrom;\n        // this won't be correct until the final recursion exits\n        dbProperties = props;\n        return props;\n    }\n\n    protected String getDbPropertiesLoadedFrom() throws IOException {\n        if (dbPropertiesLoadedFrom == null)\n            determineDbProperties(getDbType());\n        return dbPropertiesLoadedFrom;\n    }\n\n    public List<String> getRemainingParameters() {\n        try {\n            populate();\n        } catch (IllegalArgumentException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (IllegalAccessException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (InvocationTargetException exc) {\n            if (exc.getCause() instanceof InvalidConfigurationException)\n                throw (InvalidConfigurationException) exc.getCause();\n            throw new InvalidConfigurationException(exc.getCause());\n        } catch (IntrospectionException exc) {\n            throw new InvalidConfigurationException(exc);\n        }\n        return options;\n    }\n\n    /**\n     * Options that are specific to a type of database.  E.g. things like <code>host</code>,\n     * <code>port</code> or <code>db</code>, but <b>don't</b> have a setter in this class.\n     *\n     * @param dbSpecificOptions\n     */\n    public void setDbSpecificOptions(Map<String, String> dbSpecificOptions) {\n        this.dbSpecificOptions = dbSpecificOptions;\n        originalDbSpecificOptions = new HashMap<String, String>(dbSpecificOptions);\n    }\n\n    public Map<String, String> getDbSpecificOptions() {\n        if (dbSpecificOptions == null)\n            dbSpecificOptions = new HashMap<String, String>();\n        return dbSpecificOptions;\n    }\n\n    /**\n     * Returns a {@link Properties} populated with the contents of <code>bundle</code>\n     *\n     * @param bundle ResourceBundle\n     * @return Properties\n     */\n    public static Properties asProperties(ResourceBundle bundle) {\n        Properties props = new Properties();\n        Enumeration<String> iter = bundle.getKeys();\n        while (iter.hasMoreElements()) {\n            String key = iter.nextElement();\n            props.put(key, bundle.getObject(key));\n        }\n        return props;\n    }\n\n    /**\n     * 'Pull' the specified parameter from the collection of options. Returns\n     * null if the parameter isn't in the list and removes it if it is.\n     *\n     * @param paramId\n     * @return\n     */\n    private String pullParam(String paramId) {\n        return pullParam(paramId, false, false);\n    }\n\n    private String pullRequiredParam(String paramId) {\n        return pullParam(paramId, true, false);\n    }\n\n    /**\n     * @param paramId\n     * @param required\n     * @param dbTypeSpecific\n     * @return\n     * @throws MissingRequiredParameterException\n     */\n    private String pullParam(String paramId, boolean required, boolean dbTypeSpecific) throws MissingRequiredParameterException {\n        int paramIndex = options.indexOf(paramId);\n        if (paramIndex < 0) {\n            if (required)\n                throw new MissingRequiredParameterException(paramId, dbTypeSpecific);\n            return null;\n        }\n        options.remove(paramIndex);\n        String param = options.get(paramIndex).toString();\n        options.remove(paramIndex);\n        return param;\n    }\n\n    /**\n     * Thrown to indicate that a required parameter is missing\n     */\n    public static class MissingRequiredParameterException extends RuntimeException {\n\n        private static final long serialVersionUID = 1L;\n\n        private final boolean dbTypeSpecific;\n\n        public MissingRequiredParameterException(String paramId, boolean dbTypeSpecific) {\n            this(paramId, null, dbTypeSpecific);\n        }\n\n        public MissingRequiredParameterException(String paramId, String description, boolean dbTypeSpecific) {\n            super(\"Required parameter '\" + paramId + \"' \" + (description == null ? \"\" : \"(\" + description + \") \") + \"was not specified.\" + (dbTypeSpecific ? \"  It is required for this database type.\" : \"\"));\n            this.dbTypeSpecific = dbTypeSpecific;\n        }\n\n        public boolean isDbTypeSpecific() {\n            return dbTypeSpecific;\n        }\n    }\n\n    /**\n     * Allow an equal sign in args...like \"-o=foo.bar\". Useful for things like\n     * Ant and Maven.\n     *\n     * @param args\n     *            List\n     * @return List\n     */\n    protected List<String> fixupArgs(List<String> args) {\n        List<String> expandedArgs = new ArrayList<String>();\n        for (String arg : args) {\n            int indexOfEquals = arg.indexOf('=');\n            if (indexOfEquals != -1 && indexOfEquals - 1 != arg.indexOf(ESCAPED_EQUALS)) {\n                expandedArgs.add(arg.substring(0, indexOfEquals));\n                expandedArgs.add(arg.substring(indexOfEquals + 1));\n            } else {\n                expandedArgs.add(arg);\n            }\n        }\n        // some OSes/JVMs do filename expansion with runtime.exec() and some don't,\n        // so MultipleSchemaAnalyzer has to surround params with double quotes...\n        // strip them here for the OSes/JVMs that don't do anything with the params\n        List<String> unquotedArgs = new ArrayList<String>();\n        for (String arg : expandedArgs) {\n            if (// \".*\" becomes .*\n            arg.startsWith(\"\\\"\") && arg.endsWith(\"\\\"\"))\n                arg = arg.substring(1, arg.length() - 1);\n            unquotedArgs.add(arg);\n        }\n        return unquotedArgs;\n    }\n\n    /**\n     * Call all the getters to populate all the lazy initialized stuff.\n     *\n     * @throws InvocationTargetException\n     * @throws IllegalAccessException\n     * @throws IllegalArgumentException\n     * @throws IntrospectionException\n     */\n    private void populate() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IntrospectionException {\n        if (!populating) {\n            // prevent recursion\n            populating = true;\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                Method readMethod = props[i].getReadMethod();\n                if (readMethod != null)\n                    readMethod.invoke(this, (Object[]) null);\n            }\n            populating = false;\n        }\n    }\n\n    public static Set<String> getBuiltInDatabaseTypes(String loadedFromJar) {\n        Set<String> databaseTypes = new TreeSet<String>();\n        JarInputStream jar = null;\n        try {\n            jar = new JarInputStream(new FileInputStream(loadedFromJar));\n            JarEntry entry;\n            while ((entry = jar.getNextJarEntry()) != null) {\n                String entryName = entry.getName();\n                int dotPropsIndex = entryName.indexOf(\".properties\");\n                if (dotPropsIndex != -1)\n                    databaseTypes.add(entryName.substring(0, dotPropsIndex));\n            }\n        } catch (IOException exc) {\n        } finally {\n            if (jar != null) {\n                try {\n                    jar.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n        return databaseTypes;\n    }\n\n    protected void dumpUsage(String errorMessage, boolean detailedDb) {\n        if (errorMessage != null) {\n            System.out.flush();\n            System.err.println(\"*** \" + errorMessage + \" ***\");\n        } else {\n            System.out.println(\"SchemaSpy generates an HTML representation of a database schema's relationships.\");\n        }\n        System.err.flush();\n        System.out.println();\n        if (!detailedDb) {\n            System.out.println(\"Usage:\");\n            System.out.println(\" java -jar \" + getLoadedFromJar() + \" [options]\");\n            System.out.println(\"   -t databaseType       type of database - defaults to ora\");\n            System.out.println(\"                           use -dbhelp for a list of built-in types\");\n            System.out.println(\"   -u user               connect to the database with this user id\");\n            System.out.println(\"   -s schema             defaults to the specified user\");\n            System.out.println(\"   -p password           defaults to no password\");\n            System.out.println(\"   -o outputDirectory    directory to place the generated output in\");\n            System.out.println(\"   -dp pathToDrivers     optional - looks for JDBC drivers here before looking\");\n            System.out.println(\"                           in driverPath in [databaseType].properties.\");\n            System.out.println(\"Go to http://schemaspy.sourceforge.net for a complete list/description\");\n            System.out.println(\" of additional parameters.\");\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"Built-in database types and their required connection parameters:\");\n            for (String type : getBuiltInDatabaseTypes(getLoadedFromJar())) {\n                new DbSpecificConfig(type).dumpUsage();\n            }\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"You can use your own database types by specifying the filespec of a .properties file with -t.\");\n            System.out.println(\"Grab one out of \" + getLoadedFromJar() + \" and modify it to suit your needs.\");\n            System.out.println();\n        }\n        System.out.println(\"Sample usage using the default database type (implied -t ora):\");\n        System.out.println(\" java -jar schemaSpy.jar -db mydb -s myschema -u devuser -p password -o output\");\n        System.out.println();\n        System.out.flush();\n    }\n\n    /**\n     * Get the value of the specified parameter.\n     * Used for properties that are common to most db's, but aren't required.\n     *\n     * @param paramName\n     * @return\n     */\n    public String getParam(String paramName) {\n        try {\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                PropertyDescriptor prop = props[i];\n                if (prop.getName().equalsIgnoreCase(paramName)) {\n                    Object result = prop.getReadMethod().invoke(this, (Object[]) null);\n                    return result == null ? null : result.toString();\n                }\n            }\n        } catch (Exception failed) {\n            failed.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * Return all of the configuration options as a List of Strings, with\n     * each parameter and its value as a separate element.\n     *\n     * @return\n     * @throws IOException\n     */\n    public List<String> asList() throws IOException {\n        List<String> params = new ArrayList<String>();\n        if (originalDbSpecificOptions != null) {\n            for (String key : originalDbSpecificOptions.keySet()) {\n                String value = originalDbSpecificOptions.get(key);\n                if (!key.startsWith(\"-\"))\n                    key = \"-\" + key;\n                params.add(key);\n                params.add(value);\n            }\n        }\n        if (isEncodeCommentsEnabled())\n            params.add(\"-ahic\");\n        if (isEvaluateAllEnabled())\n            params.add(\"-all\");\n        if (!isHtmlGenerationEnabled())\n            params.add(\"-nohtml\");\n        if (!isImpliedConstraintsEnabled())\n            params.add(\"-noimplied\");\n        if (!isLogoEnabled())\n            params.add(\"-nologo\");\n        if (isMeterEnabled())\n            params.add(\"-meter\");\n        if (!isNumRowsEnabled())\n            params.add(\"-norows\");\n        if (!isViewsEnabled())\n            params.add(\"-noviews\");\n        if (isRankDirBugEnabled())\n            params.add(\"-rankdirbug\");\n        if (isRailsEnabled())\n            params.add(\"-rails\");\n        if (isSingleSignOn())\n            params.add(\"-sso\");\n        if (isSchemaDisabled())\n            params.add(\"-noschema\");\n        String value = getDriverPath();\n        if (value != null) {\n            params.add(\"-dp\");\n            params.add(value);\n        }\n        params.add(\"-css\");\n        params.add(getCss());\n        params.add(\"-charset\");\n        params.add(getCharset());\n        params.add(\"-font\");\n        params.add(getFont());\n        params.add(\"-fontsize\");\n        params.add(String.valueOf(getFontSize()));\n        params.add(\"-t\");\n        params.add(getDbType());\n        // query to set renderer correctly\n        isHighQuality();\n        // query to set renderer correctly\n        isLowQuality();\n        // instead of -hq and/or -lq\n        params.add(\"-renderer\");\n        params.add(getRenderer());\n        value = getDescription();\n        if (value != null) {\n            params.add(\"-desc\");\n            params.add(value);\n        }\n        value = getPassword();\n        if (value != null && !isPromptForPasswordEnabled()) {\n            // note that we don't pass -pfp since child processes\n            // won't have a console\n            params.add(\"-p\");\n            params.add(value);\n        }\n        value = getCatalog();\n        if (value != null) {\n            params.add(\"-cat\");\n            params.add(value);\n        }\n        value = getSchema();\n        if (value != null) {\n            params.add(\"-s\");\n            params.add(value);\n        }\n        value = getUser();\n        if (value != null) {\n            params.add(\"-u\");\n            params.add(value);\n        }\n        value = getConnectionPropertiesFile();\n        if (value != null) {\n            params.add(\"-connprops\");\n            params.add(value);\n        } else {\n            Properties props = getConnectionProperties();\n            if (!props.isEmpty()) {\n                params.add(\"-connprops\");\n                StringBuilder buf = new StringBuilder();\n                for (Entry<Object, Object> entry : props.entrySet()) {\n                    buf.append(entry.getKey());\n                    buf.append(ESCAPED_EQUALS);\n                    buf.append(entry.getValue());\n                    buf.append(';');\n                }\n                params.add(buf.toString());\n            }\n        }\n        value = getDb();\n        if (value != null) {\n            params.add(\"-db\");\n            params.add(value);\n        }\n        value = getHost();\n        if (value != null) {\n            params.add(\"-host\");\n            params.add(value);\n        }\n        if (getPort() != null) {\n            params.add(\"-port\");\n            params.add(getPort().toString());\n        }\n        value = getServer();\n        if (value != null) {\n            params.add(\"-server\");\n            params.add(value);\n        }\n        value = getMeta();\n        if (value != null) {\n            params.add(\"-meta\");\n            params.add(value);\n        }\n        if (getGraphvizDir() != null) {\n            params.add(\"-gv\");\n            params.add(getGraphvizDir().toString());\n        }\n        params.add(\"-loglevel\");\n        params.add(getLogLevel().toString().toLowerCase());\n        params.add(\"-sqlFormatter\");\n        params.add(getSqlFormatter().getClass().getName());\n        params.add(\"-i\");\n        params.add(getTableInclusions().toString());\n        params.add(\"-I\");\n        params.add(getTableExclusions().toString());\n        params.add(\"-X\");\n        params.add(getColumnExclusions().toString());\n        params.add(\"-x\");\n        params.add(getIndirectColumnExclusions().toString());\n        params.add(\"-dbthreads\");\n        params.add(String.valueOf(getMaxDbThreads()));\n        params.add(\"-maxdet\");\n        params.add(String.valueOf(getMaxDetailedTables()));\n        params.add(\"-o\");\n        params.add(getOutputDir().toString());\n        return params;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/ConfigTest13.java",
		"test_prompt": "// ConfigTest13.java\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Config}.\n* It contains ten unit test cases for the {@link Config#isEvaluateAllEnabled()} method.\n*/\nclass ConfigTest13 {"
	},
	{
		"original_code": "// Config.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\n\n/**\n * Configuration of a SchemaSpy run\n *\n * @author John Currier\n */\npublic class Config {\n\n    private static Config instance;\n\n    private final List<String> options;\n\n    private Map<String, String> dbSpecificOptions;\n\n    private Map<String, String> originalDbSpecificOptions;\n\n    private boolean helpRequired;\n\n    private boolean dbHelpRequired;\n\n    private File outputDir;\n\n    private File graphvizDir;\n\n    private String dbType;\n\n    private String catalog;\n\n    private String schema;\n\n    private List<String> schemas;\n\n    private String user;\n\n    private Boolean singleSignOn;\n\n    private Boolean noSchema;\n\n    private String password;\n\n    private Boolean promptForPassword;\n\n    private String db;\n\n    private String host;\n\n    private Integer port;\n\n    private String server;\n\n    private String meta;\n\n    private Pattern tableInclusions;\n\n    private Pattern tableExclusions;\n\n    private Pattern columnExclusions;\n\n    private Pattern indirectColumnExclusions;\n\n    private String userConnectionPropertiesFile;\n\n    private Properties userConnectionProperties;\n\n    private Integer maxDbThreads;\n\n    private Integer maxDetailedTables;\n\n    private String driverPath;\n\n    private String css;\n\n    private String charset;\n\n    private String font;\n\n    private Integer fontSize;\n\n    private String description;\n\n    private Properties dbProperties;\n\n    private String dbPropertiesLoadedFrom;\n\n    private Level logLevel;\n\n    private SqlFormatter sqlFormatter;\n\n    private String sqlFormatterClass;\n\n    private Boolean generateHtml;\n\n    private Boolean includeImpliedConstraints;\n\n    private Boolean logoEnabled;\n\n    private Boolean rankDirBugEnabled;\n\n    private Boolean encodeCommentsEnabled;\n\n    private Boolean numRowsEnabled;\n\n    private Boolean viewsEnabled;\n\n    private Boolean meterEnabled;\n\n    private Boolean railsEnabled;\n\n    private Boolean evaluteAll;\n\n    private Boolean highQuality;\n\n    private Boolean lowQuality;\n\n    // used in conjunction with evaluateAll\n    private String schemaSpec;\n\n    private boolean hasOrphans = false;\n\n    private boolean hasRoutines = false;\n\n    private boolean populating = false;\n\n    private List<String> columnDetails;\n\n    public static final String DOT_CHARSET = \"UTF-8\";\n\n    private static final String ESCAPED_EQUALS = \"\\\\=\";\n\n    // match everything\n    private static final String DEFAULT_TABLE_INCLUSION = \".*\";\n\n    // match nothing\n    private static final String DEFAULT_TABLE_EXCLUSION = \"\";\n\n    // match nothing\n    private static final String DEFAULT_COLUMN_EXCLUSION = \"[^.]\";\n\n    /**\n     * Default constructor. Intended for when you want to inject properties\n     * independently (i.e. not from a command line interface).\n     */\n    public Config() {\n        if (instance == null)\n            setInstance(this);\n        options = new ArrayList<String>();\n    }\n\n    /**\n     * Construct a configuration from an array of options (e.g. from a command\n     * line interface).\n     *\n     * @param options\n     */\n    public Config(String[] argv) {\n        setInstance(this);\n        options = fixupArgs(Arrays.asList(argv));\n        helpRequired = options.remove(\"-?\") || options.remove(\"/?\") || options.remove(\"?\") || options.remove(\"-h\") || options.remove(\"-help\") || options.remove(\"--help\");\n        dbHelpRequired = options.remove(\"-dbHelp\") || options.remove(\"-dbhelp\");\n    }\n\n    public static Config getInstance() {\n        if (instance == null)\n            instance = new Config();\n        return instance;\n    }\n\n    /**\n     * Sets the global instance.\n     *\n     * Useful for things like selecting a specific configuration in a UI.\n     *\n     * @param config\n     */\n    public static void setInstance(Config config) {\n        instance = config;\n    }\n\n    public void setHtmlGenerationEnabled(boolean generateHtml) {\n        this.generateHtml = generateHtml;\n    }\n\n    public boolean isHtmlGenerationEnabled() {\n        if (generateHtml == null)\n            generateHtml = !options.remove(\"-nohtml\");\n        return generateHtml;\n    }\n\n    public void setImpliedConstraintsEnabled(boolean includeImpliedConstraints) {\n        this.includeImpliedConstraints = includeImpliedConstraints;\n    }\n\n    public boolean isImpliedConstraintsEnabled() {\n        if (includeImpliedConstraints == null)\n            includeImpliedConstraints = !options.remove(\"-noimplied\");\n        return includeImpliedConstraints;\n    }\n\n    public void setOutputDir(String outputDirName) {\n        if (outputDirName.endsWith(\"\\\"\"))\n            outputDirName = outputDirName.substring(0, outputDirName.length() - 1);\n        setOutputDir(new File(outputDirName));\n    }\n\n    public void setOutputDir(File outputDir) {\n        this.outputDir = outputDir;\n    }\n\n    public File getOutputDir() {\n        if (outputDir == null) {\n            setOutputDir(pullRequiredParam(\"-o\"));\n        }\n        return outputDir;\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(String graphvizDir) {\n        if (graphvizDir.endsWith(\"\\\"\"))\n            graphvizDir = graphvizDir.substring(0, graphvizDir.length() - 1);\n        setGraphvizDir(new File(graphvizDir));\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(File graphvizDir) {\n        this.graphvizDir = graphvizDir;\n    }\n\n    /**\n     * Return the path to Graphviz (used to find the dot executable to run to\n     * generate ER diagrams).<p/>\n     *\n     * Returns {@link #getDefaultGraphvizPath()} if a specific Graphviz path\n     * was not specified.\n     *\n     * @return\n     */\n    public File getGraphvizDir() {\n        if (graphvizDir == null) {\n            String gv = pullParam(\"-gv\");\n            if (gv != null) {\n                setGraphvizDir(gv);\n            } else {\n                // expect to find Graphviz's bin directory on the PATH\n            }\n        }\n        return graphvizDir;\n    }\n\n    /**\n     * Meta files are XML-based files that provide additional metadata\n     * about the schema being evaluated.<p>\n     * <code>meta</code> is either the name of an individual XML file or\n     * the directory that contains meta files.<p>\n     * If a directory is specified then it is expected to contain files\n     * matching the pattern <code>[schema].meta.xml</code>.\n     * For databases that don't have schema substitute database for schema.\n     * @param meta\n     */\n    public void setMeta(String meta) {\n        this.meta = meta;\n    }\n\n    public String getMeta() {\n        if (meta == null)\n            meta = pullParam(\"-meta\");\n        return meta;\n    }\n\n    public void setDbType(String dbType) {\n        this.dbType = dbType;\n    }\n\n    public String getDbType() {\n        if (dbType == null) {\n            dbType = pullParam(\"-t\");\n            if (dbType == null)\n                dbType = \"ora\";\n        }\n        return dbType;\n    }\n\n    public void setDb(String db) {\n        this.db = db;\n    }\n\n    public String getDb() {\n        if (db == null)\n            db = pullParam(\"-db\");\n        return db;\n    }\n\n    public void setCatalog(String catalog) {\n        this.catalog = catalog;\n    }\n\n    public String getCatalog() {\n        if (catalog == null)\n            catalog = pullParam(\"-cat\");\n        return catalog;\n    }\n\n    public void setSchema(String schema) {\n        this.schema = schema;\n    }\n\n    public String getSchema() {\n        if (schema == null)\n            schema = pullParam(\"-s\");\n        return schema;\n    }\n\n    /**\n     * Some databases types (e.g. older versions of Informix) don't really\n     * have the concept of a schema but still return true from\n     * {@link DatabaseMetaData#supportsSchemasInTableDefinitions()}.\n     * This option lets you ignore that and treat all the tables\n     * as if they were in one flat namespace.\n     */\n    public boolean isSchemaDisabled() {\n        if (noSchema == null)\n            noSchema = options.remove(\"-noschema\");\n        return noSchema;\n    }\n\n    public void setHost(String host) {\n        this.host = host;\n    }\n\n    public String getHost() {\n        if (host == null)\n            host = pullParam(\"-host\");\n        return host;\n    }\n\n    public void setPort(Integer port) {\n        this.port = port;\n    }\n\n    public Integer getPort() {\n        if (port == null)\n            try {\n                port = Integer.valueOf(pullParam(\"-port\"));\n            } catch (Exception notSpecified) {\n            }\n        return port;\n    }\n\n    public void setServer(String server) {\n        this.server = server;\n    }\n\n    public String getServer() {\n        if (server == null) {\n            server = pullParam(\"-server\");\n        }\n        return server;\n    }\n\n    public void setUser(String user) {\n        this.user = user;\n    }\n\n    /**\n     * User used to connect to the database.\n     * Required unless single sign-on is enabled\n     * (see {@link #setSingleSignOn(boolean)}).\n     * @return\n     */\n    public String getUser() {\n        if (user == null) {\n            if (!isSingleSignOn())\n                user = pullRequiredParam(\"-u\");\n            else\n                user = pullParam(\"-u\");\n        }\n        return user;\n    }\n\n    /**\n     * By default a \"user\" (as specified with -u) is required.\n     * This option allows disabling of that requirement for\n     * single sign-on environments.\n     *\n     * @param enabled defaults to <code>false</code>\n     */\n    public void setSingleSignOn(boolean enabled) {\n        singleSignOn = enabled;\n    }\n\n    /**\n     * @see #setSingleSignOn(boolean)\n     */\n    public boolean isSingleSignOn() {\n        if (singleSignOn == null)\n            singleSignOn = options.remove(\"-sso\");\n        return singleSignOn;\n    }\n\n    /**\n     * Set the password used to connect to the database.\n     * @param password\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * @see #setPassword(String)\n     * @return\n     */\n    public String getPassword() {\n        if (password == null)\n            password = pullParam(\"-p\");\n        if (password == null && isPromptForPasswordEnabled())\n            password = new String(PasswordReader.getInstance().readPassword(\"Password: \"));\n        if (password == null) {\n            // if -pfp is enabled when analyzing multiple schemas then\n            // we don't want to send the password on the command line,\n            // so see if it was passed in the environment (not ideal, but safer)\n            password = System.getenv(\"schemaspy.pw\");\n        }\n        return password;\n    }\n\n    /**\n     * Set to <code>true</code> to prompt for the password\n     * @param promptForPassword\n     */\n    public void setPromptForPasswordEnabled(boolean promptForPassword) {\n        this.promptForPassword = promptForPassword;\n    }\n\n    /**\n     * @see #setPromptForPasswordEnabled(boolean)\n     * @return\n     */\n    public boolean isPromptForPasswordEnabled() {\n        if (promptForPassword == null) {\n            promptForPassword = options.remove(\"-pfp\");\n        }\n        return promptForPassword;\n    }\n\n    public void setMaxDetailedTabled(int maxDetailedTables) {\n        this.maxDetailedTables = new Integer(maxDetailedTables);\n    }\n\n    public int getMaxDetailedTables() {\n        if (maxDetailedTables == null) {\n            // default\n            int max = 300;\n            try {\n                max = Integer.parseInt(pullParam(\"-maxdet\"));\n            } catch (Exception notSpecified) {\n            }\n            maxDetailedTables = new Integer(max);\n        }\n        return maxDetailedTables.intValue();\n    }\n\n    public String getConnectionPropertiesFile() {\n        return userConnectionPropertiesFile;\n    }\n\n    /**\n     * Properties from this file (in key=value pair format) are passed to the\n     * database connection.<br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.\n     * @param propertiesFilename\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public void setConnectionPropertiesFile(String propertiesFilename) throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null)\n            userConnectionProperties = new Properties();\n        userConnectionProperties.load(new FileInputStream(propertiesFilename));\n        userConnectionPropertiesFile = propertiesFilename;\n    }\n\n    /**\n     * Returns a {@link Properties} populated either from the properties file specified\n     * by {@link #setConnectionPropertiesFile(String)}, the properties specified by\n     * {@link #setConnectionProperties(String)} or not populated.\n     * @return\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public Properties getConnectionProperties() throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null) {\n            String props = pullParam(\"-connprops\");\n            if (props != null) {\n                if (props.indexOf(ESCAPED_EQUALS) != -1) {\n                    setConnectionProperties(props);\n                } else {\n                    setConnectionPropertiesFile(props);\n                }\n            } else {\n                userConnectionProperties = new Properties();\n            }\n        }\n        return userConnectionProperties;\n    }\n\n    /**\n     * Specifies connection properties to use in the format:\n     * <code>key1\\=value1;key2\\=value2</code><br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.<p>\n     * This is an alternative form of passing connection properties than by file\n     * (see {@link #setConnectionPropertiesFile(String)})\n     *\n     * @param properties\n     */\n    public void setConnectionProperties(String properties) {\n        userConnectionProperties = new Properties();\n        StringTokenizer tokenizer = new StringTokenizer(properties, \";\");\n        while (tokenizer.hasMoreElements()) {\n            String pair = tokenizer.nextToken();\n            int index = pair.indexOf(ESCAPED_EQUALS);\n            if (index != -1) {\n                String key = pair.substring(0, index);\n                String value = pair.substring(index + ESCAPED_EQUALS.length());\n                userConnectionProperties.put(key, value);\n            }\n        }\n    }\n\n    public void setDriverPath(String driverPath) {\n        this.driverPath = driverPath;\n    }\n\n    public String getDriverPath() {\n        if (driverPath == null)\n            driverPath = pullParam(\"-dp\");\n        // was previously -cp:\n        if (driverPath == null)\n            driverPath = pullParam(\"-cp\");\n        return driverPath;\n    }\n\n    /**\n     * The filename of the cascading style sheet to use.\n     * Note that this file is parsed and used to determine characteristics\n     * of the generated diagrams, so it must contain specific settings that\n     * are documented within schemaSpy.css.<p>\n     *\n     * Defaults to <code>\"schemaSpy.css\"</code>.\n     *\n     * @param css\n     */\n    public void setCss(String css) {\n        this.css = css;\n    }\n\n    public String getCss() {\n        if (css == null) {\n            css = pullParam(\"-css\");\n            if (css == null)\n                css = \"schemaSpy.css\";\n        }\n        return css;\n    }\n\n    /**\n     * The font to use within diagrams.  Modify the .css to specify HTML fonts.\n     *\n     * @param font\n     */\n    public void setFont(String font) {\n        this.font = font;\n    }\n\n    /**\n     * @see #setFont(String)\n     */\n    public String getFont() {\n        if (font == null) {\n            font = pullParam(\"-font\");\n            if (font == null)\n                font = \"Helvetica\";\n        }\n        return font;\n    }\n\n    /**\n     * The font size to use within diagrams.  This is the size of the font used for\n     * 'large' (e.g. not 'compact') diagrams.<p>\n     *\n     * Modify the .css to specify HTML font sizes.<p>\n     *\n     * Defaults to 11.\n     *\n     * @param fontSize\n     */\n    public void setFontSize(int fontSize) {\n        this.fontSize = new Integer(fontSize);\n    }\n\n    /**\n     * @see #setFontSize(int)\n     * @return\n     */\n    public int getFontSize() {\n        if (fontSize == null) {\n            // default\n            int size = 11;\n            try {\n                size = Integer.parseInt(pullParam(\"-fontsize\"));\n            } catch (Exception notSpecified) {\n            }\n            fontSize = new Integer(size);\n        }\n        return fontSize.intValue();\n    }\n\n    /**\n     * The character set to use within HTML pages (defaults to <code>\"ISO-8859-1\"</code>).\n     *\n     * @param charset\n     */\n    public void setCharset(String charset) {\n        this.charset = charset;\n    }\n\n    /**\n     * @see #setCharset(String)\n     */\n    public String getCharset() {\n        if (charset == null) {\n            charset = pullParam(\"-charset\");\n            if (charset == null)\n                charset = \"ISO-8859-1\";\n        }\n        return charset;\n    }\n\n    /**\n     * Description of schema that gets display on main pages.\n     *\n     * @param description\n     */\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    /**\n     * @see #setDescription(String)\n     */\n    public String getDescription() {\n        if (description == null)\n            description = pullParam(\"-desc\");\n        return description;\n    }\n\n    /**\n     * Maximum number of threads to use when querying database metadata information.\n     *\n     * @param maxDbThreads\n     */\n    public void setMaxDbThreads(int maxDbThreads) {\n        this.maxDbThreads = new Integer(maxDbThreads);\n    }\n\n    /**\n     * @see #setMaxDbThreads(int)\n     * @throws InvalidConfigurationException if unable to load properties\n     */\n    public int getMaxDbThreads() throws InvalidConfigurationException {\n        if (maxDbThreads == null) {\n            Properties properties;\n            try {\n                properties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(\"Failed to load properties for \" + getDbType() + \": \" + exc).setParamName(\"-type\");\n            }\n            // not scientifically derived\n            final int defaultMax = 15;\n            int max = defaultMax;\n            String threads = properties.getProperty(\"dbThreads\");\n            if (threads == null)\n                threads = properties.getProperty(\"dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            threads = pullParam(\"-dbThreads\");\n            if (threads == null)\n                threads = pullParam(\"-dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            if (max < 0)\n                max = defaultMax;\n            else if (max == 0)\n                max = 1;\n            maxDbThreads = new Integer(max);\n        }\n        return maxDbThreads.intValue();\n    }\n\n    public boolean isLogoEnabled() {\n        if (logoEnabled == null)\n            logoEnabled = !options.remove(\"-nologo\");\n        return logoEnabled;\n    }\n\n    /**\n     * Don't use this unless absolutely necessary as it screws up the layout\n     *\n     * @param enabled\n     */\n    public void setRankDirBugEnabled(boolean enabled) {\n        rankDirBugEnabled = enabled;\n    }\n\n    /**\n     * @see #setRankDirBugEnabled(boolean)\n     */\n    public boolean isRankDirBugEnabled() {\n        if (rankDirBugEnabled == null)\n            rankDirBugEnabled = options.remove(\"-rankdirbug\");\n        return rankDirBugEnabled;\n    }\n\n    /**\n     * Look for Ruby on Rails-based naming conventions in\n     * relationships between logical foreign keys and primary keys.<p>\n     *\n     * Basically all tables have a primary key named <code>ID</code>.\n     * All tables are named plural names.\n     * The columns that logically reference that <code>ID</code> are the singular\n     * form of the table name suffixed with <code>_ID</code>.<p>\n     *\n     * @param enabled\n     */\n    public void setRailsEnabled(boolean enabled) {\n        railsEnabled = enabled;\n    }\n\n    /**\n     * @see #setRailsEnabled(boolean)\n     *\n     * @return\n     */\n    public boolean isRailsEnabled() {\n        if (railsEnabled == null)\n            railsEnabled = options.remove(\"-rails\");\n        return railsEnabled;\n    }\n\n    /**\n     * Allow Html In Comments - encode them unless otherwise specified\n     */\n    public void setEncodeCommentsEnabled(boolean enabled) {\n        encodeCommentsEnabled = enabled;\n    }\n\n    /**\n     * @see #setEncodeCommentsEnabled(boolean)\n     */\n    public boolean isEncodeCommentsEnabled() {\n        if (encodeCommentsEnabled == null)\n            encodeCommentsEnabled = !options.remove(\"-ahic\");\n        return encodeCommentsEnabled;\n    }\n\n    /**\n     * If enabled we'll attempt to query/render the number of rows that\n     * each table contains.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setNumRowsEnabled(boolean enabled) {\n        numRowsEnabled = enabled;\n    }\n\n    /**\n     * @see #setNumRowsEnabled(boolean)\n     * @return\n     */\n    public boolean isNumRowsEnabled() {\n        if (numRowsEnabled == null)\n            numRowsEnabled = !options.remove(\"-norows\");\n        return numRowsEnabled;\n    }\n\n    /**\n     * If enabled we'll include views in the analysis.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setViewsEnabled(boolean enabled) {\n        viewsEnabled = enabled;\n    }\n\n    /**\n     * @see #setViewsEnabled(boolean)\n     * @return\n     */\n    public boolean isViewsEnabled() {\n        if (viewsEnabled == null)\n            viewsEnabled = !options.remove(\"-noviews\");\n        return viewsEnabled;\n    }\n\n    /**\n     * Returns <code>true</code> if metering should be embedded in\n     * the generated pages.<p/>\n     * Defaults to <code>false</code> (disabled).\n     * @return\n     */\n    public boolean isMeterEnabled() {\n        if (meterEnabled == null)\n            meterEnabled = options.remove(\"-meter\");\n        return meterEnabled;\n    }\n\n    /**\n     * Set the columns to exclude from all relationship diagrams.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setColumnExclusions(String columnExclusions) {\n        this.columnExclusions = Pattern.compile(columnExclusions);\n    }\n\n    /**\n     * See {@link #setColumnExclusions(String)}\n     * @return\n     */\n    public Pattern getColumnExclusions() {\n        if (columnExclusions == null) {\n            String strExclusions = pullParam(\"-X\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.columnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            columnExclusions = Pattern.compile(strExclusions);\n        }\n        return columnExclusions;\n    }\n\n    /**\n     * Set the columns to exclude from relationship diagrams where the specified\n     * columns aren't directly referenced by the focal table.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setIndirectColumnExclusions(String fullColumnExclusions) {\n        indirectColumnExclusions = Pattern.compile(fullColumnExclusions);\n    }\n\n    /**\n     * @see #setIndirectColumnExclusions(String)\n     *\n     * @return\n     */\n    public Pattern getIndirectColumnExclusions() {\n        if (indirectColumnExclusions == null) {\n            String strExclusions = pullParam(\"-x\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.indirectColumnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            indirectColumnExclusions = Pattern.compile(strExclusions);\n        }\n        return indirectColumnExclusions;\n    }\n\n    /**\n     * Set the tables to include as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableInclusions(String tableInclusions) {\n        this.tableInclusions = Pattern.compile(tableInclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to include in the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableInclusions() {\n        if (tableInclusions == null) {\n            String strInclusions = pullParam(\"-i\");\n            if (strInclusions == null)\n                strInclusions = System.getenv(\"schemaspy.tableInclusions\");\n            if (strInclusions == null)\n                strInclusions = DEFAULT_TABLE_INCLUSION;\n            try {\n                tableInclusions = Pattern.compile(strInclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-i\");\n            }\n        }\n        return tableInclusions;\n    }\n\n    /**\n     * Set the tables to exclude as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableExclusions(String tableExclusions) {\n        this.tableExclusions = Pattern.compile(tableExclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to exclude from the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableExclusions() {\n        if (tableExclusions == null) {\n            String strExclusions = pullParam(\"-I\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.tableExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_TABLE_EXCLUSION;\n            try {\n                tableExclusions = Pattern.compile(strExclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-I\");\n            }\n        }\n        return tableExclusions;\n    }\n\n    /**\n     * @return\n     */\n    public List<String> getSchemas() {\n        if (schemas == null) {\n            String tmp = pullParam(\"-schemas\");\n            if (tmp == null)\n                tmp = pullParam(\"-schemata\");\n            if (tmp != null) {\n                schemas = new ArrayList<String>();\n                for (String name : tmp.split(\"[\\\\s,'\\\"]\")) {\n                    if (name.length() > 0)\n                        schemas.add(name);\n                }\n                if (schemas.isEmpty())\n                    schemas = null;\n            }\n        }\n        return schemas;\n    }\n\n    /**\n     * Set the name of the {@link SqlFormatter SQL formatter} class to use to\n     * format SQL into HTML.<p/>\n     * The implementation of the class must be made available to the class\n     * loader, typically by specifying the path to its jar with <em>-dp</em>\n     * ({@link #setDriverPath(String)}).\n     */\n    public void setSqlFormatter(String formatterClassName) {\n        sqlFormatterClass = formatterClassName;\n        sqlFormatter = null;\n    }\n\n    /**\n     * Set the {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.\n     */\n    public void setSqlFormatter(SqlFormatter sqlFormatter) {\n        this.sqlFormatter = sqlFormatter;\n        if (sqlFormatter != null)\n            sqlFormatterClass = sqlFormatter.getClass().getName();\n    }\n\n    /**\n     * Returns an implementation of {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.  The default implementation is {@link DefaultSqlFormatter}.\n     *\n     * @return\n     * @throws InvalidConfigurationException if unable to instantiate an instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SqlFormatter getSqlFormatter() throws InvalidConfigurationException {\n        if (sqlFormatter == null) {\n            if (sqlFormatterClass == null) {\n                sqlFormatterClass = pullParam(\"-sqlFormatter\");\n                if (sqlFormatterClass == null)\n                    sqlFormatterClass = DefaultSqlFormatter.class.getName();\n            }\n            try {\n                Class<SqlFormatter> clazz = (Class<SqlFormatter>) Class.forName(sqlFormatterClass);\n                sqlFormatter = clazz.newInstance();\n            } catch (Exception exc) {\n                throw new InvalidConfigurationException(\"Failed to initialize instance of SQL formatter: \", exc).setParamName(\"-sqlFormatter\");\n            }\n        }\n        return sqlFormatter;\n    }\n\n    /**\n     * Set the details to show on the columns page, where \"details\" are\n     * comma and/or space separated.\n     *\n     * Valid values:\n     * <ul>\n     * <li>id</li>\n     * <li>table</li>\n     * <li>column</li>\n     * <li>type</li>\n     * <li>size</li>\n     * <li>nulls</li>\n     * <li>auto</li>\n     * <li>default</li>\n     * <li>children</li>\n     * <li>parents</li>\n     * </ul>\n     *\n     * The default details are <code>\"table column type size nulls auto default\"</code>.\n     * Note that \"column\" is the initially displayed detail and must be included.\n     *\n     * @param columnDetails\n     */\n    public void setColumnDetails(String columnDetails) {\n        this.columnDetails = new ArrayList<String>();\n        if (columnDetails == null || columnDetails.length() == 0) {\n            // not specified, so use defaults\n            columnDetails = \"id table column type size nulls auto default\";\n        }\n        for (String detail : columnDetails.split(\"[\\\\s,'\\\"]\")) {\n            if (detail.length() > 0) {\n                this.columnDetails.add(detail.toLowerCase());\n            }\n        }\n        if (!this.columnDetails.contains(\"column\"))\n            throw new InvalidConfigurationException(\"'column' is a required column detail\");\n    }\n\n    public void setColumnDetails(List<String> columnDetails) {\n        String details = columnDetails == null ? \"[]\" : columnDetails.toString();\n        setColumnDetails(details.substring(1, details.length() - 1));\n    }\n\n    public List<String> getColumnDetails() {\n        if (columnDetails == null) {\n            setColumnDetails(pullParam(\"-columndetails\"));\n        }\n        return columnDetails;\n    }\n\n    public void setEvaluateAllEnabled(boolean enabled) {\n        evaluteAll = enabled;\n    }\n\n    public boolean isEvaluateAllEnabled() {\n        if (evaluteAll == null)\n            evaluteAll = options.remove(\"-all\");\n        return evaluteAll;\n    }\n\n    /**\n     * Returns true if we're evaluating a bunch of schemas in one go and\n     * at this point we're evaluating a specific schema.\n     *\n     * @return boolean\n     */\n    public boolean isOneOfMultipleSchemas() {\n        // set by MultipleSchemaAnalyzer\n        return Boolean.getBoolean(\"oneofmultipleschemas\");\n    }\n\n    /**\n     * When -all (evaluateAll) is specified then this is the regular\n     * expression that determines which schemas to evaluate.\n     *\n     * @param schemaSpec\n     */\n    public void setSchemaSpec(String schemaSpec) {\n        this.schemaSpec = schemaSpec;\n    }\n\n    public String getSchemaSpec() {\n        if (schemaSpec == null)\n            schemaSpec = pullParam(\"-schemaSpec\");\n        return schemaSpec;\n    }\n\n    /**\n     * Set the renderer to use for the -Tpng[:renderer[:formatter]] dot option as specified\n     * at <a href='http://www.graphviz.org/doc/info/command.html'>\n     * http://www.graphviz.org/doc/info/command.html</a>.<p>\n     * Note that the leading \":\" is required while :formatter is optional.<p>\n     * The default renderer is typically GD.<p>\n     * Note that using {@link #setHighQuality(boolean)} is the preferred approach\n     * over using this method.\n     */\n    public void setRenderer(String renderer) {\n        Dot.getInstance().setRenderer(renderer);\n    }\n\n    /**\n     * @see #setRenderer(String)\n     * @return\n     */\n    public String getRenderer() {\n        String renderer = pullParam(\"-renderer\");\n        if (renderer != null)\n            setRenderer(renderer);\n        return Dot.getInstance().getRenderer();\n    }\n\n    /**\n     * If <code>false</code> then generate output of \"lower quality\"\n     * than the default.\n     * Note that the default is intended to be \"higher quality\",\n     * but various installations of Graphviz may have have different abilities.\n     * That is, some might not have the \"lower quality\" libraries and others might\n     * not have the \"higher quality\" libraries.<p>\n     * Higher quality output takes longer to generate and results in significantly\n     * larger image files (which take longer to download / display), but it generally\n     * looks better.\n     */\n    public void setHighQuality(boolean highQuality) {\n        this.highQuality = highQuality;\n        lowQuality = !highQuality;\n        Dot.getInstance().setHighQuality(highQuality);\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isHighQuality() {\n        if (highQuality == null) {\n            highQuality = options.remove(\"-hq\");\n            if (highQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(highQuality);\n            }\n        }\n        highQuality = Dot.getInstance().isHighQuality();\n        return highQuality;\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isLowQuality() {\n        if (lowQuality == null) {\n            lowQuality = options.remove(\"-lq\");\n            if (lowQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(!lowQuality);\n            }\n        }\n        lowQuality = !Dot.getInstance().isHighQuality();\n        return lowQuality;\n    }\n\n    /**\n     * Set the level of logging to perform.<p/>\n     * The levels in descending order are:\n     * <ul>\n     *  <li><code>severe</code> (highest - least detail)\n     *  <li><code>warning</code> (default)\n     *  <li><code>info</code>\n     *  <li><code>config</code>\n     *  <li><code>fine</code>\n     *  <li><code>finer</code>\n     *  <li><code>finest</code>  (lowest - most detail)\n     * </ul>\n     *\n     * @param logLevel\n     */\n    public void setLogLevel(String logLevel) {\n        if (logLevel == null) {\n            this.logLevel = Level.WARNING;\n            return;\n        }\n        Map<String, Level> levels = new LinkedHashMap<String, Level>();\n        levels.put(\"severe\", Level.SEVERE);\n        levels.put(\"warning\", Level.WARNING);\n        levels.put(\"info\", Level.INFO);\n        levels.put(\"config\", Level.CONFIG);\n        levels.put(\"fine\", Level.FINE);\n        levels.put(\"finer\", Level.FINER);\n        levels.put(\"finest\", Level.FINEST);\n        this.logLevel = levels.get(logLevel.toLowerCase());\n        if (this.logLevel == null) {\n            throw new InvalidConfigurationException(\"Invalid logLevel: '\" + logLevel + \"'. Must be one of: \" + levels.keySet());\n        }\n    }\n\n    /**\n     * Returns the level of logging to perform.\n     * See {@link #setLogLevel(String)}.\n     *\n     * @return\n     */\n    public Level getLogLevel() {\n        if (logLevel == null) {\n            setLogLevel(pullParam(\"-loglevel\"));\n        }\n        return logLevel;\n    }\n\n    /**\n     * Returns <code>true</code> if the options indicate that the user wants\n     * to see some help information.\n     *\n     * @return\n     */\n    public boolean isHelpRequired() {\n        return helpRequired;\n    }\n\n    public boolean isDbHelpRequired() {\n        return dbHelpRequired;\n    }\n\n    /**\n     * Returns the jar that we were loaded from\n     *\n     * @return\n     */\n    public static String getLoadedFromJar() {\n        String classpath = System.getProperty(\"java.class.path\");\n        return new StringTokenizer(classpath, File.pathSeparator).nextToken();\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasOrphans(boolean hasOrphans) {\n        this.hasOrphans = hasOrphans;\n    }\n\n    /**\n     * @see #setHasOrphans()\n     *\n     * @return\n     */\n    public boolean hasOrphans() {\n        return hasOrphans;\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasRoutines(boolean hasRoutines) {\n        this.hasRoutines = hasRoutines;\n    }\n\n    /**\n     * @see #setHasRoutines()\n     *\n     * @return\n     */\n    public boolean hasRoutines() {\n        return hasRoutines;\n    }\n\n    /**\n     * Returns the database properties to use.\n     * These should be determined by calling {@link #determineDbProperties(String)}.\n     * @return\n     * @throws InvalidConfigurationException\n     */\n    public Properties getDbProperties() throws InvalidConfigurationException {\n        if (dbProperties == null) {\n            try {\n                dbProperties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(exc);\n            }\n        }\n        return dbProperties;\n    }\n\n    /**\n     * Determines the database properties associated with the specified type.\n     * A call to {@link #setDbProperties(Properties)} is expected after determining\n     * the complete set of properties.\n     *\n     * @param type\n     * @return\n     * @throws IOException\n     * @throws InvalidConfigurationException if db properties are incorrectly formed\n     */\n    public Properties determineDbProperties(String type) throws IOException, InvalidConfigurationException {\n        ResourceBundle bundle = null;\n        try {\n            File propertiesFile = new File(type);\n            bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n            dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n        } catch (FileNotFoundException notFoundOnFilesystemWithoutExtension) {\n            try {\n                File propertiesFile = new File(type + \".properties\");\n                bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n                dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n            } catch (FileNotFoundException notFoundOnFilesystemWithExtensionTackedOn) {\n                try {\n                    bundle = ResourceBundle.getBundle(type);\n                    dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]\" + File.separator + type + \".properties\";\n                } catch (Exception notInJarWithoutPath) {\n                    try {\n                        String path = TableOrderer.class.getPackage().getName() + \".dbTypes.\" + type;\n                        path = path.replace('.', '/');\n                        bundle = ResourceBundle.getBundle(path);\n                        dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]/\" + path + \".properties\";\n                    } catch (Exception notInJar) {\n                        notInJar.printStackTrace();\n                        notFoundOnFilesystemWithExtensionTackedOn.printStackTrace();\n                        throw notFoundOnFilesystemWithoutExtension;\n                    }\n                }\n            }\n        }\n        Properties props = asProperties(bundle);\n        bundle = null;\n        // keep original thru recursion\n        String saveLoadedFrom = dbPropertiesLoadedFrom;\n        // bring in key/values pointed to by the include directive\n        // example: include.1=mysql::selectRowCountSql\n        for (int i = 1; true; ++i) {\n            String include = (String) props.remove(\"include.\" + i);\n            if (include == null)\n                break;\n            int separator = include.indexOf(\"::\");\n            if (separator == -1)\n                throw new InvalidConfigurationException(\"include directive in \" + dbPropertiesLoadedFrom + \" must have '::' between dbType and key\");\n            String refdType = include.substring(0, separator).trim();\n            String refdKey = include.substring(separator + 2).trim();\n            // recursively resolve the ref'd properties file and the ref'd key\n            Properties refdProps = determineDbProperties(refdType);\n            props.put(refdKey, refdProps.getProperty(refdKey));\n        }\n        // bring in base properties files pointed to by the extends directive\n        String baseDbType = (String) props.remove(\"extends\");\n        if (baseDbType != null) {\n            baseDbType = baseDbType.trim();\n            Properties baseProps = determineDbProperties(baseDbType);\n            // overlay our properties on top of the base's\n            baseProps.putAll(props);\n            props = baseProps;\n        }\n        // done with this level of recursion...restore original\n        dbPropertiesLoadedFrom = saveLoadedFrom;\n        // this won't be correct until the final recursion exits\n        dbProperties = props;\n        return props;\n    }\n\n    protected String getDbPropertiesLoadedFrom() throws IOException {\n        if (dbPropertiesLoadedFrom == null)\n            determineDbProperties(getDbType());\n        return dbPropertiesLoadedFrom;\n    }\n\n    public List<String> getRemainingParameters() {\n        try {\n            populate();\n        } catch (IllegalArgumentException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (IllegalAccessException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (InvocationTargetException exc) {\n            if (exc.getCause() instanceof InvalidConfigurationException)\n                throw (InvalidConfigurationException) exc.getCause();\n            throw new InvalidConfigurationException(exc.getCause());\n        } catch (IntrospectionException exc) {\n            throw new InvalidConfigurationException(exc);\n        }\n        return options;\n    }\n\n    /**\n     * Options that are specific to a type of database.  E.g. things like <code>host</code>,\n     * <code>port</code> or <code>db</code>, but <b>don't</b> have a setter in this class.\n     *\n     * @param dbSpecificOptions\n     */\n    public void setDbSpecificOptions(Map<String, String> dbSpecificOptions) {\n        this.dbSpecificOptions = dbSpecificOptions;\n        originalDbSpecificOptions = new HashMap<String, String>(dbSpecificOptions);\n    }\n\n    public Map<String, String> getDbSpecificOptions() {\n        if (dbSpecificOptions == null)\n            dbSpecificOptions = new HashMap<String, String>();\n        return dbSpecificOptions;\n    }\n\n    /**\n     * Returns a {@link Properties} populated with the contents of <code>bundle</code>\n     *\n     * @param bundle ResourceBundle\n     * @return Properties\n     */\n    public static Properties asProperties(ResourceBundle bundle) {\n        Properties props = new Properties();\n        Enumeration<String> iter = bundle.getKeys();\n        while (iter.hasMoreElements()) {\n            String key = iter.nextElement();\n            props.put(key, bundle.getObject(key));\n        }\n        return props;\n    }\n\n    /**\n     * 'Pull' the specified parameter from the collection of options. Returns\n     * null if the parameter isn't in the list and removes it if it is.\n     *\n     * @param paramId\n     * @return\n     */\n    private String pullParam(String paramId) {\n        return pullParam(paramId, false, false);\n    }\n\n    private String pullRequiredParam(String paramId) {\n        return pullParam(paramId, true, false);\n    }\n\n    /**\n     * @param paramId\n     * @param required\n     * @param dbTypeSpecific\n     * @return\n     * @throws MissingRequiredParameterException\n     */\n    private String pullParam(String paramId, boolean required, boolean dbTypeSpecific) throws MissingRequiredParameterException {\n        int paramIndex = options.indexOf(paramId);\n        if (paramIndex < 0) {\n            if (required)\n                throw new MissingRequiredParameterException(paramId, dbTypeSpecific);\n            return null;\n        }\n        options.remove(paramIndex);\n        String param = options.get(paramIndex).toString();\n        options.remove(paramIndex);\n        return param;\n    }\n\n    /**\n     * Thrown to indicate that a required parameter is missing\n     */\n    public static class MissingRequiredParameterException extends RuntimeException {\n\n        private static final long serialVersionUID = 1L;\n\n        private final boolean dbTypeSpecific;\n\n        public MissingRequiredParameterException(String paramId, boolean dbTypeSpecific) {\n            this(paramId, null, dbTypeSpecific);\n        }\n\n        public MissingRequiredParameterException(String paramId, String description, boolean dbTypeSpecific) {\n            super(\"Required parameter '\" + paramId + \"' \" + (description == null ? \"\" : \"(\" + description + \") \") + \"was not specified.\" + (dbTypeSpecific ? \"  It is required for this database type.\" : \"\"));\n            this.dbTypeSpecific = dbTypeSpecific;\n        }\n\n        public boolean isDbTypeSpecific() {\n            return dbTypeSpecific;\n        }\n    }\n\n    /**\n     * Allow an equal sign in args...like \"-o=foo.bar\". Useful for things like\n     * Ant and Maven.\n     *\n     * @param args\n     *            List\n     * @return List\n     */\n    protected List<String> fixupArgs(List<String> args) {\n        List<String> expandedArgs = new ArrayList<String>();\n        for (String arg : args) {\n            int indexOfEquals = arg.indexOf('=');\n            if (indexOfEquals != -1 && indexOfEquals - 1 != arg.indexOf(ESCAPED_EQUALS)) {\n                expandedArgs.add(arg.substring(0, indexOfEquals));\n                expandedArgs.add(arg.substring(indexOfEquals + 1));\n            } else {\n                expandedArgs.add(arg);\n            }\n        }\n        // some OSes/JVMs do filename expansion with runtime.exec() and some don't,\n        // so MultipleSchemaAnalyzer has to surround params with double quotes...\n        // strip them here for the OSes/JVMs that don't do anything with the params\n        List<String> unquotedArgs = new ArrayList<String>();\n        for (String arg : expandedArgs) {\n            if (// \".*\" becomes .*\n            arg.startsWith(\"\\\"\") && arg.endsWith(\"\\\"\"))\n                arg = arg.substring(1, arg.length() - 1);\n            unquotedArgs.add(arg);\n        }\n        return unquotedArgs;\n    }\n\n    /**\n     * Call all the getters to populate all the lazy initialized stuff.\n     *\n     * @throws InvocationTargetException\n     * @throws IllegalAccessException\n     * @throws IllegalArgumentException\n     * @throws IntrospectionException\n     */\n    private void populate() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IntrospectionException {\n        if (!populating) {\n            // prevent recursion\n            populating = true;\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                Method readMethod = props[i].getReadMethod();\n                if (readMethod != null)\n                    readMethod.invoke(this, (Object[]) null);\n            }\n            populating = false;\n        }\n    }\n\n    public static Set<String> getBuiltInDatabaseTypes(String loadedFromJar) {\n        Set<String> databaseTypes = new TreeSet<String>();\n        JarInputStream jar = null;\n        try {\n            jar = new JarInputStream(new FileInputStream(loadedFromJar));\n            JarEntry entry;\n            while ((entry = jar.getNextJarEntry()) != null) {\n                String entryName = entry.getName();\n                int dotPropsIndex = entryName.indexOf(\".properties\");\n                if (dotPropsIndex != -1)\n                    databaseTypes.add(entryName.substring(0, dotPropsIndex));\n            }\n        } catch (IOException exc) {\n        } finally {\n            if (jar != null) {\n                try {\n                    jar.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n        return databaseTypes;\n    }\n\n    protected void dumpUsage(String errorMessage, boolean detailedDb) {\n        if (errorMessage != null) {\n            System.out.flush();\n            System.err.println(\"*** \" + errorMessage + \" ***\");\n        } else {\n            System.out.println(\"SchemaSpy generates an HTML representation of a database schema's relationships.\");\n        }\n        System.err.flush();\n        System.out.println();\n        if (!detailedDb) {\n            System.out.println(\"Usage:\");\n            System.out.println(\" java -jar \" + getLoadedFromJar() + \" [options]\");\n            System.out.println(\"   -t databaseType       type of database - defaults to ora\");\n            System.out.println(\"                           use -dbhelp for a list of built-in types\");\n            System.out.println(\"   -u user               connect to the database with this user id\");\n            System.out.println(\"   -s schema             defaults to the specified user\");\n            System.out.println(\"   -p password           defaults to no password\");\n            System.out.println(\"   -o outputDirectory    directory to place the generated output in\");\n            System.out.println(\"   -dp pathToDrivers     optional - looks for JDBC drivers here before looking\");\n            System.out.println(\"                           in driverPath in [databaseType].properties.\");\n            System.out.println(\"Go to http://schemaspy.sourceforge.net for a complete list/description\");\n            System.out.println(\" of additional parameters.\");\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"Built-in database types and their required connection parameters:\");\n            for (String type : getBuiltInDatabaseTypes(getLoadedFromJar())) {\n                new DbSpecificConfig(type).dumpUsage();\n            }\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"You can use your own database types by specifying the filespec of a .properties file with -t.\");\n            System.out.println(\"Grab one out of \" + getLoadedFromJar() + \" and modify it to suit your needs.\");\n            System.out.println();\n        }\n        System.out.println(\"Sample usage using the default database type (implied -t ora):\");\n        System.out.println(\" java -jar schemaSpy.jar -db mydb -s myschema -u devuser -p password -o output\");\n        System.out.println();\n        System.out.flush();\n    }\n\n    /**\n     * Get the value of the specified parameter.\n     * Used for properties that are common to most db's, but aren't required.\n     *\n     * @param paramName\n     * @return\n     */\n    public String getParam(String paramName) {\n        try {\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                PropertyDescriptor prop = props[i];\n                if (prop.getName().equalsIgnoreCase(paramName)) {\n                    Object result = prop.getReadMethod().invoke(this, (Object[]) null);\n                    return result == null ? null : result.toString();\n                }\n            }\n        } catch (Exception failed) {\n            failed.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * Return all of the configuration options as a List of Strings, with\n     * each parameter and its value as a separate element.\n     *\n     * @return\n     * @throws IOException\n     */\n    public List<String> asList() throws IOException {\n        List<String> params = new ArrayList<String>();\n        if (originalDbSpecificOptions != null) {\n            for (String key : originalDbSpecificOptions.keySet()) {\n                String value = originalDbSpecificOptions.get(key);\n                if (!key.startsWith(\"-\"))\n                    key = \"-\" + key;\n                params.add(key);\n                params.add(value);\n            }\n        }\n        if (isEncodeCommentsEnabled())\n            params.add(\"-ahic\");\n        if (isEvaluateAllEnabled())\n            params.add(\"-all\");\n        if (!isHtmlGenerationEnabled())\n            params.add(\"-nohtml\");\n        if (!isImpliedConstraintsEnabled())\n            params.add(\"-noimplied\");\n        if (!isLogoEnabled())\n            params.add(\"-nologo\");\n        if (isMeterEnabled())\n            params.add(\"-meter\");\n        if (!isNumRowsEnabled())\n            params.add(\"-norows\");\n        if (!isViewsEnabled())\n            params.add(\"-noviews\");\n        if (isRankDirBugEnabled())\n            params.add(\"-rankdirbug\");\n        if (isRailsEnabled())\n            params.add(\"-rails\");\n        if (isSingleSignOn())\n            params.add(\"-sso\");\n        if (isSchemaDisabled())\n            params.add(\"-noschema\");\n        String value = getDriverPath();\n        if (value != null) {\n            params.add(\"-dp\");\n            params.add(value);\n        }\n        params.add(\"-css\");\n        params.add(getCss());\n        params.add(\"-charset\");\n        params.add(getCharset());\n        params.add(\"-font\");\n        params.add(getFont());\n        params.add(\"-fontsize\");\n        params.add(String.valueOf(getFontSize()));\n        params.add(\"-t\");\n        params.add(getDbType());\n        // query to set renderer correctly\n        isHighQuality();\n        // query to set renderer correctly\n        isLowQuality();\n        // instead of -hq and/or -lq\n        params.add(\"-renderer\");\n        params.add(getRenderer());\n        value = getDescription();\n        if (value != null) {\n            params.add(\"-desc\");\n            params.add(value);\n        }\n        value = getPassword();\n        if (value != null && !isPromptForPasswordEnabled()) {\n            // note that we don't pass -pfp since child processes\n            // won't have a console\n            params.add(\"-p\");\n            params.add(value);\n        }\n        value = getCatalog();\n        if (value != null) {\n            params.add(\"-cat\");\n            params.add(value);\n        }\n        value = getSchema();\n        if (value != null) {\n            params.add(\"-s\");\n            params.add(value);\n        }\n        value = getUser();\n        if (value != null) {\n            params.add(\"-u\");\n            params.add(value);\n        }\n        value = getConnectionPropertiesFile();\n        if (value != null) {\n            params.add(\"-connprops\");\n            params.add(value);\n        } else {\n            Properties props = getConnectionProperties();\n            if (!props.isEmpty()) {\n                params.add(\"-connprops\");\n                StringBuilder buf = new StringBuilder();\n                for (Entry<Object, Object> entry : props.entrySet()) {\n                    buf.append(entry.getKey());\n                    buf.append(ESCAPED_EQUALS);\n                    buf.append(entry.getValue());\n                    buf.append(';');\n                }\n                params.add(buf.toString());\n            }\n        }\n        value = getDb();\n        if (value != null) {\n            params.add(\"-db\");\n            params.add(value);\n        }\n        value = getHost();\n        if (value != null) {\n            params.add(\"-host\");\n            params.add(value);\n        }\n        if (getPort() != null) {\n            params.add(\"-port\");\n            params.add(getPort().toString());\n        }\n        value = getServer();\n        if (value != null) {\n            params.add(\"-server\");\n            params.add(value);\n        }\n        value = getMeta();\n        if (value != null) {\n            params.add(\"-meta\");\n            params.add(value);\n        }\n        if (getGraphvizDir() != null) {\n            params.add(\"-gv\");\n            params.add(getGraphvizDir().toString());\n        }\n        params.add(\"-loglevel\");\n        params.add(getLogLevel().toString().toLowerCase());\n        params.add(\"-sqlFormatter\");\n        params.add(getSqlFormatter().getClass().getName());\n        params.add(\"-i\");\n        params.add(getTableInclusions().toString());\n        params.add(\"-I\");\n        params.add(getTableExclusions().toString());\n        params.add(\"-X\");\n        params.add(getColumnExclusions().toString());\n        params.add(\"-x\");\n        params.add(getIndirectColumnExclusions().toString());\n        params.add(\"-dbthreads\");\n        params.add(String.valueOf(getMaxDbThreads()));\n        params.add(\"-maxdet\");\n        params.add(String.valueOf(getMaxDetailedTables()));\n        params.add(\"-o\");\n        params.add(getOutputDir().toString());\n        return params;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/ConfigTest14.java",
		"test_prompt": "// ConfigTest14.java\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Config}.\n* It contains ten unit test cases for the {@link Config#isOneOfMultipleSchemas()} method.\n*/\nclass ConfigTest14 {"
	},
	{
		"original_code": "// Config.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\n\n/**\n * Configuration of a SchemaSpy run\n *\n * @author John Currier\n */\npublic class Config {\n\n    private static Config instance;\n\n    private final List<String> options;\n\n    private Map<String, String> dbSpecificOptions;\n\n    private Map<String, String> originalDbSpecificOptions;\n\n    private boolean helpRequired;\n\n    private boolean dbHelpRequired;\n\n    private File outputDir;\n\n    private File graphvizDir;\n\n    private String dbType;\n\n    private String catalog;\n\n    private String schema;\n\n    private List<String> schemas;\n\n    private String user;\n\n    private Boolean singleSignOn;\n\n    private Boolean noSchema;\n\n    private String password;\n\n    private Boolean promptForPassword;\n\n    private String db;\n\n    private String host;\n\n    private Integer port;\n\n    private String server;\n\n    private String meta;\n\n    private Pattern tableInclusions;\n\n    private Pattern tableExclusions;\n\n    private Pattern columnExclusions;\n\n    private Pattern indirectColumnExclusions;\n\n    private String userConnectionPropertiesFile;\n\n    private Properties userConnectionProperties;\n\n    private Integer maxDbThreads;\n\n    private Integer maxDetailedTables;\n\n    private String driverPath;\n\n    private String css;\n\n    private String charset;\n\n    private String font;\n\n    private Integer fontSize;\n\n    private String description;\n\n    private Properties dbProperties;\n\n    private String dbPropertiesLoadedFrom;\n\n    private Level logLevel;\n\n    private SqlFormatter sqlFormatter;\n\n    private String sqlFormatterClass;\n\n    private Boolean generateHtml;\n\n    private Boolean includeImpliedConstraints;\n\n    private Boolean logoEnabled;\n\n    private Boolean rankDirBugEnabled;\n\n    private Boolean encodeCommentsEnabled;\n\n    private Boolean numRowsEnabled;\n\n    private Boolean viewsEnabled;\n\n    private Boolean meterEnabled;\n\n    private Boolean railsEnabled;\n\n    private Boolean evaluteAll;\n\n    private Boolean highQuality;\n\n    private Boolean lowQuality;\n\n    // used in conjunction with evaluateAll\n    private String schemaSpec;\n\n    private boolean hasOrphans = false;\n\n    private boolean hasRoutines = false;\n\n    private boolean populating = false;\n\n    private List<String> columnDetails;\n\n    public static final String DOT_CHARSET = \"UTF-8\";\n\n    private static final String ESCAPED_EQUALS = \"\\\\=\";\n\n    // match everything\n    private static final String DEFAULT_TABLE_INCLUSION = \".*\";\n\n    // match nothing\n    private static final String DEFAULT_TABLE_EXCLUSION = \"\";\n\n    // match nothing\n    private static final String DEFAULT_COLUMN_EXCLUSION = \"[^.]\";\n\n    /**\n     * Default constructor. Intended for when you want to inject properties\n     * independently (i.e. not from a command line interface).\n     */\n    public Config() {\n        if (instance == null)\n            setInstance(this);\n        options = new ArrayList<String>();\n    }\n\n    /**\n     * Construct a configuration from an array of options (e.g. from a command\n     * line interface).\n     *\n     * @param options\n     */\n    public Config(String[] argv) {\n        setInstance(this);\n        options = fixupArgs(Arrays.asList(argv));\n        helpRequired = options.remove(\"-?\") || options.remove(\"/?\") || options.remove(\"?\") || options.remove(\"-h\") || options.remove(\"-help\") || options.remove(\"--help\");\n        dbHelpRequired = options.remove(\"-dbHelp\") || options.remove(\"-dbhelp\");\n    }\n\n    public static Config getInstance() {\n        if (instance == null)\n            instance = new Config();\n        return instance;\n    }\n\n    /**\n     * Sets the global instance.\n     *\n     * Useful for things like selecting a specific configuration in a UI.\n     *\n     * @param config\n     */\n    public static void setInstance(Config config) {\n        instance = config;\n    }\n\n    public void setHtmlGenerationEnabled(boolean generateHtml) {\n        this.generateHtml = generateHtml;\n    }\n\n    public boolean isHtmlGenerationEnabled() {\n        if (generateHtml == null)\n            generateHtml = !options.remove(\"-nohtml\");\n        return generateHtml;\n    }\n\n    public void setImpliedConstraintsEnabled(boolean includeImpliedConstraints) {\n        this.includeImpliedConstraints = includeImpliedConstraints;\n    }\n\n    public boolean isImpliedConstraintsEnabled() {\n        if (includeImpliedConstraints == null)\n            includeImpliedConstraints = !options.remove(\"-noimplied\");\n        return includeImpliedConstraints;\n    }\n\n    public void setOutputDir(String outputDirName) {\n        if (outputDirName.endsWith(\"\\\"\"))\n            outputDirName = outputDirName.substring(0, outputDirName.length() - 1);\n        setOutputDir(new File(outputDirName));\n    }\n\n    public void setOutputDir(File outputDir) {\n        this.outputDir = outputDir;\n    }\n\n    public File getOutputDir() {\n        if (outputDir == null) {\n            setOutputDir(pullRequiredParam(\"-o\"));\n        }\n        return outputDir;\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(String graphvizDir) {\n        if (graphvizDir.endsWith(\"\\\"\"))\n            graphvizDir = graphvizDir.substring(0, graphvizDir.length() - 1);\n        setGraphvizDir(new File(graphvizDir));\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(File graphvizDir) {\n        this.graphvizDir = graphvizDir;\n    }\n\n    /**\n     * Return the path to Graphviz (used to find the dot executable to run to\n     * generate ER diagrams).<p/>\n     *\n     * Returns {@link #getDefaultGraphvizPath()} if a specific Graphviz path\n     * was not specified.\n     *\n     * @return\n     */\n    public File getGraphvizDir() {\n        if (graphvizDir == null) {\n            String gv = pullParam(\"-gv\");\n            if (gv != null) {\n                setGraphvizDir(gv);\n            } else {\n                // expect to find Graphviz's bin directory on the PATH\n            }\n        }\n        return graphvizDir;\n    }\n\n    /**\n     * Meta files are XML-based files that provide additional metadata\n     * about the schema being evaluated.<p>\n     * <code>meta</code> is either the name of an individual XML file or\n     * the directory that contains meta files.<p>\n     * If a directory is specified then it is expected to contain files\n     * matching the pattern <code>[schema].meta.xml</code>.\n     * For databases that don't have schema substitute database for schema.\n     * @param meta\n     */\n    public void setMeta(String meta) {\n        this.meta = meta;\n    }\n\n    public String getMeta() {\n        if (meta == null)\n            meta = pullParam(\"-meta\");\n        return meta;\n    }\n\n    public void setDbType(String dbType) {\n        this.dbType = dbType;\n    }\n\n    public String getDbType() {\n        if (dbType == null) {\n            dbType = pullParam(\"-t\");\n            if (dbType == null)\n                dbType = \"ora\";\n        }\n        return dbType;\n    }\n\n    public void setDb(String db) {\n        this.db = db;\n    }\n\n    public String getDb() {\n        if (db == null)\n            db = pullParam(\"-db\");\n        return db;\n    }\n\n    public void setCatalog(String catalog) {\n        this.catalog = catalog;\n    }\n\n    public String getCatalog() {\n        if (catalog == null)\n            catalog = pullParam(\"-cat\");\n        return catalog;\n    }\n\n    public void setSchema(String schema) {\n        this.schema = schema;\n    }\n\n    public String getSchema() {\n        if (schema == null)\n            schema = pullParam(\"-s\");\n        return schema;\n    }\n\n    /**\n     * Some databases types (e.g. older versions of Informix) don't really\n     * have the concept of a schema but still return true from\n     * {@link DatabaseMetaData#supportsSchemasInTableDefinitions()}.\n     * This option lets you ignore that and treat all the tables\n     * as if they were in one flat namespace.\n     */\n    public boolean isSchemaDisabled() {\n        if (noSchema == null)\n            noSchema = options.remove(\"-noschema\");\n        return noSchema;\n    }\n\n    public void setHost(String host) {\n        this.host = host;\n    }\n\n    public String getHost() {\n        if (host == null)\n            host = pullParam(\"-host\");\n        return host;\n    }\n\n    public void setPort(Integer port) {\n        this.port = port;\n    }\n\n    public Integer getPort() {\n        if (port == null)\n            try {\n                port = Integer.valueOf(pullParam(\"-port\"));\n            } catch (Exception notSpecified) {\n            }\n        return port;\n    }\n\n    public void setServer(String server) {\n        this.server = server;\n    }\n\n    public String getServer() {\n        if (server == null) {\n            server = pullParam(\"-server\");\n        }\n        return server;\n    }\n\n    public void setUser(String user) {\n        this.user = user;\n    }\n\n    /**\n     * User used to connect to the database.\n     * Required unless single sign-on is enabled\n     * (see {@link #setSingleSignOn(boolean)}).\n     * @return\n     */\n    public String getUser() {\n        if (user == null) {\n            if (!isSingleSignOn())\n                user = pullRequiredParam(\"-u\");\n            else\n                user = pullParam(\"-u\");\n        }\n        return user;\n    }\n\n    /**\n     * By default a \"user\" (as specified with -u) is required.\n     * This option allows disabling of that requirement for\n     * single sign-on environments.\n     *\n     * @param enabled defaults to <code>false</code>\n     */\n    public void setSingleSignOn(boolean enabled) {\n        singleSignOn = enabled;\n    }\n\n    /**\n     * @see #setSingleSignOn(boolean)\n     */\n    public boolean isSingleSignOn() {\n        if (singleSignOn == null)\n            singleSignOn = options.remove(\"-sso\");\n        return singleSignOn;\n    }\n\n    /**\n     * Set the password used to connect to the database.\n     * @param password\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * @see #setPassword(String)\n     * @return\n     */\n    public String getPassword() {\n        if (password == null)\n            password = pullParam(\"-p\");\n        if (password == null && isPromptForPasswordEnabled())\n            password = new String(PasswordReader.getInstance().readPassword(\"Password: \"));\n        if (password == null) {\n            // if -pfp is enabled when analyzing multiple schemas then\n            // we don't want to send the password on the command line,\n            // so see if it was passed in the environment (not ideal, but safer)\n            password = System.getenv(\"schemaspy.pw\");\n        }\n        return password;\n    }\n\n    /**\n     * Set to <code>true</code> to prompt for the password\n     * @param promptForPassword\n     */\n    public void setPromptForPasswordEnabled(boolean promptForPassword) {\n        this.promptForPassword = promptForPassword;\n    }\n\n    /**\n     * @see #setPromptForPasswordEnabled(boolean)\n     * @return\n     */\n    public boolean isPromptForPasswordEnabled() {\n        if (promptForPassword == null) {\n            promptForPassword = options.remove(\"-pfp\");\n        }\n        return promptForPassword;\n    }\n\n    public void setMaxDetailedTabled(int maxDetailedTables) {\n        this.maxDetailedTables = new Integer(maxDetailedTables);\n    }\n\n    public int getMaxDetailedTables() {\n        if (maxDetailedTables == null) {\n            // default\n            int max = 300;\n            try {\n                max = Integer.parseInt(pullParam(\"-maxdet\"));\n            } catch (Exception notSpecified) {\n            }\n            maxDetailedTables = new Integer(max);\n        }\n        return maxDetailedTables.intValue();\n    }\n\n    public String getConnectionPropertiesFile() {\n        return userConnectionPropertiesFile;\n    }\n\n    /**\n     * Properties from this file (in key=value pair format) are passed to the\n     * database connection.<br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.\n     * @param propertiesFilename\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public void setConnectionPropertiesFile(String propertiesFilename) throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null)\n            userConnectionProperties = new Properties();\n        userConnectionProperties.load(new FileInputStream(propertiesFilename));\n        userConnectionPropertiesFile = propertiesFilename;\n    }\n\n    /**\n     * Returns a {@link Properties} populated either from the properties file specified\n     * by {@link #setConnectionPropertiesFile(String)}, the properties specified by\n     * {@link #setConnectionProperties(String)} or not populated.\n     * @return\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public Properties getConnectionProperties() throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null) {\n            String props = pullParam(\"-connprops\");\n            if (props != null) {\n                if (props.indexOf(ESCAPED_EQUALS) != -1) {\n                    setConnectionProperties(props);\n                } else {\n                    setConnectionPropertiesFile(props);\n                }\n            } else {\n                userConnectionProperties = new Properties();\n            }\n        }\n        return userConnectionProperties;\n    }\n\n    /**\n     * Specifies connection properties to use in the format:\n     * <code>key1\\=value1;key2\\=value2</code><br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.<p>\n     * This is an alternative form of passing connection properties than by file\n     * (see {@link #setConnectionPropertiesFile(String)})\n     *\n     * @param properties\n     */\n    public void setConnectionProperties(String properties) {\n        userConnectionProperties = new Properties();\n        StringTokenizer tokenizer = new StringTokenizer(properties, \";\");\n        while (tokenizer.hasMoreElements()) {\n            String pair = tokenizer.nextToken();\n            int index = pair.indexOf(ESCAPED_EQUALS);\n            if (index != -1) {\n                String key = pair.substring(0, index);\n                String value = pair.substring(index + ESCAPED_EQUALS.length());\n                userConnectionProperties.put(key, value);\n            }\n        }\n    }\n\n    public void setDriverPath(String driverPath) {\n        this.driverPath = driverPath;\n    }\n\n    public String getDriverPath() {\n        if (driverPath == null)\n            driverPath = pullParam(\"-dp\");\n        // was previously -cp:\n        if (driverPath == null)\n            driverPath = pullParam(\"-cp\");\n        return driverPath;\n    }\n\n    /**\n     * The filename of the cascading style sheet to use.\n     * Note that this file is parsed and used to determine characteristics\n     * of the generated diagrams, so it must contain specific settings that\n     * are documented within schemaSpy.css.<p>\n     *\n     * Defaults to <code>\"schemaSpy.css\"</code>.\n     *\n     * @param css\n     */\n    public void setCss(String css) {\n        this.css = css;\n    }\n\n    public String getCss() {\n        if (css == null) {\n            css = pullParam(\"-css\");\n            if (css == null)\n                css = \"schemaSpy.css\";\n        }\n        return css;\n    }\n\n    /**\n     * The font to use within diagrams.  Modify the .css to specify HTML fonts.\n     *\n     * @param font\n     */\n    public void setFont(String font) {\n        this.font = font;\n    }\n\n    /**\n     * @see #setFont(String)\n     */\n    public String getFont() {\n        if (font == null) {\n            font = pullParam(\"-font\");\n            if (font == null)\n                font = \"Helvetica\";\n        }\n        return font;\n    }\n\n    /**\n     * The font size to use within diagrams.  This is the size of the font used for\n     * 'large' (e.g. not 'compact') diagrams.<p>\n     *\n     * Modify the .css to specify HTML font sizes.<p>\n     *\n     * Defaults to 11.\n     *\n     * @param fontSize\n     */\n    public void setFontSize(int fontSize) {\n        this.fontSize = new Integer(fontSize);\n    }\n\n    /**\n     * @see #setFontSize(int)\n     * @return\n     */\n    public int getFontSize() {\n        if (fontSize == null) {\n            // default\n            int size = 11;\n            try {\n                size = Integer.parseInt(pullParam(\"-fontsize\"));\n            } catch (Exception notSpecified) {\n            }\n            fontSize = new Integer(size);\n        }\n        return fontSize.intValue();\n    }\n\n    /**\n     * The character set to use within HTML pages (defaults to <code>\"ISO-8859-1\"</code>).\n     *\n     * @param charset\n     */\n    public void setCharset(String charset) {\n        this.charset = charset;\n    }\n\n    /**\n     * @see #setCharset(String)\n     */\n    public String getCharset() {\n        if (charset == null) {\n            charset = pullParam(\"-charset\");\n            if (charset == null)\n                charset = \"ISO-8859-1\";\n        }\n        return charset;\n    }\n\n    /**\n     * Description of schema that gets display on main pages.\n     *\n     * @param description\n     */\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    /**\n     * @see #setDescription(String)\n     */\n    public String getDescription() {\n        if (description == null)\n            description = pullParam(\"-desc\");\n        return description;\n    }\n\n    /**\n     * Maximum number of threads to use when querying database metadata information.\n     *\n     * @param maxDbThreads\n     */\n    public void setMaxDbThreads(int maxDbThreads) {\n        this.maxDbThreads = new Integer(maxDbThreads);\n    }\n\n    /**\n     * @see #setMaxDbThreads(int)\n     * @throws InvalidConfigurationException if unable to load properties\n     */\n    public int getMaxDbThreads() throws InvalidConfigurationException {\n        if (maxDbThreads == null) {\n            Properties properties;\n            try {\n                properties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(\"Failed to load properties for \" + getDbType() + \": \" + exc).setParamName(\"-type\");\n            }\n            // not scientifically derived\n            final int defaultMax = 15;\n            int max = defaultMax;\n            String threads = properties.getProperty(\"dbThreads\");\n            if (threads == null)\n                threads = properties.getProperty(\"dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            threads = pullParam(\"-dbThreads\");\n            if (threads == null)\n                threads = pullParam(\"-dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            if (max < 0)\n                max = defaultMax;\n            else if (max == 0)\n                max = 1;\n            maxDbThreads = new Integer(max);\n        }\n        return maxDbThreads.intValue();\n    }\n\n    public boolean isLogoEnabled() {\n        if (logoEnabled == null)\n            logoEnabled = !options.remove(\"-nologo\");\n        return logoEnabled;\n    }\n\n    /**\n     * Don't use this unless absolutely necessary as it screws up the layout\n     *\n     * @param enabled\n     */\n    public void setRankDirBugEnabled(boolean enabled) {\n        rankDirBugEnabled = enabled;\n    }\n\n    /**\n     * @see #setRankDirBugEnabled(boolean)\n     */\n    public boolean isRankDirBugEnabled() {\n        if (rankDirBugEnabled == null)\n            rankDirBugEnabled = options.remove(\"-rankdirbug\");\n        return rankDirBugEnabled;\n    }\n\n    /**\n     * Look for Ruby on Rails-based naming conventions in\n     * relationships between logical foreign keys and primary keys.<p>\n     *\n     * Basically all tables have a primary key named <code>ID</code>.\n     * All tables are named plural names.\n     * The columns that logically reference that <code>ID</code> are the singular\n     * form of the table name suffixed with <code>_ID</code>.<p>\n     *\n     * @param enabled\n     */\n    public void setRailsEnabled(boolean enabled) {\n        railsEnabled = enabled;\n    }\n\n    /**\n     * @see #setRailsEnabled(boolean)\n     *\n     * @return\n     */\n    public boolean isRailsEnabled() {\n        if (railsEnabled == null)\n            railsEnabled = options.remove(\"-rails\");\n        return railsEnabled;\n    }\n\n    /**\n     * Allow Html In Comments - encode them unless otherwise specified\n     */\n    public void setEncodeCommentsEnabled(boolean enabled) {\n        encodeCommentsEnabled = enabled;\n    }\n\n    /**\n     * @see #setEncodeCommentsEnabled(boolean)\n     */\n    public boolean isEncodeCommentsEnabled() {\n        if (encodeCommentsEnabled == null)\n            encodeCommentsEnabled = !options.remove(\"-ahic\");\n        return encodeCommentsEnabled;\n    }\n\n    /**\n     * If enabled we'll attempt to query/render the number of rows that\n     * each table contains.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setNumRowsEnabled(boolean enabled) {\n        numRowsEnabled = enabled;\n    }\n\n    /**\n     * @see #setNumRowsEnabled(boolean)\n     * @return\n     */\n    public boolean isNumRowsEnabled() {\n        if (numRowsEnabled == null)\n            numRowsEnabled = !options.remove(\"-norows\");\n        return numRowsEnabled;\n    }\n\n    /**\n     * If enabled we'll include views in the analysis.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setViewsEnabled(boolean enabled) {\n        viewsEnabled = enabled;\n    }\n\n    /**\n     * @see #setViewsEnabled(boolean)\n     * @return\n     */\n    public boolean isViewsEnabled() {\n        if (viewsEnabled == null)\n            viewsEnabled = !options.remove(\"-noviews\");\n        return viewsEnabled;\n    }\n\n    /**\n     * Returns <code>true</code> if metering should be embedded in\n     * the generated pages.<p/>\n     * Defaults to <code>false</code> (disabled).\n     * @return\n     */\n    public boolean isMeterEnabled() {\n        if (meterEnabled == null)\n            meterEnabled = options.remove(\"-meter\");\n        return meterEnabled;\n    }\n\n    /**\n     * Set the columns to exclude from all relationship diagrams.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setColumnExclusions(String columnExclusions) {\n        this.columnExclusions = Pattern.compile(columnExclusions);\n    }\n\n    /**\n     * See {@link #setColumnExclusions(String)}\n     * @return\n     */\n    public Pattern getColumnExclusions() {\n        if (columnExclusions == null) {\n            String strExclusions = pullParam(\"-X\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.columnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            columnExclusions = Pattern.compile(strExclusions);\n        }\n        return columnExclusions;\n    }\n\n    /**\n     * Set the columns to exclude from relationship diagrams where the specified\n     * columns aren't directly referenced by the focal table.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setIndirectColumnExclusions(String fullColumnExclusions) {\n        indirectColumnExclusions = Pattern.compile(fullColumnExclusions);\n    }\n\n    /**\n     * @see #setIndirectColumnExclusions(String)\n     *\n     * @return\n     */\n    public Pattern getIndirectColumnExclusions() {\n        if (indirectColumnExclusions == null) {\n            String strExclusions = pullParam(\"-x\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.indirectColumnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            indirectColumnExclusions = Pattern.compile(strExclusions);\n        }\n        return indirectColumnExclusions;\n    }\n\n    /**\n     * Set the tables to include as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableInclusions(String tableInclusions) {\n        this.tableInclusions = Pattern.compile(tableInclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to include in the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableInclusions() {\n        if (tableInclusions == null) {\n            String strInclusions = pullParam(\"-i\");\n            if (strInclusions == null)\n                strInclusions = System.getenv(\"schemaspy.tableInclusions\");\n            if (strInclusions == null)\n                strInclusions = DEFAULT_TABLE_INCLUSION;\n            try {\n                tableInclusions = Pattern.compile(strInclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-i\");\n            }\n        }\n        return tableInclusions;\n    }\n\n    /**\n     * Set the tables to exclude as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableExclusions(String tableExclusions) {\n        this.tableExclusions = Pattern.compile(tableExclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to exclude from the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableExclusions() {\n        if (tableExclusions == null) {\n            String strExclusions = pullParam(\"-I\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.tableExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_TABLE_EXCLUSION;\n            try {\n                tableExclusions = Pattern.compile(strExclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-I\");\n            }\n        }\n        return tableExclusions;\n    }\n\n    /**\n     * @return\n     */\n    public List<String> getSchemas() {\n        if (schemas == null) {\n            String tmp = pullParam(\"-schemas\");\n            if (tmp == null)\n                tmp = pullParam(\"-schemata\");\n            if (tmp != null) {\n                schemas = new ArrayList<String>();\n                for (String name : tmp.split(\"[\\\\s,'\\\"]\")) {\n                    if (name.length() > 0)\n                        schemas.add(name);\n                }\n                if (schemas.isEmpty())\n                    schemas = null;\n            }\n        }\n        return schemas;\n    }\n\n    /**\n     * Set the name of the {@link SqlFormatter SQL formatter} class to use to\n     * format SQL into HTML.<p/>\n     * The implementation of the class must be made available to the class\n     * loader, typically by specifying the path to its jar with <em>-dp</em>\n     * ({@link #setDriverPath(String)}).\n     */\n    public void setSqlFormatter(String formatterClassName) {\n        sqlFormatterClass = formatterClassName;\n        sqlFormatter = null;\n    }\n\n    /**\n     * Set the {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.\n     */\n    public void setSqlFormatter(SqlFormatter sqlFormatter) {\n        this.sqlFormatter = sqlFormatter;\n        if (sqlFormatter != null)\n            sqlFormatterClass = sqlFormatter.getClass().getName();\n    }\n\n    /**\n     * Returns an implementation of {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.  The default implementation is {@link DefaultSqlFormatter}.\n     *\n     * @return\n     * @throws InvalidConfigurationException if unable to instantiate an instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SqlFormatter getSqlFormatter() throws InvalidConfigurationException {\n        if (sqlFormatter == null) {\n            if (sqlFormatterClass == null) {\n                sqlFormatterClass = pullParam(\"-sqlFormatter\");\n                if (sqlFormatterClass == null)\n                    sqlFormatterClass = DefaultSqlFormatter.class.getName();\n            }\n            try {\n                Class<SqlFormatter> clazz = (Class<SqlFormatter>) Class.forName(sqlFormatterClass);\n                sqlFormatter = clazz.newInstance();\n            } catch (Exception exc) {\n                throw new InvalidConfigurationException(\"Failed to initialize instance of SQL formatter: \", exc).setParamName(\"-sqlFormatter\");\n            }\n        }\n        return sqlFormatter;\n    }\n\n    /**\n     * Set the details to show on the columns page, where \"details\" are\n     * comma and/or space separated.\n     *\n     * Valid values:\n     * <ul>\n     * <li>id</li>\n     * <li>table</li>\n     * <li>column</li>\n     * <li>type</li>\n     * <li>size</li>\n     * <li>nulls</li>\n     * <li>auto</li>\n     * <li>default</li>\n     * <li>children</li>\n     * <li>parents</li>\n     * </ul>\n     *\n     * The default details are <code>\"table column type size nulls auto default\"</code>.\n     * Note that \"column\" is the initially displayed detail and must be included.\n     *\n     * @param columnDetails\n     */\n    public void setColumnDetails(String columnDetails) {\n        this.columnDetails = new ArrayList<String>();\n        if (columnDetails == null || columnDetails.length() == 0) {\n            // not specified, so use defaults\n            columnDetails = \"id table column type size nulls auto default\";\n        }\n        for (String detail : columnDetails.split(\"[\\\\s,'\\\"]\")) {\n            if (detail.length() > 0) {\n                this.columnDetails.add(detail.toLowerCase());\n            }\n        }\n        if (!this.columnDetails.contains(\"column\"))\n            throw new InvalidConfigurationException(\"'column' is a required column detail\");\n    }\n\n    public void setColumnDetails(List<String> columnDetails) {\n        String details = columnDetails == null ? \"[]\" : columnDetails.toString();\n        setColumnDetails(details.substring(1, details.length() - 1));\n    }\n\n    public List<String> getColumnDetails() {\n        if (columnDetails == null) {\n            setColumnDetails(pullParam(\"-columndetails\"));\n        }\n        return columnDetails;\n    }\n\n    public void setEvaluateAllEnabled(boolean enabled) {\n        evaluteAll = enabled;\n    }\n\n    public boolean isEvaluateAllEnabled() {\n        if (evaluteAll == null)\n            evaluteAll = options.remove(\"-all\");\n        return evaluteAll;\n    }\n\n    /**\n     * Returns true if we're evaluating a bunch of schemas in one go and\n     * at this point we're evaluating a specific schema.\n     *\n     * @return boolean\n     */\n    public boolean isOneOfMultipleSchemas() {\n        // set by MultipleSchemaAnalyzer\n        return Boolean.getBoolean(\"oneofmultipleschemas\");\n    }\n\n    /**\n     * When -all (evaluateAll) is specified then this is the regular\n     * expression that determines which schemas to evaluate.\n     *\n     * @param schemaSpec\n     */\n    public void setSchemaSpec(String schemaSpec) {\n        this.schemaSpec = schemaSpec;\n    }\n\n    public String getSchemaSpec() {\n        if (schemaSpec == null)\n            schemaSpec = pullParam(\"-schemaSpec\");\n        return schemaSpec;\n    }\n\n    /**\n     * Set the renderer to use for the -Tpng[:renderer[:formatter]] dot option as specified\n     * at <a href='http://www.graphviz.org/doc/info/command.html'>\n     * http://www.graphviz.org/doc/info/command.html</a>.<p>\n     * Note that the leading \":\" is required while :formatter is optional.<p>\n     * The default renderer is typically GD.<p>\n     * Note that using {@link #setHighQuality(boolean)} is the preferred approach\n     * over using this method.\n     */\n    public void setRenderer(String renderer) {\n        Dot.getInstance().setRenderer(renderer);\n    }\n\n    /**\n     * @see #setRenderer(String)\n     * @return\n     */\n    public String getRenderer() {\n        String renderer = pullParam(\"-renderer\");\n        if (renderer != null)\n            setRenderer(renderer);\n        return Dot.getInstance().getRenderer();\n    }\n\n    /**\n     * If <code>false</code> then generate output of \"lower quality\"\n     * than the default.\n     * Note that the default is intended to be \"higher quality\",\n     * but various installations of Graphviz may have have different abilities.\n     * That is, some might not have the \"lower quality\" libraries and others might\n     * not have the \"higher quality\" libraries.<p>\n     * Higher quality output takes longer to generate and results in significantly\n     * larger image files (which take longer to download / display), but it generally\n     * looks better.\n     */\n    public void setHighQuality(boolean highQuality) {\n        this.highQuality = highQuality;\n        lowQuality = !highQuality;\n        Dot.getInstance().setHighQuality(highQuality);\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isHighQuality() {\n        if (highQuality == null) {\n            highQuality = options.remove(\"-hq\");\n            if (highQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(highQuality);\n            }\n        }\n        highQuality = Dot.getInstance().isHighQuality();\n        return highQuality;\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isLowQuality() {\n        if (lowQuality == null) {\n            lowQuality = options.remove(\"-lq\");\n            if (lowQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(!lowQuality);\n            }\n        }\n        lowQuality = !Dot.getInstance().isHighQuality();\n        return lowQuality;\n    }\n\n    /**\n     * Set the level of logging to perform.<p/>\n     * The levels in descending order are:\n     * <ul>\n     *  <li><code>severe</code> (highest - least detail)\n     *  <li><code>warning</code> (default)\n     *  <li><code>info</code>\n     *  <li><code>config</code>\n     *  <li><code>fine</code>\n     *  <li><code>finer</code>\n     *  <li><code>finest</code>  (lowest - most detail)\n     * </ul>\n     *\n     * @param logLevel\n     */\n    public void setLogLevel(String logLevel) {\n        if (logLevel == null) {\n            this.logLevel = Level.WARNING;\n            return;\n        }\n        Map<String, Level> levels = new LinkedHashMap<String, Level>();\n        levels.put(\"severe\", Level.SEVERE);\n        levels.put(\"warning\", Level.WARNING);\n        levels.put(\"info\", Level.INFO);\n        levels.put(\"config\", Level.CONFIG);\n        levels.put(\"fine\", Level.FINE);\n        levels.put(\"finer\", Level.FINER);\n        levels.put(\"finest\", Level.FINEST);\n        this.logLevel = levels.get(logLevel.toLowerCase());\n        if (this.logLevel == null) {\n            throw new InvalidConfigurationException(\"Invalid logLevel: '\" + logLevel + \"'. Must be one of: \" + levels.keySet());\n        }\n    }\n\n    /**\n     * Returns the level of logging to perform.\n     * See {@link #setLogLevel(String)}.\n     *\n     * @return\n     */\n    public Level getLogLevel() {\n        if (logLevel == null) {\n            setLogLevel(pullParam(\"-loglevel\"));\n        }\n        return logLevel;\n    }\n\n    /**\n     * Returns <code>true</code> if the options indicate that the user wants\n     * to see some help information.\n     *\n     * @return\n     */\n    public boolean isHelpRequired() {\n        return helpRequired;\n    }\n\n    public boolean isDbHelpRequired() {\n        return dbHelpRequired;\n    }\n\n    /**\n     * Returns the jar that we were loaded from\n     *\n     * @return\n     */\n    public static String getLoadedFromJar() {\n        String classpath = System.getProperty(\"java.class.path\");\n        return new StringTokenizer(classpath, File.pathSeparator).nextToken();\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasOrphans(boolean hasOrphans) {\n        this.hasOrphans = hasOrphans;\n    }\n\n    /**\n     * @see #setHasOrphans()\n     *\n     * @return\n     */\n    public boolean hasOrphans() {\n        return hasOrphans;\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasRoutines(boolean hasRoutines) {\n        this.hasRoutines = hasRoutines;\n    }\n\n    /**\n     * @see #setHasRoutines()\n     *\n     * @return\n     */\n    public boolean hasRoutines() {\n        return hasRoutines;\n    }\n\n    /**\n     * Returns the database properties to use.\n     * These should be determined by calling {@link #determineDbProperties(String)}.\n     * @return\n     * @throws InvalidConfigurationException\n     */\n    public Properties getDbProperties() throws InvalidConfigurationException {\n        if (dbProperties == null) {\n            try {\n                dbProperties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(exc);\n            }\n        }\n        return dbProperties;\n    }\n\n    /**\n     * Determines the database properties associated with the specified type.\n     * A call to {@link #setDbProperties(Properties)} is expected after determining\n     * the complete set of properties.\n     *\n     * @param type\n     * @return\n     * @throws IOException\n     * @throws InvalidConfigurationException if db properties are incorrectly formed\n     */\n    public Properties determineDbProperties(String type) throws IOException, InvalidConfigurationException {\n        ResourceBundle bundle = null;\n        try {\n            File propertiesFile = new File(type);\n            bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n            dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n        } catch (FileNotFoundException notFoundOnFilesystemWithoutExtension) {\n            try {\n                File propertiesFile = new File(type + \".properties\");\n                bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n                dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n            } catch (FileNotFoundException notFoundOnFilesystemWithExtensionTackedOn) {\n                try {\n                    bundle = ResourceBundle.getBundle(type);\n                    dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]\" + File.separator + type + \".properties\";\n                } catch (Exception notInJarWithoutPath) {\n                    try {\n                        String path = TableOrderer.class.getPackage().getName() + \".dbTypes.\" + type;\n                        path = path.replace('.', '/');\n                        bundle = ResourceBundle.getBundle(path);\n                        dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]/\" + path + \".properties\";\n                    } catch (Exception notInJar) {\n                        notInJar.printStackTrace();\n                        notFoundOnFilesystemWithExtensionTackedOn.printStackTrace();\n                        throw notFoundOnFilesystemWithoutExtension;\n                    }\n                }\n            }\n        }\n        Properties props = asProperties(bundle);\n        bundle = null;\n        // keep original thru recursion\n        String saveLoadedFrom = dbPropertiesLoadedFrom;\n        // bring in key/values pointed to by the include directive\n        // example: include.1=mysql::selectRowCountSql\n        for (int i = 1; true; ++i) {\n            String include = (String) props.remove(\"include.\" + i);\n            if (include == null)\n                break;\n            int separator = include.indexOf(\"::\");\n            if (separator == -1)\n                throw new InvalidConfigurationException(\"include directive in \" + dbPropertiesLoadedFrom + \" must have '::' between dbType and key\");\n            String refdType = include.substring(0, separator).trim();\n            String refdKey = include.substring(separator + 2).trim();\n            // recursively resolve the ref'd properties file and the ref'd key\n            Properties refdProps = determineDbProperties(refdType);\n            props.put(refdKey, refdProps.getProperty(refdKey));\n        }\n        // bring in base properties files pointed to by the extends directive\n        String baseDbType = (String) props.remove(\"extends\");\n        if (baseDbType != null) {\n            baseDbType = baseDbType.trim();\n            Properties baseProps = determineDbProperties(baseDbType);\n            // overlay our properties on top of the base's\n            baseProps.putAll(props);\n            props = baseProps;\n        }\n        // done with this level of recursion...restore original\n        dbPropertiesLoadedFrom = saveLoadedFrom;\n        // this won't be correct until the final recursion exits\n        dbProperties = props;\n        return props;\n    }\n\n    protected String getDbPropertiesLoadedFrom() throws IOException {\n        if (dbPropertiesLoadedFrom == null)\n            determineDbProperties(getDbType());\n        return dbPropertiesLoadedFrom;\n    }\n\n    public List<String> getRemainingParameters() {\n        try {\n            populate();\n        } catch (IllegalArgumentException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (IllegalAccessException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (InvocationTargetException exc) {\n            if (exc.getCause() instanceof InvalidConfigurationException)\n                throw (InvalidConfigurationException) exc.getCause();\n            throw new InvalidConfigurationException(exc.getCause());\n        } catch (IntrospectionException exc) {\n            throw new InvalidConfigurationException(exc);\n        }\n        return options;\n    }\n\n    /**\n     * Options that are specific to a type of database.  E.g. things like <code>host</code>,\n     * <code>port</code> or <code>db</code>, but <b>don't</b> have a setter in this class.\n     *\n     * @param dbSpecificOptions\n     */\n    public void setDbSpecificOptions(Map<String, String> dbSpecificOptions) {\n        this.dbSpecificOptions = dbSpecificOptions;\n        originalDbSpecificOptions = new HashMap<String, String>(dbSpecificOptions);\n    }\n\n    public Map<String, String> getDbSpecificOptions() {\n        if (dbSpecificOptions == null)\n            dbSpecificOptions = new HashMap<String, String>();\n        return dbSpecificOptions;\n    }\n\n    /**\n     * Returns a {@link Properties} populated with the contents of <code>bundle</code>\n     *\n     * @param bundle ResourceBundle\n     * @return Properties\n     */\n    public static Properties asProperties(ResourceBundle bundle) {\n        Properties props = new Properties();\n        Enumeration<String> iter = bundle.getKeys();\n        while (iter.hasMoreElements()) {\n            String key = iter.nextElement();\n            props.put(key, bundle.getObject(key));\n        }\n        return props;\n    }\n\n    /**\n     * 'Pull' the specified parameter from the collection of options. Returns\n     * null if the parameter isn't in the list and removes it if it is.\n     *\n     * @param paramId\n     * @return\n     */\n    private String pullParam(String paramId) {\n        return pullParam(paramId, false, false);\n    }\n\n    private String pullRequiredParam(String paramId) {\n        return pullParam(paramId, true, false);\n    }\n\n    /**\n     * @param paramId\n     * @param required\n     * @param dbTypeSpecific\n     * @return\n     * @throws MissingRequiredParameterException\n     */\n    private String pullParam(String paramId, boolean required, boolean dbTypeSpecific) throws MissingRequiredParameterException {\n        int paramIndex = options.indexOf(paramId);\n        if (paramIndex < 0) {\n            if (required)\n                throw new MissingRequiredParameterException(paramId, dbTypeSpecific);\n            return null;\n        }\n        options.remove(paramIndex);\n        String param = options.get(paramIndex).toString();\n        options.remove(paramIndex);\n        return param;\n    }\n\n    /**\n     * Thrown to indicate that a required parameter is missing\n     */\n    public static class MissingRequiredParameterException extends RuntimeException {\n\n        private static final long serialVersionUID = 1L;\n\n        private final boolean dbTypeSpecific;\n\n        public MissingRequiredParameterException(String paramId, boolean dbTypeSpecific) {\n            this(paramId, null, dbTypeSpecific);\n        }\n\n        public MissingRequiredParameterException(String paramId, String description, boolean dbTypeSpecific) {\n            super(\"Required parameter '\" + paramId + \"' \" + (description == null ? \"\" : \"(\" + description + \") \") + \"was not specified.\" + (dbTypeSpecific ? \"  It is required for this database type.\" : \"\"));\n            this.dbTypeSpecific = dbTypeSpecific;\n        }\n\n        public boolean isDbTypeSpecific() {\n            return dbTypeSpecific;\n        }\n    }\n\n    /**\n     * Allow an equal sign in args...like \"-o=foo.bar\". Useful for things like\n     * Ant and Maven.\n     *\n     * @param args\n     *            List\n     * @return List\n     */\n    protected List<String> fixupArgs(List<String> args) {\n        List<String> expandedArgs = new ArrayList<String>();\n        for (String arg : args) {\n            int indexOfEquals = arg.indexOf('=');\n            if (indexOfEquals != -1 && indexOfEquals - 1 != arg.indexOf(ESCAPED_EQUALS)) {\n                expandedArgs.add(arg.substring(0, indexOfEquals));\n                expandedArgs.add(arg.substring(indexOfEquals + 1));\n            } else {\n                expandedArgs.add(arg);\n            }\n        }\n        // some OSes/JVMs do filename expansion with runtime.exec() and some don't,\n        // so MultipleSchemaAnalyzer has to surround params with double quotes...\n        // strip them here for the OSes/JVMs that don't do anything with the params\n        List<String> unquotedArgs = new ArrayList<String>();\n        for (String arg : expandedArgs) {\n            if (// \".*\" becomes .*\n            arg.startsWith(\"\\\"\") && arg.endsWith(\"\\\"\"))\n                arg = arg.substring(1, arg.length() - 1);\n            unquotedArgs.add(arg);\n        }\n        return unquotedArgs;\n    }\n\n    /**\n     * Call all the getters to populate all the lazy initialized stuff.\n     *\n     * @throws InvocationTargetException\n     * @throws IllegalAccessException\n     * @throws IllegalArgumentException\n     * @throws IntrospectionException\n     */\n    private void populate() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IntrospectionException {\n        if (!populating) {\n            // prevent recursion\n            populating = true;\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                Method readMethod = props[i].getReadMethod();\n                if (readMethod != null)\n                    readMethod.invoke(this, (Object[]) null);\n            }\n            populating = false;\n        }\n    }\n\n    public static Set<String> getBuiltInDatabaseTypes(String loadedFromJar) {\n        Set<String> databaseTypes = new TreeSet<String>();\n        JarInputStream jar = null;\n        try {\n            jar = new JarInputStream(new FileInputStream(loadedFromJar));\n            JarEntry entry;\n            while ((entry = jar.getNextJarEntry()) != null) {\n                String entryName = entry.getName();\n                int dotPropsIndex = entryName.indexOf(\".properties\");\n                if (dotPropsIndex != -1)\n                    databaseTypes.add(entryName.substring(0, dotPropsIndex));\n            }\n        } catch (IOException exc) {\n        } finally {\n            if (jar != null) {\n                try {\n                    jar.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n        return databaseTypes;\n    }\n\n    protected void dumpUsage(String errorMessage, boolean detailedDb) {\n        if (errorMessage != null) {\n            System.out.flush();\n            System.err.println(\"*** \" + errorMessage + \" ***\");\n        } else {\n            System.out.println(\"SchemaSpy generates an HTML representation of a database schema's relationships.\");\n        }\n        System.err.flush();\n        System.out.println();\n        if (!detailedDb) {\n            System.out.println(\"Usage:\");\n            System.out.println(\" java -jar \" + getLoadedFromJar() + \" [options]\");\n            System.out.println(\"   -t databaseType       type of database - defaults to ora\");\n            System.out.println(\"                           use -dbhelp for a list of built-in types\");\n            System.out.println(\"   -u user               connect to the database with this user id\");\n            System.out.println(\"   -s schema             defaults to the specified user\");\n            System.out.println(\"   -p password           defaults to no password\");\n            System.out.println(\"   -o outputDirectory    directory to place the generated output in\");\n            System.out.println(\"   -dp pathToDrivers     optional - looks for JDBC drivers here before looking\");\n            System.out.println(\"                           in driverPath in [databaseType].properties.\");\n            System.out.println(\"Go to http://schemaspy.sourceforge.net for a complete list/description\");\n            System.out.println(\" of additional parameters.\");\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"Built-in database types and their required connection parameters:\");\n            for (String type : getBuiltInDatabaseTypes(getLoadedFromJar())) {\n                new DbSpecificConfig(type).dumpUsage();\n            }\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"You can use your own database types by specifying the filespec of a .properties file with -t.\");\n            System.out.println(\"Grab one out of \" + getLoadedFromJar() + \" and modify it to suit your needs.\");\n            System.out.println();\n        }\n        System.out.println(\"Sample usage using the default database type (implied -t ora):\");\n        System.out.println(\" java -jar schemaSpy.jar -db mydb -s myschema -u devuser -p password -o output\");\n        System.out.println();\n        System.out.flush();\n    }\n\n    /**\n     * Get the value of the specified parameter.\n     * Used for properties that are common to most db's, but aren't required.\n     *\n     * @param paramName\n     * @return\n     */\n    public String getParam(String paramName) {\n        try {\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                PropertyDescriptor prop = props[i];\n                if (prop.getName().equalsIgnoreCase(paramName)) {\n                    Object result = prop.getReadMethod().invoke(this, (Object[]) null);\n                    return result == null ? null : result.toString();\n                }\n            }\n        } catch (Exception failed) {\n            failed.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * Return all of the configuration options as a List of Strings, with\n     * each parameter and its value as a separate element.\n     *\n     * @return\n     * @throws IOException\n     */\n    public List<String> asList() throws IOException {\n        List<String> params = new ArrayList<String>();\n        if (originalDbSpecificOptions != null) {\n            for (String key : originalDbSpecificOptions.keySet()) {\n                String value = originalDbSpecificOptions.get(key);\n                if (!key.startsWith(\"-\"))\n                    key = \"-\" + key;\n                params.add(key);\n                params.add(value);\n            }\n        }\n        if (isEncodeCommentsEnabled())\n            params.add(\"-ahic\");\n        if (isEvaluateAllEnabled())\n            params.add(\"-all\");\n        if (!isHtmlGenerationEnabled())\n            params.add(\"-nohtml\");\n        if (!isImpliedConstraintsEnabled())\n            params.add(\"-noimplied\");\n        if (!isLogoEnabled())\n            params.add(\"-nologo\");\n        if (isMeterEnabled())\n            params.add(\"-meter\");\n        if (!isNumRowsEnabled())\n            params.add(\"-norows\");\n        if (!isViewsEnabled())\n            params.add(\"-noviews\");\n        if (isRankDirBugEnabled())\n            params.add(\"-rankdirbug\");\n        if (isRailsEnabled())\n            params.add(\"-rails\");\n        if (isSingleSignOn())\n            params.add(\"-sso\");\n        if (isSchemaDisabled())\n            params.add(\"-noschema\");\n        String value = getDriverPath();\n        if (value != null) {\n            params.add(\"-dp\");\n            params.add(value);\n        }\n        params.add(\"-css\");\n        params.add(getCss());\n        params.add(\"-charset\");\n        params.add(getCharset());\n        params.add(\"-font\");\n        params.add(getFont());\n        params.add(\"-fontsize\");\n        params.add(String.valueOf(getFontSize()));\n        params.add(\"-t\");\n        params.add(getDbType());\n        // query to set renderer correctly\n        isHighQuality();\n        // query to set renderer correctly\n        isLowQuality();\n        // instead of -hq and/or -lq\n        params.add(\"-renderer\");\n        params.add(getRenderer());\n        value = getDescription();\n        if (value != null) {\n            params.add(\"-desc\");\n            params.add(value);\n        }\n        value = getPassword();\n        if (value != null && !isPromptForPasswordEnabled()) {\n            // note that we don't pass -pfp since child processes\n            // won't have a console\n            params.add(\"-p\");\n            params.add(value);\n        }\n        value = getCatalog();\n        if (value != null) {\n            params.add(\"-cat\");\n            params.add(value);\n        }\n        value = getSchema();\n        if (value != null) {\n            params.add(\"-s\");\n            params.add(value);\n        }\n        value = getUser();\n        if (value != null) {\n            params.add(\"-u\");\n            params.add(value);\n        }\n        value = getConnectionPropertiesFile();\n        if (value != null) {\n            params.add(\"-connprops\");\n            params.add(value);\n        } else {\n            Properties props = getConnectionProperties();\n            if (!props.isEmpty()) {\n                params.add(\"-connprops\");\n                StringBuilder buf = new StringBuilder();\n                for (Entry<Object, Object> entry : props.entrySet()) {\n                    buf.append(entry.getKey());\n                    buf.append(ESCAPED_EQUALS);\n                    buf.append(entry.getValue());\n                    buf.append(';');\n                }\n                params.add(buf.toString());\n            }\n        }\n        value = getDb();\n        if (value != null) {\n            params.add(\"-db\");\n            params.add(value);\n        }\n        value = getHost();\n        if (value != null) {\n            params.add(\"-host\");\n            params.add(value);\n        }\n        if (getPort() != null) {\n            params.add(\"-port\");\n            params.add(getPort().toString());\n        }\n        value = getServer();\n        if (value != null) {\n            params.add(\"-server\");\n            params.add(value);\n        }\n        value = getMeta();\n        if (value != null) {\n            params.add(\"-meta\");\n            params.add(value);\n        }\n        if (getGraphvizDir() != null) {\n            params.add(\"-gv\");\n            params.add(getGraphvizDir().toString());\n        }\n        params.add(\"-loglevel\");\n        params.add(getLogLevel().toString().toLowerCase());\n        params.add(\"-sqlFormatter\");\n        params.add(getSqlFormatter().getClass().getName());\n        params.add(\"-i\");\n        params.add(getTableInclusions().toString());\n        params.add(\"-I\");\n        params.add(getTableExclusions().toString());\n        params.add(\"-X\");\n        params.add(getColumnExclusions().toString());\n        params.add(\"-x\");\n        params.add(getIndirectColumnExclusions().toString());\n        params.add(\"-dbthreads\");\n        params.add(String.valueOf(getMaxDbThreads()));\n        params.add(\"-maxdet\");\n        params.add(String.valueOf(getMaxDetailedTables()));\n        params.add(\"-o\");\n        params.add(getOutputDir().toString());\n        return params;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/ConfigTest15.java",
		"test_prompt": "// ConfigTest15.java\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Config}.\n* It contains ten unit test cases for the {@link Config#isHighQuality()} method.\n*/\nclass ConfigTest15 {"
	},
	{
		"original_code": "// Config.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\n\n/**\n * Configuration of a SchemaSpy run\n *\n * @author John Currier\n */\npublic class Config {\n\n    private static Config instance;\n\n    private final List<String> options;\n\n    private Map<String, String> dbSpecificOptions;\n\n    private Map<String, String> originalDbSpecificOptions;\n\n    private boolean helpRequired;\n\n    private boolean dbHelpRequired;\n\n    private File outputDir;\n\n    private File graphvizDir;\n\n    private String dbType;\n\n    private String catalog;\n\n    private String schema;\n\n    private List<String> schemas;\n\n    private String user;\n\n    private Boolean singleSignOn;\n\n    private Boolean noSchema;\n\n    private String password;\n\n    private Boolean promptForPassword;\n\n    private String db;\n\n    private String host;\n\n    private Integer port;\n\n    private String server;\n\n    private String meta;\n\n    private Pattern tableInclusions;\n\n    private Pattern tableExclusions;\n\n    private Pattern columnExclusions;\n\n    private Pattern indirectColumnExclusions;\n\n    private String userConnectionPropertiesFile;\n\n    private Properties userConnectionProperties;\n\n    private Integer maxDbThreads;\n\n    private Integer maxDetailedTables;\n\n    private String driverPath;\n\n    private String css;\n\n    private String charset;\n\n    private String font;\n\n    private Integer fontSize;\n\n    private String description;\n\n    private Properties dbProperties;\n\n    private String dbPropertiesLoadedFrom;\n\n    private Level logLevel;\n\n    private SqlFormatter sqlFormatter;\n\n    private String sqlFormatterClass;\n\n    private Boolean generateHtml;\n\n    private Boolean includeImpliedConstraints;\n\n    private Boolean logoEnabled;\n\n    private Boolean rankDirBugEnabled;\n\n    private Boolean encodeCommentsEnabled;\n\n    private Boolean numRowsEnabled;\n\n    private Boolean viewsEnabled;\n\n    private Boolean meterEnabled;\n\n    private Boolean railsEnabled;\n\n    private Boolean evaluteAll;\n\n    private Boolean highQuality;\n\n    private Boolean lowQuality;\n\n    // used in conjunction with evaluateAll\n    private String schemaSpec;\n\n    private boolean hasOrphans = false;\n\n    private boolean hasRoutines = false;\n\n    private boolean populating = false;\n\n    private List<String> columnDetails;\n\n    public static final String DOT_CHARSET = \"UTF-8\";\n\n    private static final String ESCAPED_EQUALS = \"\\\\=\";\n\n    // match everything\n    private static final String DEFAULT_TABLE_INCLUSION = \".*\";\n\n    // match nothing\n    private static final String DEFAULT_TABLE_EXCLUSION = \"\";\n\n    // match nothing\n    private static final String DEFAULT_COLUMN_EXCLUSION = \"[^.]\";\n\n    /**\n     * Default constructor. Intended for when you want to inject properties\n     * independently (i.e. not from a command line interface).\n     */\n    public Config() {\n        if (instance == null)\n            setInstance(this);\n        options = new ArrayList<String>();\n    }\n\n    /**\n     * Construct a configuration from an array of options (e.g. from a command\n     * line interface).\n     *\n     * @param options\n     */\n    public Config(String[] argv) {\n        setInstance(this);\n        options = fixupArgs(Arrays.asList(argv));\n        helpRequired = options.remove(\"-?\") || options.remove(\"/?\") || options.remove(\"?\") || options.remove(\"-h\") || options.remove(\"-help\") || options.remove(\"--help\");\n        dbHelpRequired = options.remove(\"-dbHelp\") || options.remove(\"-dbhelp\");\n    }\n\n    public static Config getInstance() {\n        if (instance == null)\n            instance = new Config();\n        return instance;\n    }\n\n    /**\n     * Sets the global instance.\n     *\n     * Useful for things like selecting a specific configuration in a UI.\n     *\n     * @param config\n     */\n    public static void setInstance(Config config) {\n        instance = config;\n    }\n\n    public void setHtmlGenerationEnabled(boolean generateHtml) {\n        this.generateHtml = generateHtml;\n    }\n\n    public boolean isHtmlGenerationEnabled() {\n        if (generateHtml == null)\n            generateHtml = !options.remove(\"-nohtml\");\n        return generateHtml;\n    }\n\n    public void setImpliedConstraintsEnabled(boolean includeImpliedConstraints) {\n        this.includeImpliedConstraints = includeImpliedConstraints;\n    }\n\n    public boolean isImpliedConstraintsEnabled() {\n        if (includeImpliedConstraints == null)\n            includeImpliedConstraints = !options.remove(\"-noimplied\");\n        return includeImpliedConstraints;\n    }\n\n    public void setOutputDir(String outputDirName) {\n        if (outputDirName.endsWith(\"\\\"\"))\n            outputDirName = outputDirName.substring(0, outputDirName.length() - 1);\n        setOutputDir(new File(outputDirName));\n    }\n\n    public void setOutputDir(File outputDir) {\n        this.outputDir = outputDir;\n    }\n\n    public File getOutputDir() {\n        if (outputDir == null) {\n            setOutputDir(pullRequiredParam(\"-o\"));\n        }\n        return outputDir;\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(String graphvizDir) {\n        if (graphvizDir.endsWith(\"\\\"\"))\n            graphvizDir = graphvizDir.substring(0, graphvizDir.length() - 1);\n        setGraphvizDir(new File(graphvizDir));\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(File graphvizDir) {\n        this.graphvizDir = graphvizDir;\n    }\n\n    /**\n     * Return the path to Graphviz (used to find the dot executable to run to\n     * generate ER diagrams).<p/>\n     *\n     * Returns {@link #getDefaultGraphvizPath()} if a specific Graphviz path\n     * was not specified.\n     *\n     * @return\n     */\n    public File getGraphvizDir() {\n        if (graphvizDir == null) {\n            String gv = pullParam(\"-gv\");\n            if (gv != null) {\n                setGraphvizDir(gv);\n            } else {\n                // expect to find Graphviz's bin directory on the PATH\n            }\n        }\n        return graphvizDir;\n    }\n\n    /**\n     * Meta files are XML-based files that provide additional metadata\n     * about the schema being evaluated.<p>\n     * <code>meta</code> is either the name of an individual XML file or\n     * the directory that contains meta files.<p>\n     * If a directory is specified then it is expected to contain files\n     * matching the pattern <code>[schema].meta.xml</code>.\n     * For databases that don't have schema substitute database for schema.\n     * @param meta\n     */\n    public void setMeta(String meta) {\n        this.meta = meta;\n    }\n\n    public String getMeta() {\n        if (meta == null)\n            meta = pullParam(\"-meta\");\n        return meta;\n    }\n\n    public void setDbType(String dbType) {\n        this.dbType = dbType;\n    }\n\n    public String getDbType() {\n        if (dbType == null) {\n            dbType = pullParam(\"-t\");\n            if (dbType == null)\n                dbType = \"ora\";\n        }\n        return dbType;\n    }\n\n    public void setDb(String db) {\n        this.db = db;\n    }\n\n    public String getDb() {\n        if (db == null)\n            db = pullParam(\"-db\");\n        return db;\n    }\n\n    public void setCatalog(String catalog) {\n        this.catalog = catalog;\n    }\n\n    public String getCatalog() {\n        if (catalog == null)\n            catalog = pullParam(\"-cat\");\n        return catalog;\n    }\n\n    public void setSchema(String schema) {\n        this.schema = schema;\n    }\n\n    public String getSchema() {\n        if (schema == null)\n            schema = pullParam(\"-s\");\n        return schema;\n    }\n\n    /**\n     * Some databases types (e.g. older versions of Informix) don't really\n     * have the concept of a schema but still return true from\n     * {@link DatabaseMetaData#supportsSchemasInTableDefinitions()}.\n     * This option lets you ignore that and treat all the tables\n     * as if they were in one flat namespace.\n     */\n    public boolean isSchemaDisabled() {\n        if (noSchema == null)\n            noSchema = options.remove(\"-noschema\");\n        return noSchema;\n    }\n\n    public void setHost(String host) {\n        this.host = host;\n    }\n\n    public String getHost() {\n        if (host == null)\n            host = pullParam(\"-host\");\n        return host;\n    }\n\n    public void setPort(Integer port) {\n        this.port = port;\n    }\n\n    public Integer getPort() {\n        if (port == null)\n            try {\n                port = Integer.valueOf(pullParam(\"-port\"));\n            } catch (Exception notSpecified) {\n            }\n        return port;\n    }\n\n    public void setServer(String server) {\n        this.server = server;\n    }\n\n    public String getServer() {\n        if (server == null) {\n            server = pullParam(\"-server\");\n        }\n        return server;\n    }\n\n    public void setUser(String user) {\n        this.user = user;\n    }\n\n    /**\n     * User used to connect to the database.\n     * Required unless single sign-on is enabled\n     * (see {@link #setSingleSignOn(boolean)}).\n     * @return\n     */\n    public String getUser() {\n        if (user == null) {\n            if (!isSingleSignOn())\n                user = pullRequiredParam(\"-u\");\n            else\n                user = pullParam(\"-u\");\n        }\n        return user;\n    }\n\n    /**\n     * By default a \"user\" (as specified with -u) is required.\n     * This option allows disabling of that requirement for\n     * single sign-on environments.\n     *\n     * @param enabled defaults to <code>false</code>\n     */\n    public void setSingleSignOn(boolean enabled) {\n        singleSignOn = enabled;\n    }\n\n    /**\n     * @see #setSingleSignOn(boolean)\n     */\n    public boolean isSingleSignOn() {\n        if (singleSignOn == null)\n            singleSignOn = options.remove(\"-sso\");\n        return singleSignOn;\n    }\n\n    /**\n     * Set the password used to connect to the database.\n     * @param password\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * @see #setPassword(String)\n     * @return\n     */\n    public String getPassword() {\n        if (password == null)\n            password = pullParam(\"-p\");\n        if (password == null && isPromptForPasswordEnabled())\n            password = new String(PasswordReader.getInstance().readPassword(\"Password: \"));\n        if (password == null) {\n            // if -pfp is enabled when analyzing multiple schemas then\n            // we don't want to send the password on the command line,\n            // so see if it was passed in the environment (not ideal, but safer)\n            password = System.getenv(\"schemaspy.pw\");\n        }\n        return password;\n    }\n\n    /**\n     * Set to <code>true</code> to prompt for the password\n     * @param promptForPassword\n     */\n    public void setPromptForPasswordEnabled(boolean promptForPassword) {\n        this.promptForPassword = promptForPassword;\n    }\n\n    /**\n     * @see #setPromptForPasswordEnabled(boolean)\n     * @return\n     */\n    public boolean isPromptForPasswordEnabled() {\n        if (promptForPassword == null) {\n            promptForPassword = options.remove(\"-pfp\");\n        }\n        return promptForPassword;\n    }\n\n    public void setMaxDetailedTabled(int maxDetailedTables) {\n        this.maxDetailedTables = new Integer(maxDetailedTables);\n    }\n\n    public int getMaxDetailedTables() {\n        if (maxDetailedTables == null) {\n            // default\n            int max = 300;\n            try {\n                max = Integer.parseInt(pullParam(\"-maxdet\"));\n            } catch (Exception notSpecified) {\n            }\n            maxDetailedTables = new Integer(max);\n        }\n        return maxDetailedTables.intValue();\n    }\n\n    public String getConnectionPropertiesFile() {\n        return userConnectionPropertiesFile;\n    }\n\n    /**\n     * Properties from this file (in key=value pair format) are passed to the\n     * database connection.<br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.\n     * @param propertiesFilename\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public void setConnectionPropertiesFile(String propertiesFilename) throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null)\n            userConnectionProperties = new Properties();\n        userConnectionProperties.load(new FileInputStream(propertiesFilename));\n        userConnectionPropertiesFile = propertiesFilename;\n    }\n\n    /**\n     * Returns a {@link Properties} populated either from the properties file specified\n     * by {@link #setConnectionPropertiesFile(String)}, the properties specified by\n     * {@link #setConnectionProperties(String)} or not populated.\n     * @return\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public Properties getConnectionProperties() throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null) {\n            String props = pullParam(\"-connprops\");\n            if (props != null) {\n                if (props.indexOf(ESCAPED_EQUALS) != -1) {\n                    setConnectionProperties(props);\n                } else {\n                    setConnectionPropertiesFile(props);\n                }\n            } else {\n                userConnectionProperties = new Properties();\n            }\n        }\n        return userConnectionProperties;\n    }\n\n    /**\n     * Specifies connection properties to use in the format:\n     * <code>key1\\=value1;key2\\=value2</code><br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.<p>\n     * This is an alternative form of passing connection properties than by file\n     * (see {@link #setConnectionPropertiesFile(String)})\n     *\n     * @param properties\n     */\n    public void setConnectionProperties(String properties) {\n        userConnectionProperties = new Properties();\n        StringTokenizer tokenizer = new StringTokenizer(properties, \";\");\n        while (tokenizer.hasMoreElements()) {\n            String pair = tokenizer.nextToken();\n            int index = pair.indexOf(ESCAPED_EQUALS);\n            if (index != -1) {\n                String key = pair.substring(0, index);\n                String value = pair.substring(index + ESCAPED_EQUALS.length());\n                userConnectionProperties.put(key, value);\n            }\n        }\n    }\n\n    public void setDriverPath(String driverPath) {\n        this.driverPath = driverPath;\n    }\n\n    public String getDriverPath() {\n        if (driverPath == null)\n            driverPath = pullParam(\"-dp\");\n        // was previously -cp:\n        if (driverPath == null)\n            driverPath = pullParam(\"-cp\");\n        return driverPath;\n    }\n\n    /**\n     * The filename of the cascading style sheet to use.\n     * Note that this file is parsed and used to determine characteristics\n     * of the generated diagrams, so it must contain specific settings that\n     * are documented within schemaSpy.css.<p>\n     *\n     * Defaults to <code>\"schemaSpy.css\"</code>.\n     *\n     * @param css\n     */\n    public void setCss(String css) {\n        this.css = css;\n    }\n\n    public String getCss() {\n        if (css == null) {\n            css = pullParam(\"-css\");\n            if (css == null)\n                css = \"schemaSpy.css\";\n        }\n        return css;\n    }\n\n    /**\n     * The font to use within diagrams.  Modify the .css to specify HTML fonts.\n     *\n     * @param font\n     */\n    public void setFont(String font) {\n        this.font = font;\n    }\n\n    /**\n     * @see #setFont(String)\n     */\n    public String getFont() {\n        if (font == null) {\n            font = pullParam(\"-font\");\n            if (font == null)\n                font = \"Helvetica\";\n        }\n        return font;\n    }\n\n    /**\n     * The font size to use within diagrams.  This is the size of the font used for\n     * 'large' (e.g. not 'compact') diagrams.<p>\n     *\n     * Modify the .css to specify HTML font sizes.<p>\n     *\n     * Defaults to 11.\n     *\n     * @param fontSize\n     */\n    public void setFontSize(int fontSize) {\n        this.fontSize = new Integer(fontSize);\n    }\n\n    /**\n     * @see #setFontSize(int)\n     * @return\n     */\n    public int getFontSize() {\n        if (fontSize == null) {\n            // default\n            int size = 11;\n            try {\n                size = Integer.parseInt(pullParam(\"-fontsize\"));\n            } catch (Exception notSpecified) {\n            }\n            fontSize = new Integer(size);\n        }\n        return fontSize.intValue();\n    }\n\n    /**\n     * The character set to use within HTML pages (defaults to <code>\"ISO-8859-1\"</code>).\n     *\n     * @param charset\n     */\n    public void setCharset(String charset) {\n        this.charset = charset;\n    }\n\n    /**\n     * @see #setCharset(String)\n     */\n    public String getCharset() {\n        if (charset == null) {\n            charset = pullParam(\"-charset\");\n            if (charset == null)\n                charset = \"ISO-8859-1\";\n        }\n        return charset;\n    }\n\n    /**\n     * Description of schema that gets display on main pages.\n     *\n     * @param description\n     */\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    /**\n     * @see #setDescription(String)\n     */\n    public String getDescription() {\n        if (description == null)\n            description = pullParam(\"-desc\");\n        return description;\n    }\n\n    /**\n     * Maximum number of threads to use when querying database metadata information.\n     *\n     * @param maxDbThreads\n     */\n    public void setMaxDbThreads(int maxDbThreads) {\n        this.maxDbThreads = new Integer(maxDbThreads);\n    }\n\n    /**\n     * @see #setMaxDbThreads(int)\n     * @throws InvalidConfigurationException if unable to load properties\n     */\n    public int getMaxDbThreads() throws InvalidConfigurationException {\n        if (maxDbThreads == null) {\n            Properties properties;\n            try {\n                properties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(\"Failed to load properties for \" + getDbType() + \": \" + exc).setParamName(\"-type\");\n            }\n            // not scientifically derived\n            final int defaultMax = 15;\n            int max = defaultMax;\n            String threads = properties.getProperty(\"dbThreads\");\n            if (threads == null)\n                threads = properties.getProperty(\"dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            threads = pullParam(\"-dbThreads\");\n            if (threads == null)\n                threads = pullParam(\"-dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            if (max < 0)\n                max = defaultMax;\n            else if (max == 0)\n                max = 1;\n            maxDbThreads = new Integer(max);\n        }\n        return maxDbThreads.intValue();\n    }\n\n    public boolean isLogoEnabled() {\n        if (logoEnabled == null)\n            logoEnabled = !options.remove(\"-nologo\");\n        return logoEnabled;\n    }\n\n    /**\n     * Don't use this unless absolutely necessary as it screws up the layout\n     *\n     * @param enabled\n     */\n    public void setRankDirBugEnabled(boolean enabled) {\n        rankDirBugEnabled = enabled;\n    }\n\n    /**\n     * @see #setRankDirBugEnabled(boolean)\n     */\n    public boolean isRankDirBugEnabled() {\n        if (rankDirBugEnabled == null)\n            rankDirBugEnabled = options.remove(\"-rankdirbug\");\n        return rankDirBugEnabled;\n    }\n\n    /**\n     * Look for Ruby on Rails-based naming conventions in\n     * relationships between logical foreign keys and primary keys.<p>\n     *\n     * Basically all tables have a primary key named <code>ID</code>.\n     * All tables are named plural names.\n     * The columns that logically reference that <code>ID</code> are the singular\n     * form of the table name suffixed with <code>_ID</code>.<p>\n     *\n     * @param enabled\n     */\n    public void setRailsEnabled(boolean enabled) {\n        railsEnabled = enabled;\n    }\n\n    /**\n     * @see #setRailsEnabled(boolean)\n     *\n     * @return\n     */\n    public boolean isRailsEnabled() {\n        if (railsEnabled == null)\n            railsEnabled = options.remove(\"-rails\");\n        return railsEnabled;\n    }\n\n    /**\n     * Allow Html In Comments - encode them unless otherwise specified\n     */\n    public void setEncodeCommentsEnabled(boolean enabled) {\n        encodeCommentsEnabled = enabled;\n    }\n\n    /**\n     * @see #setEncodeCommentsEnabled(boolean)\n     */\n    public boolean isEncodeCommentsEnabled() {\n        if (encodeCommentsEnabled == null)\n            encodeCommentsEnabled = !options.remove(\"-ahic\");\n        return encodeCommentsEnabled;\n    }\n\n    /**\n     * If enabled we'll attempt to query/render the number of rows that\n     * each table contains.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setNumRowsEnabled(boolean enabled) {\n        numRowsEnabled = enabled;\n    }\n\n    /**\n     * @see #setNumRowsEnabled(boolean)\n     * @return\n     */\n    public boolean isNumRowsEnabled() {\n        if (numRowsEnabled == null)\n            numRowsEnabled = !options.remove(\"-norows\");\n        return numRowsEnabled;\n    }\n\n    /**\n     * If enabled we'll include views in the analysis.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setViewsEnabled(boolean enabled) {\n        viewsEnabled = enabled;\n    }\n\n    /**\n     * @see #setViewsEnabled(boolean)\n     * @return\n     */\n    public boolean isViewsEnabled() {\n        if (viewsEnabled == null)\n            viewsEnabled = !options.remove(\"-noviews\");\n        return viewsEnabled;\n    }\n\n    /**\n     * Returns <code>true</code> if metering should be embedded in\n     * the generated pages.<p/>\n     * Defaults to <code>false</code> (disabled).\n     * @return\n     */\n    public boolean isMeterEnabled() {\n        if (meterEnabled == null)\n            meterEnabled = options.remove(\"-meter\");\n        return meterEnabled;\n    }\n\n    /**\n     * Set the columns to exclude from all relationship diagrams.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setColumnExclusions(String columnExclusions) {\n        this.columnExclusions = Pattern.compile(columnExclusions);\n    }\n\n    /**\n     * See {@link #setColumnExclusions(String)}\n     * @return\n     */\n    public Pattern getColumnExclusions() {\n        if (columnExclusions == null) {\n            String strExclusions = pullParam(\"-X\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.columnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            columnExclusions = Pattern.compile(strExclusions);\n        }\n        return columnExclusions;\n    }\n\n    /**\n     * Set the columns to exclude from relationship diagrams where the specified\n     * columns aren't directly referenced by the focal table.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setIndirectColumnExclusions(String fullColumnExclusions) {\n        indirectColumnExclusions = Pattern.compile(fullColumnExclusions);\n    }\n\n    /**\n     * @see #setIndirectColumnExclusions(String)\n     *\n     * @return\n     */\n    public Pattern getIndirectColumnExclusions() {\n        if (indirectColumnExclusions == null) {\n            String strExclusions = pullParam(\"-x\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.indirectColumnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            indirectColumnExclusions = Pattern.compile(strExclusions);\n        }\n        return indirectColumnExclusions;\n    }\n\n    /**\n     * Set the tables to include as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableInclusions(String tableInclusions) {\n        this.tableInclusions = Pattern.compile(tableInclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to include in the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableInclusions() {\n        if (tableInclusions == null) {\n            String strInclusions = pullParam(\"-i\");\n            if (strInclusions == null)\n                strInclusions = System.getenv(\"schemaspy.tableInclusions\");\n            if (strInclusions == null)\n                strInclusions = DEFAULT_TABLE_INCLUSION;\n            try {\n                tableInclusions = Pattern.compile(strInclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-i\");\n            }\n        }\n        return tableInclusions;\n    }\n\n    /**\n     * Set the tables to exclude as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableExclusions(String tableExclusions) {\n        this.tableExclusions = Pattern.compile(tableExclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to exclude from the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableExclusions() {\n        if (tableExclusions == null) {\n            String strExclusions = pullParam(\"-I\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.tableExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_TABLE_EXCLUSION;\n            try {\n                tableExclusions = Pattern.compile(strExclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-I\");\n            }\n        }\n        return tableExclusions;\n    }\n\n    /**\n     * @return\n     */\n    public List<String> getSchemas() {\n        if (schemas == null) {\n            String tmp = pullParam(\"-schemas\");\n            if (tmp == null)\n                tmp = pullParam(\"-schemata\");\n            if (tmp != null) {\n                schemas = new ArrayList<String>();\n                for (String name : tmp.split(\"[\\\\s,'\\\"]\")) {\n                    if (name.length() > 0)\n                        schemas.add(name);\n                }\n                if (schemas.isEmpty())\n                    schemas = null;\n            }\n        }\n        return schemas;\n    }\n\n    /**\n     * Set the name of the {@link SqlFormatter SQL formatter} class to use to\n     * format SQL into HTML.<p/>\n     * The implementation of the class must be made available to the class\n     * loader, typically by specifying the path to its jar with <em>-dp</em>\n     * ({@link #setDriverPath(String)}).\n     */\n    public void setSqlFormatter(String formatterClassName) {\n        sqlFormatterClass = formatterClassName;\n        sqlFormatter = null;\n    }\n\n    /**\n     * Set the {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.\n     */\n    public void setSqlFormatter(SqlFormatter sqlFormatter) {\n        this.sqlFormatter = sqlFormatter;\n        if (sqlFormatter != null)\n            sqlFormatterClass = sqlFormatter.getClass().getName();\n    }\n\n    /**\n     * Returns an implementation of {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.  The default implementation is {@link DefaultSqlFormatter}.\n     *\n     * @return\n     * @throws InvalidConfigurationException if unable to instantiate an instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SqlFormatter getSqlFormatter() throws InvalidConfigurationException {\n        if (sqlFormatter == null) {\n            if (sqlFormatterClass == null) {\n                sqlFormatterClass = pullParam(\"-sqlFormatter\");\n                if (sqlFormatterClass == null)\n                    sqlFormatterClass = DefaultSqlFormatter.class.getName();\n            }\n            try {\n                Class<SqlFormatter> clazz = (Class<SqlFormatter>) Class.forName(sqlFormatterClass);\n                sqlFormatter = clazz.newInstance();\n            } catch (Exception exc) {\n                throw new InvalidConfigurationException(\"Failed to initialize instance of SQL formatter: \", exc).setParamName(\"-sqlFormatter\");\n            }\n        }\n        return sqlFormatter;\n    }\n\n    /**\n     * Set the details to show on the columns page, where \"details\" are\n     * comma and/or space separated.\n     *\n     * Valid values:\n     * <ul>\n     * <li>id</li>\n     * <li>table</li>\n     * <li>column</li>\n     * <li>type</li>\n     * <li>size</li>\n     * <li>nulls</li>\n     * <li>auto</li>\n     * <li>default</li>\n     * <li>children</li>\n     * <li>parents</li>\n     * </ul>\n     *\n     * The default details are <code>\"table column type size nulls auto default\"</code>.\n     * Note that \"column\" is the initially displayed detail and must be included.\n     *\n     * @param columnDetails\n     */\n    public void setColumnDetails(String columnDetails) {\n        this.columnDetails = new ArrayList<String>();\n        if (columnDetails == null || columnDetails.length() == 0) {\n            // not specified, so use defaults\n            columnDetails = \"id table column type size nulls auto default\";\n        }\n        for (String detail : columnDetails.split(\"[\\\\s,'\\\"]\")) {\n            if (detail.length() > 0) {\n                this.columnDetails.add(detail.toLowerCase());\n            }\n        }\n        if (!this.columnDetails.contains(\"column\"))\n            throw new InvalidConfigurationException(\"'column' is a required column detail\");\n    }\n\n    public void setColumnDetails(List<String> columnDetails) {\n        String details = columnDetails == null ? \"[]\" : columnDetails.toString();\n        setColumnDetails(details.substring(1, details.length() - 1));\n    }\n\n    public List<String> getColumnDetails() {\n        if (columnDetails == null) {\n            setColumnDetails(pullParam(\"-columndetails\"));\n        }\n        return columnDetails;\n    }\n\n    public void setEvaluateAllEnabled(boolean enabled) {\n        evaluteAll = enabled;\n    }\n\n    public boolean isEvaluateAllEnabled() {\n        if (evaluteAll == null)\n            evaluteAll = options.remove(\"-all\");\n        return evaluteAll;\n    }\n\n    /**\n     * Returns true if we're evaluating a bunch of schemas in one go and\n     * at this point we're evaluating a specific schema.\n     *\n     * @return boolean\n     */\n    public boolean isOneOfMultipleSchemas() {\n        // set by MultipleSchemaAnalyzer\n        return Boolean.getBoolean(\"oneofmultipleschemas\");\n    }\n\n    /**\n     * When -all (evaluateAll) is specified then this is the regular\n     * expression that determines which schemas to evaluate.\n     *\n     * @param schemaSpec\n     */\n    public void setSchemaSpec(String schemaSpec) {\n        this.schemaSpec = schemaSpec;\n    }\n\n    public String getSchemaSpec() {\n        if (schemaSpec == null)\n            schemaSpec = pullParam(\"-schemaSpec\");\n        return schemaSpec;\n    }\n\n    /**\n     * Set the renderer to use for the -Tpng[:renderer[:formatter]] dot option as specified\n     * at <a href='http://www.graphviz.org/doc/info/command.html'>\n     * http://www.graphviz.org/doc/info/command.html</a>.<p>\n     * Note that the leading \":\" is required while :formatter is optional.<p>\n     * The default renderer is typically GD.<p>\n     * Note that using {@link #setHighQuality(boolean)} is the preferred approach\n     * over using this method.\n     */\n    public void setRenderer(String renderer) {\n        Dot.getInstance().setRenderer(renderer);\n    }\n\n    /**\n     * @see #setRenderer(String)\n     * @return\n     */\n    public String getRenderer() {\n        String renderer = pullParam(\"-renderer\");\n        if (renderer != null)\n            setRenderer(renderer);\n        return Dot.getInstance().getRenderer();\n    }\n\n    /**\n     * If <code>false</code> then generate output of \"lower quality\"\n     * than the default.\n     * Note that the default is intended to be \"higher quality\",\n     * but various installations of Graphviz may have have different abilities.\n     * That is, some might not have the \"lower quality\" libraries and others might\n     * not have the \"higher quality\" libraries.<p>\n     * Higher quality output takes longer to generate and results in significantly\n     * larger image files (which take longer to download / display), but it generally\n     * looks better.\n     */\n    public void setHighQuality(boolean highQuality) {\n        this.highQuality = highQuality;\n        lowQuality = !highQuality;\n        Dot.getInstance().setHighQuality(highQuality);\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isHighQuality() {\n        if (highQuality == null) {\n            highQuality = options.remove(\"-hq\");\n            if (highQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(highQuality);\n            }\n        }\n        highQuality = Dot.getInstance().isHighQuality();\n        return highQuality;\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isLowQuality() {\n        if (lowQuality == null) {\n            lowQuality = options.remove(\"-lq\");\n            if (lowQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(!lowQuality);\n            }\n        }\n        lowQuality = !Dot.getInstance().isHighQuality();\n        return lowQuality;\n    }\n\n    /**\n     * Set the level of logging to perform.<p/>\n     * The levels in descending order are:\n     * <ul>\n     *  <li><code>severe</code> (highest - least detail)\n     *  <li><code>warning</code> (default)\n     *  <li><code>info</code>\n     *  <li><code>config</code>\n     *  <li><code>fine</code>\n     *  <li><code>finer</code>\n     *  <li><code>finest</code>  (lowest - most detail)\n     * </ul>\n     *\n     * @param logLevel\n     */\n    public void setLogLevel(String logLevel) {\n        if (logLevel == null) {\n            this.logLevel = Level.WARNING;\n            return;\n        }\n        Map<String, Level> levels = new LinkedHashMap<String, Level>();\n        levels.put(\"severe\", Level.SEVERE);\n        levels.put(\"warning\", Level.WARNING);\n        levels.put(\"info\", Level.INFO);\n        levels.put(\"config\", Level.CONFIG);\n        levels.put(\"fine\", Level.FINE);\n        levels.put(\"finer\", Level.FINER);\n        levels.put(\"finest\", Level.FINEST);\n        this.logLevel = levels.get(logLevel.toLowerCase());\n        if (this.logLevel == null) {\n            throw new InvalidConfigurationException(\"Invalid logLevel: '\" + logLevel + \"'. Must be one of: \" + levels.keySet());\n        }\n    }\n\n    /**\n     * Returns the level of logging to perform.\n     * See {@link #setLogLevel(String)}.\n     *\n     * @return\n     */\n    public Level getLogLevel() {\n        if (logLevel == null) {\n            setLogLevel(pullParam(\"-loglevel\"));\n        }\n        return logLevel;\n    }\n\n    /**\n     * Returns <code>true</code> if the options indicate that the user wants\n     * to see some help information.\n     *\n     * @return\n     */\n    public boolean isHelpRequired() {\n        return helpRequired;\n    }\n\n    public boolean isDbHelpRequired() {\n        return dbHelpRequired;\n    }\n\n    /**\n     * Returns the jar that we were loaded from\n     *\n     * @return\n     */\n    public static String getLoadedFromJar() {\n        String classpath = System.getProperty(\"java.class.path\");\n        return new StringTokenizer(classpath, File.pathSeparator).nextToken();\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasOrphans(boolean hasOrphans) {\n        this.hasOrphans = hasOrphans;\n    }\n\n    /**\n     * @see #setHasOrphans()\n     *\n     * @return\n     */\n    public boolean hasOrphans() {\n        return hasOrphans;\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasRoutines(boolean hasRoutines) {\n        this.hasRoutines = hasRoutines;\n    }\n\n    /**\n     * @see #setHasRoutines()\n     *\n     * @return\n     */\n    public boolean hasRoutines() {\n        return hasRoutines;\n    }\n\n    /**\n     * Returns the database properties to use.\n     * These should be determined by calling {@link #determineDbProperties(String)}.\n     * @return\n     * @throws InvalidConfigurationException\n     */\n    public Properties getDbProperties() throws InvalidConfigurationException {\n        if (dbProperties == null) {\n            try {\n                dbProperties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(exc);\n            }\n        }\n        return dbProperties;\n    }\n\n    /**\n     * Determines the database properties associated with the specified type.\n     * A call to {@link #setDbProperties(Properties)} is expected after determining\n     * the complete set of properties.\n     *\n     * @param type\n     * @return\n     * @throws IOException\n     * @throws InvalidConfigurationException if db properties are incorrectly formed\n     */\n    public Properties determineDbProperties(String type) throws IOException, InvalidConfigurationException {\n        ResourceBundle bundle = null;\n        try {\n            File propertiesFile = new File(type);\n            bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n            dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n        } catch (FileNotFoundException notFoundOnFilesystemWithoutExtension) {\n            try {\n                File propertiesFile = new File(type + \".properties\");\n                bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n                dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n            } catch (FileNotFoundException notFoundOnFilesystemWithExtensionTackedOn) {\n                try {\n                    bundle = ResourceBundle.getBundle(type);\n                    dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]\" + File.separator + type + \".properties\";\n                } catch (Exception notInJarWithoutPath) {\n                    try {\n                        String path = TableOrderer.class.getPackage().getName() + \".dbTypes.\" + type;\n                        path = path.replace('.', '/');\n                        bundle = ResourceBundle.getBundle(path);\n                        dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]/\" + path + \".properties\";\n                    } catch (Exception notInJar) {\n                        notInJar.printStackTrace();\n                        notFoundOnFilesystemWithExtensionTackedOn.printStackTrace();\n                        throw notFoundOnFilesystemWithoutExtension;\n                    }\n                }\n            }\n        }\n        Properties props = asProperties(bundle);\n        bundle = null;\n        // keep original thru recursion\n        String saveLoadedFrom = dbPropertiesLoadedFrom;\n        // bring in key/values pointed to by the include directive\n        // example: include.1=mysql::selectRowCountSql\n        for (int i = 1; true; ++i) {\n            String include = (String) props.remove(\"include.\" + i);\n            if (include == null)\n                break;\n            int separator = include.indexOf(\"::\");\n            if (separator == -1)\n                throw new InvalidConfigurationException(\"include directive in \" + dbPropertiesLoadedFrom + \" must have '::' between dbType and key\");\n            String refdType = include.substring(0, separator).trim();\n            String refdKey = include.substring(separator + 2).trim();\n            // recursively resolve the ref'd properties file and the ref'd key\n            Properties refdProps = determineDbProperties(refdType);\n            props.put(refdKey, refdProps.getProperty(refdKey));\n        }\n        // bring in base properties files pointed to by the extends directive\n        String baseDbType = (String) props.remove(\"extends\");\n        if (baseDbType != null) {\n            baseDbType = baseDbType.trim();\n            Properties baseProps = determineDbProperties(baseDbType);\n            // overlay our properties on top of the base's\n            baseProps.putAll(props);\n            props = baseProps;\n        }\n        // done with this level of recursion...restore original\n        dbPropertiesLoadedFrom = saveLoadedFrom;\n        // this won't be correct until the final recursion exits\n        dbProperties = props;\n        return props;\n    }\n\n    protected String getDbPropertiesLoadedFrom() throws IOException {\n        if (dbPropertiesLoadedFrom == null)\n            determineDbProperties(getDbType());\n        return dbPropertiesLoadedFrom;\n    }\n\n    public List<String> getRemainingParameters() {\n        try {\n            populate();\n        } catch (IllegalArgumentException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (IllegalAccessException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (InvocationTargetException exc) {\n            if (exc.getCause() instanceof InvalidConfigurationException)\n                throw (InvalidConfigurationException) exc.getCause();\n            throw new InvalidConfigurationException(exc.getCause());\n        } catch (IntrospectionException exc) {\n            throw new InvalidConfigurationException(exc);\n        }\n        return options;\n    }\n\n    /**\n     * Options that are specific to a type of database.  E.g. things like <code>host</code>,\n     * <code>port</code> or <code>db</code>, but <b>don't</b> have a setter in this class.\n     *\n     * @param dbSpecificOptions\n     */\n    public void setDbSpecificOptions(Map<String, String> dbSpecificOptions) {\n        this.dbSpecificOptions = dbSpecificOptions;\n        originalDbSpecificOptions = new HashMap<String, String>(dbSpecificOptions);\n    }\n\n    public Map<String, String> getDbSpecificOptions() {\n        if (dbSpecificOptions == null)\n            dbSpecificOptions = new HashMap<String, String>();\n        return dbSpecificOptions;\n    }\n\n    /**\n     * Returns a {@link Properties} populated with the contents of <code>bundle</code>\n     *\n     * @param bundle ResourceBundle\n     * @return Properties\n     */\n    public static Properties asProperties(ResourceBundle bundle) {\n        Properties props = new Properties();\n        Enumeration<String> iter = bundle.getKeys();\n        while (iter.hasMoreElements()) {\n            String key = iter.nextElement();\n            props.put(key, bundle.getObject(key));\n        }\n        return props;\n    }\n\n    /**\n     * 'Pull' the specified parameter from the collection of options. Returns\n     * null if the parameter isn't in the list and removes it if it is.\n     *\n     * @param paramId\n     * @return\n     */\n    private String pullParam(String paramId) {\n        return pullParam(paramId, false, false);\n    }\n\n    private String pullRequiredParam(String paramId) {\n        return pullParam(paramId, true, false);\n    }\n\n    /**\n     * @param paramId\n     * @param required\n     * @param dbTypeSpecific\n     * @return\n     * @throws MissingRequiredParameterException\n     */\n    private String pullParam(String paramId, boolean required, boolean dbTypeSpecific) throws MissingRequiredParameterException {\n        int paramIndex = options.indexOf(paramId);\n        if (paramIndex < 0) {\n            if (required)\n                throw new MissingRequiredParameterException(paramId, dbTypeSpecific);\n            return null;\n        }\n        options.remove(paramIndex);\n        String param = options.get(paramIndex).toString();\n        options.remove(paramIndex);\n        return param;\n    }\n\n    /**\n     * Thrown to indicate that a required parameter is missing\n     */\n    public static class MissingRequiredParameterException extends RuntimeException {\n\n        private static final long serialVersionUID = 1L;\n\n        private final boolean dbTypeSpecific;\n\n        public MissingRequiredParameterException(String paramId, boolean dbTypeSpecific) {\n            this(paramId, null, dbTypeSpecific);\n        }\n\n        public MissingRequiredParameterException(String paramId, String description, boolean dbTypeSpecific) {\n            super(\"Required parameter '\" + paramId + \"' \" + (description == null ? \"\" : \"(\" + description + \") \") + \"was not specified.\" + (dbTypeSpecific ? \"  It is required for this database type.\" : \"\"));\n            this.dbTypeSpecific = dbTypeSpecific;\n        }\n\n        public boolean isDbTypeSpecific() {\n            return dbTypeSpecific;\n        }\n    }\n\n    /**\n     * Allow an equal sign in args...like \"-o=foo.bar\". Useful for things like\n     * Ant and Maven.\n     *\n     * @param args\n     *            List\n     * @return List\n     */\n    protected List<String> fixupArgs(List<String> args) {\n        List<String> expandedArgs = new ArrayList<String>();\n        for (String arg : args) {\n            int indexOfEquals = arg.indexOf('=');\n            if (indexOfEquals != -1 && indexOfEquals - 1 != arg.indexOf(ESCAPED_EQUALS)) {\n                expandedArgs.add(arg.substring(0, indexOfEquals));\n                expandedArgs.add(arg.substring(indexOfEquals + 1));\n            } else {\n                expandedArgs.add(arg);\n            }\n        }\n        // some OSes/JVMs do filename expansion with runtime.exec() and some don't,\n        // so MultipleSchemaAnalyzer has to surround params with double quotes...\n        // strip them here for the OSes/JVMs that don't do anything with the params\n        List<String> unquotedArgs = new ArrayList<String>();\n        for (String arg : expandedArgs) {\n            if (// \".*\" becomes .*\n            arg.startsWith(\"\\\"\") && arg.endsWith(\"\\\"\"))\n                arg = arg.substring(1, arg.length() - 1);\n            unquotedArgs.add(arg);\n        }\n        return unquotedArgs;\n    }\n\n    /**\n     * Call all the getters to populate all the lazy initialized stuff.\n     *\n     * @throws InvocationTargetException\n     * @throws IllegalAccessException\n     * @throws IllegalArgumentException\n     * @throws IntrospectionException\n     */\n    private void populate() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IntrospectionException {\n        if (!populating) {\n            // prevent recursion\n            populating = true;\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                Method readMethod = props[i].getReadMethod();\n                if (readMethod != null)\n                    readMethod.invoke(this, (Object[]) null);\n            }\n            populating = false;\n        }\n    }\n\n    public static Set<String> getBuiltInDatabaseTypes(String loadedFromJar) {\n        Set<String> databaseTypes = new TreeSet<String>();\n        JarInputStream jar = null;\n        try {\n            jar = new JarInputStream(new FileInputStream(loadedFromJar));\n            JarEntry entry;\n            while ((entry = jar.getNextJarEntry()) != null) {\n                String entryName = entry.getName();\n                int dotPropsIndex = entryName.indexOf(\".properties\");\n                if (dotPropsIndex != -1)\n                    databaseTypes.add(entryName.substring(0, dotPropsIndex));\n            }\n        } catch (IOException exc) {\n        } finally {\n            if (jar != null) {\n                try {\n                    jar.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n        return databaseTypes;\n    }\n\n    protected void dumpUsage(String errorMessage, boolean detailedDb) {\n        if (errorMessage != null) {\n            System.out.flush();\n            System.err.println(\"*** \" + errorMessage + \" ***\");\n        } else {\n            System.out.println(\"SchemaSpy generates an HTML representation of a database schema's relationships.\");\n        }\n        System.err.flush();\n        System.out.println();\n        if (!detailedDb) {\n            System.out.println(\"Usage:\");\n            System.out.println(\" java -jar \" + getLoadedFromJar() + \" [options]\");\n            System.out.println(\"   -t databaseType       type of database - defaults to ora\");\n            System.out.println(\"                           use -dbhelp for a list of built-in types\");\n            System.out.println(\"   -u user               connect to the database with this user id\");\n            System.out.println(\"   -s schema             defaults to the specified user\");\n            System.out.println(\"   -p password           defaults to no password\");\n            System.out.println(\"   -o outputDirectory    directory to place the generated output in\");\n            System.out.println(\"   -dp pathToDrivers     optional - looks for JDBC drivers here before looking\");\n            System.out.println(\"                           in driverPath in [databaseType].properties.\");\n            System.out.println(\"Go to http://schemaspy.sourceforge.net for a complete list/description\");\n            System.out.println(\" of additional parameters.\");\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"Built-in database types and their required connection parameters:\");\n            for (String type : getBuiltInDatabaseTypes(getLoadedFromJar())) {\n                new DbSpecificConfig(type).dumpUsage();\n            }\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"You can use your own database types by specifying the filespec of a .properties file with -t.\");\n            System.out.println(\"Grab one out of \" + getLoadedFromJar() + \" and modify it to suit your needs.\");\n            System.out.println();\n        }\n        System.out.println(\"Sample usage using the default database type (implied -t ora):\");\n        System.out.println(\" java -jar schemaSpy.jar -db mydb -s myschema -u devuser -p password -o output\");\n        System.out.println();\n        System.out.flush();\n    }\n\n    /**\n     * Get the value of the specified parameter.\n     * Used for properties that are common to most db's, but aren't required.\n     *\n     * @param paramName\n     * @return\n     */\n    public String getParam(String paramName) {\n        try {\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                PropertyDescriptor prop = props[i];\n                if (prop.getName().equalsIgnoreCase(paramName)) {\n                    Object result = prop.getReadMethod().invoke(this, (Object[]) null);\n                    return result == null ? null : result.toString();\n                }\n            }\n        } catch (Exception failed) {\n            failed.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * Return all of the configuration options as a List of Strings, with\n     * each parameter and its value as a separate element.\n     *\n     * @return\n     * @throws IOException\n     */\n    public List<String> asList() throws IOException {\n        List<String> params = new ArrayList<String>();\n        if (originalDbSpecificOptions != null) {\n            for (String key : originalDbSpecificOptions.keySet()) {\n                String value = originalDbSpecificOptions.get(key);\n                if (!key.startsWith(\"-\"))\n                    key = \"-\" + key;\n                params.add(key);\n                params.add(value);\n            }\n        }\n        if (isEncodeCommentsEnabled())\n            params.add(\"-ahic\");\n        if (isEvaluateAllEnabled())\n            params.add(\"-all\");\n        if (!isHtmlGenerationEnabled())\n            params.add(\"-nohtml\");\n        if (!isImpliedConstraintsEnabled())\n            params.add(\"-noimplied\");\n        if (!isLogoEnabled())\n            params.add(\"-nologo\");\n        if (isMeterEnabled())\n            params.add(\"-meter\");\n        if (!isNumRowsEnabled())\n            params.add(\"-norows\");\n        if (!isViewsEnabled())\n            params.add(\"-noviews\");\n        if (isRankDirBugEnabled())\n            params.add(\"-rankdirbug\");\n        if (isRailsEnabled())\n            params.add(\"-rails\");\n        if (isSingleSignOn())\n            params.add(\"-sso\");\n        if (isSchemaDisabled())\n            params.add(\"-noschema\");\n        String value = getDriverPath();\n        if (value != null) {\n            params.add(\"-dp\");\n            params.add(value);\n        }\n        params.add(\"-css\");\n        params.add(getCss());\n        params.add(\"-charset\");\n        params.add(getCharset());\n        params.add(\"-font\");\n        params.add(getFont());\n        params.add(\"-fontsize\");\n        params.add(String.valueOf(getFontSize()));\n        params.add(\"-t\");\n        params.add(getDbType());\n        // query to set renderer correctly\n        isHighQuality();\n        // query to set renderer correctly\n        isLowQuality();\n        // instead of -hq and/or -lq\n        params.add(\"-renderer\");\n        params.add(getRenderer());\n        value = getDescription();\n        if (value != null) {\n            params.add(\"-desc\");\n            params.add(value);\n        }\n        value = getPassword();\n        if (value != null && !isPromptForPasswordEnabled()) {\n            // note that we don't pass -pfp since child processes\n            // won't have a console\n            params.add(\"-p\");\n            params.add(value);\n        }\n        value = getCatalog();\n        if (value != null) {\n            params.add(\"-cat\");\n            params.add(value);\n        }\n        value = getSchema();\n        if (value != null) {\n            params.add(\"-s\");\n            params.add(value);\n        }\n        value = getUser();\n        if (value != null) {\n            params.add(\"-u\");\n            params.add(value);\n        }\n        value = getConnectionPropertiesFile();\n        if (value != null) {\n            params.add(\"-connprops\");\n            params.add(value);\n        } else {\n            Properties props = getConnectionProperties();\n            if (!props.isEmpty()) {\n                params.add(\"-connprops\");\n                StringBuilder buf = new StringBuilder();\n                for (Entry<Object, Object> entry : props.entrySet()) {\n                    buf.append(entry.getKey());\n                    buf.append(ESCAPED_EQUALS);\n                    buf.append(entry.getValue());\n                    buf.append(';');\n                }\n                params.add(buf.toString());\n            }\n        }\n        value = getDb();\n        if (value != null) {\n            params.add(\"-db\");\n            params.add(value);\n        }\n        value = getHost();\n        if (value != null) {\n            params.add(\"-host\");\n            params.add(value);\n        }\n        if (getPort() != null) {\n            params.add(\"-port\");\n            params.add(getPort().toString());\n        }\n        value = getServer();\n        if (value != null) {\n            params.add(\"-server\");\n            params.add(value);\n        }\n        value = getMeta();\n        if (value != null) {\n            params.add(\"-meta\");\n            params.add(value);\n        }\n        if (getGraphvizDir() != null) {\n            params.add(\"-gv\");\n            params.add(getGraphvizDir().toString());\n        }\n        params.add(\"-loglevel\");\n        params.add(getLogLevel().toString().toLowerCase());\n        params.add(\"-sqlFormatter\");\n        params.add(getSqlFormatter().getClass().getName());\n        params.add(\"-i\");\n        params.add(getTableInclusions().toString());\n        params.add(\"-I\");\n        params.add(getTableExclusions().toString());\n        params.add(\"-X\");\n        params.add(getColumnExclusions().toString());\n        params.add(\"-x\");\n        params.add(getIndirectColumnExclusions().toString());\n        params.add(\"-dbthreads\");\n        params.add(String.valueOf(getMaxDbThreads()));\n        params.add(\"-maxdet\");\n        params.add(String.valueOf(getMaxDetailedTables()));\n        params.add(\"-o\");\n        params.add(getOutputDir().toString());\n        return params;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/ConfigTest16.java",
		"test_prompt": "// ConfigTest16.java\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Config}.\n* It contains ten unit test cases for the {@link Config#isLowQuality()} method.\n*/\nclass ConfigTest16 {"
	},
	{
		"original_code": "// Config.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\n\n/**\n * Configuration of a SchemaSpy run\n *\n * @author John Currier\n */\npublic class Config {\n\n    private static Config instance;\n\n    private final List<String> options;\n\n    private Map<String, String> dbSpecificOptions;\n\n    private Map<String, String> originalDbSpecificOptions;\n\n    private boolean helpRequired;\n\n    private boolean dbHelpRequired;\n\n    private File outputDir;\n\n    private File graphvizDir;\n\n    private String dbType;\n\n    private String catalog;\n\n    private String schema;\n\n    private List<String> schemas;\n\n    private String user;\n\n    private Boolean singleSignOn;\n\n    private Boolean noSchema;\n\n    private String password;\n\n    private Boolean promptForPassword;\n\n    private String db;\n\n    private String host;\n\n    private Integer port;\n\n    private String server;\n\n    private String meta;\n\n    private Pattern tableInclusions;\n\n    private Pattern tableExclusions;\n\n    private Pattern columnExclusions;\n\n    private Pattern indirectColumnExclusions;\n\n    private String userConnectionPropertiesFile;\n\n    private Properties userConnectionProperties;\n\n    private Integer maxDbThreads;\n\n    private Integer maxDetailedTables;\n\n    private String driverPath;\n\n    private String css;\n\n    private String charset;\n\n    private String font;\n\n    private Integer fontSize;\n\n    private String description;\n\n    private Properties dbProperties;\n\n    private String dbPropertiesLoadedFrom;\n\n    private Level logLevel;\n\n    private SqlFormatter sqlFormatter;\n\n    private String sqlFormatterClass;\n\n    private Boolean generateHtml;\n\n    private Boolean includeImpliedConstraints;\n\n    private Boolean logoEnabled;\n\n    private Boolean rankDirBugEnabled;\n\n    private Boolean encodeCommentsEnabled;\n\n    private Boolean numRowsEnabled;\n\n    private Boolean viewsEnabled;\n\n    private Boolean meterEnabled;\n\n    private Boolean railsEnabled;\n\n    private Boolean evaluteAll;\n\n    private Boolean highQuality;\n\n    private Boolean lowQuality;\n\n    // used in conjunction with evaluateAll\n    private String schemaSpec;\n\n    private boolean hasOrphans = false;\n\n    private boolean hasRoutines = false;\n\n    private boolean populating = false;\n\n    private List<String> columnDetails;\n\n    public static final String DOT_CHARSET = \"UTF-8\";\n\n    private static final String ESCAPED_EQUALS = \"\\\\=\";\n\n    // match everything\n    private static final String DEFAULT_TABLE_INCLUSION = \".*\";\n\n    // match nothing\n    private static final String DEFAULT_TABLE_EXCLUSION = \"\";\n\n    // match nothing\n    private static final String DEFAULT_COLUMN_EXCLUSION = \"[^.]\";\n\n    /**\n     * Default constructor. Intended for when you want to inject properties\n     * independently (i.e. not from a command line interface).\n     */\n    public Config() {\n        if (instance == null)\n            setInstance(this);\n        options = new ArrayList<String>();\n    }\n\n    /**\n     * Construct a configuration from an array of options (e.g. from a command\n     * line interface).\n     *\n     * @param options\n     */\n    public Config(String[] argv) {\n        setInstance(this);\n        options = fixupArgs(Arrays.asList(argv));\n        helpRequired = options.remove(\"-?\") || options.remove(\"/?\") || options.remove(\"?\") || options.remove(\"-h\") || options.remove(\"-help\") || options.remove(\"--help\");\n        dbHelpRequired = options.remove(\"-dbHelp\") || options.remove(\"-dbhelp\");\n    }\n\n    public static Config getInstance() {\n        if (instance == null)\n            instance = new Config();\n        return instance;\n    }\n\n    /**\n     * Sets the global instance.\n     *\n     * Useful for things like selecting a specific configuration in a UI.\n     *\n     * @param config\n     */\n    public static void setInstance(Config config) {\n        instance = config;\n    }\n\n    public void setHtmlGenerationEnabled(boolean generateHtml) {\n        this.generateHtml = generateHtml;\n    }\n\n    public boolean isHtmlGenerationEnabled() {\n        if (generateHtml == null)\n            generateHtml = !options.remove(\"-nohtml\");\n        return generateHtml;\n    }\n\n    public void setImpliedConstraintsEnabled(boolean includeImpliedConstraints) {\n        this.includeImpliedConstraints = includeImpliedConstraints;\n    }\n\n    public boolean isImpliedConstraintsEnabled() {\n        if (includeImpliedConstraints == null)\n            includeImpliedConstraints = !options.remove(\"-noimplied\");\n        return includeImpliedConstraints;\n    }\n\n    public void setOutputDir(String outputDirName) {\n        if (outputDirName.endsWith(\"\\\"\"))\n            outputDirName = outputDirName.substring(0, outputDirName.length() - 1);\n        setOutputDir(new File(outputDirName));\n    }\n\n    public void setOutputDir(File outputDir) {\n        this.outputDir = outputDir;\n    }\n\n    public File getOutputDir() {\n        if (outputDir == null) {\n            setOutputDir(pullRequiredParam(\"-o\"));\n        }\n        return outputDir;\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(String graphvizDir) {\n        if (graphvizDir.endsWith(\"\\\"\"))\n            graphvizDir = graphvizDir.substring(0, graphvizDir.length() - 1);\n        setGraphvizDir(new File(graphvizDir));\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(File graphvizDir) {\n        this.graphvizDir = graphvizDir;\n    }\n\n    /**\n     * Return the path to Graphviz (used to find the dot executable to run to\n     * generate ER diagrams).<p/>\n     *\n     * Returns {@link #getDefaultGraphvizPath()} if a specific Graphviz path\n     * was not specified.\n     *\n     * @return\n     */\n    public File getGraphvizDir() {\n        if (graphvizDir == null) {\n            String gv = pullParam(\"-gv\");\n            if (gv != null) {\n                setGraphvizDir(gv);\n            } else {\n                // expect to find Graphviz's bin directory on the PATH\n            }\n        }\n        return graphvizDir;\n    }\n\n    /**\n     * Meta files are XML-based files that provide additional metadata\n     * about the schema being evaluated.<p>\n     * <code>meta</code> is either the name of an individual XML file or\n     * the directory that contains meta files.<p>\n     * If a directory is specified then it is expected to contain files\n     * matching the pattern <code>[schema].meta.xml</code>.\n     * For databases that don't have schema substitute database for schema.\n     * @param meta\n     */\n    public void setMeta(String meta) {\n        this.meta = meta;\n    }\n\n    public String getMeta() {\n        if (meta == null)\n            meta = pullParam(\"-meta\");\n        return meta;\n    }\n\n    public void setDbType(String dbType) {\n        this.dbType = dbType;\n    }\n\n    public String getDbType() {\n        if (dbType == null) {\n            dbType = pullParam(\"-t\");\n            if (dbType == null)\n                dbType = \"ora\";\n        }\n        return dbType;\n    }\n\n    public void setDb(String db) {\n        this.db = db;\n    }\n\n    public String getDb() {\n        if (db == null)\n            db = pullParam(\"-db\");\n        return db;\n    }\n\n    public void setCatalog(String catalog) {\n        this.catalog = catalog;\n    }\n\n    public String getCatalog() {\n        if (catalog == null)\n            catalog = pullParam(\"-cat\");\n        return catalog;\n    }\n\n    public void setSchema(String schema) {\n        this.schema = schema;\n    }\n\n    public String getSchema() {\n        if (schema == null)\n            schema = pullParam(\"-s\");\n        return schema;\n    }\n\n    /**\n     * Some databases types (e.g. older versions of Informix) don't really\n     * have the concept of a schema but still return true from\n     * {@link DatabaseMetaData#supportsSchemasInTableDefinitions()}.\n     * This option lets you ignore that and treat all the tables\n     * as if they were in one flat namespace.\n     */\n    public boolean isSchemaDisabled() {\n        if (noSchema == null)\n            noSchema = options.remove(\"-noschema\");\n        return noSchema;\n    }\n\n    public void setHost(String host) {\n        this.host = host;\n    }\n\n    public String getHost() {\n        if (host == null)\n            host = pullParam(\"-host\");\n        return host;\n    }\n\n    public void setPort(Integer port) {\n        this.port = port;\n    }\n\n    public Integer getPort() {\n        if (port == null)\n            try {\n                port = Integer.valueOf(pullParam(\"-port\"));\n            } catch (Exception notSpecified) {\n            }\n        return port;\n    }\n\n    public void setServer(String server) {\n        this.server = server;\n    }\n\n    public String getServer() {\n        if (server == null) {\n            server = pullParam(\"-server\");\n        }\n        return server;\n    }\n\n    public void setUser(String user) {\n        this.user = user;\n    }\n\n    /**\n     * User used to connect to the database.\n     * Required unless single sign-on is enabled\n     * (see {@link #setSingleSignOn(boolean)}).\n     * @return\n     */\n    public String getUser() {\n        if (user == null) {\n            if (!isSingleSignOn())\n                user = pullRequiredParam(\"-u\");\n            else\n                user = pullParam(\"-u\");\n        }\n        return user;\n    }\n\n    /**\n     * By default a \"user\" (as specified with -u) is required.\n     * This option allows disabling of that requirement for\n     * single sign-on environments.\n     *\n     * @param enabled defaults to <code>false</code>\n     */\n    public void setSingleSignOn(boolean enabled) {\n        singleSignOn = enabled;\n    }\n\n    /**\n     * @see #setSingleSignOn(boolean)\n     */\n    public boolean isSingleSignOn() {\n        if (singleSignOn == null)\n            singleSignOn = options.remove(\"-sso\");\n        return singleSignOn;\n    }\n\n    /**\n     * Set the password used to connect to the database.\n     * @param password\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * @see #setPassword(String)\n     * @return\n     */\n    public String getPassword() {\n        if (password == null)\n            password = pullParam(\"-p\");\n        if (password == null && isPromptForPasswordEnabled())\n            password = new String(PasswordReader.getInstance().readPassword(\"Password: \"));\n        if (password == null) {\n            // if -pfp is enabled when analyzing multiple schemas then\n            // we don't want to send the password on the command line,\n            // so see if it was passed in the environment (not ideal, but safer)\n            password = System.getenv(\"schemaspy.pw\");\n        }\n        return password;\n    }\n\n    /**\n     * Set to <code>true</code> to prompt for the password\n     * @param promptForPassword\n     */\n    public void setPromptForPasswordEnabled(boolean promptForPassword) {\n        this.promptForPassword = promptForPassword;\n    }\n\n    /**\n     * @see #setPromptForPasswordEnabled(boolean)\n     * @return\n     */\n    public boolean isPromptForPasswordEnabled() {\n        if (promptForPassword == null) {\n            promptForPassword = options.remove(\"-pfp\");\n        }\n        return promptForPassword;\n    }\n\n    public void setMaxDetailedTabled(int maxDetailedTables) {\n        this.maxDetailedTables = new Integer(maxDetailedTables);\n    }\n\n    public int getMaxDetailedTables() {\n        if (maxDetailedTables == null) {\n            // default\n            int max = 300;\n            try {\n                max = Integer.parseInt(pullParam(\"-maxdet\"));\n            } catch (Exception notSpecified) {\n            }\n            maxDetailedTables = new Integer(max);\n        }\n        return maxDetailedTables.intValue();\n    }\n\n    public String getConnectionPropertiesFile() {\n        return userConnectionPropertiesFile;\n    }\n\n    /**\n     * Properties from this file (in key=value pair format) are passed to the\n     * database connection.<br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.\n     * @param propertiesFilename\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public void setConnectionPropertiesFile(String propertiesFilename) throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null)\n            userConnectionProperties = new Properties();\n        userConnectionProperties.load(new FileInputStream(propertiesFilename));\n        userConnectionPropertiesFile = propertiesFilename;\n    }\n\n    /**\n     * Returns a {@link Properties} populated either from the properties file specified\n     * by {@link #setConnectionPropertiesFile(String)}, the properties specified by\n     * {@link #setConnectionProperties(String)} or not populated.\n     * @return\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public Properties getConnectionProperties() throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null) {\n            String props = pullParam(\"-connprops\");\n            if (props != null) {\n                if (props.indexOf(ESCAPED_EQUALS) != -1) {\n                    setConnectionProperties(props);\n                } else {\n                    setConnectionPropertiesFile(props);\n                }\n            } else {\n                userConnectionProperties = new Properties();\n            }\n        }\n        return userConnectionProperties;\n    }\n\n    /**\n     * Specifies connection properties to use in the format:\n     * <code>key1\\=value1;key2\\=value2</code><br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.<p>\n     * This is an alternative form of passing connection properties than by file\n     * (see {@link #setConnectionPropertiesFile(String)})\n     *\n     * @param properties\n     */\n    public void setConnectionProperties(String properties) {\n        userConnectionProperties = new Properties();\n        StringTokenizer tokenizer = new StringTokenizer(properties, \";\");\n        while (tokenizer.hasMoreElements()) {\n            String pair = tokenizer.nextToken();\n            int index = pair.indexOf(ESCAPED_EQUALS);\n            if (index != -1) {\n                String key = pair.substring(0, index);\n                String value = pair.substring(index + ESCAPED_EQUALS.length());\n                userConnectionProperties.put(key, value);\n            }\n        }\n    }\n\n    public void setDriverPath(String driverPath) {\n        this.driverPath = driverPath;\n    }\n\n    public String getDriverPath() {\n        if (driverPath == null)\n            driverPath = pullParam(\"-dp\");\n        // was previously -cp:\n        if (driverPath == null)\n            driverPath = pullParam(\"-cp\");\n        return driverPath;\n    }\n\n    /**\n     * The filename of the cascading style sheet to use.\n     * Note that this file is parsed and used to determine characteristics\n     * of the generated diagrams, so it must contain specific settings that\n     * are documented within schemaSpy.css.<p>\n     *\n     * Defaults to <code>\"schemaSpy.css\"</code>.\n     *\n     * @param css\n     */\n    public void setCss(String css) {\n        this.css = css;\n    }\n\n    public String getCss() {\n        if (css == null) {\n            css = pullParam(\"-css\");\n            if (css == null)\n                css = \"schemaSpy.css\";\n        }\n        return css;\n    }\n\n    /**\n     * The font to use within diagrams.  Modify the .css to specify HTML fonts.\n     *\n     * @param font\n     */\n    public void setFont(String font) {\n        this.font = font;\n    }\n\n    /**\n     * @see #setFont(String)\n     */\n    public String getFont() {\n        if (font == null) {\n            font = pullParam(\"-font\");\n            if (font == null)\n                font = \"Helvetica\";\n        }\n        return font;\n    }\n\n    /**\n     * The font size to use within diagrams.  This is the size of the font used for\n     * 'large' (e.g. not 'compact') diagrams.<p>\n     *\n     * Modify the .css to specify HTML font sizes.<p>\n     *\n     * Defaults to 11.\n     *\n     * @param fontSize\n     */\n    public void setFontSize(int fontSize) {\n        this.fontSize = new Integer(fontSize);\n    }\n\n    /**\n     * @see #setFontSize(int)\n     * @return\n     */\n    public int getFontSize() {\n        if (fontSize == null) {\n            // default\n            int size = 11;\n            try {\n                size = Integer.parseInt(pullParam(\"-fontsize\"));\n            } catch (Exception notSpecified) {\n            }\n            fontSize = new Integer(size);\n        }\n        return fontSize.intValue();\n    }\n\n    /**\n     * The character set to use within HTML pages (defaults to <code>\"ISO-8859-1\"</code>).\n     *\n     * @param charset\n     */\n    public void setCharset(String charset) {\n        this.charset = charset;\n    }\n\n    /**\n     * @see #setCharset(String)\n     */\n    public String getCharset() {\n        if (charset == null) {\n            charset = pullParam(\"-charset\");\n            if (charset == null)\n                charset = \"ISO-8859-1\";\n        }\n        return charset;\n    }\n\n    /**\n     * Description of schema that gets display on main pages.\n     *\n     * @param description\n     */\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    /**\n     * @see #setDescription(String)\n     */\n    public String getDescription() {\n        if (description == null)\n            description = pullParam(\"-desc\");\n        return description;\n    }\n\n    /**\n     * Maximum number of threads to use when querying database metadata information.\n     *\n     * @param maxDbThreads\n     */\n    public void setMaxDbThreads(int maxDbThreads) {\n        this.maxDbThreads = new Integer(maxDbThreads);\n    }\n\n    /**\n     * @see #setMaxDbThreads(int)\n     * @throws InvalidConfigurationException if unable to load properties\n     */\n    public int getMaxDbThreads() throws InvalidConfigurationException {\n        if (maxDbThreads == null) {\n            Properties properties;\n            try {\n                properties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(\"Failed to load properties for \" + getDbType() + \": \" + exc).setParamName(\"-type\");\n            }\n            // not scientifically derived\n            final int defaultMax = 15;\n            int max = defaultMax;\n            String threads = properties.getProperty(\"dbThreads\");\n            if (threads == null)\n                threads = properties.getProperty(\"dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            threads = pullParam(\"-dbThreads\");\n            if (threads == null)\n                threads = pullParam(\"-dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            if (max < 0)\n                max = defaultMax;\n            else if (max == 0)\n                max = 1;\n            maxDbThreads = new Integer(max);\n        }\n        return maxDbThreads.intValue();\n    }\n\n    public boolean isLogoEnabled() {\n        if (logoEnabled == null)\n            logoEnabled = !options.remove(\"-nologo\");\n        return logoEnabled;\n    }\n\n    /**\n     * Don't use this unless absolutely necessary as it screws up the layout\n     *\n     * @param enabled\n     */\n    public void setRankDirBugEnabled(boolean enabled) {\n        rankDirBugEnabled = enabled;\n    }\n\n    /**\n     * @see #setRankDirBugEnabled(boolean)\n     */\n    public boolean isRankDirBugEnabled() {\n        if (rankDirBugEnabled == null)\n            rankDirBugEnabled = options.remove(\"-rankdirbug\");\n        return rankDirBugEnabled;\n    }\n\n    /**\n     * Look for Ruby on Rails-based naming conventions in\n     * relationships between logical foreign keys and primary keys.<p>\n     *\n     * Basically all tables have a primary key named <code>ID</code>.\n     * All tables are named plural names.\n     * The columns that logically reference that <code>ID</code> are the singular\n     * form of the table name suffixed with <code>_ID</code>.<p>\n     *\n     * @param enabled\n     */\n    public void setRailsEnabled(boolean enabled) {\n        railsEnabled = enabled;\n    }\n\n    /**\n     * @see #setRailsEnabled(boolean)\n     *\n     * @return\n     */\n    public boolean isRailsEnabled() {\n        if (railsEnabled == null)\n            railsEnabled = options.remove(\"-rails\");\n        return railsEnabled;\n    }\n\n    /**\n     * Allow Html In Comments - encode them unless otherwise specified\n     */\n    public void setEncodeCommentsEnabled(boolean enabled) {\n        encodeCommentsEnabled = enabled;\n    }\n\n    /**\n     * @see #setEncodeCommentsEnabled(boolean)\n     */\n    public boolean isEncodeCommentsEnabled() {\n        if (encodeCommentsEnabled == null)\n            encodeCommentsEnabled = !options.remove(\"-ahic\");\n        return encodeCommentsEnabled;\n    }\n\n    /**\n     * If enabled we'll attempt to query/render the number of rows that\n     * each table contains.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setNumRowsEnabled(boolean enabled) {\n        numRowsEnabled = enabled;\n    }\n\n    /**\n     * @see #setNumRowsEnabled(boolean)\n     * @return\n     */\n    public boolean isNumRowsEnabled() {\n        if (numRowsEnabled == null)\n            numRowsEnabled = !options.remove(\"-norows\");\n        return numRowsEnabled;\n    }\n\n    /**\n     * If enabled we'll include views in the analysis.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setViewsEnabled(boolean enabled) {\n        viewsEnabled = enabled;\n    }\n\n    /**\n     * @see #setViewsEnabled(boolean)\n     * @return\n     */\n    public boolean isViewsEnabled() {\n        if (viewsEnabled == null)\n            viewsEnabled = !options.remove(\"-noviews\");\n        return viewsEnabled;\n    }\n\n    /**\n     * Returns <code>true</code> if metering should be embedded in\n     * the generated pages.<p/>\n     * Defaults to <code>false</code> (disabled).\n     * @return\n     */\n    public boolean isMeterEnabled() {\n        if (meterEnabled == null)\n            meterEnabled = options.remove(\"-meter\");\n        return meterEnabled;\n    }\n\n    /**\n     * Set the columns to exclude from all relationship diagrams.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setColumnExclusions(String columnExclusions) {\n        this.columnExclusions = Pattern.compile(columnExclusions);\n    }\n\n    /**\n     * See {@link #setColumnExclusions(String)}\n     * @return\n     */\n    public Pattern getColumnExclusions() {\n        if (columnExclusions == null) {\n            String strExclusions = pullParam(\"-X\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.columnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            columnExclusions = Pattern.compile(strExclusions);\n        }\n        return columnExclusions;\n    }\n\n    /**\n     * Set the columns to exclude from relationship diagrams where the specified\n     * columns aren't directly referenced by the focal table.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setIndirectColumnExclusions(String fullColumnExclusions) {\n        indirectColumnExclusions = Pattern.compile(fullColumnExclusions);\n    }\n\n    /**\n     * @see #setIndirectColumnExclusions(String)\n     *\n     * @return\n     */\n    public Pattern getIndirectColumnExclusions() {\n        if (indirectColumnExclusions == null) {\n            String strExclusions = pullParam(\"-x\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.indirectColumnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            indirectColumnExclusions = Pattern.compile(strExclusions);\n        }\n        return indirectColumnExclusions;\n    }\n\n    /**\n     * Set the tables to include as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableInclusions(String tableInclusions) {\n        this.tableInclusions = Pattern.compile(tableInclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to include in the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableInclusions() {\n        if (tableInclusions == null) {\n            String strInclusions = pullParam(\"-i\");\n            if (strInclusions == null)\n                strInclusions = System.getenv(\"schemaspy.tableInclusions\");\n            if (strInclusions == null)\n                strInclusions = DEFAULT_TABLE_INCLUSION;\n            try {\n                tableInclusions = Pattern.compile(strInclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-i\");\n            }\n        }\n        return tableInclusions;\n    }\n\n    /**\n     * Set the tables to exclude as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableExclusions(String tableExclusions) {\n        this.tableExclusions = Pattern.compile(tableExclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to exclude from the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableExclusions() {\n        if (tableExclusions == null) {\n            String strExclusions = pullParam(\"-I\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.tableExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_TABLE_EXCLUSION;\n            try {\n                tableExclusions = Pattern.compile(strExclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-I\");\n            }\n        }\n        return tableExclusions;\n    }\n\n    /**\n     * @return\n     */\n    public List<String> getSchemas() {\n        if (schemas == null) {\n            String tmp = pullParam(\"-schemas\");\n            if (tmp == null)\n                tmp = pullParam(\"-schemata\");\n            if (tmp != null) {\n                schemas = new ArrayList<String>();\n                for (String name : tmp.split(\"[\\\\s,'\\\"]\")) {\n                    if (name.length() > 0)\n                        schemas.add(name);\n                }\n                if (schemas.isEmpty())\n                    schemas = null;\n            }\n        }\n        return schemas;\n    }\n\n    /**\n     * Set the name of the {@link SqlFormatter SQL formatter} class to use to\n     * format SQL into HTML.<p/>\n     * The implementation of the class must be made available to the class\n     * loader, typically by specifying the path to its jar with <em>-dp</em>\n     * ({@link #setDriverPath(String)}).\n     */\n    public void setSqlFormatter(String formatterClassName) {\n        sqlFormatterClass = formatterClassName;\n        sqlFormatter = null;\n    }\n\n    /**\n     * Set the {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.\n     */\n    public void setSqlFormatter(SqlFormatter sqlFormatter) {\n        this.sqlFormatter = sqlFormatter;\n        if (sqlFormatter != null)\n            sqlFormatterClass = sqlFormatter.getClass().getName();\n    }\n\n    /**\n     * Returns an implementation of {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.  The default implementation is {@link DefaultSqlFormatter}.\n     *\n     * @return\n     * @throws InvalidConfigurationException if unable to instantiate an instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SqlFormatter getSqlFormatter() throws InvalidConfigurationException {\n        if (sqlFormatter == null) {\n            if (sqlFormatterClass == null) {\n                sqlFormatterClass = pullParam(\"-sqlFormatter\");\n                if (sqlFormatterClass == null)\n                    sqlFormatterClass = DefaultSqlFormatter.class.getName();\n            }\n            try {\n                Class<SqlFormatter> clazz = (Class<SqlFormatter>) Class.forName(sqlFormatterClass);\n                sqlFormatter = clazz.newInstance();\n            } catch (Exception exc) {\n                throw new InvalidConfigurationException(\"Failed to initialize instance of SQL formatter: \", exc).setParamName(\"-sqlFormatter\");\n            }\n        }\n        return sqlFormatter;\n    }\n\n    /**\n     * Set the details to show on the columns page, where \"details\" are\n     * comma and/or space separated.\n     *\n     * Valid values:\n     * <ul>\n     * <li>id</li>\n     * <li>table</li>\n     * <li>column</li>\n     * <li>type</li>\n     * <li>size</li>\n     * <li>nulls</li>\n     * <li>auto</li>\n     * <li>default</li>\n     * <li>children</li>\n     * <li>parents</li>\n     * </ul>\n     *\n     * The default details are <code>\"table column type size nulls auto default\"</code>.\n     * Note that \"column\" is the initially displayed detail and must be included.\n     *\n     * @param columnDetails\n     */\n    public void setColumnDetails(String columnDetails) {\n        this.columnDetails = new ArrayList<String>();\n        if (columnDetails == null || columnDetails.length() == 0) {\n            // not specified, so use defaults\n            columnDetails = \"id table column type size nulls auto default\";\n        }\n        for (String detail : columnDetails.split(\"[\\\\s,'\\\"]\")) {\n            if (detail.length() > 0) {\n                this.columnDetails.add(detail.toLowerCase());\n            }\n        }\n        if (!this.columnDetails.contains(\"column\"))\n            throw new InvalidConfigurationException(\"'column' is a required column detail\");\n    }\n\n    public void setColumnDetails(List<String> columnDetails) {\n        String details = columnDetails == null ? \"[]\" : columnDetails.toString();\n        setColumnDetails(details.substring(1, details.length() - 1));\n    }\n\n    public List<String> getColumnDetails() {\n        if (columnDetails == null) {\n            setColumnDetails(pullParam(\"-columndetails\"));\n        }\n        return columnDetails;\n    }\n\n    public void setEvaluateAllEnabled(boolean enabled) {\n        evaluteAll = enabled;\n    }\n\n    public boolean isEvaluateAllEnabled() {\n        if (evaluteAll == null)\n            evaluteAll = options.remove(\"-all\");\n        return evaluteAll;\n    }\n\n    /**\n     * Returns true if we're evaluating a bunch of schemas in one go and\n     * at this point we're evaluating a specific schema.\n     *\n     * @return boolean\n     */\n    public boolean isOneOfMultipleSchemas() {\n        // set by MultipleSchemaAnalyzer\n        return Boolean.getBoolean(\"oneofmultipleschemas\");\n    }\n\n    /**\n     * When -all (evaluateAll) is specified then this is the regular\n     * expression that determines which schemas to evaluate.\n     *\n     * @param schemaSpec\n     */\n    public void setSchemaSpec(String schemaSpec) {\n        this.schemaSpec = schemaSpec;\n    }\n\n    public String getSchemaSpec() {\n        if (schemaSpec == null)\n            schemaSpec = pullParam(\"-schemaSpec\");\n        return schemaSpec;\n    }\n\n    /**\n     * Set the renderer to use for the -Tpng[:renderer[:formatter]] dot option as specified\n     * at <a href='http://www.graphviz.org/doc/info/command.html'>\n     * http://www.graphviz.org/doc/info/command.html</a>.<p>\n     * Note that the leading \":\" is required while :formatter is optional.<p>\n     * The default renderer is typically GD.<p>\n     * Note that using {@link #setHighQuality(boolean)} is the preferred approach\n     * over using this method.\n     */\n    public void setRenderer(String renderer) {\n        Dot.getInstance().setRenderer(renderer);\n    }\n\n    /**\n     * @see #setRenderer(String)\n     * @return\n     */\n    public String getRenderer() {\n        String renderer = pullParam(\"-renderer\");\n        if (renderer != null)\n            setRenderer(renderer);\n        return Dot.getInstance().getRenderer();\n    }\n\n    /**\n     * If <code>false</code> then generate output of \"lower quality\"\n     * than the default.\n     * Note that the default is intended to be \"higher quality\",\n     * but various installations of Graphviz may have have different abilities.\n     * That is, some might not have the \"lower quality\" libraries and others might\n     * not have the \"higher quality\" libraries.<p>\n     * Higher quality output takes longer to generate and results in significantly\n     * larger image files (which take longer to download / display), but it generally\n     * looks better.\n     */\n    public void setHighQuality(boolean highQuality) {\n        this.highQuality = highQuality;\n        lowQuality = !highQuality;\n        Dot.getInstance().setHighQuality(highQuality);\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isHighQuality() {\n        if (highQuality == null) {\n            highQuality = options.remove(\"-hq\");\n            if (highQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(highQuality);\n            }\n        }\n        highQuality = Dot.getInstance().isHighQuality();\n        return highQuality;\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isLowQuality() {\n        if (lowQuality == null) {\n            lowQuality = options.remove(\"-lq\");\n            if (lowQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(!lowQuality);\n            }\n        }\n        lowQuality = !Dot.getInstance().isHighQuality();\n        return lowQuality;\n    }\n\n    /**\n     * Set the level of logging to perform.<p/>\n     * The levels in descending order are:\n     * <ul>\n     *  <li><code>severe</code> (highest - least detail)\n     *  <li><code>warning</code> (default)\n     *  <li><code>info</code>\n     *  <li><code>config</code>\n     *  <li><code>fine</code>\n     *  <li><code>finer</code>\n     *  <li><code>finest</code>  (lowest - most detail)\n     * </ul>\n     *\n     * @param logLevel\n     */\n    public void setLogLevel(String logLevel) {\n        if (logLevel == null) {\n            this.logLevel = Level.WARNING;\n            return;\n        }\n        Map<String, Level> levels = new LinkedHashMap<String, Level>();\n        levels.put(\"severe\", Level.SEVERE);\n        levels.put(\"warning\", Level.WARNING);\n        levels.put(\"info\", Level.INFO);\n        levels.put(\"config\", Level.CONFIG);\n        levels.put(\"fine\", Level.FINE);\n        levels.put(\"finer\", Level.FINER);\n        levels.put(\"finest\", Level.FINEST);\n        this.logLevel = levels.get(logLevel.toLowerCase());\n        if (this.logLevel == null) {\n            throw new InvalidConfigurationException(\"Invalid logLevel: '\" + logLevel + \"'. Must be one of: \" + levels.keySet());\n        }\n    }\n\n    /**\n     * Returns the level of logging to perform.\n     * See {@link #setLogLevel(String)}.\n     *\n     * @return\n     */\n    public Level getLogLevel() {\n        if (logLevel == null) {\n            setLogLevel(pullParam(\"-loglevel\"));\n        }\n        return logLevel;\n    }\n\n    /**\n     * Returns <code>true</code> if the options indicate that the user wants\n     * to see some help information.\n     *\n     * @return\n     */\n    public boolean isHelpRequired() {\n        return helpRequired;\n    }\n\n    public boolean isDbHelpRequired() {\n        return dbHelpRequired;\n    }\n\n    /**\n     * Returns the jar that we were loaded from\n     *\n     * @return\n     */\n    public static String getLoadedFromJar() {\n        String classpath = System.getProperty(\"java.class.path\");\n        return new StringTokenizer(classpath, File.pathSeparator).nextToken();\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasOrphans(boolean hasOrphans) {\n        this.hasOrphans = hasOrphans;\n    }\n\n    /**\n     * @see #setHasOrphans()\n     *\n     * @return\n     */\n    public boolean hasOrphans() {\n        return hasOrphans;\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasRoutines(boolean hasRoutines) {\n        this.hasRoutines = hasRoutines;\n    }\n\n    /**\n     * @see #setHasRoutines()\n     *\n     * @return\n     */\n    public boolean hasRoutines() {\n        return hasRoutines;\n    }\n\n    /**\n     * Returns the database properties to use.\n     * These should be determined by calling {@link #determineDbProperties(String)}.\n     * @return\n     * @throws InvalidConfigurationException\n     */\n    public Properties getDbProperties() throws InvalidConfigurationException {\n        if (dbProperties == null) {\n            try {\n                dbProperties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(exc);\n            }\n        }\n        return dbProperties;\n    }\n\n    /**\n     * Determines the database properties associated with the specified type.\n     * A call to {@link #setDbProperties(Properties)} is expected after determining\n     * the complete set of properties.\n     *\n     * @param type\n     * @return\n     * @throws IOException\n     * @throws InvalidConfigurationException if db properties are incorrectly formed\n     */\n    public Properties determineDbProperties(String type) throws IOException, InvalidConfigurationException {\n        ResourceBundle bundle = null;\n        try {\n            File propertiesFile = new File(type);\n            bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n            dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n        } catch (FileNotFoundException notFoundOnFilesystemWithoutExtension) {\n            try {\n                File propertiesFile = new File(type + \".properties\");\n                bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n                dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n            } catch (FileNotFoundException notFoundOnFilesystemWithExtensionTackedOn) {\n                try {\n                    bundle = ResourceBundle.getBundle(type);\n                    dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]\" + File.separator + type + \".properties\";\n                } catch (Exception notInJarWithoutPath) {\n                    try {\n                        String path = TableOrderer.class.getPackage().getName() + \".dbTypes.\" + type;\n                        path = path.replace('.', '/');\n                        bundle = ResourceBundle.getBundle(path);\n                        dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]/\" + path + \".properties\";\n                    } catch (Exception notInJar) {\n                        notInJar.printStackTrace();\n                        notFoundOnFilesystemWithExtensionTackedOn.printStackTrace();\n                        throw notFoundOnFilesystemWithoutExtension;\n                    }\n                }\n            }\n        }\n        Properties props = asProperties(bundle);\n        bundle = null;\n        // keep original thru recursion\n        String saveLoadedFrom = dbPropertiesLoadedFrom;\n        // bring in key/values pointed to by the include directive\n        // example: include.1=mysql::selectRowCountSql\n        for (int i = 1; true; ++i) {\n            String include = (String) props.remove(\"include.\" + i);\n            if (include == null)\n                break;\n            int separator = include.indexOf(\"::\");\n            if (separator == -1)\n                throw new InvalidConfigurationException(\"include directive in \" + dbPropertiesLoadedFrom + \" must have '::' between dbType and key\");\n            String refdType = include.substring(0, separator).trim();\n            String refdKey = include.substring(separator + 2).trim();\n            // recursively resolve the ref'd properties file and the ref'd key\n            Properties refdProps = determineDbProperties(refdType);\n            props.put(refdKey, refdProps.getProperty(refdKey));\n        }\n        // bring in base properties files pointed to by the extends directive\n        String baseDbType = (String) props.remove(\"extends\");\n        if (baseDbType != null) {\n            baseDbType = baseDbType.trim();\n            Properties baseProps = determineDbProperties(baseDbType);\n            // overlay our properties on top of the base's\n            baseProps.putAll(props);\n            props = baseProps;\n        }\n        // done with this level of recursion...restore original\n        dbPropertiesLoadedFrom = saveLoadedFrom;\n        // this won't be correct until the final recursion exits\n        dbProperties = props;\n        return props;\n    }\n\n    protected String getDbPropertiesLoadedFrom() throws IOException {\n        if (dbPropertiesLoadedFrom == null)\n            determineDbProperties(getDbType());\n        return dbPropertiesLoadedFrom;\n    }\n\n    public List<String> getRemainingParameters() {\n        try {\n            populate();\n        } catch (IllegalArgumentException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (IllegalAccessException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (InvocationTargetException exc) {\n            if (exc.getCause() instanceof InvalidConfigurationException)\n                throw (InvalidConfigurationException) exc.getCause();\n            throw new InvalidConfigurationException(exc.getCause());\n        } catch (IntrospectionException exc) {\n            throw new InvalidConfigurationException(exc);\n        }\n        return options;\n    }\n\n    /**\n     * Options that are specific to a type of database.  E.g. things like <code>host</code>,\n     * <code>port</code> or <code>db</code>, but <b>don't</b> have a setter in this class.\n     *\n     * @param dbSpecificOptions\n     */\n    public void setDbSpecificOptions(Map<String, String> dbSpecificOptions) {\n        this.dbSpecificOptions = dbSpecificOptions;\n        originalDbSpecificOptions = new HashMap<String, String>(dbSpecificOptions);\n    }\n\n    public Map<String, String> getDbSpecificOptions() {\n        if (dbSpecificOptions == null)\n            dbSpecificOptions = new HashMap<String, String>();\n        return dbSpecificOptions;\n    }\n\n    /**\n     * Returns a {@link Properties} populated with the contents of <code>bundle</code>\n     *\n     * @param bundle ResourceBundle\n     * @return Properties\n     */\n    public static Properties asProperties(ResourceBundle bundle) {\n        Properties props = new Properties();\n        Enumeration<String> iter = bundle.getKeys();\n        while (iter.hasMoreElements()) {\n            String key = iter.nextElement();\n            props.put(key, bundle.getObject(key));\n        }\n        return props;\n    }\n\n    /**\n     * 'Pull' the specified parameter from the collection of options. Returns\n     * null if the parameter isn't in the list and removes it if it is.\n     *\n     * @param paramId\n     * @return\n     */\n    private String pullParam(String paramId) {\n        return pullParam(paramId, false, false);\n    }\n\n    private String pullRequiredParam(String paramId) {\n        return pullParam(paramId, true, false);\n    }\n\n    /**\n     * @param paramId\n     * @param required\n     * @param dbTypeSpecific\n     * @return\n     * @throws MissingRequiredParameterException\n     */\n    private String pullParam(String paramId, boolean required, boolean dbTypeSpecific) throws MissingRequiredParameterException {\n        int paramIndex = options.indexOf(paramId);\n        if (paramIndex < 0) {\n            if (required)\n                throw new MissingRequiredParameterException(paramId, dbTypeSpecific);\n            return null;\n        }\n        options.remove(paramIndex);\n        String param = options.get(paramIndex).toString();\n        options.remove(paramIndex);\n        return param;\n    }\n\n    /**\n     * Thrown to indicate that a required parameter is missing\n     */\n    public static class MissingRequiredParameterException extends RuntimeException {\n\n        private static final long serialVersionUID = 1L;\n\n        private final boolean dbTypeSpecific;\n\n        public MissingRequiredParameterException(String paramId, boolean dbTypeSpecific) {\n            this(paramId, null, dbTypeSpecific);\n        }\n\n        public MissingRequiredParameterException(String paramId, String description, boolean dbTypeSpecific) {\n            super(\"Required parameter '\" + paramId + \"' \" + (description == null ? \"\" : \"(\" + description + \") \") + \"was not specified.\" + (dbTypeSpecific ? \"  It is required for this database type.\" : \"\"));\n            this.dbTypeSpecific = dbTypeSpecific;\n        }\n\n        public boolean isDbTypeSpecific() {\n            return dbTypeSpecific;\n        }\n    }\n\n    /**\n     * Allow an equal sign in args...like \"-o=foo.bar\". Useful for things like\n     * Ant and Maven.\n     *\n     * @param args\n     *            List\n     * @return List\n     */\n    protected List<String> fixupArgs(List<String> args) {\n        List<String> expandedArgs = new ArrayList<String>();\n        for (String arg : args) {\n            int indexOfEquals = arg.indexOf('=');\n            if (indexOfEquals != -1 && indexOfEquals - 1 != arg.indexOf(ESCAPED_EQUALS)) {\n                expandedArgs.add(arg.substring(0, indexOfEquals));\n                expandedArgs.add(arg.substring(indexOfEquals + 1));\n            } else {\n                expandedArgs.add(arg);\n            }\n        }\n        // some OSes/JVMs do filename expansion with runtime.exec() and some don't,\n        // so MultipleSchemaAnalyzer has to surround params with double quotes...\n        // strip them here for the OSes/JVMs that don't do anything with the params\n        List<String> unquotedArgs = new ArrayList<String>();\n        for (String arg : expandedArgs) {\n            if (// \".*\" becomes .*\n            arg.startsWith(\"\\\"\") && arg.endsWith(\"\\\"\"))\n                arg = arg.substring(1, arg.length() - 1);\n            unquotedArgs.add(arg);\n        }\n        return unquotedArgs;\n    }\n\n    /**\n     * Call all the getters to populate all the lazy initialized stuff.\n     *\n     * @throws InvocationTargetException\n     * @throws IllegalAccessException\n     * @throws IllegalArgumentException\n     * @throws IntrospectionException\n     */\n    private void populate() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IntrospectionException {\n        if (!populating) {\n            // prevent recursion\n            populating = true;\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                Method readMethod = props[i].getReadMethod();\n                if (readMethod != null)\n                    readMethod.invoke(this, (Object[]) null);\n            }\n            populating = false;\n        }\n    }\n\n    public static Set<String> getBuiltInDatabaseTypes(String loadedFromJar) {\n        Set<String> databaseTypes = new TreeSet<String>();\n        JarInputStream jar = null;\n        try {\n            jar = new JarInputStream(new FileInputStream(loadedFromJar));\n            JarEntry entry;\n            while ((entry = jar.getNextJarEntry()) != null) {\n                String entryName = entry.getName();\n                int dotPropsIndex = entryName.indexOf(\".properties\");\n                if (dotPropsIndex != -1)\n                    databaseTypes.add(entryName.substring(0, dotPropsIndex));\n            }\n        } catch (IOException exc) {\n        } finally {\n            if (jar != null) {\n                try {\n                    jar.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n        return databaseTypes;\n    }\n\n    protected void dumpUsage(String errorMessage, boolean detailedDb) {\n        if (errorMessage != null) {\n            System.out.flush();\n            System.err.println(\"*** \" + errorMessage + \" ***\");\n        } else {\n            System.out.println(\"SchemaSpy generates an HTML representation of a database schema's relationships.\");\n        }\n        System.err.flush();\n        System.out.println();\n        if (!detailedDb) {\n            System.out.println(\"Usage:\");\n            System.out.println(\" java -jar \" + getLoadedFromJar() + \" [options]\");\n            System.out.println(\"   -t databaseType       type of database - defaults to ora\");\n            System.out.println(\"                           use -dbhelp for a list of built-in types\");\n            System.out.println(\"   -u user               connect to the database with this user id\");\n            System.out.println(\"   -s schema             defaults to the specified user\");\n            System.out.println(\"   -p password           defaults to no password\");\n            System.out.println(\"   -o outputDirectory    directory to place the generated output in\");\n            System.out.println(\"   -dp pathToDrivers     optional - looks for JDBC drivers here before looking\");\n            System.out.println(\"                           in driverPath in [databaseType].properties.\");\n            System.out.println(\"Go to http://schemaspy.sourceforge.net for a complete list/description\");\n            System.out.println(\" of additional parameters.\");\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"Built-in database types and their required connection parameters:\");\n            for (String type : getBuiltInDatabaseTypes(getLoadedFromJar())) {\n                new DbSpecificConfig(type).dumpUsage();\n            }\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"You can use your own database types by specifying the filespec of a .properties file with -t.\");\n            System.out.println(\"Grab one out of \" + getLoadedFromJar() + \" and modify it to suit your needs.\");\n            System.out.println();\n        }\n        System.out.println(\"Sample usage using the default database type (implied -t ora):\");\n        System.out.println(\" java -jar schemaSpy.jar -db mydb -s myschema -u devuser -p password -o output\");\n        System.out.println();\n        System.out.flush();\n    }\n\n    /**\n     * Get the value of the specified parameter.\n     * Used for properties that are common to most db's, but aren't required.\n     *\n     * @param paramName\n     * @return\n     */\n    public String getParam(String paramName) {\n        try {\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                PropertyDescriptor prop = props[i];\n                if (prop.getName().equalsIgnoreCase(paramName)) {\n                    Object result = prop.getReadMethod().invoke(this, (Object[]) null);\n                    return result == null ? null : result.toString();\n                }\n            }\n        } catch (Exception failed) {\n            failed.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * Return all of the configuration options as a List of Strings, with\n     * each parameter and its value as a separate element.\n     *\n     * @return\n     * @throws IOException\n     */\n    public List<String> asList() throws IOException {\n        List<String> params = new ArrayList<String>();\n        if (originalDbSpecificOptions != null) {\n            for (String key : originalDbSpecificOptions.keySet()) {\n                String value = originalDbSpecificOptions.get(key);\n                if (!key.startsWith(\"-\"))\n                    key = \"-\" + key;\n                params.add(key);\n                params.add(value);\n            }\n        }\n        if (isEncodeCommentsEnabled())\n            params.add(\"-ahic\");\n        if (isEvaluateAllEnabled())\n            params.add(\"-all\");\n        if (!isHtmlGenerationEnabled())\n            params.add(\"-nohtml\");\n        if (!isImpliedConstraintsEnabled())\n            params.add(\"-noimplied\");\n        if (!isLogoEnabled())\n            params.add(\"-nologo\");\n        if (isMeterEnabled())\n            params.add(\"-meter\");\n        if (!isNumRowsEnabled())\n            params.add(\"-norows\");\n        if (!isViewsEnabled())\n            params.add(\"-noviews\");\n        if (isRankDirBugEnabled())\n            params.add(\"-rankdirbug\");\n        if (isRailsEnabled())\n            params.add(\"-rails\");\n        if (isSingleSignOn())\n            params.add(\"-sso\");\n        if (isSchemaDisabled())\n            params.add(\"-noschema\");\n        String value = getDriverPath();\n        if (value != null) {\n            params.add(\"-dp\");\n            params.add(value);\n        }\n        params.add(\"-css\");\n        params.add(getCss());\n        params.add(\"-charset\");\n        params.add(getCharset());\n        params.add(\"-font\");\n        params.add(getFont());\n        params.add(\"-fontsize\");\n        params.add(String.valueOf(getFontSize()));\n        params.add(\"-t\");\n        params.add(getDbType());\n        // query to set renderer correctly\n        isHighQuality();\n        // query to set renderer correctly\n        isLowQuality();\n        // instead of -hq and/or -lq\n        params.add(\"-renderer\");\n        params.add(getRenderer());\n        value = getDescription();\n        if (value != null) {\n            params.add(\"-desc\");\n            params.add(value);\n        }\n        value = getPassword();\n        if (value != null && !isPromptForPasswordEnabled()) {\n            // note that we don't pass -pfp since child processes\n            // won't have a console\n            params.add(\"-p\");\n            params.add(value);\n        }\n        value = getCatalog();\n        if (value != null) {\n            params.add(\"-cat\");\n            params.add(value);\n        }\n        value = getSchema();\n        if (value != null) {\n            params.add(\"-s\");\n            params.add(value);\n        }\n        value = getUser();\n        if (value != null) {\n            params.add(\"-u\");\n            params.add(value);\n        }\n        value = getConnectionPropertiesFile();\n        if (value != null) {\n            params.add(\"-connprops\");\n            params.add(value);\n        } else {\n            Properties props = getConnectionProperties();\n            if (!props.isEmpty()) {\n                params.add(\"-connprops\");\n                StringBuilder buf = new StringBuilder();\n                for (Entry<Object, Object> entry : props.entrySet()) {\n                    buf.append(entry.getKey());\n                    buf.append(ESCAPED_EQUALS);\n                    buf.append(entry.getValue());\n                    buf.append(';');\n                }\n                params.add(buf.toString());\n            }\n        }\n        value = getDb();\n        if (value != null) {\n            params.add(\"-db\");\n            params.add(value);\n        }\n        value = getHost();\n        if (value != null) {\n            params.add(\"-host\");\n            params.add(value);\n        }\n        if (getPort() != null) {\n            params.add(\"-port\");\n            params.add(getPort().toString());\n        }\n        value = getServer();\n        if (value != null) {\n            params.add(\"-server\");\n            params.add(value);\n        }\n        value = getMeta();\n        if (value != null) {\n            params.add(\"-meta\");\n            params.add(value);\n        }\n        if (getGraphvizDir() != null) {\n            params.add(\"-gv\");\n            params.add(getGraphvizDir().toString());\n        }\n        params.add(\"-loglevel\");\n        params.add(getLogLevel().toString().toLowerCase());\n        params.add(\"-sqlFormatter\");\n        params.add(getSqlFormatter().getClass().getName());\n        params.add(\"-i\");\n        params.add(getTableInclusions().toString());\n        params.add(\"-I\");\n        params.add(getTableExclusions().toString());\n        params.add(\"-X\");\n        params.add(getColumnExclusions().toString());\n        params.add(\"-x\");\n        params.add(getIndirectColumnExclusions().toString());\n        params.add(\"-dbthreads\");\n        params.add(String.valueOf(getMaxDbThreads()));\n        params.add(\"-maxdet\");\n        params.add(String.valueOf(getMaxDetailedTables()));\n        params.add(\"-o\");\n        params.add(getOutputDir().toString());\n        return params;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/ConfigTest17.java",
		"test_prompt": "// ConfigTest17.java\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Config}.\n* It contains ten unit test cases for the {@link Config#isHelpRequired()} method.\n*/\nclass ConfigTest17 {"
	},
	{
		"original_code": "// Config.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\n\n/**\n * Configuration of a SchemaSpy run\n *\n * @author John Currier\n */\npublic class Config {\n\n    private static Config instance;\n\n    private final List<String> options;\n\n    private Map<String, String> dbSpecificOptions;\n\n    private Map<String, String> originalDbSpecificOptions;\n\n    private boolean helpRequired;\n\n    private boolean dbHelpRequired;\n\n    private File outputDir;\n\n    private File graphvizDir;\n\n    private String dbType;\n\n    private String catalog;\n\n    private String schema;\n\n    private List<String> schemas;\n\n    private String user;\n\n    private Boolean singleSignOn;\n\n    private Boolean noSchema;\n\n    private String password;\n\n    private Boolean promptForPassword;\n\n    private String db;\n\n    private String host;\n\n    private Integer port;\n\n    private String server;\n\n    private String meta;\n\n    private Pattern tableInclusions;\n\n    private Pattern tableExclusions;\n\n    private Pattern columnExclusions;\n\n    private Pattern indirectColumnExclusions;\n\n    private String userConnectionPropertiesFile;\n\n    private Properties userConnectionProperties;\n\n    private Integer maxDbThreads;\n\n    private Integer maxDetailedTables;\n\n    private String driverPath;\n\n    private String css;\n\n    private String charset;\n\n    private String font;\n\n    private Integer fontSize;\n\n    private String description;\n\n    private Properties dbProperties;\n\n    private String dbPropertiesLoadedFrom;\n\n    private Level logLevel;\n\n    private SqlFormatter sqlFormatter;\n\n    private String sqlFormatterClass;\n\n    private Boolean generateHtml;\n\n    private Boolean includeImpliedConstraints;\n\n    private Boolean logoEnabled;\n\n    private Boolean rankDirBugEnabled;\n\n    private Boolean encodeCommentsEnabled;\n\n    private Boolean numRowsEnabled;\n\n    private Boolean viewsEnabled;\n\n    private Boolean meterEnabled;\n\n    private Boolean railsEnabled;\n\n    private Boolean evaluteAll;\n\n    private Boolean highQuality;\n\n    private Boolean lowQuality;\n\n    // used in conjunction with evaluateAll\n    private String schemaSpec;\n\n    private boolean hasOrphans = false;\n\n    private boolean hasRoutines = false;\n\n    private boolean populating = false;\n\n    private List<String> columnDetails;\n\n    public static final String DOT_CHARSET = \"UTF-8\";\n\n    private static final String ESCAPED_EQUALS = \"\\\\=\";\n\n    // match everything\n    private static final String DEFAULT_TABLE_INCLUSION = \".*\";\n\n    // match nothing\n    private static final String DEFAULT_TABLE_EXCLUSION = \"\";\n\n    // match nothing\n    private static final String DEFAULT_COLUMN_EXCLUSION = \"[^.]\";\n\n    /**\n     * Default constructor. Intended for when you want to inject properties\n     * independently (i.e. not from a command line interface).\n     */\n    public Config() {\n        if (instance == null)\n            setInstance(this);\n        options = new ArrayList<String>();\n    }\n\n    /**\n     * Construct a configuration from an array of options (e.g. from a command\n     * line interface).\n     *\n     * @param options\n     */\n    public Config(String[] argv) {\n        setInstance(this);\n        options = fixupArgs(Arrays.asList(argv));\n        helpRequired = options.remove(\"-?\") || options.remove(\"/?\") || options.remove(\"?\") || options.remove(\"-h\") || options.remove(\"-help\") || options.remove(\"--help\");\n        dbHelpRequired = options.remove(\"-dbHelp\") || options.remove(\"-dbhelp\");\n    }\n\n    public static Config getInstance() {\n        if (instance == null)\n            instance = new Config();\n        return instance;\n    }\n\n    /**\n     * Sets the global instance.\n     *\n     * Useful for things like selecting a specific configuration in a UI.\n     *\n     * @param config\n     */\n    public static void setInstance(Config config) {\n        instance = config;\n    }\n\n    public void setHtmlGenerationEnabled(boolean generateHtml) {\n        this.generateHtml = generateHtml;\n    }\n\n    public boolean isHtmlGenerationEnabled() {\n        if (generateHtml == null)\n            generateHtml = !options.remove(\"-nohtml\");\n        return generateHtml;\n    }\n\n    public void setImpliedConstraintsEnabled(boolean includeImpliedConstraints) {\n        this.includeImpliedConstraints = includeImpliedConstraints;\n    }\n\n    public boolean isImpliedConstraintsEnabled() {\n        if (includeImpliedConstraints == null)\n            includeImpliedConstraints = !options.remove(\"-noimplied\");\n        return includeImpliedConstraints;\n    }\n\n    public void setOutputDir(String outputDirName) {\n        if (outputDirName.endsWith(\"\\\"\"))\n            outputDirName = outputDirName.substring(0, outputDirName.length() - 1);\n        setOutputDir(new File(outputDirName));\n    }\n\n    public void setOutputDir(File outputDir) {\n        this.outputDir = outputDir;\n    }\n\n    public File getOutputDir() {\n        if (outputDir == null) {\n            setOutputDir(pullRequiredParam(\"-o\"));\n        }\n        return outputDir;\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(String graphvizDir) {\n        if (graphvizDir.endsWith(\"\\\"\"))\n            graphvizDir = graphvizDir.substring(0, graphvizDir.length() - 1);\n        setGraphvizDir(new File(graphvizDir));\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(File graphvizDir) {\n        this.graphvizDir = graphvizDir;\n    }\n\n    /**\n     * Return the path to Graphviz (used to find the dot executable to run to\n     * generate ER diagrams).<p/>\n     *\n     * Returns {@link #getDefaultGraphvizPath()} if a specific Graphviz path\n     * was not specified.\n     *\n     * @return\n     */\n    public File getGraphvizDir() {\n        if (graphvizDir == null) {\n            String gv = pullParam(\"-gv\");\n            if (gv != null) {\n                setGraphvizDir(gv);\n            } else {\n                // expect to find Graphviz's bin directory on the PATH\n            }\n        }\n        return graphvizDir;\n    }\n\n    /**\n     * Meta files are XML-based files that provide additional metadata\n     * about the schema being evaluated.<p>\n     * <code>meta</code> is either the name of an individual XML file or\n     * the directory that contains meta files.<p>\n     * If a directory is specified then it is expected to contain files\n     * matching the pattern <code>[schema].meta.xml</code>.\n     * For databases that don't have schema substitute database for schema.\n     * @param meta\n     */\n    public void setMeta(String meta) {\n        this.meta = meta;\n    }\n\n    public String getMeta() {\n        if (meta == null)\n            meta = pullParam(\"-meta\");\n        return meta;\n    }\n\n    public void setDbType(String dbType) {\n        this.dbType = dbType;\n    }\n\n    public String getDbType() {\n        if (dbType == null) {\n            dbType = pullParam(\"-t\");\n            if (dbType == null)\n                dbType = \"ora\";\n        }\n        return dbType;\n    }\n\n    public void setDb(String db) {\n        this.db = db;\n    }\n\n    public String getDb() {\n        if (db == null)\n            db = pullParam(\"-db\");\n        return db;\n    }\n\n    public void setCatalog(String catalog) {\n        this.catalog = catalog;\n    }\n\n    public String getCatalog() {\n        if (catalog == null)\n            catalog = pullParam(\"-cat\");\n        return catalog;\n    }\n\n    public void setSchema(String schema) {\n        this.schema = schema;\n    }\n\n    public String getSchema() {\n        if (schema == null)\n            schema = pullParam(\"-s\");\n        return schema;\n    }\n\n    /**\n     * Some databases types (e.g. older versions of Informix) don't really\n     * have the concept of a schema but still return true from\n     * {@link DatabaseMetaData#supportsSchemasInTableDefinitions()}.\n     * This option lets you ignore that and treat all the tables\n     * as if they were in one flat namespace.\n     */\n    public boolean isSchemaDisabled() {\n        if (noSchema == null)\n            noSchema = options.remove(\"-noschema\");\n        return noSchema;\n    }\n\n    public void setHost(String host) {\n        this.host = host;\n    }\n\n    public String getHost() {\n        if (host == null)\n            host = pullParam(\"-host\");\n        return host;\n    }\n\n    public void setPort(Integer port) {\n        this.port = port;\n    }\n\n    public Integer getPort() {\n        if (port == null)\n            try {\n                port = Integer.valueOf(pullParam(\"-port\"));\n            } catch (Exception notSpecified) {\n            }\n        return port;\n    }\n\n    public void setServer(String server) {\n        this.server = server;\n    }\n\n    public String getServer() {\n        if (server == null) {\n            server = pullParam(\"-server\");\n        }\n        return server;\n    }\n\n    public void setUser(String user) {\n        this.user = user;\n    }\n\n    /**\n     * User used to connect to the database.\n     * Required unless single sign-on is enabled\n     * (see {@link #setSingleSignOn(boolean)}).\n     * @return\n     */\n    public String getUser() {\n        if (user == null) {\n            if (!isSingleSignOn())\n                user = pullRequiredParam(\"-u\");\n            else\n                user = pullParam(\"-u\");\n        }\n        return user;\n    }\n\n    /**\n     * By default a \"user\" (as specified with -u) is required.\n     * This option allows disabling of that requirement for\n     * single sign-on environments.\n     *\n     * @param enabled defaults to <code>false</code>\n     */\n    public void setSingleSignOn(boolean enabled) {\n        singleSignOn = enabled;\n    }\n\n    /**\n     * @see #setSingleSignOn(boolean)\n     */\n    public boolean isSingleSignOn() {\n        if (singleSignOn == null)\n            singleSignOn = options.remove(\"-sso\");\n        return singleSignOn;\n    }\n\n    /**\n     * Set the password used to connect to the database.\n     * @param password\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * @see #setPassword(String)\n     * @return\n     */\n    public String getPassword() {\n        if (password == null)\n            password = pullParam(\"-p\");\n        if (password == null && isPromptForPasswordEnabled())\n            password = new String(PasswordReader.getInstance().readPassword(\"Password: \"));\n        if (password == null) {\n            // if -pfp is enabled when analyzing multiple schemas then\n            // we don't want to send the password on the command line,\n            // so see if it was passed in the environment (not ideal, but safer)\n            password = System.getenv(\"schemaspy.pw\");\n        }\n        return password;\n    }\n\n    /**\n     * Set to <code>true</code> to prompt for the password\n     * @param promptForPassword\n     */\n    public void setPromptForPasswordEnabled(boolean promptForPassword) {\n        this.promptForPassword = promptForPassword;\n    }\n\n    /**\n     * @see #setPromptForPasswordEnabled(boolean)\n     * @return\n     */\n    public boolean isPromptForPasswordEnabled() {\n        if (promptForPassword == null) {\n            promptForPassword = options.remove(\"-pfp\");\n        }\n        return promptForPassword;\n    }\n\n    public void setMaxDetailedTabled(int maxDetailedTables) {\n        this.maxDetailedTables = new Integer(maxDetailedTables);\n    }\n\n    public int getMaxDetailedTables() {\n        if (maxDetailedTables == null) {\n            // default\n            int max = 300;\n            try {\n                max = Integer.parseInt(pullParam(\"-maxdet\"));\n            } catch (Exception notSpecified) {\n            }\n            maxDetailedTables = new Integer(max);\n        }\n        return maxDetailedTables.intValue();\n    }\n\n    public String getConnectionPropertiesFile() {\n        return userConnectionPropertiesFile;\n    }\n\n    /**\n     * Properties from this file (in key=value pair format) are passed to the\n     * database connection.<br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.\n     * @param propertiesFilename\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public void setConnectionPropertiesFile(String propertiesFilename) throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null)\n            userConnectionProperties = new Properties();\n        userConnectionProperties.load(new FileInputStream(propertiesFilename));\n        userConnectionPropertiesFile = propertiesFilename;\n    }\n\n    /**\n     * Returns a {@link Properties} populated either from the properties file specified\n     * by {@link #setConnectionPropertiesFile(String)}, the properties specified by\n     * {@link #setConnectionProperties(String)} or not populated.\n     * @return\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public Properties getConnectionProperties() throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null) {\n            String props = pullParam(\"-connprops\");\n            if (props != null) {\n                if (props.indexOf(ESCAPED_EQUALS) != -1) {\n                    setConnectionProperties(props);\n                } else {\n                    setConnectionPropertiesFile(props);\n                }\n            } else {\n                userConnectionProperties = new Properties();\n            }\n        }\n        return userConnectionProperties;\n    }\n\n    /**\n     * Specifies connection properties to use in the format:\n     * <code>key1\\=value1;key2\\=value2</code><br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.<p>\n     * This is an alternative form of passing connection properties than by file\n     * (see {@link #setConnectionPropertiesFile(String)})\n     *\n     * @param properties\n     */\n    public void setConnectionProperties(String properties) {\n        userConnectionProperties = new Properties();\n        StringTokenizer tokenizer = new StringTokenizer(properties, \";\");\n        while (tokenizer.hasMoreElements()) {\n            String pair = tokenizer.nextToken();\n            int index = pair.indexOf(ESCAPED_EQUALS);\n            if (index != -1) {\n                String key = pair.substring(0, index);\n                String value = pair.substring(index + ESCAPED_EQUALS.length());\n                userConnectionProperties.put(key, value);\n            }\n        }\n    }\n\n    public void setDriverPath(String driverPath) {\n        this.driverPath = driverPath;\n    }\n\n    public String getDriverPath() {\n        if (driverPath == null)\n            driverPath = pullParam(\"-dp\");\n        // was previously -cp:\n        if (driverPath == null)\n            driverPath = pullParam(\"-cp\");\n        return driverPath;\n    }\n\n    /**\n     * The filename of the cascading style sheet to use.\n     * Note that this file is parsed and used to determine characteristics\n     * of the generated diagrams, so it must contain specific settings that\n     * are documented within schemaSpy.css.<p>\n     *\n     * Defaults to <code>\"schemaSpy.css\"</code>.\n     *\n     * @param css\n     */\n    public void setCss(String css) {\n        this.css = css;\n    }\n\n    public String getCss() {\n        if (css == null) {\n            css = pullParam(\"-css\");\n            if (css == null)\n                css = \"schemaSpy.css\";\n        }\n        return css;\n    }\n\n    /**\n     * The font to use within diagrams.  Modify the .css to specify HTML fonts.\n     *\n     * @param font\n     */\n    public void setFont(String font) {\n        this.font = font;\n    }\n\n    /**\n     * @see #setFont(String)\n     */\n    public String getFont() {\n        if (font == null) {\n            font = pullParam(\"-font\");\n            if (font == null)\n                font = \"Helvetica\";\n        }\n        return font;\n    }\n\n    /**\n     * The font size to use within diagrams.  This is the size of the font used for\n     * 'large' (e.g. not 'compact') diagrams.<p>\n     *\n     * Modify the .css to specify HTML font sizes.<p>\n     *\n     * Defaults to 11.\n     *\n     * @param fontSize\n     */\n    public void setFontSize(int fontSize) {\n        this.fontSize = new Integer(fontSize);\n    }\n\n    /**\n     * @see #setFontSize(int)\n     * @return\n     */\n    public int getFontSize() {\n        if (fontSize == null) {\n            // default\n            int size = 11;\n            try {\n                size = Integer.parseInt(pullParam(\"-fontsize\"));\n            } catch (Exception notSpecified) {\n            }\n            fontSize = new Integer(size);\n        }\n        return fontSize.intValue();\n    }\n\n    /**\n     * The character set to use within HTML pages (defaults to <code>\"ISO-8859-1\"</code>).\n     *\n     * @param charset\n     */\n    public void setCharset(String charset) {\n        this.charset = charset;\n    }\n\n    /**\n     * @see #setCharset(String)\n     */\n    public String getCharset() {\n        if (charset == null) {\n            charset = pullParam(\"-charset\");\n            if (charset == null)\n                charset = \"ISO-8859-1\";\n        }\n        return charset;\n    }\n\n    /**\n     * Description of schema that gets display on main pages.\n     *\n     * @param description\n     */\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    /**\n     * @see #setDescription(String)\n     */\n    public String getDescription() {\n        if (description == null)\n            description = pullParam(\"-desc\");\n        return description;\n    }\n\n    /**\n     * Maximum number of threads to use when querying database metadata information.\n     *\n     * @param maxDbThreads\n     */\n    public void setMaxDbThreads(int maxDbThreads) {\n        this.maxDbThreads = new Integer(maxDbThreads);\n    }\n\n    /**\n     * @see #setMaxDbThreads(int)\n     * @throws InvalidConfigurationException if unable to load properties\n     */\n    public int getMaxDbThreads() throws InvalidConfigurationException {\n        if (maxDbThreads == null) {\n            Properties properties;\n            try {\n                properties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(\"Failed to load properties for \" + getDbType() + \": \" + exc).setParamName(\"-type\");\n            }\n            // not scientifically derived\n            final int defaultMax = 15;\n            int max = defaultMax;\n            String threads = properties.getProperty(\"dbThreads\");\n            if (threads == null)\n                threads = properties.getProperty(\"dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            threads = pullParam(\"-dbThreads\");\n            if (threads == null)\n                threads = pullParam(\"-dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            if (max < 0)\n                max = defaultMax;\n            else if (max == 0)\n                max = 1;\n            maxDbThreads = new Integer(max);\n        }\n        return maxDbThreads.intValue();\n    }\n\n    public boolean isLogoEnabled() {\n        if (logoEnabled == null)\n            logoEnabled = !options.remove(\"-nologo\");\n        return logoEnabled;\n    }\n\n    /**\n     * Don't use this unless absolutely necessary as it screws up the layout\n     *\n     * @param enabled\n     */\n    public void setRankDirBugEnabled(boolean enabled) {\n        rankDirBugEnabled = enabled;\n    }\n\n    /**\n     * @see #setRankDirBugEnabled(boolean)\n     */\n    public boolean isRankDirBugEnabled() {\n        if (rankDirBugEnabled == null)\n            rankDirBugEnabled = options.remove(\"-rankdirbug\");\n        return rankDirBugEnabled;\n    }\n\n    /**\n     * Look for Ruby on Rails-based naming conventions in\n     * relationships between logical foreign keys and primary keys.<p>\n     *\n     * Basically all tables have a primary key named <code>ID</code>.\n     * All tables are named plural names.\n     * The columns that logically reference that <code>ID</code> are the singular\n     * form of the table name suffixed with <code>_ID</code>.<p>\n     *\n     * @param enabled\n     */\n    public void setRailsEnabled(boolean enabled) {\n        railsEnabled = enabled;\n    }\n\n    /**\n     * @see #setRailsEnabled(boolean)\n     *\n     * @return\n     */\n    public boolean isRailsEnabled() {\n        if (railsEnabled == null)\n            railsEnabled = options.remove(\"-rails\");\n        return railsEnabled;\n    }\n\n    /**\n     * Allow Html In Comments - encode them unless otherwise specified\n     */\n    public void setEncodeCommentsEnabled(boolean enabled) {\n        encodeCommentsEnabled = enabled;\n    }\n\n    /**\n     * @see #setEncodeCommentsEnabled(boolean)\n     */\n    public boolean isEncodeCommentsEnabled() {\n        if (encodeCommentsEnabled == null)\n            encodeCommentsEnabled = !options.remove(\"-ahic\");\n        return encodeCommentsEnabled;\n    }\n\n    /**\n     * If enabled we'll attempt to query/render the number of rows that\n     * each table contains.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setNumRowsEnabled(boolean enabled) {\n        numRowsEnabled = enabled;\n    }\n\n    /**\n     * @see #setNumRowsEnabled(boolean)\n     * @return\n     */\n    public boolean isNumRowsEnabled() {\n        if (numRowsEnabled == null)\n            numRowsEnabled = !options.remove(\"-norows\");\n        return numRowsEnabled;\n    }\n\n    /**\n     * If enabled we'll include views in the analysis.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setViewsEnabled(boolean enabled) {\n        viewsEnabled = enabled;\n    }\n\n    /**\n     * @see #setViewsEnabled(boolean)\n     * @return\n     */\n    public boolean isViewsEnabled() {\n        if (viewsEnabled == null)\n            viewsEnabled = !options.remove(\"-noviews\");\n        return viewsEnabled;\n    }\n\n    /**\n     * Returns <code>true</code> if metering should be embedded in\n     * the generated pages.<p/>\n     * Defaults to <code>false</code> (disabled).\n     * @return\n     */\n    public boolean isMeterEnabled() {\n        if (meterEnabled == null)\n            meterEnabled = options.remove(\"-meter\");\n        return meterEnabled;\n    }\n\n    /**\n     * Set the columns to exclude from all relationship diagrams.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setColumnExclusions(String columnExclusions) {\n        this.columnExclusions = Pattern.compile(columnExclusions);\n    }\n\n    /**\n     * See {@link #setColumnExclusions(String)}\n     * @return\n     */\n    public Pattern getColumnExclusions() {\n        if (columnExclusions == null) {\n            String strExclusions = pullParam(\"-X\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.columnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            columnExclusions = Pattern.compile(strExclusions);\n        }\n        return columnExclusions;\n    }\n\n    /**\n     * Set the columns to exclude from relationship diagrams where the specified\n     * columns aren't directly referenced by the focal table.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setIndirectColumnExclusions(String fullColumnExclusions) {\n        indirectColumnExclusions = Pattern.compile(fullColumnExclusions);\n    }\n\n    /**\n     * @see #setIndirectColumnExclusions(String)\n     *\n     * @return\n     */\n    public Pattern getIndirectColumnExclusions() {\n        if (indirectColumnExclusions == null) {\n            String strExclusions = pullParam(\"-x\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.indirectColumnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            indirectColumnExclusions = Pattern.compile(strExclusions);\n        }\n        return indirectColumnExclusions;\n    }\n\n    /**\n     * Set the tables to include as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableInclusions(String tableInclusions) {\n        this.tableInclusions = Pattern.compile(tableInclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to include in the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableInclusions() {\n        if (tableInclusions == null) {\n            String strInclusions = pullParam(\"-i\");\n            if (strInclusions == null)\n                strInclusions = System.getenv(\"schemaspy.tableInclusions\");\n            if (strInclusions == null)\n                strInclusions = DEFAULT_TABLE_INCLUSION;\n            try {\n                tableInclusions = Pattern.compile(strInclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-i\");\n            }\n        }\n        return tableInclusions;\n    }\n\n    /**\n     * Set the tables to exclude as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableExclusions(String tableExclusions) {\n        this.tableExclusions = Pattern.compile(tableExclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to exclude from the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableExclusions() {\n        if (tableExclusions == null) {\n            String strExclusions = pullParam(\"-I\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.tableExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_TABLE_EXCLUSION;\n            try {\n                tableExclusions = Pattern.compile(strExclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-I\");\n            }\n        }\n        return tableExclusions;\n    }\n\n    /**\n     * @return\n     */\n    public List<String> getSchemas() {\n        if (schemas == null) {\n            String tmp = pullParam(\"-schemas\");\n            if (tmp == null)\n                tmp = pullParam(\"-schemata\");\n            if (tmp != null) {\n                schemas = new ArrayList<String>();\n                for (String name : tmp.split(\"[\\\\s,'\\\"]\")) {\n                    if (name.length() > 0)\n                        schemas.add(name);\n                }\n                if (schemas.isEmpty())\n                    schemas = null;\n            }\n        }\n        return schemas;\n    }\n\n    /**\n     * Set the name of the {@link SqlFormatter SQL formatter} class to use to\n     * format SQL into HTML.<p/>\n     * The implementation of the class must be made available to the class\n     * loader, typically by specifying the path to its jar with <em>-dp</em>\n     * ({@link #setDriverPath(String)}).\n     */\n    public void setSqlFormatter(String formatterClassName) {\n        sqlFormatterClass = formatterClassName;\n        sqlFormatter = null;\n    }\n\n    /**\n     * Set the {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.\n     */\n    public void setSqlFormatter(SqlFormatter sqlFormatter) {\n        this.sqlFormatter = sqlFormatter;\n        if (sqlFormatter != null)\n            sqlFormatterClass = sqlFormatter.getClass().getName();\n    }\n\n    /**\n     * Returns an implementation of {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.  The default implementation is {@link DefaultSqlFormatter}.\n     *\n     * @return\n     * @throws InvalidConfigurationException if unable to instantiate an instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SqlFormatter getSqlFormatter() throws InvalidConfigurationException {\n        if (sqlFormatter == null) {\n            if (sqlFormatterClass == null) {\n                sqlFormatterClass = pullParam(\"-sqlFormatter\");\n                if (sqlFormatterClass == null)\n                    sqlFormatterClass = DefaultSqlFormatter.class.getName();\n            }\n            try {\n                Class<SqlFormatter> clazz = (Class<SqlFormatter>) Class.forName(sqlFormatterClass);\n                sqlFormatter = clazz.newInstance();\n            } catch (Exception exc) {\n                throw new InvalidConfigurationException(\"Failed to initialize instance of SQL formatter: \", exc).setParamName(\"-sqlFormatter\");\n            }\n        }\n        return sqlFormatter;\n    }\n\n    /**\n     * Set the details to show on the columns page, where \"details\" are\n     * comma and/or space separated.\n     *\n     * Valid values:\n     * <ul>\n     * <li>id</li>\n     * <li>table</li>\n     * <li>column</li>\n     * <li>type</li>\n     * <li>size</li>\n     * <li>nulls</li>\n     * <li>auto</li>\n     * <li>default</li>\n     * <li>children</li>\n     * <li>parents</li>\n     * </ul>\n     *\n     * The default details are <code>\"table column type size nulls auto default\"</code>.\n     * Note that \"column\" is the initially displayed detail and must be included.\n     *\n     * @param columnDetails\n     */\n    public void setColumnDetails(String columnDetails) {\n        this.columnDetails = new ArrayList<String>();\n        if (columnDetails == null || columnDetails.length() == 0) {\n            // not specified, so use defaults\n            columnDetails = \"id table column type size nulls auto default\";\n        }\n        for (String detail : columnDetails.split(\"[\\\\s,'\\\"]\")) {\n            if (detail.length() > 0) {\n                this.columnDetails.add(detail.toLowerCase());\n            }\n        }\n        if (!this.columnDetails.contains(\"column\"))\n            throw new InvalidConfigurationException(\"'column' is a required column detail\");\n    }\n\n    public void setColumnDetails(List<String> columnDetails) {\n        String details = columnDetails == null ? \"[]\" : columnDetails.toString();\n        setColumnDetails(details.substring(1, details.length() - 1));\n    }\n\n    public List<String> getColumnDetails() {\n        if (columnDetails == null) {\n            setColumnDetails(pullParam(\"-columndetails\"));\n        }\n        return columnDetails;\n    }\n\n    public void setEvaluateAllEnabled(boolean enabled) {\n        evaluteAll = enabled;\n    }\n\n    public boolean isEvaluateAllEnabled() {\n        if (evaluteAll == null)\n            evaluteAll = options.remove(\"-all\");\n        return evaluteAll;\n    }\n\n    /**\n     * Returns true if we're evaluating a bunch of schemas in one go and\n     * at this point we're evaluating a specific schema.\n     *\n     * @return boolean\n     */\n    public boolean isOneOfMultipleSchemas() {\n        // set by MultipleSchemaAnalyzer\n        return Boolean.getBoolean(\"oneofmultipleschemas\");\n    }\n\n    /**\n     * When -all (evaluateAll) is specified then this is the regular\n     * expression that determines which schemas to evaluate.\n     *\n     * @param schemaSpec\n     */\n    public void setSchemaSpec(String schemaSpec) {\n        this.schemaSpec = schemaSpec;\n    }\n\n    public String getSchemaSpec() {\n        if (schemaSpec == null)\n            schemaSpec = pullParam(\"-schemaSpec\");\n        return schemaSpec;\n    }\n\n    /**\n     * Set the renderer to use for the -Tpng[:renderer[:formatter]] dot option as specified\n     * at <a href='http://www.graphviz.org/doc/info/command.html'>\n     * http://www.graphviz.org/doc/info/command.html</a>.<p>\n     * Note that the leading \":\" is required while :formatter is optional.<p>\n     * The default renderer is typically GD.<p>\n     * Note that using {@link #setHighQuality(boolean)} is the preferred approach\n     * over using this method.\n     */\n    public void setRenderer(String renderer) {\n        Dot.getInstance().setRenderer(renderer);\n    }\n\n    /**\n     * @see #setRenderer(String)\n     * @return\n     */\n    public String getRenderer() {\n        String renderer = pullParam(\"-renderer\");\n        if (renderer != null)\n            setRenderer(renderer);\n        return Dot.getInstance().getRenderer();\n    }\n\n    /**\n     * If <code>false</code> then generate output of \"lower quality\"\n     * than the default.\n     * Note that the default is intended to be \"higher quality\",\n     * but various installations of Graphviz may have have different abilities.\n     * That is, some might not have the \"lower quality\" libraries and others might\n     * not have the \"higher quality\" libraries.<p>\n     * Higher quality output takes longer to generate and results in significantly\n     * larger image files (which take longer to download / display), but it generally\n     * looks better.\n     */\n    public void setHighQuality(boolean highQuality) {\n        this.highQuality = highQuality;\n        lowQuality = !highQuality;\n        Dot.getInstance().setHighQuality(highQuality);\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isHighQuality() {\n        if (highQuality == null) {\n            highQuality = options.remove(\"-hq\");\n            if (highQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(highQuality);\n            }\n        }\n        highQuality = Dot.getInstance().isHighQuality();\n        return highQuality;\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isLowQuality() {\n        if (lowQuality == null) {\n            lowQuality = options.remove(\"-lq\");\n            if (lowQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(!lowQuality);\n            }\n        }\n        lowQuality = !Dot.getInstance().isHighQuality();\n        return lowQuality;\n    }\n\n    /**\n     * Set the level of logging to perform.<p/>\n     * The levels in descending order are:\n     * <ul>\n     *  <li><code>severe</code> (highest - least detail)\n     *  <li><code>warning</code> (default)\n     *  <li><code>info</code>\n     *  <li><code>config</code>\n     *  <li><code>fine</code>\n     *  <li><code>finer</code>\n     *  <li><code>finest</code>  (lowest - most detail)\n     * </ul>\n     *\n     * @param logLevel\n     */\n    public void setLogLevel(String logLevel) {\n        if (logLevel == null) {\n            this.logLevel = Level.WARNING;\n            return;\n        }\n        Map<String, Level> levels = new LinkedHashMap<String, Level>();\n        levels.put(\"severe\", Level.SEVERE);\n        levels.put(\"warning\", Level.WARNING);\n        levels.put(\"info\", Level.INFO);\n        levels.put(\"config\", Level.CONFIG);\n        levels.put(\"fine\", Level.FINE);\n        levels.put(\"finer\", Level.FINER);\n        levels.put(\"finest\", Level.FINEST);\n        this.logLevel = levels.get(logLevel.toLowerCase());\n        if (this.logLevel == null) {\n            throw new InvalidConfigurationException(\"Invalid logLevel: '\" + logLevel + \"'. Must be one of: \" + levels.keySet());\n        }\n    }\n\n    /**\n     * Returns the level of logging to perform.\n     * See {@link #setLogLevel(String)}.\n     *\n     * @return\n     */\n    public Level getLogLevel() {\n        if (logLevel == null) {\n            setLogLevel(pullParam(\"-loglevel\"));\n        }\n        return logLevel;\n    }\n\n    /**\n     * Returns <code>true</code> if the options indicate that the user wants\n     * to see some help information.\n     *\n     * @return\n     */\n    public boolean isHelpRequired() {\n        return helpRequired;\n    }\n\n    public boolean isDbHelpRequired() {\n        return dbHelpRequired;\n    }\n\n    /**\n     * Returns the jar that we were loaded from\n     *\n     * @return\n     */\n    public static String getLoadedFromJar() {\n        String classpath = System.getProperty(\"java.class.path\");\n        return new StringTokenizer(classpath, File.pathSeparator).nextToken();\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasOrphans(boolean hasOrphans) {\n        this.hasOrphans = hasOrphans;\n    }\n\n    /**\n     * @see #setHasOrphans()\n     *\n     * @return\n     */\n    public boolean hasOrphans() {\n        return hasOrphans;\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasRoutines(boolean hasRoutines) {\n        this.hasRoutines = hasRoutines;\n    }\n\n    /**\n     * @see #setHasRoutines()\n     *\n     * @return\n     */\n    public boolean hasRoutines() {\n        return hasRoutines;\n    }\n\n    /**\n     * Returns the database properties to use.\n     * These should be determined by calling {@link #determineDbProperties(String)}.\n     * @return\n     * @throws InvalidConfigurationException\n     */\n    public Properties getDbProperties() throws InvalidConfigurationException {\n        if (dbProperties == null) {\n            try {\n                dbProperties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(exc);\n            }\n        }\n        return dbProperties;\n    }\n\n    /**\n     * Determines the database properties associated with the specified type.\n     * A call to {@link #setDbProperties(Properties)} is expected after determining\n     * the complete set of properties.\n     *\n     * @param type\n     * @return\n     * @throws IOException\n     * @throws InvalidConfigurationException if db properties are incorrectly formed\n     */\n    public Properties determineDbProperties(String type) throws IOException, InvalidConfigurationException {\n        ResourceBundle bundle = null;\n        try {\n            File propertiesFile = new File(type);\n            bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n            dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n        } catch (FileNotFoundException notFoundOnFilesystemWithoutExtension) {\n            try {\n                File propertiesFile = new File(type + \".properties\");\n                bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n                dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n            } catch (FileNotFoundException notFoundOnFilesystemWithExtensionTackedOn) {\n                try {\n                    bundle = ResourceBundle.getBundle(type);\n                    dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]\" + File.separator + type + \".properties\";\n                } catch (Exception notInJarWithoutPath) {\n                    try {\n                        String path = TableOrderer.class.getPackage().getName() + \".dbTypes.\" + type;\n                        path = path.replace('.', '/');\n                        bundle = ResourceBundle.getBundle(path);\n                        dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]/\" + path + \".properties\";\n                    } catch (Exception notInJar) {\n                        notInJar.printStackTrace();\n                        notFoundOnFilesystemWithExtensionTackedOn.printStackTrace();\n                        throw notFoundOnFilesystemWithoutExtension;\n                    }\n                }\n            }\n        }\n        Properties props = asProperties(bundle);\n        bundle = null;\n        // keep original thru recursion\n        String saveLoadedFrom = dbPropertiesLoadedFrom;\n        // bring in key/values pointed to by the include directive\n        // example: include.1=mysql::selectRowCountSql\n        for (int i = 1; true; ++i) {\n            String include = (String) props.remove(\"include.\" + i);\n            if (include == null)\n                break;\n            int separator = include.indexOf(\"::\");\n            if (separator == -1)\n                throw new InvalidConfigurationException(\"include directive in \" + dbPropertiesLoadedFrom + \" must have '::' between dbType and key\");\n            String refdType = include.substring(0, separator).trim();\n            String refdKey = include.substring(separator + 2).trim();\n            // recursively resolve the ref'd properties file and the ref'd key\n            Properties refdProps = determineDbProperties(refdType);\n            props.put(refdKey, refdProps.getProperty(refdKey));\n        }\n        // bring in base properties files pointed to by the extends directive\n        String baseDbType = (String) props.remove(\"extends\");\n        if (baseDbType != null) {\n            baseDbType = baseDbType.trim();\n            Properties baseProps = determineDbProperties(baseDbType);\n            // overlay our properties on top of the base's\n            baseProps.putAll(props);\n            props = baseProps;\n        }\n        // done with this level of recursion...restore original\n        dbPropertiesLoadedFrom = saveLoadedFrom;\n        // this won't be correct until the final recursion exits\n        dbProperties = props;\n        return props;\n    }\n\n    protected String getDbPropertiesLoadedFrom() throws IOException {\n        if (dbPropertiesLoadedFrom == null)\n            determineDbProperties(getDbType());\n        return dbPropertiesLoadedFrom;\n    }\n\n    public List<String> getRemainingParameters() {\n        try {\n            populate();\n        } catch (IllegalArgumentException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (IllegalAccessException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (InvocationTargetException exc) {\n            if (exc.getCause() instanceof InvalidConfigurationException)\n                throw (InvalidConfigurationException) exc.getCause();\n            throw new InvalidConfigurationException(exc.getCause());\n        } catch (IntrospectionException exc) {\n            throw new InvalidConfigurationException(exc);\n        }\n        return options;\n    }\n\n    /**\n     * Options that are specific to a type of database.  E.g. things like <code>host</code>,\n     * <code>port</code> or <code>db</code>, but <b>don't</b> have a setter in this class.\n     *\n     * @param dbSpecificOptions\n     */\n    public void setDbSpecificOptions(Map<String, String> dbSpecificOptions) {\n        this.dbSpecificOptions = dbSpecificOptions;\n        originalDbSpecificOptions = new HashMap<String, String>(dbSpecificOptions);\n    }\n\n    public Map<String, String> getDbSpecificOptions() {\n        if (dbSpecificOptions == null)\n            dbSpecificOptions = new HashMap<String, String>();\n        return dbSpecificOptions;\n    }\n\n    /**\n     * Returns a {@link Properties} populated with the contents of <code>bundle</code>\n     *\n     * @param bundle ResourceBundle\n     * @return Properties\n     */\n    public static Properties asProperties(ResourceBundle bundle) {\n        Properties props = new Properties();\n        Enumeration<String> iter = bundle.getKeys();\n        while (iter.hasMoreElements()) {\n            String key = iter.nextElement();\n            props.put(key, bundle.getObject(key));\n        }\n        return props;\n    }\n\n    /**\n     * 'Pull' the specified parameter from the collection of options. Returns\n     * null if the parameter isn't in the list and removes it if it is.\n     *\n     * @param paramId\n     * @return\n     */\n    private String pullParam(String paramId) {\n        return pullParam(paramId, false, false);\n    }\n\n    private String pullRequiredParam(String paramId) {\n        return pullParam(paramId, true, false);\n    }\n\n    /**\n     * @param paramId\n     * @param required\n     * @param dbTypeSpecific\n     * @return\n     * @throws MissingRequiredParameterException\n     */\n    private String pullParam(String paramId, boolean required, boolean dbTypeSpecific) throws MissingRequiredParameterException {\n        int paramIndex = options.indexOf(paramId);\n        if (paramIndex < 0) {\n            if (required)\n                throw new MissingRequiredParameterException(paramId, dbTypeSpecific);\n            return null;\n        }\n        options.remove(paramIndex);\n        String param = options.get(paramIndex).toString();\n        options.remove(paramIndex);\n        return param;\n    }\n\n    /**\n     * Thrown to indicate that a required parameter is missing\n     */\n    public static class MissingRequiredParameterException extends RuntimeException {\n\n        private static final long serialVersionUID = 1L;\n\n        private final boolean dbTypeSpecific;\n\n        public MissingRequiredParameterException(String paramId, boolean dbTypeSpecific) {\n            this(paramId, null, dbTypeSpecific);\n        }\n\n        public MissingRequiredParameterException(String paramId, String description, boolean dbTypeSpecific) {\n            super(\"Required parameter '\" + paramId + \"' \" + (description == null ? \"\" : \"(\" + description + \") \") + \"was not specified.\" + (dbTypeSpecific ? \"  It is required for this database type.\" : \"\"));\n            this.dbTypeSpecific = dbTypeSpecific;\n        }\n\n        public boolean isDbTypeSpecific() {\n            return dbTypeSpecific;\n        }\n    }\n\n    /**\n     * Allow an equal sign in args...like \"-o=foo.bar\". Useful for things like\n     * Ant and Maven.\n     *\n     * @param args\n     *            List\n     * @return List\n     */\n    protected List<String> fixupArgs(List<String> args) {\n        List<String> expandedArgs = new ArrayList<String>();\n        for (String arg : args) {\n            int indexOfEquals = arg.indexOf('=');\n            if (indexOfEquals != -1 && indexOfEquals - 1 != arg.indexOf(ESCAPED_EQUALS)) {\n                expandedArgs.add(arg.substring(0, indexOfEquals));\n                expandedArgs.add(arg.substring(indexOfEquals + 1));\n            } else {\n                expandedArgs.add(arg);\n            }\n        }\n        // some OSes/JVMs do filename expansion with runtime.exec() and some don't,\n        // so MultipleSchemaAnalyzer has to surround params with double quotes...\n        // strip them here for the OSes/JVMs that don't do anything with the params\n        List<String> unquotedArgs = new ArrayList<String>();\n        for (String arg : expandedArgs) {\n            if (// \".*\" becomes .*\n            arg.startsWith(\"\\\"\") && arg.endsWith(\"\\\"\"))\n                arg = arg.substring(1, arg.length() - 1);\n            unquotedArgs.add(arg);\n        }\n        return unquotedArgs;\n    }\n\n    /**\n     * Call all the getters to populate all the lazy initialized stuff.\n     *\n     * @throws InvocationTargetException\n     * @throws IllegalAccessException\n     * @throws IllegalArgumentException\n     * @throws IntrospectionException\n     */\n    private void populate() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IntrospectionException {\n        if (!populating) {\n            // prevent recursion\n            populating = true;\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                Method readMethod = props[i].getReadMethod();\n                if (readMethod != null)\n                    readMethod.invoke(this, (Object[]) null);\n            }\n            populating = false;\n        }\n    }\n\n    public static Set<String> getBuiltInDatabaseTypes(String loadedFromJar) {\n        Set<String> databaseTypes = new TreeSet<String>();\n        JarInputStream jar = null;\n        try {\n            jar = new JarInputStream(new FileInputStream(loadedFromJar));\n            JarEntry entry;\n            while ((entry = jar.getNextJarEntry()) != null) {\n                String entryName = entry.getName();\n                int dotPropsIndex = entryName.indexOf(\".properties\");\n                if (dotPropsIndex != -1)\n                    databaseTypes.add(entryName.substring(0, dotPropsIndex));\n            }\n        } catch (IOException exc) {\n        } finally {\n            if (jar != null) {\n                try {\n                    jar.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n        return databaseTypes;\n    }\n\n    protected void dumpUsage(String errorMessage, boolean detailedDb) {\n        if (errorMessage != null) {\n            System.out.flush();\n            System.err.println(\"*** \" + errorMessage + \" ***\");\n        } else {\n            System.out.println(\"SchemaSpy generates an HTML representation of a database schema's relationships.\");\n        }\n        System.err.flush();\n        System.out.println();\n        if (!detailedDb) {\n            System.out.println(\"Usage:\");\n            System.out.println(\" java -jar \" + getLoadedFromJar() + \" [options]\");\n            System.out.println(\"   -t databaseType       type of database - defaults to ora\");\n            System.out.println(\"                           use -dbhelp for a list of built-in types\");\n            System.out.println(\"   -u user               connect to the database with this user id\");\n            System.out.println(\"   -s schema             defaults to the specified user\");\n            System.out.println(\"   -p password           defaults to no password\");\n            System.out.println(\"   -o outputDirectory    directory to place the generated output in\");\n            System.out.println(\"   -dp pathToDrivers     optional - looks for JDBC drivers here before looking\");\n            System.out.println(\"                           in driverPath in [databaseType].properties.\");\n            System.out.println(\"Go to http://schemaspy.sourceforge.net for a complete list/description\");\n            System.out.println(\" of additional parameters.\");\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"Built-in database types and their required connection parameters:\");\n            for (String type : getBuiltInDatabaseTypes(getLoadedFromJar())) {\n                new DbSpecificConfig(type).dumpUsage();\n            }\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"You can use your own database types by specifying the filespec of a .properties file with -t.\");\n            System.out.println(\"Grab one out of \" + getLoadedFromJar() + \" and modify it to suit your needs.\");\n            System.out.println();\n        }\n        System.out.println(\"Sample usage using the default database type (implied -t ora):\");\n        System.out.println(\" java -jar schemaSpy.jar -db mydb -s myschema -u devuser -p password -o output\");\n        System.out.println();\n        System.out.flush();\n    }\n\n    /**\n     * Get the value of the specified parameter.\n     * Used for properties that are common to most db's, but aren't required.\n     *\n     * @param paramName\n     * @return\n     */\n    public String getParam(String paramName) {\n        try {\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                PropertyDescriptor prop = props[i];\n                if (prop.getName().equalsIgnoreCase(paramName)) {\n                    Object result = prop.getReadMethod().invoke(this, (Object[]) null);\n                    return result == null ? null : result.toString();\n                }\n            }\n        } catch (Exception failed) {\n            failed.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * Return all of the configuration options as a List of Strings, with\n     * each parameter and its value as a separate element.\n     *\n     * @return\n     * @throws IOException\n     */\n    public List<String> asList() throws IOException {\n        List<String> params = new ArrayList<String>();\n        if (originalDbSpecificOptions != null) {\n            for (String key : originalDbSpecificOptions.keySet()) {\n                String value = originalDbSpecificOptions.get(key);\n                if (!key.startsWith(\"-\"))\n                    key = \"-\" + key;\n                params.add(key);\n                params.add(value);\n            }\n        }\n        if (isEncodeCommentsEnabled())\n            params.add(\"-ahic\");\n        if (isEvaluateAllEnabled())\n            params.add(\"-all\");\n        if (!isHtmlGenerationEnabled())\n            params.add(\"-nohtml\");\n        if (!isImpliedConstraintsEnabled())\n            params.add(\"-noimplied\");\n        if (!isLogoEnabled())\n            params.add(\"-nologo\");\n        if (isMeterEnabled())\n            params.add(\"-meter\");\n        if (!isNumRowsEnabled())\n            params.add(\"-norows\");\n        if (!isViewsEnabled())\n            params.add(\"-noviews\");\n        if (isRankDirBugEnabled())\n            params.add(\"-rankdirbug\");\n        if (isRailsEnabled())\n            params.add(\"-rails\");\n        if (isSingleSignOn())\n            params.add(\"-sso\");\n        if (isSchemaDisabled())\n            params.add(\"-noschema\");\n        String value = getDriverPath();\n        if (value != null) {\n            params.add(\"-dp\");\n            params.add(value);\n        }\n        params.add(\"-css\");\n        params.add(getCss());\n        params.add(\"-charset\");\n        params.add(getCharset());\n        params.add(\"-font\");\n        params.add(getFont());\n        params.add(\"-fontsize\");\n        params.add(String.valueOf(getFontSize()));\n        params.add(\"-t\");\n        params.add(getDbType());\n        // query to set renderer correctly\n        isHighQuality();\n        // query to set renderer correctly\n        isLowQuality();\n        // instead of -hq and/or -lq\n        params.add(\"-renderer\");\n        params.add(getRenderer());\n        value = getDescription();\n        if (value != null) {\n            params.add(\"-desc\");\n            params.add(value);\n        }\n        value = getPassword();\n        if (value != null && !isPromptForPasswordEnabled()) {\n            // note that we don't pass -pfp since child processes\n            // won't have a console\n            params.add(\"-p\");\n            params.add(value);\n        }\n        value = getCatalog();\n        if (value != null) {\n            params.add(\"-cat\");\n            params.add(value);\n        }\n        value = getSchema();\n        if (value != null) {\n            params.add(\"-s\");\n            params.add(value);\n        }\n        value = getUser();\n        if (value != null) {\n            params.add(\"-u\");\n            params.add(value);\n        }\n        value = getConnectionPropertiesFile();\n        if (value != null) {\n            params.add(\"-connprops\");\n            params.add(value);\n        } else {\n            Properties props = getConnectionProperties();\n            if (!props.isEmpty()) {\n                params.add(\"-connprops\");\n                StringBuilder buf = new StringBuilder();\n                for (Entry<Object, Object> entry : props.entrySet()) {\n                    buf.append(entry.getKey());\n                    buf.append(ESCAPED_EQUALS);\n                    buf.append(entry.getValue());\n                    buf.append(';');\n                }\n                params.add(buf.toString());\n            }\n        }\n        value = getDb();\n        if (value != null) {\n            params.add(\"-db\");\n            params.add(value);\n        }\n        value = getHost();\n        if (value != null) {\n            params.add(\"-host\");\n            params.add(value);\n        }\n        if (getPort() != null) {\n            params.add(\"-port\");\n            params.add(getPort().toString());\n        }\n        value = getServer();\n        if (value != null) {\n            params.add(\"-server\");\n            params.add(value);\n        }\n        value = getMeta();\n        if (value != null) {\n            params.add(\"-meta\");\n            params.add(value);\n        }\n        if (getGraphvizDir() != null) {\n            params.add(\"-gv\");\n            params.add(getGraphvizDir().toString());\n        }\n        params.add(\"-loglevel\");\n        params.add(getLogLevel().toString().toLowerCase());\n        params.add(\"-sqlFormatter\");\n        params.add(getSqlFormatter().getClass().getName());\n        params.add(\"-i\");\n        params.add(getTableInclusions().toString());\n        params.add(\"-I\");\n        params.add(getTableExclusions().toString());\n        params.add(\"-X\");\n        params.add(getColumnExclusions().toString());\n        params.add(\"-x\");\n        params.add(getIndirectColumnExclusions().toString());\n        params.add(\"-dbthreads\");\n        params.add(String.valueOf(getMaxDbThreads()));\n        params.add(\"-maxdet\");\n        params.add(String.valueOf(getMaxDetailedTables()));\n        params.add(\"-o\");\n        params.add(getOutputDir().toString());\n        return params;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/ConfigTest18.java",
		"test_prompt": "// ConfigTest18.java\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Config}.\n* It contains ten unit test cases for the {@link Config#isDbHelpRequired()} method.\n*/\nclass ConfigTest18 {"
	},
	{
		"original_code": "// Config.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\n\n/**\n * Configuration of a SchemaSpy run\n *\n * @author John Currier\n */\npublic class Config {\n\n    private static Config instance;\n\n    private final List<String> options;\n\n    private Map<String, String> dbSpecificOptions;\n\n    private Map<String, String> originalDbSpecificOptions;\n\n    private boolean helpRequired;\n\n    private boolean dbHelpRequired;\n\n    private File outputDir;\n\n    private File graphvizDir;\n\n    private String dbType;\n\n    private String catalog;\n\n    private String schema;\n\n    private List<String> schemas;\n\n    private String user;\n\n    private Boolean singleSignOn;\n\n    private Boolean noSchema;\n\n    private String password;\n\n    private Boolean promptForPassword;\n\n    private String db;\n\n    private String host;\n\n    private Integer port;\n\n    private String server;\n\n    private String meta;\n\n    private Pattern tableInclusions;\n\n    private Pattern tableExclusions;\n\n    private Pattern columnExclusions;\n\n    private Pattern indirectColumnExclusions;\n\n    private String userConnectionPropertiesFile;\n\n    private Properties userConnectionProperties;\n\n    private Integer maxDbThreads;\n\n    private Integer maxDetailedTables;\n\n    private String driverPath;\n\n    private String css;\n\n    private String charset;\n\n    private String font;\n\n    private Integer fontSize;\n\n    private String description;\n\n    private Properties dbProperties;\n\n    private String dbPropertiesLoadedFrom;\n\n    private Level logLevel;\n\n    private SqlFormatter sqlFormatter;\n\n    private String sqlFormatterClass;\n\n    private Boolean generateHtml;\n\n    private Boolean includeImpliedConstraints;\n\n    private Boolean logoEnabled;\n\n    private Boolean rankDirBugEnabled;\n\n    private Boolean encodeCommentsEnabled;\n\n    private Boolean numRowsEnabled;\n\n    private Boolean viewsEnabled;\n\n    private Boolean meterEnabled;\n\n    private Boolean railsEnabled;\n\n    private Boolean evaluteAll;\n\n    private Boolean highQuality;\n\n    private Boolean lowQuality;\n\n    // used in conjunction with evaluateAll\n    private String schemaSpec;\n\n    private boolean hasOrphans = false;\n\n    private boolean hasRoutines = false;\n\n    private boolean populating = false;\n\n    private List<String> columnDetails;\n\n    public static final String DOT_CHARSET = \"UTF-8\";\n\n    private static final String ESCAPED_EQUALS = \"\\\\=\";\n\n    // match everything\n    private static final String DEFAULT_TABLE_INCLUSION = \".*\";\n\n    // match nothing\n    private static final String DEFAULT_TABLE_EXCLUSION = \"\";\n\n    // match nothing\n    private static final String DEFAULT_COLUMN_EXCLUSION = \"[^.]\";\n\n    /**\n     * Default constructor. Intended for when you want to inject properties\n     * independently (i.e. not from a command line interface).\n     */\n    public Config() {\n        if (instance == null)\n            setInstance(this);\n        options = new ArrayList<String>();\n    }\n\n    /**\n     * Construct a configuration from an array of options (e.g. from a command\n     * line interface).\n     *\n     * @param options\n     */\n    public Config(String[] argv) {\n        setInstance(this);\n        options = fixupArgs(Arrays.asList(argv));\n        helpRequired = options.remove(\"-?\") || options.remove(\"/?\") || options.remove(\"?\") || options.remove(\"-h\") || options.remove(\"-help\") || options.remove(\"--help\");\n        dbHelpRequired = options.remove(\"-dbHelp\") || options.remove(\"-dbhelp\");\n    }\n\n    public static Config getInstance() {\n        if (instance == null)\n            instance = new Config();\n        return instance;\n    }\n\n    /**\n     * Sets the global instance.\n     *\n     * Useful for things like selecting a specific configuration in a UI.\n     *\n     * @param config\n     */\n    public static void setInstance(Config config) {\n        instance = config;\n    }\n\n    public void setHtmlGenerationEnabled(boolean generateHtml) {\n        this.generateHtml = generateHtml;\n    }\n\n    public boolean isHtmlGenerationEnabled() {\n        if (generateHtml == null)\n            generateHtml = !options.remove(\"-nohtml\");\n        return generateHtml;\n    }\n\n    public void setImpliedConstraintsEnabled(boolean includeImpliedConstraints) {\n        this.includeImpliedConstraints = includeImpliedConstraints;\n    }\n\n    public boolean isImpliedConstraintsEnabled() {\n        if (includeImpliedConstraints == null)\n            includeImpliedConstraints = !options.remove(\"-noimplied\");\n        return includeImpliedConstraints;\n    }\n\n    public void setOutputDir(String outputDirName) {\n        if (outputDirName.endsWith(\"\\\"\"))\n            outputDirName = outputDirName.substring(0, outputDirName.length() - 1);\n        setOutputDir(new File(outputDirName));\n    }\n\n    public void setOutputDir(File outputDir) {\n        this.outputDir = outputDir;\n    }\n\n    public File getOutputDir() {\n        if (outputDir == null) {\n            setOutputDir(pullRequiredParam(\"-o\"));\n        }\n        return outputDir;\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(String graphvizDir) {\n        if (graphvizDir.endsWith(\"\\\"\"))\n            graphvizDir = graphvizDir.substring(0, graphvizDir.length() - 1);\n        setGraphvizDir(new File(graphvizDir));\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(File graphvizDir) {\n        this.graphvizDir = graphvizDir;\n    }\n\n    /**\n     * Return the path to Graphviz (used to find the dot executable to run to\n     * generate ER diagrams).<p/>\n     *\n     * Returns {@link #getDefaultGraphvizPath()} if a specific Graphviz path\n     * was not specified.\n     *\n     * @return\n     */\n    public File getGraphvizDir() {\n        if (graphvizDir == null) {\n            String gv = pullParam(\"-gv\");\n            if (gv != null) {\n                setGraphvizDir(gv);\n            } else {\n                // expect to find Graphviz's bin directory on the PATH\n            }\n        }\n        return graphvizDir;\n    }\n\n    /**\n     * Meta files are XML-based files that provide additional metadata\n     * about the schema being evaluated.<p>\n     * <code>meta</code> is either the name of an individual XML file or\n     * the directory that contains meta files.<p>\n     * If a directory is specified then it is expected to contain files\n     * matching the pattern <code>[schema].meta.xml</code>.\n     * For databases that don't have schema substitute database for schema.\n     * @param meta\n     */\n    public void setMeta(String meta) {\n        this.meta = meta;\n    }\n\n    public String getMeta() {\n        if (meta == null)\n            meta = pullParam(\"-meta\");\n        return meta;\n    }\n\n    public void setDbType(String dbType) {\n        this.dbType = dbType;\n    }\n\n    public String getDbType() {\n        if (dbType == null) {\n            dbType = pullParam(\"-t\");\n            if (dbType == null)\n                dbType = \"ora\";\n        }\n        return dbType;\n    }\n\n    public void setDb(String db) {\n        this.db = db;\n    }\n\n    public String getDb() {\n        if (db == null)\n            db = pullParam(\"-db\");\n        return db;\n    }\n\n    public void setCatalog(String catalog) {\n        this.catalog = catalog;\n    }\n\n    public String getCatalog() {\n        if (catalog == null)\n            catalog = pullParam(\"-cat\");\n        return catalog;\n    }\n\n    public void setSchema(String schema) {\n        this.schema = schema;\n    }\n\n    public String getSchema() {\n        if (schema == null)\n            schema = pullParam(\"-s\");\n        return schema;\n    }\n\n    /**\n     * Some databases types (e.g. older versions of Informix) don't really\n     * have the concept of a schema but still return true from\n     * {@link DatabaseMetaData#supportsSchemasInTableDefinitions()}.\n     * This option lets you ignore that and treat all the tables\n     * as if they were in one flat namespace.\n     */\n    public boolean isSchemaDisabled() {\n        if (noSchema == null)\n            noSchema = options.remove(\"-noschema\");\n        return noSchema;\n    }\n\n    public void setHost(String host) {\n        this.host = host;\n    }\n\n    public String getHost() {\n        if (host == null)\n            host = pullParam(\"-host\");\n        return host;\n    }\n\n    public void setPort(Integer port) {\n        this.port = port;\n    }\n\n    public Integer getPort() {\n        if (port == null)\n            try {\n                port = Integer.valueOf(pullParam(\"-port\"));\n            } catch (Exception notSpecified) {\n            }\n        return port;\n    }\n\n    public void setServer(String server) {\n        this.server = server;\n    }\n\n    public String getServer() {\n        if (server == null) {\n            server = pullParam(\"-server\");\n        }\n        return server;\n    }\n\n    public void setUser(String user) {\n        this.user = user;\n    }\n\n    /**\n     * User used to connect to the database.\n     * Required unless single sign-on is enabled\n     * (see {@link #setSingleSignOn(boolean)}).\n     * @return\n     */\n    public String getUser() {\n        if (user == null) {\n            if (!isSingleSignOn())\n                user = pullRequiredParam(\"-u\");\n            else\n                user = pullParam(\"-u\");\n        }\n        return user;\n    }\n\n    /**\n     * By default a \"user\" (as specified with -u) is required.\n     * This option allows disabling of that requirement for\n     * single sign-on environments.\n     *\n     * @param enabled defaults to <code>false</code>\n     */\n    public void setSingleSignOn(boolean enabled) {\n        singleSignOn = enabled;\n    }\n\n    /**\n     * @see #setSingleSignOn(boolean)\n     */\n    public boolean isSingleSignOn() {\n        if (singleSignOn == null)\n            singleSignOn = options.remove(\"-sso\");\n        return singleSignOn;\n    }\n\n    /**\n     * Set the password used to connect to the database.\n     * @param password\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * @see #setPassword(String)\n     * @return\n     */\n    public String getPassword() {\n        if (password == null)\n            password = pullParam(\"-p\");\n        if (password == null && isPromptForPasswordEnabled())\n            password = new String(PasswordReader.getInstance().readPassword(\"Password: \"));\n        if (password == null) {\n            // if -pfp is enabled when analyzing multiple schemas then\n            // we don't want to send the password on the command line,\n            // so see if it was passed in the environment (not ideal, but safer)\n            password = System.getenv(\"schemaspy.pw\");\n        }\n        return password;\n    }\n\n    /**\n     * Set to <code>true</code> to prompt for the password\n     * @param promptForPassword\n     */\n    public void setPromptForPasswordEnabled(boolean promptForPassword) {\n        this.promptForPassword = promptForPassword;\n    }\n\n    /**\n     * @see #setPromptForPasswordEnabled(boolean)\n     * @return\n     */\n    public boolean isPromptForPasswordEnabled() {\n        if (promptForPassword == null) {\n            promptForPassword = options.remove(\"-pfp\");\n        }\n        return promptForPassword;\n    }\n\n    public void setMaxDetailedTabled(int maxDetailedTables) {\n        this.maxDetailedTables = new Integer(maxDetailedTables);\n    }\n\n    public int getMaxDetailedTables() {\n        if (maxDetailedTables == null) {\n            // default\n            int max = 300;\n            try {\n                max = Integer.parseInt(pullParam(\"-maxdet\"));\n            } catch (Exception notSpecified) {\n            }\n            maxDetailedTables = new Integer(max);\n        }\n        return maxDetailedTables.intValue();\n    }\n\n    public String getConnectionPropertiesFile() {\n        return userConnectionPropertiesFile;\n    }\n\n    /**\n     * Properties from this file (in key=value pair format) are passed to the\n     * database connection.<br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.\n     * @param propertiesFilename\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public void setConnectionPropertiesFile(String propertiesFilename) throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null)\n            userConnectionProperties = new Properties();\n        userConnectionProperties.load(new FileInputStream(propertiesFilename));\n        userConnectionPropertiesFile = propertiesFilename;\n    }\n\n    /**\n     * Returns a {@link Properties} populated either from the properties file specified\n     * by {@link #setConnectionPropertiesFile(String)}, the properties specified by\n     * {@link #setConnectionProperties(String)} or not populated.\n     * @return\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public Properties getConnectionProperties() throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null) {\n            String props = pullParam(\"-connprops\");\n            if (props != null) {\n                if (props.indexOf(ESCAPED_EQUALS) != -1) {\n                    setConnectionProperties(props);\n                } else {\n                    setConnectionPropertiesFile(props);\n                }\n            } else {\n                userConnectionProperties = new Properties();\n            }\n        }\n        return userConnectionProperties;\n    }\n\n    /**\n     * Specifies connection properties to use in the format:\n     * <code>key1\\=value1;key2\\=value2</code><br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.<p>\n     * This is an alternative form of passing connection properties than by file\n     * (see {@link #setConnectionPropertiesFile(String)})\n     *\n     * @param properties\n     */\n    public void setConnectionProperties(String properties) {\n        userConnectionProperties = new Properties();\n        StringTokenizer tokenizer = new StringTokenizer(properties, \";\");\n        while (tokenizer.hasMoreElements()) {\n            String pair = tokenizer.nextToken();\n            int index = pair.indexOf(ESCAPED_EQUALS);\n            if (index != -1) {\n                String key = pair.substring(0, index);\n                String value = pair.substring(index + ESCAPED_EQUALS.length());\n                userConnectionProperties.put(key, value);\n            }\n        }\n    }\n\n    public void setDriverPath(String driverPath) {\n        this.driverPath = driverPath;\n    }\n\n    public String getDriverPath() {\n        if (driverPath == null)\n            driverPath = pullParam(\"-dp\");\n        // was previously -cp:\n        if (driverPath == null)\n            driverPath = pullParam(\"-cp\");\n        return driverPath;\n    }\n\n    /**\n     * The filename of the cascading style sheet to use.\n     * Note that this file is parsed and used to determine characteristics\n     * of the generated diagrams, so it must contain specific settings that\n     * are documented within schemaSpy.css.<p>\n     *\n     * Defaults to <code>\"schemaSpy.css\"</code>.\n     *\n     * @param css\n     */\n    public void setCss(String css) {\n        this.css = css;\n    }\n\n    public String getCss() {\n        if (css == null) {\n            css = pullParam(\"-css\");\n            if (css == null)\n                css = \"schemaSpy.css\";\n        }\n        return css;\n    }\n\n    /**\n     * The font to use within diagrams.  Modify the .css to specify HTML fonts.\n     *\n     * @param font\n     */\n    public void setFont(String font) {\n        this.font = font;\n    }\n\n    /**\n     * @see #setFont(String)\n     */\n    public String getFont() {\n        if (font == null) {\n            font = pullParam(\"-font\");\n            if (font == null)\n                font = \"Helvetica\";\n        }\n        return font;\n    }\n\n    /**\n     * The font size to use within diagrams.  This is the size of the font used for\n     * 'large' (e.g. not 'compact') diagrams.<p>\n     *\n     * Modify the .css to specify HTML font sizes.<p>\n     *\n     * Defaults to 11.\n     *\n     * @param fontSize\n     */\n    public void setFontSize(int fontSize) {\n        this.fontSize = new Integer(fontSize);\n    }\n\n    /**\n     * @see #setFontSize(int)\n     * @return\n     */\n    public int getFontSize() {\n        if (fontSize == null) {\n            // default\n            int size = 11;\n            try {\n                size = Integer.parseInt(pullParam(\"-fontsize\"));\n            } catch (Exception notSpecified) {\n            }\n            fontSize = new Integer(size);\n        }\n        return fontSize.intValue();\n    }\n\n    /**\n     * The character set to use within HTML pages (defaults to <code>\"ISO-8859-1\"</code>).\n     *\n     * @param charset\n     */\n    public void setCharset(String charset) {\n        this.charset = charset;\n    }\n\n    /**\n     * @see #setCharset(String)\n     */\n    public String getCharset() {\n        if (charset == null) {\n            charset = pullParam(\"-charset\");\n            if (charset == null)\n                charset = \"ISO-8859-1\";\n        }\n        return charset;\n    }\n\n    /**\n     * Description of schema that gets display on main pages.\n     *\n     * @param description\n     */\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    /**\n     * @see #setDescription(String)\n     */\n    public String getDescription() {\n        if (description == null)\n            description = pullParam(\"-desc\");\n        return description;\n    }\n\n    /**\n     * Maximum number of threads to use when querying database metadata information.\n     *\n     * @param maxDbThreads\n     */\n    public void setMaxDbThreads(int maxDbThreads) {\n        this.maxDbThreads = new Integer(maxDbThreads);\n    }\n\n    /**\n     * @see #setMaxDbThreads(int)\n     * @throws InvalidConfigurationException if unable to load properties\n     */\n    public int getMaxDbThreads() throws InvalidConfigurationException {\n        if (maxDbThreads == null) {\n            Properties properties;\n            try {\n                properties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(\"Failed to load properties for \" + getDbType() + \": \" + exc).setParamName(\"-type\");\n            }\n            // not scientifically derived\n            final int defaultMax = 15;\n            int max = defaultMax;\n            String threads = properties.getProperty(\"dbThreads\");\n            if (threads == null)\n                threads = properties.getProperty(\"dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            threads = pullParam(\"-dbThreads\");\n            if (threads == null)\n                threads = pullParam(\"-dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            if (max < 0)\n                max = defaultMax;\n            else if (max == 0)\n                max = 1;\n            maxDbThreads = new Integer(max);\n        }\n        return maxDbThreads.intValue();\n    }\n\n    public boolean isLogoEnabled() {\n        if (logoEnabled == null)\n            logoEnabled = !options.remove(\"-nologo\");\n        return logoEnabled;\n    }\n\n    /**\n     * Don't use this unless absolutely necessary as it screws up the layout\n     *\n     * @param enabled\n     */\n    public void setRankDirBugEnabled(boolean enabled) {\n        rankDirBugEnabled = enabled;\n    }\n\n    /**\n     * @see #setRankDirBugEnabled(boolean)\n     */\n    public boolean isRankDirBugEnabled() {\n        if (rankDirBugEnabled == null)\n            rankDirBugEnabled = options.remove(\"-rankdirbug\");\n        return rankDirBugEnabled;\n    }\n\n    /**\n     * Look for Ruby on Rails-based naming conventions in\n     * relationships between logical foreign keys and primary keys.<p>\n     *\n     * Basically all tables have a primary key named <code>ID</code>.\n     * All tables are named plural names.\n     * The columns that logically reference that <code>ID</code> are the singular\n     * form of the table name suffixed with <code>_ID</code>.<p>\n     *\n     * @param enabled\n     */\n    public void setRailsEnabled(boolean enabled) {\n        railsEnabled = enabled;\n    }\n\n    /**\n     * @see #setRailsEnabled(boolean)\n     *\n     * @return\n     */\n    public boolean isRailsEnabled() {\n        if (railsEnabled == null)\n            railsEnabled = options.remove(\"-rails\");\n        return railsEnabled;\n    }\n\n    /**\n     * Allow Html In Comments - encode them unless otherwise specified\n     */\n    public void setEncodeCommentsEnabled(boolean enabled) {\n        encodeCommentsEnabled = enabled;\n    }\n\n    /**\n     * @see #setEncodeCommentsEnabled(boolean)\n     */\n    public boolean isEncodeCommentsEnabled() {\n        if (encodeCommentsEnabled == null)\n            encodeCommentsEnabled = !options.remove(\"-ahic\");\n        return encodeCommentsEnabled;\n    }\n\n    /**\n     * If enabled we'll attempt to query/render the number of rows that\n     * each table contains.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setNumRowsEnabled(boolean enabled) {\n        numRowsEnabled = enabled;\n    }\n\n    /**\n     * @see #setNumRowsEnabled(boolean)\n     * @return\n     */\n    public boolean isNumRowsEnabled() {\n        if (numRowsEnabled == null)\n            numRowsEnabled = !options.remove(\"-norows\");\n        return numRowsEnabled;\n    }\n\n    /**\n     * If enabled we'll include views in the analysis.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setViewsEnabled(boolean enabled) {\n        viewsEnabled = enabled;\n    }\n\n    /**\n     * @see #setViewsEnabled(boolean)\n     * @return\n     */\n    public boolean isViewsEnabled() {\n        if (viewsEnabled == null)\n            viewsEnabled = !options.remove(\"-noviews\");\n        return viewsEnabled;\n    }\n\n    /**\n     * Returns <code>true</code> if metering should be embedded in\n     * the generated pages.<p/>\n     * Defaults to <code>false</code> (disabled).\n     * @return\n     */\n    public boolean isMeterEnabled() {\n        if (meterEnabled == null)\n            meterEnabled = options.remove(\"-meter\");\n        return meterEnabled;\n    }\n\n    /**\n     * Set the columns to exclude from all relationship diagrams.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setColumnExclusions(String columnExclusions) {\n        this.columnExclusions = Pattern.compile(columnExclusions);\n    }\n\n    /**\n     * See {@link #setColumnExclusions(String)}\n     * @return\n     */\n    public Pattern getColumnExclusions() {\n        if (columnExclusions == null) {\n            String strExclusions = pullParam(\"-X\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.columnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            columnExclusions = Pattern.compile(strExclusions);\n        }\n        return columnExclusions;\n    }\n\n    /**\n     * Set the columns to exclude from relationship diagrams where the specified\n     * columns aren't directly referenced by the focal table.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setIndirectColumnExclusions(String fullColumnExclusions) {\n        indirectColumnExclusions = Pattern.compile(fullColumnExclusions);\n    }\n\n    /**\n     * @see #setIndirectColumnExclusions(String)\n     *\n     * @return\n     */\n    public Pattern getIndirectColumnExclusions() {\n        if (indirectColumnExclusions == null) {\n            String strExclusions = pullParam(\"-x\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.indirectColumnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            indirectColumnExclusions = Pattern.compile(strExclusions);\n        }\n        return indirectColumnExclusions;\n    }\n\n    /**\n     * Set the tables to include as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableInclusions(String tableInclusions) {\n        this.tableInclusions = Pattern.compile(tableInclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to include in the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableInclusions() {\n        if (tableInclusions == null) {\n            String strInclusions = pullParam(\"-i\");\n            if (strInclusions == null)\n                strInclusions = System.getenv(\"schemaspy.tableInclusions\");\n            if (strInclusions == null)\n                strInclusions = DEFAULT_TABLE_INCLUSION;\n            try {\n                tableInclusions = Pattern.compile(strInclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-i\");\n            }\n        }\n        return tableInclusions;\n    }\n\n    /**\n     * Set the tables to exclude as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableExclusions(String tableExclusions) {\n        this.tableExclusions = Pattern.compile(tableExclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to exclude from the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableExclusions() {\n        if (tableExclusions == null) {\n            String strExclusions = pullParam(\"-I\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.tableExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_TABLE_EXCLUSION;\n            try {\n                tableExclusions = Pattern.compile(strExclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-I\");\n            }\n        }\n        return tableExclusions;\n    }\n\n    /**\n     * @return\n     */\n    public List<String> getSchemas() {\n        if (schemas == null) {\n            String tmp = pullParam(\"-schemas\");\n            if (tmp == null)\n                tmp = pullParam(\"-schemata\");\n            if (tmp != null) {\n                schemas = new ArrayList<String>();\n                for (String name : tmp.split(\"[\\\\s,'\\\"]\")) {\n                    if (name.length() > 0)\n                        schemas.add(name);\n                }\n                if (schemas.isEmpty())\n                    schemas = null;\n            }\n        }\n        return schemas;\n    }\n\n    /**\n     * Set the name of the {@link SqlFormatter SQL formatter} class to use to\n     * format SQL into HTML.<p/>\n     * The implementation of the class must be made available to the class\n     * loader, typically by specifying the path to its jar with <em>-dp</em>\n     * ({@link #setDriverPath(String)}).\n     */\n    public void setSqlFormatter(String formatterClassName) {\n        sqlFormatterClass = formatterClassName;\n        sqlFormatter = null;\n    }\n\n    /**\n     * Set the {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.\n     */\n    public void setSqlFormatter(SqlFormatter sqlFormatter) {\n        this.sqlFormatter = sqlFormatter;\n        if (sqlFormatter != null)\n            sqlFormatterClass = sqlFormatter.getClass().getName();\n    }\n\n    /**\n     * Returns an implementation of {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.  The default implementation is {@link DefaultSqlFormatter}.\n     *\n     * @return\n     * @throws InvalidConfigurationException if unable to instantiate an instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SqlFormatter getSqlFormatter() throws InvalidConfigurationException {\n        if (sqlFormatter == null) {\n            if (sqlFormatterClass == null) {\n                sqlFormatterClass = pullParam(\"-sqlFormatter\");\n                if (sqlFormatterClass == null)\n                    sqlFormatterClass = DefaultSqlFormatter.class.getName();\n            }\n            try {\n                Class<SqlFormatter> clazz = (Class<SqlFormatter>) Class.forName(sqlFormatterClass);\n                sqlFormatter = clazz.newInstance();\n            } catch (Exception exc) {\n                throw new InvalidConfigurationException(\"Failed to initialize instance of SQL formatter: \", exc).setParamName(\"-sqlFormatter\");\n            }\n        }\n        return sqlFormatter;\n    }\n\n    /**\n     * Set the details to show on the columns page, where \"details\" are\n     * comma and/or space separated.\n     *\n     * Valid values:\n     * <ul>\n     * <li>id</li>\n     * <li>table</li>\n     * <li>column</li>\n     * <li>type</li>\n     * <li>size</li>\n     * <li>nulls</li>\n     * <li>auto</li>\n     * <li>default</li>\n     * <li>children</li>\n     * <li>parents</li>\n     * </ul>\n     *\n     * The default details are <code>\"table column type size nulls auto default\"</code>.\n     * Note that \"column\" is the initially displayed detail and must be included.\n     *\n     * @param columnDetails\n     */\n    public void setColumnDetails(String columnDetails) {\n        this.columnDetails = new ArrayList<String>();\n        if (columnDetails == null || columnDetails.length() == 0) {\n            // not specified, so use defaults\n            columnDetails = \"id table column type size nulls auto default\";\n        }\n        for (String detail : columnDetails.split(\"[\\\\s,'\\\"]\")) {\n            if (detail.length() > 0) {\n                this.columnDetails.add(detail.toLowerCase());\n            }\n        }\n        if (!this.columnDetails.contains(\"column\"))\n            throw new InvalidConfigurationException(\"'column' is a required column detail\");\n    }\n\n    public void setColumnDetails(List<String> columnDetails) {\n        String details = columnDetails == null ? \"[]\" : columnDetails.toString();\n        setColumnDetails(details.substring(1, details.length() - 1));\n    }\n\n    public List<String> getColumnDetails() {\n        if (columnDetails == null) {\n            setColumnDetails(pullParam(\"-columndetails\"));\n        }\n        return columnDetails;\n    }\n\n    public void setEvaluateAllEnabled(boolean enabled) {\n        evaluteAll = enabled;\n    }\n\n    public boolean isEvaluateAllEnabled() {\n        if (evaluteAll == null)\n            evaluteAll = options.remove(\"-all\");\n        return evaluteAll;\n    }\n\n    /**\n     * Returns true if we're evaluating a bunch of schemas in one go and\n     * at this point we're evaluating a specific schema.\n     *\n     * @return boolean\n     */\n    public boolean isOneOfMultipleSchemas() {\n        // set by MultipleSchemaAnalyzer\n        return Boolean.getBoolean(\"oneofmultipleschemas\");\n    }\n\n    /**\n     * When -all (evaluateAll) is specified then this is the regular\n     * expression that determines which schemas to evaluate.\n     *\n     * @param schemaSpec\n     */\n    public void setSchemaSpec(String schemaSpec) {\n        this.schemaSpec = schemaSpec;\n    }\n\n    public String getSchemaSpec() {\n        if (schemaSpec == null)\n            schemaSpec = pullParam(\"-schemaSpec\");\n        return schemaSpec;\n    }\n\n    /**\n     * Set the renderer to use for the -Tpng[:renderer[:formatter]] dot option as specified\n     * at <a href='http://www.graphviz.org/doc/info/command.html'>\n     * http://www.graphviz.org/doc/info/command.html</a>.<p>\n     * Note that the leading \":\" is required while :formatter is optional.<p>\n     * The default renderer is typically GD.<p>\n     * Note that using {@link #setHighQuality(boolean)} is the preferred approach\n     * over using this method.\n     */\n    public void setRenderer(String renderer) {\n        Dot.getInstance().setRenderer(renderer);\n    }\n\n    /**\n     * @see #setRenderer(String)\n     * @return\n     */\n    public String getRenderer() {\n        String renderer = pullParam(\"-renderer\");\n        if (renderer != null)\n            setRenderer(renderer);\n        return Dot.getInstance().getRenderer();\n    }\n\n    /**\n     * If <code>false</code> then generate output of \"lower quality\"\n     * than the default.\n     * Note that the default is intended to be \"higher quality\",\n     * but various installations of Graphviz may have have different abilities.\n     * That is, some might not have the \"lower quality\" libraries and others might\n     * not have the \"higher quality\" libraries.<p>\n     * Higher quality output takes longer to generate and results in significantly\n     * larger image files (which take longer to download / display), but it generally\n     * looks better.\n     */\n    public void setHighQuality(boolean highQuality) {\n        this.highQuality = highQuality;\n        lowQuality = !highQuality;\n        Dot.getInstance().setHighQuality(highQuality);\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isHighQuality() {\n        if (highQuality == null) {\n            highQuality = options.remove(\"-hq\");\n            if (highQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(highQuality);\n            }\n        }\n        highQuality = Dot.getInstance().isHighQuality();\n        return highQuality;\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isLowQuality() {\n        if (lowQuality == null) {\n            lowQuality = options.remove(\"-lq\");\n            if (lowQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(!lowQuality);\n            }\n        }\n        lowQuality = !Dot.getInstance().isHighQuality();\n        return lowQuality;\n    }\n\n    /**\n     * Set the level of logging to perform.<p/>\n     * The levels in descending order are:\n     * <ul>\n     *  <li><code>severe</code> (highest - least detail)\n     *  <li><code>warning</code> (default)\n     *  <li><code>info</code>\n     *  <li><code>config</code>\n     *  <li><code>fine</code>\n     *  <li><code>finer</code>\n     *  <li><code>finest</code>  (lowest - most detail)\n     * </ul>\n     *\n     * @param logLevel\n     */\n    public void setLogLevel(String logLevel) {\n        if (logLevel == null) {\n            this.logLevel = Level.WARNING;\n            return;\n        }\n        Map<String, Level> levels = new LinkedHashMap<String, Level>();\n        levels.put(\"severe\", Level.SEVERE);\n        levels.put(\"warning\", Level.WARNING);\n        levels.put(\"info\", Level.INFO);\n        levels.put(\"config\", Level.CONFIG);\n        levels.put(\"fine\", Level.FINE);\n        levels.put(\"finer\", Level.FINER);\n        levels.put(\"finest\", Level.FINEST);\n        this.logLevel = levels.get(logLevel.toLowerCase());\n        if (this.logLevel == null) {\n            throw new InvalidConfigurationException(\"Invalid logLevel: '\" + logLevel + \"'. Must be one of: \" + levels.keySet());\n        }\n    }\n\n    /**\n     * Returns the level of logging to perform.\n     * See {@link #setLogLevel(String)}.\n     *\n     * @return\n     */\n    public Level getLogLevel() {\n        if (logLevel == null) {\n            setLogLevel(pullParam(\"-loglevel\"));\n        }\n        return logLevel;\n    }\n\n    /**\n     * Returns <code>true</code> if the options indicate that the user wants\n     * to see some help information.\n     *\n     * @return\n     */\n    public boolean isHelpRequired() {\n        return helpRequired;\n    }\n\n    public boolean isDbHelpRequired() {\n        return dbHelpRequired;\n    }\n\n    /**\n     * Returns the jar that we were loaded from\n     *\n     * @return\n     */\n    public static String getLoadedFromJar() {\n        String classpath = System.getProperty(\"java.class.path\");\n        return new StringTokenizer(classpath, File.pathSeparator).nextToken();\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasOrphans(boolean hasOrphans) {\n        this.hasOrphans = hasOrphans;\n    }\n\n    /**\n     * @see #setHasOrphans()\n     *\n     * @return\n     */\n    public boolean hasOrphans() {\n        return hasOrphans;\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasRoutines(boolean hasRoutines) {\n        this.hasRoutines = hasRoutines;\n    }\n\n    /**\n     * @see #setHasRoutines()\n     *\n     * @return\n     */\n    public boolean hasRoutines() {\n        return hasRoutines;\n    }\n\n    /**\n     * Returns the database properties to use.\n     * These should be determined by calling {@link #determineDbProperties(String)}.\n     * @return\n     * @throws InvalidConfigurationException\n     */\n    public Properties getDbProperties() throws InvalidConfigurationException {\n        if (dbProperties == null) {\n            try {\n                dbProperties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(exc);\n            }\n        }\n        return dbProperties;\n    }\n\n    /**\n     * Determines the database properties associated with the specified type.\n     * A call to {@link #setDbProperties(Properties)} is expected after determining\n     * the complete set of properties.\n     *\n     * @param type\n     * @return\n     * @throws IOException\n     * @throws InvalidConfigurationException if db properties are incorrectly formed\n     */\n    public Properties determineDbProperties(String type) throws IOException, InvalidConfigurationException {\n        ResourceBundle bundle = null;\n        try {\n            File propertiesFile = new File(type);\n            bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n            dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n        } catch (FileNotFoundException notFoundOnFilesystemWithoutExtension) {\n            try {\n                File propertiesFile = new File(type + \".properties\");\n                bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n                dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n            } catch (FileNotFoundException notFoundOnFilesystemWithExtensionTackedOn) {\n                try {\n                    bundle = ResourceBundle.getBundle(type);\n                    dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]\" + File.separator + type + \".properties\";\n                } catch (Exception notInJarWithoutPath) {\n                    try {\n                        String path = TableOrderer.class.getPackage().getName() + \".dbTypes.\" + type;\n                        path = path.replace('.', '/');\n                        bundle = ResourceBundle.getBundle(path);\n                        dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]/\" + path + \".properties\";\n                    } catch (Exception notInJar) {\n                        notInJar.printStackTrace();\n                        notFoundOnFilesystemWithExtensionTackedOn.printStackTrace();\n                        throw notFoundOnFilesystemWithoutExtension;\n                    }\n                }\n            }\n        }\n        Properties props = asProperties(bundle);\n        bundle = null;\n        // keep original thru recursion\n        String saveLoadedFrom = dbPropertiesLoadedFrom;\n        // bring in key/values pointed to by the include directive\n        // example: include.1=mysql::selectRowCountSql\n        for (int i = 1; true; ++i) {\n            String include = (String) props.remove(\"include.\" + i);\n            if (include == null)\n                break;\n            int separator = include.indexOf(\"::\");\n            if (separator == -1)\n                throw new InvalidConfigurationException(\"include directive in \" + dbPropertiesLoadedFrom + \" must have '::' between dbType and key\");\n            String refdType = include.substring(0, separator).trim();\n            String refdKey = include.substring(separator + 2).trim();\n            // recursively resolve the ref'd properties file and the ref'd key\n            Properties refdProps = determineDbProperties(refdType);\n            props.put(refdKey, refdProps.getProperty(refdKey));\n        }\n        // bring in base properties files pointed to by the extends directive\n        String baseDbType = (String) props.remove(\"extends\");\n        if (baseDbType != null) {\n            baseDbType = baseDbType.trim();\n            Properties baseProps = determineDbProperties(baseDbType);\n            // overlay our properties on top of the base's\n            baseProps.putAll(props);\n            props = baseProps;\n        }\n        // done with this level of recursion...restore original\n        dbPropertiesLoadedFrom = saveLoadedFrom;\n        // this won't be correct until the final recursion exits\n        dbProperties = props;\n        return props;\n    }\n\n    protected String getDbPropertiesLoadedFrom() throws IOException {\n        if (dbPropertiesLoadedFrom == null)\n            determineDbProperties(getDbType());\n        return dbPropertiesLoadedFrom;\n    }\n\n    public List<String> getRemainingParameters() {\n        try {\n            populate();\n        } catch (IllegalArgumentException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (IllegalAccessException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (InvocationTargetException exc) {\n            if (exc.getCause() instanceof InvalidConfigurationException)\n                throw (InvalidConfigurationException) exc.getCause();\n            throw new InvalidConfigurationException(exc.getCause());\n        } catch (IntrospectionException exc) {\n            throw new InvalidConfigurationException(exc);\n        }\n        return options;\n    }\n\n    /**\n     * Options that are specific to a type of database.  E.g. things like <code>host</code>,\n     * <code>port</code> or <code>db</code>, but <b>don't</b> have a setter in this class.\n     *\n     * @param dbSpecificOptions\n     */\n    public void setDbSpecificOptions(Map<String, String> dbSpecificOptions) {\n        this.dbSpecificOptions = dbSpecificOptions;\n        originalDbSpecificOptions = new HashMap<String, String>(dbSpecificOptions);\n    }\n\n    public Map<String, String> getDbSpecificOptions() {\n        if (dbSpecificOptions == null)\n            dbSpecificOptions = new HashMap<String, String>();\n        return dbSpecificOptions;\n    }\n\n    /**\n     * Returns a {@link Properties} populated with the contents of <code>bundle</code>\n     *\n     * @param bundle ResourceBundle\n     * @return Properties\n     */\n    public static Properties asProperties(ResourceBundle bundle) {\n        Properties props = new Properties();\n        Enumeration<String> iter = bundle.getKeys();\n        while (iter.hasMoreElements()) {\n            String key = iter.nextElement();\n            props.put(key, bundle.getObject(key));\n        }\n        return props;\n    }\n\n    /**\n     * 'Pull' the specified parameter from the collection of options. Returns\n     * null if the parameter isn't in the list and removes it if it is.\n     *\n     * @param paramId\n     * @return\n     */\n    private String pullParam(String paramId) {\n        return pullParam(paramId, false, false);\n    }\n\n    private String pullRequiredParam(String paramId) {\n        return pullParam(paramId, true, false);\n    }\n\n    /**\n     * @param paramId\n     * @param required\n     * @param dbTypeSpecific\n     * @return\n     * @throws MissingRequiredParameterException\n     */\n    private String pullParam(String paramId, boolean required, boolean dbTypeSpecific) throws MissingRequiredParameterException {\n        int paramIndex = options.indexOf(paramId);\n        if (paramIndex < 0) {\n            if (required)\n                throw new MissingRequiredParameterException(paramId, dbTypeSpecific);\n            return null;\n        }\n        options.remove(paramIndex);\n        String param = options.get(paramIndex).toString();\n        options.remove(paramIndex);\n        return param;\n    }\n\n    /**\n     * Thrown to indicate that a required parameter is missing\n     */\n    public static class MissingRequiredParameterException extends RuntimeException {\n\n        private static final long serialVersionUID = 1L;\n\n        private final boolean dbTypeSpecific;\n\n        public MissingRequiredParameterException(String paramId, boolean dbTypeSpecific) {\n            this(paramId, null, dbTypeSpecific);\n        }\n\n        public MissingRequiredParameterException(String paramId, String description, boolean dbTypeSpecific) {\n            super(\"Required parameter '\" + paramId + \"' \" + (description == null ? \"\" : \"(\" + description + \") \") + \"was not specified.\" + (dbTypeSpecific ? \"  It is required for this database type.\" : \"\"));\n            this.dbTypeSpecific = dbTypeSpecific;\n        }\n\n        public boolean isDbTypeSpecific() {\n            return dbTypeSpecific;\n        }\n    }\n\n    /**\n     * Allow an equal sign in args...like \"-o=foo.bar\". Useful for things like\n     * Ant and Maven.\n     *\n     * @param args\n     *            List\n     * @return List\n     */\n    protected List<String> fixupArgs(List<String> args) {\n        List<String> expandedArgs = new ArrayList<String>();\n        for (String arg : args) {\n            int indexOfEquals = arg.indexOf('=');\n            if (indexOfEquals != -1 && indexOfEquals - 1 != arg.indexOf(ESCAPED_EQUALS)) {\n                expandedArgs.add(arg.substring(0, indexOfEquals));\n                expandedArgs.add(arg.substring(indexOfEquals + 1));\n            } else {\n                expandedArgs.add(arg);\n            }\n        }\n        // some OSes/JVMs do filename expansion with runtime.exec() and some don't,\n        // so MultipleSchemaAnalyzer has to surround params with double quotes...\n        // strip them here for the OSes/JVMs that don't do anything with the params\n        List<String> unquotedArgs = new ArrayList<String>();\n        for (String arg : expandedArgs) {\n            if (// \".*\" becomes .*\n            arg.startsWith(\"\\\"\") && arg.endsWith(\"\\\"\"))\n                arg = arg.substring(1, arg.length() - 1);\n            unquotedArgs.add(arg);\n        }\n        return unquotedArgs;\n    }\n\n    /**\n     * Call all the getters to populate all the lazy initialized stuff.\n     *\n     * @throws InvocationTargetException\n     * @throws IllegalAccessException\n     * @throws IllegalArgumentException\n     * @throws IntrospectionException\n     */\n    private void populate() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IntrospectionException {\n        if (!populating) {\n            // prevent recursion\n            populating = true;\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                Method readMethod = props[i].getReadMethod();\n                if (readMethod != null)\n                    readMethod.invoke(this, (Object[]) null);\n            }\n            populating = false;\n        }\n    }\n\n    public static Set<String> getBuiltInDatabaseTypes(String loadedFromJar) {\n        Set<String> databaseTypes = new TreeSet<String>();\n        JarInputStream jar = null;\n        try {\n            jar = new JarInputStream(new FileInputStream(loadedFromJar));\n            JarEntry entry;\n            while ((entry = jar.getNextJarEntry()) != null) {\n                String entryName = entry.getName();\n                int dotPropsIndex = entryName.indexOf(\".properties\");\n                if (dotPropsIndex != -1)\n                    databaseTypes.add(entryName.substring(0, dotPropsIndex));\n            }\n        } catch (IOException exc) {\n        } finally {\n            if (jar != null) {\n                try {\n                    jar.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n        return databaseTypes;\n    }\n\n    protected void dumpUsage(String errorMessage, boolean detailedDb) {\n        if (errorMessage != null) {\n            System.out.flush();\n            System.err.println(\"*** \" + errorMessage + \" ***\");\n        } else {\n            System.out.println(\"SchemaSpy generates an HTML representation of a database schema's relationships.\");\n        }\n        System.err.flush();\n        System.out.println();\n        if (!detailedDb) {\n            System.out.println(\"Usage:\");\n            System.out.println(\" java -jar \" + getLoadedFromJar() + \" [options]\");\n            System.out.println(\"   -t databaseType       type of database - defaults to ora\");\n            System.out.println(\"                           use -dbhelp for a list of built-in types\");\n            System.out.println(\"   -u user               connect to the database with this user id\");\n            System.out.println(\"   -s schema             defaults to the specified user\");\n            System.out.println(\"   -p password           defaults to no password\");\n            System.out.println(\"   -o outputDirectory    directory to place the generated output in\");\n            System.out.println(\"   -dp pathToDrivers     optional - looks for JDBC drivers here before looking\");\n            System.out.println(\"                           in driverPath in [databaseType].properties.\");\n            System.out.println(\"Go to http://schemaspy.sourceforge.net for a complete list/description\");\n            System.out.println(\" of additional parameters.\");\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"Built-in database types and their required connection parameters:\");\n            for (String type : getBuiltInDatabaseTypes(getLoadedFromJar())) {\n                new DbSpecificConfig(type).dumpUsage();\n            }\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"You can use your own database types by specifying the filespec of a .properties file with -t.\");\n            System.out.println(\"Grab one out of \" + getLoadedFromJar() + \" and modify it to suit your needs.\");\n            System.out.println();\n        }\n        System.out.println(\"Sample usage using the default database type (implied -t ora):\");\n        System.out.println(\" java -jar schemaSpy.jar -db mydb -s myschema -u devuser -p password -o output\");\n        System.out.println();\n        System.out.flush();\n    }\n\n    /**\n     * Get the value of the specified parameter.\n     * Used for properties that are common to most db's, but aren't required.\n     *\n     * @param paramName\n     * @return\n     */\n    public String getParam(String paramName) {\n        try {\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                PropertyDescriptor prop = props[i];\n                if (prop.getName().equalsIgnoreCase(paramName)) {\n                    Object result = prop.getReadMethod().invoke(this, (Object[]) null);\n                    return result == null ? null : result.toString();\n                }\n            }\n        } catch (Exception failed) {\n            failed.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * Return all of the configuration options as a List of Strings, with\n     * each parameter and its value as a separate element.\n     *\n     * @return\n     * @throws IOException\n     */\n    public List<String> asList() throws IOException {\n        List<String> params = new ArrayList<String>();\n        if (originalDbSpecificOptions != null) {\n            for (String key : originalDbSpecificOptions.keySet()) {\n                String value = originalDbSpecificOptions.get(key);\n                if (!key.startsWith(\"-\"))\n                    key = \"-\" + key;\n                params.add(key);\n                params.add(value);\n            }\n        }\n        if (isEncodeCommentsEnabled())\n            params.add(\"-ahic\");\n        if (isEvaluateAllEnabled())\n            params.add(\"-all\");\n        if (!isHtmlGenerationEnabled())\n            params.add(\"-nohtml\");\n        if (!isImpliedConstraintsEnabled())\n            params.add(\"-noimplied\");\n        if (!isLogoEnabled())\n            params.add(\"-nologo\");\n        if (isMeterEnabled())\n            params.add(\"-meter\");\n        if (!isNumRowsEnabled())\n            params.add(\"-norows\");\n        if (!isViewsEnabled())\n            params.add(\"-noviews\");\n        if (isRankDirBugEnabled())\n            params.add(\"-rankdirbug\");\n        if (isRailsEnabled())\n            params.add(\"-rails\");\n        if (isSingleSignOn())\n            params.add(\"-sso\");\n        if (isSchemaDisabled())\n            params.add(\"-noschema\");\n        String value = getDriverPath();\n        if (value != null) {\n            params.add(\"-dp\");\n            params.add(value);\n        }\n        params.add(\"-css\");\n        params.add(getCss());\n        params.add(\"-charset\");\n        params.add(getCharset());\n        params.add(\"-font\");\n        params.add(getFont());\n        params.add(\"-fontsize\");\n        params.add(String.valueOf(getFontSize()));\n        params.add(\"-t\");\n        params.add(getDbType());\n        // query to set renderer correctly\n        isHighQuality();\n        // query to set renderer correctly\n        isLowQuality();\n        // instead of -hq and/or -lq\n        params.add(\"-renderer\");\n        params.add(getRenderer());\n        value = getDescription();\n        if (value != null) {\n            params.add(\"-desc\");\n            params.add(value);\n        }\n        value = getPassword();\n        if (value != null && !isPromptForPasswordEnabled()) {\n            // note that we don't pass -pfp since child processes\n            // won't have a console\n            params.add(\"-p\");\n            params.add(value);\n        }\n        value = getCatalog();\n        if (value != null) {\n            params.add(\"-cat\");\n            params.add(value);\n        }\n        value = getSchema();\n        if (value != null) {\n            params.add(\"-s\");\n            params.add(value);\n        }\n        value = getUser();\n        if (value != null) {\n            params.add(\"-u\");\n            params.add(value);\n        }\n        value = getConnectionPropertiesFile();\n        if (value != null) {\n            params.add(\"-connprops\");\n            params.add(value);\n        } else {\n            Properties props = getConnectionProperties();\n            if (!props.isEmpty()) {\n                params.add(\"-connprops\");\n                StringBuilder buf = new StringBuilder();\n                for (Entry<Object, Object> entry : props.entrySet()) {\n                    buf.append(entry.getKey());\n                    buf.append(ESCAPED_EQUALS);\n                    buf.append(entry.getValue());\n                    buf.append(';');\n                }\n                params.add(buf.toString());\n            }\n        }\n        value = getDb();\n        if (value != null) {\n            params.add(\"-db\");\n            params.add(value);\n        }\n        value = getHost();\n        if (value != null) {\n            params.add(\"-host\");\n            params.add(value);\n        }\n        if (getPort() != null) {\n            params.add(\"-port\");\n            params.add(getPort().toString());\n        }\n        value = getServer();\n        if (value != null) {\n            params.add(\"-server\");\n            params.add(value);\n        }\n        value = getMeta();\n        if (value != null) {\n            params.add(\"-meta\");\n            params.add(value);\n        }\n        if (getGraphvizDir() != null) {\n            params.add(\"-gv\");\n            params.add(getGraphvizDir().toString());\n        }\n        params.add(\"-loglevel\");\n        params.add(getLogLevel().toString().toLowerCase());\n        params.add(\"-sqlFormatter\");\n        params.add(getSqlFormatter().getClass().getName());\n        params.add(\"-i\");\n        params.add(getTableInclusions().toString());\n        params.add(\"-I\");\n        params.add(getTableExclusions().toString());\n        params.add(\"-X\");\n        params.add(getColumnExclusions().toString());\n        params.add(\"-x\");\n        params.add(getIndirectColumnExclusions().toString());\n        params.add(\"-dbthreads\");\n        params.add(String.valueOf(getMaxDbThreads()));\n        params.add(\"-maxdet\");\n        params.add(String.valueOf(getMaxDetailedTables()));\n        params.add(\"-o\");\n        params.add(getOutputDir().toString());\n        return params;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/ConfigTest19.java",
		"test_prompt": "// ConfigTest19.java\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Config}.\n* It contains ten unit test cases for the {@link Config#getLoadedFromJar()} method.\n*/\nclass ConfigTest19 {"
	},
	{
		"original_code": "// Config.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\n\n/**\n * Configuration of a SchemaSpy run\n *\n * @author John Currier\n */\npublic class Config {\n\n    private static Config instance;\n\n    private final List<String> options;\n\n    private Map<String, String> dbSpecificOptions;\n\n    private Map<String, String> originalDbSpecificOptions;\n\n    private boolean helpRequired;\n\n    private boolean dbHelpRequired;\n\n    private File outputDir;\n\n    private File graphvizDir;\n\n    private String dbType;\n\n    private String catalog;\n\n    private String schema;\n\n    private List<String> schemas;\n\n    private String user;\n\n    private Boolean singleSignOn;\n\n    private Boolean noSchema;\n\n    private String password;\n\n    private Boolean promptForPassword;\n\n    private String db;\n\n    private String host;\n\n    private Integer port;\n\n    private String server;\n\n    private String meta;\n\n    private Pattern tableInclusions;\n\n    private Pattern tableExclusions;\n\n    private Pattern columnExclusions;\n\n    private Pattern indirectColumnExclusions;\n\n    private String userConnectionPropertiesFile;\n\n    private Properties userConnectionProperties;\n\n    private Integer maxDbThreads;\n\n    private Integer maxDetailedTables;\n\n    private String driverPath;\n\n    private String css;\n\n    private String charset;\n\n    private String font;\n\n    private Integer fontSize;\n\n    private String description;\n\n    private Properties dbProperties;\n\n    private String dbPropertiesLoadedFrom;\n\n    private Level logLevel;\n\n    private SqlFormatter sqlFormatter;\n\n    private String sqlFormatterClass;\n\n    private Boolean generateHtml;\n\n    private Boolean includeImpliedConstraints;\n\n    private Boolean logoEnabled;\n\n    private Boolean rankDirBugEnabled;\n\n    private Boolean encodeCommentsEnabled;\n\n    private Boolean numRowsEnabled;\n\n    private Boolean viewsEnabled;\n\n    private Boolean meterEnabled;\n\n    private Boolean railsEnabled;\n\n    private Boolean evaluteAll;\n\n    private Boolean highQuality;\n\n    private Boolean lowQuality;\n\n    // used in conjunction with evaluateAll\n    private String schemaSpec;\n\n    private boolean hasOrphans = false;\n\n    private boolean hasRoutines = false;\n\n    private boolean populating = false;\n\n    private List<String> columnDetails;\n\n    public static final String DOT_CHARSET = \"UTF-8\";\n\n    private static final String ESCAPED_EQUALS = \"\\\\=\";\n\n    // match everything\n    private static final String DEFAULT_TABLE_INCLUSION = \".*\";\n\n    // match nothing\n    private static final String DEFAULT_TABLE_EXCLUSION = \"\";\n\n    // match nothing\n    private static final String DEFAULT_COLUMN_EXCLUSION = \"[^.]\";\n\n    /**\n     * Default constructor. Intended for when you want to inject properties\n     * independently (i.e. not from a command line interface).\n     */\n    public Config() {\n        if (instance == null)\n            setInstance(this);\n        options = new ArrayList<String>();\n    }\n\n    /**\n     * Construct a configuration from an array of options (e.g. from a command\n     * line interface).\n     *\n     * @param options\n     */\n    public Config(String[] argv) {\n        setInstance(this);\n        options = fixupArgs(Arrays.asList(argv));\n        helpRequired = options.remove(\"-?\") || options.remove(\"/?\") || options.remove(\"?\") || options.remove(\"-h\") || options.remove(\"-help\") || options.remove(\"--help\");\n        dbHelpRequired = options.remove(\"-dbHelp\") || options.remove(\"-dbhelp\");\n    }\n\n    public static Config getInstance() {\n        if (instance == null)\n            instance = new Config();\n        return instance;\n    }\n\n    /**\n     * Sets the global instance.\n     *\n     * Useful for things like selecting a specific configuration in a UI.\n     *\n     * @param config\n     */\n    public static void setInstance(Config config) {\n        instance = config;\n    }\n\n    public void setHtmlGenerationEnabled(boolean generateHtml) {\n        this.generateHtml = generateHtml;\n    }\n\n    public boolean isHtmlGenerationEnabled() {\n        if (generateHtml == null)\n            generateHtml = !options.remove(\"-nohtml\");\n        return generateHtml;\n    }\n\n    public void setImpliedConstraintsEnabled(boolean includeImpliedConstraints) {\n        this.includeImpliedConstraints = includeImpliedConstraints;\n    }\n\n    public boolean isImpliedConstraintsEnabled() {\n        if (includeImpliedConstraints == null)\n            includeImpliedConstraints = !options.remove(\"-noimplied\");\n        return includeImpliedConstraints;\n    }\n\n    public void setOutputDir(String outputDirName) {\n        if (outputDirName.endsWith(\"\\\"\"))\n            outputDirName = outputDirName.substring(0, outputDirName.length() - 1);\n        setOutputDir(new File(outputDirName));\n    }\n\n    public void setOutputDir(File outputDir) {\n        this.outputDir = outputDir;\n    }\n\n    public File getOutputDir() {\n        if (outputDir == null) {\n            setOutputDir(pullRequiredParam(\"-o\"));\n        }\n        return outputDir;\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(String graphvizDir) {\n        if (graphvizDir.endsWith(\"\\\"\"))\n            graphvizDir = graphvizDir.substring(0, graphvizDir.length() - 1);\n        setGraphvizDir(new File(graphvizDir));\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(File graphvizDir) {\n        this.graphvizDir = graphvizDir;\n    }\n\n    /**\n     * Return the path to Graphviz (used to find the dot executable to run to\n     * generate ER diagrams).<p/>\n     *\n     * Returns {@link #getDefaultGraphvizPath()} if a specific Graphviz path\n     * was not specified.\n     *\n     * @return\n     */\n    public File getGraphvizDir() {\n        if (graphvizDir == null) {\n            String gv = pullParam(\"-gv\");\n            if (gv != null) {\n                setGraphvizDir(gv);\n            } else {\n                // expect to find Graphviz's bin directory on the PATH\n            }\n        }\n        return graphvizDir;\n    }\n\n    /**\n     * Meta files are XML-based files that provide additional metadata\n     * about the schema being evaluated.<p>\n     * <code>meta</code> is either the name of an individual XML file or\n     * the directory that contains meta files.<p>\n     * If a directory is specified then it is expected to contain files\n     * matching the pattern <code>[schema].meta.xml</code>.\n     * For databases that don't have schema substitute database for schema.\n     * @param meta\n     */\n    public void setMeta(String meta) {\n        this.meta = meta;\n    }\n\n    public String getMeta() {\n        if (meta == null)\n            meta = pullParam(\"-meta\");\n        return meta;\n    }\n\n    public void setDbType(String dbType) {\n        this.dbType = dbType;\n    }\n\n    public String getDbType() {\n        if (dbType == null) {\n            dbType = pullParam(\"-t\");\n            if (dbType == null)\n                dbType = \"ora\";\n        }\n        return dbType;\n    }\n\n    public void setDb(String db) {\n        this.db = db;\n    }\n\n    public String getDb() {\n        if (db == null)\n            db = pullParam(\"-db\");\n        return db;\n    }\n\n    public void setCatalog(String catalog) {\n        this.catalog = catalog;\n    }\n\n    public String getCatalog() {\n        if (catalog == null)\n            catalog = pullParam(\"-cat\");\n        return catalog;\n    }\n\n    public void setSchema(String schema) {\n        this.schema = schema;\n    }\n\n    public String getSchema() {\n        if (schema == null)\n            schema = pullParam(\"-s\");\n        return schema;\n    }\n\n    /**\n     * Some databases types (e.g. older versions of Informix) don't really\n     * have the concept of a schema but still return true from\n     * {@link DatabaseMetaData#supportsSchemasInTableDefinitions()}.\n     * This option lets you ignore that and treat all the tables\n     * as if they were in one flat namespace.\n     */\n    public boolean isSchemaDisabled() {\n        if (noSchema == null)\n            noSchema = options.remove(\"-noschema\");\n        return noSchema;\n    }\n\n    public void setHost(String host) {\n        this.host = host;\n    }\n\n    public String getHost() {\n        if (host == null)\n            host = pullParam(\"-host\");\n        return host;\n    }\n\n    public void setPort(Integer port) {\n        this.port = port;\n    }\n\n    public Integer getPort() {\n        if (port == null)\n            try {\n                port = Integer.valueOf(pullParam(\"-port\"));\n            } catch (Exception notSpecified) {\n            }\n        return port;\n    }\n\n    public void setServer(String server) {\n        this.server = server;\n    }\n\n    public String getServer() {\n        if (server == null) {\n            server = pullParam(\"-server\");\n        }\n        return server;\n    }\n\n    public void setUser(String user) {\n        this.user = user;\n    }\n\n    /**\n     * User used to connect to the database.\n     * Required unless single sign-on is enabled\n     * (see {@link #setSingleSignOn(boolean)}).\n     * @return\n     */\n    public String getUser() {\n        if (user == null) {\n            if (!isSingleSignOn())\n                user = pullRequiredParam(\"-u\");\n            else\n                user = pullParam(\"-u\");\n        }\n        return user;\n    }\n\n    /**\n     * By default a \"user\" (as specified with -u) is required.\n     * This option allows disabling of that requirement for\n     * single sign-on environments.\n     *\n     * @param enabled defaults to <code>false</code>\n     */\n    public void setSingleSignOn(boolean enabled) {\n        singleSignOn = enabled;\n    }\n\n    /**\n     * @see #setSingleSignOn(boolean)\n     */\n    public boolean isSingleSignOn() {\n        if (singleSignOn == null)\n            singleSignOn = options.remove(\"-sso\");\n        return singleSignOn;\n    }\n\n    /**\n     * Set the password used to connect to the database.\n     * @param password\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * @see #setPassword(String)\n     * @return\n     */\n    public String getPassword() {\n        if (password == null)\n            password = pullParam(\"-p\");\n        if (password == null && isPromptForPasswordEnabled())\n            password = new String(PasswordReader.getInstance().readPassword(\"Password: \"));\n        if (password == null) {\n            // if -pfp is enabled when analyzing multiple schemas then\n            // we don't want to send the password on the command line,\n            // so see if it was passed in the environment (not ideal, but safer)\n            password = System.getenv(\"schemaspy.pw\");\n        }\n        return password;\n    }\n\n    /**\n     * Set to <code>true</code> to prompt for the password\n     * @param promptForPassword\n     */\n    public void setPromptForPasswordEnabled(boolean promptForPassword) {\n        this.promptForPassword = promptForPassword;\n    }\n\n    /**\n     * @see #setPromptForPasswordEnabled(boolean)\n     * @return\n     */\n    public boolean isPromptForPasswordEnabled() {\n        if (promptForPassword == null) {\n            promptForPassword = options.remove(\"-pfp\");\n        }\n        return promptForPassword;\n    }\n\n    public void setMaxDetailedTabled(int maxDetailedTables) {\n        this.maxDetailedTables = new Integer(maxDetailedTables);\n    }\n\n    public int getMaxDetailedTables() {\n        if (maxDetailedTables == null) {\n            // default\n            int max = 300;\n            try {\n                max = Integer.parseInt(pullParam(\"-maxdet\"));\n            } catch (Exception notSpecified) {\n            }\n            maxDetailedTables = new Integer(max);\n        }\n        return maxDetailedTables.intValue();\n    }\n\n    public String getConnectionPropertiesFile() {\n        return userConnectionPropertiesFile;\n    }\n\n    /**\n     * Properties from this file (in key=value pair format) are passed to the\n     * database connection.<br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.\n     * @param propertiesFilename\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public void setConnectionPropertiesFile(String propertiesFilename) throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null)\n            userConnectionProperties = new Properties();\n        userConnectionProperties.load(new FileInputStream(propertiesFilename));\n        userConnectionPropertiesFile = propertiesFilename;\n    }\n\n    /**\n     * Returns a {@link Properties} populated either from the properties file specified\n     * by {@link #setConnectionPropertiesFile(String)}, the properties specified by\n     * {@link #setConnectionProperties(String)} or not populated.\n     * @return\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public Properties getConnectionProperties() throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null) {\n            String props = pullParam(\"-connprops\");\n            if (props != null) {\n                if (props.indexOf(ESCAPED_EQUALS) != -1) {\n                    setConnectionProperties(props);\n                } else {\n                    setConnectionPropertiesFile(props);\n                }\n            } else {\n                userConnectionProperties = new Properties();\n            }\n        }\n        return userConnectionProperties;\n    }\n\n    /**\n     * Specifies connection properties to use in the format:\n     * <code>key1\\=value1;key2\\=value2</code><br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.<p>\n     * This is an alternative form of passing connection properties than by file\n     * (see {@link #setConnectionPropertiesFile(String)})\n     *\n     * @param properties\n     */\n    public void setConnectionProperties(String properties) {\n        userConnectionProperties = new Properties();\n        StringTokenizer tokenizer = new StringTokenizer(properties, \";\");\n        while (tokenizer.hasMoreElements()) {\n            String pair = tokenizer.nextToken();\n            int index = pair.indexOf(ESCAPED_EQUALS);\n            if (index != -1) {\n                String key = pair.substring(0, index);\n                String value = pair.substring(index + ESCAPED_EQUALS.length());\n                userConnectionProperties.put(key, value);\n            }\n        }\n    }\n\n    public void setDriverPath(String driverPath) {\n        this.driverPath = driverPath;\n    }\n\n    public String getDriverPath() {\n        if (driverPath == null)\n            driverPath = pullParam(\"-dp\");\n        // was previously -cp:\n        if (driverPath == null)\n            driverPath = pullParam(\"-cp\");\n        return driverPath;\n    }\n\n    /**\n     * The filename of the cascading style sheet to use.\n     * Note that this file is parsed and used to determine characteristics\n     * of the generated diagrams, so it must contain specific settings that\n     * are documented within schemaSpy.css.<p>\n     *\n     * Defaults to <code>\"schemaSpy.css\"</code>.\n     *\n     * @param css\n     */\n    public void setCss(String css) {\n        this.css = css;\n    }\n\n    public String getCss() {\n        if (css == null) {\n            css = pullParam(\"-css\");\n            if (css == null)\n                css = \"schemaSpy.css\";\n        }\n        return css;\n    }\n\n    /**\n     * The font to use within diagrams.  Modify the .css to specify HTML fonts.\n     *\n     * @param font\n     */\n    public void setFont(String font) {\n        this.font = font;\n    }\n\n    /**\n     * @see #setFont(String)\n     */\n    public String getFont() {\n        if (font == null) {\n            font = pullParam(\"-font\");\n            if (font == null)\n                font = \"Helvetica\";\n        }\n        return font;\n    }\n\n    /**\n     * The font size to use within diagrams.  This is the size of the font used for\n     * 'large' (e.g. not 'compact') diagrams.<p>\n     *\n     * Modify the .css to specify HTML font sizes.<p>\n     *\n     * Defaults to 11.\n     *\n     * @param fontSize\n     */\n    public void setFontSize(int fontSize) {\n        this.fontSize = new Integer(fontSize);\n    }\n\n    /**\n     * @see #setFontSize(int)\n     * @return\n     */\n    public int getFontSize() {\n        if (fontSize == null) {\n            // default\n            int size = 11;\n            try {\n                size = Integer.parseInt(pullParam(\"-fontsize\"));\n            } catch (Exception notSpecified) {\n            }\n            fontSize = new Integer(size);\n        }\n        return fontSize.intValue();\n    }\n\n    /**\n     * The character set to use within HTML pages (defaults to <code>\"ISO-8859-1\"</code>).\n     *\n     * @param charset\n     */\n    public void setCharset(String charset) {\n        this.charset = charset;\n    }\n\n    /**\n     * @see #setCharset(String)\n     */\n    public String getCharset() {\n        if (charset == null) {\n            charset = pullParam(\"-charset\");\n            if (charset == null)\n                charset = \"ISO-8859-1\";\n        }\n        return charset;\n    }\n\n    /**\n     * Description of schema that gets display on main pages.\n     *\n     * @param description\n     */\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    /**\n     * @see #setDescription(String)\n     */\n    public String getDescription() {\n        if (description == null)\n            description = pullParam(\"-desc\");\n        return description;\n    }\n\n    /**\n     * Maximum number of threads to use when querying database metadata information.\n     *\n     * @param maxDbThreads\n     */\n    public void setMaxDbThreads(int maxDbThreads) {\n        this.maxDbThreads = new Integer(maxDbThreads);\n    }\n\n    /**\n     * @see #setMaxDbThreads(int)\n     * @throws InvalidConfigurationException if unable to load properties\n     */\n    public int getMaxDbThreads() throws InvalidConfigurationException {\n        if (maxDbThreads == null) {\n            Properties properties;\n            try {\n                properties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(\"Failed to load properties for \" + getDbType() + \": \" + exc).setParamName(\"-type\");\n            }\n            // not scientifically derived\n            final int defaultMax = 15;\n            int max = defaultMax;\n            String threads = properties.getProperty(\"dbThreads\");\n            if (threads == null)\n                threads = properties.getProperty(\"dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            threads = pullParam(\"-dbThreads\");\n            if (threads == null)\n                threads = pullParam(\"-dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            if (max < 0)\n                max = defaultMax;\n            else if (max == 0)\n                max = 1;\n            maxDbThreads = new Integer(max);\n        }\n        return maxDbThreads.intValue();\n    }\n\n    public boolean isLogoEnabled() {\n        if (logoEnabled == null)\n            logoEnabled = !options.remove(\"-nologo\");\n        return logoEnabled;\n    }\n\n    /**\n     * Don't use this unless absolutely necessary as it screws up the layout\n     *\n     * @param enabled\n     */\n    public void setRankDirBugEnabled(boolean enabled) {\n        rankDirBugEnabled = enabled;\n    }\n\n    /**\n     * @see #setRankDirBugEnabled(boolean)\n     */\n    public boolean isRankDirBugEnabled() {\n        if (rankDirBugEnabled == null)\n            rankDirBugEnabled = options.remove(\"-rankdirbug\");\n        return rankDirBugEnabled;\n    }\n\n    /**\n     * Look for Ruby on Rails-based naming conventions in\n     * relationships between logical foreign keys and primary keys.<p>\n     *\n     * Basically all tables have a primary key named <code>ID</code>.\n     * All tables are named plural names.\n     * The columns that logically reference that <code>ID</code> are the singular\n     * form of the table name suffixed with <code>_ID</code>.<p>\n     *\n     * @param enabled\n     */\n    public void setRailsEnabled(boolean enabled) {\n        railsEnabled = enabled;\n    }\n\n    /**\n     * @see #setRailsEnabled(boolean)\n     *\n     * @return\n     */\n    public boolean isRailsEnabled() {\n        if (railsEnabled == null)\n            railsEnabled = options.remove(\"-rails\");\n        return railsEnabled;\n    }\n\n    /**\n     * Allow Html In Comments - encode them unless otherwise specified\n     */\n    public void setEncodeCommentsEnabled(boolean enabled) {\n        encodeCommentsEnabled = enabled;\n    }\n\n    /**\n     * @see #setEncodeCommentsEnabled(boolean)\n     */\n    public boolean isEncodeCommentsEnabled() {\n        if (encodeCommentsEnabled == null)\n            encodeCommentsEnabled = !options.remove(\"-ahic\");\n        return encodeCommentsEnabled;\n    }\n\n    /**\n     * If enabled we'll attempt to query/render the number of rows that\n     * each table contains.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setNumRowsEnabled(boolean enabled) {\n        numRowsEnabled = enabled;\n    }\n\n    /**\n     * @see #setNumRowsEnabled(boolean)\n     * @return\n     */\n    public boolean isNumRowsEnabled() {\n        if (numRowsEnabled == null)\n            numRowsEnabled = !options.remove(\"-norows\");\n        return numRowsEnabled;\n    }\n\n    /**\n     * If enabled we'll include views in the analysis.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setViewsEnabled(boolean enabled) {\n        viewsEnabled = enabled;\n    }\n\n    /**\n     * @see #setViewsEnabled(boolean)\n     * @return\n     */\n    public boolean isViewsEnabled() {\n        if (viewsEnabled == null)\n            viewsEnabled = !options.remove(\"-noviews\");\n        return viewsEnabled;\n    }\n\n    /**\n     * Returns <code>true</code> if metering should be embedded in\n     * the generated pages.<p/>\n     * Defaults to <code>false</code> (disabled).\n     * @return\n     */\n    public boolean isMeterEnabled() {\n        if (meterEnabled == null)\n            meterEnabled = options.remove(\"-meter\");\n        return meterEnabled;\n    }\n\n    /**\n     * Set the columns to exclude from all relationship diagrams.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setColumnExclusions(String columnExclusions) {\n        this.columnExclusions = Pattern.compile(columnExclusions);\n    }\n\n    /**\n     * See {@link #setColumnExclusions(String)}\n     * @return\n     */\n    public Pattern getColumnExclusions() {\n        if (columnExclusions == null) {\n            String strExclusions = pullParam(\"-X\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.columnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            columnExclusions = Pattern.compile(strExclusions);\n        }\n        return columnExclusions;\n    }\n\n    /**\n     * Set the columns to exclude from relationship diagrams where the specified\n     * columns aren't directly referenced by the focal table.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setIndirectColumnExclusions(String fullColumnExclusions) {\n        indirectColumnExclusions = Pattern.compile(fullColumnExclusions);\n    }\n\n    /**\n     * @see #setIndirectColumnExclusions(String)\n     *\n     * @return\n     */\n    public Pattern getIndirectColumnExclusions() {\n        if (indirectColumnExclusions == null) {\n            String strExclusions = pullParam(\"-x\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.indirectColumnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            indirectColumnExclusions = Pattern.compile(strExclusions);\n        }\n        return indirectColumnExclusions;\n    }\n\n    /**\n     * Set the tables to include as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableInclusions(String tableInclusions) {\n        this.tableInclusions = Pattern.compile(tableInclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to include in the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableInclusions() {\n        if (tableInclusions == null) {\n            String strInclusions = pullParam(\"-i\");\n            if (strInclusions == null)\n                strInclusions = System.getenv(\"schemaspy.tableInclusions\");\n            if (strInclusions == null)\n                strInclusions = DEFAULT_TABLE_INCLUSION;\n            try {\n                tableInclusions = Pattern.compile(strInclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-i\");\n            }\n        }\n        return tableInclusions;\n    }\n\n    /**\n     * Set the tables to exclude as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableExclusions(String tableExclusions) {\n        this.tableExclusions = Pattern.compile(tableExclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to exclude from the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableExclusions() {\n        if (tableExclusions == null) {\n            String strExclusions = pullParam(\"-I\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.tableExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_TABLE_EXCLUSION;\n            try {\n                tableExclusions = Pattern.compile(strExclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-I\");\n            }\n        }\n        return tableExclusions;\n    }\n\n    /**\n     * @return\n     */\n    public List<String> getSchemas() {\n        if (schemas == null) {\n            String tmp = pullParam(\"-schemas\");\n            if (tmp == null)\n                tmp = pullParam(\"-schemata\");\n            if (tmp != null) {\n                schemas = new ArrayList<String>();\n                for (String name : tmp.split(\"[\\\\s,'\\\"]\")) {\n                    if (name.length() > 0)\n                        schemas.add(name);\n                }\n                if (schemas.isEmpty())\n                    schemas = null;\n            }\n        }\n        return schemas;\n    }\n\n    /**\n     * Set the name of the {@link SqlFormatter SQL formatter} class to use to\n     * format SQL into HTML.<p/>\n     * The implementation of the class must be made available to the class\n     * loader, typically by specifying the path to its jar with <em>-dp</em>\n     * ({@link #setDriverPath(String)}).\n     */\n    public void setSqlFormatter(String formatterClassName) {\n        sqlFormatterClass = formatterClassName;\n        sqlFormatter = null;\n    }\n\n    /**\n     * Set the {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.\n     */\n    public void setSqlFormatter(SqlFormatter sqlFormatter) {\n        this.sqlFormatter = sqlFormatter;\n        if (sqlFormatter != null)\n            sqlFormatterClass = sqlFormatter.getClass().getName();\n    }\n\n    /**\n     * Returns an implementation of {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.  The default implementation is {@link DefaultSqlFormatter}.\n     *\n     * @return\n     * @throws InvalidConfigurationException if unable to instantiate an instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SqlFormatter getSqlFormatter() throws InvalidConfigurationException {\n        if (sqlFormatter == null) {\n            if (sqlFormatterClass == null) {\n                sqlFormatterClass = pullParam(\"-sqlFormatter\");\n                if (sqlFormatterClass == null)\n                    sqlFormatterClass = DefaultSqlFormatter.class.getName();\n            }\n            try {\n                Class<SqlFormatter> clazz = (Class<SqlFormatter>) Class.forName(sqlFormatterClass);\n                sqlFormatter = clazz.newInstance();\n            } catch (Exception exc) {\n                throw new InvalidConfigurationException(\"Failed to initialize instance of SQL formatter: \", exc).setParamName(\"-sqlFormatter\");\n            }\n        }\n        return sqlFormatter;\n    }\n\n    /**\n     * Set the details to show on the columns page, where \"details\" are\n     * comma and/or space separated.\n     *\n     * Valid values:\n     * <ul>\n     * <li>id</li>\n     * <li>table</li>\n     * <li>column</li>\n     * <li>type</li>\n     * <li>size</li>\n     * <li>nulls</li>\n     * <li>auto</li>\n     * <li>default</li>\n     * <li>children</li>\n     * <li>parents</li>\n     * </ul>\n     *\n     * The default details are <code>\"table column type size nulls auto default\"</code>.\n     * Note that \"column\" is the initially displayed detail and must be included.\n     *\n     * @param columnDetails\n     */\n    public void setColumnDetails(String columnDetails) {\n        this.columnDetails = new ArrayList<String>();\n        if (columnDetails == null || columnDetails.length() == 0) {\n            // not specified, so use defaults\n            columnDetails = \"id table column type size nulls auto default\";\n        }\n        for (String detail : columnDetails.split(\"[\\\\s,'\\\"]\")) {\n            if (detail.length() > 0) {\n                this.columnDetails.add(detail.toLowerCase());\n            }\n        }\n        if (!this.columnDetails.contains(\"column\"))\n            throw new InvalidConfigurationException(\"'column' is a required column detail\");\n    }\n\n    public void setColumnDetails(List<String> columnDetails) {\n        String details = columnDetails == null ? \"[]\" : columnDetails.toString();\n        setColumnDetails(details.substring(1, details.length() - 1));\n    }\n\n    public List<String> getColumnDetails() {\n        if (columnDetails == null) {\n            setColumnDetails(pullParam(\"-columndetails\"));\n        }\n        return columnDetails;\n    }\n\n    public void setEvaluateAllEnabled(boolean enabled) {\n        evaluteAll = enabled;\n    }\n\n    public boolean isEvaluateAllEnabled() {\n        if (evaluteAll == null)\n            evaluteAll = options.remove(\"-all\");\n        return evaluteAll;\n    }\n\n    /**\n     * Returns true if we're evaluating a bunch of schemas in one go and\n     * at this point we're evaluating a specific schema.\n     *\n     * @return boolean\n     */\n    public boolean isOneOfMultipleSchemas() {\n        // set by MultipleSchemaAnalyzer\n        return Boolean.getBoolean(\"oneofmultipleschemas\");\n    }\n\n    /**\n     * When -all (evaluateAll) is specified then this is the regular\n     * expression that determines which schemas to evaluate.\n     *\n     * @param schemaSpec\n     */\n    public void setSchemaSpec(String schemaSpec) {\n        this.schemaSpec = schemaSpec;\n    }\n\n    public String getSchemaSpec() {\n        if (schemaSpec == null)\n            schemaSpec = pullParam(\"-schemaSpec\");\n        return schemaSpec;\n    }\n\n    /**\n     * Set the renderer to use for the -Tpng[:renderer[:formatter]] dot option as specified\n     * at <a href='http://www.graphviz.org/doc/info/command.html'>\n     * http://www.graphviz.org/doc/info/command.html</a>.<p>\n     * Note that the leading \":\" is required while :formatter is optional.<p>\n     * The default renderer is typically GD.<p>\n     * Note that using {@link #setHighQuality(boolean)} is the preferred approach\n     * over using this method.\n     */\n    public void setRenderer(String renderer) {\n        Dot.getInstance().setRenderer(renderer);\n    }\n\n    /**\n     * @see #setRenderer(String)\n     * @return\n     */\n    public String getRenderer() {\n        String renderer = pullParam(\"-renderer\");\n        if (renderer != null)\n            setRenderer(renderer);\n        return Dot.getInstance().getRenderer();\n    }\n\n    /**\n     * If <code>false</code> then generate output of \"lower quality\"\n     * than the default.\n     * Note that the default is intended to be \"higher quality\",\n     * but various installations of Graphviz may have have different abilities.\n     * That is, some might not have the \"lower quality\" libraries and others might\n     * not have the \"higher quality\" libraries.<p>\n     * Higher quality output takes longer to generate and results in significantly\n     * larger image files (which take longer to download / display), but it generally\n     * looks better.\n     */\n    public void setHighQuality(boolean highQuality) {\n        this.highQuality = highQuality;\n        lowQuality = !highQuality;\n        Dot.getInstance().setHighQuality(highQuality);\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isHighQuality() {\n        if (highQuality == null) {\n            highQuality = options.remove(\"-hq\");\n            if (highQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(highQuality);\n            }\n        }\n        highQuality = Dot.getInstance().isHighQuality();\n        return highQuality;\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isLowQuality() {\n        if (lowQuality == null) {\n            lowQuality = options.remove(\"-lq\");\n            if (lowQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(!lowQuality);\n            }\n        }\n        lowQuality = !Dot.getInstance().isHighQuality();\n        return lowQuality;\n    }\n\n    /**\n     * Set the level of logging to perform.<p/>\n     * The levels in descending order are:\n     * <ul>\n     *  <li><code>severe</code> (highest - least detail)\n     *  <li><code>warning</code> (default)\n     *  <li><code>info</code>\n     *  <li><code>config</code>\n     *  <li><code>fine</code>\n     *  <li><code>finer</code>\n     *  <li><code>finest</code>  (lowest - most detail)\n     * </ul>\n     *\n     * @param logLevel\n     */\n    public void setLogLevel(String logLevel) {\n        if (logLevel == null) {\n            this.logLevel = Level.WARNING;\n            return;\n        }\n        Map<String, Level> levels = new LinkedHashMap<String, Level>();\n        levels.put(\"severe\", Level.SEVERE);\n        levels.put(\"warning\", Level.WARNING);\n        levels.put(\"info\", Level.INFO);\n        levels.put(\"config\", Level.CONFIG);\n        levels.put(\"fine\", Level.FINE);\n        levels.put(\"finer\", Level.FINER);\n        levels.put(\"finest\", Level.FINEST);\n        this.logLevel = levels.get(logLevel.toLowerCase());\n        if (this.logLevel == null) {\n            throw new InvalidConfigurationException(\"Invalid logLevel: '\" + logLevel + \"'. Must be one of: \" + levels.keySet());\n        }\n    }\n\n    /**\n     * Returns the level of logging to perform.\n     * See {@link #setLogLevel(String)}.\n     *\n     * @return\n     */\n    public Level getLogLevel() {\n        if (logLevel == null) {\n            setLogLevel(pullParam(\"-loglevel\"));\n        }\n        return logLevel;\n    }\n\n    /**\n     * Returns <code>true</code> if the options indicate that the user wants\n     * to see some help information.\n     *\n     * @return\n     */\n    public boolean isHelpRequired() {\n        return helpRequired;\n    }\n\n    public boolean isDbHelpRequired() {\n        return dbHelpRequired;\n    }\n\n    /**\n     * Returns the jar that we were loaded from\n     *\n     * @return\n     */\n    public static String getLoadedFromJar() {\n        String classpath = System.getProperty(\"java.class.path\");\n        return new StringTokenizer(classpath, File.pathSeparator).nextToken();\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasOrphans(boolean hasOrphans) {\n        this.hasOrphans = hasOrphans;\n    }\n\n    /**\n     * @see #setHasOrphans()\n     *\n     * @return\n     */\n    public boolean hasOrphans() {\n        return hasOrphans;\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasRoutines(boolean hasRoutines) {\n        this.hasRoutines = hasRoutines;\n    }\n\n    /**\n     * @see #setHasRoutines()\n     *\n     * @return\n     */\n    public boolean hasRoutines() {\n        return hasRoutines;\n    }\n\n    /**\n     * Returns the database properties to use.\n     * These should be determined by calling {@link #determineDbProperties(String)}.\n     * @return\n     * @throws InvalidConfigurationException\n     */\n    public Properties getDbProperties() throws InvalidConfigurationException {\n        if (dbProperties == null) {\n            try {\n                dbProperties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(exc);\n            }\n        }\n        return dbProperties;\n    }\n\n    /**\n     * Determines the database properties associated with the specified type.\n     * A call to {@link #setDbProperties(Properties)} is expected after determining\n     * the complete set of properties.\n     *\n     * @param type\n     * @return\n     * @throws IOException\n     * @throws InvalidConfigurationException if db properties are incorrectly formed\n     */\n    public Properties determineDbProperties(String type) throws IOException, InvalidConfigurationException {\n        ResourceBundle bundle = null;\n        try {\n            File propertiesFile = new File(type);\n            bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n            dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n        } catch (FileNotFoundException notFoundOnFilesystemWithoutExtension) {\n            try {\n                File propertiesFile = new File(type + \".properties\");\n                bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n                dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n            } catch (FileNotFoundException notFoundOnFilesystemWithExtensionTackedOn) {\n                try {\n                    bundle = ResourceBundle.getBundle(type);\n                    dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]\" + File.separator + type + \".properties\";\n                } catch (Exception notInJarWithoutPath) {\n                    try {\n                        String path = TableOrderer.class.getPackage().getName() + \".dbTypes.\" + type;\n                        path = path.replace('.', '/');\n                        bundle = ResourceBundle.getBundle(path);\n                        dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]/\" + path + \".properties\";\n                    } catch (Exception notInJar) {\n                        notInJar.printStackTrace();\n                        notFoundOnFilesystemWithExtensionTackedOn.printStackTrace();\n                        throw notFoundOnFilesystemWithoutExtension;\n                    }\n                }\n            }\n        }\n        Properties props = asProperties(bundle);\n        bundle = null;\n        // keep original thru recursion\n        String saveLoadedFrom = dbPropertiesLoadedFrom;\n        // bring in key/values pointed to by the include directive\n        // example: include.1=mysql::selectRowCountSql\n        for (int i = 1; true; ++i) {\n            String include = (String) props.remove(\"include.\" + i);\n            if (include == null)\n                break;\n            int separator = include.indexOf(\"::\");\n            if (separator == -1)\n                throw new InvalidConfigurationException(\"include directive in \" + dbPropertiesLoadedFrom + \" must have '::' between dbType and key\");\n            String refdType = include.substring(0, separator).trim();\n            String refdKey = include.substring(separator + 2).trim();\n            // recursively resolve the ref'd properties file and the ref'd key\n            Properties refdProps = determineDbProperties(refdType);\n            props.put(refdKey, refdProps.getProperty(refdKey));\n        }\n        // bring in base properties files pointed to by the extends directive\n        String baseDbType = (String) props.remove(\"extends\");\n        if (baseDbType != null) {\n            baseDbType = baseDbType.trim();\n            Properties baseProps = determineDbProperties(baseDbType);\n            // overlay our properties on top of the base's\n            baseProps.putAll(props);\n            props = baseProps;\n        }\n        // done with this level of recursion...restore original\n        dbPropertiesLoadedFrom = saveLoadedFrom;\n        // this won't be correct until the final recursion exits\n        dbProperties = props;\n        return props;\n    }\n\n    protected String getDbPropertiesLoadedFrom() throws IOException {\n        if (dbPropertiesLoadedFrom == null)\n            determineDbProperties(getDbType());\n        return dbPropertiesLoadedFrom;\n    }\n\n    public List<String> getRemainingParameters() {\n        try {\n            populate();\n        } catch (IllegalArgumentException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (IllegalAccessException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (InvocationTargetException exc) {\n            if (exc.getCause() instanceof InvalidConfigurationException)\n                throw (InvalidConfigurationException) exc.getCause();\n            throw new InvalidConfigurationException(exc.getCause());\n        } catch (IntrospectionException exc) {\n            throw new InvalidConfigurationException(exc);\n        }\n        return options;\n    }\n\n    /**\n     * Options that are specific to a type of database.  E.g. things like <code>host</code>,\n     * <code>port</code> or <code>db</code>, but <b>don't</b> have a setter in this class.\n     *\n     * @param dbSpecificOptions\n     */\n    public void setDbSpecificOptions(Map<String, String> dbSpecificOptions) {\n        this.dbSpecificOptions = dbSpecificOptions;\n        originalDbSpecificOptions = new HashMap<String, String>(dbSpecificOptions);\n    }\n\n    public Map<String, String> getDbSpecificOptions() {\n        if (dbSpecificOptions == null)\n            dbSpecificOptions = new HashMap<String, String>();\n        return dbSpecificOptions;\n    }\n\n    /**\n     * Returns a {@link Properties} populated with the contents of <code>bundle</code>\n     *\n     * @param bundle ResourceBundle\n     * @return Properties\n     */\n    public static Properties asProperties(ResourceBundle bundle) {\n        Properties props = new Properties();\n        Enumeration<String> iter = bundle.getKeys();\n        while (iter.hasMoreElements()) {\n            String key = iter.nextElement();\n            props.put(key, bundle.getObject(key));\n        }\n        return props;\n    }\n\n    /**\n     * 'Pull' the specified parameter from the collection of options. Returns\n     * null if the parameter isn't in the list and removes it if it is.\n     *\n     * @param paramId\n     * @return\n     */\n    private String pullParam(String paramId) {\n        return pullParam(paramId, false, false);\n    }\n\n    private String pullRequiredParam(String paramId) {\n        return pullParam(paramId, true, false);\n    }\n\n    /**\n     * @param paramId\n     * @param required\n     * @param dbTypeSpecific\n     * @return\n     * @throws MissingRequiredParameterException\n     */\n    private String pullParam(String paramId, boolean required, boolean dbTypeSpecific) throws MissingRequiredParameterException {\n        int paramIndex = options.indexOf(paramId);\n        if (paramIndex < 0) {\n            if (required)\n                throw new MissingRequiredParameterException(paramId, dbTypeSpecific);\n            return null;\n        }\n        options.remove(paramIndex);\n        String param = options.get(paramIndex).toString();\n        options.remove(paramIndex);\n        return param;\n    }\n\n    /**\n     * Thrown to indicate that a required parameter is missing\n     */\n    public static class MissingRequiredParameterException extends RuntimeException {\n\n        private static final long serialVersionUID = 1L;\n\n        private final boolean dbTypeSpecific;\n\n        public MissingRequiredParameterException(String paramId, boolean dbTypeSpecific) {\n            this(paramId, null, dbTypeSpecific);\n        }\n\n        public MissingRequiredParameterException(String paramId, String description, boolean dbTypeSpecific) {\n            super(\"Required parameter '\" + paramId + \"' \" + (description == null ? \"\" : \"(\" + description + \") \") + \"was not specified.\" + (dbTypeSpecific ? \"  It is required for this database type.\" : \"\"));\n            this.dbTypeSpecific = dbTypeSpecific;\n        }\n\n        public boolean isDbTypeSpecific() {\n            return dbTypeSpecific;\n        }\n    }\n\n    /**\n     * Allow an equal sign in args...like \"-o=foo.bar\". Useful for things like\n     * Ant and Maven.\n     *\n     * @param args\n     *            List\n     * @return List\n     */\n    protected List<String> fixupArgs(List<String> args) {\n        List<String> expandedArgs = new ArrayList<String>();\n        for (String arg : args) {\n            int indexOfEquals = arg.indexOf('=');\n            if (indexOfEquals != -1 && indexOfEquals - 1 != arg.indexOf(ESCAPED_EQUALS)) {\n                expandedArgs.add(arg.substring(0, indexOfEquals));\n                expandedArgs.add(arg.substring(indexOfEquals + 1));\n            } else {\n                expandedArgs.add(arg);\n            }\n        }\n        // some OSes/JVMs do filename expansion with runtime.exec() and some don't,\n        // so MultipleSchemaAnalyzer has to surround params with double quotes...\n        // strip them here for the OSes/JVMs that don't do anything with the params\n        List<String> unquotedArgs = new ArrayList<String>();\n        for (String arg : expandedArgs) {\n            if (// \".*\" becomes .*\n            arg.startsWith(\"\\\"\") && arg.endsWith(\"\\\"\"))\n                arg = arg.substring(1, arg.length() - 1);\n            unquotedArgs.add(arg);\n        }\n        return unquotedArgs;\n    }\n\n    /**\n     * Call all the getters to populate all the lazy initialized stuff.\n     *\n     * @throws InvocationTargetException\n     * @throws IllegalAccessException\n     * @throws IllegalArgumentException\n     * @throws IntrospectionException\n     */\n    private void populate() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IntrospectionException {\n        if (!populating) {\n            // prevent recursion\n            populating = true;\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                Method readMethod = props[i].getReadMethod();\n                if (readMethod != null)\n                    readMethod.invoke(this, (Object[]) null);\n            }\n            populating = false;\n        }\n    }\n\n    public static Set<String> getBuiltInDatabaseTypes(String loadedFromJar) {\n        Set<String> databaseTypes = new TreeSet<String>();\n        JarInputStream jar = null;\n        try {\n            jar = new JarInputStream(new FileInputStream(loadedFromJar));\n            JarEntry entry;\n            while ((entry = jar.getNextJarEntry()) != null) {\n                String entryName = entry.getName();\n                int dotPropsIndex = entryName.indexOf(\".properties\");\n                if (dotPropsIndex != -1)\n                    databaseTypes.add(entryName.substring(0, dotPropsIndex));\n            }\n        } catch (IOException exc) {\n        } finally {\n            if (jar != null) {\n                try {\n                    jar.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n        return databaseTypes;\n    }\n\n    protected void dumpUsage(String errorMessage, boolean detailedDb) {\n        if (errorMessage != null) {\n            System.out.flush();\n            System.err.println(\"*** \" + errorMessage + \" ***\");\n        } else {\n            System.out.println(\"SchemaSpy generates an HTML representation of a database schema's relationships.\");\n        }\n        System.err.flush();\n        System.out.println();\n        if (!detailedDb) {\n            System.out.println(\"Usage:\");\n            System.out.println(\" java -jar \" + getLoadedFromJar() + \" [options]\");\n            System.out.println(\"   -t databaseType       type of database - defaults to ora\");\n            System.out.println(\"                           use -dbhelp for a list of built-in types\");\n            System.out.println(\"   -u user               connect to the database with this user id\");\n            System.out.println(\"   -s schema             defaults to the specified user\");\n            System.out.println(\"   -p password           defaults to no password\");\n            System.out.println(\"   -o outputDirectory    directory to place the generated output in\");\n            System.out.println(\"   -dp pathToDrivers     optional - looks for JDBC drivers here before looking\");\n            System.out.println(\"                           in driverPath in [databaseType].properties.\");\n            System.out.println(\"Go to http://schemaspy.sourceforge.net for a complete list/description\");\n            System.out.println(\" of additional parameters.\");\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"Built-in database types and their required connection parameters:\");\n            for (String type : getBuiltInDatabaseTypes(getLoadedFromJar())) {\n                new DbSpecificConfig(type).dumpUsage();\n            }\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"You can use your own database types by specifying the filespec of a .properties file with -t.\");\n            System.out.println(\"Grab one out of \" + getLoadedFromJar() + \" and modify it to suit your needs.\");\n            System.out.println();\n        }\n        System.out.println(\"Sample usage using the default database type (implied -t ora):\");\n        System.out.println(\" java -jar schemaSpy.jar -db mydb -s myschema -u devuser -p password -o output\");\n        System.out.println();\n        System.out.flush();\n    }\n\n    /**\n     * Get the value of the specified parameter.\n     * Used for properties that are common to most db's, but aren't required.\n     *\n     * @param paramName\n     * @return\n     */\n    public String getParam(String paramName) {\n        try {\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                PropertyDescriptor prop = props[i];\n                if (prop.getName().equalsIgnoreCase(paramName)) {\n                    Object result = prop.getReadMethod().invoke(this, (Object[]) null);\n                    return result == null ? null : result.toString();\n                }\n            }\n        } catch (Exception failed) {\n            failed.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * Return all of the configuration options as a List of Strings, with\n     * each parameter and its value as a separate element.\n     *\n     * @return\n     * @throws IOException\n     */\n    public List<String> asList() throws IOException {\n        List<String> params = new ArrayList<String>();\n        if (originalDbSpecificOptions != null) {\n            for (String key : originalDbSpecificOptions.keySet()) {\n                String value = originalDbSpecificOptions.get(key);\n                if (!key.startsWith(\"-\"))\n                    key = \"-\" + key;\n                params.add(key);\n                params.add(value);\n            }\n        }\n        if (isEncodeCommentsEnabled())\n            params.add(\"-ahic\");\n        if (isEvaluateAllEnabled())\n            params.add(\"-all\");\n        if (!isHtmlGenerationEnabled())\n            params.add(\"-nohtml\");\n        if (!isImpliedConstraintsEnabled())\n            params.add(\"-noimplied\");\n        if (!isLogoEnabled())\n            params.add(\"-nologo\");\n        if (isMeterEnabled())\n            params.add(\"-meter\");\n        if (!isNumRowsEnabled())\n            params.add(\"-norows\");\n        if (!isViewsEnabled())\n            params.add(\"-noviews\");\n        if (isRankDirBugEnabled())\n            params.add(\"-rankdirbug\");\n        if (isRailsEnabled())\n            params.add(\"-rails\");\n        if (isSingleSignOn())\n            params.add(\"-sso\");\n        if (isSchemaDisabled())\n            params.add(\"-noschema\");\n        String value = getDriverPath();\n        if (value != null) {\n            params.add(\"-dp\");\n            params.add(value);\n        }\n        params.add(\"-css\");\n        params.add(getCss());\n        params.add(\"-charset\");\n        params.add(getCharset());\n        params.add(\"-font\");\n        params.add(getFont());\n        params.add(\"-fontsize\");\n        params.add(String.valueOf(getFontSize()));\n        params.add(\"-t\");\n        params.add(getDbType());\n        // query to set renderer correctly\n        isHighQuality();\n        // query to set renderer correctly\n        isLowQuality();\n        // instead of -hq and/or -lq\n        params.add(\"-renderer\");\n        params.add(getRenderer());\n        value = getDescription();\n        if (value != null) {\n            params.add(\"-desc\");\n            params.add(value);\n        }\n        value = getPassword();\n        if (value != null && !isPromptForPasswordEnabled()) {\n            // note that we don't pass -pfp since child processes\n            // won't have a console\n            params.add(\"-p\");\n            params.add(value);\n        }\n        value = getCatalog();\n        if (value != null) {\n            params.add(\"-cat\");\n            params.add(value);\n        }\n        value = getSchema();\n        if (value != null) {\n            params.add(\"-s\");\n            params.add(value);\n        }\n        value = getUser();\n        if (value != null) {\n            params.add(\"-u\");\n            params.add(value);\n        }\n        value = getConnectionPropertiesFile();\n        if (value != null) {\n            params.add(\"-connprops\");\n            params.add(value);\n        } else {\n            Properties props = getConnectionProperties();\n            if (!props.isEmpty()) {\n                params.add(\"-connprops\");\n                StringBuilder buf = new StringBuilder();\n                for (Entry<Object, Object> entry : props.entrySet()) {\n                    buf.append(entry.getKey());\n                    buf.append(ESCAPED_EQUALS);\n                    buf.append(entry.getValue());\n                    buf.append(';');\n                }\n                params.add(buf.toString());\n            }\n        }\n        value = getDb();\n        if (value != null) {\n            params.add(\"-db\");\n            params.add(value);\n        }\n        value = getHost();\n        if (value != null) {\n            params.add(\"-host\");\n            params.add(value);\n        }\n        if (getPort() != null) {\n            params.add(\"-port\");\n            params.add(getPort().toString());\n        }\n        value = getServer();\n        if (value != null) {\n            params.add(\"-server\");\n            params.add(value);\n        }\n        value = getMeta();\n        if (value != null) {\n            params.add(\"-meta\");\n            params.add(value);\n        }\n        if (getGraphvizDir() != null) {\n            params.add(\"-gv\");\n            params.add(getGraphvizDir().toString());\n        }\n        params.add(\"-loglevel\");\n        params.add(getLogLevel().toString().toLowerCase());\n        params.add(\"-sqlFormatter\");\n        params.add(getSqlFormatter().getClass().getName());\n        params.add(\"-i\");\n        params.add(getTableInclusions().toString());\n        params.add(\"-I\");\n        params.add(getTableExclusions().toString());\n        params.add(\"-X\");\n        params.add(getColumnExclusions().toString());\n        params.add(\"-x\");\n        params.add(getIndirectColumnExclusions().toString());\n        params.add(\"-dbthreads\");\n        params.add(String.valueOf(getMaxDbThreads()));\n        params.add(\"-maxdet\");\n        params.add(String.valueOf(getMaxDetailedTables()));\n        params.add(\"-o\");\n        params.add(getOutputDir().toString());\n        return params;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/ConfigTest20.java",
		"test_prompt": "// ConfigTest20.java\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Config}.\n* It contains ten unit test cases for the {@link Config#hasOrphans()} method.\n*/\nclass ConfigTest20 {"
	},
	{
		"original_code": "// Config.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\n\n/**\n * Configuration of a SchemaSpy run\n *\n * @author John Currier\n */\npublic class Config {\n\n    private static Config instance;\n\n    private final List<String> options;\n\n    private Map<String, String> dbSpecificOptions;\n\n    private Map<String, String> originalDbSpecificOptions;\n\n    private boolean helpRequired;\n\n    private boolean dbHelpRequired;\n\n    private File outputDir;\n\n    private File graphvizDir;\n\n    private String dbType;\n\n    private String catalog;\n\n    private String schema;\n\n    private List<String> schemas;\n\n    private String user;\n\n    private Boolean singleSignOn;\n\n    private Boolean noSchema;\n\n    private String password;\n\n    private Boolean promptForPassword;\n\n    private String db;\n\n    private String host;\n\n    private Integer port;\n\n    private String server;\n\n    private String meta;\n\n    private Pattern tableInclusions;\n\n    private Pattern tableExclusions;\n\n    private Pattern columnExclusions;\n\n    private Pattern indirectColumnExclusions;\n\n    private String userConnectionPropertiesFile;\n\n    private Properties userConnectionProperties;\n\n    private Integer maxDbThreads;\n\n    private Integer maxDetailedTables;\n\n    private String driverPath;\n\n    private String css;\n\n    private String charset;\n\n    private String font;\n\n    private Integer fontSize;\n\n    private String description;\n\n    private Properties dbProperties;\n\n    private String dbPropertiesLoadedFrom;\n\n    private Level logLevel;\n\n    private SqlFormatter sqlFormatter;\n\n    private String sqlFormatterClass;\n\n    private Boolean generateHtml;\n\n    private Boolean includeImpliedConstraints;\n\n    private Boolean logoEnabled;\n\n    private Boolean rankDirBugEnabled;\n\n    private Boolean encodeCommentsEnabled;\n\n    private Boolean numRowsEnabled;\n\n    private Boolean viewsEnabled;\n\n    private Boolean meterEnabled;\n\n    private Boolean railsEnabled;\n\n    private Boolean evaluteAll;\n\n    private Boolean highQuality;\n\n    private Boolean lowQuality;\n\n    // used in conjunction with evaluateAll\n    private String schemaSpec;\n\n    private boolean hasOrphans = false;\n\n    private boolean hasRoutines = false;\n\n    private boolean populating = false;\n\n    private List<String> columnDetails;\n\n    public static final String DOT_CHARSET = \"UTF-8\";\n\n    private static final String ESCAPED_EQUALS = \"\\\\=\";\n\n    // match everything\n    private static final String DEFAULT_TABLE_INCLUSION = \".*\";\n\n    // match nothing\n    private static final String DEFAULT_TABLE_EXCLUSION = \"\";\n\n    // match nothing\n    private static final String DEFAULT_COLUMN_EXCLUSION = \"[^.]\";\n\n    /**\n     * Default constructor. Intended for when you want to inject properties\n     * independently (i.e. not from a command line interface).\n     */\n    public Config() {\n        if (instance == null)\n            setInstance(this);\n        options = new ArrayList<String>();\n    }\n\n    /**\n     * Construct a configuration from an array of options (e.g. from a command\n     * line interface).\n     *\n     * @param options\n     */\n    public Config(String[] argv) {\n        setInstance(this);\n        options = fixupArgs(Arrays.asList(argv));\n        helpRequired = options.remove(\"-?\") || options.remove(\"/?\") || options.remove(\"?\") || options.remove(\"-h\") || options.remove(\"-help\") || options.remove(\"--help\");\n        dbHelpRequired = options.remove(\"-dbHelp\") || options.remove(\"-dbhelp\");\n    }\n\n    public static Config getInstance() {\n        if (instance == null)\n            instance = new Config();\n        return instance;\n    }\n\n    /**\n     * Sets the global instance.\n     *\n     * Useful for things like selecting a specific configuration in a UI.\n     *\n     * @param config\n     */\n    public static void setInstance(Config config) {\n        instance = config;\n    }\n\n    public void setHtmlGenerationEnabled(boolean generateHtml) {\n        this.generateHtml = generateHtml;\n    }\n\n    public boolean isHtmlGenerationEnabled() {\n        if (generateHtml == null)\n            generateHtml = !options.remove(\"-nohtml\");\n        return generateHtml;\n    }\n\n    public void setImpliedConstraintsEnabled(boolean includeImpliedConstraints) {\n        this.includeImpliedConstraints = includeImpliedConstraints;\n    }\n\n    public boolean isImpliedConstraintsEnabled() {\n        if (includeImpliedConstraints == null)\n            includeImpliedConstraints = !options.remove(\"-noimplied\");\n        return includeImpliedConstraints;\n    }\n\n    public void setOutputDir(String outputDirName) {\n        if (outputDirName.endsWith(\"\\\"\"))\n            outputDirName = outputDirName.substring(0, outputDirName.length() - 1);\n        setOutputDir(new File(outputDirName));\n    }\n\n    public void setOutputDir(File outputDir) {\n        this.outputDir = outputDir;\n    }\n\n    public File getOutputDir() {\n        if (outputDir == null) {\n            setOutputDir(pullRequiredParam(\"-o\"));\n        }\n        return outputDir;\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(String graphvizDir) {\n        if (graphvizDir.endsWith(\"\\\"\"))\n            graphvizDir = graphvizDir.substring(0, graphvizDir.length() - 1);\n        setGraphvizDir(new File(graphvizDir));\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(File graphvizDir) {\n        this.graphvizDir = graphvizDir;\n    }\n\n    /**\n     * Return the path to Graphviz (used to find the dot executable to run to\n     * generate ER diagrams).<p/>\n     *\n     * Returns {@link #getDefaultGraphvizPath()} if a specific Graphviz path\n     * was not specified.\n     *\n     * @return\n     */\n    public File getGraphvizDir() {\n        if (graphvizDir == null) {\n            String gv = pullParam(\"-gv\");\n            if (gv != null) {\n                setGraphvizDir(gv);\n            } else {\n                // expect to find Graphviz's bin directory on the PATH\n            }\n        }\n        return graphvizDir;\n    }\n\n    /**\n     * Meta files are XML-based files that provide additional metadata\n     * about the schema being evaluated.<p>\n     * <code>meta</code> is either the name of an individual XML file or\n     * the directory that contains meta files.<p>\n     * If a directory is specified then it is expected to contain files\n     * matching the pattern <code>[schema].meta.xml</code>.\n     * For databases that don't have schema substitute database for schema.\n     * @param meta\n     */\n    public void setMeta(String meta) {\n        this.meta = meta;\n    }\n\n    public String getMeta() {\n        if (meta == null)\n            meta = pullParam(\"-meta\");\n        return meta;\n    }\n\n    public void setDbType(String dbType) {\n        this.dbType = dbType;\n    }\n\n    public String getDbType() {\n        if (dbType == null) {\n            dbType = pullParam(\"-t\");\n            if (dbType == null)\n                dbType = \"ora\";\n        }\n        return dbType;\n    }\n\n    public void setDb(String db) {\n        this.db = db;\n    }\n\n    public String getDb() {\n        if (db == null)\n            db = pullParam(\"-db\");\n        return db;\n    }\n\n    public void setCatalog(String catalog) {\n        this.catalog = catalog;\n    }\n\n    public String getCatalog() {\n        if (catalog == null)\n            catalog = pullParam(\"-cat\");\n        return catalog;\n    }\n\n    public void setSchema(String schema) {\n        this.schema = schema;\n    }\n\n    public String getSchema() {\n        if (schema == null)\n            schema = pullParam(\"-s\");\n        return schema;\n    }\n\n    /**\n     * Some databases types (e.g. older versions of Informix) don't really\n     * have the concept of a schema but still return true from\n     * {@link DatabaseMetaData#supportsSchemasInTableDefinitions()}.\n     * This option lets you ignore that and treat all the tables\n     * as if they were in one flat namespace.\n     */\n    public boolean isSchemaDisabled() {\n        if (noSchema == null)\n            noSchema = options.remove(\"-noschema\");\n        return noSchema;\n    }\n\n    public void setHost(String host) {\n        this.host = host;\n    }\n\n    public String getHost() {\n        if (host == null)\n            host = pullParam(\"-host\");\n        return host;\n    }\n\n    public void setPort(Integer port) {\n        this.port = port;\n    }\n\n    public Integer getPort() {\n        if (port == null)\n            try {\n                port = Integer.valueOf(pullParam(\"-port\"));\n            } catch (Exception notSpecified) {\n            }\n        return port;\n    }\n\n    public void setServer(String server) {\n        this.server = server;\n    }\n\n    public String getServer() {\n        if (server == null) {\n            server = pullParam(\"-server\");\n        }\n        return server;\n    }\n\n    public void setUser(String user) {\n        this.user = user;\n    }\n\n    /**\n     * User used to connect to the database.\n     * Required unless single sign-on is enabled\n     * (see {@link #setSingleSignOn(boolean)}).\n     * @return\n     */\n    public String getUser() {\n        if (user == null) {\n            if (!isSingleSignOn())\n                user = pullRequiredParam(\"-u\");\n            else\n                user = pullParam(\"-u\");\n        }\n        return user;\n    }\n\n    /**\n     * By default a \"user\" (as specified with -u) is required.\n     * This option allows disabling of that requirement for\n     * single sign-on environments.\n     *\n     * @param enabled defaults to <code>false</code>\n     */\n    public void setSingleSignOn(boolean enabled) {\n        singleSignOn = enabled;\n    }\n\n    /**\n     * @see #setSingleSignOn(boolean)\n     */\n    public boolean isSingleSignOn() {\n        if (singleSignOn == null)\n            singleSignOn = options.remove(\"-sso\");\n        return singleSignOn;\n    }\n\n    /**\n     * Set the password used to connect to the database.\n     * @param password\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * @see #setPassword(String)\n     * @return\n     */\n    public String getPassword() {\n        if (password == null)\n            password = pullParam(\"-p\");\n        if (password == null && isPromptForPasswordEnabled())\n            password = new String(PasswordReader.getInstance().readPassword(\"Password: \"));\n        if (password == null) {\n            // if -pfp is enabled when analyzing multiple schemas then\n            // we don't want to send the password on the command line,\n            // so see if it was passed in the environment (not ideal, but safer)\n            password = System.getenv(\"schemaspy.pw\");\n        }\n        return password;\n    }\n\n    /**\n     * Set to <code>true</code> to prompt for the password\n     * @param promptForPassword\n     */\n    public void setPromptForPasswordEnabled(boolean promptForPassword) {\n        this.promptForPassword = promptForPassword;\n    }\n\n    /**\n     * @see #setPromptForPasswordEnabled(boolean)\n     * @return\n     */\n    public boolean isPromptForPasswordEnabled() {\n        if (promptForPassword == null) {\n            promptForPassword = options.remove(\"-pfp\");\n        }\n        return promptForPassword;\n    }\n\n    public void setMaxDetailedTabled(int maxDetailedTables) {\n        this.maxDetailedTables = new Integer(maxDetailedTables);\n    }\n\n    public int getMaxDetailedTables() {\n        if (maxDetailedTables == null) {\n            // default\n            int max = 300;\n            try {\n                max = Integer.parseInt(pullParam(\"-maxdet\"));\n            } catch (Exception notSpecified) {\n            }\n            maxDetailedTables = new Integer(max);\n        }\n        return maxDetailedTables.intValue();\n    }\n\n    public String getConnectionPropertiesFile() {\n        return userConnectionPropertiesFile;\n    }\n\n    /**\n     * Properties from this file (in key=value pair format) are passed to the\n     * database connection.<br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.\n     * @param propertiesFilename\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public void setConnectionPropertiesFile(String propertiesFilename) throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null)\n            userConnectionProperties = new Properties();\n        userConnectionProperties.load(new FileInputStream(propertiesFilename));\n        userConnectionPropertiesFile = propertiesFilename;\n    }\n\n    /**\n     * Returns a {@link Properties} populated either from the properties file specified\n     * by {@link #setConnectionPropertiesFile(String)}, the properties specified by\n     * {@link #setConnectionProperties(String)} or not populated.\n     * @return\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public Properties getConnectionProperties() throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null) {\n            String props = pullParam(\"-connprops\");\n            if (props != null) {\n                if (props.indexOf(ESCAPED_EQUALS) != -1) {\n                    setConnectionProperties(props);\n                } else {\n                    setConnectionPropertiesFile(props);\n                }\n            } else {\n                userConnectionProperties = new Properties();\n            }\n        }\n        return userConnectionProperties;\n    }\n\n    /**\n     * Specifies connection properties to use in the format:\n     * <code>key1\\=value1;key2\\=value2</code><br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.<p>\n     * This is an alternative form of passing connection properties than by file\n     * (see {@link #setConnectionPropertiesFile(String)})\n     *\n     * @param properties\n     */\n    public void setConnectionProperties(String properties) {\n        userConnectionProperties = new Properties();\n        StringTokenizer tokenizer = new StringTokenizer(properties, \";\");\n        while (tokenizer.hasMoreElements()) {\n            String pair = tokenizer.nextToken();\n            int index = pair.indexOf(ESCAPED_EQUALS);\n            if (index != -1) {\n                String key = pair.substring(0, index);\n                String value = pair.substring(index + ESCAPED_EQUALS.length());\n                userConnectionProperties.put(key, value);\n            }\n        }\n    }\n\n    public void setDriverPath(String driverPath) {\n        this.driverPath = driverPath;\n    }\n\n    public String getDriverPath() {\n        if (driverPath == null)\n            driverPath = pullParam(\"-dp\");\n        // was previously -cp:\n        if (driverPath == null)\n            driverPath = pullParam(\"-cp\");\n        return driverPath;\n    }\n\n    /**\n     * The filename of the cascading style sheet to use.\n     * Note that this file is parsed and used to determine characteristics\n     * of the generated diagrams, so it must contain specific settings that\n     * are documented within schemaSpy.css.<p>\n     *\n     * Defaults to <code>\"schemaSpy.css\"</code>.\n     *\n     * @param css\n     */\n    public void setCss(String css) {\n        this.css = css;\n    }\n\n    public String getCss() {\n        if (css == null) {\n            css = pullParam(\"-css\");\n            if (css == null)\n                css = \"schemaSpy.css\";\n        }\n        return css;\n    }\n\n    /**\n     * The font to use within diagrams.  Modify the .css to specify HTML fonts.\n     *\n     * @param font\n     */\n    public void setFont(String font) {\n        this.font = font;\n    }\n\n    /**\n     * @see #setFont(String)\n     */\n    public String getFont() {\n        if (font == null) {\n            font = pullParam(\"-font\");\n            if (font == null)\n                font = \"Helvetica\";\n        }\n        return font;\n    }\n\n    /**\n     * The font size to use within diagrams.  This is the size of the font used for\n     * 'large' (e.g. not 'compact') diagrams.<p>\n     *\n     * Modify the .css to specify HTML font sizes.<p>\n     *\n     * Defaults to 11.\n     *\n     * @param fontSize\n     */\n    public void setFontSize(int fontSize) {\n        this.fontSize = new Integer(fontSize);\n    }\n\n    /**\n     * @see #setFontSize(int)\n     * @return\n     */\n    public int getFontSize() {\n        if (fontSize == null) {\n            // default\n            int size = 11;\n            try {\n                size = Integer.parseInt(pullParam(\"-fontsize\"));\n            } catch (Exception notSpecified) {\n            }\n            fontSize = new Integer(size);\n        }\n        return fontSize.intValue();\n    }\n\n    /**\n     * The character set to use within HTML pages (defaults to <code>\"ISO-8859-1\"</code>).\n     *\n     * @param charset\n     */\n    public void setCharset(String charset) {\n        this.charset = charset;\n    }\n\n    /**\n     * @see #setCharset(String)\n     */\n    public String getCharset() {\n        if (charset == null) {\n            charset = pullParam(\"-charset\");\n            if (charset == null)\n                charset = \"ISO-8859-1\";\n        }\n        return charset;\n    }\n\n    /**\n     * Description of schema that gets display on main pages.\n     *\n     * @param description\n     */\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    /**\n     * @see #setDescription(String)\n     */\n    public String getDescription() {\n        if (description == null)\n            description = pullParam(\"-desc\");\n        return description;\n    }\n\n    /**\n     * Maximum number of threads to use when querying database metadata information.\n     *\n     * @param maxDbThreads\n     */\n    public void setMaxDbThreads(int maxDbThreads) {\n        this.maxDbThreads = new Integer(maxDbThreads);\n    }\n\n    /**\n     * @see #setMaxDbThreads(int)\n     * @throws InvalidConfigurationException if unable to load properties\n     */\n    public int getMaxDbThreads() throws InvalidConfigurationException {\n        if (maxDbThreads == null) {\n            Properties properties;\n            try {\n                properties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(\"Failed to load properties for \" + getDbType() + \": \" + exc).setParamName(\"-type\");\n            }\n            // not scientifically derived\n            final int defaultMax = 15;\n            int max = defaultMax;\n            String threads = properties.getProperty(\"dbThreads\");\n            if (threads == null)\n                threads = properties.getProperty(\"dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            threads = pullParam(\"-dbThreads\");\n            if (threads == null)\n                threads = pullParam(\"-dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            if (max < 0)\n                max = defaultMax;\n            else if (max == 0)\n                max = 1;\n            maxDbThreads = new Integer(max);\n        }\n        return maxDbThreads.intValue();\n    }\n\n    public boolean isLogoEnabled() {\n        if (logoEnabled == null)\n            logoEnabled = !options.remove(\"-nologo\");\n        return logoEnabled;\n    }\n\n    /**\n     * Don't use this unless absolutely necessary as it screws up the layout\n     *\n     * @param enabled\n     */\n    public void setRankDirBugEnabled(boolean enabled) {\n        rankDirBugEnabled = enabled;\n    }\n\n    /**\n     * @see #setRankDirBugEnabled(boolean)\n     */\n    public boolean isRankDirBugEnabled() {\n        if (rankDirBugEnabled == null)\n            rankDirBugEnabled = options.remove(\"-rankdirbug\");\n        return rankDirBugEnabled;\n    }\n\n    /**\n     * Look for Ruby on Rails-based naming conventions in\n     * relationships between logical foreign keys and primary keys.<p>\n     *\n     * Basically all tables have a primary key named <code>ID</code>.\n     * All tables are named plural names.\n     * The columns that logically reference that <code>ID</code> are the singular\n     * form of the table name suffixed with <code>_ID</code>.<p>\n     *\n     * @param enabled\n     */\n    public void setRailsEnabled(boolean enabled) {\n        railsEnabled = enabled;\n    }\n\n    /**\n     * @see #setRailsEnabled(boolean)\n     *\n     * @return\n     */\n    public boolean isRailsEnabled() {\n        if (railsEnabled == null)\n            railsEnabled = options.remove(\"-rails\");\n        return railsEnabled;\n    }\n\n    /**\n     * Allow Html In Comments - encode them unless otherwise specified\n     */\n    public void setEncodeCommentsEnabled(boolean enabled) {\n        encodeCommentsEnabled = enabled;\n    }\n\n    /**\n     * @see #setEncodeCommentsEnabled(boolean)\n     */\n    public boolean isEncodeCommentsEnabled() {\n        if (encodeCommentsEnabled == null)\n            encodeCommentsEnabled = !options.remove(\"-ahic\");\n        return encodeCommentsEnabled;\n    }\n\n    /**\n     * If enabled we'll attempt to query/render the number of rows that\n     * each table contains.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setNumRowsEnabled(boolean enabled) {\n        numRowsEnabled = enabled;\n    }\n\n    /**\n     * @see #setNumRowsEnabled(boolean)\n     * @return\n     */\n    public boolean isNumRowsEnabled() {\n        if (numRowsEnabled == null)\n            numRowsEnabled = !options.remove(\"-norows\");\n        return numRowsEnabled;\n    }\n\n    /**\n     * If enabled we'll include views in the analysis.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setViewsEnabled(boolean enabled) {\n        viewsEnabled = enabled;\n    }\n\n    /**\n     * @see #setViewsEnabled(boolean)\n     * @return\n     */\n    public boolean isViewsEnabled() {\n        if (viewsEnabled == null)\n            viewsEnabled = !options.remove(\"-noviews\");\n        return viewsEnabled;\n    }\n\n    /**\n     * Returns <code>true</code> if metering should be embedded in\n     * the generated pages.<p/>\n     * Defaults to <code>false</code> (disabled).\n     * @return\n     */\n    public boolean isMeterEnabled() {\n        if (meterEnabled == null)\n            meterEnabled = options.remove(\"-meter\");\n        return meterEnabled;\n    }\n\n    /**\n     * Set the columns to exclude from all relationship diagrams.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setColumnExclusions(String columnExclusions) {\n        this.columnExclusions = Pattern.compile(columnExclusions);\n    }\n\n    /**\n     * See {@link #setColumnExclusions(String)}\n     * @return\n     */\n    public Pattern getColumnExclusions() {\n        if (columnExclusions == null) {\n            String strExclusions = pullParam(\"-X\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.columnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            columnExclusions = Pattern.compile(strExclusions);\n        }\n        return columnExclusions;\n    }\n\n    /**\n     * Set the columns to exclude from relationship diagrams where the specified\n     * columns aren't directly referenced by the focal table.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setIndirectColumnExclusions(String fullColumnExclusions) {\n        indirectColumnExclusions = Pattern.compile(fullColumnExclusions);\n    }\n\n    /**\n     * @see #setIndirectColumnExclusions(String)\n     *\n     * @return\n     */\n    public Pattern getIndirectColumnExclusions() {\n        if (indirectColumnExclusions == null) {\n            String strExclusions = pullParam(\"-x\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.indirectColumnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            indirectColumnExclusions = Pattern.compile(strExclusions);\n        }\n        return indirectColumnExclusions;\n    }\n\n    /**\n     * Set the tables to include as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableInclusions(String tableInclusions) {\n        this.tableInclusions = Pattern.compile(tableInclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to include in the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableInclusions() {\n        if (tableInclusions == null) {\n            String strInclusions = pullParam(\"-i\");\n            if (strInclusions == null)\n                strInclusions = System.getenv(\"schemaspy.tableInclusions\");\n            if (strInclusions == null)\n                strInclusions = DEFAULT_TABLE_INCLUSION;\n            try {\n                tableInclusions = Pattern.compile(strInclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-i\");\n            }\n        }\n        return tableInclusions;\n    }\n\n    /**\n     * Set the tables to exclude as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableExclusions(String tableExclusions) {\n        this.tableExclusions = Pattern.compile(tableExclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to exclude from the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableExclusions() {\n        if (tableExclusions == null) {\n            String strExclusions = pullParam(\"-I\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.tableExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_TABLE_EXCLUSION;\n            try {\n                tableExclusions = Pattern.compile(strExclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-I\");\n            }\n        }\n        return tableExclusions;\n    }\n\n    /**\n     * @return\n     */\n    public List<String> getSchemas() {\n        if (schemas == null) {\n            String tmp = pullParam(\"-schemas\");\n            if (tmp == null)\n                tmp = pullParam(\"-schemata\");\n            if (tmp != null) {\n                schemas = new ArrayList<String>();\n                for (String name : tmp.split(\"[\\\\s,'\\\"]\")) {\n                    if (name.length() > 0)\n                        schemas.add(name);\n                }\n                if (schemas.isEmpty())\n                    schemas = null;\n            }\n        }\n        return schemas;\n    }\n\n    /**\n     * Set the name of the {@link SqlFormatter SQL formatter} class to use to\n     * format SQL into HTML.<p/>\n     * The implementation of the class must be made available to the class\n     * loader, typically by specifying the path to its jar with <em>-dp</em>\n     * ({@link #setDriverPath(String)}).\n     */\n    public void setSqlFormatter(String formatterClassName) {\n        sqlFormatterClass = formatterClassName;\n        sqlFormatter = null;\n    }\n\n    /**\n     * Set the {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.\n     */\n    public void setSqlFormatter(SqlFormatter sqlFormatter) {\n        this.sqlFormatter = sqlFormatter;\n        if (sqlFormatter != null)\n            sqlFormatterClass = sqlFormatter.getClass().getName();\n    }\n\n    /**\n     * Returns an implementation of {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.  The default implementation is {@link DefaultSqlFormatter}.\n     *\n     * @return\n     * @throws InvalidConfigurationException if unable to instantiate an instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SqlFormatter getSqlFormatter() throws InvalidConfigurationException {\n        if (sqlFormatter == null) {\n            if (sqlFormatterClass == null) {\n                sqlFormatterClass = pullParam(\"-sqlFormatter\");\n                if (sqlFormatterClass == null)\n                    sqlFormatterClass = DefaultSqlFormatter.class.getName();\n            }\n            try {\n                Class<SqlFormatter> clazz = (Class<SqlFormatter>) Class.forName(sqlFormatterClass);\n                sqlFormatter = clazz.newInstance();\n            } catch (Exception exc) {\n                throw new InvalidConfigurationException(\"Failed to initialize instance of SQL formatter: \", exc).setParamName(\"-sqlFormatter\");\n            }\n        }\n        return sqlFormatter;\n    }\n\n    /**\n     * Set the details to show on the columns page, where \"details\" are\n     * comma and/or space separated.\n     *\n     * Valid values:\n     * <ul>\n     * <li>id</li>\n     * <li>table</li>\n     * <li>column</li>\n     * <li>type</li>\n     * <li>size</li>\n     * <li>nulls</li>\n     * <li>auto</li>\n     * <li>default</li>\n     * <li>children</li>\n     * <li>parents</li>\n     * </ul>\n     *\n     * The default details are <code>\"table column type size nulls auto default\"</code>.\n     * Note that \"column\" is the initially displayed detail and must be included.\n     *\n     * @param columnDetails\n     */\n    public void setColumnDetails(String columnDetails) {\n        this.columnDetails = new ArrayList<String>();\n        if (columnDetails == null || columnDetails.length() == 0) {\n            // not specified, so use defaults\n            columnDetails = \"id table column type size nulls auto default\";\n        }\n        for (String detail : columnDetails.split(\"[\\\\s,'\\\"]\")) {\n            if (detail.length() > 0) {\n                this.columnDetails.add(detail.toLowerCase());\n            }\n        }\n        if (!this.columnDetails.contains(\"column\"))\n            throw new InvalidConfigurationException(\"'column' is a required column detail\");\n    }\n\n    public void setColumnDetails(List<String> columnDetails) {\n        String details = columnDetails == null ? \"[]\" : columnDetails.toString();\n        setColumnDetails(details.substring(1, details.length() - 1));\n    }\n\n    public List<String> getColumnDetails() {\n        if (columnDetails == null) {\n            setColumnDetails(pullParam(\"-columndetails\"));\n        }\n        return columnDetails;\n    }\n\n    public void setEvaluateAllEnabled(boolean enabled) {\n        evaluteAll = enabled;\n    }\n\n    public boolean isEvaluateAllEnabled() {\n        if (evaluteAll == null)\n            evaluteAll = options.remove(\"-all\");\n        return evaluteAll;\n    }\n\n    /**\n     * Returns true if we're evaluating a bunch of schemas in one go and\n     * at this point we're evaluating a specific schema.\n     *\n     * @return boolean\n     */\n    public boolean isOneOfMultipleSchemas() {\n        // set by MultipleSchemaAnalyzer\n        return Boolean.getBoolean(\"oneofmultipleschemas\");\n    }\n\n    /**\n     * When -all (evaluateAll) is specified then this is the regular\n     * expression that determines which schemas to evaluate.\n     *\n     * @param schemaSpec\n     */\n    public void setSchemaSpec(String schemaSpec) {\n        this.schemaSpec = schemaSpec;\n    }\n\n    public String getSchemaSpec() {\n        if (schemaSpec == null)\n            schemaSpec = pullParam(\"-schemaSpec\");\n        return schemaSpec;\n    }\n\n    /**\n     * Set the renderer to use for the -Tpng[:renderer[:formatter]] dot option as specified\n     * at <a href='http://www.graphviz.org/doc/info/command.html'>\n     * http://www.graphviz.org/doc/info/command.html</a>.<p>\n     * Note that the leading \":\" is required while :formatter is optional.<p>\n     * The default renderer is typically GD.<p>\n     * Note that using {@link #setHighQuality(boolean)} is the preferred approach\n     * over using this method.\n     */\n    public void setRenderer(String renderer) {\n        Dot.getInstance().setRenderer(renderer);\n    }\n\n    /**\n     * @see #setRenderer(String)\n     * @return\n     */\n    public String getRenderer() {\n        String renderer = pullParam(\"-renderer\");\n        if (renderer != null)\n            setRenderer(renderer);\n        return Dot.getInstance().getRenderer();\n    }\n\n    /**\n     * If <code>false</code> then generate output of \"lower quality\"\n     * than the default.\n     * Note that the default is intended to be \"higher quality\",\n     * but various installations of Graphviz may have have different abilities.\n     * That is, some might not have the \"lower quality\" libraries and others might\n     * not have the \"higher quality\" libraries.<p>\n     * Higher quality output takes longer to generate and results in significantly\n     * larger image files (which take longer to download / display), but it generally\n     * looks better.\n     */\n    public void setHighQuality(boolean highQuality) {\n        this.highQuality = highQuality;\n        lowQuality = !highQuality;\n        Dot.getInstance().setHighQuality(highQuality);\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isHighQuality() {\n        if (highQuality == null) {\n            highQuality = options.remove(\"-hq\");\n            if (highQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(highQuality);\n            }\n        }\n        highQuality = Dot.getInstance().isHighQuality();\n        return highQuality;\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isLowQuality() {\n        if (lowQuality == null) {\n            lowQuality = options.remove(\"-lq\");\n            if (lowQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(!lowQuality);\n            }\n        }\n        lowQuality = !Dot.getInstance().isHighQuality();\n        return lowQuality;\n    }\n\n    /**\n     * Set the level of logging to perform.<p/>\n     * The levels in descending order are:\n     * <ul>\n     *  <li><code>severe</code> (highest - least detail)\n     *  <li><code>warning</code> (default)\n     *  <li><code>info</code>\n     *  <li><code>config</code>\n     *  <li><code>fine</code>\n     *  <li><code>finer</code>\n     *  <li><code>finest</code>  (lowest - most detail)\n     * </ul>\n     *\n     * @param logLevel\n     */\n    public void setLogLevel(String logLevel) {\n        if (logLevel == null) {\n            this.logLevel = Level.WARNING;\n            return;\n        }\n        Map<String, Level> levels = new LinkedHashMap<String, Level>();\n        levels.put(\"severe\", Level.SEVERE);\n        levels.put(\"warning\", Level.WARNING);\n        levels.put(\"info\", Level.INFO);\n        levels.put(\"config\", Level.CONFIG);\n        levels.put(\"fine\", Level.FINE);\n        levels.put(\"finer\", Level.FINER);\n        levels.put(\"finest\", Level.FINEST);\n        this.logLevel = levels.get(logLevel.toLowerCase());\n        if (this.logLevel == null) {\n            throw new InvalidConfigurationException(\"Invalid logLevel: '\" + logLevel + \"'. Must be one of: \" + levels.keySet());\n        }\n    }\n\n    /**\n     * Returns the level of logging to perform.\n     * See {@link #setLogLevel(String)}.\n     *\n     * @return\n     */\n    public Level getLogLevel() {\n        if (logLevel == null) {\n            setLogLevel(pullParam(\"-loglevel\"));\n        }\n        return logLevel;\n    }\n\n    /**\n     * Returns <code>true</code> if the options indicate that the user wants\n     * to see some help information.\n     *\n     * @return\n     */\n    public boolean isHelpRequired() {\n        return helpRequired;\n    }\n\n    public boolean isDbHelpRequired() {\n        return dbHelpRequired;\n    }\n\n    /**\n     * Returns the jar that we were loaded from\n     *\n     * @return\n     */\n    public static String getLoadedFromJar() {\n        String classpath = System.getProperty(\"java.class.path\");\n        return new StringTokenizer(classpath, File.pathSeparator).nextToken();\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasOrphans(boolean hasOrphans) {\n        this.hasOrphans = hasOrphans;\n    }\n\n    /**\n     * @see #setHasOrphans()\n     *\n     * @return\n     */\n    public boolean hasOrphans() {\n        return hasOrphans;\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasRoutines(boolean hasRoutines) {\n        this.hasRoutines = hasRoutines;\n    }\n\n    /**\n     * @see #setHasRoutines()\n     *\n     * @return\n     */\n    public boolean hasRoutines() {\n        return hasRoutines;\n    }\n\n    /**\n     * Returns the database properties to use.\n     * These should be determined by calling {@link #determineDbProperties(String)}.\n     * @return\n     * @throws InvalidConfigurationException\n     */\n    public Properties getDbProperties() throws InvalidConfigurationException {\n        if (dbProperties == null) {\n            try {\n                dbProperties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(exc);\n            }\n        }\n        return dbProperties;\n    }\n\n    /**\n     * Determines the database properties associated with the specified type.\n     * A call to {@link #setDbProperties(Properties)} is expected after determining\n     * the complete set of properties.\n     *\n     * @param type\n     * @return\n     * @throws IOException\n     * @throws InvalidConfigurationException if db properties are incorrectly formed\n     */\n    public Properties determineDbProperties(String type) throws IOException, InvalidConfigurationException {\n        ResourceBundle bundle = null;\n        try {\n            File propertiesFile = new File(type);\n            bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n            dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n        } catch (FileNotFoundException notFoundOnFilesystemWithoutExtension) {\n            try {\n                File propertiesFile = new File(type + \".properties\");\n                bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n                dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n            } catch (FileNotFoundException notFoundOnFilesystemWithExtensionTackedOn) {\n                try {\n                    bundle = ResourceBundle.getBundle(type);\n                    dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]\" + File.separator + type + \".properties\";\n                } catch (Exception notInJarWithoutPath) {\n                    try {\n                        String path = TableOrderer.class.getPackage().getName() + \".dbTypes.\" + type;\n                        path = path.replace('.', '/');\n                        bundle = ResourceBundle.getBundle(path);\n                        dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]/\" + path + \".properties\";\n                    } catch (Exception notInJar) {\n                        notInJar.printStackTrace();\n                        notFoundOnFilesystemWithExtensionTackedOn.printStackTrace();\n                        throw notFoundOnFilesystemWithoutExtension;\n                    }\n                }\n            }\n        }\n        Properties props = asProperties(bundle);\n        bundle = null;\n        // keep original thru recursion\n        String saveLoadedFrom = dbPropertiesLoadedFrom;\n        // bring in key/values pointed to by the include directive\n        // example: include.1=mysql::selectRowCountSql\n        for (int i = 1; true; ++i) {\n            String include = (String) props.remove(\"include.\" + i);\n            if (include == null)\n                break;\n            int separator = include.indexOf(\"::\");\n            if (separator == -1)\n                throw new InvalidConfigurationException(\"include directive in \" + dbPropertiesLoadedFrom + \" must have '::' between dbType and key\");\n            String refdType = include.substring(0, separator).trim();\n            String refdKey = include.substring(separator + 2).trim();\n            // recursively resolve the ref'd properties file and the ref'd key\n            Properties refdProps = determineDbProperties(refdType);\n            props.put(refdKey, refdProps.getProperty(refdKey));\n        }\n        // bring in base properties files pointed to by the extends directive\n        String baseDbType = (String) props.remove(\"extends\");\n        if (baseDbType != null) {\n            baseDbType = baseDbType.trim();\n            Properties baseProps = determineDbProperties(baseDbType);\n            // overlay our properties on top of the base's\n            baseProps.putAll(props);\n            props = baseProps;\n        }\n        // done with this level of recursion...restore original\n        dbPropertiesLoadedFrom = saveLoadedFrom;\n        // this won't be correct until the final recursion exits\n        dbProperties = props;\n        return props;\n    }\n\n    protected String getDbPropertiesLoadedFrom() throws IOException {\n        if (dbPropertiesLoadedFrom == null)\n            determineDbProperties(getDbType());\n        return dbPropertiesLoadedFrom;\n    }\n\n    public List<String> getRemainingParameters() {\n        try {\n            populate();\n        } catch (IllegalArgumentException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (IllegalAccessException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (InvocationTargetException exc) {\n            if (exc.getCause() instanceof InvalidConfigurationException)\n                throw (InvalidConfigurationException) exc.getCause();\n            throw new InvalidConfigurationException(exc.getCause());\n        } catch (IntrospectionException exc) {\n            throw new InvalidConfigurationException(exc);\n        }\n        return options;\n    }\n\n    /**\n     * Options that are specific to a type of database.  E.g. things like <code>host</code>,\n     * <code>port</code> or <code>db</code>, but <b>don't</b> have a setter in this class.\n     *\n     * @param dbSpecificOptions\n     */\n    public void setDbSpecificOptions(Map<String, String> dbSpecificOptions) {\n        this.dbSpecificOptions = dbSpecificOptions;\n        originalDbSpecificOptions = new HashMap<String, String>(dbSpecificOptions);\n    }\n\n    public Map<String, String> getDbSpecificOptions() {\n        if (dbSpecificOptions == null)\n            dbSpecificOptions = new HashMap<String, String>();\n        return dbSpecificOptions;\n    }\n\n    /**\n     * Returns a {@link Properties} populated with the contents of <code>bundle</code>\n     *\n     * @param bundle ResourceBundle\n     * @return Properties\n     */\n    public static Properties asProperties(ResourceBundle bundle) {\n        Properties props = new Properties();\n        Enumeration<String> iter = bundle.getKeys();\n        while (iter.hasMoreElements()) {\n            String key = iter.nextElement();\n            props.put(key, bundle.getObject(key));\n        }\n        return props;\n    }\n\n    /**\n     * 'Pull' the specified parameter from the collection of options. Returns\n     * null if the parameter isn't in the list and removes it if it is.\n     *\n     * @param paramId\n     * @return\n     */\n    private String pullParam(String paramId) {\n        return pullParam(paramId, false, false);\n    }\n\n    private String pullRequiredParam(String paramId) {\n        return pullParam(paramId, true, false);\n    }\n\n    /**\n     * @param paramId\n     * @param required\n     * @param dbTypeSpecific\n     * @return\n     * @throws MissingRequiredParameterException\n     */\n    private String pullParam(String paramId, boolean required, boolean dbTypeSpecific) throws MissingRequiredParameterException {\n        int paramIndex = options.indexOf(paramId);\n        if (paramIndex < 0) {\n            if (required)\n                throw new MissingRequiredParameterException(paramId, dbTypeSpecific);\n            return null;\n        }\n        options.remove(paramIndex);\n        String param = options.get(paramIndex).toString();\n        options.remove(paramIndex);\n        return param;\n    }\n\n    /**\n     * Thrown to indicate that a required parameter is missing\n     */\n    public static class MissingRequiredParameterException extends RuntimeException {\n\n        private static final long serialVersionUID = 1L;\n\n        private final boolean dbTypeSpecific;\n\n        public MissingRequiredParameterException(String paramId, boolean dbTypeSpecific) {\n            this(paramId, null, dbTypeSpecific);\n        }\n\n        public MissingRequiredParameterException(String paramId, String description, boolean dbTypeSpecific) {\n            super(\"Required parameter '\" + paramId + \"' \" + (description == null ? \"\" : \"(\" + description + \") \") + \"was not specified.\" + (dbTypeSpecific ? \"  It is required for this database type.\" : \"\"));\n            this.dbTypeSpecific = dbTypeSpecific;\n        }\n\n        public boolean isDbTypeSpecific() {\n            return dbTypeSpecific;\n        }\n    }\n\n    /**\n     * Allow an equal sign in args...like \"-o=foo.bar\". Useful for things like\n     * Ant and Maven.\n     *\n     * @param args\n     *            List\n     * @return List\n     */\n    protected List<String> fixupArgs(List<String> args) {\n        List<String> expandedArgs = new ArrayList<String>();\n        for (String arg : args) {\n            int indexOfEquals = arg.indexOf('=');\n            if (indexOfEquals != -1 && indexOfEquals - 1 != arg.indexOf(ESCAPED_EQUALS)) {\n                expandedArgs.add(arg.substring(0, indexOfEquals));\n                expandedArgs.add(arg.substring(indexOfEquals + 1));\n            } else {\n                expandedArgs.add(arg);\n            }\n        }\n        // some OSes/JVMs do filename expansion with runtime.exec() and some don't,\n        // so MultipleSchemaAnalyzer has to surround params with double quotes...\n        // strip them here for the OSes/JVMs that don't do anything with the params\n        List<String> unquotedArgs = new ArrayList<String>();\n        for (String arg : expandedArgs) {\n            if (// \".*\" becomes .*\n            arg.startsWith(\"\\\"\") && arg.endsWith(\"\\\"\"))\n                arg = arg.substring(1, arg.length() - 1);\n            unquotedArgs.add(arg);\n        }\n        return unquotedArgs;\n    }\n\n    /**\n     * Call all the getters to populate all the lazy initialized stuff.\n     *\n     * @throws InvocationTargetException\n     * @throws IllegalAccessException\n     * @throws IllegalArgumentException\n     * @throws IntrospectionException\n     */\n    private void populate() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IntrospectionException {\n        if (!populating) {\n            // prevent recursion\n            populating = true;\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                Method readMethod = props[i].getReadMethod();\n                if (readMethod != null)\n                    readMethod.invoke(this, (Object[]) null);\n            }\n            populating = false;\n        }\n    }\n\n    public static Set<String> getBuiltInDatabaseTypes(String loadedFromJar) {\n        Set<String> databaseTypes = new TreeSet<String>();\n        JarInputStream jar = null;\n        try {\n            jar = new JarInputStream(new FileInputStream(loadedFromJar));\n            JarEntry entry;\n            while ((entry = jar.getNextJarEntry()) != null) {\n                String entryName = entry.getName();\n                int dotPropsIndex = entryName.indexOf(\".properties\");\n                if (dotPropsIndex != -1)\n                    databaseTypes.add(entryName.substring(0, dotPropsIndex));\n            }\n        } catch (IOException exc) {\n        } finally {\n            if (jar != null) {\n                try {\n                    jar.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n        return databaseTypes;\n    }\n\n    protected void dumpUsage(String errorMessage, boolean detailedDb) {\n        if (errorMessage != null) {\n            System.out.flush();\n            System.err.println(\"*** \" + errorMessage + \" ***\");\n        } else {\n            System.out.println(\"SchemaSpy generates an HTML representation of a database schema's relationships.\");\n        }\n        System.err.flush();\n        System.out.println();\n        if (!detailedDb) {\n            System.out.println(\"Usage:\");\n            System.out.println(\" java -jar \" + getLoadedFromJar() + \" [options]\");\n            System.out.println(\"   -t databaseType       type of database - defaults to ora\");\n            System.out.println(\"                           use -dbhelp for a list of built-in types\");\n            System.out.println(\"   -u user               connect to the database with this user id\");\n            System.out.println(\"   -s schema             defaults to the specified user\");\n            System.out.println(\"   -p password           defaults to no password\");\n            System.out.println(\"   -o outputDirectory    directory to place the generated output in\");\n            System.out.println(\"   -dp pathToDrivers     optional - looks for JDBC drivers here before looking\");\n            System.out.println(\"                           in driverPath in [databaseType].properties.\");\n            System.out.println(\"Go to http://schemaspy.sourceforge.net for a complete list/description\");\n            System.out.println(\" of additional parameters.\");\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"Built-in database types and their required connection parameters:\");\n            for (String type : getBuiltInDatabaseTypes(getLoadedFromJar())) {\n                new DbSpecificConfig(type).dumpUsage();\n            }\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"You can use your own database types by specifying the filespec of a .properties file with -t.\");\n            System.out.println(\"Grab one out of \" + getLoadedFromJar() + \" and modify it to suit your needs.\");\n            System.out.println();\n        }\n        System.out.println(\"Sample usage using the default database type (implied -t ora):\");\n        System.out.println(\" java -jar schemaSpy.jar -db mydb -s myschema -u devuser -p password -o output\");\n        System.out.println();\n        System.out.flush();\n    }\n\n    /**\n     * Get the value of the specified parameter.\n     * Used for properties that are common to most db's, but aren't required.\n     *\n     * @param paramName\n     * @return\n     */\n    public String getParam(String paramName) {\n        try {\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                PropertyDescriptor prop = props[i];\n                if (prop.getName().equalsIgnoreCase(paramName)) {\n                    Object result = prop.getReadMethod().invoke(this, (Object[]) null);\n                    return result == null ? null : result.toString();\n                }\n            }\n        } catch (Exception failed) {\n            failed.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * Return all of the configuration options as a List of Strings, with\n     * each parameter and its value as a separate element.\n     *\n     * @return\n     * @throws IOException\n     */\n    public List<String> asList() throws IOException {\n        List<String> params = new ArrayList<String>();\n        if (originalDbSpecificOptions != null) {\n            for (String key : originalDbSpecificOptions.keySet()) {\n                String value = originalDbSpecificOptions.get(key);\n                if (!key.startsWith(\"-\"))\n                    key = \"-\" + key;\n                params.add(key);\n                params.add(value);\n            }\n        }\n        if (isEncodeCommentsEnabled())\n            params.add(\"-ahic\");\n        if (isEvaluateAllEnabled())\n            params.add(\"-all\");\n        if (!isHtmlGenerationEnabled())\n            params.add(\"-nohtml\");\n        if (!isImpliedConstraintsEnabled())\n            params.add(\"-noimplied\");\n        if (!isLogoEnabled())\n            params.add(\"-nologo\");\n        if (isMeterEnabled())\n            params.add(\"-meter\");\n        if (!isNumRowsEnabled())\n            params.add(\"-norows\");\n        if (!isViewsEnabled())\n            params.add(\"-noviews\");\n        if (isRankDirBugEnabled())\n            params.add(\"-rankdirbug\");\n        if (isRailsEnabled())\n            params.add(\"-rails\");\n        if (isSingleSignOn())\n            params.add(\"-sso\");\n        if (isSchemaDisabled())\n            params.add(\"-noschema\");\n        String value = getDriverPath();\n        if (value != null) {\n            params.add(\"-dp\");\n            params.add(value);\n        }\n        params.add(\"-css\");\n        params.add(getCss());\n        params.add(\"-charset\");\n        params.add(getCharset());\n        params.add(\"-font\");\n        params.add(getFont());\n        params.add(\"-fontsize\");\n        params.add(String.valueOf(getFontSize()));\n        params.add(\"-t\");\n        params.add(getDbType());\n        // query to set renderer correctly\n        isHighQuality();\n        // query to set renderer correctly\n        isLowQuality();\n        // instead of -hq and/or -lq\n        params.add(\"-renderer\");\n        params.add(getRenderer());\n        value = getDescription();\n        if (value != null) {\n            params.add(\"-desc\");\n            params.add(value);\n        }\n        value = getPassword();\n        if (value != null && !isPromptForPasswordEnabled()) {\n            // note that we don't pass -pfp since child processes\n            // won't have a console\n            params.add(\"-p\");\n            params.add(value);\n        }\n        value = getCatalog();\n        if (value != null) {\n            params.add(\"-cat\");\n            params.add(value);\n        }\n        value = getSchema();\n        if (value != null) {\n            params.add(\"-s\");\n            params.add(value);\n        }\n        value = getUser();\n        if (value != null) {\n            params.add(\"-u\");\n            params.add(value);\n        }\n        value = getConnectionPropertiesFile();\n        if (value != null) {\n            params.add(\"-connprops\");\n            params.add(value);\n        } else {\n            Properties props = getConnectionProperties();\n            if (!props.isEmpty()) {\n                params.add(\"-connprops\");\n                StringBuilder buf = new StringBuilder();\n                for (Entry<Object, Object> entry : props.entrySet()) {\n                    buf.append(entry.getKey());\n                    buf.append(ESCAPED_EQUALS);\n                    buf.append(entry.getValue());\n                    buf.append(';');\n                }\n                params.add(buf.toString());\n            }\n        }\n        value = getDb();\n        if (value != null) {\n            params.add(\"-db\");\n            params.add(value);\n        }\n        value = getHost();\n        if (value != null) {\n            params.add(\"-host\");\n            params.add(value);\n        }\n        if (getPort() != null) {\n            params.add(\"-port\");\n            params.add(getPort().toString());\n        }\n        value = getServer();\n        if (value != null) {\n            params.add(\"-server\");\n            params.add(value);\n        }\n        value = getMeta();\n        if (value != null) {\n            params.add(\"-meta\");\n            params.add(value);\n        }\n        if (getGraphvizDir() != null) {\n            params.add(\"-gv\");\n            params.add(getGraphvizDir().toString());\n        }\n        params.add(\"-loglevel\");\n        params.add(getLogLevel().toString().toLowerCase());\n        params.add(\"-sqlFormatter\");\n        params.add(getSqlFormatter().getClass().getName());\n        params.add(\"-i\");\n        params.add(getTableInclusions().toString());\n        params.add(\"-I\");\n        params.add(getTableExclusions().toString());\n        params.add(\"-X\");\n        params.add(getColumnExclusions().toString());\n        params.add(\"-x\");\n        params.add(getIndirectColumnExclusions().toString());\n        params.add(\"-dbthreads\");\n        params.add(String.valueOf(getMaxDbThreads()));\n        params.add(\"-maxdet\");\n        params.add(String.valueOf(getMaxDetailedTables()));\n        params.add(\"-o\");\n        params.add(getOutputDir().toString());\n        return params;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/ConfigTest21.java",
		"test_prompt": "// ConfigTest21.java\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Config}.\n* It contains ten unit test cases for the {@link Config#hasRoutines()} method.\n*/\nclass ConfigTest21 {"
	},
	{
		"original_code": "// Config.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\n\n/**\n * Configuration of a SchemaSpy run\n *\n * @author John Currier\n */\npublic class Config {\n\n    private static Config instance;\n\n    private final List<String> options;\n\n    private Map<String, String> dbSpecificOptions;\n\n    private Map<String, String> originalDbSpecificOptions;\n\n    private boolean helpRequired;\n\n    private boolean dbHelpRequired;\n\n    private File outputDir;\n\n    private File graphvizDir;\n\n    private String dbType;\n\n    private String catalog;\n\n    private String schema;\n\n    private List<String> schemas;\n\n    private String user;\n\n    private Boolean singleSignOn;\n\n    private Boolean noSchema;\n\n    private String password;\n\n    private Boolean promptForPassword;\n\n    private String db;\n\n    private String host;\n\n    private Integer port;\n\n    private String server;\n\n    private String meta;\n\n    private Pattern tableInclusions;\n\n    private Pattern tableExclusions;\n\n    private Pattern columnExclusions;\n\n    private Pattern indirectColumnExclusions;\n\n    private String userConnectionPropertiesFile;\n\n    private Properties userConnectionProperties;\n\n    private Integer maxDbThreads;\n\n    private Integer maxDetailedTables;\n\n    private String driverPath;\n\n    private String css;\n\n    private String charset;\n\n    private String font;\n\n    private Integer fontSize;\n\n    private String description;\n\n    private Properties dbProperties;\n\n    private String dbPropertiesLoadedFrom;\n\n    private Level logLevel;\n\n    private SqlFormatter sqlFormatter;\n\n    private String sqlFormatterClass;\n\n    private Boolean generateHtml;\n\n    private Boolean includeImpliedConstraints;\n\n    private Boolean logoEnabled;\n\n    private Boolean rankDirBugEnabled;\n\n    private Boolean encodeCommentsEnabled;\n\n    private Boolean numRowsEnabled;\n\n    private Boolean viewsEnabled;\n\n    private Boolean meterEnabled;\n\n    private Boolean railsEnabled;\n\n    private Boolean evaluteAll;\n\n    private Boolean highQuality;\n\n    private Boolean lowQuality;\n\n    // used in conjunction with evaluateAll\n    private String schemaSpec;\n\n    private boolean hasOrphans = false;\n\n    private boolean hasRoutines = false;\n\n    private boolean populating = false;\n\n    private List<String> columnDetails;\n\n    public static final String DOT_CHARSET = \"UTF-8\";\n\n    private static final String ESCAPED_EQUALS = \"\\\\=\";\n\n    // match everything\n    private static final String DEFAULT_TABLE_INCLUSION = \".*\";\n\n    // match nothing\n    private static final String DEFAULT_TABLE_EXCLUSION = \"\";\n\n    // match nothing\n    private static final String DEFAULT_COLUMN_EXCLUSION = \"[^.]\";\n\n    /**\n     * Default constructor. Intended for when you want to inject properties\n     * independently (i.e. not from a command line interface).\n     */\n    public Config() {\n        if (instance == null)\n            setInstance(this);\n        options = new ArrayList<String>();\n    }\n\n    /**\n     * Construct a configuration from an array of options (e.g. from a command\n     * line interface).\n     *\n     * @param options\n     */\n    public Config(String[] argv) {\n        setInstance(this);\n        options = fixupArgs(Arrays.asList(argv));\n        helpRequired = options.remove(\"-?\") || options.remove(\"/?\") || options.remove(\"?\") || options.remove(\"-h\") || options.remove(\"-help\") || options.remove(\"--help\");\n        dbHelpRequired = options.remove(\"-dbHelp\") || options.remove(\"-dbhelp\");\n    }\n\n    public static Config getInstance() {\n        if (instance == null)\n            instance = new Config();\n        return instance;\n    }\n\n    /**\n     * Sets the global instance.\n     *\n     * Useful for things like selecting a specific configuration in a UI.\n     *\n     * @param config\n     */\n    public static void setInstance(Config config) {\n        instance = config;\n    }\n\n    public void setHtmlGenerationEnabled(boolean generateHtml) {\n        this.generateHtml = generateHtml;\n    }\n\n    public boolean isHtmlGenerationEnabled() {\n        if (generateHtml == null)\n            generateHtml = !options.remove(\"-nohtml\");\n        return generateHtml;\n    }\n\n    public void setImpliedConstraintsEnabled(boolean includeImpliedConstraints) {\n        this.includeImpliedConstraints = includeImpliedConstraints;\n    }\n\n    public boolean isImpliedConstraintsEnabled() {\n        if (includeImpliedConstraints == null)\n            includeImpliedConstraints = !options.remove(\"-noimplied\");\n        return includeImpliedConstraints;\n    }\n\n    public void setOutputDir(String outputDirName) {\n        if (outputDirName.endsWith(\"\\\"\"))\n            outputDirName = outputDirName.substring(0, outputDirName.length() - 1);\n        setOutputDir(new File(outputDirName));\n    }\n\n    public void setOutputDir(File outputDir) {\n        this.outputDir = outputDir;\n    }\n\n    public File getOutputDir() {\n        if (outputDir == null) {\n            setOutputDir(pullRequiredParam(\"-o\"));\n        }\n        return outputDir;\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(String graphvizDir) {\n        if (graphvizDir.endsWith(\"\\\"\"))\n            graphvizDir = graphvizDir.substring(0, graphvizDir.length() - 1);\n        setGraphvizDir(new File(graphvizDir));\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(File graphvizDir) {\n        this.graphvizDir = graphvizDir;\n    }\n\n    /**\n     * Return the path to Graphviz (used to find the dot executable to run to\n     * generate ER diagrams).<p/>\n     *\n     * Returns {@link #getDefaultGraphvizPath()} if a specific Graphviz path\n     * was not specified.\n     *\n     * @return\n     */\n    public File getGraphvizDir() {\n        if (graphvizDir == null) {\n            String gv = pullParam(\"-gv\");\n            if (gv != null) {\n                setGraphvizDir(gv);\n            } else {\n                // expect to find Graphviz's bin directory on the PATH\n            }\n        }\n        return graphvizDir;\n    }\n\n    /**\n     * Meta files are XML-based files that provide additional metadata\n     * about the schema being evaluated.<p>\n     * <code>meta</code> is either the name of an individual XML file or\n     * the directory that contains meta files.<p>\n     * If a directory is specified then it is expected to contain files\n     * matching the pattern <code>[schema].meta.xml</code>.\n     * For databases that don't have schema substitute database for schema.\n     * @param meta\n     */\n    public void setMeta(String meta) {\n        this.meta = meta;\n    }\n\n    public String getMeta() {\n        if (meta == null)\n            meta = pullParam(\"-meta\");\n        return meta;\n    }\n\n    public void setDbType(String dbType) {\n        this.dbType = dbType;\n    }\n\n    public String getDbType() {\n        if (dbType == null) {\n            dbType = pullParam(\"-t\");\n            if (dbType == null)\n                dbType = \"ora\";\n        }\n        return dbType;\n    }\n\n    public void setDb(String db) {\n        this.db = db;\n    }\n\n    public String getDb() {\n        if (db == null)\n            db = pullParam(\"-db\");\n        return db;\n    }\n\n    public void setCatalog(String catalog) {\n        this.catalog = catalog;\n    }\n\n    public String getCatalog() {\n        if (catalog == null)\n            catalog = pullParam(\"-cat\");\n        return catalog;\n    }\n\n    public void setSchema(String schema) {\n        this.schema = schema;\n    }\n\n    public String getSchema() {\n        if (schema == null)\n            schema = pullParam(\"-s\");\n        return schema;\n    }\n\n    /**\n     * Some databases types (e.g. older versions of Informix) don't really\n     * have the concept of a schema but still return true from\n     * {@link DatabaseMetaData#supportsSchemasInTableDefinitions()}.\n     * This option lets you ignore that and treat all the tables\n     * as if they were in one flat namespace.\n     */\n    public boolean isSchemaDisabled() {\n        if (noSchema == null)\n            noSchema = options.remove(\"-noschema\");\n        return noSchema;\n    }\n\n    public void setHost(String host) {\n        this.host = host;\n    }\n\n    public String getHost() {\n        if (host == null)\n            host = pullParam(\"-host\");\n        return host;\n    }\n\n    public void setPort(Integer port) {\n        this.port = port;\n    }\n\n    public Integer getPort() {\n        if (port == null)\n            try {\n                port = Integer.valueOf(pullParam(\"-port\"));\n            } catch (Exception notSpecified) {\n            }\n        return port;\n    }\n\n    public void setServer(String server) {\n        this.server = server;\n    }\n\n    public String getServer() {\n        if (server == null) {\n            server = pullParam(\"-server\");\n        }\n        return server;\n    }\n\n    public void setUser(String user) {\n        this.user = user;\n    }\n\n    /**\n     * User used to connect to the database.\n     * Required unless single sign-on is enabled\n     * (see {@link #setSingleSignOn(boolean)}).\n     * @return\n     */\n    public String getUser() {\n        if (user == null) {\n            if (!isSingleSignOn())\n                user = pullRequiredParam(\"-u\");\n            else\n                user = pullParam(\"-u\");\n        }\n        return user;\n    }\n\n    /**\n     * By default a \"user\" (as specified with -u) is required.\n     * This option allows disabling of that requirement for\n     * single sign-on environments.\n     *\n     * @param enabled defaults to <code>false</code>\n     */\n    public void setSingleSignOn(boolean enabled) {\n        singleSignOn = enabled;\n    }\n\n    /**\n     * @see #setSingleSignOn(boolean)\n     */\n    public boolean isSingleSignOn() {\n        if (singleSignOn == null)\n            singleSignOn = options.remove(\"-sso\");\n        return singleSignOn;\n    }\n\n    /**\n     * Set the password used to connect to the database.\n     * @param password\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * @see #setPassword(String)\n     * @return\n     */\n    public String getPassword() {\n        if (password == null)\n            password = pullParam(\"-p\");\n        if (password == null && isPromptForPasswordEnabled())\n            password = new String(PasswordReader.getInstance().readPassword(\"Password: \"));\n        if (password == null) {\n            // if -pfp is enabled when analyzing multiple schemas then\n            // we don't want to send the password on the command line,\n            // so see if it was passed in the environment (not ideal, but safer)\n            password = System.getenv(\"schemaspy.pw\");\n        }\n        return password;\n    }\n\n    /**\n     * Set to <code>true</code> to prompt for the password\n     * @param promptForPassword\n     */\n    public void setPromptForPasswordEnabled(boolean promptForPassword) {\n        this.promptForPassword = promptForPassword;\n    }\n\n    /**\n     * @see #setPromptForPasswordEnabled(boolean)\n     * @return\n     */\n    public boolean isPromptForPasswordEnabled() {\n        if (promptForPassword == null) {\n            promptForPassword = options.remove(\"-pfp\");\n        }\n        return promptForPassword;\n    }\n\n    public void setMaxDetailedTabled(int maxDetailedTables) {\n        this.maxDetailedTables = new Integer(maxDetailedTables);\n    }\n\n    public int getMaxDetailedTables() {\n        if (maxDetailedTables == null) {\n            // default\n            int max = 300;\n            try {\n                max = Integer.parseInt(pullParam(\"-maxdet\"));\n            } catch (Exception notSpecified) {\n            }\n            maxDetailedTables = new Integer(max);\n        }\n        return maxDetailedTables.intValue();\n    }\n\n    public String getConnectionPropertiesFile() {\n        return userConnectionPropertiesFile;\n    }\n\n    /**\n     * Properties from this file (in key=value pair format) are passed to the\n     * database connection.<br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.\n     * @param propertiesFilename\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public void setConnectionPropertiesFile(String propertiesFilename) throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null)\n            userConnectionProperties = new Properties();\n        userConnectionProperties.load(new FileInputStream(propertiesFilename));\n        userConnectionPropertiesFile = propertiesFilename;\n    }\n\n    /**\n     * Returns a {@link Properties} populated either from the properties file specified\n     * by {@link #setConnectionPropertiesFile(String)}, the properties specified by\n     * {@link #setConnectionProperties(String)} or not populated.\n     * @return\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public Properties getConnectionProperties() throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null) {\n            String props = pullParam(\"-connprops\");\n            if (props != null) {\n                if (props.indexOf(ESCAPED_EQUALS) != -1) {\n                    setConnectionProperties(props);\n                } else {\n                    setConnectionPropertiesFile(props);\n                }\n            } else {\n                userConnectionProperties = new Properties();\n            }\n        }\n        return userConnectionProperties;\n    }\n\n    /**\n     * Specifies connection properties to use in the format:\n     * <code>key1\\=value1;key2\\=value2</code><br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.<p>\n     * This is an alternative form of passing connection properties than by file\n     * (see {@link #setConnectionPropertiesFile(String)})\n     *\n     * @param properties\n     */\n    public void setConnectionProperties(String properties) {\n        userConnectionProperties = new Properties();\n        StringTokenizer tokenizer = new StringTokenizer(properties, \";\");\n        while (tokenizer.hasMoreElements()) {\n            String pair = tokenizer.nextToken();\n            int index = pair.indexOf(ESCAPED_EQUALS);\n            if (index != -1) {\n                String key = pair.substring(0, index);\n                String value = pair.substring(index + ESCAPED_EQUALS.length());\n                userConnectionProperties.put(key, value);\n            }\n        }\n    }\n\n    public void setDriverPath(String driverPath) {\n        this.driverPath = driverPath;\n    }\n\n    public String getDriverPath() {\n        if (driverPath == null)\n            driverPath = pullParam(\"-dp\");\n        // was previously -cp:\n        if (driverPath == null)\n            driverPath = pullParam(\"-cp\");\n        return driverPath;\n    }\n\n    /**\n     * The filename of the cascading style sheet to use.\n     * Note that this file is parsed and used to determine characteristics\n     * of the generated diagrams, so it must contain specific settings that\n     * are documented within schemaSpy.css.<p>\n     *\n     * Defaults to <code>\"schemaSpy.css\"</code>.\n     *\n     * @param css\n     */\n    public void setCss(String css) {\n        this.css = css;\n    }\n\n    public String getCss() {\n        if (css == null) {\n            css = pullParam(\"-css\");\n            if (css == null)\n                css = \"schemaSpy.css\";\n        }\n        return css;\n    }\n\n    /**\n     * The font to use within diagrams.  Modify the .css to specify HTML fonts.\n     *\n     * @param font\n     */\n    public void setFont(String font) {\n        this.font = font;\n    }\n\n    /**\n     * @see #setFont(String)\n     */\n    public String getFont() {\n        if (font == null) {\n            font = pullParam(\"-font\");\n            if (font == null)\n                font = \"Helvetica\";\n        }\n        return font;\n    }\n\n    /**\n     * The font size to use within diagrams.  This is the size of the font used for\n     * 'large' (e.g. not 'compact') diagrams.<p>\n     *\n     * Modify the .css to specify HTML font sizes.<p>\n     *\n     * Defaults to 11.\n     *\n     * @param fontSize\n     */\n    public void setFontSize(int fontSize) {\n        this.fontSize = new Integer(fontSize);\n    }\n\n    /**\n     * @see #setFontSize(int)\n     * @return\n     */\n    public int getFontSize() {\n        if (fontSize == null) {\n            // default\n            int size = 11;\n            try {\n                size = Integer.parseInt(pullParam(\"-fontsize\"));\n            } catch (Exception notSpecified) {\n            }\n            fontSize = new Integer(size);\n        }\n        return fontSize.intValue();\n    }\n\n    /**\n     * The character set to use within HTML pages (defaults to <code>\"ISO-8859-1\"</code>).\n     *\n     * @param charset\n     */\n    public void setCharset(String charset) {\n        this.charset = charset;\n    }\n\n    /**\n     * @see #setCharset(String)\n     */\n    public String getCharset() {\n        if (charset == null) {\n            charset = pullParam(\"-charset\");\n            if (charset == null)\n                charset = \"ISO-8859-1\";\n        }\n        return charset;\n    }\n\n    /**\n     * Description of schema that gets display on main pages.\n     *\n     * @param description\n     */\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    /**\n     * @see #setDescription(String)\n     */\n    public String getDescription() {\n        if (description == null)\n            description = pullParam(\"-desc\");\n        return description;\n    }\n\n    /**\n     * Maximum number of threads to use when querying database metadata information.\n     *\n     * @param maxDbThreads\n     */\n    public void setMaxDbThreads(int maxDbThreads) {\n        this.maxDbThreads = new Integer(maxDbThreads);\n    }\n\n    /**\n     * @see #setMaxDbThreads(int)\n     * @throws InvalidConfigurationException if unable to load properties\n     */\n    public int getMaxDbThreads() throws InvalidConfigurationException {\n        if (maxDbThreads == null) {\n            Properties properties;\n            try {\n                properties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(\"Failed to load properties for \" + getDbType() + \": \" + exc).setParamName(\"-type\");\n            }\n            // not scientifically derived\n            final int defaultMax = 15;\n            int max = defaultMax;\n            String threads = properties.getProperty(\"dbThreads\");\n            if (threads == null)\n                threads = properties.getProperty(\"dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            threads = pullParam(\"-dbThreads\");\n            if (threads == null)\n                threads = pullParam(\"-dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            if (max < 0)\n                max = defaultMax;\n            else if (max == 0)\n                max = 1;\n            maxDbThreads = new Integer(max);\n        }\n        return maxDbThreads.intValue();\n    }\n\n    public boolean isLogoEnabled() {\n        if (logoEnabled == null)\n            logoEnabled = !options.remove(\"-nologo\");\n        return logoEnabled;\n    }\n\n    /**\n     * Don't use this unless absolutely necessary as it screws up the layout\n     *\n     * @param enabled\n     */\n    public void setRankDirBugEnabled(boolean enabled) {\n        rankDirBugEnabled = enabled;\n    }\n\n    /**\n     * @see #setRankDirBugEnabled(boolean)\n     */\n    public boolean isRankDirBugEnabled() {\n        if (rankDirBugEnabled == null)\n            rankDirBugEnabled = options.remove(\"-rankdirbug\");\n        return rankDirBugEnabled;\n    }\n\n    /**\n     * Look for Ruby on Rails-based naming conventions in\n     * relationships between logical foreign keys and primary keys.<p>\n     *\n     * Basically all tables have a primary key named <code>ID</code>.\n     * All tables are named plural names.\n     * The columns that logically reference that <code>ID</code> are the singular\n     * form of the table name suffixed with <code>_ID</code>.<p>\n     *\n     * @param enabled\n     */\n    public void setRailsEnabled(boolean enabled) {\n        railsEnabled = enabled;\n    }\n\n    /**\n     * @see #setRailsEnabled(boolean)\n     *\n     * @return\n     */\n    public boolean isRailsEnabled() {\n        if (railsEnabled == null)\n            railsEnabled = options.remove(\"-rails\");\n        return railsEnabled;\n    }\n\n    /**\n     * Allow Html In Comments - encode them unless otherwise specified\n     */\n    public void setEncodeCommentsEnabled(boolean enabled) {\n        encodeCommentsEnabled = enabled;\n    }\n\n    /**\n     * @see #setEncodeCommentsEnabled(boolean)\n     */\n    public boolean isEncodeCommentsEnabled() {\n        if (encodeCommentsEnabled == null)\n            encodeCommentsEnabled = !options.remove(\"-ahic\");\n        return encodeCommentsEnabled;\n    }\n\n    /**\n     * If enabled we'll attempt to query/render the number of rows that\n     * each table contains.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setNumRowsEnabled(boolean enabled) {\n        numRowsEnabled = enabled;\n    }\n\n    /**\n     * @see #setNumRowsEnabled(boolean)\n     * @return\n     */\n    public boolean isNumRowsEnabled() {\n        if (numRowsEnabled == null)\n            numRowsEnabled = !options.remove(\"-norows\");\n        return numRowsEnabled;\n    }\n\n    /**\n     * If enabled we'll include views in the analysis.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setViewsEnabled(boolean enabled) {\n        viewsEnabled = enabled;\n    }\n\n    /**\n     * @see #setViewsEnabled(boolean)\n     * @return\n     */\n    public boolean isViewsEnabled() {\n        if (viewsEnabled == null)\n            viewsEnabled = !options.remove(\"-noviews\");\n        return viewsEnabled;\n    }\n\n    /**\n     * Returns <code>true</code> if metering should be embedded in\n     * the generated pages.<p/>\n     * Defaults to <code>false</code> (disabled).\n     * @return\n     */\n    public boolean isMeterEnabled() {\n        if (meterEnabled == null)\n            meterEnabled = options.remove(\"-meter\");\n        return meterEnabled;\n    }\n\n    /**\n     * Set the columns to exclude from all relationship diagrams.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setColumnExclusions(String columnExclusions) {\n        this.columnExclusions = Pattern.compile(columnExclusions);\n    }\n\n    /**\n     * See {@link #setColumnExclusions(String)}\n     * @return\n     */\n    public Pattern getColumnExclusions() {\n        if (columnExclusions == null) {\n            String strExclusions = pullParam(\"-X\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.columnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            columnExclusions = Pattern.compile(strExclusions);\n        }\n        return columnExclusions;\n    }\n\n    /**\n     * Set the columns to exclude from relationship diagrams where the specified\n     * columns aren't directly referenced by the focal table.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setIndirectColumnExclusions(String fullColumnExclusions) {\n        indirectColumnExclusions = Pattern.compile(fullColumnExclusions);\n    }\n\n    /**\n     * @see #setIndirectColumnExclusions(String)\n     *\n     * @return\n     */\n    public Pattern getIndirectColumnExclusions() {\n        if (indirectColumnExclusions == null) {\n            String strExclusions = pullParam(\"-x\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.indirectColumnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            indirectColumnExclusions = Pattern.compile(strExclusions);\n        }\n        return indirectColumnExclusions;\n    }\n\n    /**\n     * Set the tables to include as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableInclusions(String tableInclusions) {\n        this.tableInclusions = Pattern.compile(tableInclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to include in the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableInclusions() {\n        if (tableInclusions == null) {\n            String strInclusions = pullParam(\"-i\");\n            if (strInclusions == null)\n                strInclusions = System.getenv(\"schemaspy.tableInclusions\");\n            if (strInclusions == null)\n                strInclusions = DEFAULT_TABLE_INCLUSION;\n            try {\n                tableInclusions = Pattern.compile(strInclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-i\");\n            }\n        }\n        return tableInclusions;\n    }\n\n    /**\n     * Set the tables to exclude as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableExclusions(String tableExclusions) {\n        this.tableExclusions = Pattern.compile(tableExclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to exclude from the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableExclusions() {\n        if (tableExclusions == null) {\n            String strExclusions = pullParam(\"-I\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.tableExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_TABLE_EXCLUSION;\n            try {\n                tableExclusions = Pattern.compile(strExclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-I\");\n            }\n        }\n        return tableExclusions;\n    }\n\n    /**\n     * @return\n     */\n    public List<String> getSchemas() {\n        if (schemas == null) {\n            String tmp = pullParam(\"-schemas\");\n            if (tmp == null)\n                tmp = pullParam(\"-schemata\");\n            if (tmp != null) {\n                schemas = new ArrayList<String>();\n                for (String name : tmp.split(\"[\\\\s,'\\\"]\")) {\n                    if (name.length() > 0)\n                        schemas.add(name);\n                }\n                if (schemas.isEmpty())\n                    schemas = null;\n            }\n        }\n        return schemas;\n    }\n\n    /**\n     * Set the name of the {@link SqlFormatter SQL formatter} class to use to\n     * format SQL into HTML.<p/>\n     * The implementation of the class must be made available to the class\n     * loader, typically by specifying the path to its jar with <em>-dp</em>\n     * ({@link #setDriverPath(String)}).\n     */\n    public void setSqlFormatter(String formatterClassName) {\n        sqlFormatterClass = formatterClassName;\n        sqlFormatter = null;\n    }\n\n    /**\n     * Set the {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.\n     */\n    public void setSqlFormatter(SqlFormatter sqlFormatter) {\n        this.sqlFormatter = sqlFormatter;\n        if (sqlFormatter != null)\n            sqlFormatterClass = sqlFormatter.getClass().getName();\n    }\n\n    /**\n     * Returns an implementation of {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.  The default implementation is {@link DefaultSqlFormatter}.\n     *\n     * @return\n     * @throws InvalidConfigurationException if unable to instantiate an instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SqlFormatter getSqlFormatter() throws InvalidConfigurationException {\n        if (sqlFormatter == null) {\n            if (sqlFormatterClass == null) {\n                sqlFormatterClass = pullParam(\"-sqlFormatter\");\n                if (sqlFormatterClass == null)\n                    sqlFormatterClass = DefaultSqlFormatter.class.getName();\n            }\n            try {\n                Class<SqlFormatter> clazz = (Class<SqlFormatter>) Class.forName(sqlFormatterClass);\n                sqlFormatter = clazz.newInstance();\n            } catch (Exception exc) {\n                throw new InvalidConfigurationException(\"Failed to initialize instance of SQL formatter: \", exc).setParamName(\"-sqlFormatter\");\n            }\n        }\n        return sqlFormatter;\n    }\n\n    /**\n     * Set the details to show on the columns page, where \"details\" are\n     * comma and/or space separated.\n     *\n     * Valid values:\n     * <ul>\n     * <li>id</li>\n     * <li>table</li>\n     * <li>column</li>\n     * <li>type</li>\n     * <li>size</li>\n     * <li>nulls</li>\n     * <li>auto</li>\n     * <li>default</li>\n     * <li>children</li>\n     * <li>parents</li>\n     * </ul>\n     *\n     * The default details are <code>\"table column type size nulls auto default\"</code>.\n     * Note that \"column\" is the initially displayed detail and must be included.\n     *\n     * @param columnDetails\n     */\n    public void setColumnDetails(String columnDetails) {\n        this.columnDetails = new ArrayList<String>();\n        if (columnDetails == null || columnDetails.length() == 0) {\n            // not specified, so use defaults\n            columnDetails = \"id table column type size nulls auto default\";\n        }\n        for (String detail : columnDetails.split(\"[\\\\s,'\\\"]\")) {\n            if (detail.length() > 0) {\n                this.columnDetails.add(detail.toLowerCase());\n            }\n        }\n        if (!this.columnDetails.contains(\"column\"))\n            throw new InvalidConfigurationException(\"'column' is a required column detail\");\n    }\n\n    public void setColumnDetails(List<String> columnDetails) {\n        String details = columnDetails == null ? \"[]\" : columnDetails.toString();\n        setColumnDetails(details.substring(1, details.length() - 1));\n    }\n\n    public List<String> getColumnDetails() {\n        if (columnDetails == null) {\n            setColumnDetails(pullParam(\"-columndetails\"));\n        }\n        return columnDetails;\n    }\n\n    public void setEvaluateAllEnabled(boolean enabled) {\n        evaluteAll = enabled;\n    }\n\n    public boolean isEvaluateAllEnabled() {\n        if (evaluteAll == null)\n            evaluteAll = options.remove(\"-all\");\n        return evaluteAll;\n    }\n\n    /**\n     * Returns true if we're evaluating a bunch of schemas in one go and\n     * at this point we're evaluating a specific schema.\n     *\n     * @return boolean\n     */\n    public boolean isOneOfMultipleSchemas() {\n        // set by MultipleSchemaAnalyzer\n        return Boolean.getBoolean(\"oneofmultipleschemas\");\n    }\n\n    /**\n     * When -all (evaluateAll) is specified then this is the regular\n     * expression that determines which schemas to evaluate.\n     *\n     * @param schemaSpec\n     */\n    public void setSchemaSpec(String schemaSpec) {\n        this.schemaSpec = schemaSpec;\n    }\n\n    public String getSchemaSpec() {\n        if (schemaSpec == null)\n            schemaSpec = pullParam(\"-schemaSpec\");\n        return schemaSpec;\n    }\n\n    /**\n     * Set the renderer to use for the -Tpng[:renderer[:formatter]] dot option as specified\n     * at <a href='http://www.graphviz.org/doc/info/command.html'>\n     * http://www.graphviz.org/doc/info/command.html</a>.<p>\n     * Note that the leading \":\" is required while :formatter is optional.<p>\n     * The default renderer is typically GD.<p>\n     * Note that using {@link #setHighQuality(boolean)} is the preferred approach\n     * over using this method.\n     */\n    public void setRenderer(String renderer) {\n        Dot.getInstance().setRenderer(renderer);\n    }\n\n    /**\n     * @see #setRenderer(String)\n     * @return\n     */\n    public String getRenderer() {\n        String renderer = pullParam(\"-renderer\");\n        if (renderer != null)\n            setRenderer(renderer);\n        return Dot.getInstance().getRenderer();\n    }\n\n    /**\n     * If <code>false</code> then generate output of \"lower quality\"\n     * than the default.\n     * Note that the default is intended to be \"higher quality\",\n     * but various installations of Graphviz may have have different abilities.\n     * That is, some might not have the \"lower quality\" libraries and others might\n     * not have the \"higher quality\" libraries.<p>\n     * Higher quality output takes longer to generate and results in significantly\n     * larger image files (which take longer to download / display), but it generally\n     * looks better.\n     */\n    public void setHighQuality(boolean highQuality) {\n        this.highQuality = highQuality;\n        lowQuality = !highQuality;\n        Dot.getInstance().setHighQuality(highQuality);\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isHighQuality() {\n        if (highQuality == null) {\n            highQuality = options.remove(\"-hq\");\n            if (highQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(highQuality);\n            }\n        }\n        highQuality = Dot.getInstance().isHighQuality();\n        return highQuality;\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isLowQuality() {\n        if (lowQuality == null) {\n            lowQuality = options.remove(\"-lq\");\n            if (lowQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(!lowQuality);\n            }\n        }\n        lowQuality = !Dot.getInstance().isHighQuality();\n        return lowQuality;\n    }\n\n    /**\n     * Set the level of logging to perform.<p/>\n     * The levels in descending order are:\n     * <ul>\n     *  <li><code>severe</code> (highest - least detail)\n     *  <li><code>warning</code> (default)\n     *  <li><code>info</code>\n     *  <li><code>config</code>\n     *  <li><code>fine</code>\n     *  <li><code>finer</code>\n     *  <li><code>finest</code>  (lowest - most detail)\n     * </ul>\n     *\n     * @param logLevel\n     */\n    public void setLogLevel(String logLevel) {\n        if (logLevel == null) {\n            this.logLevel = Level.WARNING;\n            return;\n        }\n        Map<String, Level> levels = new LinkedHashMap<String, Level>();\n        levels.put(\"severe\", Level.SEVERE);\n        levels.put(\"warning\", Level.WARNING);\n        levels.put(\"info\", Level.INFO);\n        levels.put(\"config\", Level.CONFIG);\n        levels.put(\"fine\", Level.FINE);\n        levels.put(\"finer\", Level.FINER);\n        levels.put(\"finest\", Level.FINEST);\n        this.logLevel = levels.get(logLevel.toLowerCase());\n        if (this.logLevel == null) {\n            throw new InvalidConfigurationException(\"Invalid logLevel: '\" + logLevel + \"'. Must be one of: \" + levels.keySet());\n        }\n    }\n\n    /**\n     * Returns the level of logging to perform.\n     * See {@link #setLogLevel(String)}.\n     *\n     * @return\n     */\n    public Level getLogLevel() {\n        if (logLevel == null) {\n            setLogLevel(pullParam(\"-loglevel\"));\n        }\n        return logLevel;\n    }\n\n    /**\n     * Returns <code>true</code> if the options indicate that the user wants\n     * to see some help information.\n     *\n     * @return\n     */\n    public boolean isHelpRequired() {\n        return helpRequired;\n    }\n\n    public boolean isDbHelpRequired() {\n        return dbHelpRequired;\n    }\n\n    /**\n     * Returns the jar that we were loaded from\n     *\n     * @return\n     */\n    public static String getLoadedFromJar() {\n        String classpath = System.getProperty(\"java.class.path\");\n        return new StringTokenizer(classpath, File.pathSeparator).nextToken();\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasOrphans(boolean hasOrphans) {\n        this.hasOrphans = hasOrphans;\n    }\n\n    /**\n     * @see #setHasOrphans()\n     *\n     * @return\n     */\n    public boolean hasOrphans() {\n        return hasOrphans;\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasRoutines(boolean hasRoutines) {\n        this.hasRoutines = hasRoutines;\n    }\n\n    /**\n     * @see #setHasRoutines()\n     *\n     * @return\n     */\n    public boolean hasRoutines() {\n        return hasRoutines;\n    }\n\n    /**\n     * Returns the database properties to use.\n     * These should be determined by calling {@link #determineDbProperties(String)}.\n     * @return\n     * @throws InvalidConfigurationException\n     */\n    public Properties getDbProperties() throws InvalidConfigurationException {\n        if (dbProperties == null) {\n            try {\n                dbProperties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(exc);\n            }\n        }\n        return dbProperties;\n    }\n\n    /**\n     * Determines the database properties associated with the specified type.\n     * A call to {@link #setDbProperties(Properties)} is expected after determining\n     * the complete set of properties.\n     *\n     * @param type\n     * @return\n     * @throws IOException\n     * @throws InvalidConfigurationException if db properties are incorrectly formed\n     */\n    public Properties determineDbProperties(String type) throws IOException, InvalidConfigurationException {\n        ResourceBundle bundle = null;\n        try {\n            File propertiesFile = new File(type);\n            bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n            dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n        } catch (FileNotFoundException notFoundOnFilesystemWithoutExtension) {\n            try {\n                File propertiesFile = new File(type + \".properties\");\n                bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n                dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n            } catch (FileNotFoundException notFoundOnFilesystemWithExtensionTackedOn) {\n                try {\n                    bundle = ResourceBundle.getBundle(type);\n                    dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]\" + File.separator + type + \".properties\";\n                } catch (Exception notInJarWithoutPath) {\n                    try {\n                        String path = TableOrderer.class.getPackage().getName() + \".dbTypes.\" + type;\n                        path = path.replace('.', '/');\n                        bundle = ResourceBundle.getBundle(path);\n                        dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]/\" + path + \".properties\";\n                    } catch (Exception notInJar) {\n                        notInJar.printStackTrace();\n                        notFoundOnFilesystemWithExtensionTackedOn.printStackTrace();\n                        throw notFoundOnFilesystemWithoutExtension;\n                    }\n                }\n            }\n        }\n        Properties props = asProperties(bundle);\n        bundle = null;\n        // keep original thru recursion\n        String saveLoadedFrom = dbPropertiesLoadedFrom;\n        // bring in key/values pointed to by the include directive\n        // example: include.1=mysql::selectRowCountSql\n        for (int i = 1; true; ++i) {\n            String include = (String) props.remove(\"include.\" + i);\n            if (include == null)\n                break;\n            int separator = include.indexOf(\"::\");\n            if (separator == -1)\n                throw new InvalidConfigurationException(\"include directive in \" + dbPropertiesLoadedFrom + \" must have '::' between dbType and key\");\n            String refdType = include.substring(0, separator).trim();\n            String refdKey = include.substring(separator + 2).trim();\n            // recursively resolve the ref'd properties file and the ref'd key\n            Properties refdProps = determineDbProperties(refdType);\n            props.put(refdKey, refdProps.getProperty(refdKey));\n        }\n        // bring in base properties files pointed to by the extends directive\n        String baseDbType = (String) props.remove(\"extends\");\n        if (baseDbType != null) {\n            baseDbType = baseDbType.trim();\n            Properties baseProps = determineDbProperties(baseDbType);\n            // overlay our properties on top of the base's\n            baseProps.putAll(props);\n            props = baseProps;\n        }\n        // done with this level of recursion...restore original\n        dbPropertiesLoadedFrom = saveLoadedFrom;\n        // this won't be correct until the final recursion exits\n        dbProperties = props;\n        return props;\n    }\n\n    protected String getDbPropertiesLoadedFrom() throws IOException {\n        if (dbPropertiesLoadedFrom == null)\n            determineDbProperties(getDbType());\n        return dbPropertiesLoadedFrom;\n    }\n\n    public List<String> getRemainingParameters() {\n        try {\n            populate();\n        } catch (IllegalArgumentException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (IllegalAccessException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (InvocationTargetException exc) {\n            if (exc.getCause() instanceof InvalidConfigurationException)\n                throw (InvalidConfigurationException) exc.getCause();\n            throw new InvalidConfigurationException(exc.getCause());\n        } catch (IntrospectionException exc) {\n            throw new InvalidConfigurationException(exc);\n        }\n        return options;\n    }\n\n    /**\n     * Options that are specific to a type of database.  E.g. things like <code>host</code>,\n     * <code>port</code> or <code>db</code>, but <b>don't</b> have a setter in this class.\n     *\n     * @param dbSpecificOptions\n     */\n    public void setDbSpecificOptions(Map<String, String> dbSpecificOptions) {\n        this.dbSpecificOptions = dbSpecificOptions;\n        originalDbSpecificOptions = new HashMap<String, String>(dbSpecificOptions);\n    }\n\n    public Map<String, String> getDbSpecificOptions() {\n        if (dbSpecificOptions == null)\n            dbSpecificOptions = new HashMap<String, String>();\n        return dbSpecificOptions;\n    }\n\n    /**\n     * Returns a {@link Properties} populated with the contents of <code>bundle</code>\n     *\n     * @param bundle ResourceBundle\n     * @return Properties\n     */\n    public static Properties asProperties(ResourceBundle bundle) {\n        Properties props = new Properties();\n        Enumeration<String> iter = bundle.getKeys();\n        while (iter.hasMoreElements()) {\n            String key = iter.nextElement();\n            props.put(key, bundle.getObject(key));\n        }\n        return props;\n    }\n\n    /**\n     * 'Pull' the specified parameter from the collection of options. Returns\n     * null if the parameter isn't in the list and removes it if it is.\n     *\n     * @param paramId\n     * @return\n     */\n    private String pullParam(String paramId) {\n        return pullParam(paramId, false, false);\n    }\n\n    private String pullRequiredParam(String paramId) {\n        return pullParam(paramId, true, false);\n    }\n\n    /**\n     * @param paramId\n     * @param required\n     * @param dbTypeSpecific\n     * @return\n     * @throws MissingRequiredParameterException\n     */\n    private String pullParam(String paramId, boolean required, boolean dbTypeSpecific) throws MissingRequiredParameterException {\n        int paramIndex = options.indexOf(paramId);\n        if (paramIndex < 0) {\n            if (required)\n                throw new MissingRequiredParameterException(paramId, dbTypeSpecific);\n            return null;\n        }\n        options.remove(paramIndex);\n        String param = options.get(paramIndex).toString();\n        options.remove(paramIndex);\n        return param;\n    }\n\n    /**\n     * Thrown to indicate that a required parameter is missing\n     */\n    public static class MissingRequiredParameterException extends RuntimeException {\n\n        private static final long serialVersionUID = 1L;\n\n        private final boolean dbTypeSpecific;\n\n        public MissingRequiredParameterException(String paramId, boolean dbTypeSpecific) {\n            this(paramId, null, dbTypeSpecific);\n        }\n\n        public MissingRequiredParameterException(String paramId, String description, boolean dbTypeSpecific) {\n            super(\"Required parameter '\" + paramId + \"' \" + (description == null ? \"\" : \"(\" + description + \") \") + \"was not specified.\" + (dbTypeSpecific ? \"  It is required for this database type.\" : \"\"));\n            this.dbTypeSpecific = dbTypeSpecific;\n        }\n\n        public boolean isDbTypeSpecific() {\n            return dbTypeSpecific;\n        }\n    }\n\n    /**\n     * Allow an equal sign in args...like \"-o=foo.bar\". Useful for things like\n     * Ant and Maven.\n     *\n     * @param args\n     *            List\n     * @return List\n     */\n    protected List<String> fixupArgs(List<String> args) {\n        List<String> expandedArgs = new ArrayList<String>();\n        for (String arg : args) {\n            int indexOfEquals = arg.indexOf('=');\n            if (indexOfEquals != -1 && indexOfEquals - 1 != arg.indexOf(ESCAPED_EQUALS)) {\n                expandedArgs.add(arg.substring(0, indexOfEquals));\n                expandedArgs.add(arg.substring(indexOfEquals + 1));\n            } else {\n                expandedArgs.add(arg);\n            }\n        }\n        // some OSes/JVMs do filename expansion with runtime.exec() and some don't,\n        // so MultipleSchemaAnalyzer has to surround params with double quotes...\n        // strip them here for the OSes/JVMs that don't do anything with the params\n        List<String> unquotedArgs = new ArrayList<String>();\n        for (String arg : expandedArgs) {\n            if (// \".*\" becomes .*\n            arg.startsWith(\"\\\"\") && arg.endsWith(\"\\\"\"))\n                arg = arg.substring(1, arg.length() - 1);\n            unquotedArgs.add(arg);\n        }\n        return unquotedArgs;\n    }\n\n    /**\n     * Call all the getters to populate all the lazy initialized stuff.\n     *\n     * @throws InvocationTargetException\n     * @throws IllegalAccessException\n     * @throws IllegalArgumentException\n     * @throws IntrospectionException\n     */\n    private void populate() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IntrospectionException {\n        if (!populating) {\n            // prevent recursion\n            populating = true;\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                Method readMethod = props[i].getReadMethod();\n                if (readMethod != null)\n                    readMethod.invoke(this, (Object[]) null);\n            }\n            populating = false;\n        }\n    }\n\n    public static Set<String> getBuiltInDatabaseTypes(String loadedFromJar) {\n        Set<String> databaseTypes = new TreeSet<String>();\n        JarInputStream jar = null;\n        try {\n            jar = new JarInputStream(new FileInputStream(loadedFromJar));\n            JarEntry entry;\n            while ((entry = jar.getNextJarEntry()) != null) {\n                String entryName = entry.getName();\n                int dotPropsIndex = entryName.indexOf(\".properties\");\n                if (dotPropsIndex != -1)\n                    databaseTypes.add(entryName.substring(0, dotPropsIndex));\n            }\n        } catch (IOException exc) {\n        } finally {\n            if (jar != null) {\n                try {\n                    jar.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n        return databaseTypes;\n    }\n\n    protected void dumpUsage(String errorMessage, boolean detailedDb) {\n        if (errorMessage != null) {\n            System.out.flush();\n            System.err.println(\"*** \" + errorMessage + \" ***\");\n        } else {\n            System.out.println(\"SchemaSpy generates an HTML representation of a database schema's relationships.\");\n        }\n        System.err.flush();\n        System.out.println();\n        if (!detailedDb) {\n            System.out.println(\"Usage:\");\n            System.out.println(\" java -jar \" + getLoadedFromJar() + \" [options]\");\n            System.out.println(\"   -t databaseType       type of database - defaults to ora\");\n            System.out.println(\"                           use -dbhelp for a list of built-in types\");\n            System.out.println(\"   -u user               connect to the database with this user id\");\n            System.out.println(\"   -s schema             defaults to the specified user\");\n            System.out.println(\"   -p password           defaults to no password\");\n            System.out.println(\"   -o outputDirectory    directory to place the generated output in\");\n            System.out.println(\"   -dp pathToDrivers     optional - looks for JDBC drivers here before looking\");\n            System.out.println(\"                           in driverPath in [databaseType].properties.\");\n            System.out.println(\"Go to http://schemaspy.sourceforge.net for a complete list/description\");\n            System.out.println(\" of additional parameters.\");\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"Built-in database types and their required connection parameters:\");\n            for (String type : getBuiltInDatabaseTypes(getLoadedFromJar())) {\n                new DbSpecificConfig(type).dumpUsage();\n            }\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"You can use your own database types by specifying the filespec of a .properties file with -t.\");\n            System.out.println(\"Grab one out of \" + getLoadedFromJar() + \" and modify it to suit your needs.\");\n            System.out.println();\n        }\n        System.out.println(\"Sample usage using the default database type (implied -t ora):\");\n        System.out.println(\" java -jar schemaSpy.jar -db mydb -s myschema -u devuser -p password -o output\");\n        System.out.println();\n        System.out.flush();\n    }\n\n    /**\n     * Get the value of the specified parameter.\n     * Used for properties that are common to most db's, but aren't required.\n     *\n     * @param paramName\n     * @return\n     */\n    public String getParam(String paramName) {\n        try {\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                PropertyDescriptor prop = props[i];\n                if (prop.getName().equalsIgnoreCase(paramName)) {\n                    Object result = prop.getReadMethod().invoke(this, (Object[]) null);\n                    return result == null ? null : result.toString();\n                }\n            }\n        } catch (Exception failed) {\n            failed.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * Return all of the configuration options as a List of Strings, with\n     * each parameter and its value as a separate element.\n     *\n     * @return\n     * @throws IOException\n     */\n    public List<String> asList() throws IOException {\n        List<String> params = new ArrayList<String>();\n        if (originalDbSpecificOptions != null) {\n            for (String key : originalDbSpecificOptions.keySet()) {\n                String value = originalDbSpecificOptions.get(key);\n                if (!key.startsWith(\"-\"))\n                    key = \"-\" + key;\n                params.add(key);\n                params.add(value);\n            }\n        }\n        if (isEncodeCommentsEnabled())\n            params.add(\"-ahic\");\n        if (isEvaluateAllEnabled())\n            params.add(\"-all\");\n        if (!isHtmlGenerationEnabled())\n            params.add(\"-nohtml\");\n        if (!isImpliedConstraintsEnabled())\n            params.add(\"-noimplied\");\n        if (!isLogoEnabled())\n            params.add(\"-nologo\");\n        if (isMeterEnabled())\n            params.add(\"-meter\");\n        if (!isNumRowsEnabled())\n            params.add(\"-norows\");\n        if (!isViewsEnabled())\n            params.add(\"-noviews\");\n        if (isRankDirBugEnabled())\n            params.add(\"-rankdirbug\");\n        if (isRailsEnabled())\n            params.add(\"-rails\");\n        if (isSingleSignOn())\n            params.add(\"-sso\");\n        if (isSchemaDisabled())\n            params.add(\"-noschema\");\n        String value = getDriverPath();\n        if (value != null) {\n            params.add(\"-dp\");\n            params.add(value);\n        }\n        params.add(\"-css\");\n        params.add(getCss());\n        params.add(\"-charset\");\n        params.add(getCharset());\n        params.add(\"-font\");\n        params.add(getFont());\n        params.add(\"-fontsize\");\n        params.add(String.valueOf(getFontSize()));\n        params.add(\"-t\");\n        params.add(getDbType());\n        // query to set renderer correctly\n        isHighQuality();\n        // query to set renderer correctly\n        isLowQuality();\n        // instead of -hq and/or -lq\n        params.add(\"-renderer\");\n        params.add(getRenderer());\n        value = getDescription();\n        if (value != null) {\n            params.add(\"-desc\");\n            params.add(value);\n        }\n        value = getPassword();\n        if (value != null && !isPromptForPasswordEnabled()) {\n            // note that we don't pass -pfp since child processes\n            // won't have a console\n            params.add(\"-p\");\n            params.add(value);\n        }\n        value = getCatalog();\n        if (value != null) {\n            params.add(\"-cat\");\n            params.add(value);\n        }\n        value = getSchema();\n        if (value != null) {\n            params.add(\"-s\");\n            params.add(value);\n        }\n        value = getUser();\n        if (value != null) {\n            params.add(\"-u\");\n            params.add(value);\n        }\n        value = getConnectionPropertiesFile();\n        if (value != null) {\n            params.add(\"-connprops\");\n            params.add(value);\n        } else {\n            Properties props = getConnectionProperties();\n            if (!props.isEmpty()) {\n                params.add(\"-connprops\");\n                StringBuilder buf = new StringBuilder();\n                for (Entry<Object, Object> entry : props.entrySet()) {\n                    buf.append(entry.getKey());\n                    buf.append(ESCAPED_EQUALS);\n                    buf.append(entry.getValue());\n                    buf.append(';');\n                }\n                params.add(buf.toString());\n            }\n        }\n        value = getDb();\n        if (value != null) {\n            params.add(\"-db\");\n            params.add(value);\n        }\n        value = getHost();\n        if (value != null) {\n            params.add(\"-host\");\n            params.add(value);\n        }\n        if (getPort() != null) {\n            params.add(\"-port\");\n            params.add(getPort().toString());\n        }\n        value = getServer();\n        if (value != null) {\n            params.add(\"-server\");\n            params.add(value);\n        }\n        value = getMeta();\n        if (value != null) {\n            params.add(\"-meta\");\n            params.add(value);\n        }\n        if (getGraphvizDir() != null) {\n            params.add(\"-gv\");\n            params.add(getGraphvizDir().toString());\n        }\n        params.add(\"-loglevel\");\n        params.add(getLogLevel().toString().toLowerCase());\n        params.add(\"-sqlFormatter\");\n        params.add(getSqlFormatter().getClass().getName());\n        params.add(\"-i\");\n        params.add(getTableInclusions().toString());\n        params.add(\"-I\");\n        params.add(getTableExclusions().toString());\n        params.add(\"-X\");\n        params.add(getColumnExclusions().toString());\n        params.add(\"-x\");\n        params.add(getIndirectColumnExclusions().toString());\n        params.add(\"-dbthreads\");\n        params.add(String.valueOf(getMaxDbThreads()));\n        params.add(\"-maxdet\");\n        params.add(String.valueOf(getMaxDetailedTables()));\n        params.add(\"-o\");\n        params.add(getOutputDir().toString());\n        return params;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/ConfigTest22.java",
		"test_prompt": "// ConfigTest22.java\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Config}.\n* It contains ten unit test cases for the {@link Config#determineDbProperties(String)} method.\n*/\nclass ConfigTest22 {"
	},
	{
		"original_code": "// Config.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\n\n/**\n * Configuration of a SchemaSpy run\n *\n * @author John Currier\n */\npublic class Config {\n\n    private static Config instance;\n\n    private final List<String> options;\n\n    private Map<String, String> dbSpecificOptions;\n\n    private Map<String, String> originalDbSpecificOptions;\n\n    private boolean helpRequired;\n\n    private boolean dbHelpRequired;\n\n    private File outputDir;\n\n    private File graphvizDir;\n\n    private String dbType;\n\n    private String catalog;\n\n    private String schema;\n\n    private List<String> schemas;\n\n    private String user;\n\n    private Boolean singleSignOn;\n\n    private Boolean noSchema;\n\n    private String password;\n\n    private Boolean promptForPassword;\n\n    private String db;\n\n    private String host;\n\n    private Integer port;\n\n    private String server;\n\n    private String meta;\n\n    private Pattern tableInclusions;\n\n    private Pattern tableExclusions;\n\n    private Pattern columnExclusions;\n\n    private Pattern indirectColumnExclusions;\n\n    private String userConnectionPropertiesFile;\n\n    private Properties userConnectionProperties;\n\n    private Integer maxDbThreads;\n\n    private Integer maxDetailedTables;\n\n    private String driverPath;\n\n    private String css;\n\n    private String charset;\n\n    private String font;\n\n    private Integer fontSize;\n\n    private String description;\n\n    private Properties dbProperties;\n\n    private String dbPropertiesLoadedFrom;\n\n    private Level logLevel;\n\n    private SqlFormatter sqlFormatter;\n\n    private String sqlFormatterClass;\n\n    private Boolean generateHtml;\n\n    private Boolean includeImpliedConstraints;\n\n    private Boolean logoEnabled;\n\n    private Boolean rankDirBugEnabled;\n\n    private Boolean encodeCommentsEnabled;\n\n    private Boolean numRowsEnabled;\n\n    private Boolean viewsEnabled;\n\n    private Boolean meterEnabled;\n\n    private Boolean railsEnabled;\n\n    private Boolean evaluteAll;\n\n    private Boolean highQuality;\n\n    private Boolean lowQuality;\n\n    // used in conjunction with evaluateAll\n    private String schemaSpec;\n\n    private boolean hasOrphans = false;\n\n    private boolean hasRoutines = false;\n\n    private boolean populating = false;\n\n    private List<String> columnDetails;\n\n    public static final String DOT_CHARSET = \"UTF-8\";\n\n    private static final String ESCAPED_EQUALS = \"\\\\=\";\n\n    // match everything\n    private static final String DEFAULT_TABLE_INCLUSION = \".*\";\n\n    // match nothing\n    private static final String DEFAULT_TABLE_EXCLUSION = \"\";\n\n    // match nothing\n    private static final String DEFAULT_COLUMN_EXCLUSION = \"[^.]\";\n\n    /**\n     * Default constructor. Intended for when you want to inject properties\n     * independently (i.e. not from a command line interface).\n     */\n    public Config() {\n        if (instance == null)\n            setInstance(this);\n        options = new ArrayList<String>();\n    }\n\n    /**\n     * Construct a configuration from an array of options (e.g. from a command\n     * line interface).\n     *\n     * @param options\n     */\n    public Config(String[] argv) {\n        setInstance(this);\n        options = fixupArgs(Arrays.asList(argv));\n        helpRequired = options.remove(\"-?\") || options.remove(\"/?\") || options.remove(\"?\") || options.remove(\"-h\") || options.remove(\"-help\") || options.remove(\"--help\");\n        dbHelpRequired = options.remove(\"-dbHelp\") || options.remove(\"-dbhelp\");\n    }\n\n    public static Config getInstance() {\n        if (instance == null)\n            instance = new Config();\n        return instance;\n    }\n\n    /**\n     * Sets the global instance.\n     *\n     * Useful for things like selecting a specific configuration in a UI.\n     *\n     * @param config\n     */\n    public static void setInstance(Config config) {\n        instance = config;\n    }\n\n    public void setHtmlGenerationEnabled(boolean generateHtml) {\n        this.generateHtml = generateHtml;\n    }\n\n    public boolean isHtmlGenerationEnabled() {\n        if (generateHtml == null)\n            generateHtml = !options.remove(\"-nohtml\");\n        return generateHtml;\n    }\n\n    public void setImpliedConstraintsEnabled(boolean includeImpliedConstraints) {\n        this.includeImpliedConstraints = includeImpliedConstraints;\n    }\n\n    public boolean isImpliedConstraintsEnabled() {\n        if (includeImpliedConstraints == null)\n            includeImpliedConstraints = !options.remove(\"-noimplied\");\n        return includeImpliedConstraints;\n    }\n\n    public void setOutputDir(String outputDirName) {\n        if (outputDirName.endsWith(\"\\\"\"))\n            outputDirName = outputDirName.substring(0, outputDirName.length() - 1);\n        setOutputDir(new File(outputDirName));\n    }\n\n    public void setOutputDir(File outputDir) {\n        this.outputDir = outputDir;\n    }\n\n    public File getOutputDir() {\n        if (outputDir == null) {\n            setOutputDir(pullRequiredParam(\"-o\"));\n        }\n        return outputDir;\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(String graphvizDir) {\n        if (graphvizDir.endsWith(\"\\\"\"))\n            graphvizDir = graphvizDir.substring(0, graphvizDir.length() - 1);\n        setGraphvizDir(new File(graphvizDir));\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(File graphvizDir) {\n        this.graphvizDir = graphvizDir;\n    }\n\n    /**\n     * Return the path to Graphviz (used to find the dot executable to run to\n     * generate ER diagrams).<p/>\n     *\n     * Returns {@link #getDefaultGraphvizPath()} if a specific Graphviz path\n     * was not specified.\n     *\n     * @return\n     */\n    public File getGraphvizDir() {\n        if (graphvizDir == null) {\n            String gv = pullParam(\"-gv\");\n            if (gv != null) {\n                setGraphvizDir(gv);\n            } else {\n                // expect to find Graphviz's bin directory on the PATH\n            }\n        }\n        return graphvizDir;\n    }\n\n    /**\n     * Meta files are XML-based files that provide additional metadata\n     * about the schema being evaluated.<p>\n     * <code>meta</code> is either the name of an individual XML file or\n     * the directory that contains meta files.<p>\n     * If a directory is specified then it is expected to contain files\n     * matching the pattern <code>[schema].meta.xml</code>.\n     * For databases that don't have schema substitute database for schema.\n     * @param meta\n     */\n    public void setMeta(String meta) {\n        this.meta = meta;\n    }\n\n    public String getMeta() {\n        if (meta == null)\n            meta = pullParam(\"-meta\");\n        return meta;\n    }\n\n    public void setDbType(String dbType) {\n        this.dbType = dbType;\n    }\n\n    public String getDbType() {\n        if (dbType == null) {\n            dbType = pullParam(\"-t\");\n            if (dbType == null)\n                dbType = \"ora\";\n        }\n        return dbType;\n    }\n\n    public void setDb(String db) {\n        this.db = db;\n    }\n\n    public String getDb() {\n        if (db == null)\n            db = pullParam(\"-db\");\n        return db;\n    }\n\n    public void setCatalog(String catalog) {\n        this.catalog = catalog;\n    }\n\n    public String getCatalog() {\n        if (catalog == null)\n            catalog = pullParam(\"-cat\");\n        return catalog;\n    }\n\n    public void setSchema(String schema) {\n        this.schema = schema;\n    }\n\n    public String getSchema() {\n        if (schema == null)\n            schema = pullParam(\"-s\");\n        return schema;\n    }\n\n    /**\n     * Some databases types (e.g. older versions of Informix) don't really\n     * have the concept of a schema but still return true from\n     * {@link DatabaseMetaData#supportsSchemasInTableDefinitions()}.\n     * This option lets you ignore that and treat all the tables\n     * as if they were in one flat namespace.\n     */\n    public boolean isSchemaDisabled() {\n        if (noSchema == null)\n            noSchema = options.remove(\"-noschema\");\n        return noSchema;\n    }\n\n    public void setHost(String host) {\n        this.host = host;\n    }\n\n    public String getHost() {\n        if (host == null)\n            host = pullParam(\"-host\");\n        return host;\n    }\n\n    public void setPort(Integer port) {\n        this.port = port;\n    }\n\n    public Integer getPort() {\n        if (port == null)\n            try {\n                port = Integer.valueOf(pullParam(\"-port\"));\n            } catch (Exception notSpecified) {\n            }\n        return port;\n    }\n\n    public void setServer(String server) {\n        this.server = server;\n    }\n\n    public String getServer() {\n        if (server == null) {\n            server = pullParam(\"-server\");\n        }\n        return server;\n    }\n\n    public void setUser(String user) {\n        this.user = user;\n    }\n\n    /**\n     * User used to connect to the database.\n     * Required unless single sign-on is enabled\n     * (see {@link #setSingleSignOn(boolean)}).\n     * @return\n     */\n    public String getUser() {\n        if (user == null) {\n            if (!isSingleSignOn())\n                user = pullRequiredParam(\"-u\");\n            else\n                user = pullParam(\"-u\");\n        }\n        return user;\n    }\n\n    /**\n     * By default a \"user\" (as specified with -u) is required.\n     * This option allows disabling of that requirement for\n     * single sign-on environments.\n     *\n     * @param enabled defaults to <code>false</code>\n     */\n    public void setSingleSignOn(boolean enabled) {\n        singleSignOn = enabled;\n    }\n\n    /**\n     * @see #setSingleSignOn(boolean)\n     */\n    public boolean isSingleSignOn() {\n        if (singleSignOn == null)\n            singleSignOn = options.remove(\"-sso\");\n        return singleSignOn;\n    }\n\n    /**\n     * Set the password used to connect to the database.\n     * @param password\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * @see #setPassword(String)\n     * @return\n     */\n    public String getPassword() {\n        if (password == null)\n            password = pullParam(\"-p\");\n        if (password == null && isPromptForPasswordEnabled())\n            password = new String(PasswordReader.getInstance().readPassword(\"Password: \"));\n        if (password == null) {\n            // if -pfp is enabled when analyzing multiple schemas then\n            // we don't want to send the password on the command line,\n            // so see if it was passed in the environment (not ideal, but safer)\n            password = System.getenv(\"schemaspy.pw\");\n        }\n        return password;\n    }\n\n    /**\n     * Set to <code>true</code> to prompt for the password\n     * @param promptForPassword\n     */\n    public void setPromptForPasswordEnabled(boolean promptForPassword) {\n        this.promptForPassword = promptForPassword;\n    }\n\n    /**\n     * @see #setPromptForPasswordEnabled(boolean)\n     * @return\n     */\n    public boolean isPromptForPasswordEnabled() {\n        if (promptForPassword == null) {\n            promptForPassword = options.remove(\"-pfp\");\n        }\n        return promptForPassword;\n    }\n\n    public void setMaxDetailedTabled(int maxDetailedTables) {\n        this.maxDetailedTables = new Integer(maxDetailedTables);\n    }\n\n    public int getMaxDetailedTables() {\n        if (maxDetailedTables == null) {\n            // default\n            int max = 300;\n            try {\n                max = Integer.parseInt(pullParam(\"-maxdet\"));\n            } catch (Exception notSpecified) {\n            }\n            maxDetailedTables = new Integer(max);\n        }\n        return maxDetailedTables.intValue();\n    }\n\n    public String getConnectionPropertiesFile() {\n        return userConnectionPropertiesFile;\n    }\n\n    /**\n     * Properties from this file (in key=value pair format) are passed to the\n     * database connection.<br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.\n     * @param propertiesFilename\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public void setConnectionPropertiesFile(String propertiesFilename) throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null)\n            userConnectionProperties = new Properties();\n        userConnectionProperties.load(new FileInputStream(propertiesFilename));\n        userConnectionPropertiesFile = propertiesFilename;\n    }\n\n    /**\n     * Returns a {@link Properties} populated either from the properties file specified\n     * by {@link #setConnectionPropertiesFile(String)}, the properties specified by\n     * {@link #setConnectionProperties(String)} or not populated.\n     * @return\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public Properties getConnectionProperties() throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null) {\n            String props = pullParam(\"-connprops\");\n            if (props != null) {\n                if (props.indexOf(ESCAPED_EQUALS) != -1) {\n                    setConnectionProperties(props);\n                } else {\n                    setConnectionPropertiesFile(props);\n                }\n            } else {\n                userConnectionProperties = new Properties();\n            }\n        }\n        return userConnectionProperties;\n    }\n\n    /**\n     * Specifies connection properties to use in the format:\n     * <code>key1\\=value1;key2\\=value2</code><br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.<p>\n     * This is an alternative form of passing connection properties than by file\n     * (see {@link #setConnectionPropertiesFile(String)})\n     *\n     * @param properties\n     */\n    public void setConnectionProperties(String properties) {\n        userConnectionProperties = new Properties();\n        StringTokenizer tokenizer = new StringTokenizer(properties, \";\");\n        while (tokenizer.hasMoreElements()) {\n            String pair = tokenizer.nextToken();\n            int index = pair.indexOf(ESCAPED_EQUALS);\n            if (index != -1) {\n                String key = pair.substring(0, index);\n                String value = pair.substring(index + ESCAPED_EQUALS.length());\n                userConnectionProperties.put(key, value);\n            }\n        }\n    }\n\n    public void setDriverPath(String driverPath) {\n        this.driverPath = driverPath;\n    }\n\n    public String getDriverPath() {\n        if (driverPath == null)\n            driverPath = pullParam(\"-dp\");\n        // was previously -cp:\n        if (driverPath == null)\n            driverPath = pullParam(\"-cp\");\n        return driverPath;\n    }\n\n    /**\n     * The filename of the cascading style sheet to use.\n     * Note that this file is parsed and used to determine characteristics\n     * of the generated diagrams, so it must contain specific settings that\n     * are documented within schemaSpy.css.<p>\n     *\n     * Defaults to <code>\"schemaSpy.css\"</code>.\n     *\n     * @param css\n     */\n    public void setCss(String css) {\n        this.css = css;\n    }\n\n    public String getCss() {\n        if (css == null) {\n            css = pullParam(\"-css\");\n            if (css == null)\n                css = \"schemaSpy.css\";\n        }\n        return css;\n    }\n\n    /**\n     * The font to use within diagrams.  Modify the .css to specify HTML fonts.\n     *\n     * @param font\n     */\n    public void setFont(String font) {\n        this.font = font;\n    }\n\n    /**\n     * @see #setFont(String)\n     */\n    public String getFont() {\n        if (font == null) {\n            font = pullParam(\"-font\");\n            if (font == null)\n                font = \"Helvetica\";\n        }\n        return font;\n    }\n\n    /**\n     * The font size to use within diagrams.  This is the size of the font used for\n     * 'large' (e.g. not 'compact') diagrams.<p>\n     *\n     * Modify the .css to specify HTML font sizes.<p>\n     *\n     * Defaults to 11.\n     *\n     * @param fontSize\n     */\n    public void setFontSize(int fontSize) {\n        this.fontSize = new Integer(fontSize);\n    }\n\n    /**\n     * @see #setFontSize(int)\n     * @return\n     */\n    public int getFontSize() {\n        if (fontSize == null) {\n            // default\n            int size = 11;\n            try {\n                size = Integer.parseInt(pullParam(\"-fontsize\"));\n            } catch (Exception notSpecified) {\n            }\n            fontSize = new Integer(size);\n        }\n        return fontSize.intValue();\n    }\n\n    /**\n     * The character set to use within HTML pages (defaults to <code>\"ISO-8859-1\"</code>).\n     *\n     * @param charset\n     */\n    public void setCharset(String charset) {\n        this.charset = charset;\n    }\n\n    /**\n     * @see #setCharset(String)\n     */\n    public String getCharset() {\n        if (charset == null) {\n            charset = pullParam(\"-charset\");\n            if (charset == null)\n                charset = \"ISO-8859-1\";\n        }\n        return charset;\n    }\n\n    /**\n     * Description of schema that gets display on main pages.\n     *\n     * @param description\n     */\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    /**\n     * @see #setDescription(String)\n     */\n    public String getDescription() {\n        if (description == null)\n            description = pullParam(\"-desc\");\n        return description;\n    }\n\n    /**\n     * Maximum number of threads to use when querying database metadata information.\n     *\n     * @param maxDbThreads\n     */\n    public void setMaxDbThreads(int maxDbThreads) {\n        this.maxDbThreads = new Integer(maxDbThreads);\n    }\n\n    /**\n     * @see #setMaxDbThreads(int)\n     * @throws InvalidConfigurationException if unable to load properties\n     */\n    public int getMaxDbThreads() throws InvalidConfigurationException {\n        if (maxDbThreads == null) {\n            Properties properties;\n            try {\n                properties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(\"Failed to load properties for \" + getDbType() + \": \" + exc).setParamName(\"-type\");\n            }\n            // not scientifically derived\n            final int defaultMax = 15;\n            int max = defaultMax;\n            String threads = properties.getProperty(\"dbThreads\");\n            if (threads == null)\n                threads = properties.getProperty(\"dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            threads = pullParam(\"-dbThreads\");\n            if (threads == null)\n                threads = pullParam(\"-dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            if (max < 0)\n                max = defaultMax;\n            else if (max == 0)\n                max = 1;\n            maxDbThreads = new Integer(max);\n        }\n        return maxDbThreads.intValue();\n    }\n\n    public boolean isLogoEnabled() {\n        if (logoEnabled == null)\n            logoEnabled = !options.remove(\"-nologo\");\n        return logoEnabled;\n    }\n\n    /**\n     * Don't use this unless absolutely necessary as it screws up the layout\n     *\n     * @param enabled\n     */\n    public void setRankDirBugEnabled(boolean enabled) {\n        rankDirBugEnabled = enabled;\n    }\n\n    /**\n     * @see #setRankDirBugEnabled(boolean)\n     */\n    public boolean isRankDirBugEnabled() {\n        if (rankDirBugEnabled == null)\n            rankDirBugEnabled = options.remove(\"-rankdirbug\");\n        return rankDirBugEnabled;\n    }\n\n    /**\n     * Look for Ruby on Rails-based naming conventions in\n     * relationships between logical foreign keys and primary keys.<p>\n     *\n     * Basically all tables have a primary key named <code>ID</code>.\n     * All tables are named plural names.\n     * The columns that logically reference that <code>ID</code> are the singular\n     * form of the table name suffixed with <code>_ID</code>.<p>\n     *\n     * @param enabled\n     */\n    public void setRailsEnabled(boolean enabled) {\n        railsEnabled = enabled;\n    }\n\n    /**\n     * @see #setRailsEnabled(boolean)\n     *\n     * @return\n     */\n    public boolean isRailsEnabled() {\n        if (railsEnabled == null)\n            railsEnabled = options.remove(\"-rails\");\n        return railsEnabled;\n    }\n\n    /**\n     * Allow Html In Comments - encode them unless otherwise specified\n     */\n    public void setEncodeCommentsEnabled(boolean enabled) {\n        encodeCommentsEnabled = enabled;\n    }\n\n    /**\n     * @see #setEncodeCommentsEnabled(boolean)\n     */\n    public boolean isEncodeCommentsEnabled() {\n        if (encodeCommentsEnabled == null)\n            encodeCommentsEnabled = !options.remove(\"-ahic\");\n        return encodeCommentsEnabled;\n    }\n\n    /**\n     * If enabled we'll attempt to query/render the number of rows that\n     * each table contains.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setNumRowsEnabled(boolean enabled) {\n        numRowsEnabled = enabled;\n    }\n\n    /**\n     * @see #setNumRowsEnabled(boolean)\n     * @return\n     */\n    public boolean isNumRowsEnabled() {\n        if (numRowsEnabled == null)\n            numRowsEnabled = !options.remove(\"-norows\");\n        return numRowsEnabled;\n    }\n\n    /**\n     * If enabled we'll include views in the analysis.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setViewsEnabled(boolean enabled) {\n        viewsEnabled = enabled;\n    }\n\n    /**\n     * @see #setViewsEnabled(boolean)\n     * @return\n     */\n    public boolean isViewsEnabled() {\n        if (viewsEnabled == null)\n            viewsEnabled = !options.remove(\"-noviews\");\n        return viewsEnabled;\n    }\n\n    /**\n     * Returns <code>true</code> if metering should be embedded in\n     * the generated pages.<p/>\n     * Defaults to <code>false</code> (disabled).\n     * @return\n     */\n    public boolean isMeterEnabled() {\n        if (meterEnabled == null)\n            meterEnabled = options.remove(\"-meter\");\n        return meterEnabled;\n    }\n\n    /**\n     * Set the columns to exclude from all relationship diagrams.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setColumnExclusions(String columnExclusions) {\n        this.columnExclusions = Pattern.compile(columnExclusions);\n    }\n\n    /**\n     * See {@link #setColumnExclusions(String)}\n     * @return\n     */\n    public Pattern getColumnExclusions() {\n        if (columnExclusions == null) {\n            String strExclusions = pullParam(\"-X\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.columnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            columnExclusions = Pattern.compile(strExclusions);\n        }\n        return columnExclusions;\n    }\n\n    /**\n     * Set the columns to exclude from relationship diagrams where the specified\n     * columns aren't directly referenced by the focal table.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setIndirectColumnExclusions(String fullColumnExclusions) {\n        indirectColumnExclusions = Pattern.compile(fullColumnExclusions);\n    }\n\n    /**\n     * @see #setIndirectColumnExclusions(String)\n     *\n     * @return\n     */\n    public Pattern getIndirectColumnExclusions() {\n        if (indirectColumnExclusions == null) {\n            String strExclusions = pullParam(\"-x\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.indirectColumnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            indirectColumnExclusions = Pattern.compile(strExclusions);\n        }\n        return indirectColumnExclusions;\n    }\n\n    /**\n     * Set the tables to include as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableInclusions(String tableInclusions) {\n        this.tableInclusions = Pattern.compile(tableInclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to include in the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableInclusions() {\n        if (tableInclusions == null) {\n            String strInclusions = pullParam(\"-i\");\n            if (strInclusions == null)\n                strInclusions = System.getenv(\"schemaspy.tableInclusions\");\n            if (strInclusions == null)\n                strInclusions = DEFAULT_TABLE_INCLUSION;\n            try {\n                tableInclusions = Pattern.compile(strInclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-i\");\n            }\n        }\n        return tableInclusions;\n    }\n\n    /**\n     * Set the tables to exclude as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableExclusions(String tableExclusions) {\n        this.tableExclusions = Pattern.compile(tableExclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to exclude from the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableExclusions() {\n        if (tableExclusions == null) {\n            String strExclusions = pullParam(\"-I\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.tableExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_TABLE_EXCLUSION;\n            try {\n                tableExclusions = Pattern.compile(strExclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-I\");\n            }\n        }\n        return tableExclusions;\n    }\n\n    /**\n     * @return\n     */\n    public List<String> getSchemas() {\n        if (schemas == null) {\n            String tmp = pullParam(\"-schemas\");\n            if (tmp == null)\n                tmp = pullParam(\"-schemata\");\n            if (tmp != null) {\n                schemas = new ArrayList<String>();\n                for (String name : tmp.split(\"[\\\\s,'\\\"]\")) {\n                    if (name.length() > 0)\n                        schemas.add(name);\n                }\n                if (schemas.isEmpty())\n                    schemas = null;\n            }\n        }\n        return schemas;\n    }\n\n    /**\n     * Set the name of the {@link SqlFormatter SQL formatter} class to use to\n     * format SQL into HTML.<p/>\n     * The implementation of the class must be made available to the class\n     * loader, typically by specifying the path to its jar with <em>-dp</em>\n     * ({@link #setDriverPath(String)}).\n     */\n    public void setSqlFormatter(String formatterClassName) {\n        sqlFormatterClass = formatterClassName;\n        sqlFormatter = null;\n    }\n\n    /**\n     * Set the {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.\n     */\n    public void setSqlFormatter(SqlFormatter sqlFormatter) {\n        this.sqlFormatter = sqlFormatter;\n        if (sqlFormatter != null)\n            sqlFormatterClass = sqlFormatter.getClass().getName();\n    }\n\n    /**\n     * Returns an implementation of {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.  The default implementation is {@link DefaultSqlFormatter}.\n     *\n     * @return\n     * @throws InvalidConfigurationException if unable to instantiate an instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SqlFormatter getSqlFormatter() throws InvalidConfigurationException {\n        if (sqlFormatter == null) {\n            if (sqlFormatterClass == null) {\n                sqlFormatterClass = pullParam(\"-sqlFormatter\");\n                if (sqlFormatterClass == null)\n                    sqlFormatterClass = DefaultSqlFormatter.class.getName();\n            }\n            try {\n                Class<SqlFormatter> clazz = (Class<SqlFormatter>) Class.forName(sqlFormatterClass);\n                sqlFormatter = clazz.newInstance();\n            } catch (Exception exc) {\n                throw new InvalidConfigurationException(\"Failed to initialize instance of SQL formatter: \", exc).setParamName(\"-sqlFormatter\");\n            }\n        }\n        return sqlFormatter;\n    }\n\n    /**\n     * Set the details to show on the columns page, where \"details\" are\n     * comma and/or space separated.\n     *\n     * Valid values:\n     * <ul>\n     * <li>id</li>\n     * <li>table</li>\n     * <li>column</li>\n     * <li>type</li>\n     * <li>size</li>\n     * <li>nulls</li>\n     * <li>auto</li>\n     * <li>default</li>\n     * <li>children</li>\n     * <li>parents</li>\n     * </ul>\n     *\n     * The default details are <code>\"table column type size nulls auto default\"</code>.\n     * Note that \"column\" is the initially displayed detail and must be included.\n     *\n     * @param columnDetails\n     */\n    public void setColumnDetails(String columnDetails) {\n        this.columnDetails = new ArrayList<String>();\n        if (columnDetails == null || columnDetails.length() == 0) {\n            // not specified, so use defaults\n            columnDetails = \"id table column type size nulls auto default\";\n        }\n        for (String detail : columnDetails.split(\"[\\\\s,'\\\"]\")) {\n            if (detail.length() > 0) {\n                this.columnDetails.add(detail.toLowerCase());\n            }\n        }\n        if (!this.columnDetails.contains(\"column\"))\n            throw new InvalidConfigurationException(\"'column' is a required column detail\");\n    }\n\n    public void setColumnDetails(List<String> columnDetails) {\n        String details = columnDetails == null ? \"[]\" : columnDetails.toString();\n        setColumnDetails(details.substring(1, details.length() - 1));\n    }\n\n    public List<String> getColumnDetails() {\n        if (columnDetails == null) {\n            setColumnDetails(pullParam(\"-columndetails\"));\n        }\n        return columnDetails;\n    }\n\n    public void setEvaluateAllEnabled(boolean enabled) {\n        evaluteAll = enabled;\n    }\n\n    public boolean isEvaluateAllEnabled() {\n        if (evaluteAll == null)\n            evaluteAll = options.remove(\"-all\");\n        return evaluteAll;\n    }\n\n    /**\n     * Returns true if we're evaluating a bunch of schemas in one go and\n     * at this point we're evaluating a specific schema.\n     *\n     * @return boolean\n     */\n    public boolean isOneOfMultipleSchemas() {\n        // set by MultipleSchemaAnalyzer\n        return Boolean.getBoolean(\"oneofmultipleschemas\");\n    }\n\n    /**\n     * When -all (evaluateAll) is specified then this is the regular\n     * expression that determines which schemas to evaluate.\n     *\n     * @param schemaSpec\n     */\n    public void setSchemaSpec(String schemaSpec) {\n        this.schemaSpec = schemaSpec;\n    }\n\n    public String getSchemaSpec() {\n        if (schemaSpec == null)\n            schemaSpec = pullParam(\"-schemaSpec\");\n        return schemaSpec;\n    }\n\n    /**\n     * Set the renderer to use for the -Tpng[:renderer[:formatter]] dot option as specified\n     * at <a href='http://www.graphviz.org/doc/info/command.html'>\n     * http://www.graphviz.org/doc/info/command.html</a>.<p>\n     * Note that the leading \":\" is required while :formatter is optional.<p>\n     * The default renderer is typically GD.<p>\n     * Note that using {@link #setHighQuality(boolean)} is the preferred approach\n     * over using this method.\n     */\n    public void setRenderer(String renderer) {\n        Dot.getInstance().setRenderer(renderer);\n    }\n\n    /**\n     * @see #setRenderer(String)\n     * @return\n     */\n    public String getRenderer() {\n        String renderer = pullParam(\"-renderer\");\n        if (renderer != null)\n            setRenderer(renderer);\n        return Dot.getInstance().getRenderer();\n    }\n\n    /**\n     * If <code>false</code> then generate output of \"lower quality\"\n     * than the default.\n     * Note that the default is intended to be \"higher quality\",\n     * but various installations of Graphviz may have have different abilities.\n     * That is, some might not have the \"lower quality\" libraries and others might\n     * not have the \"higher quality\" libraries.<p>\n     * Higher quality output takes longer to generate and results in significantly\n     * larger image files (which take longer to download / display), but it generally\n     * looks better.\n     */\n    public void setHighQuality(boolean highQuality) {\n        this.highQuality = highQuality;\n        lowQuality = !highQuality;\n        Dot.getInstance().setHighQuality(highQuality);\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isHighQuality() {\n        if (highQuality == null) {\n            highQuality = options.remove(\"-hq\");\n            if (highQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(highQuality);\n            }\n        }\n        highQuality = Dot.getInstance().isHighQuality();\n        return highQuality;\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isLowQuality() {\n        if (lowQuality == null) {\n            lowQuality = options.remove(\"-lq\");\n            if (lowQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(!lowQuality);\n            }\n        }\n        lowQuality = !Dot.getInstance().isHighQuality();\n        return lowQuality;\n    }\n\n    /**\n     * Set the level of logging to perform.<p/>\n     * The levels in descending order are:\n     * <ul>\n     *  <li><code>severe</code> (highest - least detail)\n     *  <li><code>warning</code> (default)\n     *  <li><code>info</code>\n     *  <li><code>config</code>\n     *  <li><code>fine</code>\n     *  <li><code>finer</code>\n     *  <li><code>finest</code>  (lowest - most detail)\n     * </ul>\n     *\n     * @param logLevel\n     */\n    public void setLogLevel(String logLevel) {\n        if (logLevel == null) {\n            this.logLevel = Level.WARNING;\n            return;\n        }\n        Map<String, Level> levels = new LinkedHashMap<String, Level>();\n        levels.put(\"severe\", Level.SEVERE);\n        levels.put(\"warning\", Level.WARNING);\n        levels.put(\"info\", Level.INFO);\n        levels.put(\"config\", Level.CONFIG);\n        levels.put(\"fine\", Level.FINE);\n        levels.put(\"finer\", Level.FINER);\n        levels.put(\"finest\", Level.FINEST);\n        this.logLevel = levels.get(logLevel.toLowerCase());\n        if (this.logLevel == null) {\n            throw new InvalidConfigurationException(\"Invalid logLevel: '\" + logLevel + \"'. Must be one of: \" + levels.keySet());\n        }\n    }\n\n    /**\n     * Returns the level of logging to perform.\n     * See {@link #setLogLevel(String)}.\n     *\n     * @return\n     */\n    public Level getLogLevel() {\n        if (logLevel == null) {\n            setLogLevel(pullParam(\"-loglevel\"));\n        }\n        return logLevel;\n    }\n\n    /**\n     * Returns <code>true</code> if the options indicate that the user wants\n     * to see some help information.\n     *\n     * @return\n     */\n    public boolean isHelpRequired() {\n        return helpRequired;\n    }\n\n    public boolean isDbHelpRequired() {\n        return dbHelpRequired;\n    }\n\n    /**\n     * Returns the jar that we were loaded from\n     *\n     * @return\n     */\n    public static String getLoadedFromJar() {\n        String classpath = System.getProperty(\"java.class.path\");\n        return new StringTokenizer(classpath, File.pathSeparator).nextToken();\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasOrphans(boolean hasOrphans) {\n        this.hasOrphans = hasOrphans;\n    }\n\n    /**\n     * @see #setHasOrphans()\n     *\n     * @return\n     */\n    public boolean hasOrphans() {\n        return hasOrphans;\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasRoutines(boolean hasRoutines) {\n        this.hasRoutines = hasRoutines;\n    }\n\n    /**\n     * @see #setHasRoutines()\n     *\n     * @return\n     */\n    public boolean hasRoutines() {\n        return hasRoutines;\n    }\n\n    /**\n     * Returns the database properties to use.\n     * These should be determined by calling {@link #determineDbProperties(String)}.\n     * @return\n     * @throws InvalidConfigurationException\n     */\n    public Properties getDbProperties() throws InvalidConfigurationException {\n        if (dbProperties == null) {\n            try {\n                dbProperties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(exc);\n            }\n        }\n        return dbProperties;\n    }\n\n    /**\n     * Determines the database properties associated with the specified type.\n     * A call to {@link #setDbProperties(Properties)} is expected after determining\n     * the complete set of properties.\n     *\n     * @param type\n     * @return\n     * @throws IOException\n     * @throws InvalidConfigurationException if db properties are incorrectly formed\n     */\n    public Properties determineDbProperties(String type) throws IOException, InvalidConfigurationException {\n        ResourceBundle bundle = null;\n        try {\n            File propertiesFile = new File(type);\n            bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n            dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n        } catch (FileNotFoundException notFoundOnFilesystemWithoutExtension) {\n            try {\n                File propertiesFile = new File(type + \".properties\");\n                bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n                dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n            } catch (FileNotFoundException notFoundOnFilesystemWithExtensionTackedOn) {\n                try {\n                    bundle = ResourceBundle.getBundle(type);\n                    dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]\" + File.separator + type + \".properties\";\n                } catch (Exception notInJarWithoutPath) {\n                    try {\n                        String path = TableOrderer.class.getPackage().getName() + \".dbTypes.\" + type;\n                        path = path.replace('.', '/');\n                        bundle = ResourceBundle.getBundle(path);\n                        dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]/\" + path + \".properties\";\n                    } catch (Exception notInJar) {\n                        notInJar.printStackTrace();\n                        notFoundOnFilesystemWithExtensionTackedOn.printStackTrace();\n                        throw notFoundOnFilesystemWithoutExtension;\n                    }\n                }\n            }\n        }\n        Properties props = asProperties(bundle);\n        bundle = null;\n        // keep original thru recursion\n        String saveLoadedFrom = dbPropertiesLoadedFrom;\n        // bring in key/values pointed to by the include directive\n        // example: include.1=mysql::selectRowCountSql\n        for (int i = 1; true; ++i) {\n            String include = (String) props.remove(\"include.\" + i);\n            if (include == null)\n                break;\n            int separator = include.indexOf(\"::\");\n            if (separator == -1)\n                throw new InvalidConfigurationException(\"include directive in \" + dbPropertiesLoadedFrom + \" must have '::' between dbType and key\");\n            String refdType = include.substring(0, separator).trim();\n            String refdKey = include.substring(separator + 2).trim();\n            // recursively resolve the ref'd properties file and the ref'd key\n            Properties refdProps = determineDbProperties(refdType);\n            props.put(refdKey, refdProps.getProperty(refdKey));\n        }\n        // bring in base properties files pointed to by the extends directive\n        String baseDbType = (String) props.remove(\"extends\");\n        if (baseDbType != null) {\n            baseDbType = baseDbType.trim();\n            Properties baseProps = determineDbProperties(baseDbType);\n            // overlay our properties on top of the base's\n            baseProps.putAll(props);\n            props = baseProps;\n        }\n        // done with this level of recursion...restore original\n        dbPropertiesLoadedFrom = saveLoadedFrom;\n        // this won't be correct until the final recursion exits\n        dbProperties = props;\n        return props;\n    }\n\n    protected String getDbPropertiesLoadedFrom() throws IOException {\n        if (dbPropertiesLoadedFrom == null)\n            determineDbProperties(getDbType());\n        return dbPropertiesLoadedFrom;\n    }\n\n    public List<String> getRemainingParameters() {\n        try {\n            populate();\n        } catch (IllegalArgumentException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (IllegalAccessException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (InvocationTargetException exc) {\n            if (exc.getCause() instanceof InvalidConfigurationException)\n                throw (InvalidConfigurationException) exc.getCause();\n            throw new InvalidConfigurationException(exc.getCause());\n        } catch (IntrospectionException exc) {\n            throw new InvalidConfigurationException(exc);\n        }\n        return options;\n    }\n\n    /**\n     * Options that are specific to a type of database.  E.g. things like <code>host</code>,\n     * <code>port</code> or <code>db</code>, but <b>don't</b> have a setter in this class.\n     *\n     * @param dbSpecificOptions\n     */\n    public void setDbSpecificOptions(Map<String, String> dbSpecificOptions) {\n        this.dbSpecificOptions = dbSpecificOptions;\n        originalDbSpecificOptions = new HashMap<String, String>(dbSpecificOptions);\n    }\n\n    public Map<String, String> getDbSpecificOptions() {\n        if (dbSpecificOptions == null)\n            dbSpecificOptions = new HashMap<String, String>();\n        return dbSpecificOptions;\n    }\n\n    /**\n     * Returns a {@link Properties} populated with the contents of <code>bundle</code>\n     *\n     * @param bundle ResourceBundle\n     * @return Properties\n     */\n    public static Properties asProperties(ResourceBundle bundle) {\n        Properties props = new Properties();\n        Enumeration<String> iter = bundle.getKeys();\n        while (iter.hasMoreElements()) {\n            String key = iter.nextElement();\n            props.put(key, bundle.getObject(key));\n        }\n        return props;\n    }\n\n    /**\n     * 'Pull' the specified parameter from the collection of options. Returns\n     * null if the parameter isn't in the list and removes it if it is.\n     *\n     * @param paramId\n     * @return\n     */\n    private String pullParam(String paramId) {\n        return pullParam(paramId, false, false);\n    }\n\n    private String pullRequiredParam(String paramId) {\n        return pullParam(paramId, true, false);\n    }\n\n    /**\n     * @param paramId\n     * @param required\n     * @param dbTypeSpecific\n     * @return\n     * @throws MissingRequiredParameterException\n     */\n    private String pullParam(String paramId, boolean required, boolean dbTypeSpecific) throws MissingRequiredParameterException {\n        int paramIndex = options.indexOf(paramId);\n        if (paramIndex < 0) {\n            if (required)\n                throw new MissingRequiredParameterException(paramId, dbTypeSpecific);\n            return null;\n        }\n        options.remove(paramIndex);\n        String param = options.get(paramIndex).toString();\n        options.remove(paramIndex);\n        return param;\n    }\n\n    /**\n     * Thrown to indicate that a required parameter is missing\n     */\n    public static class MissingRequiredParameterException extends RuntimeException {\n\n        private static final long serialVersionUID = 1L;\n\n        private final boolean dbTypeSpecific;\n\n        public MissingRequiredParameterException(String paramId, boolean dbTypeSpecific) {\n            this(paramId, null, dbTypeSpecific);\n        }\n\n        public MissingRequiredParameterException(String paramId, String description, boolean dbTypeSpecific) {\n            super(\"Required parameter '\" + paramId + \"' \" + (description == null ? \"\" : \"(\" + description + \") \") + \"was not specified.\" + (dbTypeSpecific ? \"  It is required for this database type.\" : \"\"));\n            this.dbTypeSpecific = dbTypeSpecific;\n        }\n\n        public boolean isDbTypeSpecific() {\n            return dbTypeSpecific;\n        }\n    }\n\n    /**\n     * Allow an equal sign in args...like \"-o=foo.bar\". Useful for things like\n     * Ant and Maven.\n     *\n     * @param args\n     *            List\n     * @return List\n     */\n    protected List<String> fixupArgs(List<String> args) {\n        List<String> expandedArgs = new ArrayList<String>();\n        for (String arg : args) {\n            int indexOfEquals = arg.indexOf('=');\n            if (indexOfEquals != -1 && indexOfEquals - 1 != arg.indexOf(ESCAPED_EQUALS)) {\n                expandedArgs.add(arg.substring(0, indexOfEquals));\n                expandedArgs.add(arg.substring(indexOfEquals + 1));\n            } else {\n                expandedArgs.add(arg);\n            }\n        }\n        // some OSes/JVMs do filename expansion with runtime.exec() and some don't,\n        // so MultipleSchemaAnalyzer has to surround params with double quotes...\n        // strip them here for the OSes/JVMs that don't do anything with the params\n        List<String> unquotedArgs = new ArrayList<String>();\n        for (String arg : expandedArgs) {\n            if (// \".*\" becomes .*\n            arg.startsWith(\"\\\"\") && arg.endsWith(\"\\\"\"))\n                arg = arg.substring(1, arg.length() - 1);\n            unquotedArgs.add(arg);\n        }\n        return unquotedArgs;\n    }\n\n    /**\n     * Call all the getters to populate all the lazy initialized stuff.\n     *\n     * @throws InvocationTargetException\n     * @throws IllegalAccessException\n     * @throws IllegalArgumentException\n     * @throws IntrospectionException\n     */\n    private void populate() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IntrospectionException {\n        if (!populating) {\n            // prevent recursion\n            populating = true;\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                Method readMethod = props[i].getReadMethod();\n                if (readMethod != null)\n                    readMethod.invoke(this, (Object[]) null);\n            }\n            populating = false;\n        }\n    }\n\n    public static Set<String> getBuiltInDatabaseTypes(String loadedFromJar) {\n        Set<String> databaseTypes = new TreeSet<String>();\n        JarInputStream jar = null;\n        try {\n            jar = new JarInputStream(new FileInputStream(loadedFromJar));\n            JarEntry entry;\n            while ((entry = jar.getNextJarEntry()) != null) {\n                String entryName = entry.getName();\n                int dotPropsIndex = entryName.indexOf(\".properties\");\n                if (dotPropsIndex != -1)\n                    databaseTypes.add(entryName.substring(0, dotPropsIndex));\n            }\n        } catch (IOException exc) {\n        } finally {\n            if (jar != null) {\n                try {\n                    jar.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n        return databaseTypes;\n    }\n\n    protected void dumpUsage(String errorMessage, boolean detailedDb) {\n        if (errorMessage != null) {\n            System.out.flush();\n            System.err.println(\"*** \" + errorMessage + \" ***\");\n        } else {\n            System.out.println(\"SchemaSpy generates an HTML representation of a database schema's relationships.\");\n        }\n        System.err.flush();\n        System.out.println();\n        if (!detailedDb) {\n            System.out.println(\"Usage:\");\n            System.out.println(\" java -jar \" + getLoadedFromJar() + \" [options]\");\n            System.out.println(\"   -t databaseType       type of database - defaults to ora\");\n            System.out.println(\"                           use -dbhelp for a list of built-in types\");\n            System.out.println(\"   -u user               connect to the database with this user id\");\n            System.out.println(\"   -s schema             defaults to the specified user\");\n            System.out.println(\"   -p password           defaults to no password\");\n            System.out.println(\"   -o outputDirectory    directory to place the generated output in\");\n            System.out.println(\"   -dp pathToDrivers     optional - looks for JDBC drivers here before looking\");\n            System.out.println(\"                           in driverPath in [databaseType].properties.\");\n            System.out.println(\"Go to http://schemaspy.sourceforge.net for a complete list/description\");\n            System.out.println(\" of additional parameters.\");\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"Built-in database types and their required connection parameters:\");\n            for (String type : getBuiltInDatabaseTypes(getLoadedFromJar())) {\n                new DbSpecificConfig(type).dumpUsage();\n            }\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"You can use your own database types by specifying the filespec of a .properties file with -t.\");\n            System.out.println(\"Grab one out of \" + getLoadedFromJar() + \" and modify it to suit your needs.\");\n            System.out.println();\n        }\n        System.out.println(\"Sample usage using the default database type (implied -t ora):\");\n        System.out.println(\" java -jar schemaSpy.jar -db mydb -s myschema -u devuser -p password -o output\");\n        System.out.println();\n        System.out.flush();\n    }\n\n    /**\n     * Get the value of the specified parameter.\n     * Used for properties that are common to most db's, but aren't required.\n     *\n     * @param paramName\n     * @return\n     */\n    public String getParam(String paramName) {\n        try {\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                PropertyDescriptor prop = props[i];\n                if (prop.getName().equalsIgnoreCase(paramName)) {\n                    Object result = prop.getReadMethod().invoke(this, (Object[]) null);\n                    return result == null ? null : result.toString();\n                }\n            }\n        } catch (Exception failed) {\n            failed.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * Return all of the configuration options as a List of Strings, with\n     * each parameter and its value as a separate element.\n     *\n     * @return\n     * @throws IOException\n     */\n    public List<String> asList() throws IOException {\n        List<String> params = new ArrayList<String>();\n        if (originalDbSpecificOptions != null) {\n            for (String key : originalDbSpecificOptions.keySet()) {\n                String value = originalDbSpecificOptions.get(key);\n                if (!key.startsWith(\"-\"))\n                    key = \"-\" + key;\n                params.add(key);\n                params.add(value);\n            }\n        }\n        if (isEncodeCommentsEnabled())\n            params.add(\"-ahic\");\n        if (isEvaluateAllEnabled())\n            params.add(\"-all\");\n        if (!isHtmlGenerationEnabled())\n            params.add(\"-nohtml\");\n        if (!isImpliedConstraintsEnabled())\n            params.add(\"-noimplied\");\n        if (!isLogoEnabled())\n            params.add(\"-nologo\");\n        if (isMeterEnabled())\n            params.add(\"-meter\");\n        if (!isNumRowsEnabled())\n            params.add(\"-norows\");\n        if (!isViewsEnabled())\n            params.add(\"-noviews\");\n        if (isRankDirBugEnabled())\n            params.add(\"-rankdirbug\");\n        if (isRailsEnabled())\n            params.add(\"-rails\");\n        if (isSingleSignOn())\n            params.add(\"-sso\");\n        if (isSchemaDisabled())\n            params.add(\"-noschema\");\n        String value = getDriverPath();\n        if (value != null) {\n            params.add(\"-dp\");\n            params.add(value);\n        }\n        params.add(\"-css\");\n        params.add(getCss());\n        params.add(\"-charset\");\n        params.add(getCharset());\n        params.add(\"-font\");\n        params.add(getFont());\n        params.add(\"-fontsize\");\n        params.add(String.valueOf(getFontSize()));\n        params.add(\"-t\");\n        params.add(getDbType());\n        // query to set renderer correctly\n        isHighQuality();\n        // query to set renderer correctly\n        isLowQuality();\n        // instead of -hq and/or -lq\n        params.add(\"-renderer\");\n        params.add(getRenderer());\n        value = getDescription();\n        if (value != null) {\n            params.add(\"-desc\");\n            params.add(value);\n        }\n        value = getPassword();\n        if (value != null && !isPromptForPasswordEnabled()) {\n            // note that we don't pass -pfp since child processes\n            // won't have a console\n            params.add(\"-p\");\n            params.add(value);\n        }\n        value = getCatalog();\n        if (value != null) {\n            params.add(\"-cat\");\n            params.add(value);\n        }\n        value = getSchema();\n        if (value != null) {\n            params.add(\"-s\");\n            params.add(value);\n        }\n        value = getUser();\n        if (value != null) {\n            params.add(\"-u\");\n            params.add(value);\n        }\n        value = getConnectionPropertiesFile();\n        if (value != null) {\n            params.add(\"-connprops\");\n            params.add(value);\n        } else {\n            Properties props = getConnectionProperties();\n            if (!props.isEmpty()) {\n                params.add(\"-connprops\");\n                StringBuilder buf = new StringBuilder();\n                for (Entry<Object, Object> entry : props.entrySet()) {\n                    buf.append(entry.getKey());\n                    buf.append(ESCAPED_EQUALS);\n                    buf.append(entry.getValue());\n                    buf.append(';');\n                }\n                params.add(buf.toString());\n            }\n        }\n        value = getDb();\n        if (value != null) {\n            params.add(\"-db\");\n            params.add(value);\n        }\n        value = getHost();\n        if (value != null) {\n            params.add(\"-host\");\n            params.add(value);\n        }\n        if (getPort() != null) {\n            params.add(\"-port\");\n            params.add(getPort().toString());\n        }\n        value = getServer();\n        if (value != null) {\n            params.add(\"-server\");\n            params.add(value);\n        }\n        value = getMeta();\n        if (value != null) {\n            params.add(\"-meta\");\n            params.add(value);\n        }\n        if (getGraphvizDir() != null) {\n            params.add(\"-gv\");\n            params.add(getGraphvizDir().toString());\n        }\n        params.add(\"-loglevel\");\n        params.add(getLogLevel().toString().toLowerCase());\n        params.add(\"-sqlFormatter\");\n        params.add(getSqlFormatter().getClass().getName());\n        params.add(\"-i\");\n        params.add(getTableInclusions().toString());\n        params.add(\"-I\");\n        params.add(getTableExclusions().toString());\n        params.add(\"-X\");\n        params.add(getColumnExclusions().toString());\n        params.add(\"-x\");\n        params.add(getIndirectColumnExclusions().toString());\n        params.add(\"-dbthreads\");\n        params.add(String.valueOf(getMaxDbThreads()));\n        params.add(\"-maxdet\");\n        params.add(String.valueOf(getMaxDetailedTables()));\n        params.add(\"-o\");\n        params.add(getOutputDir().toString());\n        return params;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/ConfigTest23.java",
		"test_prompt": "// ConfigTest23.java\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Config}.\n* It contains ten unit test cases for the {@link Config#asProperties(ResourceBundle)} method.\n*/\nclass ConfigTest23 {"
	},
	{
		"original_code": "// Config.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\n\n/**\n * Configuration of a SchemaSpy run\n *\n * @author John Currier\n */\npublic class Config {\n\n    private static Config instance;\n\n    private final List<String> options;\n\n    private Map<String, String> dbSpecificOptions;\n\n    private Map<String, String> originalDbSpecificOptions;\n\n    private boolean helpRequired;\n\n    private boolean dbHelpRequired;\n\n    private File outputDir;\n\n    private File graphvizDir;\n\n    private String dbType;\n\n    private String catalog;\n\n    private String schema;\n\n    private List<String> schemas;\n\n    private String user;\n\n    private Boolean singleSignOn;\n\n    private Boolean noSchema;\n\n    private String password;\n\n    private Boolean promptForPassword;\n\n    private String db;\n\n    private String host;\n\n    private Integer port;\n\n    private String server;\n\n    private String meta;\n\n    private Pattern tableInclusions;\n\n    private Pattern tableExclusions;\n\n    private Pattern columnExclusions;\n\n    private Pattern indirectColumnExclusions;\n\n    private String userConnectionPropertiesFile;\n\n    private Properties userConnectionProperties;\n\n    private Integer maxDbThreads;\n\n    private Integer maxDetailedTables;\n\n    private String driverPath;\n\n    private String css;\n\n    private String charset;\n\n    private String font;\n\n    private Integer fontSize;\n\n    private String description;\n\n    private Properties dbProperties;\n\n    private String dbPropertiesLoadedFrom;\n\n    private Level logLevel;\n\n    private SqlFormatter sqlFormatter;\n\n    private String sqlFormatterClass;\n\n    private Boolean generateHtml;\n\n    private Boolean includeImpliedConstraints;\n\n    private Boolean logoEnabled;\n\n    private Boolean rankDirBugEnabled;\n\n    private Boolean encodeCommentsEnabled;\n\n    private Boolean numRowsEnabled;\n\n    private Boolean viewsEnabled;\n\n    private Boolean meterEnabled;\n\n    private Boolean railsEnabled;\n\n    private Boolean evaluteAll;\n\n    private Boolean highQuality;\n\n    private Boolean lowQuality;\n\n    // used in conjunction with evaluateAll\n    private String schemaSpec;\n\n    private boolean hasOrphans = false;\n\n    private boolean hasRoutines = false;\n\n    private boolean populating = false;\n\n    private List<String> columnDetails;\n\n    public static final String DOT_CHARSET = \"UTF-8\";\n\n    private static final String ESCAPED_EQUALS = \"\\\\=\";\n\n    // match everything\n    private static final String DEFAULT_TABLE_INCLUSION = \".*\";\n\n    // match nothing\n    private static final String DEFAULT_TABLE_EXCLUSION = \"\";\n\n    // match nothing\n    private static final String DEFAULT_COLUMN_EXCLUSION = \"[^.]\";\n\n    /**\n     * Default constructor. Intended for when you want to inject properties\n     * independently (i.e. not from a command line interface).\n     */\n    public Config() {\n        if (instance == null)\n            setInstance(this);\n        options = new ArrayList<String>();\n    }\n\n    /**\n     * Construct a configuration from an array of options (e.g. from a command\n     * line interface).\n     *\n     * @param options\n     */\n    public Config(String[] argv) {\n        setInstance(this);\n        options = fixupArgs(Arrays.asList(argv));\n        helpRequired = options.remove(\"-?\") || options.remove(\"/?\") || options.remove(\"?\") || options.remove(\"-h\") || options.remove(\"-help\") || options.remove(\"--help\");\n        dbHelpRequired = options.remove(\"-dbHelp\") || options.remove(\"-dbhelp\");\n    }\n\n    public static Config getInstance() {\n        if (instance == null)\n            instance = new Config();\n        return instance;\n    }\n\n    /**\n     * Sets the global instance.\n     *\n     * Useful for things like selecting a specific configuration in a UI.\n     *\n     * @param config\n     */\n    public static void setInstance(Config config) {\n        instance = config;\n    }\n\n    public void setHtmlGenerationEnabled(boolean generateHtml) {\n        this.generateHtml = generateHtml;\n    }\n\n    public boolean isHtmlGenerationEnabled() {\n        if (generateHtml == null)\n            generateHtml = !options.remove(\"-nohtml\");\n        return generateHtml;\n    }\n\n    public void setImpliedConstraintsEnabled(boolean includeImpliedConstraints) {\n        this.includeImpliedConstraints = includeImpliedConstraints;\n    }\n\n    public boolean isImpliedConstraintsEnabled() {\n        if (includeImpliedConstraints == null)\n            includeImpliedConstraints = !options.remove(\"-noimplied\");\n        return includeImpliedConstraints;\n    }\n\n    public void setOutputDir(String outputDirName) {\n        if (outputDirName.endsWith(\"\\\"\"))\n            outputDirName = outputDirName.substring(0, outputDirName.length() - 1);\n        setOutputDir(new File(outputDirName));\n    }\n\n    public void setOutputDir(File outputDir) {\n        this.outputDir = outputDir;\n    }\n\n    public File getOutputDir() {\n        if (outputDir == null) {\n            setOutputDir(pullRequiredParam(\"-o\"));\n        }\n        return outputDir;\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(String graphvizDir) {\n        if (graphvizDir.endsWith(\"\\\"\"))\n            graphvizDir = graphvizDir.substring(0, graphvizDir.length() - 1);\n        setGraphvizDir(new File(graphvizDir));\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(File graphvizDir) {\n        this.graphvizDir = graphvizDir;\n    }\n\n    /**\n     * Return the path to Graphviz (used to find the dot executable to run to\n     * generate ER diagrams).<p/>\n     *\n     * Returns {@link #getDefaultGraphvizPath()} if a specific Graphviz path\n     * was not specified.\n     *\n     * @return\n     */\n    public File getGraphvizDir() {\n        if (graphvizDir == null) {\n            String gv = pullParam(\"-gv\");\n            if (gv != null) {\n                setGraphvizDir(gv);\n            } else {\n                // expect to find Graphviz's bin directory on the PATH\n            }\n        }\n        return graphvizDir;\n    }\n\n    /**\n     * Meta files are XML-based files that provide additional metadata\n     * about the schema being evaluated.<p>\n     * <code>meta</code> is either the name of an individual XML file or\n     * the directory that contains meta files.<p>\n     * If a directory is specified then it is expected to contain files\n     * matching the pattern <code>[schema].meta.xml</code>.\n     * For databases that don't have schema substitute database for schema.\n     * @param meta\n     */\n    public void setMeta(String meta) {\n        this.meta = meta;\n    }\n\n    public String getMeta() {\n        if (meta == null)\n            meta = pullParam(\"-meta\");\n        return meta;\n    }\n\n    public void setDbType(String dbType) {\n        this.dbType = dbType;\n    }\n\n    public String getDbType() {\n        if (dbType == null) {\n            dbType = pullParam(\"-t\");\n            if (dbType == null)\n                dbType = \"ora\";\n        }\n        return dbType;\n    }\n\n    public void setDb(String db) {\n        this.db = db;\n    }\n\n    public String getDb() {\n        if (db == null)\n            db = pullParam(\"-db\");\n        return db;\n    }\n\n    public void setCatalog(String catalog) {\n        this.catalog = catalog;\n    }\n\n    public String getCatalog() {\n        if (catalog == null)\n            catalog = pullParam(\"-cat\");\n        return catalog;\n    }\n\n    public void setSchema(String schema) {\n        this.schema = schema;\n    }\n\n    public String getSchema() {\n        if (schema == null)\n            schema = pullParam(\"-s\");\n        return schema;\n    }\n\n    /**\n     * Some databases types (e.g. older versions of Informix) don't really\n     * have the concept of a schema but still return true from\n     * {@link DatabaseMetaData#supportsSchemasInTableDefinitions()}.\n     * This option lets you ignore that and treat all the tables\n     * as if they were in one flat namespace.\n     */\n    public boolean isSchemaDisabled() {\n        if (noSchema == null)\n            noSchema = options.remove(\"-noschema\");\n        return noSchema;\n    }\n\n    public void setHost(String host) {\n        this.host = host;\n    }\n\n    public String getHost() {\n        if (host == null)\n            host = pullParam(\"-host\");\n        return host;\n    }\n\n    public void setPort(Integer port) {\n        this.port = port;\n    }\n\n    public Integer getPort() {\n        if (port == null)\n            try {\n                port = Integer.valueOf(pullParam(\"-port\"));\n            } catch (Exception notSpecified) {\n            }\n        return port;\n    }\n\n    public void setServer(String server) {\n        this.server = server;\n    }\n\n    public String getServer() {\n        if (server == null) {\n            server = pullParam(\"-server\");\n        }\n        return server;\n    }\n\n    public void setUser(String user) {\n        this.user = user;\n    }\n\n    /**\n     * User used to connect to the database.\n     * Required unless single sign-on is enabled\n     * (see {@link #setSingleSignOn(boolean)}).\n     * @return\n     */\n    public String getUser() {\n        if (user == null) {\n            if (!isSingleSignOn())\n                user = pullRequiredParam(\"-u\");\n            else\n                user = pullParam(\"-u\");\n        }\n        return user;\n    }\n\n    /**\n     * By default a \"user\" (as specified with -u) is required.\n     * This option allows disabling of that requirement for\n     * single sign-on environments.\n     *\n     * @param enabled defaults to <code>false</code>\n     */\n    public void setSingleSignOn(boolean enabled) {\n        singleSignOn = enabled;\n    }\n\n    /**\n     * @see #setSingleSignOn(boolean)\n     */\n    public boolean isSingleSignOn() {\n        if (singleSignOn == null)\n            singleSignOn = options.remove(\"-sso\");\n        return singleSignOn;\n    }\n\n    /**\n     * Set the password used to connect to the database.\n     * @param password\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * @see #setPassword(String)\n     * @return\n     */\n    public String getPassword() {\n        if (password == null)\n            password = pullParam(\"-p\");\n        if (password == null && isPromptForPasswordEnabled())\n            password = new String(PasswordReader.getInstance().readPassword(\"Password: \"));\n        if (password == null) {\n            // if -pfp is enabled when analyzing multiple schemas then\n            // we don't want to send the password on the command line,\n            // so see if it was passed in the environment (not ideal, but safer)\n            password = System.getenv(\"schemaspy.pw\");\n        }\n        return password;\n    }\n\n    /**\n     * Set to <code>true</code> to prompt for the password\n     * @param promptForPassword\n     */\n    public void setPromptForPasswordEnabled(boolean promptForPassword) {\n        this.promptForPassword = promptForPassword;\n    }\n\n    /**\n     * @see #setPromptForPasswordEnabled(boolean)\n     * @return\n     */\n    public boolean isPromptForPasswordEnabled() {\n        if (promptForPassword == null) {\n            promptForPassword = options.remove(\"-pfp\");\n        }\n        return promptForPassword;\n    }\n\n    public void setMaxDetailedTabled(int maxDetailedTables) {\n        this.maxDetailedTables = new Integer(maxDetailedTables);\n    }\n\n    public int getMaxDetailedTables() {\n        if (maxDetailedTables == null) {\n            // default\n            int max = 300;\n            try {\n                max = Integer.parseInt(pullParam(\"-maxdet\"));\n            } catch (Exception notSpecified) {\n            }\n            maxDetailedTables = new Integer(max);\n        }\n        return maxDetailedTables.intValue();\n    }\n\n    public String getConnectionPropertiesFile() {\n        return userConnectionPropertiesFile;\n    }\n\n    /**\n     * Properties from this file (in key=value pair format) are passed to the\n     * database connection.<br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.\n     * @param propertiesFilename\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public void setConnectionPropertiesFile(String propertiesFilename) throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null)\n            userConnectionProperties = new Properties();\n        userConnectionProperties.load(new FileInputStream(propertiesFilename));\n        userConnectionPropertiesFile = propertiesFilename;\n    }\n\n    /**\n     * Returns a {@link Properties} populated either from the properties file specified\n     * by {@link #setConnectionPropertiesFile(String)}, the properties specified by\n     * {@link #setConnectionProperties(String)} or not populated.\n     * @return\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public Properties getConnectionProperties() throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null) {\n            String props = pullParam(\"-connprops\");\n            if (props != null) {\n                if (props.indexOf(ESCAPED_EQUALS) != -1) {\n                    setConnectionProperties(props);\n                } else {\n                    setConnectionPropertiesFile(props);\n                }\n            } else {\n                userConnectionProperties = new Properties();\n            }\n        }\n        return userConnectionProperties;\n    }\n\n    /**\n     * Specifies connection properties to use in the format:\n     * <code>key1\\=value1;key2\\=value2</code><br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.<p>\n     * This is an alternative form of passing connection properties than by file\n     * (see {@link #setConnectionPropertiesFile(String)})\n     *\n     * @param properties\n     */\n    public void setConnectionProperties(String properties) {\n        userConnectionProperties = new Properties();\n        StringTokenizer tokenizer = new StringTokenizer(properties, \";\");\n        while (tokenizer.hasMoreElements()) {\n            String pair = tokenizer.nextToken();\n            int index = pair.indexOf(ESCAPED_EQUALS);\n            if (index != -1) {\n                String key = pair.substring(0, index);\n                String value = pair.substring(index + ESCAPED_EQUALS.length());\n                userConnectionProperties.put(key, value);\n            }\n        }\n    }\n\n    public void setDriverPath(String driverPath) {\n        this.driverPath = driverPath;\n    }\n\n    public String getDriverPath() {\n        if (driverPath == null)\n            driverPath = pullParam(\"-dp\");\n        // was previously -cp:\n        if (driverPath == null)\n            driverPath = pullParam(\"-cp\");\n        return driverPath;\n    }\n\n    /**\n     * The filename of the cascading style sheet to use.\n     * Note that this file is parsed and used to determine characteristics\n     * of the generated diagrams, so it must contain specific settings that\n     * are documented within schemaSpy.css.<p>\n     *\n     * Defaults to <code>\"schemaSpy.css\"</code>.\n     *\n     * @param css\n     */\n    public void setCss(String css) {\n        this.css = css;\n    }\n\n    public String getCss() {\n        if (css == null) {\n            css = pullParam(\"-css\");\n            if (css == null)\n                css = \"schemaSpy.css\";\n        }\n        return css;\n    }\n\n    /**\n     * The font to use within diagrams.  Modify the .css to specify HTML fonts.\n     *\n     * @param font\n     */\n    public void setFont(String font) {\n        this.font = font;\n    }\n\n    /**\n     * @see #setFont(String)\n     */\n    public String getFont() {\n        if (font == null) {\n            font = pullParam(\"-font\");\n            if (font == null)\n                font = \"Helvetica\";\n        }\n        return font;\n    }\n\n    /**\n     * The font size to use within diagrams.  This is the size of the font used for\n     * 'large' (e.g. not 'compact') diagrams.<p>\n     *\n     * Modify the .css to specify HTML font sizes.<p>\n     *\n     * Defaults to 11.\n     *\n     * @param fontSize\n     */\n    public void setFontSize(int fontSize) {\n        this.fontSize = new Integer(fontSize);\n    }\n\n    /**\n     * @see #setFontSize(int)\n     * @return\n     */\n    public int getFontSize() {\n        if (fontSize == null) {\n            // default\n            int size = 11;\n            try {\n                size = Integer.parseInt(pullParam(\"-fontsize\"));\n            } catch (Exception notSpecified) {\n            }\n            fontSize = new Integer(size);\n        }\n        return fontSize.intValue();\n    }\n\n    /**\n     * The character set to use within HTML pages (defaults to <code>\"ISO-8859-1\"</code>).\n     *\n     * @param charset\n     */\n    public void setCharset(String charset) {\n        this.charset = charset;\n    }\n\n    /**\n     * @see #setCharset(String)\n     */\n    public String getCharset() {\n        if (charset == null) {\n            charset = pullParam(\"-charset\");\n            if (charset == null)\n                charset = \"ISO-8859-1\";\n        }\n        return charset;\n    }\n\n    /**\n     * Description of schema that gets display on main pages.\n     *\n     * @param description\n     */\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    /**\n     * @see #setDescription(String)\n     */\n    public String getDescription() {\n        if (description == null)\n            description = pullParam(\"-desc\");\n        return description;\n    }\n\n    /**\n     * Maximum number of threads to use when querying database metadata information.\n     *\n     * @param maxDbThreads\n     */\n    public void setMaxDbThreads(int maxDbThreads) {\n        this.maxDbThreads = new Integer(maxDbThreads);\n    }\n\n    /**\n     * @see #setMaxDbThreads(int)\n     * @throws InvalidConfigurationException if unable to load properties\n     */\n    public int getMaxDbThreads() throws InvalidConfigurationException {\n        if (maxDbThreads == null) {\n            Properties properties;\n            try {\n                properties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(\"Failed to load properties for \" + getDbType() + \": \" + exc).setParamName(\"-type\");\n            }\n            // not scientifically derived\n            final int defaultMax = 15;\n            int max = defaultMax;\n            String threads = properties.getProperty(\"dbThreads\");\n            if (threads == null)\n                threads = properties.getProperty(\"dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            threads = pullParam(\"-dbThreads\");\n            if (threads == null)\n                threads = pullParam(\"-dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            if (max < 0)\n                max = defaultMax;\n            else if (max == 0)\n                max = 1;\n            maxDbThreads = new Integer(max);\n        }\n        return maxDbThreads.intValue();\n    }\n\n    public boolean isLogoEnabled() {\n        if (logoEnabled == null)\n            logoEnabled = !options.remove(\"-nologo\");\n        return logoEnabled;\n    }\n\n    /**\n     * Don't use this unless absolutely necessary as it screws up the layout\n     *\n     * @param enabled\n     */\n    public void setRankDirBugEnabled(boolean enabled) {\n        rankDirBugEnabled = enabled;\n    }\n\n    /**\n     * @see #setRankDirBugEnabled(boolean)\n     */\n    public boolean isRankDirBugEnabled() {\n        if (rankDirBugEnabled == null)\n            rankDirBugEnabled = options.remove(\"-rankdirbug\");\n        return rankDirBugEnabled;\n    }\n\n    /**\n     * Look for Ruby on Rails-based naming conventions in\n     * relationships between logical foreign keys and primary keys.<p>\n     *\n     * Basically all tables have a primary key named <code>ID</code>.\n     * All tables are named plural names.\n     * The columns that logically reference that <code>ID</code> are the singular\n     * form of the table name suffixed with <code>_ID</code>.<p>\n     *\n     * @param enabled\n     */\n    public void setRailsEnabled(boolean enabled) {\n        railsEnabled = enabled;\n    }\n\n    /**\n     * @see #setRailsEnabled(boolean)\n     *\n     * @return\n     */\n    public boolean isRailsEnabled() {\n        if (railsEnabled == null)\n            railsEnabled = options.remove(\"-rails\");\n        return railsEnabled;\n    }\n\n    /**\n     * Allow Html In Comments - encode them unless otherwise specified\n     */\n    public void setEncodeCommentsEnabled(boolean enabled) {\n        encodeCommentsEnabled = enabled;\n    }\n\n    /**\n     * @see #setEncodeCommentsEnabled(boolean)\n     */\n    public boolean isEncodeCommentsEnabled() {\n        if (encodeCommentsEnabled == null)\n            encodeCommentsEnabled = !options.remove(\"-ahic\");\n        return encodeCommentsEnabled;\n    }\n\n    /**\n     * If enabled we'll attempt to query/render the number of rows that\n     * each table contains.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setNumRowsEnabled(boolean enabled) {\n        numRowsEnabled = enabled;\n    }\n\n    /**\n     * @see #setNumRowsEnabled(boolean)\n     * @return\n     */\n    public boolean isNumRowsEnabled() {\n        if (numRowsEnabled == null)\n            numRowsEnabled = !options.remove(\"-norows\");\n        return numRowsEnabled;\n    }\n\n    /**\n     * If enabled we'll include views in the analysis.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setViewsEnabled(boolean enabled) {\n        viewsEnabled = enabled;\n    }\n\n    /**\n     * @see #setViewsEnabled(boolean)\n     * @return\n     */\n    public boolean isViewsEnabled() {\n        if (viewsEnabled == null)\n            viewsEnabled = !options.remove(\"-noviews\");\n        return viewsEnabled;\n    }\n\n    /**\n     * Returns <code>true</code> if metering should be embedded in\n     * the generated pages.<p/>\n     * Defaults to <code>false</code> (disabled).\n     * @return\n     */\n    public boolean isMeterEnabled() {\n        if (meterEnabled == null)\n            meterEnabled = options.remove(\"-meter\");\n        return meterEnabled;\n    }\n\n    /**\n     * Set the columns to exclude from all relationship diagrams.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setColumnExclusions(String columnExclusions) {\n        this.columnExclusions = Pattern.compile(columnExclusions);\n    }\n\n    /**\n     * See {@link #setColumnExclusions(String)}\n     * @return\n     */\n    public Pattern getColumnExclusions() {\n        if (columnExclusions == null) {\n            String strExclusions = pullParam(\"-X\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.columnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            columnExclusions = Pattern.compile(strExclusions);\n        }\n        return columnExclusions;\n    }\n\n    /**\n     * Set the columns to exclude from relationship diagrams where the specified\n     * columns aren't directly referenced by the focal table.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setIndirectColumnExclusions(String fullColumnExclusions) {\n        indirectColumnExclusions = Pattern.compile(fullColumnExclusions);\n    }\n\n    /**\n     * @see #setIndirectColumnExclusions(String)\n     *\n     * @return\n     */\n    public Pattern getIndirectColumnExclusions() {\n        if (indirectColumnExclusions == null) {\n            String strExclusions = pullParam(\"-x\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.indirectColumnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            indirectColumnExclusions = Pattern.compile(strExclusions);\n        }\n        return indirectColumnExclusions;\n    }\n\n    /**\n     * Set the tables to include as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableInclusions(String tableInclusions) {\n        this.tableInclusions = Pattern.compile(tableInclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to include in the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableInclusions() {\n        if (tableInclusions == null) {\n            String strInclusions = pullParam(\"-i\");\n            if (strInclusions == null)\n                strInclusions = System.getenv(\"schemaspy.tableInclusions\");\n            if (strInclusions == null)\n                strInclusions = DEFAULT_TABLE_INCLUSION;\n            try {\n                tableInclusions = Pattern.compile(strInclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-i\");\n            }\n        }\n        return tableInclusions;\n    }\n\n    /**\n     * Set the tables to exclude as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableExclusions(String tableExclusions) {\n        this.tableExclusions = Pattern.compile(tableExclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to exclude from the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableExclusions() {\n        if (tableExclusions == null) {\n            String strExclusions = pullParam(\"-I\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.tableExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_TABLE_EXCLUSION;\n            try {\n                tableExclusions = Pattern.compile(strExclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-I\");\n            }\n        }\n        return tableExclusions;\n    }\n\n    /**\n     * @return\n     */\n    public List<String> getSchemas() {\n        if (schemas == null) {\n            String tmp = pullParam(\"-schemas\");\n            if (tmp == null)\n                tmp = pullParam(\"-schemata\");\n            if (tmp != null) {\n                schemas = new ArrayList<String>();\n                for (String name : tmp.split(\"[\\\\s,'\\\"]\")) {\n                    if (name.length() > 0)\n                        schemas.add(name);\n                }\n                if (schemas.isEmpty())\n                    schemas = null;\n            }\n        }\n        return schemas;\n    }\n\n    /**\n     * Set the name of the {@link SqlFormatter SQL formatter} class to use to\n     * format SQL into HTML.<p/>\n     * The implementation of the class must be made available to the class\n     * loader, typically by specifying the path to its jar with <em>-dp</em>\n     * ({@link #setDriverPath(String)}).\n     */\n    public void setSqlFormatter(String formatterClassName) {\n        sqlFormatterClass = formatterClassName;\n        sqlFormatter = null;\n    }\n\n    /**\n     * Set the {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.\n     */\n    public void setSqlFormatter(SqlFormatter sqlFormatter) {\n        this.sqlFormatter = sqlFormatter;\n        if (sqlFormatter != null)\n            sqlFormatterClass = sqlFormatter.getClass().getName();\n    }\n\n    /**\n     * Returns an implementation of {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.  The default implementation is {@link DefaultSqlFormatter}.\n     *\n     * @return\n     * @throws InvalidConfigurationException if unable to instantiate an instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SqlFormatter getSqlFormatter() throws InvalidConfigurationException {\n        if (sqlFormatter == null) {\n            if (sqlFormatterClass == null) {\n                sqlFormatterClass = pullParam(\"-sqlFormatter\");\n                if (sqlFormatterClass == null)\n                    sqlFormatterClass = DefaultSqlFormatter.class.getName();\n            }\n            try {\n                Class<SqlFormatter> clazz = (Class<SqlFormatter>) Class.forName(sqlFormatterClass);\n                sqlFormatter = clazz.newInstance();\n            } catch (Exception exc) {\n                throw new InvalidConfigurationException(\"Failed to initialize instance of SQL formatter: \", exc).setParamName(\"-sqlFormatter\");\n            }\n        }\n        return sqlFormatter;\n    }\n\n    /**\n     * Set the details to show on the columns page, where \"details\" are\n     * comma and/or space separated.\n     *\n     * Valid values:\n     * <ul>\n     * <li>id</li>\n     * <li>table</li>\n     * <li>column</li>\n     * <li>type</li>\n     * <li>size</li>\n     * <li>nulls</li>\n     * <li>auto</li>\n     * <li>default</li>\n     * <li>children</li>\n     * <li>parents</li>\n     * </ul>\n     *\n     * The default details are <code>\"table column type size nulls auto default\"</code>.\n     * Note that \"column\" is the initially displayed detail and must be included.\n     *\n     * @param columnDetails\n     */\n    public void setColumnDetails(String columnDetails) {\n        this.columnDetails = new ArrayList<String>();\n        if (columnDetails == null || columnDetails.length() == 0) {\n            // not specified, so use defaults\n            columnDetails = \"id table column type size nulls auto default\";\n        }\n        for (String detail : columnDetails.split(\"[\\\\s,'\\\"]\")) {\n            if (detail.length() > 0) {\n                this.columnDetails.add(detail.toLowerCase());\n            }\n        }\n        if (!this.columnDetails.contains(\"column\"))\n            throw new InvalidConfigurationException(\"'column' is a required column detail\");\n    }\n\n    public void setColumnDetails(List<String> columnDetails) {\n        String details = columnDetails == null ? \"[]\" : columnDetails.toString();\n        setColumnDetails(details.substring(1, details.length() - 1));\n    }\n\n    public List<String> getColumnDetails() {\n        if (columnDetails == null) {\n            setColumnDetails(pullParam(\"-columndetails\"));\n        }\n        return columnDetails;\n    }\n\n    public void setEvaluateAllEnabled(boolean enabled) {\n        evaluteAll = enabled;\n    }\n\n    public boolean isEvaluateAllEnabled() {\n        if (evaluteAll == null)\n            evaluteAll = options.remove(\"-all\");\n        return evaluteAll;\n    }\n\n    /**\n     * Returns true if we're evaluating a bunch of schemas in one go and\n     * at this point we're evaluating a specific schema.\n     *\n     * @return boolean\n     */\n    public boolean isOneOfMultipleSchemas() {\n        // set by MultipleSchemaAnalyzer\n        return Boolean.getBoolean(\"oneofmultipleschemas\");\n    }\n\n    /**\n     * When -all (evaluateAll) is specified then this is the regular\n     * expression that determines which schemas to evaluate.\n     *\n     * @param schemaSpec\n     */\n    public void setSchemaSpec(String schemaSpec) {\n        this.schemaSpec = schemaSpec;\n    }\n\n    public String getSchemaSpec() {\n        if (schemaSpec == null)\n            schemaSpec = pullParam(\"-schemaSpec\");\n        return schemaSpec;\n    }\n\n    /**\n     * Set the renderer to use for the -Tpng[:renderer[:formatter]] dot option as specified\n     * at <a href='http://www.graphviz.org/doc/info/command.html'>\n     * http://www.graphviz.org/doc/info/command.html</a>.<p>\n     * Note that the leading \":\" is required while :formatter is optional.<p>\n     * The default renderer is typically GD.<p>\n     * Note that using {@link #setHighQuality(boolean)} is the preferred approach\n     * over using this method.\n     */\n    public void setRenderer(String renderer) {\n        Dot.getInstance().setRenderer(renderer);\n    }\n\n    /**\n     * @see #setRenderer(String)\n     * @return\n     */\n    public String getRenderer() {\n        String renderer = pullParam(\"-renderer\");\n        if (renderer != null)\n            setRenderer(renderer);\n        return Dot.getInstance().getRenderer();\n    }\n\n    /**\n     * If <code>false</code> then generate output of \"lower quality\"\n     * than the default.\n     * Note that the default is intended to be \"higher quality\",\n     * but various installations of Graphviz may have have different abilities.\n     * That is, some might not have the \"lower quality\" libraries and others might\n     * not have the \"higher quality\" libraries.<p>\n     * Higher quality output takes longer to generate and results in significantly\n     * larger image files (which take longer to download / display), but it generally\n     * looks better.\n     */\n    public void setHighQuality(boolean highQuality) {\n        this.highQuality = highQuality;\n        lowQuality = !highQuality;\n        Dot.getInstance().setHighQuality(highQuality);\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isHighQuality() {\n        if (highQuality == null) {\n            highQuality = options.remove(\"-hq\");\n            if (highQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(highQuality);\n            }\n        }\n        highQuality = Dot.getInstance().isHighQuality();\n        return highQuality;\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isLowQuality() {\n        if (lowQuality == null) {\n            lowQuality = options.remove(\"-lq\");\n            if (lowQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(!lowQuality);\n            }\n        }\n        lowQuality = !Dot.getInstance().isHighQuality();\n        return lowQuality;\n    }\n\n    /**\n     * Set the level of logging to perform.<p/>\n     * The levels in descending order are:\n     * <ul>\n     *  <li><code>severe</code> (highest - least detail)\n     *  <li><code>warning</code> (default)\n     *  <li><code>info</code>\n     *  <li><code>config</code>\n     *  <li><code>fine</code>\n     *  <li><code>finer</code>\n     *  <li><code>finest</code>  (lowest - most detail)\n     * </ul>\n     *\n     * @param logLevel\n     */\n    public void setLogLevel(String logLevel) {\n        if (logLevel == null) {\n            this.logLevel = Level.WARNING;\n            return;\n        }\n        Map<String, Level> levels = new LinkedHashMap<String, Level>();\n        levels.put(\"severe\", Level.SEVERE);\n        levels.put(\"warning\", Level.WARNING);\n        levels.put(\"info\", Level.INFO);\n        levels.put(\"config\", Level.CONFIG);\n        levels.put(\"fine\", Level.FINE);\n        levels.put(\"finer\", Level.FINER);\n        levels.put(\"finest\", Level.FINEST);\n        this.logLevel = levels.get(logLevel.toLowerCase());\n        if (this.logLevel == null) {\n            throw new InvalidConfigurationException(\"Invalid logLevel: '\" + logLevel + \"'. Must be one of: \" + levels.keySet());\n        }\n    }\n\n    /**\n     * Returns the level of logging to perform.\n     * See {@link #setLogLevel(String)}.\n     *\n     * @return\n     */\n    public Level getLogLevel() {\n        if (logLevel == null) {\n            setLogLevel(pullParam(\"-loglevel\"));\n        }\n        return logLevel;\n    }\n\n    /**\n     * Returns <code>true</code> if the options indicate that the user wants\n     * to see some help information.\n     *\n     * @return\n     */\n    public boolean isHelpRequired() {\n        return helpRequired;\n    }\n\n    public boolean isDbHelpRequired() {\n        return dbHelpRequired;\n    }\n\n    /**\n     * Returns the jar that we were loaded from\n     *\n     * @return\n     */\n    public static String getLoadedFromJar() {\n        String classpath = System.getProperty(\"java.class.path\");\n        return new StringTokenizer(classpath, File.pathSeparator).nextToken();\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasOrphans(boolean hasOrphans) {\n        this.hasOrphans = hasOrphans;\n    }\n\n    /**\n     * @see #setHasOrphans()\n     *\n     * @return\n     */\n    public boolean hasOrphans() {\n        return hasOrphans;\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasRoutines(boolean hasRoutines) {\n        this.hasRoutines = hasRoutines;\n    }\n\n    /**\n     * @see #setHasRoutines()\n     *\n     * @return\n     */\n    public boolean hasRoutines() {\n        return hasRoutines;\n    }\n\n    /**\n     * Returns the database properties to use.\n     * These should be determined by calling {@link #determineDbProperties(String)}.\n     * @return\n     * @throws InvalidConfigurationException\n     */\n    public Properties getDbProperties() throws InvalidConfigurationException {\n        if (dbProperties == null) {\n            try {\n                dbProperties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(exc);\n            }\n        }\n        return dbProperties;\n    }\n\n    /**\n     * Determines the database properties associated with the specified type.\n     * A call to {@link #setDbProperties(Properties)} is expected after determining\n     * the complete set of properties.\n     *\n     * @param type\n     * @return\n     * @throws IOException\n     * @throws InvalidConfigurationException if db properties are incorrectly formed\n     */\n    public Properties determineDbProperties(String type) throws IOException, InvalidConfigurationException {\n        ResourceBundle bundle = null;\n        try {\n            File propertiesFile = new File(type);\n            bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n            dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n        } catch (FileNotFoundException notFoundOnFilesystemWithoutExtension) {\n            try {\n                File propertiesFile = new File(type + \".properties\");\n                bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n                dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n            } catch (FileNotFoundException notFoundOnFilesystemWithExtensionTackedOn) {\n                try {\n                    bundle = ResourceBundle.getBundle(type);\n                    dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]\" + File.separator + type + \".properties\";\n                } catch (Exception notInJarWithoutPath) {\n                    try {\n                        String path = TableOrderer.class.getPackage().getName() + \".dbTypes.\" + type;\n                        path = path.replace('.', '/');\n                        bundle = ResourceBundle.getBundle(path);\n                        dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]/\" + path + \".properties\";\n                    } catch (Exception notInJar) {\n                        notInJar.printStackTrace();\n                        notFoundOnFilesystemWithExtensionTackedOn.printStackTrace();\n                        throw notFoundOnFilesystemWithoutExtension;\n                    }\n                }\n            }\n        }\n        Properties props = asProperties(bundle);\n        bundle = null;\n        // keep original thru recursion\n        String saveLoadedFrom = dbPropertiesLoadedFrom;\n        // bring in key/values pointed to by the include directive\n        // example: include.1=mysql::selectRowCountSql\n        for (int i = 1; true; ++i) {\n            String include = (String) props.remove(\"include.\" + i);\n            if (include == null)\n                break;\n            int separator = include.indexOf(\"::\");\n            if (separator == -1)\n                throw new InvalidConfigurationException(\"include directive in \" + dbPropertiesLoadedFrom + \" must have '::' between dbType and key\");\n            String refdType = include.substring(0, separator).trim();\n            String refdKey = include.substring(separator + 2).trim();\n            // recursively resolve the ref'd properties file and the ref'd key\n            Properties refdProps = determineDbProperties(refdType);\n            props.put(refdKey, refdProps.getProperty(refdKey));\n        }\n        // bring in base properties files pointed to by the extends directive\n        String baseDbType = (String) props.remove(\"extends\");\n        if (baseDbType != null) {\n            baseDbType = baseDbType.trim();\n            Properties baseProps = determineDbProperties(baseDbType);\n            // overlay our properties on top of the base's\n            baseProps.putAll(props);\n            props = baseProps;\n        }\n        // done with this level of recursion...restore original\n        dbPropertiesLoadedFrom = saveLoadedFrom;\n        // this won't be correct until the final recursion exits\n        dbProperties = props;\n        return props;\n    }\n\n    protected String getDbPropertiesLoadedFrom() throws IOException {\n        if (dbPropertiesLoadedFrom == null)\n            determineDbProperties(getDbType());\n        return dbPropertiesLoadedFrom;\n    }\n\n    public List<String> getRemainingParameters() {\n        try {\n            populate();\n        } catch (IllegalArgumentException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (IllegalAccessException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (InvocationTargetException exc) {\n            if (exc.getCause() instanceof InvalidConfigurationException)\n                throw (InvalidConfigurationException) exc.getCause();\n            throw new InvalidConfigurationException(exc.getCause());\n        } catch (IntrospectionException exc) {\n            throw new InvalidConfigurationException(exc);\n        }\n        return options;\n    }\n\n    /**\n     * Options that are specific to a type of database.  E.g. things like <code>host</code>,\n     * <code>port</code> or <code>db</code>, but <b>don't</b> have a setter in this class.\n     *\n     * @param dbSpecificOptions\n     */\n    public void setDbSpecificOptions(Map<String, String> dbSpecificOptions) {\n        this.dbSpecificOptions = dbSpecificOptions;\n        originalDbSpecificOptions = new HashMap<String, String>(dbSpecificOptions);\n    }\n\n    public Map<String, String> getDbSpecificOptions() {\n        if (dbSpecificOptions == null)\n            dbSpecificOptions = new HashMap<String, String>();\n        return dbSpecificOptions;\n    }\n\n    /**\n     * Returns a {@link Properties} populated with the contents of <code>bundle</code>\n     *\n     * @param bundle ResourceBundle\n     * @return Properties\n     */\n    public static Properties asProperties(ResourceBundle bundle) {\n        Properties props = new Properties();\n        Enumeration<String> iter = bundle.getKeys();\n        while (iter.hasMoreElements()) {\n            String key = iter.nextElement();\n            props.put(key, bundle.getObject(key));\n        }\n        return props;\n    }\n\n    /**\n     * 'Pull' the specified parameter from the collection of options. Returns\n     * null if the parameter isn't in the list and removes it if it is.\n     *\n     * @param paramId\n     * @return\n     */\n    private String pullParam(String paramId) {\n        return pullParam(paramId, false, false);\n    }\n\n    private String pullRequiredParam(String paramId) {\n        return pullParam(paramId, true, false);\n    }\n\n    /**\n     * @param paramId\n     * @param required\n     * @param dbTypeSpecific\n     * @return\n     * @throws MissingRequiredParameterException\n     */\n    private String pullParam(String paramId, boolean required, boolean dbTypeSpecific) throws MissingRequiredParameterException {\n        int paramIndex = options.indexOf(paramId);\n        if (paramIndex < 0) {\n            if (required)\n                throw new MissingRequiredParameterException(paramId, dbTypeSpecific);\n            return null;\n        }\n        options.remove(paramIndex);\n        String param = options.get(paramIndex).toString();\n        options.remove(paramIndex);\n        return param;\n    }\n\n    /**\n     * Thrown to indicate that a required parameter is missing\n     */\n    public static class MissingRequiredParameterException extends RuntimeException {\n\n        private static final long serialVersionUID = 1L;\n\n        private final boolean dbTypeSpecific;\n\n        public MissingRequiredParameterException(String paramId, boolean dbTypeSpecific) {\n            this(paramId, null, dbTypeSpecific);\n        }\n\n        public MissingRequiredParameterException(String paramId, String description, boolean dbTypeSpecific) {\n            super(\"Required parameter '\" + paramId + \"' \" + (description == null ? \"\" : \"(\" + description + \") \") + \"was not specified.\" + (dbTypeSpecific ? \"  It is required for this database type.\" : \"\"));\n            this.dbTypeSpecific = dbTypeSpecific;\n        }\n\n        public boolean isDbTypeSpecific() {\n            return dbTypeSpecific;\n        }\n    }\n\n    /**\n     * Allow an equal sign in args...like \"-o=foo.bar\". Useful for things like\n     * Ant and Maven.\n     *\n     * @param args\n     *            List\n     * @return List\n     */\n    protected List<String> fixupArgs(List<String> args) {\n        List<String> expandedArgs = new ArrayList<String>();\n        for (String arg : args) {\n            int indexOfEquals = arg.indexOf('=');\n            if (indexOfEquals != -1 && indexOfEquals - 1 != arg.indexOf(ESCAPED_EQUALS)) {\n                expandedArgs.add(arg.substring(0, indexOfEquals));\n                expandedArgs.add(arg.substring(indexOfEquals + 1));\n            } else {\n                expandedArgs.add(arg);\n            }\n        }\n        // some OSes/JVMs do filename expansion with runtime.exec() and some don't,\n        // so MultipleSchemaAnalyzer has to surround params with double quotes...\n        // strip them here for the OSes/JVMs that don't do anything with the params\n        List<String> unquotedArgs = new ArrayList<String>();\n        for (String arg : expandedArgs) {\n            if (// \".*\" becomes .*\n            arg.startsWith(\"\\\"\") && arg.endsWith(\"\\\"\"))\n                arg = arg.substring(1, arg.length() - 1);\n            unquotedArgs.add(arg);\n        }\n        return unquotedArgs;\n    }\n\n    /**\n     * Call all the getters to populate all the lazy initialized stuff.\n     *\n     * @throws InvocationTargetException\n     * @throws IllegalAccessException\n     * @throws IllegalArgumentException\n     * @throws IntrospectionException\n     */\n    private void populate() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IntrospectionException {\n        if (!populating) {\n            // prevent recursion\n            populating = true;\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                Method readMethod = props[i].getReadMethod();\n                if (readMethod != null)\n                    readMethod.invoke(this, (Object[]) null);\n            }\n            populating = false;\n        }\n    }\n\n    public static Set<String> getBuiltInDatabaseTypes(String loadedFromJar) {\n        Set<String> databaseTypes = new TreeSet<String>();\n        JarInputStream jar = null;\n        try {\n            jar = new JarInputStream(new FileInputStream(loadedFromJar));\n            JarEntry entry;\n            while ((entry = jar.getNextJarEntry()) != null) {\n                String entryName = entry.getName();\n                int dotPropsIndex = entryName.indexOf(\".properties\");\n                if (dotPropsIndex != -1)\n                    databaseTypes.add(entryName.substring(0, dotPropsIndex));\n            }\n        } catch (IOException exc) {\n        } finally {\n            if (jar != null) {\n                try {\n                    jar.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n        return databaseTypes;\n    }\n\n    protected void dumpUsage(String errorMessage, boolean detailedDb) {\n        if (errorMessage != null) {\n            System.out.flush();\n            System.err.println(\"*** \" + errorMessage + \" ***\");\n        } else {\n            System.out.println(\"SchemaSpy generates an HTML representation of a database schema's relationships.\");\n        }\n        System.err.flush();\n        System.out.println();\n        if (!detailedDb) {\n            System.out.println(\"Usage:\");\n            System.out.println(\" java -jar \" + getLoadedFromJar() + \" [options]\");\n            System.out.println(\"   -t databaseType       type of database - defaults to ora\");\n            System.out.println(\"                           use -dbhelp for a list of built-in types\");\n            System.out.println(\"   -u user               connect to the database with this user id\");\n            System.out.println(\"   -s schema             defaults to the specified user\");\n            System.out.println(\"   -p password           defaults to no password\");\n            System.out.println(\"   -o outputDirectory    directory to place the generated output in\");\n            System.out.println(\"   -dp pathToDrivers     optional - looks for JDBC drivers here before looking\");\n            System.out.println(\"                           in driverPath in [databaseType].properties.\");\n            System.out.println(\"Go to http://schemaspy.sourceforge.net for a complete list/description\");\n            System.out.println(\" of additional parameters.\");\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"Built-in database types and their required connection parameters:\");\n            for (String type : getBuiltInDatabaseTypes(getLoadedFromJar())) {\n                new DbSpecificConfig(type).dumpUsage();\n            }\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"You can use your own database types by specifying the filespec of a .properties file with -t.\");\n            System.out.println(\"Grab one out of \" + getLoadedFromJar() + \" and modify it to suit your needs.\");\n            System.out.println();\n        }\n        System.out.println(\"Sample usage using the default database type (implied -t ora):\");\n        System.out.println(\" java -jar schemaSpy.jar -db mydb -s myschema -u devuser -p password -o output\");\n        System.out.println();\n        System.out.flush();\n    }\n\n    /**\n     * Get the value of the specified parameter.\n     * Used for properties that are common to most db's, but aren't required.\n     *\n     * @param paramName\n     * @return\n     */\n    public String getParam(String paramName) {\n        try {\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                PropertyDescriptor prop = props[i];\n                if (prop.getName().equalsIgnoreCase(paramName)) {\n                    Object result = prop.getReadMethod().invoke(this, (Object[]) null);\n                    return result == null ? null : result.toString();\n                }\n            }\n        } catch (Exception failed) {\n            failed.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * Return all of the configuration options as a List of Strings, with\n     * each parameter and its value as a separate element.\n     *\n     * @return\n     * @throws IOException\n     */\n    public List<String> asList() throws IOException {\n        List<String> params = new ArrayList<String>();\n        if (originalDbSpecificOptions != null) {\n            for (String key : originalDbSpecificOptions.keySet()) {\n                String value = originalDbSpecificOptions.get(key);\n                if (!key.startsWith(\"-\"))\n                    key = \"-\" + key;\n                params.add(key);\n                params.add(value);\n            }\n        }\n        if (isEncodeCommentsEnabled())\n            params.add(\"-ahic\");\n        if (isEvaluateAllEnabled())\n            params.add(\"-all\");\n        if (!isHtmlGenerationEnabled())\n            params.add(\"-nohtml\");\n        if (!isImpliedConstraintsEnabled())\n            params.add(\"-noimplied\");\n        if (!isLogoEnabled())\n            params.add(\"-nologo\");\n        if (isMeterEnabled())\n            params.add(\"-meter\");\n        if (!isNumRowsEnabled())\n            params.add(\"-norows\");\n        if (!isViewsEnabled())\n            params.add(\"-noviews\");\n        if (isRankDirBugEnabled())\n            params.add(\"-rankdirbug\");\n        if (isRailsEnabled())\n            params.add(\"-rails\");\n        if (isSingleSignOn())\n            params.add(\"-sso\");\n        if (isSchemaDisabled())\n            params.add(\"-noschema\");\n        String value = getDriverPath();\n        if (value != null) {\n            params.add(\"-dp\");\n            params.add(value);\n        }\n        params.add(\"-css\");\n        params.add(getCss());\n        params.add(\"-charset\");\n        params.add(getCharset());\n        params.add(\"-font\");\n        params.add(getFont());\n        params.add(\"-fontsize\");\n        params.add(String.valueOf(getFontSize()));\n        params.add(\"-t\");\n        params.add(getDbType());\n        // query to set renderer correctly\n        isHighQuality();\n        // query to set renderer correctly\n        isLowQuality();\n        // instead of -hq and/or -lq\n        params.add(\"-renderer\");\n        params.add(getRenderer());\n        value = getDescription();\n        if (value != null) {\n            params.add(\"-desc\");\n            params.add(value);\n        }\n        value = getPassword();\n        if (value != null && !isPromptForPasswordEnabled()) {\n            // note that we don't pass -pfp since child processes\n            // won't have a console\n            params.add(\"-p\");\n            params.add(value);\n        }\n        value = getCatalog();\n        if (value != null) {\n            params.add(\"-cat\");\n            params.add(value);\n        }\n        value = getSchema();\n        if (value != null) {\n            params.add(\"-s\");\n            params.add(value);\n        }\n        value = getUser();\n        if (value != null) {\n            params.add(\"-u\");\n            params.add(value);\n        }\n        value = getConnectionPropertiesFile();\n        if (value != null) {\n            params.add(\"-connprops\");\n            params.add(value);\n        } else {\n            Properties props = getConnectionProperties();\n            if (!props.isEmpty()) {\n                params.add(\"-connprops\");\n                StringBuilder buf = new StringBuilder();\n                for (Entry<Object, Object> entry : props.entrySet()) {\n                    buf.append(entry.getKey());\n                    buf.append(ESCAPED_EQUALS);\n                    buf.append(entry.getValue());\n                    buf.append(';');\n                }\n                params.add(buf.toString());\n            }\n        }\n        value = getDb();\n        if (value != null) {\n            params.add(\"-db\");\n            params.add(value);\n        }\n        value = getHost();\n        if (value != null) {\n            params.add(\"-host\");\n            params.add(value);\n        }\n        if (getPort() != null) {\n            params.add(\"-port\");\n            params.add(getPort().toString());\n        }\n        value = getServer();\n        if (value != null) {\n            params.add(\"-server\");\n            params.add(value);\n        }\n        value = getMeta();\n        if (value != null) {\n            params.add(\"-meta\");\n            params.add(value);\n        }\n        if (getGraphvizDir() != null) {\n            params.add(\"-gv\");\n            params.add(getGraphvizDir().toString());\n        }\n        params.add(\"-loglevel\");\n        params.add(getLogLevel().toString().toLowerCase());\n        params.add(\"-sqlFormatter\");\n        params.add(getSqlFormatter().getClass().getName());\n        params.add(\"-i\");\n        params.add(getTableInclusions().toString());\n        params.add(\"-I\");\n        params.add(getTableExclusions().toString());\n        params.add(\"-X\");\n        params.add(getColumnExclusions().toString());\n        params.add(\"-x\");\n        params.add(getIndirectColumnExclusions().toString());\n        params.add(\"-dbthreads\");\n        params.add(String.valueOf(getMaxDbThreads()));\n        params.add(\"-maxdet\");\n        params.add(String.valueOf(getMaxDetailedTables()));\n        params.add(\"-o\");\n        params.add(getOutputDir().toString());\n        return params;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/ConfigTest24.java",
		"test_prompt": "// ConfigTest24.java\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Config}.\n* It contains ten unit test cases for the {@link Config#getBuiltInDatabaseTypes(String)} method.\n*/\nclass ConfigTest24 {"
	},
	{
		"original_code": "// Config.java\n/*\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\n\n/**\n * Configuration of a SchemaSpy run\n *\n * @author John Currier\n */\npublic class Config {\n\n    private static Config instance;\n\n    private final List<String> options;\n\n    private Map<String, String> dbSpecificOptions;\n\n    private Map<String, String> originalDbSpecificOptions;\n\n    private boolean helpRequired;\n\n    private boolean dbHelpRequired;\n\n    private File outputDir;\n\n    private File graphvizDir;\n\n    private String dbType;\n\n    private String catalog;\n\n    private String schema;\n\n    private List<String> schemas;\n\n    private String user;\n\n    private Boolean singleSignOn;\n\n    private Boolean noSchema;\n\n    private String password;\n\n    private Boolean promptForPassword;\n\n    private String db;\n\n    private String host;\n\n    private Integer port;\n\n    private String server;\n\n    private String meta;\n\n    private Pattern tableInclusions;\n\n    private Pattern tableExclusions;\n\n    private Pattern columnExclusions;\n\n    private Pattern indirectColumnExclusions;\n\n    private String userConnectionPropertiesFile;\n\n    private Properties userConnectionProperties;\n\n    private Integer maxDbThreads;\n\n    private Integer maxDetailedTables;\n\n    private String driverPath;\n\n    private String css;\n\n    private String charset;\n\n    private String font;\n\n    private Integer fontSize;\n\n    private String description;\n\n    private Properties dbProperties;\n\n    private String dbPropertiesLoadedFrom;\n\n    private Level logLevel;\n\n    private SqlFormatter sqlFormatter;\n\n    private String sqlFormatterClass;\n\n    private Boolean generateHtml;\n\n    private Boolean includeImpliedConstraints;\n\n    private Boolean logoEnabled;\n\n    private Boolean rankDirBugEnabled;\n\n    private Boolean encodeCommentsEnabled;\n\n    private Boolean numRowsEnabled;\n\n    private Boolean viewsEnabled;\n\n    private Boolean meterEnabled;\n\n    private Boolean railsEnabled;\n\n    private Boolean evaluteAll;\n\n    private Boolean highQuality;\n\n    private Boolean lowQuality;\n\n    // used in conjunction with evaluateAll\n    private String schemaSpec;\n\n    private boolean hasOrphans = false;\n\n    private boolean hasRoutines = false;\n\n    private boolean populating = false;\n\n    private List<String> columnDetails;\n\n    public static final String DOT_CHARSET = \"UTF-8\";\n\n    private static final String ESCAPED_EQUALS = \"\\\\=\";\n\n    // match everything\n    private static final String DEFAULT_TABLE_INCLUSION = \".*\";\n\n    // match nothing\n    private static final String DEFAULT_TABLE_EXCLUSION = \"\";\n\n    // match nothing\n    private static final String DEFAULT_COLUMN_EXCLUSION = \"[^.]\";\n\n    /**\n     * Default constructor. Intended for when you want to inject properties\n     * independently (i.e. not from a command line interface).\n     */\n    public Config() {\n        if (instance == null)\n            setInstance(this);\n        options = new ArrayList<String>();\n    }\n\n    /**\n     * Construct a configuration from an array of options (e.g. from a command\n     * line interface).\n     *\n     * @param options\n     */\n    public Config(String[] argv) {\n        setInstance(this);\n        options = fixupArgs(Arrays.asList(argv));\n        helpRequired = options.remove(\"-?\") || options.remove(\"/?\") || options.remove(\"?\") || options.remove(\"-h\") || options.remove(\"-help\") || options.remove(\"--help\");\n        dbHelpRequired = options.remove(\"-dbHelp\") || options.remove(\"-dbhelp\");\n    }\n\n    public static Config getInstance() {\n        if (instance == null)\n            instance = new Config();\n        return instance;\n    }\n\n    /**\n     * Sets the global instance.\n     *\n     * Useful for things like selecting a specific configuration in a UI.\n     *\n     * @param config\n     */\n    public static void setInstance(Config config) {\n        instance = config;\n    }\n\n    public void setHtmlGenerationEnabled(boolean generateHtml) {\n        this.generateHtml = generateHtml;\n    }\n\n    public boolean isHtmlGenerationEnabled() {\n        if (generateHtml == null)\n            generateHtml = !options.remove(\"-nohtml\");\n        return generateHtml;\n    }\n\n    public void setImpliedConstraintsEnabled(boolean includeImpliedConstraints) {\n        this.includeImpliedConstraints = includeImpliedConstraints;\n    }\n\n    public boolean isImpliedConstraintsEnabled() {\n        if (includeImpliedConstraints == null)\n            includeImpliedConstraints = !options.remove(\"-noimplied\");\n        return includeImpliedConstraints;\n    }\n\n    public void setOutputDir(String outputDirName) {\n        if (outputDirName.endsWith(\"\\\"\"))\n            outputDirName = outputDirName.substring(0, outputDirName.length() - 1);\n        setOutputDir(new File(outputDirName));\n    }\n\n    public void setOutputDir(File outputDir) {\n        this.outputDir = outputDir;\n    }\n\n    public File getOutputDir() {\n        if (outputDir == null) {\n            setOutputDir(pullRequiredParam(\"-o\"));\n        }\n        return outputDir;\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(String graphvizDir) {\n        if (graphvizDir.endsWith(\"\\\"\"))\n            graphvizDir = graphvizDir.substring(0, graphvizDir.length() - 1);\n        setGraphvizDir(new File(graphvizDir));\n    }\n\n    /**\n     * Set the path to Graphviz so we can find dot to generate ER diagrams\n     *\n     * @param graphvizDir\n     */\n    public void setGraphvizDir(File graphvizDir) {\n        this.graphvizDir = graphvizDir;\n    }\n\n    /**\n     * Return the path to Graphviz (used to find the dot executable to run to\n     * generate ER diagrams).<p/>\n     *\n     * Returns {@link #getDefaultGraphvizPath()} if a specific Graphviz path\n     * was not specified.\n     *\n     * @return\n     */\n    public File getGraphvizDir() {\n        if (graphvizDir == null) {\n            String gv = pullParam(\"-gv\");\n            if (gv != null) {\n                setGraphvizDir(gv);\n            } else {\n                // expect to find Graphviz's bin directory on the PATH\n            }\n        }\n        return graphvizDir;\n    }\n\n    /**\n     * Meta files are XML-based files that provide additional metadata\n     * about the schema being evaluated.<p>\n     * <code>meta</code> is either the name of an individual XML file or\n     * the directory that contains meta files.<p>\n     * If a directory is specified then it is expected to contain files\n     * matching the pattern <code>[schema].meta.xml</code>.\n     * For databases that don't have schema substitute database for schema.\n     * @param meta\n     */\n    public void setMeta(String meta) {\n        this.meta = meta;\n    }\n\n    public String getMeta() {\n        if (meta == null)\n            meta = pullParam(\"-meta\");\n        return meta;\n    }\n\n    public void setDbType(String dbType) {\n        this.dbType = dbType;\n    }\n\n    public String getDbType() {\n        if (dbType == null) {\n            dbType = pullParam(\"-t\");\n            if (dbType == null)\n                dbType = \"ora\";\n        }\n        return dbType;\n    }\n\n    public void setDb(String db) {\n        this.db = db;\n    }\n\n    public String getDb() {\n        if (db == null)\n            db = pullParam(\"-db\");\n        return db;\n    }\n\n    public void setCatalog(String catalog) {\n        this.catalog = catalog;\n    }\n\n    public String getCatalog() {\n        if (catalog == null)\n            catalog = pullParam(\"-cat\");\n        return catalog;\n    }\n\n    public void setSchema(String schema) {\n        this.schema = schema;\n    }\n\n    public String getSchema() {\n        if (schema == null)\n            schema = pullParam(\"-s\");\n        return schema;\n    }\n\n    /**\n     * Some databases types (e.g. older versions of Informix) don't really\n     * have the concept of a schema but still return true from\n     * {@link DatabaseMetaData#supportsSchemasInTableDefinitions()}.\n     * This option lets you ignore that and treat all the tables\n     * as if they were in one flat namespace.\n     */\n    public boolean isSchemaDisabled() {\n        if (noSchema == null)\n            noSchema = options.remove(\"-noschema\");\n        return noSchema;\n    }\n\n    public void setHost(String host) {\n        this.host = host;\n    }\n\n    public String getHost() {\n        if (host == null)\n            host = pullParam(\"-host\");\n        return host;\n    }\n\n    public void setPort(Integer port) {\n        this.port = port;\n    }\n\n    public Integer getPort() {\n        if (port == null)\n            try {\n                port = Integer.valueOf(pullParam(\"-port\"));\n            } catch (Exception notSpecified) {\n            }\n        return port;\n    }\n\n    public void setServer(String server) {\n        this.server = server;\n    }\n\n    public String getServer() {\n        if (server == null) {\n            server = pullParam(\"-server\");\n        }\n        return server;\n    }\n\n    public void setUser(String user) {\n        this.user = user;\n    }\n\n    /**\n     * User used to connect to the database.\n     * Required unless single sign-on is enabled\n     * (see {@link #setSingleSignOn(boolean)}).\n     * @return\n     */\n    public String getUser() {\n        if (user == null) {\n            if (!isSingleSignOn())\n                user = pullRequiredParam(\"-u\");\n            else\n                user = pullParam(\"-u\");\n        }\n        return user;\n    }\n\n    /**\n     * By default a \"user\" (as specified with -u) is required.\n     * This option allows disabling of that requirement for\n     * single sign-on environments.\n     *\n     * @param enabled defaults to <code>false</code>\n     */\n    public void setSingleSignOn(boolean enabled) {\n        singleSignOn = enabled;\n    }\n\n    /**\n     * @see #setSingleSignOn(boolean)\n     */\n    public boolean isSingleSignOn() {\n        if (singleSignOn == null)\n            singleSignOn = options.remove(\"-sso\");\n        return singleSignOn;\n    }\n\n    /**\n     * Set the password used to connect to the database.\n     * @param password\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    /**\n     * @see #setPassword(String)\n     * @return\n     */\n    public String getPassword() {\n        if (password == null)\n            password = pullParam(\"-p\");\n        if (password == null && isPromptForPasswordEnabled())\n            password = new String(PasswordReader.getInstance().readPassword(\"Password: \"));\n        if (password == null) {\n            // if -pfp is enabled when analyzing multiple schemas then\n            // we don't want to send the password on the command line,\n            // so see if it was passed in the environment (not ideal, but safer)\n            password = System.getenv(\"schemaspy.pw\");\n        }\n        return password;\n    }\n\n    /**\n     * Set to <code>true</code> to prompt for the password\n     * @param promptForPassword\n     */\n    public void setPromptForPasswordEnabled(boolean promptForPassword) {\n        this.promptForPassword = promptForPassword;\n    }\n\n    /**\n     * @see #setPromptForPasswordEnabled(boolean)\n     * @return\n     */\n    public boolean isPromptForPasswordEnabled() {\n        if (promptForPassword == null) {\n            promptForPassword = options.remove(\"-pfp\");\n        }\n        return promptForPassword;\n    }\n\n    public void setMaxDetailedTabled(int maxDetailedTables) {\n        this.maxDetailedTables = new Integer(maxDetailedTables);\n    }\n\n    public int getMaxDetailedTables() {\n        if (maxDetailedTables == null) {\n            // default\n            int max = 300;\n            try {\n                max = Integer.parseInt(pullParam(\"-maxdet\"));\n            } catch (Exception notSpecified) {\n            }\n            maxDetailedTables = new Integer(max);\n        }\n        return maxDetailedTables.intValue();\n    }\n\n    public String getConnectionPropertiesFile() {\n        return userConnectionPropertiesFile;\n    }\n\n    /**\n     * Properties from this file (in key=value pair format) are passed to the\n     * database connection.<br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.\n     * @param propertiesFilename\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public void setConnectionPropertiesFile(String propertiesFilename) throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null)\n            userConnectionProperties = new Properties();\n        userConnectionProperties.load(new FileInputStream(propertiesFilename));\n        userConnectionPropertiesFile = propertiesFilename;\n    }\n\n    /**\n     * Returns a {@link Properties} populated either from the properties file specified\n     * by {@link #setConnectionPropertiesFile(String)}, the properties specified by\n     * {@link #setConnectionProperties(String)} or not populated.\n     * @return\n     * @throws FileNotFoundException\n     * @throws IOException\n     */\n    public Properties getConnectionProperties() throws FileNotFoundException, IOException {\n        if (userConnectionProperties == null) {\n            String props = pullParam(\"-connprops\");\n            if (props != null) {\n                if (props.indexOf(ESCAPED_EQUALS) != -1) {\n                    setConnectionProperties(props);\n                } else {\n                    setConnectionPropertiesFile(props);\n                }\n            } else {\n                userConnectionProperties = new Properties();\n            }\n        }\n        return userConnectionProperties;\n    }\n\n    /**\n     * Specifies connection properties to use in the format:\n     * <code>key1\\=value1;key2\\=value2</code><br>\n     * user (from -u) and password (from -p) will be passed in the\n     * connection properties if specified.<p>\n     * This is an alternative form of passing connection properties than by file\n     * (see {@link #setConnectionPropertiesFile(String)})\n     *\n     * @param properties\n     */\n    public void setConnectionProperties(String properties) {\n        userConnectionProperties = new Properties();\n        StringTokenizer tokenizer = new StringTokenizer(properties, \";\");\n        while (tokenizer.hasMoreElements()) {\n            String pair = tokenizer.nextToken();\n            int index = pair.indexOf(ESCAPED_EQUALS);\n            if (index != -1) {\n                String key = pair.substring(0, index);\n                String value = pair.substring(index + ESCAPED_EQUALS.length());\n                userConnectionProperties.put(key, value);\n            }\n        }\n    }\n\n    public void setDriverPath(String driverPath) {\n        this.driverPath = driverPath;\n    }\n\n    public String getDriverPath() {\n        if (driverPath == null)\n            driverPath = pullParam(\"-dp\");\n        // was previously -cp:\n        if (driverPath == null)\n            driverPath = pullParam(\"-cp\");\n        return driverPath;\n    }\n\n    /**\n     * The filename of the cascading style sheet to use.\n     * Note that this file is parsed and used to determine characteristics\n     * of the generated diagrams, so it must contain specific settings that\n     * are documented within schemaSpy.css.<p>\n     *\n     * Defaults to <code>\"schemaSpy.css\"</code>.\n     *\n     * @param css\n     */\n    public void setCss(String css) {\n        this.css = css;\n    }\n\n    public String getCss() {\n        if (css == null) {\n            css = pullParam(\"-css\");\n            if (css == null)\n                css = \"schemaSpy.css\";\n        }\n        return css;\n    }\n\n    /**\n     * The font to use within diagrams.  Modify the .css to specify HTML fonts.\n     *\n     * @param font\n     */\n    public void setFont(String font) {\n        this.font = font;\n    }\n\n    /**\n     * @see #setFont(String)\n     */\n    public String getFont() {\n        if (font == null) {\n            font = pullParam(\"-font\");\n            if (font == null)\n                font = \"Helvetica\";\n        }\n        return font;\n    }\n\n    /**\n     * The font size to use within diagrams.  This is the size of the font used for\n     * 'large' (e.g. not 'compact') diagrams.<p>\n     *\n     * Modify the .css to specify HTML font sizes.<p>\n     *\n     * Defaults to 11.\n     *\n     * @param fontSize\n     */\n    public void setFontSize(int fontSize) {\n        this.fontSize = new Integer(fontSize);\n    }\n\n    /**\n     * @see #setFontSize(int)\n     * @return\n     */\n    public int getFontSize() {\n        if (fontSize == null) {\n            // default\n            int size = 11;\n            try {\n                size = Integer.parseInt(pullParam(\"-fontsize\"));\n            } catch (Exception notSpecified) {\n            }\n            fontSize = new Integer(size);\n        }\n        return fontSize.intValue();\n    }\n\n    /**\n     * The character set to use within HTML pages (defaults to <code>\"ISO-8859-1\"</code>).\n     *\n     * @param charset\n     */\n    public void setCharset(String charset) {\n        this.charset = charset;\n    }\n\n    /**\n     * @see #setCharset(String)\n     */\n    public String getCharset() {\n        if (charset == null) {\n            charset = pullParam(\"-charset\");\n            if (charset == null)\n                charset = \"ISO-8859-1\";\n        }\n        return charset;\n    }\n\n    /**\n     * Description of schema that gets display on main pages.\n     *\n     * @param description\n     */\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    /**\n     * @see #setDescription(String)\n     */\n    public String getDescription() {\n        if (description == null)\n            description = pullParam(\"-desc\");\n        return description;\n    }\n\n    /**\n     * Maximum number of threads to use when querying database metadata information.\n     *\n     * @param maxDbThreads\n     */\n    public void setMaxDbThreads(int maxDbThreads) {\n        this.maxDbThreads = new Integer(maxDbThreads);\n    }\n\n    /**\n     * @see #setMaxDbThreads(int)\n     * @throws InvalidConfigurationException if unable to load properties\n     */\n    public int getMaxDbThreads() throws InvalidConfigurationException {\n        if (maxDbThreads == null) {\n            Properties properties;\n            try {\n                properties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(\"Failed to load properties for \" + getDbType() + \": \" + exc).setParamName(\"-type\");\n            }\n            // not scientifically derived\n            final int defaultMax = 15;\n            int max = defaultMax;\n            String threads = properties.getProperty(\"dbThreads\");\n            if (threads == null)\n                threads = properties.getProperty(\"dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            threads = pullParam(\"-dbThreads\");\n            if (threads == null)\n                threads = pullParam(\"-dbthreads\");\n            if (threads != null)\n                max = Integer.parseInt(threads);\n            if (max < 0)\n                max = defaultMax;\n            else if (max == 0)\n                max = 1;\n            maxDbThreads = new Integer(max);\n        }\n        return maxDbThreads.intValue();\n    }\n\n    public boolean isLogoEnabled() {\n        if (logoEnabled == null)\n            logoEnabled = !options.remove(\"-nologo\");\n        return logoEnabled;\n    }\n\n    /**\n     * Don't use this unless absolutely necessary as it screws up the layout\n     *\n     * @param enabled\n     */\n    public void setRankDirBugEnabled(boolean enabled) {\n        rankDirBugEnabled = enabled;\n    }\n\n    /**\n     * @see #setRankDirBugEnabled(boolean)\n     */\n    public boolean isRankDirBugEnabled() {\n        if (rankDirBugEnabled == null)\n            rankDirBugEnabled = options.remove(\"-rankdirbug\");\n        return rankDirBugEnabled;\n    }\n\n    /**\n     * Look for Ruby on Rails-based naming conventions in\n     * relationships between logical foreign keys and primary keys.<p>\n     *\n     * Basically all tables have a primary key named <code>ID</code>.\n     * All tables are named plural names.\n     * The columns that logically reference that <code>ID</code> are the singular\n     * form of the table name suffixed with <code>_ID</code>.<p>\n     *\n     * @param enabled\n     */\n    public void setRailsEnabled(boolean enabled) {\n        railsEnabled = enabled;\n    }\n\n    /**\n     * @see #setRailsEnabled(boolean)\n     *\n     * @return\n     */\n    public boolean isRailsEnabled() {\n        if (railsEnabled == null)\n            railsEnabled = options.remove(\"-rails\");\n        return railsEnabled;\n    }\n\n    /**\n     * Allow Html In Comments - encode them unless otherwise specified\n     */\n    public void setEncodeCommentsEnabled(boolean enabled) {\n        encodeCommentsEnabled = enabled;\n    }\n\n    /**\n     * @see #setEncodeCommentsEnabled(boolean)\n     */\n    public boolean isEncodeCommentsEnabled() {\n        if (encodeCommentsEnabled == null)\n            encodeCommentsEnabled = !options.remove(\"-ahic\");\n        return encodeCommentsEnabled;\n    }\n\n    /**\n     * If enabled we'll attempt to query/render the number of rows that\n     * each table contains.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setNumRowsEnabled(boolean enabled) {\n        numRowsEnabled = enabled;\n    }\n\n    /**\n     * @see #setNumRowsEnabled(boolean)\n     * @return\n     */\n    public boolean isNumRowsEnabled() {\n        if (numRowsEnabled == null)\n            numRowsEnabled = !options.remove(\"-norows\");\n        return numRowsEnabled;\n    }\n\n    /**\n     * If enabled we'll include views in the analysis.<p/>\n     *\n     * Defaults to <code>true</code> (enabled).\n     *\n     * @param enabled\n     */\n    public void setViewsEnabled(boolean enabled) {\n        viewsEnabled = enabled;\n    }\n\n    /**\n     * @see #setViewsEnabled(boolean)\n     * @return\n     */\n    public boolean isViewsEnabled() {\n        if (viewsEnabled == null)\n            viewsEnabled = !options.remove(\"-noviews\");\n        return viewsEnabled;\n    }\n\n    /**\n     * Returns <code>true</code> if metering should be embedded in\n     * the generated pages.<p/>\n     * Defaults to <code>false</code> (disabled).\n     * @return\n     */\n    public boolean isMeterEnabled() {\n        if (meterEnabled == null)\n            meterEnabled = options.remove(\"-meter\");\n        return meterEnabled;\n    }\n\n    /**\n     * Set the columns to exclude from all relationship diagrams.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setColumnExclusions(String columnExclusions) {\n        this.columnExclusions = Pattern.compile(columnExclusions);\n    }\n\n    /**\n     * See {@link #setColumnExclusions(String)}\n     * @return\n     */\n    public Pattern getColumnExclusions() {\n        if (columnExclusions == null) {\n            String strExclusions = pullParam(\"-X\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.columnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            columnExclusions = Pattern.compile(strExclusions);\n        }\n        return columnExclusions;\n    }\n\n    /**\n     * Set the columns to exclude from relationship diagrams where the specified\n     * columns aren't directly referenced by the focal table.\n     *\n     * @param columnExclusions regular expression of the columns to\n     *        exclude\n     */\n    public void setIndirectColumnExclusions(String fullColumnExclusions) {\n        indirectColumnExclusions = Pattern.compile(fullColumnExclusions);\n    }\n\n    /**\n     * @see #setIndirectColumnExclusions(String)\n     *\n     * @return\n     */\n    public Pattern getIndirectColumnExclusions() {\n        if (indirectColumnExclusions == null) {\n            String strExclusions = pullParam(\"-x\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.indirectColumnExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_COLUMN_EXCLUSION;\n            indirectColumnExclusions = Pattern.compile(strExclusions);\n        }\n        return indirectColumnExclusions;\n    }\n\n    /**\n     * Set the tables to include as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableInclusions(String tableInclusions) {\n        this.tableInclusions = Pattern.compile(tableInclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to include in the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableInclusions() {\n        if (tableInclusions == null) {\n            String strInclusions = pullParam(\"-i\");\n            if (strInclusions == null)\n                strInclusions = System.getenv(\"schemaspy.tableInclusions\");\n            if (strInclusions == null)\n                strInclusions = DEFAULT_TABLE_INCLUSION;\n            try {\n                tableInclusions = Pattern.compile(strInclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-i\");\n            }\n        }\n        return tableInclusions;\n    }\n\n    /**\n     * Set the tables to exclude as a regular expression\n     * @param tableInclusions\n     */\n    public void setTableExclusions(String tableExclusions) {\n        this.tableExclusions = Pattern.compile(tableExclusions);\n    }\n\n    /**\n     * Get the regex {@link Pattern} for which tables to exclude from the analysis.\n     *\n     * @return\n     */\n    public Pattern getTableExclusions() {\n        if (tableExclusions == null) {\n            String strExclusions = pullParam(\"-I\");\n            if (strExclusions == null)\n                strExclusions = System.getenv(\"schemaspy.tableExclusions\");\n            if (strExclusions == null)\n                strExclusions = DEFAULT_TABLE_EXCLUSION;\n            try {\n                tableExclusions = Pattern.compile(strExclusions);\n            } catch (PatternSyntaxException badPattern) {\n                throw new InvalidConfigurationException(badPattern).setParamName(\"-I\");\n            }\n        }\n        return tableExclusions;\n    }\n\n    /**\n     * @return\n     */\n    public List<String> getSchemas() {\n        if (schemas == null) {\n            String tmp = pullParam(\"-schemas\");\n            if (tmp == null)\n                tmp = pullParam(\"-schemata\");\n            if (tmp != null) {\n                schemas = new ArrayList<String>();\n                for (String name : tmp.split(\"[\\\\s,'\\\"]\")) {\n                    if (name.length() > 0)\n                        schemas.add(name);\n                }\n                if (schemas.isEmpty())\n                    schemas = null;\n            }\n        }\n        return schemas;\n    }\n\n    /**\n     * Set the name of the {@link SqlFormatter SQL formatter} class to use to\n     * format SQL into HTML.<p/>\n     * The implementation of the class must be made available to the class\n     * loader, typically by specifying the path to its jar with <em>-dp</em>\n     * ({@link #setDriverPath(String)}).\n     */\n    public void setSqlFormatter(String formatterClassName) {\n        sqlFormatterClass = formatterClassName;\n        sqlFormatter = null;\n    }\n\n    /**\n     * Set the {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.\n     */\n    public void setSqlFormatter(SqlFormatter sqlFormatter) {\n        this.sqlFormatter = sqlFormatter;\n        if (sqlFormatter != null)\n            sqlFormatterClass = sqlFormatter.getClass().getName();\n    }\n\n    /**\n     * Returns an implementation of {@link SqlFormatter SQL formatter} to use to format\n     * SQL into HTML.  The default implementation is {@link DefaultSqlFormatter}.\n     *\n     * @return\n     * @throws InvalidConfigurationException if unable to instantiate an instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public SqlFormatter getSqlFormatter() throws InvalidConfigurationException {\n        if (sqlFormatter == null) {\n            if (sqlFormatterClass == null) {\n                sqlFormatterClass = pullParam(\"-sqlFormatter\");\n                if (sqlFormatterClass == null)\n                    sqlFormatterClass = DefaultSqlFormatter.class.getName();\n            }\n            try {\n                Class<SqlFormatter> clazz = (Class<SqlFormatter>) Class.forName(sqlFormatterClass);\n                sqlFormatter = clazz.newInstance();\n            } catch (Exception exc) {\n                throw new InvalidConfigurationException(\"Failed to initialize instance of SQL formatter: \", exc).setParamName(\"-sqlFormatter\");\n            }\n        }\n        return sqlFormatter;\n    }\n\n    /**\n     * Set the details to show on the columns page, where \"details\" are\n     * comma and/or space separated.\n     *\n     * Valid values:\n     * <ul>\n     * <li>id</li>\n     * <li>table</li>\n     * <li>column</li>\n     * <li>type</li>\n     * <li>size</li>\n     * <li>nulls</li>\n     * <li>auto</li>\n     * <li>default</li>\n     * <li>children</li>\n     * <li>parents</li>\n     * </ul>\n     *\n     * The default details are <code>\"table column type size nulls auto default\"</code>.\n     * Note that \"column\" is the initially displayed detail and must be included.\n     *\n     * @param columnDetails\n     */\n    public void setColumnDetails(String columnDetails) {\n        this.columnDetails = new ArrayList<String>();\n        if (columnDetails == null || columnDetails.length() == 0) {\n            // not specified, so use defaults\n            columnDetails = \"id table column type size nulls auto default\";\n        }\n        for (String detail : columnDetails.split(\"[\\\\s,'\\\"]\")) {\n            if (detail.length() > 0) {\n                this.columnDetails.add(detail.toLowerCase());\n            }\n        }\n        if (!this.columnDetails.contains(\"column\"))\n            throw new InvalidConfigurationException(\"'column' is a required column detail\");\n    }\n\n    public void setColumnDetails(List<String> columnDetails) {\n        String details = columnDetails == null ? \"[]\" : columnDetails.toString();\n        setColumnDetails(details.substring(1, details.length() - 1));\n    }\n\n    public List<String> getColumnDetails() {\n        if (columnDetails == null) {\n            setColumnDetails(pullParam(\"-columndetails\"));\n        }\n        return columnDetails;\n    }\n\n    public void setEvaluateAllEnabled(boolean enabled) {\n        evaluteAll = enabled;\n    }\n\n    public boolean isEvaluateAllEnabled() {\n        if (evaluteAll == null)\n            evaluteAll = options.remove(\"-all\");\n        return evaluteAll;\n    }\n\n    /**\n     * Returns true if we're evaluating a bunch of schemas in one go and\n     * at this point we're evaluating a specific schema.\n     *\n     * @return boolean\n     */\n    public boolean isOneOfMultipleSchemas() {\n        // set by MultipleSchemaAnalyzer\n        return Boolean.getBoolean(\"oneofmultipleschemas\");\n    }\n\n    /**\n     * When -all (evaluateAll) is specified then this is the regular\n     * expression that determines which schemas to evaluate.\n     *\n     * @param schemaSpec\n     */\n    public void setSchemaSpec(String schemaSpec) {\n        this.schemaSpec = schemaSpec;\n    }\n\n    public String getSchemaSpec() {\n        if (schemaSpec == null)\n            schemaSpec = pullParam(\"-schemaSpec\");\n        return schemaSpec;\n    }\n\n    /**\n     * Set the renderer to use for the -Tpng[:renderer[:formatter]] dot option as specified\n     * at <a href='http://www.graphviz.org/doc/info/command.html'>\n     * http://www.graphviz.org/doc/info/command.html</a>.<p>\n     * Note that the leading \":\" is required while :formatter is optional.<p>\n     * The default renderer is typically GD.<p>\n     * Note that using {@link #setHighQuality(boolean)} is the preferred approach\n     * over using this method.\n     */\n    public void setRenderer(String renderer) {\n        Dot.getInstance().setRenderer(renderer);\n    }\n\n    /**\n     * @see #setRenderer(String)\n     * @return\n     */\n    public String getRenderer() {\n        String renderer = pullParam(\"-renderer\");\n        if (renderer != null)\n            setRenderer(renderer);\n        return Dot.getInstance().getRenderer();\n    }\n\n    /**\n     * If <code>false</code> then generate output of \"lower quality\"\n     * than the default.\n     * Note that the default is intended to be \"higher quality\",\n     * but various installations of Graphviz may have have different abilities.\n     * That is, some might not have the \"lower quality\" libraries and others might\n     * not have the \"higher quality\" libraries.<p>\n     * Higher quality output takes longer to generate and results in significantly\n     * larger image files (which take longer to download / display), but it generally\n     * looks better.\n     */\n    public void setHighQuality(boolean highQuality) {\n        this.highQuality = highQuality;\n        lowQuality = !highQuality;\n        Dot.getInstance().setHighQuality(highQuality);\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isHighQuality() {\n        if (highQuality == null) {\n            highQuality = options.remove(\"-hq\");\n            if (highQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(highQuality);\n            }\n        }\n        highQuality = Dot.getInstance().isHighQuality();\n        return highQuality;\n    }\n\n    /**\n     * @see #setHighQuality(boolean)\n     */\n    public boolean isLowQuality() {\n        if (lowQuality == null) {\n            lowQuality = options.remove(\"-lq\");\n            if (lowQuality) {\n                // use whatever is the default unless explicitly specified otherwise\n                Dot.getInstance().setHighQuality(!lowQuality);\n            }\n        }\n        lowQuality = !Dot.getInstance().isHighQuality();\n        return lowQuality;\n    }\n\n    /**\n     * Set the level of logging to perform.<p/>\n     * The levels in descending order are:\n     * <ul>\n     *  <li><code>severe</code> (highest - least detail)\n     *  <li><code>warning</code> (default)\n     *  <li><code>info</code>\n     *  <li><code>config</code>\n     *  <li><code>fine</code>\n     *  <li><code>finer</code>\n     *  <li><code>finest</code>  (lowest - most detail)\n     * </ul>\n     *\n     * @param logLevel\n     */\n    public void setLogLevel(String logLevel) {\n        if (logLevel == null) {\n            this.logLevel = Level.WARNING;\n            return;\n        }\n        Map<String, Level> levels = new LinkedHashMap<String, Level>();\n        levels.put(\"severe\", Level.SEVERE);\n        levels.put(\"warning\", Level.WARNING);\n        levels.put(\"info\", Level.INFO);\n        levels.put(\"config\", Level.CONFIG);\n        levels.put(\"fine\", Level.FINE);\n        levels.put(\"finer\", Level.FINER);\n        levels.put(\"finest\", Level.FINEST);\n        this.logLevel = levels.get(logLevel.toLowerCase());\n        if (this.logLevel == null) {\n            throw new InvalidConfigurationException(\"Invalid logLevel: '\" + logLevel + \"'. Must be one of: \" + levels.keySet());\n        }\n    }\n\n    /**\n     * Returns the level of logging to perform.\n     * See {@link #setLogLevel(String)}.\n     *\n     * @return\n     */\n    public Level getLogLevel() {\n        if (logLevel == null) {\n            setLogLevel(pullParam(\"-loglevel\"));\n        }\n        return logLevel;\n    }\n\n    /**\n     * Returns <code>true</code> if the options indicate that the user wants\n     * to see some help information.\n     *\n     * @return\n     */\n    public boolean isHelpRequired() {\n        return helpRequired;\n    }\n\n    public boolean isDbHelpRequired() {\n        return dbHelpRequired;\n    }\n\n    /**\n     * Returns the jar that we were loaded from\n     *\n     * @return\n     */\n    public static String getLoadedFromJar() {\n        String classpath = System.getProperty(\"java.class.path\");\n        return new StringTokenizer(classpath, File.pathSeparator).nextToken();\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasOrphans(boolean hasOrphans) {\n        this.hasOrphans = hasOrphans;\n    }\n\n    /**\n     * @see #setHasOrphans()\n     *\n     * @return\n     */\n    public boolean hasOrphans() {\n        return hasOrphans;\n    }\n\n    /**\n     * Not a true configuration item in that it's determined at runtime\n     */\n    public void setHasRoutines(boolean hasRoutines) {\n        this.hasRoutines = hasRoutines;\n    }\n\n    /**\n     * @see #setHasRoutines()\n     *\n     * @return\n     */\n    public boolean hasRoutines() {\n        return hasRoutines;\n    }\n\n    /**\n     * Returns the database properties to use.\n     * These should be determined by calling {@link #determineDbProperties(String)}.\n     * @return\n     * @throws InvalidConfigurationException\n     */\n    public Properties getDbProperties() throws InvalidConfigurationException {\n        if (dbProperties == null) {\n            try {\n                dbProperties = determineDbProperties(getDbType());\n            } catch (IOException exc) {\n                throw new InvalidConfigurationException(exc);\n            }\n        }\n        return dbProperties;\n    }\n\n    /**\n     * Determines the database properties associated with the specified type.\n     * A call to {@link #setDbProperties(Properties)} is expected after determining\n     * the complete set of properties.\n     *\n     * @param type\n     * @return\n     * @throws IOException\n     * @throws InvalidConfigurationException if db properties are incorrectly formed\n     */\n    public Properties determineDbProperties(String type) throws IOException, InvalidConfigurationException {\n        ResourceBundle bundle = null;\n        try {\n            File propertiesFile = new File(type);\n            bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n            dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n        } catch (FileNotFoundException notFoundOnFilesystemWithoutExtension) {\n            try {\n                File propertiesFile = new File(type + \".properties\");\n                bundle = new PropertyResourceBundle(new FileInputStream(propertiesFile));\n                dbPropertiesLoadedFrom = propertiesFile.getAbsolutePath();\n            } catch (FileNotFoundException notFoundOnFilesystemWithExtensionTackedOn) {\n                try {\n                    bundle = ResourceBundle.getBundle(type);\n                    dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]\" + File.separator + type + \".properties\";\n                } catch (Exception notInJarWithoutPath) {\n                    try {\n                        String path = TableOrderer.class.getPackage().getName() + \".dbTypes.\" + type;\n                        path = path.replace('.', '/');\n                        bundle = ResourceBundle.getBundle(path);\n                        dbPropertiesLoadedFrom = \"[\" + getLoadedFromJar() + \"]/\" + path + \".properties\";\n                    } catch (Exception notInJar) {\n                        notInJar.printStackTrace();\n                        notFoundOnFilesystemWithExtensionTackedOn.printStackTrace();\n                        throw notFoundOnFilesystemWithoutExtension;\n                    }\n                }\n            }\n        }\n        Properties props = asProperties(bundle);\n        bundle = null;\n        // keep original thru recursion\n        String saveLoadedFrom = dbPropertiesLoadedFrom;\n        // bring in key/values pointed to by the include directive\n        // example: include.1=mysql::selectRowCountSql\n        for (int i = 1; true; ++i) {\n            String include = (String) props.remove(\"include.\" + i);\n            if (include == null)\n                break;\n            int separator = include.indexOf(\"::\");\n            if (separator == -1)\n                throw new InvalidConfigurationException(\"include directive in \" + dbPropertiesLoadedFrom + \" must have '::' between dbType and key\");\n            String refdType = include.substring(0, separator).trim();\n            String refdKey = include.substring(separator + 2).trim();\n            // recursively resolve the ref'd properties file and the ref'd key\n            Properties refdProps = determineDbProperties(refdType);\n            props.put(refdKey, refdProps.getProperty(refdKey));\n        }\n        // bring in base properties files pointed to by the extends directive\n        String baseDbType = (String) props.remove(\"extends\");\n        if (baseDbType != null) {\n            baseDbType = baseDbType.trim();\n            Properties baseProps = determineDbProperties(baseDbType);\n            // overlay our properties on top of the base's\n            baseProps.putAll(props);\n            props = baseProps;\n        }\n        // done with this level of recursion...restore original\n        dbPropertiesLoadedFrom = saveLoadedFrom;\n        // this won't be correct until the final recursion exits\n        dbProperties = props;\n        return props;\n    }\n\n    protected String getDbPropertiesLoadedFrom() throws IOException {\n        if (dbPropertiesLoadedFrom == null)\n            determineDbProperties(getDbType());\n        return dbPropertiesLoadedFrom;\n    }\n\n    public List<String> getRemainingParameters() {\n        try {\n            populate();\n        } catch (IllegalArgumentException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (IllegalAccessException exc) {\n            throw new InvalidConfigurationException(exc);\n        } catch (InvocationTargetException exc) {\n            if (exc.getCause() instanceof InvalidConfigurationException)\n                throw (InvalidConfigurationException) exc.getCause();\n            throw new InvalidConfigurationException(exc.getCause());\n        } catch (IntrospectionException exc) {\n            throw new InvalidConfigurationException(exc);\n        }\n        return options;\n    }\n\n    /**\n     * Options that are specific to a type of database.  E.g. things like <code>host</code>,\n     * <code>port</code> or <code>db</code>, but <b>don't</b> have a setter in this class.\n     *\n     * @param dbSpecificOptions\n     */\n    public void setDbSpecificOptions(Map<String, String> dbSpecificOptions) {\n        this.dbSpecificOptions = dbSpecificOptions;\n        originalDbSpecificOptions = new HashMap<String, String>(dbSpecificOptions);\n    }\n\n    public Map<String, String> getDbSpecificOptions() {\n        if (dbSpecificOptions == null)\n            dbSpecificOptions = new HashMap<String, String>();\n        return dbSpecificOptions;\n    }\n\n    /**\n     * Returns a {@link Properties} populated with the contents of <code>bundle</code>\n     *\n     * @param bundle ResourceBundle\n     * @return Properties\n     */\n    public static Properties asProperties(ResourceBundle bundle) {\n        Properties props = new Properties();\n        Enumeration<String> iter = bundle.getKeys();\n        while (iter.hasMoreElements()) {\n            String key = iter.nextElement();\n            props.put(key, bundle.getObject(key));\n        }\n        return props;\n    }\n\n    /**\n     * 'Pull' the specified parameter from the collection of options. Returns\n     * null if the parameter isn't in the list and removes it if it is.\n     *\n     * @param paramId\n     * @return\n     */\n    private String pullParam(String paramId) {\n        return pullParam(paramId, false, false);\n    }\n\n    private String pullRequiredParam(String paramId) {\n        return pullParam(paramId, true, false);\n    }\n\n    /**\n     * @param paramId\n     * @param required\n     * @param dbTypeSpecific\n     * @return\n     * @throws MissingRequiredParameterException\n     */\n    private String pullParam(String paramId, boolean required, boolean dbTypeSpecific) throws MissingRequiredParameterException {\n        int paramIndex = options.indexOf(paramId);\n        if (paramIndex < 0) {\n            if (required)\n                throw new MissingRequiredParameterException(paramId, dbTypeSpecific);\n            return null;\n        }\n        options.remove(paramIndex);\n        String param = options.get(paramIndex).toString();\n        options.remove(paramIndex);\n        return param;\n    }\n\n    /**\n     * Thrown to indicate that a required parameter is missing\n     */\n    public static class MissingRequiredParameterException extends RuntimeException {\n\n        private static final long serialVersionUID = 1L;\n\n        private final boolean dbTypeSpecific;\n\n        public MissingRequiredParameterException(String paramId, boolean dbTypeSpecific) {\n            this(paramId, null, dbTypeSpecific);\n        }\n\n        public MissingRequiredParameterException(String paramId, String description, boolean dbTypeSpecific) {\n            super(\"Required parameter '\" + paramId + \"' \" + (description == null ? \"\" : \"(\" + description + \") \") + \"was not specified.\" + (dbTypeSpecific ? \"  It is required for this database type.\" : \"\"));\n            this.dbTypeSpecific = dbTypeSpecific;\n        }\n\n        public boolean isDbTypeSpecific() {\n            return dbTypeSpecific;\n        }\n    }\n\n    /**\n     * Allow an equal sign in args...like \"-o=foo.bar\". Useful for things like\n     * Ant and Maven.\n     *\n     * @param args\n     *            List\n     * @return List\n     */\n    protected List<String> fixupArgs(List<String> args) {\n        List<String> expandedArgs = new ArrayList<String>();\n        for (String arg : args) {\n            int indexOfEquals = arg.indexOf('=');\n            if (indexOfEquals != -1 && indexOfEquals - 1 != arg.indexOf(ESCAPED_EQUALS)) {\n                expandedArgs.add(arg.substring(0, indexOfEquals));\n                expandedArgs.add(arg.substring(indexOfEquals + 1));\n            } else {\n                expandedArgs.add(arg);\n            }\n        }\n        // some OSes/JVMs do filename expansion with runtime.exec() and some don't,\n        // so MultipleSchemaAnalyzer has to surround params with double quotes...\n        // strip them here for the OSes/JVMs that don't do anything with the params\n        List<String> unquotedArgs = new ArrayList<String>();\n        for (String arg : expandedArgs) {\n            if (// \".*\" becomes .*\n            arg.startsWith(\"\\\"\") && arg.endsWith(\"\\\"\"))\n                arg = arg.substring(1, arg.length() - 1);\n            unquotedArgs.add(arg);\n        }\n        return unquotedArgs;\n    }\n\n    /**\n     * Call all the getters to populate all the lazy initialized stuff.\n     *\n     * @throws InvocationTargetException\n     * @throws IllegalAccessException\n     * @throws IllegalArgumentException\n     * @throws IntrospectionException\n     */\n    private void populate() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException, IntrospectionException {\n        if (!populating) {\n            // prevent recursion\n            populating = true;\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                Method readMethod = props[i].getReadMethod();\n                if (readMethod != null)\n                    readMethod.invoke(this, (Object[]) null);\n            }\n            populating = false;\n        }\n    }\n\n    public static Set<String> getBuiltInDatabaseTypes(String loadedFromJar) {\n        Set<String> databaseTypes = new TreeSet<String>();\n        JarInputStream jar = null;\n        try {\n            jar = new JarInputStream(new FileInputStream(loadedFromJar));\n            JarEntry entry;\n            while ((entry = jar.getNextJarEntry()) != null) {\n                String entryName = entry.getName();\n                int dotPropsIndex = entryName.indexOf(\".properties\");\n                if (dotPropsIndex != -1)\n                    databaseTypes.add(entryName.substring(0, dotPropsIndex));\n            }\n        } catch (IOException exc) {\n        } finally {\n            if (jar != null) {\n                try {\n                    jar.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n        return databaseTypes;\n    }\n\n    protected void dumpUsage(String errorMessage, boolean detailedDb) {\n        if (errorMessage != null) {\n            System.out.flush();\n            System.err.println(\"*** \" + errorMessage + \" ***\");\n        } else {\n            System.out.println(\"SchemaSpy generates an HTML representation of a database schema's relationships.\");\n        }\n        System.err.flush();\n        System.out.println();\n        if (!detailedDb) {\n            System.out.println(\"Usage:\");\n            System.out.println(\" java -jar \" + getLoadedFromJar() + \" [options]\");\n            System.out.println(\"   -t databaseType       type of database - defaults to ora\");\n            System.out.println(\"                           use -dbhelp for a list of built-in types\");\n            System.out.println(\"   -u user               connect to the database with this user id\");\n            System.out.println(\"   -s schema             defaults to the specified user\");\n            System.out.println(\"   -p password           defaults to no password\");\n            System.out.println(\"   -o outputDirectory    directory to place the generated output in\");\n            System.out.println(\"   -dp pathToDrivers     optional - looks for JDBC drivers here before looking\");\n            System.out.println(\"                           in driverPath in [databaseType].properties.\");\n            System.out.println(\"Go to http://schemaspy.sourceforge.net for a complete list/description\");\n            System.out.println(\" of additional parameters.\");\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"Built-in database types and their required connection parameters:\");\n            for (String type : getBuiltInDatabaseTypes(getLoadedFromJar())) {\n                new DbSpecificConfig(type).dumpUsage();\n            }\n            System.out.println();\n        }\n        if (detailedDb) {\n            System.out.println(\"You can use your own database types by specifying the filespec of a .properties file with -t.\");\n            System.out.println(\"Grab one out of \" + getLoadedFromJar() + \" and modify it to suit your needs.\");\n            System.out.println();\n        }\n        System.out.println(\"Sample usage using the default database type (implied -t ora):\");\n        System.out.println(\" java -jar schemaSpy.jar -db mydb -s myschema -u devuser -p password -o output\");\n        System.out.println();\n        System.out.flush();\n    }\n\n    /**\n     * Get the value of the specified parameter.\n     * Used for properties that are common to most db's, but aren't required.\n     *\n     * @param paramName\n     * @return\n     */\n    public String getParam(String paramName) {\n        try {\n            BeanInfo beanInfo = Introspector.getBeanInfo(Config.class);\n            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();\n            for (int i = 0; i < props.length; ++i) {\n                PropertyDescriptor prop = props[i];\n                if (prop.getName().equalsIgnoreCase(paramName)) {\n                    Object result = prop.getReadMethod().invoke(this, (Object[]) null);\n                    return result == null ? null : result.toString();\n                }\n            }\n        } catch (Exception failed) {\n            failed.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * Return all of the configuration options as a List of Strings, with\n     * each parameter and its value as a separate element.\n     *\n     * @return\n     * @throws IOException\n     */\n    public List<String> asList() throws IOException {\n        List<String> params = new ArrayList<String>();\n        if (originalDbSpecificOptions != null) {\n            for (String key : originalDbSpecificOptions.keySet()) {\n                String value = originalDbSpecificOptions.get(key);\n                if (!key.startsWith(\"-\"))\n                    key = \"-\" + key;\n                params.add(key);\n                params.add(value);\n            }\n        }\n        if (isEncodeCommentsEnabled())\n            params.add(\"-ahic\");\n        if (isEvaluateAllEnabled())\n            params.add(\"-all\");\n        if (!isHtmlGenerationEnabled())\n            params.add(\"-nohtml\");\n        if (!isImpliedConstraintsEnabled())\n            params.add(\"-noimplied\");\n        if (!isLogoEnabled())\n            params.add(\"-nologo\");\n        if (isMeterEnabled())\n            params.add(\"-meter\");\n        if (!isNumRowsEnabled())\n            params.add(\"-norows\");\n        if (!isViewsEnabled())\n            params.add(\"-noviews\");\n        if (isRankDirBugEnabled())\n            params.add(\"-rankdirbug\");\n        if (isRailsEnabled())\n            params.add(\"-rails\");\n        if (isSingleSignOn())\n            params.add(\"-sso\");\n        if (isSchemaDisabled())\n            params.add(\"-noschema\");\n        String value = getDriverPath();\n        if (value != null) {\n            params.add(\"-dp\");\n            params.add(value);\n        }\n        params.add(\"-css\");\n        params.add(getCss());\n        params.add(\"-charset\");\n        params.add(getCharset());\n        params.add(\"-font\");\n        params.add(getFont());\n        params.add(\"-fontsize\");\n        params.add(String.valueOf(getFontSize()));\n        params.add(\"-t\");\n        params.add(getDbType());\n        // query to set renderer correctly\n        isHighQuality();\n        // query to set renderer correctly\n        isLowQuality();\n        // instead of -hq and/or -lq\n        params.add(\"-renderer\");\n        params.add(getRenderer());\n        value = getDescription();\n        if (value != null) {\n            params.add(\"-desc\");\n            params.add(value);\n        }\n        value = getPassword();\n        if (value != null && !isPromptForPasswordEnabled()) {\n            // note that we don't pass -pfp since child processes\n            // won't have a console\n            params.add(\"-p\");\n            params.add(value);\n        }\n        value = getCatalog();\n        if (value != null) {\n            params.add(\"-cat\");\n            params.add(value);\n        }\n        value = getSchema();\n        if (value != null) {\n            params.add(\"-s\");\n            params.add(value);\n        }\n        value = getUser();\n        if (value != null) {\n            params.add(\"-u\");\n            params.add(value);\n        }\n        value = getConnectionPropertiesFile();\n        if (value != null) {\n            params.add(\"-connprops\");\n            params.add(value);\n        } else {\n            Properties props = getConnectionProperties();\n            if (!props.isEmpty()) {\n                params.add(\"-connprops\");\n                StringBuilder buf = new StringBuilder();\n                for (Entry<Object, Object> entry : props.entrySet()) {\n                    buf.append(entry.getKey());\n                    buf.append(ESCAPED_EQUALS);\n                    buf.append(entry.getValue());\n                    buf.append(';');\n                }\n                params.add(buf.toString());\n            }\n        }\n        value = getDb();\n        if (value != null) {\n            params.add(\"-db\");\n            params.add(value);\n        }\n        value = getHost();\n        if (value != null) {\n            params.add(\"-host\");\n            params.add(value);\n        }\n        if (getPort() != null) {\n            params.add(\"-port\");\n            params.add(getPort().toString());\n        }\n        value = getServer();\n        if (value != null) {\n            params.add(\"-server\");\n            params.add(value);\n        }\n        value = getMeta();\n        if (value != null) {\n            params.add(\"-meta\");\n            params.add(value);\n        }\n        if (getGraphvizDir() != null) {\n            params.add(\"-gv\");\n            params.add(getGraphvizDir().toString());\n        }\n        params.add(\"-loglevel\");\n        params.add(getLogLevel().toString().toLowerCase());\n        params.add(\"-sqlFormatter\");\n        params.add(getSqlFormatter().getClass().getName());\n        params.add(\"-i\");\n        params.add(getTableInclusions().toString());\n        params.add(\"-I\");\n        params.add(getTableExclusions().toString());\n        params.add(\"-X\");\n        params.add(getColumnExclusions().toString());\n        params.add(\"-x\");\n        params.add(getIndirectColumnExclusions().toString());\n        params.add(\"-dbthreads\");\n        params.add(String.valueOf(getMaxDbThreads()));\n        params.add(\"-maxdet\");\n        params.add(String.valueOf(getMaxDetailedTables()));\n        params.add(\"-o\");\n        params.add(getOutputDir().toString());\n        return params;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/ConfigTest25.java",
		"test_prompt": "// ConfigTest25.java\npackage net.sourceforge.schemaspy;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.DatabaseMetaData;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.logging.Level;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport net.sourceforge.schemaspy.model.InvalidConfigurationException;\nimport net.sourceforge.schemaspy.util.DbSpecificConfig;\nimport net.sourceforge.schemaspy.util.Dot;\nimport net.sourceforge.schemaspy.util.PasswordReader;\nimport net.sourceforge.schemaspy.view.DefaultSqlFormatter;\nimport net.sourceforge.schemaspy.view.SqlFormatter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Config}.\n* It contains ten unit test cases for the {@link Config#asList()} method.\n*/\nclass ConfigTest25 {"
	},
	{
		"original_code": "// DbAnalyzer.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy;\r\n\r\nimport java.sql.DatabaseMetaData;\r\nimport java.sql.ResultSet;\r\nimport java.sql.ResultSetMetaData;\r\nimport java.sql.SQLException;\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.Collections;\r\nimport java.util.Comparator;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\nimport java.util.TreeMap;\r\nimport java.util.TreeSet;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.regex.Pattern;\r\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.Table;\r\nimport net.sourceforge.schemaspy.model.TableColumn;\r\nimport net.sourceforge.schemaspy.model.TableIndex;\r\nimport net.sourceforge.schemaspy.util.Inflection;\r\n\r\npublic class DbAnalyzer {\r\n\r\n    public static List<ImpliedForeignKeyConstraint> getImpliedConstraints(Collection<Table> tables) {\r\n        List<TableColumn> columnsWithoutParents = new ArrayList<TableColumn>();\r\n        Map<TableColumn, Table> allPrimaries = new TreeMap<TableColumn, Table>(new Comparator<TableColumn>() {\r\n\r\n            public int compare(TableColumn column1, TableColumn column2) {\r\n                int rc = column1.getName().compareToIgnoreCase(column2.getName());\r\n                if (rc == 0)\r\n                    rc = column1.getType().compareToIgnoreCase(column2.getType());\r\n                if (rc == 0)\r\n                    rc = column1.getLength() - column2.getLength();\r\n                return rc;\r\n            }\r\n        });\r\n        int duplicatePrimaries = 0;\r\n        // gather all the primary key columns and columns without parents\r\n        for (Table table : tables) {\r\n            List<TableColumn> tablePrimaries = table.getPrimaryColumns();\r\n            if (tablePrimaries.size() == 1) {\r\n                // can't match up multiples...yet...\r\n                for (TableColumn primary : tablePrimaries) {\r\n                    if (primary.allowsImpliedChildren() && allPrimaries.put(primary, table) != null)\r\n                        ++duplicatePrimaries;\r\n                }\r\n            }\r\n            for (TableColumn column : table.getColumns()) {\r\n                if (!column.isForeignKey() && column.allowsImpliedParents())\r\n                    columnsWithoutParents.add(column);\r\n            }\r\n        }\r\n        // if more than half of the tables have the same primary key then\r\n        // it's most likely a database where primary key names aren't unique\r\n        // (e.g. they all have a primary key named 'ID')\r\n        if (// bizarre logic, but it does approximately what we need\r\n        duplicatePrimaries > allPrimaries.size())\r\n            return new ArrayList<ImpliedForeignKeyConstraint>();\r\n        sortColumnsByTable(columnsWithoutParents);\r\n        List<ImpliedForeignKeyConstraint> impliedConstraints = new ArrayList<ImpliedForeignKeyConstraint>();\r\n        for (TableColumn childColumn : columnsWithoutParents) {\r\n            Table primaryTable = allPrimaries.get(childColumn);\r\n            if (primaryTable != null && primaryTable != childColumn.getTable()) {\r\n                TableColumn parentColumn = primaryTable.getColumn(childColumn.getName());\r\n                // make sure the potential child->parent relationships isn't already a\r\n                // parent->child relationship\r\n                if (parentColumn.getParentConstraint(childColumn) == null) {\r\n                    // ok, we've found a potential relationship with a column matches a primary\r\n                    // key column in another table and isn't already related to that column\r\n                    impliedConstraints.add(new ImpliedForeignKeyConstraint(parentColumn, childColumn));\r\n                }\r\n            }\r\n        }\r\n        return impliedConstraints;\r\n    }\r\n\r\n    /**\r\n     * Ruby on Rails-based databases typically have no real referential integrity\r\n     * constraints.  Instead they have a somewhat unusual way of associating\r\n     * columns to primary keys.<p>\r\n     *\r\n     * Basically all tables have a primary key named <code>ID</code>.\r\n     * All tables are named plural names.\r\n     * The columns that logically reference that <code>ID</code> are the singular\r\n     * form of the table name suffixed with <code>_ID</code>.<p>\r\n     *\r\n     * A side-effect of calling this method is that the returned collection of\r\n     * constraints will be \"tied into\" the associated tables.\r\n     *\r\n     * @param tables\r\n     * @return List of {@link RailsForeignKeyConstraint}s\r\n     */\r\n    public static List<RailsForeignKeyConstraint> getRailsConstraints(Map<String, Table> tables) {\r\n        List<RailsForeignKeyConstraint> railsConstraints = new ArrayList<RailsForeignKeyConstraint>(tables.size());\r\n        // iterate thru each column in each table looking for columns that\r\n        // match Rails naming conventions\r\n        for (Table table : tables.values()) {\r\n            for (TableColumn column : table.getColumns()) {\r\n                String columnName = column.getName().toLowerCase();\r\n                if (!column.isForeignKey() && column.allowsImpliedParents() && columnName.endsWith(\"_id\")) {\r\n                    String singular = columnName.substring(0, columnName.length() - 3);\r\n                    String primaryTableName = Inflection.pluralize(singular);\r\n                    Table primaryTable = tables.get(primaryTableName);\r\n                    if (primaryTable != null) {\r\n                        TableColumn primaryColumn = primaryTable.getColumn(\"ID\");\r\n                        if (primaryColumn != null) {\r\n                            railsConstraints.add(new RailsForeignKeyConstraint(primaryColumn, column));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return railsConstraints;\r\n    }\r\n\r\n    /**\r\n     * Returns a <code>List</code> of all of the <code>ForeignKeyConstraint</code>s\r\n     * used by the specified tables.\r\n     *\r\n     * @param tables Collection\r\n     * @return List\r\n     */\r\n    public static List<ForeignKeyConstraint> getForeignKeyConstraints(Collection<Table> tables) {\r\n        List<ForeignKeyConstraint> constraints = new ArrayList<ForeignKeyConstraint>();\r\n        for (Table table : tables) {\r\n            constraints.addAll(table.getForeignKeys());\r\n        }\r\n        return constraints;\r\n    }\r\n\r\n    public static List<Table> getOrphans(Collection<Table> tables) {\r\n        List<Table> orphans = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.isOrphan(false)) {\r\n                orphans.add(table);\r\n            }\r\n        }\r\n        return sortTablesByName(orphans);\r\n    }\r\n\r\n    /**\r\n     * Return a list of <code>TableColumn</code>s that are both nullable\r\n     * and have an index that specifies that they must be unique (a rather strange combo).\r\n     */\r\n    public static List<TableColumn> getMustBeUniqueNullableColumns(Collection<Table> tables) {\r\n        List<TableColumn> uniqueNullables = new ArrayList<TableColumn>();\r\n        for (Table table : tables) {\r\n            for (TableIndex index : table.getIndexes()) {\r\n                if (index.isUniqueNullable()) {\r\n                    uniqueNullables.addAll(index.getColumns());\r\n                }\r\n            }\r\n        }\r\n        return sortColumnsByTable(uniqueNullables);\r\n    }\r\n\r\n    /**\r\n     * Return a list of <code>Table</code>s that have neither an index nor a primary key.\r\n     */\r\n    public static List<Table> getTablesWithoutIndexes(Collection<Table> tables) {\r\n        List<Table> withoutIndexes = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.getIndexes().size() == 0 && !table.isView() && !table.isLogical())\r\n                withoutIndexes.add(table);\r\n        }\r\n        return sortTablesByName(withoutIndexes);\r\n    }\r\n\r\n    public static List<Table> getTablesWithIncrementingColumnNames(Collection<Table> tables) {\r\n        List<Table> denormalizedTables = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            Map<String, Long> columnPrefixes = new HashMap<String, Long>();\r\n            for (TableColumn column : table.getColumns()) {\r\n                // search for columns that start with the same prefix\r\n                // and end in an incrementing number\r\n                String columnName = column.getName();\r\n                String numbers = null;\r\n                for (int i = columnName.length() - 1; i > 0; --i) {\r\n                    if (Character.isDigit(columnName.charAt(i))) {\r\n                        numbers = String.valueOf(columnName.charAt(i)) + (numbers == null ? \"\" : numbers);\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n                // attempt to detect where they had an existing column\r\n                // and added a \"column2\" type of column (we'll call this one \"1\")\r\n                if (numbers == null) {\r\n                    numbers = \"1\";\r\n                    columnName = columnName + numbers;\r\n                }\r\n                // see if we've already found a column with the same prefix\r\n                // that had a numeric suffix +/- 1.\r\n                String prefix = columnName.substring(0, columnName.length() - numbers.length());\r\n                long numeric = Long.parseLong(numbers);\r\n                Long existing = columnPrefixes.get(prefix);\r\n                if (existing != null && Math.abs(existing.longValue() - numeric) == 1) {\r\n                    // found one so add it to our list and stop evaluating this table\r\n                    denormalizedTables.add(table);\r\n                    break;\r\n                }\r\n                columnPrefixes.put(prefix, new Long(numeric));\r\n            }\r\n        }\r\n        return sortTablesByName(denormalizedTables);\r\n    }\r\n\r\n    public static List<Table> getTablesWithOneColumn(Collection<Table> tables) {\r\n        List<Table> singleColumnTables = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.getColumns().size() == 1)\r\n                singleColumnTables.add(table);\r\n        }\r\n        return sortTablesByName(singleColumnTables);\r\n    }\r\n\r\n    public static List<Table> sortTablesByName(List<Table> tables) {\r\n        Collections.sort(tables, new Comparator<Table>() {\r\n\r\n            public int compare(Table table1, Table table2) {\r\n                return table1.compareTo(table2);\r\n            }\r\n        });\r\n        return tables;\r\n    }\r\n\r\n    public static List<TableColumn> sortColumnsByTable(List<TableColumn> columns) {\r\n        Collections.sort(columns, new Comparator<TableColumn>() {\r\n\r\n            public int compare(TableColumn column1, TableColumn column2) {\r\n                int rc = column1.getTable().compareTo(column2.getTable());\r\n                if (rc == 0)\r\n                    rc = column1.getName().compareToIgnoreCase(column2.getName());\r\n                return rc;\r\n            }\r\n        });\r\n        return columns;\r\n    }\r\n\r\n    /**\r\n     * Returns a list of columns that have the word \"NULL\" or \"null\" as their default value\r\n     * instead of the likely candidate value null.\r\n     *\r\n     * @param tables Collection\r\n     * @return List\r\n     */\r\n    public static List<TableColumn> getDefaultNullStringColumns(Collection<Table> tables) {\r\n        List<TableColumn> defaultNullStringColumns = new ArrayList<TableColumn>();\r\n        for (Table table : tables) {\r\n            for (TableColumn column : table.getColumns()) {\r\n                Object defaultValue = column.getDefaultValue();\r\n                if (defaultValue != null && defaultValue instanceof String) {\r\n                    String defaultString = defaultValue.toString();\r\n                    if (defaultString.trim().equalsIgnoreCase(\"'null'\")) {\r\n                        defaultNullStringColumns.add(column);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return sortColumnsByTable(defaultNullStringColumns);\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of catalog names (Strings)\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getCatalogs(DatabaseMetaData meta) throws SQLException {\r\n        List<String> catalogs = new ArrayList<String>();\r\n        ResultSet rs = meta.getCatalogs();\r\n        while (rs.next()) {\r\n            catalogs.add(rs.getString(\"TABLE_CAT\"));\r\n        }\r\n        rs.close();\r\n        return catalogs;\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings)\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getSchemas(DatabaseMetaData meta) throws SQLException {\r\n        List<String> schemas = new ArrayList<String>();\r\n        ResultSet rs = meta.getSchemas();\r\n        while (rs.next()) {\r\n            schemas.add(rs.getString(\"TABLE_SCHEM\"));\r\n        }\r\n        rs.close();\r\n        return schemas;\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings) that contain tables\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getPopulatedSchemas(DatabaseMetaData meta) throws SQLException {\r\n        return getPopulatedSchemas(meta, \".*\", false);\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings) that contain tables and\r\n     * match the <code>schemaSpec</code> regular expression\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getPopulatedSchemas(DatabaseMetaData meta, String schemaSpec, boolean isCatalog) throws SQLException {\r\n        // alpha sorted\r\n        Set<String> schemas = new TreeSet<String>();\r\n        Pattern schemaRegex = Pattern.compile(schemaSpec);\r\n        Logger logger = Logger.getLogger(DbAnalyzer.class.getName());\r\n        boolean logging = logger.isLoggable(Level.FINE);\r\n        for (String schema : (isCatalog ? getCatalogs(meta) : getSchemas(meta))) {\r\n            if (schemaRegex.matcher(schema).matches()) {\r\n                ResultSet rs = null;\r\n                try {\r\n                    rs = meta.getTables(null, schema, \"%\", null);\r\n                    if (rs.next()) {\r\n                        if (logging)\r\n                            logger.fine(\"Including schema \" + schema + \": matches + \\\"\" + schemaRegex + \"\\\" and contains tables\");\r\n                        schemas.add(schema);\r\n                    } else {\r\n                        if (logging)\r\n                            logger.fine(\"Excluding schema \" + schema + \": matches \\\"\" + schemaRegex + \"\\\" but contains no tables\");\r\n                    }\r\n                } catch (SQLException ignore) {\r\n                } finally {\r\n                    if (rs != null)\r\n                        rs.close();\r\n                }\r\n            } else {\r\n                if (logging)\r\n                    logger.fine(\"Excluding schema \" + schema + \": doesn't match \\\"\" + schemaRegex + '\"');\r\n            }\r\n        }\r\n        return new ArrayList<String>(schemas);\r\n    }\r\n\r\n    /**\r\n     * For debugging/analyzing result sets\r\n     * @param rs ResultSet\r\n     * @throws SQLException\r\n     */\r\n    public static void dumpResultSetRow(ResultSet rs, String description) throws SQLException {\r\n        ResultSetMetaData meta = rs.getMetaData();\r\n        int numColumns = meta.getColumnCount();\r\n        System.out.println(numColumns + \" columns of \" + description + \":\");\r\n        for (int i = 1; i <= numColumns; ++i) {\r\n            System.out.print(meta.getColumnLabel(i));\r\n            System.out.print(\": \");\r\n            System.out.print(String.valueOf(rs.getString(i)));\r\n            System.out.print(\"\\t\");\r\n        }\r\n        System.out.println();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/DbAnalyzerTest0.java",
		"test_prompt": "// DbAnalyzerTest0.java\npackage net.sourceforge.schemaspy;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.model.TableIndex;\nimport net.sourceforge.schemaspy.util.Inflection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DbAnalyzer}.\n* It contains ten unit test cases for the {@link DbAnalyzer#getImpliedConstraints(Collection)} method.\n*/\nclass DbAnalyzerTest0 {"
	},
	{
		"original_code": "// DbAnalyzer.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy;\r\n\r\nimport java.sql.DatabaseMetaData;\r\nimport java.sql.ResultSet;\r\nimport java.sql.ResultSetMetaData;\r\nimport java.sql.SQLException;\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.Collections;\r\nimport java.util.Comparator;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\nimport java.util.TreeMap;\r\nimport java.util.TreeSet;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.regex.Pattern;\r\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.Table;\r\nimport net.sourceforge.schemaspy.model.TableColumn;\r\nimport net.sourceforge.schemaspy.model.TableIndex;\r\nimport net.sourceforge.schemaspy.util.Inflection;\r\n\r\npublic class DbAnalyzer {\r\n\r\n    public static List<ImpliedForeignKeyConstraint> getImpliedConstraints(Collection<Table> tables) {\r\n        List<TableColumn> columnsWithoutParents = new ArrayList<TableColumn>();\r\n        Map<TableColumn, Table> allPrimaries = new TreeMap<TableColumn, Table>(new Comparator<TableColumn>() {\r\n\r\n            public int compare(TableColumn column1, TableColumn column2) {\r\n                int rc = column1.getName().compareToIgnoreCase(column2.getName());\r\n                if (rc == 0)\r\n                    rc = column1.getType().compareToIgnoreCase(column2.getType());\r\n                if (rc == 0)\r\n                    rc = column1.getLength() - column2.getLength();\r\n                return rc;\r\n            }\r\n        });\r\n        int duplicatePrimaries = 0;\r\n        // gather all the primary key columns and columns without parents\r\n        for (Table table : tables) {\r\n            List<TableColumn> tablePrimaries = table.getPrimaryColumns();\r\n            if (tablePrimaries.size() == 1) {\r\n                // can't match up multiples...yet...\r\n                for (TableColumn primary : tablePrimaries) {\r\n                    if (primary.allowsImpliedChildren() && allPrimaries.put(primary, table) != null)\r\n                        ++duplicatePrimaries;\r\n                }\r\n            }\r\n            for (TableColumn column : table.getColumns()) {\r\n                if (!column.isForeignKey() && column.allowsImpliedParents())\r\n                    columnsWithoutParents.add(column);\r\n            }\r\n        }\r\n        // if more than half of the tables have the same primary key then\r\n        // it's most likely a database where primary key names aren't unique\r\n        // (e.g. they all have a primary key named 'ID')\r\n        if (// bizarre logic, but it does approximately what we need\r\n        duplicatePrimaries > allPrimaries.size())\r\n            return new ArrayList<ImpliedForeignKeyConstraint>();\r\n        sortColumnsByTable(columnsWithoutParents);\r\n        List<ImpliedForeignKeyConstraint> impliedConstraints = new ArrayList<ImpliedForeignKeyConstraint>();\r\n        for (TableColumn childColumn : columnsWithoutParents) {\r\n            Table primaryTable = allPrimaries.get(childColumn);\r\n            if (primaryTable != null && primaryTable != childColumn.getTable()) {\r\n                TableColumn parentColumn = primaryTable.getColumn(childColumn.getName());\r\n                // make sure the potential child->parent relationships isn't already a\r\n                // parent->child relationship\r\n                if (parentColumn.getParentConstraint(childColumn) == null) {\r\n                    // ok, we've found a potential relationship with a column matches a primary\r\n                    // key column in another table and isn't already related to that column\r\n                    impliedConstraints.add(new ImpliedForeignKeyConstraint(parentColumn, childColumn));\r\n                }\r\n            }\r\n        }\r\n        return impliedConstraints;\r\n    }\r\n\r\n    /**\r\n     * Ruby on Rails-based databases typically have no real referential integrity\r\n     * constraints.  Instead they have a somewhat unusual way of associating\r\n     * columns to primary keys.<p>\r\n     *\r\n     * Basically all tables have a primary key named <code>ID</code>.\r\n     * All tables are named plural names.\r\n     * The columns that logically reference that <code>ID</code> are the singular\r\n     * form of the table name suffixed with <code>_ID</code>.<p>\r\n     *\r\n     * A side-effect of calling this method is that the returned collection of\r\n     * constraints will be \"tied into\" the associated tables.\r\n     *\r\n     * @param tables\r\n     * @return List of {@link RailsForeignKeyConstraint}s\r\n     */\r\n    public static List<RailsForeignKeyConstraint> getRailsConstraints(Map<String, Table> tables) {\r\n        List<RailsForeignKeyConstraint> railsConstraints = new ArrayList<RailsForeignKeyConstraint>(tables.size());\r\n        // iterate thru each column in each table looking for columns that\r\n        // match Rails naming conventions\r\n        for (Table table : tables.values()) {\r\n            for (TableColumn column : table.getColumns()) {\r\n                String columnName = column.getName().toLowerCase();\r\n                if (!column.isForeignKey() && column.allowsImpliedParents() && columnName.endsWith(\"_id\")) {\r\n                    String singular = columnName.substring(0, columnName.length() - 3);\r\n                    String primaryTableName = Inflection.pluralize(singular);\r\n                    Table primaryTable = tables.get(primaryTableName);\r\n                    if (primaryTable != null) {\r\n                        TableColumn primaryColumn = primaryTable.getColumn(\"ID\");\r\n                        if (primaryColumn != null) {\r\n                            railsConstraints.add(new RailsForeignKeyConstraint(primaryColumn, column));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return railsConstraints;\r\n    }\r\n\r\n    /**\r\n     * Returns a <code>List</code> of all of the <code>ForeignKeyConstraint</code>s\r\n     * used by the specified tables.\r\n     *\r\n     * @param tables Collection\r\n     * @return List\r\n     */\r\n    public static List<ForeignKeyConstraint> getForeignKeyConstraints(Collection<Table> tables) {\r\n        List<ForeignKeyConstraint> constraints = new ArrayList<ForeignKeyConstraint>();\r\n        for (Table table : tables) {\r\n            constraints.addAll(table.getForeignKeys());\r\n        }\r\n        return constraints;\r\n    }\r\n\r\n    public static List<Table> getOrphans(Collection<Table> tables) {\r\n        List<Table> orphans = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.isOrphan(false)) {\r\n                orphans.add(table);\r\n            }\r\n        }\r\n        return sortTablesByName(orphans);\r\n    }\r\n\r\n    /**\r\n     * Return a list of <code>TableColumn</code>s that are both nullable\r\n     * and have an index that specifies that they must be unique (a rather strange combo).\r\n     */\r\n    public static List<TableColumn> getMustBeUniqueNullableColumns(Collection<Table> tables) {\r\n        List<TableColumn> uniqueNullables = new ArrayList<TableColumn>();\r\n        for (Table table : tables) {\r\n            for (TableIndex index : table.getIndexes()) {\r\n                if (index.isUniqueNullable()) {\r\n                    uniqueNullables.addAll(index.getColumns());\r\n                }\r\n            }\r\n        }\r\n        return sortColumnsByTable(uniqueNullables);\r\n    }\r\n\r\n    /**\r\n     * Return a list of <code>Table</code>s that have neither an index nor a primary key.\r\n     */\r\n    public static List<Table> getTablesWithoutIndexes(Collection<Table> tables) {\r\n        List<Table> withoutIndexes = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.getIndexes().size() == 0 && !table.isView() && !table.isLogical())\r\n                withoutIndexes.add(table);\r\n        }\r\n        return sortTablesByName(withoutIndexes);\r\n    }\r\n\r\n    public static List<Table> getTablesWithIncrementingColumnNames(Collection<Table> tables) {\r\n        List<Table> denormalizedTables = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            Map<String, Long> columnPrefixes = new HashMap<String, Long>();\r\n            for (TableColumn column : table.getColumns()) {\r\n                // search for columns that start with the same prefix\r\n                // and end in an incrementing number\r\n                String columnName = column.getName();\r\n                String numbers = null;\r\n                for (int i = columnName.length() - 1; i > 0; --i) {\r\n                    if (Character.isDigit(columnName.charAt(i))) {\r\n                        numbers = String.valueOf(columnName.charAt(i)) + (numbers == null ? \"\" : numbers);\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n                // attempt to detect where they had an existing column\r\n                // and added a \"column2\" type of column (we'll call this one \"1\")\r\n                if (numbers == null) {\r\n                    numbers = \"1\";\r\n                    columnName = columnName + numbers;\r\n                }\r\n                // see if we've already found a column with the same prefix\r\n                // that had a numeric suffix +/- 1.\r\n                String prefix = columnName.substring(0, columnName.length() - numbers.length());\r\n                long numeric = Long.parseLong(numbers);\r\n                Long existing = columnPrefixes.get(prefix);\r\n                if (existing != null && Math.abs(existing.longValue() - numeric) == 1) {\r\n                    // found one so add it to our list and stop evaluating this table\r\n                    denormalizedTables.add(table);\r\n                    break;\r\n                }\r\n                columnPrefixes.put(prefix, new Long(numeric));\r\n            }\r\n        }\r\n        return sortTablesByName(denormalizedTables);\r\n    }\r\n\r\n    public static List<Table> getTablesWithOneColumn(Collection<Table> tables) {\r\n        List<Table> singleColumnTables = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.getColumns().size() == 1)\r\n                singleColumnTables.add(table);\r\n        }\r\n        return sortTablesByName(singleColumnTables);\r\n    }\r\n\r\n    public static List<Table> sortTablesByName(List<Table> tables) {\r\n        Collections.sort(tables, new Comparator<Table>() {\r\n\r\n            public int compare(Table table1, Table table2) {\r\n                return table1.compareTo(table2);\r\n            }\r\n        });\r\n        return tables;\r\n    }\r\n\r\n    public static List<TableColumn> sortColumnsByTable(List<TableColumn> columns) {\r\n        Collections.sort(columns, new Comparator<TableColumn>() {\r\n\r\n            public int compare(TableColumn column1, TableColumn column2) {\r\n                int rc = column1.getTable().compareTo(column2.getTable());\r\n                if (rc == 0)\r\n                    rc = column1.getName().compareToIgnoreCase(column2.getName());\r\n                return rc;\r\n            }\r\n        });\r\n        return columns;\r\n    }\r\n\r\n    /**\r\n     * Returns a list of columns that have the word \"NULL\" or \"null\" as their default value\r\n     * instead of the likely candidate value null.\r\n     *\r\n     * @param tables Collection\r\n     * @return List\r\n     */\r\n    public static List<TableColumn> getDefaultNullStringColumns(Collection<Table> tables) {\r\n        List<TableColumn> defaultNullStringColumns = new ArrayList<TableColumn>();\r\n        for (Table table : tables) {\r\n            for (TableColumn column : table.getColumns()) {\r\n                Object defaultValue = column.getDefaultValue();\r\n                if (defaultValue != null && defaultValue instanceof String) {\r\n                    String defaultString = defaultValue.toString();\r\n                    if (defaultString.trim().equalsIgnoreCase(\"'null'\")) {\r\n                        defaultNullStringColumns.add(column);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return sortColumnsByTable(defaultNullStringColumns);\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of catalog names (Strings)\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getCatalogs(DatabaseMetaData meta) throws SQLException {\r\n        List<String> catalogs = new ArrayList<String>();\r\n        ResultSet rs = meta.getCatalogs();\r\n        while (rs.next()) {\r\n            catalogs.add(rs.getString(\"TABLE_CAT\"));\r\n        }\r\n        rs.close();\r\n        return catalogs;\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings)\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getSchemas(DatabaseMetaData meta) throws SQLException {\r\n        List<String> schemas = new ArrayList<String>();\r\n        ResultSet rs = meta.getSchemas();\r\n        while (rs.next()) {\r\n            schemas.add(rs.getString(\"TABLE_SCHEM\"));\r\n        }\r\n        rs.close();\r\n        return schemas;\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings) that contain tables\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getPopulatedSchemas(DatabaseMetaData meta) throws SQLException {\r\n        return getPopulatedSchemas(meta, \".*\", false);\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings) that contain tables and\r\n     * match the <code>schemaSpec</code> regular expression\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getPopulatedSchemas(DatabaseMetaData meta, String schemaSpec, boolean isCatalog) throws SQLException {\r\n        // alpha sorted\r\n        Set<String> schemas = new TreeSet<String>();\r\n        Pattern schemaRegex = Pattern.compile(schemaSpec);\r\n        Logger logger = Logger.getLogger(DbAnalyzer.class.getName());\r\n        boolean logging = logger.isLoggable(Level.FINE);\r\n        for (String schema : (isCatalog ? getCatalogs(meta) : getSchemas(meta))) {\r\n            if (schemaRegex.matcher(schema).matches()) {\r\n                ResultSet rs = null;\r\n                try {\r\n                    rs = meta.getTables(null, schema, \"%\", null);\r\n                    if (rs.next()) {\r\n                        if (logging)\r\n                            logger.fine(\"Including schema \" + schema + \": matches + \\\"\" + schemaRegex + \"\\\" and contains tables\");\r\n                        schemas.add(schema);\r\n                    } else {\r\n                        if (logging)\r\n                            logger.fine(\"Excluding schema \" + schema + \": matches \\\"\" + schemaRegex + \"\\\" but contains no tables\");\r\n                    }\r\n                } catch (SQLException ignore) {\r\n                } finally {\r\n                    if (rs != null)\r\n                        rs.close();\r\n                }\r\n            } else {\r\n                if (logging)\r\n                    logger.fine(\"Excluding schema \" + schema + \": doesn't match \\\"\" + schemaRegex + '\"');\r\n            }\r\n        }\r\n        return new ArrayList<String>(schemas);\r\n    }\r\n\r\n    /**\r\n     * For debugging/analyzing result sets\r\n     * @param rs ResultSet\r\n     * @throws SQLException\r\n     */\r\n    public static void dumpResultSetRow(ResultSet rs, String description) throws SQLException {\r\n        ResultSetMetaData meta = rs.getMetaData();\r\n        int numColumns = meta.getColumnCount();\r\n        System.out.println(numColumns + \" columns of \" + description + \":\");\r\n        for (int i = 1; i <= numColumns; ++i) {\r\n            System.out.print(meta.getColumnLabel(i));\r\n            System.out.print(\": \");\r\n            System.out.print(String.valueOf(rs.getString(i)));\r\n            System.out.print(\"\\t\");\r\n        }\r\n        System.out.println();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/DbAnalyzerTest1.java",
		"test_prompt": "// DbAnalyzerTest1.java\npackage net.sourceforge.schemaspy;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.model.TableIndex;\nimport net.sourceforge.schemaspy.util.Inflection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DbAnalyzer}.\n* It contains ten unit test cases for the {@link DbAnalyzer#getRailsConstraints(Map)} method.\n*/\nclass DbAnalyzerTest1 {"
	},
	{
		"original_code": "// DbAnalyzer.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy;\r\n\r\nimport java.sql.DatabaseMetaData;\r\nimport java.sql.ResultSet;\r\nimport java.sql.ResultSetMetaData;\r\nimport java.sql.SQLException;\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.Collections;\r\nimport java.util.Comparator;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\nimport java.util.TreeMap;\r\nimport java.util.TreeSet;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.regex.Pattern;\r\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.Table;\r\nimport net.sourceforge.schemaspy.model.TableColumn;\r\nimport net.sourceforge.schemaspy.model.TableIndex;\r\nimport net.sourceforge.schemaspy.util.Inflection;\r\n\r\npublic class DbAnalyzer {\r\n\r\n    public static List<ImpliedForeignKeyConstraint> getImpliedConstraints(Collection<Table> tables) {\r\n        List<TableColumn> columnsWithoutParents = new ArrayList<TableColumn>();\r\n        Map<TableColumn, Table> allPrimaries = new TreeMap<TableColumn, Table>(new Comparator<TableColumn>() {\r\n\r\n            public int compare(TableColumn column1, TableColumn column2) {\r\n                int rc = column1.getName().compareToIgnoreCase(column2.getName());\r\n                if (rc == 0)\r\n                    rc = column1.getType().compareToIgnoreCase(column2.getType());\r\n                if (rc == 0)\r\n                    rc = column1.getLength() - column2.getLength();\r\n                return rc;\r\n            }\r\n        });\r\n        int duplicatePrimaries = 0;\r\n        // gather all the primary key columns and columns without parents\r\n        for (Table table : tables) {\r\n            List<TableColumn> tablePrimaries = table.getPrimaryColumns();\r\n            if (tablePrimaries.size() == 1) {\r\n                // can't match up multiples...yet...\r\n                for (TableColumn primary : tablePrimaries) {\r\n                    if (primary.allowsImpliedChildren() && allPrimaries.put(primary, table) != null)\r\n                        ++duplicatePrimaries;\r\n                }\r\n            }\r\n            for (TableColumn column : table.getColumns()) {\r\n                if (!column.isForeignKey() && column.allowsImpliedParents())\r\n                    columnsWithoutParents.add(column);\r\n            }\r\n        }\r\n        // if more than half of the tables have the same primary key then\r\n        // it's most likely a database where primary key names aren't unique\r\n        // (e.g. they all have a primary key named 'ID')\r\n        if (// bizarre logic, but it does approximately what we need\r\n        duplicatePrimaries > allPrimaries.size())\r\n            return new ArrayList<ImpliedForeignKeyConstraint>();\r\n        sortColumnsByTable(columnsWithoutParents);\r\n        List<ImpliedForeignKeyConstraint> impliedConstraints = new ArrayList<ImpliedForeignKeyConstraint>();\r\n        for (TableColumn childColumn : columnsWithoutParents) {\r\n            Table primaryTable = allPrimaries.get(childColumn);\r\n            if (primaryTable != null && primaryTable != childColumn.getTable()) {\r\n                TableColumn parentColumn = primaryTable.getColumn(childColumn.getName());\r\n                // make sure the potential child->parent relationships isn't already a\r\n                // parent->child relationship\r\n                if (parentColumn.getParentConstraint(childColumn) == null) {\r\n                    // ok, we've found a potential relationship with a column matches a primary\r\n                    // key column in another table and isn't already related to that column\r\n                    impliedConstraints.add(new ImpliedForeignKeyConstraint(parentColumn, childColumn));\r\n                }\r\n            }\r\n        }\r\n        return impliedConstraints;\r\n    }\r\n\r\n    /**\r\n     * Ruby on Rails-based databases typically have no real referential integrity\r\n     * constraints.  Instead they have a somewhat unusual way of associating\r\n     * columns to primary keys.<p>\r\n     *\r\n     * Basically all tables have a primary key named <code>ID</code>.\r\n     * All tables are named plural names.\r\n     * The columns that logically reference that <code>ID</code> are the singular\r\n     * form of the table name suffixed with <code>_ID</code>.<p>\r\n     *\r\n     * A side-effect of calling this method is that the returned collection of\r\n     * constraints will be \"tied into\" the associated tables.\r\n     *\r\n     * @param tables\r\n     * @return List of {@link RailsForeignKeyConstraint}s\r\n     */\r\n    public static List<RailsForeignKeyConstraint> getRailsConstraints(Map<String, Table> tables) {\r\n        List<RailsForeignKeyConstraint> railsConstraints = new ArrayList<RailsForeignKeyConstraint>(tables.size());\r\n        // iterate thru each column in each table looking for columns that\r\n        // match Rails naming conventions\r\n        for (Table table : tables.values()) {\r\n            for (TableColumn column : table.getColumns()) {\r\n                String columnName = column.getName().toLowerCase();\r\n                if (!column.isForeignKey() && column.allowsImpliedParents() && columnName.endsWith(\"_id\")) {\r\n                    String singular = columnName.substring(0, columnName.length() - 3);\r\n                    String primaryTableName = Inflection.pluralize(singular);\r\n                    Table primaryTable = tables.get(primaryTableName);\r\n                    if (primaryTable != null) {\r\n                        TableColumn primaryColumn = primaryTable.getColumn(\"ID\");\r\n                        if (primaryColumn != null) {\r\n                            railsConstraints.add(new RailsForeignKeyConstraint(primaryColumn, column));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return railsConstraints;\r\n    }\r\n\r\n    /**\r\n     * Returns a <code>List</code> of all of the <code>ForeignKeyConstraint</code>s\r\n     * used by the specified tables.\r\n     *\r\n     * @param tables Collection\r\n     * @return List\r\n     */\r\n    public static List<ForeignKeyConstraint> getForeignKeyConstraints(Collection<Table> tables) {\r\n        List<ForeignKeyConstraint> constraints = new ArrayList<ForeignKeyConstraint>();\r\n        for (Table table : tables) {\r\n            constraints.addAll(table.getForeignKeys());\r\n        }\r\n        return constraints;\r\n    }\r\n\r\n    public static List<Table> getOrphans(Collection<Table> tables) {\r\n        List<Table> orphans = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.isOrphan(false)) {\r\n                orphans.add(table);\r\n            }\r\n        }\r\n        return sortTablesByName(orphans);\r\n    }\r\n\r\n    /**\r\n     * Return a list of <code>TableColumn</code>s that are both nullable\r\n     * and have an index that specifies that they must be unique (a rather strange combo).\r\n     */\r\n    public static List<TableColumn> getMustBeUniqueNullableColumns(Collection<Table> tables) {\r\n        List<TableColumn> uniqueNullables = new ArrayList<TableColumn>();\r\n        for (Table table : tables) {\r\n            for (TableIndex index : table.getIndexes()) {\r\n                if (index.isUniqueNullable()) {\r\n                    uniqueNullables.addAll(index.getColumns());\r\n                }\r\n            }\r\n        }\r\n        return sortColumnsByTable(uniqueNullables);\r\n    }\r\n\r\n    /**\r\n     * Return a list of <code>Table</code>s that have neither an index nor a primary key.\r\n     */\r\n    public static List<Table> getTablesWithoutIndexes(Collection<Table> tables) {\r\n        List<Table> withoutIndexes = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.getIndexes().size() == 0 && !table.isView() && !table.isLogical())\r\n                withoutIndexes.add(table);\r\n        }\r\n        return sortTablesByName(withoutIndexes);\r\n    }\r\n\r\n    public static List<Table> getTablesWithIncrementingColumnNames(Collection<Table> tables) {\r\n        List<Table> denormalizedTables = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            Map<String, Long> columnPrefixes = new HashMap<String, Long>();\r\n            for (TableColumn column : table.getColumns()) {\r\n                // search for columns that start with the same prefix\r\n                // and end in an incrementing number\r\n                String columnName = column.getName();\r\n                String numbers = null;\r\n                for (int i = columnName.length() - 1; i > 0; --i) {\r\n                    if (Character.isDigit(columnName.charAt(i))) {\r\n                        numbers = String.valueOf(columnName.charAt(i)) + (numbers == null ? \"\" : numbers);\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n                // attempt to detect where they had an existing column\r\n                // and added a \"column2\" type of column (we'll call this one \"1\")\r\n                if (numbers == null) {\r\n                    numbers = \"1\";\r\n                    columnName = columnName + numbers;\r\n                }\r\n                // see if we've already found a column with the same prefix\r\n                // that had a numeric suffix +/- 1.\r\n                String prefix = columnName.substring(0, columnName.length() - numbers.length());\r\n                long numeric = Long.parseLong(numbers);\r\n                Long existing = columnPrefixes.get(prefix);\r\n                if (existing != null && Math.abs(existing.longValue() - numeric) == 1) {\r\n                    // found one so add it to our list and stop evaluating this table\r\n                    denormalizedTables.add(table);\r\n                    break;\r\n                }\r\n                columnPrefixes.put(prefix, new Long(numeric));\r\n            }\r\n        }\r\n        return sortTablesByName(denormalizedTables);\r\n    }\r\n\r\n    public static List<Table> getTablesWithOneColumn(Collection<Table> tables) {\r\n        List<Table> singleColumnTables = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.getColumns().size() == 1)\r\n                singleColumnTables.add(table);\r\n        }\r\n        return sortTablesByName(singleColumnTables);\r\n    }\r\n\r\n    public static List<Table> sortTablesByName(List<Table> tables) {\r\n        Collections.sort(tables, new Comparator<Table>() {\r\n\r\n            public int compare(Table table1, Table table2) {\r\n                return table1.compareTo(table2);\r\n            }\r\n        });\r\n        return tables;\r\n    }\r\n\r\n    public static List<TableColumn> sortColumnsByTable(List<TableColumn> columns) {\r\n        Collections.sort(columns, new Comparator<TableColumn>() {\r\n\r\n            public int compare(TableColumn column1, TableColumn column2) {\r\n                int rc = column1.getTable().compareTo(column2.getTable());\r\n                if (rc == 0)\r\n                    rc = column1.getName().compareToIgnoreCase(column2.getName());\r\n                return rc;\r\n            }\r\n        });\r\n        return columns;\r\n    }\r\n\r\n    /**\r\n     * Returns a list of columns that have the word \"NULL\" or \"null\" as their default value\r\n     * instead of the likely candidate value null.\r\n     *\r\n     * @param tables Collection\r\n     * @return List\r\n     */\r\n    public static List<TableColumn> getDefaultNullStringColumns(Collection<Table> tables) {\r\n        List<TableColumn> defaultNullStringColumns = new ArrayList<TableColumn>();\r\n        for (Table table : tables) {\r\n            for (TableColumn column : table.getColumns()) {\r\n                Object defaultValue = column.getDefaultValue();\r\n                if (defaultValue != null && defaultValue instanceof String) {\r\n                    String defaultString = defaultValue.toString();\r\n                    if (defaultString.trim().equalsIgnoreCase(\"'null'\")) {\r\n                        defaultNullStringColumns.add(column);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return sortColumnsByTable(defaultNullStringColumns);\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of catalog names (Strings)\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getCatalogs(DatabaseMetaData meta) throws SQLException {\r\n        List<String> catalogs = new ArrayList<String>();\r\n        ResultSet rs = meta.getCatalogs();\r\n        while (rs.next()) {\r\n            catalogs.add(rs.getString(\"TABLE_CAT\"));\r\n        }\r\n        rs.close();\r\n        return catalogs;\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings)\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getSchemas(DatabaseMetaData meta) throws SQLException {\r\n        List<String> schemas = new ArrayList<String>();\r\n        ResultSet rs = meta.getSchemas();\r\n        while (rs.next()) {\r\n            schemas.add(rs.getString(\"TABLE_SCHEM\"));\r\n        }\r\n        rs.close();\r\n        return schemas;\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings) that contain tables\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getPopulatedSchemas(DatabaseMetaData meta) throws SQLException {\r\n        return getPopulatedSchemas(meta, \".*\", false);\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings) that contain tables and\r\n     * match the <code>schemaSpec</code> regular expression\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getPopulatedSchemas(DatabaseMetaData meta, String schemaSpec, boolean isCatalog) throws SQLException {\r\n        // alpha sorted\r\n        Set<String> schemas = new TreeSet<String>();\r\n        Pattern schemaRegex = Pattern.compile(schemaSpec);\r\n        Logger logger = Logger.getLogger(DbAnalyzer.class.getName());\r\n        boolean logging = logger.isLoggable(Level.FINE);\r\n        for (String schema : (isCatalog ? getCatalogs(meta) : getSchemas(meta))) {\r\n            if (schemaRegex.matcher(schema).matches()) {\r\n                ResultSet rs = null;\r\n                try {\r\n                    rs = meta.getTables(null, schema, \"%\", null);\r\n                    if (rs.next()) {\r\n                        if (logging)\r\n                            logger.fine(\"Including schema \" + schema + \": matches + \\\"\" + schemaRegex + \"\\\" and contains tables\");\r\n                        schemas.add(schema);\r\n                    } else {\r\n                        if (logging)\r\n                            logger.fine(\"Excluding schema \" + schema + \": matches \\\"\" + schemaRegex + \"\\\" but contains no tables\");\r\n                    }\r\n                } catch (SQLException ignore) {\r\n                } finally {\r\n                    if (rs != null)\r\n                        rs.close();\r\n                }\r\n            } else {\r\n                if (logging)\r\n                    logger.fine(\"Excluding schema \" + schema + \": doesn't match \\\"\" + schemaRegex + '\"');\r\n            }\r\n        }\r\n        return new ArrayList<String>(schemas);\r\n    }\r\n\r\n    /**\r\n     * For debugging/analyzing result sets\r\n     * @param rs ResultSet\r\n     * @throws SQLException\r\n     */\r\n    public static void dumpResultSetRow(ResultSet rs, String description) throws SQLException {\r\n        ResultSetMetaData meta = rs.getMetaData();\r\n        int numColumns = meta.getColumnCount();\r\n        System.out.println(numColumns + \" columns of \" + description + \":\");\r\n        for (int i = 1; i <= numColumns; ++i) {\r\n            System.out.print(meta.getColumnLabel(i));\r\n            System.out.print(\": \");\r\n            System.out.print(String.valueOf(rs.getString(i)));\r\n            System.out.print(\"\\t\");\r\n        }\r\n        System.out.println();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/DbAnalyzerTest2.java",
		"test_prompt": "// DbAnalyzerTest2.java\npackage net.sourceforge.schemaspy;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.model.TableIndex;\nimport net.sourceforge.schemaspy.util.Inflection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DbAnalyzer}.\n* It contains ten unit test cases for the {@link DbAnalyzer#getForeignKeyConstraints(Collection)} method.\n*/\nclass DbAnalyzerTest2 {"
	},
	{
		"original_code": "// DbAnalyzer.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy;\r\n\r\nimport java.sql.DatabaseMetaData;\r\nimport java.sql.ResultSet;\r\nimport java.sql.ResultSetMetaData;\r\nimport java.sql.SQLException;\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.Collections;\r\nimport java.util.Comparator;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\nimport java.util.TreeMap;\r\nimport java.util.TreeSet;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.regex.Pattern;\r\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.Table;\r\nimport net.sourceforge.schemaspy.model.TableColumn;\r\nimport net.sourceforge.schemaspy.model.TableIndex;\r\nimport net.sourceforge.schemaspy.util.Inflection;\r\n\r\npublic class DbAnalyzer {\r\n\r\n    public static List<ImpliedForeignKeyConstraint> getImpliedConstraints(Collection<Table> tables) {\r\n        List<TableColumn> columnsWithoutParents = new ArrayList<TableColumn>();\r\n        Map<TableColumn, Table> allPrimaries = new TreeMap<TableColumn, Table>(new Comparator<TableColumn>() {\r\n\r\n            public int compare(TableColumn column1, TableColumn column2) {\r\n                int rc = column1.getName().compareToIgnoreCase(column2.getName());\r\n                if (rc == 0)\r\n                    rc = column1.getType().compareToIgnoreCase(column2.getType());\r\n                if (rc == 0)\r\n                    rc = column1.getLength() - column2.getLength();\r\n                return rc;\r\n            }\r\n        });\r\n        int duplicatePrimaries = 0;\r\n        // gather all the primary key columns and columns without parents\r\n        for (Table table : tables) {\r\n            List<TableColumn> tablePrimaries = table.getPrimaryColumns();\r\n            if (tablePrimaries.size() == 1) {\r\n                // can't match up multiples...yet...\r\n                for (TableColumn primary : tablePrimaries) {\r\n                    if (primary.allowsImpliedChildren() && allPrimaries.put(primary, table) != null)\r\n                        ++duplicatePrimaries;\r\n                }\r\n            }\r\n            for (TableColumn column : table.getColumns()) {\r\n                if (!column.isForeignKey() && column.allowsImpliedParents())\r\n                    columnsWithoutParents.add(column);\r\n            }\r\n        }\r\n        // if more than half of the tables have the same primary key then\r\n        // it's most likely a database where primary key names aren't unique\r\n        // (e.g. they all have a primary key named 'ID')\r\n        if (// bizarre logic, but it does approximately what we need\r\n        duplicatePrimaries > allPrimaries.size())\r\n            return new ArrayList<ImpliedForeignKeyConstraint>();\r\n        sortColumnsByTable(columnsWithoutParents);\r\n        List<ImpliedForeignKeyConstraint> impliedConstraints = new ArrayList<ImpliedForeignKeyConstraint>();\r\n        for (TableColumn childColumn : columnsWithoutParents) {\r\n            Table primaryTable = allPrimaries.get(childColumn);\r\n            if (primaryTable != null && primaryTable != childColumn.getTable()) {\r\n                TableColumn parentColumn = primaryTable.getColumn(childColumn.getName());\r\n                // make sure the potential child->parent relationships isn't already a\r\n                // parent->child relationship\r\n                if (parentColumn.getParentConstraint(childColumn) == null) {\r\n                    // ok, we've found a potential relationship with a column matches a primary\r\n                    // key column in another table and isn't already related to that column\r\n                    impliedConstraints.add(new ImpliedForeignKeyConstraint(parentColumn, childColumn));\r\n                }\r\n            }\r\n        }\r\n        return impliedConstraints;\r\n    }\r\n\r\n    /**\r\n     * Ruby on Rails-based databases typically have no real referential integrity\r\n     * constraints.  Instead they have a somewhat unusual way of associating\r\n     * columns to primary keys.<p>\r\n     *\r\n     * Basically all tables have a primary key named <code>ID</code>.\r\n     * All tables are named plural names.\r\n     * The columns that logically reference that <code>ID</code> are the singular\r\n     * form of the table name suffixed with <code>_ID</code>.<p>\r\n     *\r\n     * A side-effect of calling this method is that the returned collection of\r\n     * constraints will be \"tied into\" the associated tables.\r\n     *\r\n     * @param tables\r\n     * @return List of {@link RailsForeignKeyConstraint}s\r\n     */\r\n    public static List<RailsForeignKeyConstraint> getRailsConstraints(Map<String, Table> tables) {\r\n        List<RailsForeignKeyConstraint> railsConstraints = new ArrayList<RailsForeignKeyConstraint>(tables.size());\r\n        // iterate thru each column in each table looking for columns that\r\n        // match Rails naming conventions\r\n        for (Table table : tables.values()) {\r\n            for (TableColumn column : table.getColumns()) {\r\n                String columnName = column.getName().toLowerCase();\r\n                if (!column.isForeignKey() && column.allowsImpliedParents() && columnName.endsWith(\"_id\")) {\r\n                    String singular = columnName.substring(0, columnName.length() - 3);\r\n                    String primaryTableName = Inflection.pluralize(singular);\r\n                    Table primaryTable = tables.get(primaryTableName);\r\n                    if (primaryTable != null) {\r\n                        TableColumn primaryColumn = primaryTable.getColumn(\"ID\");\r\n                        if (primaryColumn != null) {\r\n                            railsConstraints.add(new RailsForeignKeyConstraint(primaryColumn, column));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return railsConstraints;\r\n    }\r\n\r\n    /**\r\n     * Returns a <code>List</code> of all of the <code>ForeignKeyConstraint</code>s\r\n     * used by the specified tables.\r\n     *\r\n     * @param tables Collection\r\n     * @return List\r\n     */\r\n    public static List<ForeignKeyConstraint> getForeignKeyConstraints(Collection<Table> tables) {\r\n        List<ForeignKeyConstraint> constraints = new ArrayList<ForeignKeyConstraint>();\r\n        for (Table table : tables) {\r\n            constraints.addAll(table.getForeignKeys());\r\n        }\r\n        return constraints;\r\n    }\r\n\r\n    public static List<Table> getOrphans(Collection<Table> tables) {\r\n        List<Table> orphans = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.isOrphan(false)) {\r\n                orphans.add(table);\r\n            }\r\n        }\r\n        return sortTablesByName(orphans);\r\n    }\r\n\r\n    /**\r\n     * Return a list of <code>TableColumn</code>s that are both nullable\r\n     * and have an index that specifies that they must be unique (a rather strange combo).\r\n     */\r\n    public static List<TableColumn> getMustBeUniqueNullableColumns(Collection<Table> tables) {\r\n        List<TableColumn> uniqueNullables = new ArrayList<TableColumn>();\r\n        for (Table table : tables) {\r\n            for (TableIndex index : table.getIndexes()) {\r\n                if (index.isUniqueNullable()) {\r\n                    uniqueNullables.addAll(index.getColumns());\r\n                }\r\n            }\r\n        }\r\n        return sortColumnsByTable(uniqueNullables);\r\n    }\r\n\r\n    /**\r\n     * Return a list of <code>Table</code>s that have neither an index nor a primary key.\r\n     */\r\n    public static List<Table> getTablesWithoutIndexes(Collection<Table> tables) {\r\n        List<Table> withoutIndexes = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.getIndexes().size() == 0 && !table.isView() && !table.isLogical())\r\n                withoutIndexes.add(table);\r\n        }\r\n        return sortTablesByName(withoutIndexes);\r\n    }\r\n\r\n    public static List<Table> getTablesWithIncrementingColumnNames(Collection<Table> tables) {\r\n        List<Table> denormalizedTables = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            Map<String, Long> columnPrefixes = new HashMap<String, Long>();\r\n            for (TableColumn column : table.getColumns()) {\r\n                // search for columns that start with the same prefix\r\n                // and end in an incrementing number\r\n                String columnName = column.getName();\r\n                String numbers = null;\r\n                for (int i = columnName.length() - 1; i > 0; --i) {\r\n                    if (Character.isDigit(columnName.charAt(i))) {\r\n                        numbers = String.valueOf(columnName.charAt(i)) + (numbers == null ? \"\" : numbers);\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n                // attempt to detect where they had an existing column\r\n                // and added a \"column2\" type of column (we'll call this one \"1\")\r\n                if (numbers == null) {\r\n                    numbers = \"1\";\r\n                    columnName = columnName + numbers;\r\n                }\r\n                // see if we've already found a column with the same prefix\r\n                // that had a numeric suffix +/- 1.\r\n                String prefix = columnName.substring(0, columnName.length() - numbers.length());\r\n                long numeric = Long.parseLong(numbers);\r\n                Long existing = columnPrefixes.get(prefix);\r\n                if (existing != null && Math.abs(existing.longValue() - numeric) == 1) {\r\n                    // found one so add it to our list and stop evaluating this table\r\n                    denormalizedTables.add(table);\r\n                    break;\r\n                }\r\n                columnPrefixes.put(prefix, new Long(numeric));\r\n            }\r\n        }\r\n        return sortTablesByName(denormalizedTables);\r\n    }\r\n\r\n    public static List<Table> getTablesWithOneColumn(Collection<Table> tables) {\r\n        List<Table> singleColumnTables = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.getColumns().size() == 1)\r\n                singleColumnTables.add(table);\r\n        }\r\n        return sortTablesByName(singleColumnTables);\r\n    }\r\n\r\n    public static List<Table> sortTablesByName(List<Table> tables) {\r\n        Collections.sort(tables, new Comparator<Table>() {\r\n\r\n            public int compare(Table table1, Table table2) {\r\n                return table1.compareTo(table2);\r\n            }\r\n        });\r\n        return tables;\r\n    }\r\n\r\n    public static List<TableColumn> sortColumnsByTable(List<TableColumn> columns) {\r\n        Collections.sort(columns, new Comparator<TableColumn>() {\r\n\r\n            public int compare(TableColumn column1, TableColumn column2) {\r\n                int rc = column1.getTable().compareTo(column2.getTable());\r\n                if (rc == 0)\r\n                    rc = column1.getName().compareToIgnoreCase(column2.getName());\r\n                return rc;\r\n            }\r\n        });\r\n        return columns;\r\n    }\r\n\r\n    /**\r\n     * Returns a list of columns that have the word \"NULL\" or \"null\" as their default value\r\n     * instead of the likely candidate value null.\r\n     *\r\n     * @param tables Collection\r\n     * @return List\r\n     */\r\n    public static List<TableColumn> getDefaultNullStringColumns(Collection<Table> tables) {\r\n        List<TableColumn> defaultNullStringColumns = new ArrayList<TableColumn>();\r\n        for (Table table : tables) {\r\n            for (TableColumn column : table.getColumns()) {\r\n                Object defaultValue = column.getDefaultValue();\r\n                if (defaultValue != null && defaultValue instanceof String) {\r\n                    String defaultString = defaultValue.toString();\r\n                    if (defaultString.trim().equalsIgnoreCase(\"'null'\")) {\r\n                        defaultNullStringColumns.add(column);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return sortColumnsByTable(defaultNullStringColumns);\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of catalog names (Strings)\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getCatalogs(DatabaseMetaData meta) throws SQLException {\r\n        List<String> catalogs = new ArrayList<String>();\r\n        ResultSet rs = meta.getCatalogs();\r\n        while (rs.next()) {\r\n            catalogs.add(rs.getString(\"TABLE_CAT\"));\r\n        }\r\n        rs.close();\r\n        return catalogs;\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings)\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getSchemas(DatabaseMetaData meta) throws SQLException {\r\n        List<String> schemas = new ArrayList<String>();\r\n        ResultSet rs = meta.getSchemas();\r\n        while (rs.next()) {\r\n            schemas.add(rs.getString(\"TABLE_SCHEM\"));\r\n        }\r\n        rs.close();\r\n        return schemas;\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings) that contain tables\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getPopulatedSchemas(DatabaseMetaData meta) throws SQLException {\r\n        return getPopulatedSchemas(meta, \".*\", false);\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings) that contain tables and\r\n     * match the <code>schemaSpec</code> regular expression\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getPopulatedSchemas(DatabaseMetaData meta, String schemaSpec, boolean isCatalog) throws SQLException {\r\n        // alpha sorted\r\n        Set<String> schemas = new TreeSet<String>();\r\n        Pattern schemaRegex = Pattern.compile(schemaSpec);\r\n        Logger logger = Logger.getLogger(DbAnalyzer.class.getName());\r\n        boolean logging = logger.isLoggable(Level.FINE);\r\n        for (String schema : (isCatalog ? getCatalogs(meta) : getSchemas(meta))) {\r\n            if (schemaRegex.matcher(schema).matches()) {\r\n                ResultSet rs = null;\r\n                try {\r\n                    rs = meta.getTables(null, schema, \"%\", null);\r\n                    if (rs.next()) {\r\n                        if (logging)\r\n                            logger.fine(\"Including schema \" + schema + \": matches + \\\"\" + schemaRegex + \"\\\" and contains tables\");\r\n                        schemas.add(schema);\r\n                    } else {\r\n                        if (logging)\r\n                            logger.fine(\"Excluding schema \" + schema + \": matches \\\"\" + schemaRegex + \"\\\" but contains no tables\");\r\n                    }\r\n                } catch (SQLException ignore) {\r\n                } finally {\r\n                    if (rs != null)\r\n                        rs.close();\r\n                }\r\n            } else {\r\n                if (logging)\r\n                    logger.fine(\"Excluding schema \" + schema + \": doesn't match \\\"\" + schemaRegex + '\"');\r\n            }\r\n        }\r\n        return new ArrayList<String>(schemas);\r\n    }\r\n\r\n    /**\r\n     * For debugging/analyzing result sets\r\n     * @param rs ResultSet\r\n     * @throws SQLException\r\n     */\r\n    public static void dumpResultSetRow(ResultSet rs, String description) throws SQLException {\r\n        ResultSetMetaData meta = rs.getMetaData();\r\n        int numColumns = meta.getColumnCount();\r\n        System.out.println(numColumns + \" columns of \" + description + \":\");\r\n        for (int i = 1; i <= numColumns; ++i) {\r\n            System.out.print(meta.getColumnLabel(i));\r\n            System.out.print(\": \");\r\n            System.out.print(String.valueOf(rs.getString(i)));\r\n            System.out.print(\"\\t\");\r\n        }\r\n        System.out.println();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/DbAnalyzerTest3.java",
		"test_prompt": "// DbAnalyzerTest3.java\npackage net.sourceforge.schemaspy;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.model.TableIndex;\nimport net.sourceforge.schemaspy.util.Inflection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DbAnalyzer}.\n* It contains ten unit test cases for the {@link DbAnalyzer#getOrphans(Collection)} method.\n*/\nclass DbAnalyzerTest3 {"
	},
	{
		"original_code": "// DbAnalyzer.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy;\r\n\r\nimport java.sql.DatabaseMetaData;\r\nimport java.sql.ResultSet;\r\nimport java.sql.ResultSetMetaData;\r\nimport java.sql.SQLException;\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.Collections;\r\nimport java.util.Comparator;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\nimport java.util.TreeMap;\r\nimport java.util.TreeSet;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.regex.Pattern;\r\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.Table;\r\nimport net.sourceforge.schemaspy.model.TableColumn;\r\nimport net.sourceforge.schemaspy.model.TableIndex;\r\nimport net.sourceforge.schemaspy.util.Inflection;\r\n\r\npublic class DbAnalyzer {\r\n\r\n    public static List<ImpliedForeignKeyConstraint> getImpliedConstraints(Collection<Table> tables) {\r\n        List<TableColumn> columnsWithoutParents = new ArrayList<TableColumn>();\r\n        Map<TableColumn, Table> allPrimaries = new TreeMap<TableColumn, Table>(new Comparator<TableColumn>() {\r\n\r\n            public int compare(TableColumn column1, TableColumn column2) {\r\n                int rc = column1.getName().compareToIgnoreCase(column2.getName());\r\n                if (rc == 0)\r\n                    rc = column1.getType().compareToIgnoreCase(column2.getType());\r\n                if (rc == 0)\r\n                    rc = column1.getLength() - column2.getLength();\r\n                return rc;\r\n            }\r\n        });\r\n        int duplicatePrimaries = 0;\r\n        // gather all the primary key columns and columns without parents\r\n        for (Table table : tables) {\r\n            List<TableColumn> tablePrimaries = table.getPrimaryColumns();\r\n            if (tablePrimaries.size() == 1) {\r\n                // can't match up multiples...yet...\r\n                for (TableColumn primary : tablePrimaries) {\r\n                    if (primary.allowsImpliedChildren() && allPrimaries.put(primary, table) != null)\r\n                        ++duplicatePrimaries;\r\n                }\r\n            }\r\n            for (TableColumn column : table.getColumns()) {\r\n                if (!column.isForeignKey() && column.allowsImpliedParents())\r\n                    columnsWithoutParents.add(column);\r\n            }\r\n        }\r\n        // if more than half of the tables have the same primary key then\r\n        // it's most likely a database where primary key names aren't unique\r\n        // (e.g. they all have a primary key named 'ID')\r\n        if (// bizarre logic, but it does approximately what we need\r\n        duplicatePrimaries > allPrimaries.size())\r\n            return new ArrayList<ImpliedForeignKeyConstraint>();\r\n        sortColumnsByTable(columnsWithoutParents);\r\n        List<ImpliedForeignKeyConstraint> impliedConstraints = new ArrayList<ImpliedForeignKeyConstraint>();\r\n        for (TableColumn childColumn : columnsWithoutParents) {\r\n            Table primaryTable = allPrimaries.get(childColumn);\r\n            if (primaryTable != null && primaryTable != childColumn.getTable()) {\r\n                TableColumn parentColumn = primaryTable.getColumn(childColumn.getName());\r\n                // make sure the potential child->parent relationships isn't already a\r\n                // parent->child relationship\r\n                if (parentColumn.getParentConstraint(childColumn) == null) {\r\n                    // ok, we've found a potential relationship with a column matches a primary\r\n                    // key column in another table and isn't already related to that column\r\n                    impliedConstraints.add(new ImpliedForeignKeyConstraint(parentColumn, childColumn));\r\n                }\r\n            }\r\n        }\r\n        return impliedConstraints;\r\n    }\r\n\r\n    /**\r\n     * Ruby on Rails-based databases typically have no real referential integrity\r\n     * constraints.  Instead they have a somewhat unusual way of associating\r\n     * columns to primary keys.<p>\r\n     *\r\n     * Basically all tables have a primary key named <code>ID</code>.\r\n     * All tables are named plural names.\r\n     * The columns that logically reference that <code>ID</code> are the singular\r\n     * form of the table name suffixed with <code>_ID</code>.<p>\r\n     *\r\n     * A side-effect of calling this method is that the returned collection of\r\n     * constraints will be \"tied into\" the associated tables.\r\n     *\r\n     * @param tables\r\n     * @return List of {@link RailsForeignKeyConstraint}s\r\n     */\r\n    public static List<RailsForeignKeyConstraint> getRailsConstraints(Map<String, Table> tables) {\r\n        List<RailsForeignKeyConstraint> railsConstraints = new ArrayList<RailsForeignKeyConstraint>(tables.size());\r\n        // iterate thru each column in each table looking for columns that\r\n        // match Rails naming conventions\r\n        for (Table table : tables.values()) {\r\n            for (TableColumn column : table.getColumns()) {\r\n                String columnName = column.getName().toLowerCase();\r\n                if (!column.isForeignKey() && column.allowsImpliedParents() && columnName.endsWith(\"_id\")) {\r\n                    String singular = columnName.substring(0, columnName.length() - 3);\r\n                    String primaryTableName = Inflection.pluralize(singular);\r\n                    Table primaryTable = tables.get(primaryTableName);\r\n                    if (primaryTable != null) {\r\n                        TableColumn primaryColumn = primaryTable.getColumn(\"ID\");\r\n                        if (primaryColumn != null) {\r\n                            railsConstraints.add(new RailsForeignKeyConstraint(primaryColumn, column));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return railsConstraints;\r\n    }\r\n\r\n    /**\r\n     * Returns a <code>List</code> of all of the <code>ForeignKeyConstraint</code>s\r\n     * used by the specified tables.\r\n     *\r\n     * @param tables Collection\r\n     * @return List\r\n     */\r\n    public static List<ForeignKeyConstraint> getForeignKeyConstraints(Collection<Table> tables) {\r\n        List<ForeignKeyConstraint> constraints = new ArrayList<ForeignKeyConstraint>();\r\n        for (Table table : tables) {\r\n            constraints.addAll(table.getForeignKeys());\r\n        }\r\n        return constraints;\r\n    }\r\n\r\n    public static List<Table> getOrphans(Collection<Table> tables) {\r\n        List<Table> orphans = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.isOrphan(false)) {\r\n                orphans.add(table);\r\n            }\r\n        }\r\n        return sortTablesByName(orphans);\r\n    }\r\n\r\n    /**\r\n     * Return a list of <code>TableColumn</code>s that are both nullable\r\n     * and have an index that specifies that they must be unique (a rather strange combo).\r\n     */\r\n    public static List<TableColumn> getMustBeUniqueNullableColumns(Collection<Table> tables) {\r\n        List<TableColumn> uniqueNullables = new ArrayList<TableColumn>();\r\n        for (Table table : tables) {\r\n            for (TableIndex index : table.getIndexes()) {\r\n                if (index.isUniqueNullable()) {\r\n                    uniqueNullables.addAll(index.getColumns());\r\n                }\r\n            }\r\n        }\r\n        return sortColumnsByTable(uniqueNullables);\r\n    }\r\n\r\n    /**\r\n     * Return a list of <code>Table</code>s that have neither an index nor a primary key.\r\n     */\r\n    public static List<Table> getTablesWithoutIndexes(Collection<Table> tables) {\r\n        List<Table> withoutIndexes = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.getIndexes().size() == 0 && !table.isView() && !table.isLogical())\r\n                withoutIndexes.add(table);\r\n        }\r\n        return sortTablesByName(withoutIndexes);\r\n    }\r\n\r\n    public static List<Table> getTablesWithIncrementingColumnNames(Collection<Table> tables) {\r\n        List<Table> denormalizedTables = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            Map<String, Long> columnPrefixes = new HashMap<String, Long>();\r\n            for (TableColumn column : table.getColumns()) {\r\n                // search for columns that start with the same prefix\r\n                // and end in an incrementing number\r\n                String columnName = column.getName();\r\n                String numbers = null;\r\n                for (int i = columnName.length() - 1; i > 0; --i) {\r\n                    if (Character.isDigit(columnName.charAt(i))) {\r\n                        numbers = String.valueOf(columnName.charAt(i)) + (numbers == null ? \"\" : numbers);\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n                // attempt to detect where they had an existing column\r\n                // and added a \"column2\" type of column (we'll call this one \"1\")\r\n                if (numbers == null) {\r\n                    numbers = \"1\";\r\n                    columnName = columnName + numbers;\r\n                }\r\n                // see if we've already found a column with the same prefix\r\n                // that had a numeric suffix +/- 1.\r\n                String prefix = columnName.substring(0, columnName.length() - numbers.length());\r\n                long numeric = Long.parseLong(numbers);\r\n                Long existing = columnPrefixes.get(prefix);\r\n                if (existing != null && Math.abs(existing.longValue() - numeric) == 1) {\r\n                    // found one so add it to our list and stop evaluating this table\r\n                    denormalizedTables.add(table);\r\n                    break;\r\n                }\r\n                columnPrefixes.put(prefix, new Long(numeric));\r\n            }\r\n        }\r\n        return sortTablesByName(denormalizedTables);\r\n    }\r\n\r\n    public static List<Table> getTablesWithOneColumn(Collection<Table> tables) {\r\n        List<Table> singleColumnTables = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.getColumns().size() == 1)\r\n                singleColumnTables.add(table);\r\n        }\r\n        return sortTablesByName(singleColumnTables);\r\n    }\r\n\r\n    public static List<Table> sortTablesByName(List<Table> tables) {\r\n        Collections.sort(tables, new Comparator<Table>() {\r\n\r\n            public int compare(Table table1, Table table2) {\r\n                return table1.compareTo(table2);\r\n            }\r\n        });\r\n        return tables;\r\n    }\r\n\r\n    public static List<TableColumn> sortColumnsByTable(List<TableColumn> columns) {\r\n        Collections.sort(columns, new Comparator<TableColumn>() {\r\n\r\n            public int compare(TableColumn column1, TableColumn column2) {\r\n                int rc = column1.getTable().compareTo(column2.getTable());\r\n                if (rc == 0)\r\n                    rc = column1.getName().compareToIgnoreCase(column2.getName());\r\n                return rc;\r\n            }\r\n        });\r\n        return columns;\r\n    }\r\n\r\n    /**\r\n     * Returns a list of columns that have the word \"NULL\" or \"null\" as their default value\r\n     * instead of the likely candidate value null.\r\n     *\r\n     * @param tables Collection\r\n     * @return List\r\n     */\r\n    public static List<TableColumn> getDefaultNullStringColumns(Collection<Table> tables) {\r\n        List<TableColumn> defaultNullStringColumns = new ArrayList<TableColumn>();\r\n        for (Table table : tables) {\r\n            for (TableColumn column : table.getColumns()) {\r\n                Object defaultValue = column.getDefaultValue();\r\n                if (defaultValue != null && defaultValue instanceof String) {\r\n                    String defaultString = defaultValue.toString();\r\n                    if (defaultString.trim().equalsIgnoreCase(\"'null'\")) {\r\n                        defaultNullStringColumns.add(column);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return sortColumnsByTable(defaultNullStringColumns);\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of catalog names (Strings)\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getCatalogs(DatabaseMetaData meta) throws SQLException {\r\n        List<String> catalogs = new ArrayList<String>();\r\n        ResultSet rs = meta.getCatalogs();\r\n        while (rs.next()) {\r\n            catalogs.add(rs.getString(\"TABLE_CAT\"));\r\n        }\r\n        rs.close();\r\n        return catalogs;\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings)\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getSchemas(DatabaseMetaData meta) throws SQLException {\r\n        List<String> schemas = new ArrayList<String>();\r\n        ResultSet rs = meta.getSchemas();\r\n        while (rs.next()) {\r\n            schemas.add(rs.getString(\"TABLE_SCHEM\"));\r\n        }\r\n        rs.close();\r\n        return schemas;\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings) that contain tables\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getPopulatedSchemas(DatabaseMetaData meta) throws SQLException {\r\n        return getPopulatedSchemas(meta, \".*\", false);\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings) that contain tables and\r\n     * match the <code>schemaSpec</code> regular expression\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getPopulatedSchemas(DatabaseMetaData meta, String schemaSpec, boolean isCatalog) throws SQLException {\r\n        // alpha sorted\r\n        Set<String> schemas = new TreeSet<String>();\r\n        Pattern schemaRegex = Pattern.compile(schemaSpec);\r\n        Logger logger = Logger.getLogger(DbAnalyzer.class.getName());\r\n        boolean logging = logger.isLoggable(Level.FINE);\r\n        for (String schema : (isCatalog ? getCatalogs(meta) : getSchemas(meta))) {\r\n            if (schemaRegex.matcher(schema).matches()) {\r\n                ResultSet rs = null;\r\n                try {\r\n                    rs = meta.getTables(null, schema, \"%\", null);\r\n                    if (rs.next()) {\r\n                        if (logging)\r\n                            logger.fine(\"Including schema \" + schema + \": matches + \\\"\" + schemaRegex + \"\\\" and contains tables\");\r\n                        schemas.add(schema);\r\n                    } else {\r\n                        if (logging)\r\n                            logger.fine(\"Excluding schema \" + schema + \": matches \\\"\" + schemaRegex + \"\\\" but contains no tables\");\r\n                    }\r\n                } catch (SQLException ignore) {\r\n                } finally {\r\n                    if (rs != null)\r\n                        rs.close();\r\n                }\r\n            } else {\r\n                if (logging)\r\n                    logger.fine(\"Excluding schema \" + schema + \": doesn't match \\\"\" + schemaRegex + '\"');\r\n            }\r\n        }\r\n        return new ArrayList<String>(schemas);\r\n    }\r\n\r\n    /**\r\n     * For debugging/analyzing result sets\r\n     * @param rs ResultSet\r\n     * @throws SQLException\r\n     */\r\n    public static void dumpResultSetRow(ResultSet rs, String description) throws SQLException {\r\n        ResultSetMetaData meta = rs.getMetaData();\r\n        int numColumns = meta.getColumnCount();\r\n        System.out.println(numColumns + \" columns of \" + description + \":\");\r\n        for (int i = 1; i <= numColumns; ++i) {\r\n            System.out.print(meta.getColumnLabel(i));\r\n            System.out.print(\": \");\r\n            System.out.print(String.valueOf(rs.getString(i)));\r\n            System.out.print(\"\\t\");\r\n        }\r\n        System.out.println();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/DbAnalyzerTest4.java",
		"test_prompt": "// DbAnalyzerTest4.java\npackage net.sourceforge.schemaspy;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.model.TableIndex;\nimport net.sourceforge.schemaspy.util.Inflection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DbAnalyzer}.\n* It contains ten unit test cases for the {@link DbAnalyzer#getMustBeUniqueNullableColumns(Collection)} method.\n*/\nclass DbAnalyzerTest4 {"
	},
	{
		"original_code": "// DbAnalyzer.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy;\r\n\r\nimport java.sql.DatabaseMetaData;\r\nimport java.sql.ResultSet;\r\nimport java.sql.ResultSetMetaData;\r\nimport java.sql.SQLException;\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.Collections;\r\nimport java.util.Comparator;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\nimport java.util.TreeMap;\r\nimport java.util.TreeSet;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.regex.Pattern;\r\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.Table;\r\nimport net.sourceforge.schemaspy.model.TableColumn;\r\nimport net.sourceforge.schemaspy.model.TableIndex;\r\nimport net.sourceforge.schemaspy.util.Inflection;\r\n\r\npublic class DbAnalyzer {\r\n\r\n    public static List<ImpliedForeignKeyConstraint> getImpliedConstraints(Collection<Table> tables) {\r\n        List<TableColumn> columnsWithoutParents = new ArrayList<TableColumn>();\r\n        Map<TableColumn, Table> allPrimaries = new TreeMap<TableColumn, Table>(new Comparator<TableColumn>() {\r\n\r\n            public int compare(TableColumn column1, TableColumn column2) {\r\n                int rc = column1.getName().compareToIgnoreCase(column2.getName());\r\n                if (rc == 0)\r\n                    rc = column1.getType().compareToIgnoreCase(column2.getType());\r\n                if (rc == 0)\r\n                    rc = column1.getLength() - column2.getLength();\r\n                return rc;\r\n            }\r\n        });\r\n        int duplicatePrimaries = 0;\r\n        // gather all the primary key columns and columns without parents\r\n        for (Table table : tables) {\r\n            List<TableColumn> tablePrimaries = table.getPrimaryColumns();\r\n            if (tablePrimaries.size() == 1) {\r\n                // can't match up multiples...yet...\r\n                for (TableColumn primary : tablePrimaries) {\r\n                    if (primary.allowsImpliedChildren() && allPrimaries.put(primary, table) != null)\r\n                        ++duplicatePrimaries;\r\n                }\r\n            }\r\n            for (TableColumn column : table.getColumns()) {\r\n                if (!column.isForeignKey() && column.allowsImpliedParents())\r\n                    columnsWithoutParents.add(column);\r\n            }\r\n        }\r\n        // if more than half of the tables have the same primary key then\r\n        // it's most likely a database where primary key names aren't unique\r\n        // (e.g. they all have a primary key named 'ID')\r\n        if (// bizarre logic, but it does approximately what we need\r\n        duplicatePrimaries > allPrimaries.size())\r\n            return new ArrayList<ImpliedForeignKeyConstraint>();\r\n        sortColumnsByTable(columnsWithoutParents);\r\n        List<ImpliedForeignKeyConstraint> impliedConstraints = new ArrayList<ImpliedForeignKeyConstraint>();\r\n        for (TableColumn childColumn : columnsWithoutParents) {\r\n            Table primaryTable = allPrimaries.get(childColumn);\r\n            if (primaryTable != null && primaryTable != childColumn.getTable()) {\r\n                TableColumn parentColumn = primaryTable.getColumn(childColumn.getName());\r\n                // make sure the potential child->parent relationships isn't already a\r\n                // parent->child relationship\r\n                if (parentColumn.getParentConstraint(childColumn) == null) {\r\n                    // ok, we've found a potential relationship with a column matches a primary\r\n                    // key column in another table and isn't already related to that column\r\n                    impliedConstraints.add(new ImpliedForeignKeyConstraint(parentColumn, childColumn));\r\n                }\r\n            }\r\n        }\r\n        return impliedConstraints;\r\n    }\r\n\r\n    /**\r\n     * Ruby on Rails-based databases typically have no real referential integrity\r\n     * constraints.  Instead they have a somewhat unusual way of associating\r\n     * columns to primary keys.<p>\r\n     *\r\n     * Basically all tables have a primary key named <code>ID</code>.\r\n     * All tables are named plural names.\r\n     * The columns that logically reference that <code>ID</code> are the singular\r\n     * form of the table name suffixed with <code>_ID</code>.<p>\r\n     *\r\n     * A side-effect of calling this method is that the returned collection of\r\n     * constraints will be \"tied into\" the associated tables.\r\n     *\r\n     * @param tables\r\n     * @return List of {@link RailsForeignKeyConstraint}s\r\n     */\r\n    public static List<RailsForeignKeyConstraint> getRailsConstraints(Map<String, Table> tables) {\r\n        List<RailsForeignKeyConstraint> railsConstraints = new ArrayList<RailsForeignKeyConstraint>(tables.size());\r\n        // iterate thru each column in each table looking for columns that\r\n        // match Rails naming conventions\r\n        for (Table table : tables.values()) {\r\n            for (TableColumn column : table.getColumns()) {\r\n                String columnName = column.getName().toLowerCase();\r\n                if (!column.isForeignKey() && column.allowsImpliedParents() && columnName.endsWith(\"_id\")) {\r\n                    String singular = columnName.substring(0, columnName.length() - 3);\r\n                    String primaryTableName = Inflection.pluralize(singular);\r\n                    Table primaryTable = tables.get(primaryTableName);\r\n                    if (primaryTable != null) {\r\n                        TableColumn primaryColumn = primaryTable.getColumn(\"ID\");\r\n                        if (primaryColumn != null) {\r\n                            railsConstraints.add(new RailsForeignKeyConstraint(primaryColumn, column));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return railsConstraints;\r\n    }\r\n\r\n    /**\r\n     * Returns a <code>List</code> of all of the <code>ForeignKeyConstraint</code>s\r\n     * used by the specified tables.\r\n     *\r\n     * @param tables Collection\r\n     * @return List\r\n     */\r\n    public static List<ForeignKeyConstraint> getForeignKeyConstraints(Collection<Table> tables) {\r\n        List<ForeignKeyConstraint> constraints = new ArrayList<ForeignKeyConstraint>();\r\n        for (Table table : tables) {\r\n            constraints.addAll(table.getForeignKeys());\r\n        }\r\n        return constraints;\r\n    }\r\n\r\n    public static List<Table> getOrphans(Collection<Table> tables) {\r\n        List<Table> orphans = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.isOrphan(false)) {\r\n                orphans.add(table);\r\n            }\r\n        }\r\n        return sortTablesByName(orphans);\r\n    }\r\n\r\n    /**\r\n     * Return a list of <code>TableColumn</code>s that are both nullable\r\n     * and have an index that specifies that they must be unique (a rather strange combo).\r\n     */\r\n    public static List<TableColumn> getMustBeUniqueNullableColumns(Collection<Table> tables) {\r\n        List<TableColumn> uniqueNullables = new ArrayList<TableColumn>();\r\n        for (Table table : tables) {\r\n            for (TableIndex index : table.getIndexes()) {\r\n                if (index.isUniqueNullable()) {\r\n                    uniqueNullables.addAll(index.getColumns());\r\n                }\r\n            }\r\n        }\r\n        return sortColumnsByTable(uniqueNullables);\r\n    }\r\n\r\n    /**\r\n     * Return a list of <code>Table</code>s that have neither an index nor a primary key.\r\n     */\r\n    public static List<Table> getTablesWithoutIndexes(Collection<Table> tables) {\r\n        List<Table> withoutIndexes = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.getIndexes().size() == 0 && !table.isView() && !table.isLogical())\r\n                withoutIndexes.add(table);\r\n        }\r\n        return sortTablesByName(withoutIndexes);\r\n    }\r\n\r\n    public static List<Table> getTablesWithIncrementingColumnNames(Collection<Table> tables) {\r\n        List<Table> denormalizedTables = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            Map<String, Long> columnPrefixes = new HashMap<String, Long>();\r\n            for (TableColumn column : table.getColumns()) {\r\n                // search for columns that start with the same prefix\r\n                // and end in an incrementing number\r\n                String columnName = column.getName();\r\n                String numbers = null;\r\n                for (int i = columnName.length() - 1; i > 0; --i) {\r\n                    if (Character.isDigit(columnName.charAt(i))) {\r\n                        numbers = String.valueOf(columnName.charAt(i)) + (numbers == null ? \"\" : numbers);\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n                // attempt to detect where they had an existing column\r\n                // and added a \"column2\" type of column (we'll call this one \"1\")\r\n                if (numbers == null) {\r\n                    numbers = \"1\";\r\n                    columnName = columnName + numbers;\r\n                }\r\n                // see if we've already found a column with the same prefix\r\n                // that had a numeric suffix +/- 1.\r\n                String prefix = columnName.substring(0, columnName.length() - numbers.length());\r\n                long numeric = Long.parseLong(numbers);\r\n                Long existing = columnPrefixes.get(prefix);\r\n                if (existing != null && Math.abs(existing.longValue() - numeric) == 1) {\r\n                    // found one so add it to our list and stop evaluating this table\r\n                    denormalizedTables.add(table);\r\n                    break;\r\n                }\r\n                columnPrefixes.put(prefix, new Long(numeric));\r\n            }\r\n        }\r\n        return sortTablesByName(denormalizedTables);\r\n    }\r\n\r\n    public static List<Table> getTablesWithOneColumn(Collection<Table> tables) {\r\n        List<Table> singleColumnTables = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.getColumns().size() == 1)\r\n                singleColumnTables.add(table);\r\n        }\r\n        return sortTablesByName(singleColumnTables);\r\n    }\r\n\r\n    public static List<Table> sortTablesByName(List<Table> tables) {\r\n        Collections.sort(tables, new Comparator<Table>() {\r\n\r\n            public int compare(Table table1, Table table2) {\r\n                return table1.compareTo(table2);\r\n            }\r\n        });\r\n        return tables;\r\n    }\r\n\r\n    public static List<TableColumn> sortColumnsByTable(List<TableColumn> columns) {\r\n        Collections.sort(columns, new Comparator<TableColumn>() {\r\n\r\n            public int compare(TableColumn column1, TableColumn column2) {\r\n                int rc = column1.getTable().compareTo(column2.getTable());\r\n                if (rc == 0)\r\n                    rc = column1.getName().compareToIgnoreCase(column2.getName());\r\n                return rc;\r\n            }\r\n        });\r\n        return columns;\r\n    }\r\n\r\n    /**\r\n     * Returns a list of columns that have the word \"NULL\" or \"null\" as their default value\r\n     * instead of the likely candidate value null.\r\n     *\r\n     * @param tables Collection\r\n     * @return List\r\n     */\r\n    public static List<TableColumn> getDefaultNullStringColumns(Collection<Table> tables) {\r\n        List<TableColumn> defaultNullStringColumns = new ArrayList<TableColumn>();\r\n        for (Table table : tables) {\r\n            for (TableColumn column : table.getColumns()) {\r\n                Object defaultValue = column.getDefaultValue();\r\n                if (defaultValue != null && defaultValue instanceof String) {\r\n                    String defaultString = defaultValue.toString();\r\n                    if (defaultString.trim().equalsIgnoreCase(\"'null'\")) {\r\n                        defaultNullStringColumns.add(column);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return sortColumnsByTable(defaultNullStringColumns);\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of catalog names (Strings)\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getCatalogs(DatabaseMetaData meta) throws SQLException {\r\n        List<String> catalogs = new ArrayList<String>();\r\n        ResultSet rs = meta.getCatalogs();\r\n        while (rs.next()) {\r\n            catalogs.add(rs.getString(\"TABLE_CAT\"));\r\n        }\r\n        rs.close();\r\n        return catalogs;\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings)\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getSchemas(DatabaseMetaData meta) throws SQLException {\r\n        List<String> schemas = new ArrayList<String>();\r\n        ResultSet rs = meta.getSchemas();\r\n        while (rs.next()) {\r\n            schemas.add(rs.getString(\"TABLE_SCHEM\"));\r\n        }\r\n        rs.close();\r\n        return schemas;\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings) that contain tables\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getPopulatedSchemas(DatabaseMetaData meta) throws SQLException {\r\n        return getPopulatedSchemas(meta, \".*\", false);\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings) that contain tables and\r\n     * match the <code>schemaSpec</code> regular expression\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getPopulatedSchemas(DatabaseMetaData meta, String schemaSpec, boolean isCatalog) throws SQLException {\r\n        // alpha sorted\r\n        Set<String> schemas = new TreeSet<String>();\r\n        Pattern schemaRegex = Pattern.compile(schemaSpec);\r\n        Logger logger = Logger.getLogger(DbAnalyzer.class.getName());\r\n        boolean logging = logger.isLoggable(Level.FINE);\r\n        for (String schema : (isCatalog ? getCatalogs(meta) : getSchemas(meta))) {\r\n            if (schemaRegex.matcher(schema).matches()) {\r\n                ResultSet rs = null;\r\n                try {\r\n                    rs = meta.getTables(null, schema, \"%\", null);\r\n                    if (rs.next()) {\r\n                        if (logging)\r\n                            logger.fine(\"Including schema \" + schema + \": matches + \\\"\" + schemaRegex + \"\\\" and contains tables\");\r\n                        schemas.add(schema);\r\n                    } else {\r\n                        if (logging)\r\n                            logger.fine(\"Excluding schema \" + schema + \": matches \\\"\" + schemaRegex + \"\\\" but contains no tables\");\r\n                    }\r\n                } catch (SQLException ignore) {\r\n                } finally {\r\n                    if (rs != null)\r\n                        rs.close();\r\n                }\r\n            } else {\r\n                if (logging)\r\n                    logger.fine(\"Excluding schema \" + schema + \": doesn't match \\\"\" + schemaRegex + '\"');\r\n            }\r\n        }\r\n        return new ArrayList<String>(schemas);\r\n    }\r\n\r\n    /**\r\n     * For debugging/analyzing result sets\r\n     * @param rs ResultSet\r\n     * @throws SQLException\r\n     */\r\n    public static void dumpResultSetRow(ResultSet rs, String description) throws SQLException {\r\n        ResultSetMetaData meta = rs.getMetaData();\r\n        int numColumns = meta.getColumnCount();\r\n        System.out.println(numColumns + \" columns of \" + description + \":\");\r\n        for (int i = 1; i <= numColumns; ++i) {\r\n            System.out.print(meta.getColumnLabel(i));\r\n            System.out.print(\": \");\r\n            System.out.print(String.valueOf(rs.getString(i)));\r\n            System.out.print(\"\\t\");\r\n        }\r\n        System.out.println();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/DbAnalyzerTest5.java",
		"test_prompt": "// DbAnalyzerTest5.java\npackage net.sourceforge.schemaspy;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.model.TableIndex;\nimport net.sourceforge.schemaspy.util.Inflection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DbAnalyzer}.\n* It contains ten unit test cases for the {@link DbAnalyzer#getTablesWithoutIndexes(Collection)} method.\n*/\nclass DbAnalyzerTest5 {"
	},
	{
		"original_code": "// DbAnalyzer.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy;\r\n\r\nimport java.sql.DatabaseMetaData;\r\nimport java.sql.ResultSet;\r\nimport java.sql.ResultSetMetaData;\r\nimport java.sql.SQLException;\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.Collections;\r\nimport java.util.Comparator;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\nimport java.util.TreeMap;\r\nimport java.util.TreeSet;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.regex.Pattern;\r\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.Table;\r\nimport net.sourceforge.schemaspy.model.TableColumn;\r\nimport net.sourceforge.schemaspy.model.TableIndex;\r\nimport net.sourceforge.schemaspy.util.Inflection;\r\n\r\npublic class DbAnalyzer {\r\n\r\n    public static List<ImpliedForeignKeyConstraint> getImpliedConstraints(Collection<Table> tables) {\r\n        List<TableColumn> columnsWithoutParents = new ArrayList<TableColumn>();\r\n        Map<TableColumn, Table> allPrimaries = new TreeMap<TableColumn, Table>(new Comparator<TableColumn>() {\r\n\r\n            public int compare(TableColumn column1, TableColumn column2) {\r\n                int rc = column1.getName().compareToIgnoreCase(column2.getName());\r\n                if (rc == 0)\r\n                    rc = column1.getType().compareToIgnoreCase(column2.getType());\r\n                if (rc == 0)\r\n                    rc = column1.getLength() - column2.getLength();\r\n                return rc;\r\n            }\r\n        });\r\n        int duplicatePrimaries = 0;\r\n        // gather all the primary key columns and columns without parents\r\n        for (Table table : tables) {\r\n            List<TableColumn> tablePrimaries = table.getPrimaryColumns();\r\n            if (tablePrimaries.size() == 1) {\r\n                // can't match up multiples...yet...\r\n                for (TableColumn primary : tablePrimaries) {\r\n                    if (primary.allowsImpliedChildren() && allPrimaries.put(primary, table) != null)\r\n                        ++duplicatePrimaries;\r\n                }\r\n            }\r\n            for (TableColumn column : table.getColumns()) {\r\n                if (!column.isForeignKey() && column.allowsImpliedParents())\r\n                    columnsWithoutParents.add(column);\r\n            }\r\n        }\r\n        // if more than half of the tables have the same primary key then\r\n        // it's most likely a database where primary key names aren't unique\r\n        // (e.g. they all have a primary key named 'ID')\r\n        if (// bizarre logic, but it does approximately what we need\r\n        duplicatePrimaries > allPrimaries.size())\r\n            return new ArrayList<ImpliedForeignKeyConstraint>();\r\n        sortColumnsByTable(columnsWithoutParents);\r\n        List<ImpliedForeignKeyConstraint> impliedConstraints = new ArrayList<ImpliedForeignKeyConstraint>();\r\n        for (TableColumn childColumn : columnsWithoutParents) {\r\n            Table primaryTable = allPrimaries.get(childColumn);\r\n            if (primaryTable != null && primaryTable != childColumn.getTable()) {\r\n                TableColumn parentColumn = primaryTable.getColumn(childColumn.getName());\r\n                // make sure the potential child->parent relationships isn't already a\r\n                // parent->child relationship\r\n                if (parentColumn.getParentConstraint(childColumn) == null) {\r\n                    // ok, we've found a potential relationship with a column matches a primary\r\n                    // key column in another table and isn't already related to that column\r\n                    impliedConstraints.add(new ImpliedForeignKeyConstraint(parentColumn, childColumn));\r\n                }\r\n            }\r\n        }\r\n        return impliedConstraints;\r\n    }\r\n\r\n    /**\r\n     * Ruby on Rails-based databases typically have no real referential integrity\r\n     * constraints.  Instead they have a somewhat unusual way of associating\r\n     * columns to primary keys.<p>\r\n     *\r\n     * Basically all tables have a primary key named <code>ID</code>.\r\n     * All tables are named plural names.\r\n     * The columns that logically reference that <code>ID</code> are the singular\r\n     * form of the table name suffixed with <code>_ID</code>.<p>\r\n     *\r\n     * A side-effect of calling this method is that the returned collection of\r\n     * constraints will be \"tied into\" the associated tables.\r\n     *\r\n     * @param tables\r\n     * @return List of {@link RailsForeignKeyConstraint}s\r\n     */\r\n    public static List<RailsForeignKeyConstraint> getRailsConstraints(Map<String, Table> tables) {\r\n        List<RailsForeignKeyConstraint> railsConstraints = new ArrayList<RailsForeignKeyConstraint>(tables.size());\r\n        // iterate thru each column in each table looking for columns that\r\n        // match Rails naming conventions\r\n        for (Table table : tables.values()) {\r\n            for (TableColumn column : table.getColumns()) {\r\n                String columnName = column.getName().toLowerCase();\r\n                if (!column.isForeignKey() && column.allowsImpliedParents() && columnName.endsWith(\"_id\")) {\r\n                    String singular = columnName.substring(0, columnName.length() - 3);\r\n                    String primaryTableName = Inflection.pluralize(singular);\r\n                    Table primaryTable = tables.get(primaryTableName);\r\n                    if (primaryTable != null) {\r\n                        TableColumn primaryColumn = primaryTable.getColumn(\"ID\");\r\n                        if (primaryColumn != null) {\r\n                            railsConstraints.add(new RailsForeignKeyConstraint(primaryColumn, column));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return railsConstraints;\r\n    }\r\n\r\n    /**\r\n     * Returns a <code>List</code> of all of the <code>ForeignKeyConstraint</code>s\r\n     * used by the specified tables.\r\n     *\r\n     * @param tables Collection\r\n     * @return List\r\n     */\r\n    public static List<ForeignKeyConstraint> getForeignKeyConstraints(Collection<Table> tables) {\r\n        List<ForeignKeyConstraint> constraints = new ArrayList<ForeignKeyConstraint>();\r\n        for (Table table : tables) {\r\n            constraints.addAll(table.getForeignKeys());\r\n        }\r\n        return constraints;\r\n    }\r\n\r\n    public static List<Table> getOrphans(Collection<Table> tables) {\r\n        List<Table> orphans = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.isOrphan(false)) {\r\n                orphans.add(table);\r\n            }\r\n        }\r\n        return sortTablesByName(orphans);\r\n    }\r\n\r\n    /**\r\n     * Return a list of <code>TableColumn</code>s that are both nullable\r\n     * and have an index that specifies that they must be unique (a rather strange combo).\r\n     */\r\n    public static List<TableColumn> getMustBeUniqueNullableColumns(Collection<Table> tables) {\r\n        List<TableColumn> uniqueNullables = new ArrayList<TableColumn>();\r\n        for (Table table : tables) {\r\n            for (TableIndex index : table.getIndexes()) {\r\n                if (index.isUniqueNullable()) {\r\n                    uniqueNullables.addAll(index.getColumns());\r\n                }\r\n            }\r\n        }\r\n        return sortColumnsByTable(uniqueNullables);\r\n    }\r\n\r\n    /**\r\n     * Return a list of <code>Table</code>s that have neither an index nor a primary key.\r\n     */\r\n    public static List<Table> getTablesWithoutIndexes(Collection<Table> tables) {\r\n        List<Table> withoutIndexes = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.getIndexes().size() == 0 && !table.isView() && !table.isLogical())\r\n                withoutIndexes.add(table);\r\n        }\r\n        return sortTablesByName(withoutIndexes);\r\n    }\r\n\r\n    public static List<Table> getTablesWithIncrementingColumnNames(Collection<Table> tables) {\r\n        List<Table> denormalizedTables = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            Map<String, Long> columnPrefixes = new HashMap<String, Long>();\r\n            for (TableColumn column : table.getColumns()) {\r\n                // search for columns that start with the same prefix\r\n                // and end in an incrementing number\r\n                String columnName = column.getName();\r\n                String numbers = null;\r\n                for (int i = columnName.length() - 1; i > 0; --i) {\r\n                    if (Character.isDigit(columnName.charAt(i))) {\r\n                        numbers = String.valueOf(columnName.charAt(i)) + (numbers == null ? \"\" : numbers);\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n                // attempt to detect where they had an existing column\r\n                // and added a \"column2\" type of column (we'll call this one \"1\")\r\n                if (numbers == null) {\r\n                    numbers = \"1\";\r\n                    columnName = columnName + numbers;\r\n                }\r\n                // see if we've already found a column with the same prefix\r\n                // that had a numeric suffix +/- 1.\r\n                String prefix = columnName.substring(0, columnName.length() - numbers.length());\r\n                long numeric = Long.parseLong(numbers);\r\n                Long existing = columnPrefixes.get(prefix);\r\n                if (existing != null && Math.abs(existing.longValue() - numeric) == 1) {\r\n                    // found one so add it to our list and stop evaluating this table\r\n                    denormalizedTables.add(table);\r\n                    break;\r\n                }\r\n                columnPrefixes.put(prefix, new Long(numeric));\r\n            }\r\n        }\r\n        return sortTablesByName(denormalizedTables);\r\n    }\r\n\r\n    public static List<Table> getTablesWithOneColumn(Collection<Table> tables) {\r\n        List<Table> singleColumnTables = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.getColumns().size() == 1)\r\n                singleColumnTables.add(table);\r\n        }\r\n        return sortTablesByName(singleColumnTables);\r\n    }\r\n\r\n    public static List<Table> sortTablesByName(List<Table> tables) {\r\n        Collections.sort(tables, new Comparator<Table>() {\r\n\r\n            public int compare(Table table1, Table table2) {\r\n                return table1.compareTo(table2);\r\n            }\r\n        });\r\n        return tables;\r\n    }\r\n\r\n    public static List<TableColumn> sortColumnsByTable(List<TableColumn> columns) {\r\n        Collections.sort(columns, new Comparator<TableColumn>() {\r\n\r\n            public int compare(TableColumn column1, TableColumn column2) {\r\n                int rc = column1.getTable().compareTo(column2.getTable());\r\n                if (rc == 0)\r\n                    rc = column1.getName().compareToIgnoreCase(column2.getName());\r\n                return rc;\r\n            }\r\n        });\r\n        return columns;\r\n    }\r\n\r\n    /**\r\n     * Returns a list of columns that have the word \"NULL\" or \"null\" as their default value\r\n     * instead of the likely candidate value null.\r\n     *\r\n     * @param tables Collection\r\n     * @return List\r\n     */\r\n    public static List<TableColumn> getDefaultNullStringColumns(Collection<Table> tables) {\r\n        List<TableColumn> defaultNullStringColumns = new ArrayList<TableColumn>();\r\n        for (Table table : tables) {\r\n            for (TableColumn column : table.getColumns()) {\r\n                Object defaultValue = column.getDefaultValue();\r\n                if (defaultValue != null && defaultValue instanceof String) {\r\n                    String defaultString = defaultValue.toString();\r\n                    if (defaultString.trim().equalsIgnoreCase(\"'null'\")) {\r\n                        defaultNullStringColumns.add(column);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return sortColumnsByTable(defaultNullStringColumns);\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of catalog names (Strings)\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getCatalogs(DatabaseMetaData meta) throws SQLException {\r\n        List<String> catalogs = new ArrayList<String>();\r\n        ResultSet rs = meta.getCatalogs();\r\n        while (rs.next()) {\r\n            catalogs.add(rs.getString(\"TABLE_CAT\"));\r\n        }\r\n        rs.close();\r\n        return catalogs;\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings)\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getSchemas(DatabaseMetaData meta) throws SQLException {\r\n        List<String> schemas = new ArrayList<String>();\r\n        ResultSet rs = meta.getSchemas();\r\n        while (rs.next()) {\r\n            schemas.add(rs.getString(\"TABLE_SCHEM\"));\r\n        }\r\n        rs.close();\r\n        return schemas;\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings) that contain tables\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getPopulatedSchemas(DatabaseMetaData meta) throws SQLException {\r\n        return getPopulatedSchemas(meta, \".*\", false);\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings) that contain tables and\r\n     * match the <code>schemaSpec</code> regular expression\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getPopulatedSchemas(DatabaseMetaData meta, String schemaSpec, boolean isCatalog) throws SQLException {\r\n        // alpha sorted\r\n        Set<String> schemas = new TreeSet<String>();\r\n        Pattern schemaRegex = Pattern.compile(schemaSpec);\r\n        Logger logger = Logger.getLogger(DbAnalyzer.class.getName());\r\n        boolean logging = logger.isLoggable(Level.FINE);\r\n        for (String schema : (isCatalog ? getCatalogs(meta) : getSchemas(meta))) {\r\n            if (schemaRegex.matcher(schema).matches()) {\r\n                ResultSet rs = null;\r\n                try {\r\n                    rs = meta.getTables(null, schema, \"%\", null);\r\n                    if (rs.next()) {\r\n                        if (logging)\r\n                            logger.fine(\"Including schema \" + schema + \": matches + \\\"\" + schemaRegex + \"\\\" and contains tables\");\r\n                        schemas.add(schema);\r\n                    } else {\r\n                        if (logging)\r\n                            logger.fine(\"Excluding schema \" + schema + \": matches \\\"\" + schemaRegex + \"\\\" but contains no tables\");\r\n                    }\r\n                } catch (SQLException ignore) {\r\n                } finally {\r\n                    if (rs != null)\r\n                        rs.close();\r\n                }\r\n            } else {\r\n                if (logging)\r\n                    logger.fine(\"Excluding schema \" + schema + \": doesn't match \\\"\" + schemaRegex + '\"');\r\n            }\r\n        }\r\n        return new ArrayList<String>(schemas);\r\n    }\r\n\r\n    /**\r\n     * For debugging/analyzing result sets\r\n     * @param rs ResultSet\r\n     * @throws SQLException\r\n     */\r\n    public static void dumpResultSetRow(ResultSet rs, String description) throws SQLException {\r\n        ResultSetMetaData meta = rs.getMetaData();\r\n        int numColumns = meta.getColumnCount();\r\n        System.out.println(numColumns + \" columns of \" + description + \":\");\r\n        for (int i = 1; i <= numColumns; ++i) {\r\n            System.out.print(meta.getColumnLabel(i));\r\n            System.out.print(\": \");\r\n            System.out.print(String.valueOf(rs.getString(i)));\r\n            System.out.print(\"\\t\");\r\n        }\r\n        System.out.println();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/DbAnalyzerTest6.java",
		"test_prompt": "// DbAnalyzerTest6.java\npackage net.sourceforge.schemaspy;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.model.TableIndex;\nimport net.sourceforge.schemaspy.util.Inflection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DbAnalyzer}.\n* It contains ten unit test cases for the {@link DbAnalyzer#getTablesWithIncrementingColumnNames(Collection)} method.\n*/\nclass DbAnalyzerTest6 {"
	},
	{
		"original_code": "// DbAnalyzer.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy;\r\n\r\nimport java.sql.DatabaseMetaData;\r\nimport java.sql.ResultSet;\r\nimport java.sql.ResultSetMetaData;\r\nimport java.sql.SQLException;\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.Collections;\r\nimport java.util.Comparator;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\nimport java.util.TreeMap;\r\nimport java.util.TreeSet;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.regex.Pattern;\r\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.Table;\r\nimport net.sourceforge.schemaspy.model.TableColumn;\r\nimport net.sourceforge.schemaspy.model.TableIndex;\r\nimport net.sourceforge.schemaspy.util.Inflection;\r\n\r\npublic class DbAnalyzer {\r\n\r\n    public static List<ImpliedForeignKeyConstraint> getImpliedConstraints(Collection<Table> tables) {\r\n        List<TableColumn> columnsWithoutParents = new ArrayList<TableColumn>();\r\n        Map<TableColumn, Table> allPrimaries = new TreeMap<TableColumn, Table>(new Comparator<TableColumn>() {\r\n\r\n            public int compare(TableColumn column1, TableColumn column2) {\r\n                int rc = column1.getName().compareToIgnoreCase(column2.getName());\r\n                if (rc == 0)\r\n                    rc = column1.getType().compareToIgnoreCase(column2.getType());\r\n                if (rc == 0)\r\n                    rc = column1.getLength() - column2.getLength();\r\n                return rc;\r\n            }\r\n        });\r\n        int duplicatePrimaries = 0;\r\n        // gather all the primary key columns and columns without parents\r\n        for (Table table : tables) {\r\n            List<TableColumn> tablePrimaries = table.getPrimaryColumns();\r\n            if (tablePrimaries.size() == 1) {\r\n                // can't match up multiples...yet...\r\n                for (TableColumn primary : tablePrimaries) {\r\n                    if (primary.allowsImpliedChildren() && allPrimaries.put(primary, table) != null)\r\n                        ++duplicatePrimaries;\r\n                }\r\n            }\r\n            for (TableColumn column : table.getColumns()) {\r\n                if (!column.isForeignKey() && column.allowsImpliedParents())\r\n                    columnsWithoutParents.add(column);\r\n            }\r\n        }\r\n        // if more than half of the tables have the same primary key then\r\n        // it's most likely a database where primary key names aren't unique\r\n        // (e.g. they all have a primary key named 'ID')\r\n        if (// bizarre logic, but it does approximately what we need\r\n        duplicatePrimaries > allPrimaries.size())\r\n            return new ArrayList<ImpliedForeignKeyConstraint>();\r\n        sortColumnsByTable(columnsWithoutParents);\r\n        List<ImpliedForeignKeyConstraint> impliedConstraints = new ArrayList<ImpliedForeignKeyConstraint>();\r\n        for (TableColumn childColumn : columnsWithoutParents) {\r\n            Table primaryTable = allPrimaries.get(childColumn);\r\n            if (primaryTable != null && primaryTable != childColumn.getTable()) {\r\n                TableColumn parentColumn = primaryTable.getColumn(childColumn.getName());\r\n                // make sure the potential child->parent relationships isn't already a\r\n                // parent->child relationship\r\n                if (parentColumn.getParentConstraint(childColumn) == null) {\r\n                    // ok, we've found a potential relationship with a column matches a primary\r\n                    // key column in another table and isn't already related to that column\r\n                    impliedConstraints.add(new ImpliedForeignKeyConstraint(parentColumn, childColumn));\r\n                }\r\n            }\r\n        }\r\n        return impliedConstraints;\r\n    }\r\n\r\n    /**\r\n     * Ruby on Rails-based databases typically have no real referential integrity\r\n     * constraints.  Instead they have a somewhat unusual way of associating\r\n     * columns to primary keys.<p>\r\n     *\r\n     * Basically all tables have a primary key named <code>ID</code>.\r\n     * All tables are named plural names.\r\n     * The columns that logically reference that <code>ID</code> are the singular\r\n     * form of the table name suffixed with <code>_ID</code>.<p>\r\n     *\r\n     * A side-effect of calling this method is that the returned collection of\r\n     * constraints will be \"tied into\" the associated tables.\r\n     *\r\n     * @param tables\r\n     * @return List of {@link RailsForeignKeyConstraint}s\r\n     */\r\n    public static List<RailsForeignKeyConstraint> getRailsConstraints(Map<String, Table> tables) {\r\n        List<RailsForeignKeyConstraint> railsConstraints = new ArrayList<RailsForeignKeyConstraint>(tables.size());\r\n        // iterate thru each column in each table looking for columns that\r\n        // match Rails naming conventions\r\n        for (Table table : tables.values()) {\r\n            for (TableColumn column : table.getColumns()) {\r\n                String columnName = column.getName().toLowerCase();\r\n                if (!column.isForeignKey() && column.allowsImpliedParents() && columnName.endsWith(\"_id\")) {\r\n                    String singular = columnName.substring(0, columnName.length() - 3);\r\n                    String primaryTableName = Inflection.pluralize(singular);\r\n                    Table primaryTable = tables.get(primaryTableName);\r\n                    if (primaryTable != null) {\r\n                        TableColumn primaryColumn = primaryTable.getColumn(\"ID\");\r\n                        if (primaryColumn != null) {\r\n                            railsConstraints.add(new RailsForeignKeyConstraint(primaryColumn, column));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return railsConstraints;\r\n    }\r\n\r\n    /**\r\n     * Returns a <code>List</code> of all of the <code>ForeignKeyConstraint</code>s\r\n     * used by the specified tables.\r\n     *\r\n     * @param tables Collection\r\n     * @return List\r\n     */\r\n    public static List<ForeignKeyConstraint> getForeignKeyConstraints(Collection<Table> tables) {\r\n        List<ForeignKeyConstraint> constraints = new ArrayList<ForeignKeyConstraint>();\r\n        for (Table table : tables) {\r\n            constraints.addAll(table.getForeignKeys());\r\n        }\r\n        return constraints;\r\n    }\r\n\r\n    public static List<Table> getOrphans(Collection<Table> tables) {\r\n        List<Table> orphans = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.isOrphan(false)) {\r\n                orphans.add(table);\r\n            }\r\n        }\r\n        return sortTablesByName(orphans);\r\n    }\r\n\r\n    /**\r\n     * Return a list of <code>TableColumn</code>s that are both nullable\r\n     * and have an index that specifies that they must be unique (a rather strange combo).\r\n     */\r\n    public static List<TableColumn> getMustBeUniqueNullableColumns(Collection<Table> tables) {\r\n        List<TableColumn> uniqueNullables = new ArrayList<TableColumn>();\r\n        for (Table table : tables) {\r\n            for (TableIndex index : table.getIndexes()) {\r\n                if (index.isUniqueNullable()) {\r\n                    uniqueNullables.addAll(index.getColumns());\r\n                }\r\n            }\r\n        }\r\n        return sortColumnsByTable(uniqueNullables);\r\n    }\r\n\r\n    /**\r\n     * Return a list of <code>Table</code>s that have neither an index nor a primary key.\r\n     */\r\n    public static List<Table> getTablesWithoutIndexes(Collection<Table> tables) {\r\n        List<Table> withoutIndexes = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.getIndexes().size() == 0 && !table.isView() && !table.isLogical())\r\n                withoutIndexes.add(table);\r\n        }\r\n        return sortTablesByName(withoutIndexes);\r\n    }\r\n\r\n    public static List<Table> getTablesWithIncrementingColumnNames(Collection<Table> tables) {\r\n        List<Table> denormalizedTables = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            Map<String, Long> columnPrefixes = new HashMap<String, Long>();\r\n            for (TableColumn column : table.getColumns()) {\r\n                // search for columns that start with the same prefix\r\n                // and end in an incrementing number\r\n                String columnName = column.getName();\r\n                String numbers = null;\r\n                for (int i = columnName.length() - 1; i > 0; --i) {\r\n                    if (Character.isDigit(columnName.charAt(i))) {\r\n                        numbers = String.valueOf(columnName.charAt(i)) + (numbers == null ? \"\" : numbers);\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n                // attempt to detect where they had an existing column\r\n                // and added a \"column2\" type of column (we'll call this one \"1\")\r\n                if (numbers == null) {\r\n                    numbers = \"1\";\r\n                    columnName = columnName + numbers;\r\n                }\r\n                // see if we've already found a column with the same prefix\r\n                // that had a numeric suffix +/- 1.\r\n                String prefix = columnName.substring(0, columnName.length() - numbers.length());\r\n                long numeric = Long.parseLong(numbers);\r\n                Long existing = columnPrefixes.get(prefix);\r\n                if (existing != null && Math.abs(existing.longValue() - numeric) == 1) {\r\n                    // found one so add it to our list and stop evaluating this table\r\n                    denormalizedTables.add(table);\r\n                    break;\r\n                }\r\n                columnPrefixes.put(prefix, new Long(numeric));\r\n            }\r\n        }\r\n        return sortTablesByName(denormalizedTables);\r\n    }\r\n\r\n    public static List<Table> getTablesWithOneColumn(Collection<Table> tables) {\r\n        List<Table> singleColumnTables = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.getColumns().size() == 1)\r\n                singleColumnTables.add(table);\r\n        }\r\n        return sortTablesByName(singleColumnTables);\r\n    }\r\n\r\n    public static List<Table> sortTablesByName(List<Table> tables) {\r\n        Collections.sort(tables, new Comparator<Table>() {\r\n\r\n            public int compare(Table table1, Table table2) {\r\n                return table1.compareTo(table2);\r\n            }\r\n        });\r\n        return tables;\r\n    }\r\n\r\n    public static List<TableColumn> sortColumnsByTable(List<TableColumn> columns) {\r\n        Collections.sort(columns, new Comparator<TableColumn>() {\r\n\r\n            public int compare(TableColumn column1, TableColumn column2) {\r\n                int rc = column1.getTable().compareTo(column2.getTable());\r\n                if (rc == 0)\r\n                    rc = column1.getName().compareToIgnoreCase(column2.getName());\r\n                return rc;\r\n            }\r\n        });\r\n        return columns;\r\n    }\r\n\r\n    /**\r\n     * Returns a list of columns that have the word \"NULL\" or \"null\" as their default value\r\n     * instead of the likely candidate value null.\r\n     *\r\n     * @param tables Collection\r\n     * @return List\r\n     */\r\n    public static List<TableColumn> getDefaultNullStringColumns(Collection<Table> tables) {\r\n        List<TableColumn> defaultNullStringColumns = new ArrayList<TableColumn>();\r\n        for (Table table : tables) {\r\n            for (TableColumn column : table.getColumns()) {\r\n                Object defaultValue = column.getDefaultValue();\r\n                if (defaultValue != null && defaultValue instanceof String) {\r\n                    String defaultString = defaultValue.toString();\r\n                    if (defaultString.trim().equalsIgnoreCase(\"'null'\")) {\r\n                        defaultNullStringColumns.add(column);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return sortColumnsByTable(defaultNullStringColumns);\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of catalog names (Strings)\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getCatalogs(DatabaseMetaData meta) throws SQLException {\r\n        List<String> catalogs = new ArrayList<String>();\r\n        ResultSet rs = meta.getCatalogs();\r\n        while (rs.next()) {\r\n            catalogs.add(rs.getString(\"TABLE_CAT\"));\r\n        }\r\n        rs.close();\r\n        return catalogs;\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings)\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getSchemas(DatabaseMetaData meta) throws SQLException {\r\n        List<String> schemas = new ArrayList<String>();\r\n        ResultSet rs = meta.getSchemas();\r\n        while (rs.next()) {\r\n            schemas.add(rs.getString(\"TABLE_SCHEM\"));\r\n        }\r\n        rs.close();\r\n        return schemas;\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings) that contain tables\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getPopulatedSchemas(DatabaseMetaData meta) throws SQLException {\r\n        return getPopulatedSchemas(meta, \".*\", false);\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings) that contain tables and\r\n     * match the <code>schemaSpec</code> regular expression\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getPopulatedSchemas(DatabaseMetaData meta, String schemaSpec, boolean isCatalog) throws SQLException {\r\n        // alpha sorted\r\n        Set<String> schemas = new TreeSet<String>();\r\n        Pattern schemaRegex = Pattern.compile(schemaSpec);\r\n        Logger logger = Logger.getLogger(DbAnalyzer.class.getName());\r\n        boolean logging = logger.isLoggable(Level.FINE);\r\n        for (String schema : (isCatalog ? getCatalogs(meta) : getSchemas(meta))) {\r\n            if (schemaRegex.matcher(schema).matches()) {\r\n                ResultSet rs = null;\r\n                try {\r\n                    rs = meta.getTables(null, schema, \"%\", null);\r\n                    if (rs.next()) {\r\n                        if (logging)\r\n                            logger.fine(\"Including schema \" + schema + \": matches + \\\"\" + schemaRegex + \"\\\" and contains tables\");\r\n                        schemas.add(schema);\r\n                    } else {\r\n                        if (logging)\r\n                            logger.fine(\"Excluding schema \" + schema + \": matches \\\"\" + schemaRegex + \"\\\" but contains no tables\");\r\n                    }\r\n                } catch (SQLException ignore) {\r\n                } finally {\r\n                    if (rs != null)\r\n                        rs.close();\r\n                }\r\n            } else {\r\n                if (logging)\r\n                    logger.fine(\"Excluding schema \" + schema + \": doesn't match \\\"\" + schemaRegex + '\"');\r\n            }\r\n        }\r\n        return new ArrayList<String>(schemas);\r\n    }\r\n\r\n    /**\r\n     * For debugging/analyzing result sets\r\n     * @param rs ResultSet\r\n     * @throws SQLException\r\n     */\r\n    public static void dumpResultSetRow(ResultSet rs, String description) throws SQLException {\r\n        ResultSetMetaData meta = rs.getMetaData();\r\n        int numColumns = meta.getColumnCount();\r\n        System.out.println(numColumns + \" columns of \" + description + \":\");\r\n        for (int i = 1; i <= numColumns; ++i) {\r\n            System.out.print(meta.getColumnLabel(i));\r\n            System.out.print(\": \");\r\n            System.out.print(String.valueOf(rs.getString(i)));\r\n            System.out.print(\"\\t\");\r\n        }\r\n        System.out.println();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/DbAnalyzerTest7.java",
		"test_prompt": "// DbAnalyzerTest7.java\npackage net.sourceforge.schemaspy;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.model.TableIndex;\nimport net.sourceforge.schemaspy.util.Inflection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DbAnalyzer}.\n* It contains ten unit test cases for the {@link DbAnalyzer#getTablesWithOneColumn(Collection)} method.\n*/\nclass DbAnalyzerTest7 {"
	},
	{
		"original_code": "// DbAnalyzer.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy;\r\n\r\nimport java.sql.DatabaseMetaData;\r\nimport java.sql.ResultSet;\r\nimport java.sql.ResultSetMetaData;\r\nimport java.sql.SQLException;\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.Collections;\r\nimport java.util.Comparator;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\nimport java.util.TreeMap;\r\nimport java.util.TreeSet;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.regex.Pattern;\r\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.Table;\r\nimport net.sourceforge.schemaspy.model.TableColumn;\r\nimport net.sourceforge.schemaspy.model.TableIndex;\r\nimport net.sourceforge.schemaspy.util.Inflection;\r\n\r\npublic class DbAnalyzer {\r\n\r\n    public static List<ImpliedForeignKeyConstraint> getImpliedConstraints(Collection<Table> tables) {\r\n        List<TableColumn> columnsWithoutParents = new ArrayList<TableColumn>();\r\n        Map<TableColumn, Table> allPrimaries = new TreeMap<TableColumn, Table>(new Comparator<TableColumn>() {\r\n\r\n            public int compare(TableColumn column1, TableColumn column2) {\r\n                int rc = column1.getName().compareToIgnoreCase(column2.getName());\r\n                if (rc == 0)\r\n                    rc = column1.getType().compareToIgnoreCase(column2.getType());\r\n                if (rc == 0)\r\n                    rc = column1.getLength() - column2.getLength();\r\n                return rc;\r\n            }\r\n        });\r\n        int duplicatePrimaries = 0;\r\n        // gather all the primary key columns and columns without parents\r\n        for (Table table : tables) {\r\n            List<TableColumn> tablePrimaries = table.getPrimaryColumns();\r\n            if (tablePrimaries.size() == 1) {\r\n                // can't match up multiples...yet...\r\n                for (TableColumn primary : tablePrimaries) {\r\n                    if (primary.allowsImpliedChildren() && allPrimaries.put(primary, table) != null)\r\n                        ++duplicatePrimaries;\r\n                }\r\n            }\r\n            for (TableColumn column : table.getColumns()) {\r\n                if (!column.isForeignKey() && column.allowsImpliedParents())\r\n                    columnsWithoutParents.add(column);\r\n            }\r\n        }\r\n        // if more than half of the tables have the same primary key then\r\n        // it's most likely a database where primary key names aren't unique\r\n        // (e.g. they all have a primary key named 'ID')\r\n        if (// bizarre logic, but it does approximately what we need\r\n        duplicatePrimaries > allPrimaries.size())\r\n            return new ArrayList<ImpliedForeignKeyConstraint>();\r\n        sortColumnsByTable(columnsWithoutParents);\r\n        List<ImpliedForeignKeyConstraint> impliedConstraints = new ArrayList<ImpliedForeignKeyConstraint>();\r\n        for (TableColumn childColumn : columnsWithoutParents) {\r\n            Table primaryTable = allPrimaries.get(childColumn);\r\n            if (primaryTable != null && primaryTable != childColumn.getTable()) {\r\n                TableColumn parentColumn = primaryTable.getColumn(childColumn.getName());\r\n                // make sure the potential child->parent relationships isn't already a\r\n                // parent->child relationship\r\n                if (parentColumn.getParentConstraint(childColumn) == null) {\r\n                    // ok, we've found a potential relationship with a column matches a primary\r\n                    // key column in another table and isn't already related to that column\r\n                    impliedConstraints.add(new ImpliedForeignKeyConstraint(parentColumn, childColumn));\r\n                }\r\n            }\r\n        }\r\n        return impliedConstraints;\r\n    }\r\n\r\n    /**\r\n     * Ruby on Rails-based databases typically have no real referential integrity\r\n     * constraints.  Instead they have a somewhat unusual way of associating\r\n     * columns to primary keys.<p>\r\n     *\r\n     * Basically all tables have a primary key named <code>ID</code>.\r\n     * All tables are named plural names.\r\n     * The columns that logically reference that <code>ID</code> are the singular\r\n     * form of the table name suffixed with <code>_ID</code>.<p>\r\n     *\r\n     * A side-effect of calling this method is that the returned collection of\r\n     * constraints will be \"tied into\" the associated tables.\r\n     *\r\n     * @param tables\r\n     * @return List of {@link RailsForeignKeyConstraint}s\r\n     */\r\n    public static List<RailsForeignKeyConstraint> getRailsConstraints(Map<String, Table> tables) {\r\n        List<RailsForeignKeyConstraint> railsConstraints = new ArrayList<RailsForeignKeyConstraint>(tables.size());\r\n        // iterate thru each column in each table looking for columns that\r\n        // match Rails naming conventions\r\n        for (Table table : tables.values()) {\r\n            for (TableColumn column : table.getColumns()) {\r\n                String columnName = column.getName().toLowerCase();\r\n                if (!column.isForeignKey() && column.allowsImpliedParents() && columnName.endsWith(\"_id\")) {\r\n                    String singular = columnName.substring(0, columnName.length() - 3);\r\n                    String primaryTableName = Inflection.pluralize(singular);\r\n                    Table primaryTable = tables.get(primaryTableName);\r\n                    if (primaryTable != null) {\r\n                        TableColumn primaryColumn = primaryTable.getColumn(\"ID\");\r\n                        if (primaryColumn != null) {\r\n                            railsConstraints.add(new RailsForeignKeyConstraint(primaryColumn, column));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return railsConstraints;\r\n    }\r\n\r\n    /**\r\n     * Returns a <code>List</code> of all of the <code>ForeignKeyConstraint</code>s\r\n     * used by the specified tables.\r\n     *\r\n     * @param tables Collection\r\n     * @return List\r\n     */\r\n    public static List<ForeignKeyConstraint> getForeignKeyConstraints(Collection<Table> tables) {\r\n        List<ForeignKeyConstraint> constraints = new ArrayList<ForeignKeyConstraint>();\r\n        for (Table table : tables) {\r\n            constraints.addAll(table.getForeignKeys());\r\n        }\r\n        return constraints;\r\n    }\r\n\r\n    public static List<Table> getOrphans(Collection<Table> tables) {\r\n        List<Table> orphans = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.isOrphan(false)) {\r\n                orphans.add(table);\r\n            }\r\n        }\r\n        return sortTablesByName(orphans);\r\n    }\r\n\r\n    /**\r\n     * Return a list of <code>TableColumn</code>s that are both nullable\r\n     * and have an index that specifies that they must be unique (a rather strange combo).\r\n     */\r\n    public static List<TableColumn> getMustBeUniqueNullableColumns(Collection<Table> tables) {\r\n        List<TableColumn> uniqueNullables = new ArrayList<TableColumn>();\r\n        for (Table table : tables) {\r\n            for (TableIndex index : table.getIndexes()) {\r\n                if (index.isUniqueNullable()) {\r\n                    uniqueNullables.addAll(index.getColumns());\r\n                }\r\n            }\r\n        }\r\n        return sortColumnsByTable(uniqueNullables);\r\n    }\r\n\r\n    /**\r\n     * Return a list of <code>Table</code>s that have neither an index nor a primary key.\r\n     */\r\n    public static List<Table> getTablesWithoutIndexes(Collection<Table> tables) {\r\n        List<Table> withoutIndexes = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.getIndexes().size() == 0 && !table.isView() && !table.isLogical())\r\n                withoutIndexes.add(table);\r\n        }\r\n        return sortTablesByName(withoutIndexes);\r\n    }\r\n\r\n    public static List<Table> getTablesWithIncrementingColumnNames(Collection<Table> tables) {\r\n        List<Table> denormalizedTables = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            Map<String, Long> columnPrefixes = new HashMap<String, Long>();\r\n            for (TableColumn column : table.getColumns()) {\r\n                // search for columns that start with the same prefix\r\n                // and end in an incrementing number\r\n                String columnName = column.getName();\r\n                String numbers = null;\r\n                for (int i = columnName.length() - 1; i > 0; --i) {\r\n                    if (Character.isDigit(columnName.charAt(i))) {\r\n                        numbers = String.valueOf(columnName.charAt(i)) + (numbers == null ? \"\" : numbers);\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n                // attempt to detect where they had an existing column\r\n                // and added a \"column2\" type of column (we'll call this one \"1\")\r\n                if (numbers == null) {\r\n                    numbers = \"1\";\r\n                    columnName = columnName + numbers;\r\n                }\r\n                // see if we've already found a column with the same prefix\r\n                // that had a numeric suffix +/- 1.\r\n                String prefix = columnName.substring(0, columnName.length() - numbers.length());\r\n                long numeric = Long.parseLong(numbers);\r\n                Long existing = columnPrefixes.get(prefix);\r\n                if (existing != null && Math.abs(existing.longValue() - numeric) == 1) {\r\n                    // found one so add it to our list and stop evaluating this table\r\n                    denormalizedTables.add(table);\r\n                    break;\r\n                }\r\n                columnPrefixes.put(prefix, new Long(numeric));\r\n            }\r\n        }\r\n        return sortTablesByName(denormalizedTables);\r\n    }\r\n\r\n    public static List<Table> getTablesWithOneColumn(Collection<Table> tables) {\r\n        List<Table> singleColumnTables = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.getColumns().size() == 1)\r\n                singleColumnTables.add(table);\r\n        }\r\n        return sortTablesByName(singleColumnTables);\r\n    }\r\n\r\n    public static List<Table> sortTablesByName(List<Table> tables) {\r\n        Collections.sort(tables, new Comparator<Table>() {\r\n\r\n            public int compare(Table table1, Table table2) {\r\n                return table1.compareTo(table2);\r\n            }\r\n        });\r\n        return tables;\r\n    }\r\n\r\n    public static List<TableColumn> sortColumnsByTable(List<TableColumn> columns) {\r\n        Collections.sort(columns, new Comparator<TableColumn>() {\r\n\r\n            public int compare(TableColumn column1, TableColumn column2) {\r\n                int rc = column1.getTable().compareTo(column2.getTable());\r\n                if (rc == 0)\r\n                    rc = column1.getName().compareToIgnoreCase(column2.getName());\r\n                return rc;\r\n            }\r\n        });\r\n        return columns;\r\n    }\r\n\r\n    /**\r\n     * Returns a list of columns that have the word \"NULL\" or \"null\" as their default value\r\n     * instead of the likely candidate value null.\r\n     *\r\n     * @param tables Collection\r\n     * @return List\r\n     */\r\n    public static List<TableColumn> getDefaultNullStringColumns(Collection<Table> tables) {\r\n        List<TableColumn> defaultNullStringColumns = new ArrayList<TableColumn>();\r\n        for (Table table : tables) {\r\n            for (TableColumn column : table.getColumns()) {\r\n                Object defaultValue = column.getDefaultValue();\r\n                if (defaultValue != null && defaultValue instanceof String) {\r\n                    String defaultString = defaultValue.toString();\r\n                    if (defaultString.trim().equalsIgnoreCase(\"'null'\")) {\r\n                        defaultNullStringColumns.add(column);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return sortColumnsByTable(defaultNullStringColumns);\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of catalog names (Strings)\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getCatalogs(DatabaseMetaData meta) throws SQLException {\r\n        List<String> catalogs = new ArrayList<String>();\r\n        ResultSet rs = meta.getCatalogs();\r\n        while (rs.next()) {\r\n            catalogs.add(rs.getString(\"TABLE_CAT\"));\r\n        }\r\n        rs.close();\r\n        return catalogs;\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings)\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getSchemas(DatabaseMetaData meta) throws SQLException {\r\n        List<String> schemas = new ArrayList<String>();\r\n        ResultSet rs = meta.getSchemas();\r\n        while (rs.next()) {\r\n            schemas.add(rs.getString(\"TABLE_SCHEM\"));\r\n        }\r\n        rs.close();\r\n        return schemas;\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings) that contain tables\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getPopulatedSchemas(DatabaseMetaData meta) throws SQLException {\r\n        return getPopulatedSchemas(meta, \".*\", false);\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings) that contain tables and\r\n     * match the <code>schemaSpec</code> regular expression\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getPopulatedSchemas(DatabaseMetaData meta, String schemaSpec, boolean isCatalog) throws SQLException {\r\n        // alpha sorted\r\n        Set<String> schemas = new TreeSet<String>();\r\n        Pattern schemaRegex = Pattern.compile(schemaSpec);\r\n        Logger logger = Logger.getLogger(DbAnalyzer.class.getName());\r\n        boolean logging = logger.isLoggable(Level.FINE);\r\n        for (String schema : (isCatalog ? getCatalogs(meta) : getSchemas(meta))) {\r\n            if (schemaRegex.matcher(schema).matches()) {\r\n                ResultSet rs = null;\r\n                try {\r\n                    rs = meta.getTables(null, schema, \"%\", null);\r\n                    if (rs.next()) {\r\n                        if (logging)\r\n                            logger.fine(\"Including schema \" + schema + \": matches + \\\"\" + schemaRegex + \"\\\" and contains tables\");\r\n                        schemas.add(schema);\r\n                    } else {\r\n                        if (logging)\r\n                            logger.fine(\"Excluding schema \" + schema + \": matches \\\"\" + schemaRegex + \"\\\" but contains no tables\");\r\n                    }\r\n                } catch (SQLException ignore) {\r\n                } finally {\r\n                    if (rs != null)\r\n                        rs.close();\r\n                }\r\n            } else {\r\n                if (logging)\r\n                    logger.fine(\"Excluding schema \" + schema + \": doesn't match \\\"\" + schemaRegex + '\"');\r\n            }\r\n        }\r\n        return new ArrayList<String>(schemas);\r\n    }\r\n\r\n    /**\r\n     * For debugging/analyzing result sets\r\n     * @param rs ResultSet\r\n     * @throws SQLException\r\n     */\r\n    public static void dumpResultSetRow(ResultSet rs, String description) throws SQLException {\r\n        ResultSetMetaData meta = rs.getMetaData();\r\n        int numColumns = meta.getColumnCount();\r\n        System.out.println(numColumns + \" columns of \" + description + \":\");\r\n        for (int i = 1; i <= numColumns; ++i) {\r\n            System.out.print(meta.getColumnLabel(i));\r\n            System.out.print(\": \");\r\n            System.out.print(String.valueOf(rs.getString(i)));\r\n            System.out.print(\"\\t\");\r\n        }\r\n        System.out.println();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/DbAnalyzerTest8.java",
		"test_prompt": "// DbAnalyzerTest8.java\npackage net.sourceforge.schemaspy;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.model.TableIndex;\nimport net.sourceforge.schemaspy.util.Inflection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DbAnalyzer}.\n* It contains ten unit test cases for the {@link DbAnalyzer#sortTablesByName(List)} method.\n*/\nclass DbAnalyzerTest8 {"
	},
	{
		"original_code": "// DbAnalyzer.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy;\r\n\r\nimport java.sql.DatabaseMetaData;\r\nimport java.sql.ResultSet;\r\nimport java.sql.ResultSetMetaData;\r\nimport java.sql.SQLException;\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.Collections;\r\nimport java.util.Comparator;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\nimport java.util.TreeMap;\r\nimport java.util.TreeSet;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.regex.Pattern;\r\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.Table;\r\nimport net.sourceforge.schemaspy.model.TableColumn;\r\nimport net.sourceforge.schemaspy.model.TableIndex;\r\nimport net.sourceforge.schemaspy.util.Inflection;\r\n\r\npublic class DbAnalyzer {\r\n\r\n    public static List<ImpliedForeignKeyConstraint> getImpliedConstraints(Collection<Table> tables) {\r\n        List<TableColumn> columnsWithoutParents = new ArrayList<TableColumn>();\r\n        Map<TableColumn, Table> allPrimaries = new TreeMap<TableColumn, Table>(new Comparator<TableColumn>() {\r\n\r\n            public int compare(TableColumn column1, TableColumn column2) {\r\n                int rc = column1.getName().compareToIgnoreCase(column2.getName());\r\n                if (rc == 0)\r\n                    rc = column1.getType().compareToIgnoreCase(column2.getType());\r\n                if (rc == 0)\r\n                    rc = column1.getLength() - column2.getLength();\r\n                return rc;\r\n            }\r\n        });\r\n        int duplicatePrimaries = 0;\r\n        // gather all the primary key columns and columns without parents\r\n        for (Table table : tables) {\r\n            List<TableColumn> tablePrimaries = table.getPrimaryColumns();\r\n            if (tablePrimaries.size() == 1) {\r\n                // can't match up multiples...yet...\r\n                for (TableColumn primary : tablePrimaries) {\r\n                    if (primary.allowsImpliedChildren() && allPrimaries.put(primary, table) != null)\r\n                        ++duplicatePrimaries;\r\n                }\r\n            }\r\n            for (TableColumn column : table.getColumns()) {\r\n                if (!column.isForeignKey() && column.allowsImpliedParents())\r\n                    columnsWithoutParents.add(column);\r\n            }\r\n        }\r\n        // if more than half of the tables have the same primary key then\r\n        // it's most likely a database where primary key names aren't unique\r\n        // (e.g. they all have a primary key named 'ID')\r\n        if (// bizarre logic, but it does approximately what we need\r\n        duplicatePrimaries > allPrimaries.size())\r\n            return new ArrayList<ImpliedForeignKeyConstraint>();\r\n        sortColumnsByTable(columnsWithoutParents);\r\n        List<ImpliedForeignKeyConstraint> impliedConstraints = new ArrayList<ImpliedForeignKeyConstraint>();\r\n        for (TableColumn childColumn : columnsWithoutParents) {\r\n            Table primaryTable = allPrimaries.get(childColumn);\r\n            if (primaryTable != null && primaryTable != childColumn.getTable()) {\r\n                TableColumn parentColumn = primaryTable.getColumn(childColumn.getName());\r\n                // make sure the potential child->parent relationships isn't already a\r\n                // parent->child relationship\r\n                if (parentColumn.getParentConstraint(childColumn) == null) {\r\n                    // ok, we've found a potential relationship with a column matches a primary\r\n                    // key column in another table and isn't already related to that column\r\n                    impliedConstraints.add(new ImpliedForeignKeyConstraint(parentColumn, childColumn));\r\n                }\r\n            }\r\n        }\r\n        return impliedConstraints;\r\n    }\r\n\r\n    /**\r\n     * Ruby on Rails-based databases typically have no real referential integrity\r\n     * constraints.  Instead they have a somewhat unusual way of associating\r\n     * columns to primary keys.<p>\r\n     *\r\n     * Basically all tables have a primary key named <code>ID</code>.\r\n     * All tables are named plural names.\r\n     * The columns that logically reference that <code>ID</code> are the singular\r\n     * form of the table name suffixed with <code>_ID</code>.<p>\r\n     *\r\n     * A side-effect of calling this method is that the returned collection of\r\n     * constraints will be \"tied into\" the associated tables.\r\n     *\r\n     * @param tables\r\n     * @return List of {@link RailsForeignKeyConstraint}s\r\n     */\r\n    public static List<RailsForeignKeyConstraint> getRailsConstraints(Map<String, Table> tables) {\r\n        List<RailsForeignKeyConstraint> railsConstraints = new ArrayList<RailsForeignKeyConstraint>(tables.size());\r\n        // iterate thru each column in each table looking for columns that\r\n        // match Rails naming conventions\r\n        for (Table table : tables.values()) {\r\n            for (TableColumn column : table.getColumns()) {\r\n                String columnName = column.getName().toLowerCase();\r\n                if (!column.isForeignKey() && column.allowsImpliedParents() && columnName.endsWith(\"_id\")) {\r\n                    String singular = columnName.substring(0, columnName.length() - 3);\r\n                    String primaryTableName = Inflection.pluralize(singular);\r\n                    Table primaryTable = tables.get(primaryTableName);\r\n                    if (primaryTable != null) {\r\n                        TableColumn primaryColumn = primaryTable.getColumn(\"ID\");\r\n                        if (primaryColumn != null) {\r\n                            railsConstraints.add(new RailsForeignKeyConstraint(primaryColumn, column));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return railsConstraints;\r\n    }\r\n\r\n    /**\r\n     * Returns a <code>List</code> of all of the <code>ForeignKeyConstraint</code>s\r\n     * used by the specified tables.\r\n     *\r\n     * @param tables Collection\r\n     * @return List\r\n     */\r\n    public static List<ForeignKeyConstraint> getForeignKeyConstraints(Collection<Table> tables) {\r\n        List<ForeignKeyConstraint> constraints = new ArrayList<ForeignKeyConstraint>();\r\n        for (Table table : tables) {\r\n            constraints.addAll(table.getForeignKeys());\r\n        }\r\n        return constraints;\r\n    }\r\n\r\n    public static List<Table> getOrphans(Collection<Table> tables) {\r\n        List<Table> orphans = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.isOrphan(false)) {\r\n                orphans.add(table);\r\n            }\r\n        }\r\n        return sortTablesByName(orphans);\r\n    }\r\n\r\n    /**\r\n     * Return a list of <code>TableColumn</code>s that are both nullable\r\n     * and have an index that specifies that they must be unique (a rather strange combo).\r\n     */\r\n    public static List<TableColumn> getMustBeUniqueNullableColumns(Collection<Table> tables) {\r\n        List<TableColumn> uniqueNullables = new ArrayList<TableColumn>();\r\n        for (Table table : tables) {\r\n            for (TableIndex index : table.getIndexes()) {\r\n                if (index.isUniqueNullable()) {\r\n                    uniqueNullables.addAll(index.getColumns());\r\n                }\r\n            }\r\n        }\r\n        return sortColumnsByTable(uniqueNullables);\r\n    }\r\n\r\n    /**\r\n     * Return a list of <code>Table</code>s that have neither an index nor a primary key.\r\n     */\r\n    public static List<Table> getTablesWithoutIndexes(Collection<Table> tables) {\r\n        List<Table> withoutIndexes = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.getIndexes().size() == 0 && !table.isView() && !table.isLogical())\r\n                withoutIndexes.add(table);\r\n        }\r\n        return sortTablesByName(withoutIndexes);\r\n    }\r\n\r\n    public static List<Table> getTablesWithIncrementingColumnNames(Collection<Table> tables) {\r\n        List<Table> denormalizedTables = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            Map<String, Long> columnPrefixes = new HashMap<String, Long>();\r\n            for (TableColumn column : table.getColumns()) {\r\n                // search for columns that start with the same prefix\r\n                // and end in an incrementing number\r\n                String columnName = column.getName();\r\n                String numbers = null;\r\n                for (int i = columnName.length() - 1; i > 0; --i) {\r\n                    if (Character.isDigit(columnName.charAt(i))) {\r\n                        numbers = String.valueOf(columnName.charAt(i)) + (numbers == null ? \"\" : numbers);\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n                // attempt to detect where they had an existing column\r\n                // and added a \"column2\" type of column (we'll call this one \"1\")\r\n                if (numbers == null) {\r\n                    numbers = \"1\";\r\n                    columnName = columnName + numbers;\r\n                }\r\n                // see if we've already found a column with the same prefix\r\n                // that had a numeric suffix +/- 1.\r\n                String prefix = columnName.substring(0, columnName.length() - numbers.length());\r\n                long numeric = Long.parseLong(numbers);\r\n                Long existing = columnPrefixes.get(prefix);\r\n                if (existing != null && Math.abs(existing.longValue() - numeric) == 1) {\r\n                    // found one so add it to our list and stop evaluating this table\r\n                    denormalizedTables.add(table);\r\n                    break;\r\n                }\r\n                columnPrefixes.put(prefix, new Long(numeric));\r\n            }\r\n        }\r\n        return sortTablesByName(denormalizedTables);\r\n    }\r\n\r\n    public static List<Table> getTablesWithOneColumn(Collection<Table> tables) {\r\n        List<Table> singleColumnTables = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.getColumns().size() == 1)\r\n                singleColumnTables.add(table);\r\n        }\r\n        return sortTablesByName(singleColumnTables);\r\n    }\r\n\r\n    public static List<Table> sortTablesByName(List<Table> tables) {\r\n        Collections.sort(tables, new Comparator<Table>() {\r\n\r\n            public int compare(Table table1, Table table2) {\r\n                return table1.compareTo(table2);\r\n            }\r\n        });\r\n        return tables;\r\n    }\r\n\r\n    public static List<TableColumn> sortColumnsByTable(List<TableColumn> columns) {\r\n        Collections.sort(columns, new Comparator<TableColumn>() {\r\n\r\n            public int compare(TableColumn column1, TableColumn column2) {\r\n                int rc = column1.getTable().compareTo(column2.getTable());\r\n                if (rc == 0)\r\n                    rc = column1.getName().compareToIgnoreCase(column2.getName());\r\n                return rc;\r\n            }\r\n        });\r\n        return columns;\r\n    }\r\n\r\n    /**\r\n     * Returns a list of columns that have the word \"NULL\" or \"null\" as their default value\r\n     * instead of the likely candidate value null.\r\n     *\r\n     * @param tables Collection\r\n     * @return List\r\n     */\r\n    public static List<TableColumn> getDefaultNullStringColumns(Collection<Table> tables) {\r\n        List<TableColumn> defaultNullStringColumns = new ArrayList<TableColumn>();\r\n        for (Table table : tables) {\r\n            for (TableColumn column : table.getColumns()) {\r\n                Object defaultValue = column.getDefaultValue();\r\n                if (defaultValue != null && defaultValue instanceof String) {\r\n                    String defaultString = defaultValue.toString();\r\n                    if (defaultString.trim().equalsIgnoreCase(\"'null'\")) {\r\n                        defaultNullStringColumns.add(column);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return sortColumnsByTable(defaultNullStringColumns);\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of catalog names (Strings)\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getCatalogs(DatabaseMetaData meta) throws SQLException {\r\n        List<String> catalogs = new ArrayList<String>();\r\n        ResultSet rs = meta.getCatalogs();\r\n        while (rs.next()) {\r\n            catalogs.add(rs.getString(\"TABLE_CAT\"));\r\n        }\r\n        rs.close();\r\n        return catalogs;\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings)\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getSchemas(DatabaseMetaData meta) throws SQLException {\r\n        List<String> schemas = new ArrayList<String>();\r\n        ResultSet rs = meta.getSchemas();\r\n        while (rs.next()) {\r\n            schemas.add(rs.getString(\"TABLE_SCHEM\"));\r\n        }\r\n        rs.close();\r\n        return schemas;\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings) that contain tables\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getPopulatedSchemas(DatabaseMetaData meta) throws SQLException {\r\n        return getPopulatedSchemas(meta, \".*\", false);\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings) that contain tables and\r\n     * match the <code>schemaSpec</code> regular expression\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getPopulatedSchemas(DatabaseMetaData meta, String schemaSpec, boolean isCatalog) throws SQLException {\r\n        // alpha sorted\r\n        Set<String> schemas = new TreeSet<String>();\r\n        Pattern schemaRegex = Pattern.compile(schemaSpec);\r\n        Logger logger = Logger.getLogger(DbAnalyzer.class.getName());\r\n        boolean logging = logger.isLoggable(Level.FINE);\r\n        for (String schema : (isCatalog ? getCatalogs(meta) : getSchemas(meta))) {\r\n            if (schemaRegex.matcher(schema).matches()) {\r\n                ResultSet rs = null;\r\n                try {\r\n                    rs = meta.getTables(null, schema, \"%\", null);\r\n                    if (rs.next()) {\r\n                        if (logging)\r\n                            logger.fine(\"Including schema \" + schema + \": matches + \\\"\" + schemaRegex + \"\\\" and contains tables\");\r\n                        schemas.add(schema);\r\n                    } else {\r\n                        if (logging)\r\n                            logger.fine(\"Excluding schema \" + schema + \": matches \\\"\" + schemaRegex + \"\\\" but contains no tables\");\r\n                    }\r\n                } catch (SQLException ignore) {\r\n                } finally {\r\n                    if (rs != null)\r\n                        rs.close();\r\n                }\r\n            } else {\r\n                if (logging)\r\n                    logger.fine(\"Excluding schema \" + schema + \": doesn't match \\\"\" + schemaRegex + '\"');\r\n            }\r\n        }\r\n        return new ArrayList<String>(schemas);\r\n    }\r\n\r\n    /**\r\n     * For debugging/analyzing result sets\r\n     * @param rs ResultSet\r\n     * @throws SQLException\r\n     */\r\n    public static void dumpResultSetRow(ResultSet rs, String description) throws SQLException {\r\n        ResultSetMetaData meta = rs.getMetaData();\r\n        int numColumns = meta.getColumnCount();\r\n        System.out.println(numColumns + \" columns of \" + description + \":\");\r\n        for (int i = 1; i <= numColumns; ++i) {\r\n            System.out.print(meta.getColumnLabel(i));\r\n            System.out.print(\": \");\r\n            System.out.print(String.valueOf(rs.getString(i)));\r\n            System.out.print(\"\\t\");\r\n        }\r\n        System.out.println();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/DbAnalyzerTest9.java",
		"test_prompt": "// DbAnalyzerTest9.java\npackage net.sourceforge.schemaspy;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.model.TableIndex;\nimport net.sourceforge.schemaspy.util.Inflection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DbAnalyzer}.\n* It contains ten unit test cases for the {@link DbAnalyzer#sortColumnsByTable(List)} method.\n*/\nclass DbAnalyzerTest9 {"
	},
	{
		"original_code": "// DbAnalyzer.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy;\r\n\r\nimport java.sql.DatabaseMetaData;\r\nimport java.sql.ResultSet;\r\nimport java.sql.ResultSetMetaData;\r\nimport java.sql.SQLException;\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.Collections;\r\nimport java.util.Comparator;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\nimport java.util.TreeMap;\r\nimport java.util.TreeSet;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.regex.Pattern;\r\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.Table;\r\nimport net.sourceforge.schemaspy.model.TableColumn;\r\nimport net.sourceforge.schemaspy.model.TableIndex;\r\nimport net.sourceforge.schemaspy.util.Inflection;\r\n\r\npublic class DbAnalyzer {\r\n\r\n    public static List<ImpliedForeignKeyConstraint> getImpliedConstraints(Collection<Table> tables) {\r\n        List<TableColumn> columnsWithoutParents = new ArrayList<TableColumn>();\r\n        Map<TableColumn, Table> allPrimaries = new TreeMap<TableColumn, Table>(new Comparator<TableColumn>() {\r\n\r\n            public int compare(TableColumn column1, TableColumn column2) {\r\n                int rc = column1.getName().compareToIgnoreCase(column2.getName());\r\n                if (rc == 0)\r\n                    rc = column1.getType().compareToIgnoreCase(column2.getType());\r\n                if (rc == 0)\r\n                    rc = column1.getLength() - column2.getLength();\r\n                return rc;\r\n            }\r\n        });\r\n        int duplicatePrimaries = 0;\r\n        // gather all the primary key columns and columns without parents\r\n        for (Table table : tables) {\r\n            List<TableColumn> tablePrimaries = table.getPrimaryColumns();\r\n            if (tablePrimaries.size() == 1) {\r\n                // can't match up multiples...yet...\r\n                for (TableColumn primary : tablePrimaries) {\r\n                    if (primary.allowsImpliedChildren() && allPrimaries.put(primary, table) != null)\r\n                        ++duplicatePrimaries;\r\n                }\r\n            }\r\n            for (TableColumn column : table.getColumns()) {\r\n                if (!column.isForeignKey() && column.allowsImpliedParents())\r\n                    columnsWithoutParents.add(column);\r\n            }\r\n        }\r\n        // if more than half of the tables have the same primary key then\r\n        // it's most likely a database where primary key names aren't unique\r\n        // (e.g. they all have a primary key named 'ID')\r\n        if (// bizarre logic, but it does approximately what we need\r\n        duplicatePrimaries > allPrimaries.size())\r\n            return new ArrayList<ImpliedForeignKeyConstraint>();\r\n        sortColumnsByTable(columnsWithoutParents);\r\n        List<ImpliedForeignKeyConstraint> impliedConstraints = new ArrayList<ImpliedForeignKeyConstraint>();\r\n        for (TableColumn childColumn : columnsWithoutParents) {\r\n            Table primaryTable = allPrimaries.get(childColumn);\r\n            if (primaryTable != null && primaryTable != childColumn.getTable()) {\r\n                TableColumn parentColumn = primaryTable.getColumn(childColumn.getName());\r\n                // make sure the potential child->parent relationships isn't already a\r\n                // parent->child relationship\r\n                if (parentColumn.getParentConstraint(childColumn) == null) {\r\n                    // ok, we've found a potential relationship with a column matches a primary\r\n                    // key column in another table and isn't already related to that column\r\n                    impliedConstraints.add(new ImpliedForeignKeyConstraint(parentColumn, childColumn));\r\n                }\r\n            }\r\n        }\r\n        return impliedConstraints;\r\n    }\r\n\r\n    /**\r\n     * Ruby on Rails-based databases typically have no real referential integrity\r\n     * constraints.  Instead they have a somewhat unusual way of associating\r\n     * columns to primary keys.<p>\r\n     *\r\n     * Basically all tables have a primary key named <code>ID</code>.\r\n     * All tables are named plural names.\r\n     * The columns that logically reference that <code>ID</code> are the singular\r\n     * form of the table name suffixed with <code>_ID</code>.<p>\r\n     *\r\n     * A side-effect of calling this method is that the returned collection of\r\n     * constraints will be \"tied into\" the associated tables.\r\n     *\r\n     * @param tables\r\n     * @return List of {@link RailsForeignKeyConstraint}s\r\n     */\r\n    public static List<RailsForeignKeyConstraint> getRailsConstraints(Map<String, Table> tables) {\r\n        List<RailsForeignKeyConstraint> railsConstraints = new ArrayList<RailsForeignKeyConstraint>(tables.size());\r\n        // iterate thru each column in each table looking for columns that\r\n        // match Rails naming conventions\r\n        for (Table table : tables.values()) {\r\n            for (TableColumn column : table.getColumns()) {\r\n                String columnName = column.getName().toLowerCase();\r\n                if (!column.isForeignKey() && column.allowsImpliedParents() && columnName.endsWith(\"_id\")) {\r\n                    String singular = columnName.substring(0, columnName.length() - 3);\r\n                    String primaryTableName = Inflection.pluralize(singular);\r\n                    Table primaryTable = tables.get(primaryTableName);\r\n                    if (primaryTable != null) {\r\n                        TableColumn primaryColumn = primaryTable.getColumn(\"ID\");\r\n                        if (primaryColumn != null) {\r\n                            railsConstraints.add(new RailsForeignKeyConstraint(primaryColumn, column));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return railsConstraints;\r\n    }\r\n\r\n    /**\r\n     * Returns a <code>List</code> of all of the <code>ForeignKeyConstraint</code>s\r\n     * used by the specified tables.\r\n     *\r\n     * @param tables Collection\r\n     * @return List\r\n     */\r\n    public static List<ForeignKeyConstraint> getForeignKeyConstraints(Collection<Table> tables) {\r\n        List<ForeignKeyConstraint> constraints = new ArrayList<ForeignKeyConstraint>();\r\n        for (Table table : tables) {\r\n            constraints.addAll(table.getForeignKeys());\r\n        }\r\n        return constraints;\r\n    }\r\n\r\n    public static List<Table> getOrphans(Collection<Table> tables) {\r\n        List<Table> orphans = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.isOrphan(false)) {\r\n                orphans.add(table);\r\n            }\r\n        }\r\n        return sortTablesByName(orphans);\r\n    }\r\n\r\n    /**\r\n     * Return a list of <code>TableColumn</code>s that are both nullable\r\n     * and have an index that specifies that they must be unique (a rather strange combo).\r\n     */\r\n    public static List<TableColumn> getMustBeUniqueNullableColumns(Collection<Table> tables) {\r\n        List<TableColumn> uniqueNullables = new ArrayList<TableColumn>();\r\n        for (Table table : tables) {\r\n            for (TableIndex index : table.getIndexes()) {\r\n                if (index.isUniqueNullable()) {\r\n                    uniqueNullables.addAll(index.getColumns());\r\n                }\r\n            }\r\n        }\r\n        return sortColumnsByTable(uniqueNullables);\r\n    }\r\n\r\n    /**\r\n     * Return a list of <code>Table</code>s that have neither an index nor a primary key.\r\n     */\r\n    public static List<Table> getTablesWithoutIndexes(Collection<Table> tables) {\r\n        List<Table> withoutIndexes = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.getIndexes().size() == 0 && !table.isView() && !table.isLogical())\r\n                withoutIndexes.add(table);\r\n        }\r\n        return sortTablesByName(withoutIndexes);\r\n    }\r\n\r\n    public static List<Table> getTablesWithIncrementingColumnNames(Collection<Table> tables) {\r\n        List<Table> denormalizedTables = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            Map<String, Long> columnPrefixes = new HashMap<String, Long>();\r\n            for (TableColumn column : table.getColumns()) {\r\n                // search for columns that start with the same prefix\r\n                // and end in an incrementing number\r\n                String columnName = column.getName();\r\n                String numbers = null;\r\n                for (int i = columnName.length() - 1; i > 0; --i) {\r\n                    if (Character.isDigit(columnName.charAt(i))) {\r\n                        numbers = String.valueOf(columnName.charAt(i)) + (numbers == null ? \"\" : numbers);\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n                // attempt to detect where they had an existing column\r\n                // and added a \"column2\" type of column (we'll call this one \"1\")\r\n                if (numbers == null) {\r\n                    numbers = \"1\";\r\n                    columnName = columnName + numbers;\r\n                }\r\n                // see if we've already found a column with the same prefix\r\n                // that had a numeric suffix +/- 1.\r\n                String prefix = columnName.substring(0, columnName.length() - numbers.length());\r\n                long numeric = Long.parseLong(numbers);\r\n                Long existing = columnPrefixes.get(prefix);\r\n                if (existing != null && Math.abs(existing.longValue() - numeric) == 1) {\r\n                    // found one so add it to our list and stop evaluating this table\r\n                    denormalizedTables.add(table);\r\n                    break;\r\n                }\r\n                columnPrefixes.put(prefix, new Long(numeric));\r\n            }\r\n        }\r\n        return sortTablesByName(denormalizedTables);\r\n    }\r\n\r\n    public static List<Table> getTablesWithOneColumn(Collection<Table> tables) {\r\n        List<Table> singleColumnTables = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.getColumns().size() == 1)\r\n                singleColumnTables.add(table);\r\n        }\r\n        return sortTablesByName(singleColumnTables);\r\n    }\r\n\r\n    public static List<Table> sortTablesByName(List<Table> tables) {\r\n        Collections.sort(tables, new Comparator<Table>() {\r\n\r\n            public int compare(Table table1, Table table2) {\r\n                return table1.compareTo(table2);\r\n            }\r\n        });\r\n        return tables;\r\n    }\r\n\r\n    public static List<TableColumn> sortColumnsByTable(List<TableColumn> columns) {\r\n        Collections.sort(columns, new Comparator<TableColumn>() {\r\n\r\n            public int compare(TableColumn column1, TableColumn column2) {\r\n                int rc = column1.getTable().compareTo(column2.getTable());\r\n                if (rc == 0)\r\n                    rc = column1.getName().compareToIgnoreCase(column2.getName());\r\n                return rc;\r\n            }\r\n        });\r\n        return columns;\r\n    }\r\n\r\n    /**\r\n     * Returns a list of columns that have the word \"NULL\" or \"null\" as their default value\r\n     * instead of the likely candidate value null.\r\n     *\r\n     * @param tables Collection\r\n     * @return List\r\n     */\r\n    public static List<TableColumn> getDefaultNullStringColumns(Collection<Table> tables) {\r\n        List<TableColumn> defaultNullStringColumns = new ArrayList<TableColumn>();\r\n        for (Table table : tables) {\r\n            for (TableColumn column : table.getColumns()) {\r\n                Object defaultValue = column.getDefaultValue();\r\n                if (defaultValue != null && defaultValue instanceof String) {\r\n                    String defaultString = defaultValue.toString();\r\n                    if (defaultString.trim().equalsIgnoreCase(\"'null'\")) {\r\n                        defaultNullStringColumns.add(column);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return sortColumnsByTable(defaultNullStringColumns);\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of catalog names (Strings)\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getCatalogs(DatabaseMetaData meta) throws SQLException {\r\n        List<String> catalogs = new ArrayList<String>();\r\n        ResultSet rs = meta.getCatalogs();\r\n        while (rs.next()) {\r\n            catalogs.add(rs.getString(\"TABLE_CAT\"));\r\n        }\r\n        rs.close();\r\n        return catalogs;\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings)\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getSchemas(DatabaseMetaData meta) throws SQLException {\r\n        List<String> schemas = new ArrayList<String>();\r\n        ResultSet rs = meta.getSchemas();\r\n        while (rs.next()) {\r\n            schemas.add(rs.getString(\"TABLE_SCHEM\"));\r\n        }\r\n        rs.close();\r\n        return schemas;\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings) that contain tables\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getPopulatedSchemas(DatabaseMetaData meta) throws SQLException {\r\n        return getPopulatedSchemas(meta, \".*\", false);\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings) that contain tables and\r\n     * match the <code>schemaSpec</code> regular expression\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getPopulatedSchemas(DatabaseMetaData meta, String schemaSpec, boolean isCatalog) throws SQLException {\r\n        // alpha sorted\r\n        Set<String> schemas = new TreeSet<String>();\r\n        Pattern schemaRegex = Pattern.compile(schemaSpec);\r\n        Logger logger = Logger.getLogger(DbAnalyzer.class.getName());\r\n        boolean logging = logger.isLoggable(Level.FINE);\r\n        for (String schema : (isCatalog ? getCatalogs(meta) : getSchemas(meta))) {\r\n            if (schemaRegex.matcher(schema).matches()) {\r\n                ResultSet rs = null;\r\n                try {\r\n                    rs = meta.getTables(null, schema, \"%\", null);\r\n                    if (rs.next()) {\r\n                        if (logging)\r\n                            logger.fine(\"Including schema \" + schema + \": matches + \\\"\" + schemaRegex + \"\\\" and contains tables\");\r\n                        schemas.add(schema);\r\n                    } else {\r\n                        if (logging)\r\n                            logger.fine(\"Excluding schema \" + schema + \": matches \\\"\" + schemaRegex + \"\\\" but contains no tables\");\r\n                    }\r\n                } catch (SQLException ignore) {\r\n                } finally {\r\n                    if (rs != null)\r\n                        rs.close();\r\n                }\r\n            } else {\r\n                if (logging)\r\n                    logger.fine(\"Excluding schema \" + schema + \": doesn't match \\\"\" + schemaRegex + '\"');\r\n            }\r\n        }\r\n        return new ArrayList<String>(schemas);\r\n    }\r\n\r\n    /**\r\n     * For debugging/analyzing result sets\r\n     * @param rs ResultSet\r\n     * @throws SQLException\r\n     */\r\n    public static void dumpResultSetRow(ResultSet rs, String description) throws SQLException {\r\n        ResultSetMetaData meta = rs.getMetaData();\r\n        int numColumns = meta.getColumnCount();\r\n        System.out.println(numColumns + \" columns of \" + description + \":\");\r\n        for (int i = 1; i <= numColumns; ++i) {\r\n            System.out.print(meta.getColumnLabel(i));\r\n            System.out.print(\": \");\r\n            System.out.print(String.valueOf(rs.getString(i)));\r\n            System.out.print(\"\\t\");\r\n        }\r\n        System.out.println();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/DbAnalyzerTest10.java",
		"test_prompt": "// DbAnalyzerTest10.java\npackage net.sourceforge.schemaspy;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.model.TableIndex;\nimport net.sourceforge.schemaspy.util.Inflection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DbAnalyzer}.\n* It contains ten unit test cases for the {@link DbAnalyzer#getDefaultNullStringColumns(Collection)} method.\n*/\nclass DbAnalyzerTest10 {"
	},
	{
		"original_code": "// DbAnalyzer.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy;\r\n\r\nimport java.sql.DatabaseMetaData;\r\nimport java.sql.ResultSet;\r\nimport java.sql.ResultSetMetaData;\r\nimport java.sql.SQLException;\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.Collections;\r\nimport java.util.Comparator;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\nimport java.util.TreeMap;\r\nimport java.util.TreeSet;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.regex.Pattern;\r\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.Table;\r\nimport net.sourceforge.schemaspy.model.TableColumn;\r\nimport net.sourceforge.schemaspy.model.TableIndex;\r\nimport net.sourceforge.schemaspy.util.Inflection;\r\n\r\npublic class DbAnalyzer {\r\n\r\n    public static List<ImpliedForeignKeyConstraint> getImpliedConstraints(Collection<Table> tables) {\r\n        List<TableColumn> columnsWithoutParents = new ArrayList<TableColumn>();\r\n        Map<TableColumn, Table> allPrimaries = new TreeMap<TableColumn, Table>(new Comparator<TableColumn>() {\r\n\r\n            public int compare(TableColumn column1, TableColumn column2) {\r\n                int rc = column1.getName().compareToIgnoreCase(column2.getName());\r\n                if (rc == 0)\r\n                    rc = column1.getType().compareToIgnoreCase(column2.getType());\r\n                if (rc == 0)\r\n                    rc = column1.getLength() - column2.getLength();\r\n                return rc;\r\n            }\r\n        });\r\n        int duplicatePrimaries = 0;\r\n        // gather all the primary key columns and columns without parents\r\n        for (Table table : tables) {\r\n            List<TableColumn> tablePrimaries = table.getPrimaryColumns();\r\n            if (tablePrimaries.size() == 1) {\r\n                // can't match up multiples...yet...\r\n                for (TableColumn primary : tablePrimaries) {\r\n                    if (primary.allowsImpliedChildren() && allPrimaries.put(primary, table) != null)\r\n                        ++duplicatePrimaries;\r\n                }\r\n            }\r\n            for (TableColumn column : table.getColumns()) {\r\n                if (!column.isForeignKey() && column.allowsImpliedParents())\r\n                    columnsWithoutParents.add(column);\r\n            }\r\n        }\r\n        // if more than half of the tables have the same primary key then\r\n        // it's most likely a database where primary key names aren't unique\r\n        // (e.g. they all have a primary key named 'ID')\r\n        if (// bizarre logic, but it does approximately what we need\r\n        duplicatePrimaries > allPrimaries.size())\r\n            return new ArrayList<ImpliedForeignKeyConstraint>();\r\n        sortColumnsByTable(columnsWithoutParents);\r\n        List<ImpliedForeignKeyConstraint> impliedConstraints = new ArrayList<ImpliedForeignKeyConstraint>();\r\n        for (TableColumn childColumn : columnsWithoutParents) {\r\n            Table primaryTable = allPrimaries.get(childColumn);\r\n            if (primaryTable != null && primaryTable != childColumn.getTable()) {\r\n                TableColumn parentColumn = primaryTable.getColumn(childColumn.getName());\r\n                // make sure the potential child->parent relationships isn't already a\r\n                // parent->child relationship\r\n                if (parentColumn.getParentConstraint(childColumn) == null) {\r\n                    // ok, we've found a potential relationship with a column matches a primary\r\n                    // key column in another table and isn't already related to that column\r\n                    impliedConstraints.add(new ImpliedForeignKeyConstraint(parentColumn, childColumn));\r\n                }\r\n            }\r\n        }\r\n        return impliedConstraints;\r\n    }\r\n\r\n    /**\r\n     * Ruby on Rails-based databases typically have no real referential integrity\r\n     * constraints.  Instead they have a somewhat unusual way of associating\r\n     * columns to primary keys.<p>\r\n     *\r\n     * Basically all tables have a primary key named <code>ID</code>.\r\n     * All tables are named plural names.\r\n     * The columns that logically reference that <code>ID</code> are the singular\r\n     * form of the table name suffixed with <code>_ID</code>.<p>\r\n     *\r\n     * A side-effect of calling this method is that the returned collection of\r\n     * constraints will be \"tied into\" the associated tables.\r\n     *\r\n     * @param tables\r\n     * @return List of {@link RailsForeignKeyConstraint}s\r\n     */\r\n    public static List<RailsForeignKeyConstraint> getRailsConstraints(Map<String, Table> tables) {\r\n        List<RailsForeignKeyConstraint> railsConstraints = new ArrayList<RailsForeignKeyConstraint>(tables.size());\r\n        // iterate thru each column in each table looking for columns that\r\n        // match Rails naming conventions\r\n        for (Table table : tables.values()) {\r\n            for (TableColumn column : table.getColumns()) {\r\n                String columnName = column.getName().toLowerCase();\r\n                if (!column.isForeignKey() && column.allowsImpliedParents() && columnName.endsWith(\"_id\")) {\r\n                    String singular = columnName.substring(0, columnName.length() - 3);\r\n                    String primaryTableName = Inflection.pluralize(singular);\r\n                    Table primaryTable = tables.get(primaryTableName);\r\n                    if (primaryTable != null) {\r\n                        TableColumn primaryColumn = primaryTable.getColumn(\"ID\");\r\n                        if (primaryColumn != null) {\r\n                            railsConstraints.add(new RailsForeignKeyConstraint(primaryColumn, column));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return railsConstraints;\r\n    }\r\n\r\n    /**\r\n     * Returns a <code>List</code> of all of the <code>ForeignKeyConstraint</code>s\r\n     * used by the specified tables.\r\n     *\r\n     * @param tables Collection\r\n     * @return List\r\n     */\r\n    public static List<ForeignKeyConstraint> getForeignKeyConstraints(Collection<Table> tables) {\r\n        List<ForeignKeyConstraint> constraints = new ArrayList<ForeignKeyConstraint>();\r\n        for (Table table : tables) {\r\n            constraints.addAll(table.getForeignKeys());\r\n        }\r\n        return constraints;\r\n    }\r\n\r\n    public static List<Table> getOrphans(Collection<Table> tables) {\r\n        List<Table> orphans = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.isOrphan(false)) {\r\n                orphans.add(table);\r\n            }\r\n        }\r\n        return sortTablesByName(orphans);\r\n    }\r\n\r\n    /**\r\n     * Return a list of <code>TableColumn</code>s that are both nullable\r\n     * and have an index that specifies that they must be unique (a rather strange combo).\r\n     */\r\n    public static List<TableColumn> getMustBeUniqueNullableColumns(Collection<Table> tables) {\r\n        List<TableColumn> uniqueNullables = new ArrayList<TableColumn>();\r\n        for (Table table : tables) {\r\n            for (TableIndex index : table.getIndexes()) {\r\n                if (index.isUniqueNullable()) {\r\n                    uniqueNullables.addAll(index.getColumns());\r\n                }\r\n            }\r\n        }\r\n        return sortColumnsByTable(uniqueNullables);\r\n    }\r\n\r\n    /**\r\n     * Return a list of <code>Table</code>s that have neither an index nor a primary key.\r\n     */\r\n    public static List<Table> getTablesWithoutIndexes(Collection<Table> tables) {\r\n        List<Table> withoutIndexes = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.getIndexes().size() == 0 && !table.isView() && !table.isLogical())\r\n                withoutIndexes.add(table);\r\n        }\r\n        return sortTablesByName(withoutIndexes);\r\n    }\r\n\r\n    public static List<Table> getTablesWithIncrementingColumnNames(Collection<Table> tables) {\r\n        List<Table> denormalizedTables = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            Map<String, Long> columnPrefixes = new HashMap<String, Long>();\r\n            for (TableColumn column : table.getColumns()) {\r\n                // search for columns that start with the same prefix\r\n                // and end in an incrementing number\r\n                String columnName = column.getName();\r\n                String numbers = null;\r\n                for (int i = columnName.length() - 1; i > 0; --i) {\r\n                    if (Character.isDigit(columnName.charAt(i))) {\r\n                        numbers = String.valueOf(columnName.charAt(i)) + (numbers == null ? \"\" : numbers);\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n                // attempt to detect where they had an existing column\r\n                // and added a \"column2\" type of column (we'll call this one \"1\")\r\n                if (numbers == null) {\r\n                    numbers = \"1\";\r\n                    columnName = columnName + numbers;\r\n                }\r\n                // see if we've already found a column with the same prefix\r\n                // that had a numeric suffix +/- 1.\r\n                String prefix = columnName.substring(0, columnName.length() - numbers.length());\r\n                long numeric = Long.parseLong(numbers);\r\n                Long existing = columnPrefixes.get(prefix);\r\n                if (existing != null && Math.abs(existing.longValue() - numeric) == 1) {\r\n                    // found one so add it to our list and stop evaluating this table\r\n                    denormalizedTables.add(table);\r\n                    break;\r\n                }\r\n                columnPrefixes.put(prefix, new Long(numeric));\r\n            }\r\n        }\r\n        return sortTablesByName(denormalizedTables);\r\n    }\r\n\r\n    public static List<Table> getTablesWithOneColumn(Collection<Table> tables) {\r\n        List<Table> singleColumnTables = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.getColumns().size() == 1)\r\n                singleColumnTables.add(table);\r\n        }\r\n        return sortTablesByName(singleColumnTables);\r\n    }\r\n\r\n    public static List<Table> sortTablesByName(List<Table> tables) {\r\n        Collections.sort(tables, new Comparator<Table>() {\r\n\r\n            public int compare(Table table1, Table table2) {\r\n                return table1.compareTo(table2);\r\n            }\r\n        });\r\n        return tables;\r\n    }\r\n\r\n    public static List<TableColumn> sortColumnsByTable(List<TableColumn> columns) {\r\n        Collections.sort(columns, new Comparator<TableColumn>() {\r\n\r\n            public int compare(TableColumn column1, TableColumn column2) {\r\n                int rc = column1.getTable().compareTo(column2.getTable());\r\n                if (rc == 0)\r\n                    rc = column1.getName().compareToIgnoreCase(column2.getName());\r\n                return rc;\r\n            }\r\n        });\r\n        return columns;\r\n    }\r\n\r\n    /**\r\n     * Returns a list of columns that have the word \"NULL\" or \"null\" as their default value\r\n     * instead of the likely candidate value null.\r\n     *\r\n     * @param tables Collection\r\n     * @return List\r\n     */\r\n    public static List<TableColumn> getDefaultNullStringColumns(Collection<Table> tables) {\r\n        List<TableColumn> defaultNullStringColumns = new ArrayList<TableColumn>();\r\n        for (Table table : tables) {\r\n            for (TableColumn column : table.getColumns()) {\r\n                Object defaultValue = column.getDefaultValue();\r\n                if (defaultValue != null && defaultValue instanceof String) {\r\n                    String defaultString = defaultValue.toString();\r\n                    if (defaultString.trim().equalsIgnoreCase(\"'null'\")) {\r\n                        defaultNullStringColumns.add(column);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return sortColumnsByTable(defaultNullStringColumns);\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of catalog names (Strings)\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getCatalogs(DatabaseMetaData meta) throws SQLException {\r\n        List<String> catalogs = new ArrayList<String>();\r\n        ResultSet rs = meta.getCatalogs();\r\n        while (rs.next()) {\r\n            catalogs.add(rs.getString(\"TABLE_CAT\"));\r\n        }\r\n        rs.close();\r\n        return catalogs;\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings)\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getSchemas(DatabaseMetaData meta) throws SQLException {\r\n        List<String> schemas = new ArrayList<String>();\r\n        ResultSet rs = meta.getSchemas();\r\n        while (rs.next()) {\r\n            schemas.add(rs.getString(\"TABLE_SCHEM\"));\r\n        }\r\n        rs.close();\r\n        return schemas;\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings) that contain tables\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getPopulatedSchemas(DatabaseMetaData meta) throws SQLException {\r\n        return getPopulatedSchemas(meta, \".*\", false);\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings) that contain tables and\r\n     * match the <code>schemaSpec</code> regular expression\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getPopulatedSchemas(DatabaseMetaData meta, String schemaSpec, boolean isCatalog) throws SQLException {\r\n        // alpha sorted\r\n        Set<String> schemas = new TreeSet<String>();\r\n        Pattern schemaRegex = Pattern.compile(schemaSpec);\r\n        Logger logger = Logger.getLogger(DbAnalyzer.class.getName());\r\n        boolean logging = logger.isLoggable(Level.FINE);\r\n        for (String schema : (isCatalog ? getCatalogs(meta) : getSchemas(meta))) {\r\n            if (schemaRegex.matcher(schema).matches()) {\r\n                ResultSet rs = null;\r\n                try {\r\n                    rs = meta.getTables(null, schema, \"%\", null);\r\n                    if (rs.next()) {\r\n                        if (logging)\r\n                            logger.fine(\"Including schema \" + schema + \": matches + \\\"\" + schemaRegex + \"\\\" and contains tables\");\r\n                        schemas.add(schema);\r\n                    } else {\r\n                        if (logging)\r\n                            logger.fine(\"Excluding schema \" + schema + \": matches \\\"\" + schemaRegex + \"\\\" but contains no tables\");\r\n                    }\r\n                } catch (SQLException ignore) {\r\n                } finally {\r\n                    if (rs != null)\r\n                        rs.close();\r\n                }\r\n            } else {\r\n                if (logging)\r\n                    logger.fine(\"Excluding schema \" + schema + \": doesn't match \\\"\" + schemaRegex + '\"');\r\n            }\r\n        }\r\n        return new ArrayList<String>(schemas);\r\n    }\r\n\r\n    /**\r\n     * For debugging/analyzing result sets\r\n     * @param rs ResultSet\r\n     * @throws SQLException\r\n     */\r\n    public static void dumpResultSetRow(ResultSet rs, String description) throws SQLException {\r\n        ResultSetMetaData meta = rs.getMetaData();\r\n        int numColumns = meta.getColumnCount();\r\n        System.out.println(numColumns + \" columns of \" + description + \":\");\r\n        for (int i = 1; i <= numColumns; ++i) {\r\n            System.out.print(meta.getColumnLabel(i));\r\n            System.out.print(\": \");\r\n            System.out.print(String.valueOf(rs.getString(i)));\r\n            System.out.print(\"\\t\");\r\n        }\r\n        System.out.println();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/DbAnalyzerTest11.java",
		"test_prompt": "// DbAnalyzerTest11.java\npackage net.sourceforge.schemaspy;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.model.TableIndex;\nimport net.sourceforge.schemaspy.util.Inflection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DbAnalyzer}.\n* It contains ten unit test cases for the {@link DbAnalyzer#getCatalogs(DatabaseMetaData)} method.\n*/\nclass DbAnalyzerTest11 {"
	},
	{
		"original_code": "// DbAnalyzer.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy;\r\n\r\nimport java.sql.DatabaseMetaData;\r\nimport java.sql.ResultSet;\r\nimport java.sql.ResultSetMetaData;\r\nimport java.sql.SQLException;\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.Collections;\r\nimport java.util.Comparator;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\nimport java.util.TreeMap;\r\nimport java.util.TreeSet;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.regex.Pattern;\r\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.Table;\r\nimport net.sourceforge.schemaspy.model.TableColumn;\r\nimport net.sourceforge.schemaspy.model.TableIndex;\r\nimport net.sourceforge.schemaspy.util.Inflection;\r\n\r\npublic class DbAnalyzer {\r\n\r\n    public static List<ImpliedForeignKeyConstraint> getImpliedConstraints(Collection<Table> tables) {\r\n        List<TableColumn> columnsWithoutParents = new ArrayList<TableColumn>();\r\n        Map<TableColumn, Table> allPrimaries = new TreeMap<TableColumn, Table>(new Comparator<TableColumn>() {\r\n\r\n            public int compare(TableColumn column1, TableColumn column2) {\r\n                int rc = column1.getName().compareToIgnoreCase(column2.getName());\r\n                if (rc == 0)\r\n                    rc = column1.getType().compareToIgnoreCase(column2.getType());\r\n                if (rc == 0)\r\n                    rc = column1.getLength() - column2.getLength();\r\n                return rc;\r\n            }\r\n        });\r\n        int duplicatePrimaries = 0;\r\n        // gather all the primary key columns and columns without parents\r\n        for (Table table : tables) {\r\n            List<TableColumn> tablePrimaries = table.getPrimaryColumns();\r\n            if (tablePrimaries.size() == 1) {\r\n                // can't match up multiples...yet...\r\n                for (TableColumn primary : tablePrimaries) {\r\n                    if (primary.allowsImpliedChildren() && allPrimaries.put(primary, table) != null)\r\n                        ++duplicatePrimaries;\r\n                }\r\n            }\r\n            for (TableColumn column : table.getColumns()) {\r\n                if (!column.isForeignKey() && column.allowsImpliedParents())\r\n                    columnsWithoutParents.add(column);\r\n            }\r\n        }\r\n        // if more than half of the tables have the same primary key then\r\n        // it's most likely a database where primary key names aren't unique\r\n        // (e.g. they all have a primary key named 'ID')\r\n        if (// bizarre logic, but it does approximately what we need\r\n        duplicatePrimaries > allPrimaries.size())\r\n            return new ArrayList<ImpliedForeignKeyConstraint>();\r\n        sortColumnsByTable(columnsWithoutParents);\r\n        List<ImpliedForeignKeyConstraint> impliedConstraints = new ArrayList<ImpliedForeignKeyConstraint>();\r\n        for (TableColumn childColumn : columnsWithoutParents) {\r\n            Table primaryTable = allPrimaries.get(childColumn);\r\n            if (primaryTable != null && primaryTable != childColumn.getTable()) {\r\n                TableColumn parentColumn = primaryTable.getColumn(childColumn.getName());\r\n                // make sure the potential child->parent relationships isn't already a\r\n                // parent->child relationship\r\n                if (parentColumn.getParentConstraint(childColumn) == null) {\r\n                    // ok, we've found a potential relationship with a column matches a primary\r\n                    // key column in another table and isn't already related to that column\r\n                    impliedConstraints.add(new ImpliedForeignKeyConstraint(parentColumn, childColumn));\r\n                }\r\n            }\r\n        }\r\n        return impliedConstraints;\r\n    }\r\n\r\n    /**\r\n     * Ruby on Rails-based databases typically have no real referential integrity\r\n     * constraints.  Instead they have a somewhat unusual way of associating\r\n     * columns to primary keys.<p>\r\n     *\r\n     * Basically all tables have a primary key named <code>ID</code>.\r\n     * All tables are named plural names.\r\n     * The columns that logically reference that <code>ID</code> are the singular\r\n     * form of the table name suffixed with <code>_ID</code>.<p>\r\n     *\r\n     * A side-effect of calling this method is that the returned collection of\r\n     * constraints will be \"tied into\" the associated tables.\r\n     *\r\n     * @param tables\r\n     * @return List of {@link RailsForeignKeyConstraint}s\r\n     */\r\n    public static List<RailsForeignKeyConstraint> getRailsConstraints(Map<String, Table> tables) {\r\n        List<RailsForeignKeyConstraint> railsConstraints = new ArrayList<RailsForeignKeyConstraint>(tables.size());\r\n        // iterate thru each column in each table looking for columns that\r\n        // match Rails naming conventions\r\n        for (Table table : tables.values()) {\r\n            for (TableColumn column : table.getColumns()) {\r\n                String columnName = column.getName().toLowerCase();\r\n                if (!column.isForeignKey() && column.allowsImpliedParents() && columnName.endsWith(\"_id\")) {\r\n                    String singular = columnName.substring(0, columnName.length() - 3);\r\n                    String primaryTableName = Inflection.pluralize(singular);\r\n                    Table primaryTable = tables.get(primaryTableName);\r\n                    if (primaryTable != null) {\r\n                        TableColumn primaryColumn = primaryTable.getColumn(\"ID\");\r\n                        if (primaryColumn != null) {\r\n                            railsConstraints.add(new RailsForeignKeyConstraint(primaryColumn, column));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return railsConstraints;\r\n    }\r\n\r\n    /**\r\n     * Returns a <code>List</code> of all of the <code>ForeignKeyConstraint</code>s\r\n     * used by the specified tables.\r\n     *\r\n     * @param tables Collection\r\n     * @return List\r\n     */\r\n    public static List<ForeignKeyConstraint> getForeignKeyConstraints(Collection<Table> tables) {\r\n        List<ForeignKeyConstraint> constraints = new ArrayList<ForeignKeyConstraint>();\r\n        for (Table table : tables) {\r\n            constraints.addAll(table.getForeignKeys());\r\n        }\r\n        return constraints;\r\n    }\r\n\r\n    public static List<Table> getOrphans(Collection<Table> tables) {\r\n        List<Table> orphans = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.isOrphan(false)) {\r\n                orphans.add(table);\r\n            }\r\n        }\r\n        return sortTablesByName(orphans);\r\n    }\r\n\r\n    /**\r\n     * Return a list of <code>TableColumn</code>s that are both nullable\r\n     * and have an index that specifies that they must be unique (a rather strange combo).\r\n     */\r\n    public static List<TableColumn> getMustBeUniqueNullableColumns(Collection<Table> tables) {\r\n        List<TableColumn> uniqueNullables = new ArrayList<TableColumn>();\r\n        for (Table table : tables) {\r\n            for (TableIndex index : table.getIndexes()) {\r\n                if (index.isUniqueNullable()) {\r\n                    uniqueNullables.addAll(index.getColumns());\r\n                }\r\n            }\r\n        }\r\n        return sortColumnsByTable(uniqueNullables);\r\n    }\r\n\r\n    /**\r\n     * Return a list of <code>Table</code>s that have neither an index nor a primary key.\r\n     */\r\n    public static List<Table> getTablesWithoutIndexes(Collection<Table> tables) {\r\n        List<Table> withoutIndexes = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.getIndexes().size() == 0 && !table.isView() && !table.isLogical())\r\n                withoutIndexes.add(table);\r\n        }\r\n        return sortTablesByName(withoutIndexes);\r\n    }\r\n\r\n    public static List<Table> getTablesWithIncrementingColumnNames(Collection<Table> tables) {\r\n        List<Table> denormalizedTables = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            Map<String, Long> columnPrefixes = new HashMap<String, Long>();\r\n            for (TableColumn column : table.getColumns()) {\r\n                // search for columns that start with the same prefix\r\n                // and end in an incrementing number\r\n                String columnName = column.getName();\r\n                String numbers = null;\r\n                for (int i = columnName.length() - 1; i > 0; --i) {\r\n                    if (Character.isDigit(columnName.charAt(i))) {\r\n                        numbers = String.valueOf(columnName.charAt(i)) + (numbers == null ? \"\" : numbers);\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n                // attempt to detect where they had an existing column\r\n                // and added a \"column2\" type of column (we'll call this one \"1\")\r\n                if (numbers == null) {\r\n                    numbers = \"1\";\r\n                    columnName = columnName + numbers;\r\n                }\r\n                // see if we've already found a column with the same prefix\r\n                // that had a numeric suffix +/- 1.\r\n                String prefix = columnName.substring(0, columnName.length() - numbers.length());\r\n                long numeric = Long.parseLong(numbers);\r\n                Long existing = columnPrefixes.get(prefix);\r\n                if (existing != null && Math.abs(existing.longValue() - numeric) == 1) {\r\n                    // found one so add it to our list and stop evaluating this table\r\n                    denormalizedTables.add(table);\r\n                    break;\r\n                }\r\n                columnPrefixes.put(prefix, new Long(numeric));\r\n            }\r\n        }\r\n        return sortTablesByName(denormalizedTables);\r\n    }\r\n\r\n    public static List<Table> getTablesWithOneColumn(Collection<Table> tables) {\r\n        List<Table> singleColumnTables = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.getColumns().size() == 1)\r\n                singleColumnTables.add(table);\r\n        }\r\n        return sortTablesByName(singleColumnTables);\r\n    }\r\n\r\n    public static List<Table> sortTablesByName(List<Table> tables) {\r\n        Collections.sort(tables, new Comparator<Table>() {\r\n\r\n            public int compare(Table table1, Table table2) {\r\n                return table1.compareTo(table2);\r\n            }\r\n        });\r\n        return tables;\r\n    }\r\n\r\n    public static List<TableColumn> sortColumnsByTable(List<TableColumn> columns) {\r\n        Collections.sort(columns, new Comparator<TableColumn>() {\r\n\r\n            public int compare(TableColumn column1, TableColumn column2) {\r\n                int rc = column1.getTable().compareTo(column2.getTable());\r\n                if (rc == 0)\r\n                    rc = column1.getName().compareToIgnoreCase(column2.getName());\r\n                return rc;\r\n            }\r\n        });\r\n        return columns;\r\n    }\r\n\r\n    /**\r\n     * Returns a list of columns that have the word \"NULL\" or \"null\" as their default value\r\n     * instead of the likely candidate value null.\r\n     *\r\n     * @param tables Collection\r\n     * @return List\r\n     */\r\n    public static List<TableColumn> getDefaultNullStringColumns(Collection<Table> tables) {\r\n        List<TableColumn> defaultNullStringColumns = new ArrayList<TableColumn>();\r\n        for (Table table : tables) {\r\n            for (TableColumn column : table.getColumns()) {\r\n                Object defaultValue = column.getDefaultValue();\r\n                if (defaultValue != null && defaultValue instanceof String) {\r\n                    String defaultString = defaultValue.toString();\r\n                    if (defaultString.trim().equalsIgnoreCase(\"'null'\")) {\r\n                        defaultNullStringColumns.add(column);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return sortColumnsByTable(defaultNullStringColumns);\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of catalog names (Strings)\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getCatalogs(DatabaseMetaData meta) throws SQLException {\r\n        List<String> catalogs = new ArrayList<String>();\r\n        ResultSet rs = meta.getCatalogs();\r\n        while (rs.next()) {\r\n            catalogs.add(rs.getString(\"TABLE_CAT\"));\r\n        }\r\n        rs.close();\r\n        return catalogs;\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings)\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getSchemas(DatabaseMetaData meta) throws SQLException {\r\n        List<String> schemas = new ArrayList<String>();\r\n        ResultSet rs = meta.getSchemas();\r\n        while (rs.next()) {\r\n            schemas.add(rs.getString(\"TABLE_SCHEM\"));\r\n        }\r\n        rs.close();\r\n        return schemas;\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings) that contain tables\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getPopulatedSchemas(DatabaseMetaData meta) throws SQLException {\r\n        return getPopulatedSchemas(meta, \".*\", false);\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings) that contain tables and\r\n     * match the <code>schemaSpec</code> regular expression\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getPopulatedSchemas(DatabaseMetaData meta, String schemaSpec, boolean isCatalog) throws SQLException {\r\n        // alpha sorted\r\n        Set<String> schemas = new TreeSet<String>();\r\n        Pattern schemaRegex = Pattern.compile(schemaSpec);\r\n        Logger logger = Logger.getLogger(DbAnalyzer.class.getName());\r\n        boolean logging = logger.isLoggable(Level.FINE);\r\n        for (String schema : (isCatalog ? getCatalogs(meta) : getSchemas(meta))) {\r\n            if (schemaRegex.matcher(schema).matches()) {\r\n                ResultSet rs = null;\r\n                try {\r\n                    rs = meta.getTables(null, schema, \"%\", null);\r\n                    if (rs.next()) {\r\n                        if (logging)\r\n                            logger.fine(\"Including schema \" + schema + \": matches + \\\"\" + schemaRegex + \"\\\" and contains tables\");\r\n                        schemas.add(schema);\r\n                    } else {\r\n                        if (logging)\r\n                            logger.fine(\"Excluding schema \" + schema + \": matches \\\"\" + schemaRegex + \"\\\" but contains no tables\");\r\n                    }\r\n                } catch (SQLException ignore) {\r\n                } finally {\r\n                    if (rs != null)\r\n                        rs.close();\r\n                }\r\n            } else {\r\n                if (logging)\r\n                    logger.fine(\"Excluding schema \" + schema + \": doesn't match \\\"\" + schemaRegex + '\"');\r\n            }\r\n        }\r\n        return new ArrayList<String>(schemas);\r\n    }\r\n\r\n    /**\r\n     * For debugging/analyzing result sets\r\n     * @param rs ResultSet\r\n     * @throws SQLException\r\n     */\r\n    public static void dumpResultSetRow(ResultSet rs, String description) throws SQLException {\r\n        ResultSetMetaData meta = rs.getMetaData();\r\n        int numColumns = meta.getColumnCount();\r\n        System.out.println(numColumns + \" columns of \" + description + \":\");\r\n        for (int i = 1; i <= numColumns; ++i) {\r\n            System.out.print(meta.getColumnLabel(i));\r\n            System.out.print(\": \");\r\n            System.out.print(String.valueOf(rs.getString(i)));\r\n            System.out.print(\"\\t\");\r\n        }\r\n        System.out.println();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/DbAnalyzerTest12.java",
		"test_prompt": "// DbAnalyzerTest12.java\npackage net.sourceforge.schemaspy;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.model.TableIndex;\nimport net.sourceforge.schemaspy.util.Inflection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DbAnalyzer}.\n* It contains ten unit test cases for the {@link DbAnalyzer#getSchemas(DatabaseMetaData)} method.\n*/\nclass DbAnalyzerTest12 {"
	},
	{
		"original_code": "// DbAnalyzer.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy;\r\n\r\nimport java.sql.DatabaseMetaData;\r\nimport java.sql.ResultSet;\r\nimport java.sql.ResultSetMetaData;\r\nimport java.sql.SQLException;\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.Collections;\r\nimport java.util.Comparator;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\nimport java.util.TreeMap;\r\nimport java.util.TreeSet;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.regex.Pattern;\r\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.Table;\r\nimport net.sourceforge.schemaspy.model.TableColumn;\r\nimport net.sourceforge.schemaspy.model.TableIndex;\r\nimport net.sourceforge.schemaspy.util.Inflection;\r\n\r\npublic class DbAnalyzer {\r\n\r\n    public static List<ImpliedForeignKeyConstraint> getImpliedConstraints(Collection<Table> tables) {\r\n        List<TableColumn> columnsWithoutParents = new ArrayList<TableColumn>();\r\n        Map<TableColumn, Table> allPrimaries = new TreeMap<TableColumn, Table>(new Comparator<TableColumn>() {\r\n\r\n            public int compare(TableColumn column1, TableColumn column2) {\r\n                int rc = column1.getName().compareToIgnoreCase(column2.getName());\r\n                if (rc == 0)\r\n                    rc = column1.getType().compareToIgnoreCase(column2.getType());\r\n                if (rc == 0)\r\n                    rc = column1.getLength() - column2.getLength();\r\n                return rc;\r\n            }\r\n        });\r\n        int duplicatePrimaries = 0;\r\n        // gather all the primary key columns and columns without parents\r\n        for (Table table : tables) {\r\n            List<TableColumn> tablePrimaries = table.getPrimaryColumns();\r\n            if (tablePrimaries.size() == 1) {\r\n                // can't match up multiples...yet...\r\n                for (TableColumn primary : tablePrimaries) {\r\n                    if (primary.allowsImpliedChildren() && allPrimaries.put(primary, table) != null)\r\n                        ++duplicatePrimaries;\r\n                }\r\n            }\r\n            for (TableColumn column : table.getColumns()) {\r\n                if (!column.isForeignKey() && column.allowsImpliedParents())\r\n                    columnsWithoutParents.add(column);\r\n            }\r\n        }\r\n        // if more than half of the tables have the same primary key then\r\n        // it's most likely a database where primary key names aren't unique\r\n        // (e.g. they all have a primary key named 'ID')\r\n        if (// bizarre logic, but it does approximately what we need\r\n        duplicatePrimaries > allPrimaries.size())\r\n            return new ArrayList<ImpliedForeignKeyConstraint>();\r\n        sortColumnsByTable(columnsWithoutParents);\r\n        List<ImpliedForeignKeyConstraint> impliedConstraints = new ArrayList<ImpliedForeignKeyConstraint>();\r\n        for (TableColumn childColumn : columnsWithoutParents) {\r\n            Table primaryTable = allPrimaries.get(childColumn);\r\n            if (primaryTable != null && primaryTable != childColumn.getTable()) {\r\n                TableColumn parentColumn = primaryTable.getColumn(childColumn.getName());\r\n                // make sure the potential child->parent relationships isn't already a\r\n                // parent->child relationship\r\n                if (parentColumn.getParentConstraint(childColumn) == null) {\r\n                    // ok, we've found a potential relationship with a column matches a primary\r\n                    // key column in another table and isn't already related to that column\r\n                    impliedConstraints.add(new ImpliedForeignKeyConstraint(parentColumn, childColumn));\r\n                }\r\n            }\r\n        }\r\n        return impliedConstraints;\r\n    }\r\n\r\n    /**\r\n     * Ruby on Rails-based databases typically have no real referential integrity\r\n     * constraints.  Instead they have a somewhat unusual way of associating\r\n     * columns to primary keys.<p>\r\n     *\r\n     * Basically all tables have a primary key named <code>ID</code>.\r\n     * All tables are named plural names.\r\n     * The columns that logically reference that <code>ID</code> are the singular\r\n     * form of the table name suffixed with <code>_ID</code>.<p>\r\n     *\r\n     * A side-effect of calling this method is that the returned collection of\r\n     * constraints will be \"tied into\" the associated tables.\r\n     *\r\n     * @param tables\r\n     * @return List of {@link RailsForeignKeyConstraint}s\r\n     */\r\n    public static List<RailsForeignKeyConstraint> getRailsConstraints(Map<String, Table> tables) {\r\n        List<RailsForeignKeyConstraint> railsConstraints = new ArrayList<RailsForeignKeyConstraint>(tables.size());\r\n        // iterate thru each column in each table looking for columns that\r\n        // match Rails naming conventions\r\n        for (Table table : tables.values()) {\r\n            for (TableColumn column : table.getColumns()) {\r\n                String columnName = column.getName().toLowerCase();\r\n                if (!column.isForeignKey() && column.allowsImpliedParents() && columnName.endsWith(\"_id\")) {\r\n                    String singular = columnName.substring(0, columnName.length() - 3);\r\n                    String primaryTableName = Inflection.pluralize(singular);\r\n                    Table primaryTable = tables.get(primaryTableName);\r\n                    if (primaryTable != null) {\r\n                        TableColumn primaryColumn = primaryTable.getColumn(\"ID\");\r\n                        if (primaryColumn != null) {\r\n                            railsConstraints.add(new RailsForeignKeyConstraint(primaryColumn, column));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return railsConstraints;\r\n    }\r\n\r\n    /**\r\n     * Returns a <code>List</code> of all of the <code>ForeignKeyConstraint</code>s\r\n     * used by the specified tables.\r\n     *\r\n     * @param tables Collection\r\n     * @return List\r\n     */\r\n    public static List<ForeignKeyConstraint> getForeignKeyConstraints(Collection<Table> tables) {\r\n        List<ForeignKeyConstraint> constraints = new ArrayList<ForeignKeyConstraint>();\r\n        for (Table table : tables) {\r\n            constraints.addAll(table.getForeignKeys());\r\n        }\r\n        return constraints;\r\n    }\r\n\r\n    public static List<Table> getOrphans(Collection<Table> tables) {\r\n        List<Table> orphans = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.isOrphan(false)) {\r\n                orphans.add(table);\r\n            }\r\n        }\r\n        return sortTablesByName(orphans);\r\n    }\r\n\r\n    /**\r\n     * Return a list of <code>TableColumn</code>s that are both nullable\r\n     * and have an index that specifies that they must be unique (a rather strange combo).\r\n     */\r\n    public static List<TableColumn> getMustBeUniqueNullableColumns(Collection<Table> tables) {\r\n        List<TableColumn> uniqueNullables = new ArrayList<TableColumn>();\r\n        for (Table table : tables) {\r\n            for (TableIndex index : table.getIndexes()) {\r\n                if (index.isUniqueNullable()) {\r\n                    uniqueNullables.addAll(index.getColumns());\r\n                }\r\n            }\r\n        }\r\n        return sortColumnsByTable(uniqueNullables);\r\n    }\r\n\r\n    /**\r\n     * Return a list of <code>Table</code>s that have neither an index nor a primary key.\r\n     */\r\n    public static List<Table> getTablesWithoutIndexes(Collection<Table> tables) {\r\n        List<Table> withoutIndexes = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.getIndexes().size() == 0 && !table.isView() && !table.isLogical())\r\n                withoutIndexes.add(table);\r\n        }\r\n        return sortTablesByName(withoutIndexes);\r\n    }\r\n\r\n    public static List<Table> getTablesWithIncrementingColumnNames(Collection<Table> tables) {\r\n        List<Table> denormalizedTables = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            Map<String, Long> columnPrefixes = new HashMap<String, Long>();\r\n            for (TableColumn column : table.getColumns()) {\r\n                // search for columns that start with the same prefix\r\n                // and end in an incrementing number\r\n                String columnName = column.getName();\r\n                String numbers = null;\r\n                for (int i = columnName.length() - 1; i > 0; --i) {\r\n                    if (Character.isDigit(columnName.charAt(i))) {\r\n                        numbers = String.valueOf(columnName.charAt(i)) + (numbers == null ? \"\" : numbers);\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n                // attempt to detect where they had an existing column\r\n                // and added a \"column2\" type of column (we'll call this one \"1\")\r\n                if (numbers == null) {\r\n                    numbers = \"1\";\r\n                    columnName = columnName + numbers;\r\n                }\r\n                // see if we've already found a column with the same prefix\r\n                // that had a numeric suffix +/- 1.\r\n                String prefix = columnName.substring(0, columnName.length() - numbers.length());\r\n                long numeric = Long.parseLong(numbers);\r\n                Long existing = columnPrefixes.get(prefix);\r\n                if (existing != null && Math.abs(existing.longValue() - numeric) == 1) {\r\n                    // found one so add it to our list and stop evaluating this table\r\n                    denormalizedTables.add(table);\r\n                    break;\r\n                }\r\n                columnPrefixes.put(prefix, new Long(numeric));\r\n            }\r\n        }\r\n        return sortTablesByName(denormalizedTables);\r\n    }\r\n\r\n    public static List<Table> getTablesWithOneColumn(Collection<Table> tables) {\r\n        List<Table> singleColumnTables = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.getColumns().size() == 1)\r\n                singleColumnTables.add(table);\r\n        }\r\n        return sortTablesByName(singleColumnTables);\r\n    }\r\n\r\n    public static List<Table> sortTablesByName(List<Table> tables) {\r\n        Collections.sort(tables, new Comparator<Table>() {\r\n\r\n            public int compare(Table table1, Table table2) {\r\n                return table1.compareTo(table2);\r\n            }\r\n        });\r\n        return tables;\r\n    }\r\n\r\n    public static List<TableColumn> sortColumnsByTable(List<TableColumn> columns) {\r\n        Collections.sort(columns, new Comparator<TableColumn>() {\r\n\r\n            public int compare(TableColumn column1, TableColumn column2) {\r\n                int rc = column1.getTable().compareTo(column2.getTable());\r\n                if (rc == 0)\r\n                    rc = column1.getName().compareToIgnoreCase(column2.getName());\r\n                return rc;\r\n            }\r\n        });\r\n        return columns;\r\n    }\r\n\r\n    /**\r\n     * Returns a list of columns that have the word \"NULL\" or \"null\" as their default value\r\n     * instead of the likely candidate value null.\r\n     *\r\n     * @param tables Collection\r\n     * @return List\r\n     */\r\n    public static List<TableColumn> getDefaultNullStringColumns(Collection<Table> tables) {\r\n        List<TableColumn> defaultNullStringColumns = new ArrayList<TableColumn>();\r\n        for (Table table : tables) {\r\n            for (TableColumn column : table.getColumns()) {\r\n                Object defaultValue = column.getDefaultValue();\r\n                if (defaultValue != null && defaultValue instanceof String) {\r\n                    String defaultString = defaultValue.toString();\r\n                    if (defaultString.trim().equalsIgnoreCase(\"'null'\")) {\r\n                        defaultNullStringColumns.add(column);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return sortColumnsByTable(defaultNullStringColumns);\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of catalog names (Strings)\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getCatalogs(DatabaseMetaData meta) throws SQLException {\r\n        List<String> catalogs = new ArrayList<String>();\r\n        ResultSet rs = meta.getCatalogs();\r\n        while (rs.next()) {\r\n            catalogs.add(rs.getString(\"TABLE_CAT\"));\r\n        }\r\n        rs.close();\r\n        return catalogs;\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings)\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getSchemas(DatabaseMetaData meta) throws SQLException {\r\n        List<String> schemas = new ArrayList<String>();\r\n        ResultSet rs = meta.getSchemas();\r\n        while (rs.next()) {\r\n            schemas.add(rs.getString(\"TABLE_SCHEM\"));\r\n        }\r\n        rs.close();\r\n        return schemas;\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings) that contain tables\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getPopulatedSchemas(DatabaseMetaData meta) throws SQLException {\r\n        return getPopulatedSchemas(meta, \".*\", false);\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings) that contain tables and\r\n     * match the <code>schemaSpec</code> regular expression\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getPopulatedSchemas(DatabaseMetaData meta, String schemaSpec, boolean isCatalog) throws SQLException {\r\n        // alpha sorted\r\n        Set<String> schemas = new TreeSet<String>();\r\n        Pattern schemaRegex = Pattern.compile(schemaSpec);\r\n        Logger logger = Logger.getLogger(DbAnalyzer.class.getName());\r\n        boolean logging = logger.isLoggable(Level.FINE);\r\n        for (String schema : (isCatalog ? getCatalogs(meta) : getSchemas(meta))) {\r\n            if (schemaRegex.matcher(schema).matches()) {\r\n                ResultSet rs = null;\r\n                try {\r\n                    rs = meta.getTables(null, schema, \"%\", null);\r\n                    if (rs.next()) {\r\n                        if (logging)\r\n                            logger.fine(\"Including schema \" + schema + \": matches + \\\"\" + schemaRegex + \"\\\" and contains tables\");\r\n                        schemas.add(schema);\r\n                    } else {\r\n                        if (logging)\r\n                            logger.fine(\"Excluding schema \" + schema + \": matches \\\"\" + schemaRegex + \"\\\" but contains no tables\");\r\n                    }\r\n                } catch (SQLException ignore) {\r\n                } finally {\r\n                    if (rs != null)\r\n                        rs.close();\r\n                }\r\n            } else {\r\n                if (logging)\r\n                    logger.fine(\"Excluding schema \" + schema + \": doesn't match \\\"\" + schemaRegex + '\"');\r\n            }\r\n        }\r\n        return new ArrayList<String>(schemas);\r\n    }\r\n\r\n    /**\r\n     * For debugging/analyzing result sets\r\n     * @param rs ResultSet\r\n     * @throws SQLException\r\n     */\r\n    public static void dumpResultSetRow(ResultSet rs, String description) throws SQLException {\r\n        ResultSetMetaData meta = rs.getMetaData();\r\n        int numColumns = meta.getColumnCount();\r\n        System.out.println(numColumns + \" columns of \" + description + \":\");\r\n        for (int i = 1; i <= numColumns; ++i) {\r\n            System.out.print(meta.getColumnLabel(i));\r\n            System.out.print(\": \");\r\n            System.out.print(String.valueOf(rs.getString(i)));\r\n            System.out.print(\"\\t\");\r\n        }\r\n        System.out.println();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/DbAnalyzerTest13.java",
		"test_prompt": "// DbAnalyzerTest13.java\npackage net.sourceforge.schemaspy;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.model.TableIndex;\nimport net.sourceforge.schemaspy.util.Inflection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DbAnalyzer}.\n* It contains ten unit test cases for the {@link DbAnalyzer#getPopulatedSchemas(DatabaseMetaData)} method.\n*/\nclass DbAnalyzerTest13 {"
	},
	{
		"original_code": "// DbAnalyzer.java\n/*\r\n * This file is a part of the SchemaSpy project (http://schemaspy.sourceforge.net).\r\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\r\n *\r\n * SchemaSpy is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n * SchemaSpy is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage net.sourceforge.schemaspy;\r\n\r\nimport java.sql.DatabaseMetaData;\r\nimport java.sql.ResultSet;\r\nimport java.sql.ResultSetMetaData;\r\nimport java.sql.SQLException;\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.Collections;\r\nimport java.util.Comparator;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\nimport java.util.TreeMap;\r\nimport java.util.TreeSet;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.regex.Pattern;\r\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;\r\nimport net.sourceforge.schemaspy.model.Table;\r\nimport net.sourceforge.schemaspy.model.TableColumn;\r\nimport net.sourceforge.schemaspy.model.TableIndex;\r\nimport net.sourceforge.schemaspy.util.Inflection;\r\n\r\npublic class DbAnalyzer {\r\n\r\n    public static List<ImpliedForeignKeyConstraint> getImpliedConstraints(Collection<Table> tables) {\r\n        List<TableColumn> columnsWithoutParents = new ArrayList<TableColumn>();\r\n        Map<TableColumn, Table> allPrimaries = new TreeMap<TableColumn, Table>(new Comparator<TableColumn>() {\r\n\r\n            public int compare(TableColumn column1, TableColumn column2) {\r\n                int rc = column1.getName().compareToIgnoreCase(column2.getName());\r\n                if (rc == 0)\r\n                    rc = column1.getType().compareToIgnoreCase(column2.getType());\r\n                if (rc == 0)\r\n                    rc = column1.getLength() - column2.getLength();\r\n                return rc;\r\n            }\r\n        });\r\n        int duplicatePrimaries = 0;\r\n        // gather all the primary key columns and columns without parents\r\n        for (Table table : tables) {\r\n            List<TableColumn> tablePrimaries = table.getPrimaryColumns();\r\n            if (tablePrimaries.size() == 1) {\r\n                // can't match up multiples...yet...\r\n                for (TableColumn primary : tablePrimaries) {\r\n                    if (primary.allowsImpliedChildren() && allPrimaries.put(primary, table) != null)\r\n                        ++duplicatePrimaries;\r\n                }\r\n            }\r\n            for (TableColumn column : table.getColumns()) {\r\n                if (!column.isForeignKey() && column.allowsImpliedParents())\r\n                    columnsWithoutParents.add(column);\r\n            }\r\n        }\r\n        // if more than half of the tables have the same primary key then\r\n        // it's most likely a database where primary key names aren't unique\r\n        // (e.g. they all have a primary key named 'ID')\r\n        if (// bizarre logic, but it does approximately what we need\r\n        duplicatePrimaries > allPrimaries.size())\r\n            return new ArrayList<ImpliedForeignKeyConstraint>();\r\n        sortColumnsByTable(columnsWithoutParents);\r\n        List<ImpliedForeignKeyConstraint> impliedConstraints = new ArrayList<ImpliedForeignKeyConstraint>();\r\n        for (TableColumn childColumn : columnsWithoutParents) {\r\n            Table primaryTable = allPrimaries.get(childColumn);\r\n            if (primaryTable != null && primaryTable != childColumn.getTable()) {\r\n                TableColumn parentColumn = primaryTable.getColumn(childColumn.getName());\r\n                // make sure the potential child->parent relationships isn't already a\r\n                // parent->child relationship\r\n                if (parentColumn.getParentConstraint(childColumn) == null) {\r\n                    // ok, we've found a potential relationship with a column matches a primary\r\n                    // key column in another table and isn't already related to that column\r\n                    impliedConstraints.add(new ImpliedForeignKeyConstraint(parentColumn, childColumn));\r\n                }\r\n            }\r\n        }\r\n        return impliedConstraints;\r\n    }\r\n\r\n    /**\r\n     * Ruby on Rails-based databases typically have no real referential integrity\r\n     * constraints.  Instead they have a somewhat unusual way of associating\r\n     * columns to primary keys.<p>\r\n     *\r\n     * Basically all tables have a primary key named <code>ID</code>.\r\n     * All tables are named plural names.\r\n     * The columns that logically reference that <code>ID</code> are the singular\r\n     * form of the table name suffixed with <code>_ID</code>.<p>\r\n     *\r\n     * A side-effect of calling this method is that the returned collection of\r\n     * constraints will be \"tied into\" the associated tables.\r\n     *\r\n     * @param tables\r\n     * @return List of {@link RailsForeignKeyConstraint}s\r\n     */\r\n    public static List<RailsForeignKeyConstraint> getRailsConstraints(Map<String, Table> tables) {\r\n        List<RailsForeignKeyConstraint> railsConstraints = new ArrayList<RailsForeignKeyConstraint>(tables.size());\r\n        // iterate thru each column in each table looking for columns that\r\n        // match Rails naming conventions\r\n        for (Table table : tables.values()) {\r\n            for (TableColumn column : table.getColumns()) {\r\n                String columnName = column.getName().toLowerCase();\r\n                if (!column.isForeignKey() && column.allowsImpliedParents() && columnName.endsWith(\"_id\")) {\r\n                    String singular = columnName.substring(0, columnName.length() - 3);\r\n                    String primaryTableName = Inflection.pluralize(singular);\r\n                    Table primaryTable = tables.get(primaryTableName);\r\n                    if (primaryTable != null) {\r\n                        TableColumn primaryColumn = primaryTable.getColumn(\"ID\");\r\n                        if (primaryColumn != null) {\r\n                            railsConstraints.add(new RailsForeignKeyConstraint(primaryColumn, column));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return railsConstraints;\r\n    }\r\n\r\n    /**\r\n     * Returns a <code>List</code> of all of the <code>ForeignKeyConstraint</code>s\r\n     * used by the specified tables.\r\n     *\r\n     * @param tables Collection\r\n     * @return List\r\n     */\r\n    public static List<ForeignKeyConstraint> getForeignKeyConstraints(Collection<Table> tables) {\r\n        List<ForeignKeyConstraint> constraints = new ArrayList<ForeignKeyConstraint>();\r\n        for (Table table : tables) {\r\n            constraints.addAll(table.getForeignKeys());\r\n        }\r\n        return constraints;\r\n    }\r\n\r\n    public static List<Table> getOrphans(Collection<Table> tables) {\r\n        List<Table> orphans = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.isOrphan(false)) {\r\n                orphans.add(table);\r\n            }\r\n        }\r\n        return sortTablesByName(orphans);\r\n    }\r\n\r\n    /**\r\n     * Return a list of <code>TableColumn</code>s that are both nullable\r\n     * and have an index that specifies that they must be unique (a rather strange combo).\r\n     */\r\n    public static List<TableColumn> getMustBeUniqueNullableColumns(Collection<Table> tables) {\r\n        List<TableColumn> uniqueNullables = new ArrayList<TableColumn>();\r\n        for (Table table : tables) {\r\n            for (TableIndex index : table.getIndexes()) {\r\n                if (index.isUniqueNullable()) {\r\n                    uniqueNullables.addAll(index.getColumns());\r\n                }\r\n            }\r\n        }\r\n        return sortColumnsByTable(uniqueNullables);\r\n    }\r\n\r\n    /**\r\n     * Return a list of <code>Table</code>s that have neither an index nor a primary key.\r\n     */\r\n    public static List<Table> getTablesWithoutIndexes(Collection<Table> tables) {\r\n        List<Table> withoutIndexes = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.getIndexes().size() == 0 && !table.isView() && !table.isLogical())\r\n                withoutIndexes.add(table);\r\n        }\r\n        return sortTablesByName(withoutIndexes);\r\n    }\r\n\r\n    public static List<Table> getTablesWithIncrementingColumnNames(Collection<Table> tables) {\r\n        List<Table> denormalizedTables = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            Map<String, Long> columnPrefixes = new HashMap<String, Long>();\r\n            for (TableColumn column : table.getColumns()) {\r\n                // search for columns that start with the same prefix\r\n                // and end in an incrementing number\r\n                String columnName = column.getName();\r\n                String numbers = null;\r\n                for (int i = columnName.length() - 1; i > 0; --i) {\r\n                    if (Character.isDigit(columnName.charAt(i))) {\r\n                        numbers = String.valueOf(columnName.charAt(i)) + (numbers == null ? \"\" : numbers);\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n                // attempt to detect where they had an existing column\r\n                // and added a \"column2\" type of column (we'll call this one \"1\")\r\n                if (numbers == null) {\r\n                    numbers = \"1\";\r\n                    columnName = columnName + numbers;\r\n                }\r\n                // see if we've already found a column with the same prefix\r\n                // that had a numeric suffix +/- 1.\r\n                String prefix = columnName.substring(0, columnName.length() - numbers.length());\r\n                long numeric = Long.parseLong(numbers);\r\n                Long existing = columnPrefixes.get(prefix);\r\n                if (existing != null && Math.abs(existing.longValue() - numeric) == 1) {\r\n                    // found one so add it to our list and stop evaluating this table\r\n                    denormalizedTables.add(table);\r\n                    break;\r\n                }\r\n                columnPrefixes.put(prefix, new Long(numeric));\r\n            }\r\n        }\r\n        return sortTablesByName(denormalizedTables);\r\n    }\r\n\r\n    public static List<Table> getTablesWithOneColumn(Collection<Table> tables) {\r\n        List<Table> singleColumnTables = new ArrayList<Table>();\r\n        for (Table table : tables) {\r\n            if (table.getColumns().size() == 1)\r\n                singleColumnTables.add(table);\r\n        }\r\n        return sortTablesByName(singleColumnTables);\r\n    }\r\n\r\n    public static List<Table> sortTablesByName(List<Table> tables) {\r\n        Collections.sort(tables, new Comparator<Table>() {\r\n\r\n            public int compare(Table table1, Table table2) {\r\n                return table1.compareTo(table2);\r\n            }\r\n        });\r\n        return tables;\r\n    }\r\n\r\n    public static List<TableColumn> sortColumnsByTable(List<TableColumn> columns) {\r\n        Collections.sort(columns, new Comparator<TableColumn>() {\r\n\r\n            public int compare(TableColumn column1, TableColumn column2) {\r\n                int rc = column1.getTable().compareTo(column2.getTable());\r\n                if (rc == 0)\r\n                    rc = column1.getName().compareToIgnoreCase(column2.getName());\r\n                return rc;\r\n            }\r\n        });\r\n        return columns;\r\n    }\r\n\r\n    /**\r\n     * Returns a list of columns that have the word \"NULL\" or \"null\" as their default value\r\n     * instead of the likely candidate value null.\r\n     *\r\n     * @param tables Collection\r\n     * @return List\r\n     */\r\n    public static List<TableColumn> getDefaultNullStringColumns(Collection<Table> tables) {\r\n        List<TableColumn> defaultNullStringColumns = new ArrayList<TableColumn>();\r\n        for (Table table : tables) {\r\n            for (TableColumn column : table.getColumns()) {\r\n                Object defaultValue = column.getDefaultValue();\r\n                if (defaultValue != null && defaultValue instanceof String) {\r\n                    String defaultString = defaultValue.toString();\r\n                    if (defaultString.trim().equalsIgnoreCase(\"'null'\")) {\r\n                        defaultNullStringColumns.add(column);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return sortColumnsByTable(defaultNullStringColumns);\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of catalog names (Strings)\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getCatalogs(DatabaseMetaData meta) throws SQLException {\r\n        List<String> catalogs = new ArrayList<String>();\r\n        ResultSet rs = meta.getCatalogs();\r\n        while (rs.next()) {\r\n            catalogs.add(rs.getString(\"TABLE_CAT\"));\r\n        }\r\n        rs.close();\r\n        return catalogs;\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings)\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getSchemas(DatabaseMetaData meta) throws SQLException {\r\n        List<String> schemas = new ArrayList<String>();\r\n        ResultSet rs = meta.getSchemas();\r\n        while (rs.next()) {\r\n            schemas.add(rs.getString(\"TABLE_SCHEM\"));\r\n        }\r\n        rs.close();\r\n        return schemas;\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings) that contain tables\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getPopulatedSchemas(DatabaseMetaData meta) throws SQLException {\r\n        return getPopulatedSchemas(meta, \".*\", false);\r\n    }\r\n\r\n    /**\r\n     * getSchemas - returns a List of schema names (Strings) that contain tables and\r\n     * match the <code>schemaSpec</code> regular expression\r\n     *\r\n     * @param meta DatabaseMetaData\r\n     */\r\n    public static List<String> getPopulatedSchemas(DatabaseMetaData meta, String schemaSpec, boolean isCatalog) throws SQLException {\r\n        // alpha sorted\r\n        Set<String> schemas = new TreeSet<String>();\r\n        Pattern schemaRegex = Pattern.compile(schemaSpec);\r\n        Logger logger = Logger.getLogger(DbAnalyzer.class.getName());\r\n        boolean logging = logger.isLoggable(Level.FINE);\r\n        for (String schema : (isCatalog ? getCatalogs(meta) : getSchemas(meta))) {\r\n            if (schemaRegex.matcher(schema).matches()) {\r\n                ResultSet rs = null;\r\n                try {\r\n                    rs = meta.getTables(null, schema, \"%\", null);\r\n                    if (rs.next()) {\r\n                        if (logging)\r\n                            logger.fine(\"Including schema \" + schema + \": matches + \\\"\" + schemaRegex + \"\\\" and contains tables\");\r\n                        schemas.add(schema);\r\n                    } else {\r\n                        if (logging)\r\n                            logger.fine(\"Excluding schema \" + schema + \": matches \\\"\" + schemaRegex + \"\\\" but contains no tables\");\r\n                    }\r\n                } catch (SQLException ignore) {\r\n                } finally {\r\n                    if (rs != null)\r\n                        rs.close();\r\n                }\r\n            } else {\r\n                if (logging)\r\n                    logger.fine(\"Excluding schema \" + schema + \": doesn't match \\\"\" + schemaRegex + '\"');\r\n            }\r\n        }\r\n        return new ArrayList<String>(schemas);\r\n    }\r\n\r\n    /**\r\n     * For debugging/analyzing result sets\r\n     * @param rs ResultSet\r\n     * @throws SQLException\r\n     */\r\n    public static void dumpResultSetRow(ResultSet rs, String description) throws SQLException {\r\n        ResultSetMetaData meta = rs.getMetaData();\r\n        int numColumns = meta.getColumnCount();\r\n        System.out.println(numColumns + \" columns of \" + description + \":\");\r\n        for (int i = 1; i <= numColumns; ++i) {\r\n            System.out.print(meta.getColumnLabel(i));\r\n            System.out.print(\": \");\r\n            System.out.print(String.valueOf(rs.getString(i)));\r\n            System.out.print(\"\\t\");\r\n        }\r\n        System.out.println();\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/36_schemaspy/src/main/java/net/sourceforge/schemaspy/DbAnalyzerTest14.java",
		"test_prompt": "// DbAnalyzerTest14.java\npackage net.sourceforge.schemaspy;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport net.sourceforge.schemaspy.model.ForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.ImpliedForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.RailsForeignKeyConstraint;\nimport net.sourceforge.schemaspy.model.Table;\nimport net.sourceforge.schemaspy.model.TableColumn;\nimport net.sourceforge.schemaspy.model.TableIndex;\nimport net.sourceforge.schemaspy.util.Inflection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DbAnalyzer}.\n* It contains ten unit test cases for the {@link DbAnalyzer#getPopulatedSchemas(DatabaseMetaData, String, boolean)} method.\n*/\nclass DbAnalyzerTest14 {"
	}
]